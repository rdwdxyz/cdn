<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b74a8f13013bf28201b998337394f9edba94b619ebffe680591b034316e27d29366c331cb32e30a950697806b8291b8210eaeb0c068e3f4d7c6209601bef81f31eda7741a1c3f36b103f834f9b055c0fa2eb132d22fbe8c0154c732f52e7cdbf0f7c586f240316d8ca5e681095f4a2bc6da6acac609aa020d2f034ae1a16700b6e725156a527109f7b4af9f558dfd902b1bbd5c996308261e101ea949afdc7b3e7387c085d036f5619fb961c2d8cfb866884ea37a7eb0f6f5b69f81027b806ffe763f786513e46b6f8e43610f4b14bece51984875a622ed6eb6db4d8e4760fb4755ea12b448f03a48bea16ea479c9804fdff861a2d10afc7ab26416de9ccc253bba147a44e315ebca7904ff9a15c6991656c750161cb83546d92a692e602923caa7b0e1fb8a3d8b251b5e4384091f2bf8e246365a0ef73a4864fbf96e508a4a43d97be0ad33475741c71cd111fd2eb3f526ae5ded5cd6a0198b202e83695acbaed194bb44bdc189fb1c54b7a74e2b733caf49d76bd56472738a9b894c629594e20fe3c05b2cebb46101e158a6759c88a1f2504d85ac742b29ea7a1c4ab3d51a7dc1af35409012e3163a925470519b06eebf4969fc4c97d071b0cda2d74f84a0d748dca07c0a4967d98853df68b6c67ff222b2850145131df06990e827da0445f00810d47d6915d26241497c09047300becbf4ee24dcc6d1fe9466eef37e21ab88cbc48f2e576d1a7e0207d77ea245bc845a9cc6261d74b50de04bee390ef31d265a97fe206986ea667232df1e4869e97f419e7142aa1e8590210fcee7d533c85c3ebc755728a5693b45bbf5e73212647cf1b6cfd0d9932b926a7cea66dc0a144ed3453af4f1d4c096023cba00d45527a72f3eed434bbda5159cc867e4a16178036c69bb95b8b17ee7712dc9483bf8f5ac8792e30e793573cb0e2a3fe8f671c72ea60116ba91ab710761d1899e619f9150fde40989518e9df4ccae9bbec08e53af0b700c44ebf1cbe8f7f8b0317983ee4f6aae8e15756b5bb5d7f172d65f62cabf1b37470d4451e0e4e798c5bbe63daed46fd8ce15278155622e63f26d7e87f60dd02e4864aeb8d0bd2b9c56a532fe48644d956795286d005265c16015a2f60d6ae4b7c05b3f26a760d8a4309a0a883833f27b9c458d40d6017856277d616c65b620906955f8095c10d6c1e569f8b68a446a3172f4d4a22118128ad05210920547399172a4930fc99071c803b23729931c2753bf2c30cc0641af69fdb314341515ad277f779ef861e6f350bf72240ccbe34c3f4ae58124c0f40f55c8f07a719cbf8c72e50cc0f4c76a915b4d0aded2e7467edfbe215ba11bbb8cab88e32c762f607c4be3993f1af11a09318d99df4622ce94173cda5024fd6082e3472ca5727e1d7cf4bf9962e3e4b3e23f327a30e9e611b6281cc9dfaca7e39ac307e04bae973519e0923434e96f8056191b87c14f8e416a339a7146df2fbc8b380b535ba291e2b1fb3f0ea1dd2730b2b9202a90d3cb5b2381b05b14099aab5a68f0bed170f641580d8d5a1d92b2df0d5f0727ab70ddfe121a76fc85e89eba9ad190b2839bf809c315dd86fa1e75470a8acca15ea6cc09f4497d8c11c2e12ff5a8e2e669402c03c8f78a9a70dfb40eb7531727b04d0ecdfe484424f181d72b84ef341b3aa60ebf3dcc9eee45235df08ed43b6daf67faea594fe42a05dd323bdb4d2840723156490a7684dc50e2e65f530590e0aefc232e148c1f1173676c3630cba9bd07ea8b07d4724466df1564186994e923ba7012416c4dc189baa878df708353086abf3529e97ed6193b34ee1733b59621519e88f36b3a4f2b362b4e417f5c6daf6999039f3fc757918fdc0e6479db30839c668a975e04d4f9d62a8cdb5b00b5fd53f6159ac6ab686c1b1cd136877cc6540e69973f08f0fc9cbb7a78ecdbd1c8e7c7cdd48fbee07543857996f5d3998fa9ea9acf27f00c39ad2d3e2c5b6b8c9af5702d0ba95647a3d856a18680f6bf6215923edfc9d638719bf7ed744cd4901da55459ab6caa7f88410e3e881eebe94fc3574f37390796e510afeddd2980a5124f4fe830b41cdfd309314452cd06eabb26e7334af7d81a14b870ac87a6e5c91227924aae4300971955f02a18d71a0473192108240bfdf36a6df05356f915828fe5f5e6e5071a38da8258af6b3a738e549fca7d5268108b6bccf86677eb4a0cbfe87d6b4f2b9740b24f9d9004346d104055a74c0d5cbacc66bac768135ff6e6b856bf77d471daf1e37709dd8c9bbff72c814fe14b096b393686da89082a698debd332876089bf70dfa372d4fd3aa3ec9a54bf81b09c66e8439562536f5e1055bbb1617359699f1d1d1103fbdde1ece60d3825e1108c43c6d37038bb6d7a81b16db5e897719f00bd5796744aaed9d9cf87ea16d2ea0a50dc550bb7a4c73ec12d89c939f79d7364b19afc4bbef7dcf3b4e93bc43706349041466bb2176f853cfcee5c64afa2f2afe15144144c2f5cc253438cf2cabc9b507ee351906536a5a78ce2e3319bf251579a2c0b2bd8cb980a1c8a14cbfabf3238dc4e9e1bb5f223ab82638affe548846cf9b150e66a4b5e4c516a2752a879f1c62f771cbf7ab3954a33df12b90561f95e455dffb3b095d8648340187ed42b018a3edac6819f2b157a5e22d7de6d4dc7cb94df19e5d0b9033f53d978fa86878399de0cd4008450dfa2d754fce78416b821edcb15174ade2eb7b808903e1829b49f9dc85089b88dcdaf2bac49684e97d6ced613f6d0cd8d3f63a75535caf4230e37c6f6caadc4fe9b52d66b60ae14887a7df5650f4bc8dd36e9c1a9750339d064165d01d236116471efda8d7c054a1c0c17618a539e1d6ef26f664e01d7c48edfe19bda6503f759e4218efa2c08c99f7922bbcee74c53b903265131f0d9bd3aec923952f74ff1b8ba76907bfe435c6c2ad200b3eb9bf9e3321da56e000b3c3ba9cdc55ba1929fe5fc068d30e2165233966059c96eae065dc17e74c749d6bbe86d37367cac97dfbc5b6c7bea40b623e929f1c6fb92103cd94d41055732f744b35d9f5e35360fcaf510422e92972baee9235805d19517e2cc6a6a834dab3341459a31a356333a9975ad7ef5e9acad1e9ff7d477837cf6980d6249a69ba0a004a228a7726033cb5cfe77d18a3b6295a83f767bc7d9ca4e256dbe381c21c99c1fb62e3c6fa2a3cc879dd3ee11dbe642932c9d882be4420b799cf675ebd58177860f562c2e7f47943218c4de8982b75c2ab3c52a2e96f49b0a1b60f92e2790b041c9b98c42ff4558dec3f1edeb9178845c17ca661c375790cd35c148a5a13460c83aeb266d82b7e8f1c69993dc966a5f4ff46d721577ce4bf939603d40945edb867e64536de0307ca5fd2f406f7e456767361a531ec1619b6fbd59e0c21ddb96bfcf09a30040762516be5dd2d7c116ada0bb4e582b7acd44f232be53339dde3e7b313c3fbda2435c15b24f9b5506275c97720bb7abe74fdef9217ba995454f4408396e8721a4b0754b40700957c251adbd0bf843b248b5d7b02abf88c08ab69ead1d18e1e834a6892145b538ec9ab3cdca8dc822ad1738e8fb182cc302a92122e9963c450a50a2380f651559d9813116807b4214fd34ad14f6a728a370b602ae60a335b9814c93ef1c0367ce0f8abf33081b68306a35a388aca09702ec28a304adc818ac21377f5b458f80985596289b7acf9ec801e4860330696bb0f7cbfc5c9b2bfa2c8c11d8f102ad9c9a19aada91851447a26f820dfaaea0e278339b81a08c7e57b26772e657c6bf51bf8289566f4d686f3e7c1671749fca3c3cc2a424a660ebd6038aafc14f9c761b03307dbad3fbed8a7b8db3d3947c2a1ec145ef4730ffe12d1c399c21cdbe7db4a0379c464122d0d7334737688d72693dfb2eedbd04f70a730709b6b15276aeebd35edb451fa3e7fdc3ea945751491af3978e96c50ec4b43a67869b7a354f03e4646c5ee14a2e2dd2ea180e391a7dc7466aee9388f3195ca47160fb45735f668aad81f83d32baf429bbb491a8ce56c3f4c9dfe5ddee4a777e0433a5059f6a5c869ce76ce2dc27f41eca2dd8c6bd3791d325a965087de591ea923873166d2948d134d65e978a99cea7141ee095abcafa70b3f24eb54512d31bbdb77bebf64cfb148e2ab69b91da941fed6fb5bbd0cc7cfed0967f6b27083fc900534ee73668d15afba1770f81080c285db3846371e6541056db806bcf192b9962511b1136a403ee0df2885e89c7855d3150a373b0de748c38ae0aba9d96256a7fcff1810ee76b4d51cde24db900c7b8c8c1324b9bb5187e72e6ddcc879d395d980b6494fa9426f2e2dc20ae0da9d53d75692ed106727130c1d3b0c00e574ac0f948b8a7b6c985a4165c81b86e3fb5d1712f005882b94e253639db892784e4b573943e53061e0681a0e2b9a781b4eec097035c5f14f546872c2c656fea9178bfb4a05a2f2ab5526eda85ab3719c656a3b8626238d2d042785f8ddfc0d632259f19768a6bcb8797690c1c635e4fa142dada860a57b9c4edbb1ca4866ee7706a3afce26a711728a58f972bb64555c25700dd839195fdb467412e65023c3132d2b5ec5bbc79c4e612593f1fa0b06e60bbf5725597b3581368e08054930b63ad1c38db6874e97cf27cf183da984f7ccbe1854c762cd9bd51eaa7bebd0112fbb528b44237fcd1ee245edb4cfb697077fc8a66c0c04b1ed484a7e66e9e306bc6e968f851aefbcb5c3c0813c593d1b9a25e7eb6879c9baa43e73ce50436e2f60f5ed19d8ce4cba715497ad47c1d18565adad92a492b5ad96f28dc2b86fec8e5df87cca1ba74c8bb17cc0ac4d392da42899181b01e2dfcf3f460326b8daca952d123eb2d2725c9a1e6d7a60f11e9479fe189d64daea383f57bec82175881625782816e957b6a33d417c3684b1c1d1f14343ab27b304b2f232bf981c7c5361e70bc023204e126c8799c551ae633f2d96e79c35e543e14ec99f3a167b5c7915c6d282261c86045a988832e497e45cbd356e58bd030a7bd7588cc7842cfea5e0a546f2d03202a5541fe43e4147d3d5e4e986df0d9a80473436d68fe88fa295472d504da2a35353a07ed74951438b8156f91cfe6a2a5975d6bb574fe56f3c3be36ba8b32ce0af395a29d43e69c69bb3f084aa243136fbd6a0997d3024f732d99808ee5b89cc7d89ae97c334daff1c788a8054ae139ab7e68e5dea9b22a7cd42dff86e30ca98defe3adc38bd03d1eabd9ca55972fbd3b20e9bf404d5f773fe75255a192095a13927e8637a411746da260b2f956c6dc1395dce0b6ad6456cd38b6ddd4a6529d55faad323942ea547a92e9d24755553a9cf209d56fa37334d3c697a78894466f8ba45c4c837f37ed183b8bc112e61dd08f8d73e27485da9cf13ce70e41e0678bf41bee23bad9c70812c76b8dad59a4e8bd268695b346587e51fef3a4eb00d67868e2f44aa8d2059b8a9dfc3f50f8ac4aaac27759dfc31e511992fe56e28515a02fec38be078d2c72f6355bf656e20452a9511e83a96594fbed9a17db156702928f7fb8f3223e10cde993de44f80df78bd2d61e8a5e41166ce3283da114599e57453067de4c601998115a6d90a7e2d5b57e445af729e2a0d9dda16f61406130c7618e0399b52aa2c7a851e2975ef388a0977fbbe8e7b252df0b1c5366cd4c779520d4c16dae37fdd4c1c67ed9f70a843915682f91d6705bd94d49d4e15bdc29d452b609b309007bbb280018fac8fe20e395240255f80bef1f6ee853daa40cc9ae0def6fea9e0445dac9ea4ddda18e6bda1904a3bfabf01d734eadab3a559c9e00b244b693f26f1add1bf73c454f235c0da96c42108086eb9a3cc97ed670c11bcdd649db38c1c1f1613902ce882da580acad8897e73186e3abbef9c50a4ee193bce88f7f344acb7650bcd9303117ff816db0e4eb6d2524011076ea23351b6dc1a20a31d6597e1038f47092f86872bc0eb928d5c6c8d39acc6764302aff30e487f59ade3eea3da242dfbd097fec85b9ef8b5149664c03f34fd1209777650c32a2958e4e63943f0b5b574c8e5b0001f031943c257ce7a2f1bf3c7c25f411fe2005c4b60f6f4b195095e5b7e12ac2dab35b1c6821be63d9a510383a55ce8a0600319d9b6dd45f31463b7f5975836d31f982d8978077de56a6970bdaca95bcc467e497671bd23ae6918cb49093088c19d685417654f2ebd5bf752ef5e78af829160ca33c384a005c286129fe6a2977c26bddc544e30bbb5731e2a4c2c1fa9b94baa126ae1499a91937bedd38713a3d87ceafeacba5cd3ed27c21b18e498281781a023a882c69dffb79f08a298f9a33b20ccebc5716b2422ee439b844de04472e8dc46eb71a889f5b0dbf0112be7aea10652e3c4e02964c13bd784addc82b43d605ffc233dd6705fbcb30dfd55d73d213741be1ac5ccf8ed1259acd71673062a9a23c98a136da17077b75144be4464ba22d8391e623c1b57e1001c8655b355a6128d86b9ed7eb08049eb51829aa5bc4b1b490cf7d47e01f28b3f05e2e8e464b765c5e7a6fe8fde2dfbe099504a2a0c9b5bbce6fd6c0ea79d726762c0b22c129ebec907d91b5a1c8b68346ec34fe82d046a6e54efea5fe792d68b12f805985f75fb643eee4e829320d9fcbc3badc2fd856098ef5fa7e47cc4a08bed37f5f9c212fc0e80a69e6666b0740e4b73cced318cc724669f7d6e7159f95188cf89481f22b030dd9383451c93f06d814b9e8bb4ec6d200f69f4bb8608c2fb5c8620ed6e4eef4e7f99d45da500d393c404f144b8ad8e8d586d9d64a1fbe702284acd67a0cc65226d8da3234b9c8305cebc00dd825e248759de0b7684cb574907314430bfa6c5a38a5568dc5e4bc1cb85ff17c394a1e49ec87da44056b6800e22a03d6dbd9177f6b2efec0b9aab47e8a0b6fbf8f379cfcd9643fba6ef166d75614ebfd8318ea3e9aa4af933fa8ccb814b64abdabeb38c4e7105a210d963addf269b8cc21bb41c86a43bedf640cb3fb4a56e114efa06664b20efd94f8ccaa26881131afb3f4ed65ad489a3eea6e3b726741a6b0c2cbe55fb596ede7cb8d815f4f339df2f17ab9f79f3f5f09267e60de1d9d26d3db8787ce84c1fe68462435d4434147cb92633f01d36d6d3da9034def18aa736835e57900bca4fc4da567d12c11f369e3d03e6f14e64ffd5eb81a7d958c31564880952517c066e24807fa568e4c9f101a53ab481a8f1ea59f3f9138a0126b204f28b1d717ca259dbcc75210aaf3d93a5e4c8e142f7e12330aa4580c61afb8ac2ed32b404784c46123056568e4d0dd67755ef9321d21d351840f9a81040ceb92293e78917fc1df11409b2ae5064f80a6f431a0b8f28ade08e35167a10e49d6f88ad7a625651ac314f9d6e64dcc0ff4fd683925d0f7516fccad90830f20b09114f3815b1caf423e9822fddab98457e73f688947087377aceb125d0f854ecca3f7ec34d30d2bb966f033a8f82cfad07c4056ce5909c6403833bd30e39152177c355e82931e1da56a82d32bcf6f51c89b83880cb8fda3c13f7f7b755a560701ca95b1fc1f8774e44773a339b0e1995e22aa88005dfdfbe6740862e425fcecb7ba6630b3fa17058b7f51dc221ae40c6b0d513464235554c2f5dd1d89083dda32a57226565e90a3e12ce45ff1632878e01bf8a15027c1d11195ed5f769f30d275432b78090235993a0183529c22a037026a118240d2ecb2be7c0c08824a673b02e4f655ab13a5b1ee3034b46470b528e9fefd817b03085a1d967592911a88ce3afad6bcf7b6d4c66b4568d51e867a0b6256ed8c5e84e59841f0f08e840e43aa679d359feaace61052b67a660b42b91553f8d29172c4fc8c5d9112c4dd22305a1c311a4717152f267439d6cb180825708324da678f1ce43a6f8e676a565deb679a593050ff448b7290b2c453bc5106b55a4c68f8da2a3ccd523349d736287e357e8bc762d103e8b08c2437ddba0c47ec18c8b5c08df69931b3d3929a732a14319360f4deb964a54cf970a09cc27074ebb370395b3a2f75236b8644923ca65112a65251aa294d00759712c4bcfd6281d5fb2b4daa1c5def0772b00f67d6d51aaf81dac2cfb9474a4918895c9c81d38c9d064d4b537a3435bcaeb1df8bc7ab2921b791fbdf0319c6160ce9c946c80010e2e8fc86b063eab9abf508eebdc3d147141eebff98073f118be161b442d2928f71fdd04f0ff15c3ab975a6b2ee8e4b6b02114e96c881c409f7b82b9d0fad27457dd2c75c395f7c385bf82d71a9f3241144658032039fde99d6cb8530b5c656afab41ec773e633fbd57e04791481d3504d5aa5358981eda7f23bfef6b25fed8f3fab2c9759735797e9c563f575e91bf051517e509820b1878817f1b41f94722e1bb3e372a3955ca494b8decd1220663d09097f7b8608d182fd69095a198017f36f853f7eb46b906f85b4a0dcd850b624f09e96e81bd66b06e4e957a111f5ad498b2c99fdc90dc716da6f423083812c181bc9389ffd7c117ccadb6d3cebcfeeee576d7a2c32bf4ac129711f240cfdb4987f282bf6ab57a3e54f81fe5d7138ffd05f0464eb043abbb5ee676a180f220658c2c7b25db85b73fb0f07d83b846a774bd021fe2ecfbeacaa312c624c45b40d927e14ad33f6b564fa5661ca44bf24293afffb0c7362444f9f5ec1d19f5f2f8b64d8777ed79f936193e5314d513d25ef1fc58a20007a3c738606d4e4f5555a23bfc56599b5f55c7c1b9c1336aa717ea179832dbabfb9c433d83f6d70d6697d7d05902decdc543a9770365c7e1472374c5c30b1a0916ae3abfbc2d59f0b74253a505f1025821ff7ebb89253596e760612176f753445da44835bb7b4b8d3fb75370d5f9f1fb2567c414fa523994cb1dd8bcbab32bfab8cd21e3ed79d205f98e7cb3fe071ec47c3431c8c0e5617fa1683ff980331682a570d0c0481adc95b837eea2cc14f3f63a7cd7a8e4ed41c491935aa54b064f1d707b754ec1f31d49644eff0266eeb02fdf5d6cbd64209082f81ea5e25a9592044838011c9274f75763be000741f8d30afaf18e470377f21e2a4c6a1d3fa580998b2ce13882ab9ce15dcb7efba79b671fa17bac74975b4144027b86c37deb343a67cacd6506aae7ee25c8183e9566cdcd93419f714ca4519bee1ed39194cbabca534c507ce84cc9f324352125773360256a5d53b92a11cea1dc23c1601997fb07397801f28b108091c4f77ceb3a2f5347340790525f7938726ed86817c307f2c13244fda48b4917c4be041d6174ee9e0010f9800b56554eb9a8042701b402766d5589fad43c675e865f04afaa18b0b49c787a3d30022834b04a67d021ed95cd86130bd9d5a894868681a0b6c5a31a4ae4607567d183193a79d102e44aecab2b40b6cde68814bd7c258c7fdaa9066309ab541bd0d78694a3f843775645f4a7aeb54b78f05b3f49168818b5746af4983e72ee1f8403d2518dfb2237a6cd890c20c5d4744d2060bfdddae92ed8f4a65196d6118c45202e15a6cb25fdd3970db2d07731ae260c6850160c248b5c335444886a90c2e11885c8e070bce01ed58975c63eea885942b887a040a8469975e767a2c15c5a792800bfe64bfed744b2f759eb5a20347213b8c3a2cd0f5a6df72b57695c7cf907bd614e2352ed89ef7c8a4d45a2795580d3ffc6d7940fba18a383e1dfb1634684a1ece6ca8bcf9065ab58d6220d2b35de2813070b8f0cab25b1cc0c1b0e495f5b16154018634fe155331b5a065b920b9977210bf062c24f70db172fec09362dba3be3b3e96adc6627a3b4e2d5ee567763fd6134079f2e5c3bbe0de1bde24a030237722ac62ea31b9f3586ffeda7b8ee53b66b17093e8c70f1c97ddcfdb62365c1688f7ad0045fbc631fade1a6d87b1eff9230a3e6eb5e4972c0b41d6718ad230d6a80f1d20992567745f055e1186535eb9c60cb0071254f7074aad98bf18e87675321e3d6ae10ec6d4bc51ecaf14a37a947a994b0fc7e40d9e80052c513cb1c805c67f56f910d65b4add4beb6cdba6ed265175c0b34630544a9a66e84183d1c46a6ca8f03abeaa2ebe174f436cb62a252f92c1d1e661d75f79df94a298bf1fa3036a4a7df7c95bff7307464ee91972a434815aea2aff71de6ef55f6271bfc7e2ef02ed663f52a3ac1ac6cc6dc8a0439c5720819ac03203c6925552cc9bd3728982f0c4445ecf338e3c8097e8ec79862339aaddcef6051ef1421521febbdc0b5c08b1705ceb7442142b7348e77b7e9d59a545ff68f92640fe58b0fc07f22bd684d990829bf0d819610583cdcda2e8592b1a73025e9001fb6208418ad594ad555fe18033b0db604d8cc294abc785941a01a343ca06dfc27b87e0c9e523b4bf1b14088b9f8df5864416ab1b616c901c66a87dd4d3ca60873da5d903a4261af96f161969544763654441614ed33d87cbc3c138c4ea0664557ecd3fb1eee45bd4dc3203139abb8dad16a9a6bb130716274b2f7d1faf5899c06052f9d50024fff416c929596031e376a99cfbd0a7cc8d910aa6ef2096431d780de5952e1e2640beff4d64177472e6d76d7211cf7c35faf821435cf5920777f58c328046e96b9ae3fc90ea1d2e34e9ed6b85b5673727cf42a06b2fa77b0ebb7d74632c30aa8e3e2cd2bfc39eea52496450e958ffd1c99c5c71180ea90b60fb90d313bbaadfb235761e7508438e8de33d78fcd9eb63647db5921ab172f6d9a942643b135746f4b88bb6fa8aebef9c2c4712998027c66d240a90d036b9f010c11554635d1da7e8b25e409d18968aa53656dcd4e392408a297f7eed3a2df6f5a47ea8a88d8db3b15c406e73193f88e968399e6b24a20db3a0db4a3febde21b2475e2afcb76eeb8fcc319b13ba39a6d00ddfe313a1a5cb5f028c8efca781c5c583092dacdb89a2ce05772ae327970ffe5b5539a7beab6ea84bbe6f231647ffbd16043da3e9835398452e7283598fa53593be15442ed154ae2d019157a86e2123ed826d23ff2440ae4682100336d395f7a01b35b914148c8383385f7857d0c76890bffd865b0fc135878a03012d30f07426ff24902f9837bde75acc41feb2147ee276f92c8e394174c9e5fb0b34f60b8e73273e5160b869ce023b3efd2bb3bad291a5bb1f1bb219db9310b7208ccc756bd330ea9b92d9b211dd70756da59632750ae740f8665b553d10ee92a65d8708085eb81776815d79236f99648d55e30a8f180a2da2dd9c72a7324e84efefd54e3444df1d7f8b5601c43ae7f2982581518f47fcbe3e035e9c9002a1c892dd78f11a114a3c07c54156312c66ea46c775b6d35ac5b20e17978a10d70ad830c1592591d32ee7bb1f7a6ccf31ecaecf5ce77d44943763c08db0e62e5945224fd604b2b9200ba910eced618c09b19ace928611a2a3ab140b9ac3b8e1d69ea0c51b9832c50127af5f659fadc2b493dd0457765f97ac377dc8b40eea8b134a71047eeaa450caacfd6e2b93e5aa4f1a3d50ca248322684ee7cbc7e9c35e634bdf46a447986a31b9489ff63d152cc1f9efaa687e548eefb3d992acd8ca17fd4c4378e3a1d331e45e6f05d46926d0c09df5f51570c7d502e7e7a40b3b4933e4ef06c9578599674d63d7ab1de37efef277d260e0b8644709f8d2d403a71b0f61a1a39fe982f57405754c64730824bff66dee5b487f1aa596ba80842c05256f2a667b6200fe48d40bd9003783d90911d7492e6ff790fbb2bf96bc3349c8e35975fa09d94027378a161ed8b1ed54ca8745afa416969bca9a9eaaffefabce23e995ec96c2100c8ae4a2ec7df40f805c02b605d986d4f320953320ac1cd649da91175707606e1880264248938c9b481caf0850d1e5f59b75af7e5465cf983e96443d76e76bad33c5160769b90ccaf5bf538c14690f75cb82e59bbb02b7e20a3f1d113bfe08d02c689c24881ee367a306a8c266c7d1fbe295cf03ffb7f71c6891b5df7ee97bad3de37b15780761baaff5732e4d81944365b7ce149ae0bd8ce3fe5ed5942e032678907a3f663218374f900713e10db450100371999c5fb2daecc5426f6e55e112cf986d76b45b31175fb111d7d8e098ec8e1daa98bbb821e53f4ddf7480a5ab057e0d53deaa00e504dc15c36458b1bbc2331bd6271ae3ef345f8f26904869a44c7e839e1989c771973e34d29f4d6c7b2806784445c2176906defee291ef6ad7b288da7af61a829d42643c577e5d47eb7c89063817c0293ecc741c269630d884b2ecd72c726dce10738e6e865051a1a68eb1802c6f648e90a9e4b14dc8104bc3c371e1056dba41bd18bb8a360c2655b0d509c958c55317a161c8839072e44ac1c1d136dc4da75fdf8ab0421e32aca1eb1528b696100e219811394174f33bdf4d5c9f9dfd3cc7e578beb539419a8e93a205cc7859ce329af4760c3af8902a993905b7f7081da052446ebb9b2b113cdbfb220cbd1fffed09f062d719d77fd53110fb19821a3c377c2dbf6a8bbc79b54bbc7863b82074c4e5fdf8c9ea8f477ac75c7e5162f77f09ba1f0842adc3671dde60cf5a24c61456c294489a180fdffebfc2b68ebddd3c073adb9202543101fb4807240c4d579d6b33f90268961e8b0fe1e2e02555366bee78d5014cb6bf88a30804f861603ccd97852bf8b4dd2d8a04455cbddf8e59c1c601116a2c3d7464c61fbae3174f204bd025a7be1a884e0bb52992bed60f7f0727834f6b851a949f4bcbece9077f9f4dddbf702aa3f5231ff05c2ceabda5192b487e30c39acb87c99353d55ab3729b8fadd05dc6947d2dd45cedb77faebf589a16a41404f69f88fce1ec98524beafa225fc73348fd54d204f40a325d9f5e0f8da349a1b52423aedb5a3bcf977522c2588488649eb5f315a3bd6e31c046b8d5d1a28296e8d38c2ffdd09b2cdfc807a600b78d9ba69e1f999727eefa798497cf84fc418874c7c0576bab598084457266077fd52646e830f2fa214a4094863d65353da8a5fc41c39b5e300332c9c26ab8b5c5b3e4f2c091085306ac47fea6b2e11b2a4bdf9626183d5c868793a8d2d67ad3280109c0c46caf7ef6b1ef0a9e75301eea4329f167e7811146975c9d3f4a88596d35f00cd2881f9a2cf67304bfecbfe19b4546bbb1b57a42c490df32e8d6342de714aa89ebe6995134d36a9e5768a6b407d9c6389d5732c2c4d0a98db44af57d142b362c0607b205c0fe86436ab009e2f6056aadb4cc87f1df85b7b259e3b6b6e5c73f2e7a9cab56e6122815672946c175af97513be54b906a742df2f66ad7d42027de17e63b993815d2565b05abb7d8f5bd32a1199e528556b3ad64904d3a8035540c6da58afa2dd43ef456bc5dc2df785f35885ca831e10d9d29db886d5568b203784aaa1dc95e5ff18ca1fc0d6b3d426f3d3a1fbc7313341bd1276b32ca3f2f82cbaf624a838cb526f3158915297103344ed9fd77e7d3f58b879fbf3bfe983e2c4becefbff5d567db1cbc75b51d5c2b38dbb90d6f00c4a4acb42941078965d25a12c3c4576ed13eca07b713b203f46cfb2a9fc0530633b0e4980d5c1f0f1c49fbc7bffb88ac17f6b753675c25b44b0d33b3d9bc860719489ba865f7934f8c1490283b5f298d4f860e48ba0c8e127e0670703c8a8357a08c9da954ae659833745ae8fde5f266b48f1bdf4682830e9c056d8ad70b97190ab61e309096c0c95ef07b654a8d42f13cd0cb7d4432337d17ca4d0009944e258df492878203940e906452a4c5439d0c0f2842de50c3b330b800494f01c7dc312a9ff78df9ecd10809d8a9f8aec1cd330c855aba4d9031d35e63369ed9b15c702ab42e65e575d8ea1d7a25990d80c412d106d3f09e371cdb9ba6d7ffa5a4be4ee78e92939f4e81d892fe715958a336ba8bd241992ce9a96fe55ff386691674dd35b49d240eb809d3b6e844191dc95f455f11393bb2201c8a0c27a8eaf99bad303902648ff430d988a9ae77f488affb22357c17f56709c1e41346a6d950014d6203975c800ecbbc8eae98e5433b07fd2c194fc001a94267d71e751cc5a17da0c90ca64f819e52663b4205d477e0988c9e41a5939df9bf015aea24c69701ea9bbbae8c67ad9c9ca112fda6b91ebbdff2576e118351323b83be0a5d8dd4d96bec525437e630c165ca10c6a715a868b822f861e98d3fdfee6568a4ec0ea1d26ffdd728cea53997a6b2a61016a0267e051dda2134d8b7cde0be559fe15db74d330f14899fbd251d0cef34cea651c321cd067d06a61fc89e62fb9b1a81653c31331db6c65a4939a4d0c3ca7cb87d0632c4668dfe7c80bbc5f4477ddcac59d17f091e33b5acb6788209a362388bdc269591cfabf00e604222ec9cfdff4ae7f3f6d995b7cf818b39bf347d7f5ceddf28a0a70ec3b40d0dd4c17542db637763ce8809c87b2200ac8a2af3b51c5fd420ed9b1b6324a1c0c29153feb9a9a4c8020ce176eb8d2ee51d247a4a454af71758537b7d0e0584fa97d0aaf0482c41ad26f9c09b88d0c5fc6aa093483b3fa047309b43acf5357bb4b54f4f72039dbc9960f39758994a639f934af5c34d6a85b1a22f905ff211713be93794c92d5bfbe838ac1c48a87eebc21aa1fc9c188c122cdaa962ac945c2f1927d34274b32d2e0b20b6b1391ff66cb55a5be5d8ba6a7334326ae6369877dfc64715b25b72ea058409ad8783c558fb663fa0332372725a3d3c237558ed05ff59a8b372356f0151416081e6cc3a80567ccf92751abfc422d62f27a19b9eb915d2466bb845f45ee20b92fb64bad18d67f057aed685638ec8488a7cb54cedfc5d160bc8dad6535aa3811f473fd4609558d3233d1af2ccb7de4df9e51129a2f8c759cf65b507342a54686b75b6c46b831e66ca51dae36ec47b9331a95e60a288330a5513258b041339c45a25c7fb92c7041f37d3e384873baf33897b885095c9bd526657590f3a8f494adf3d4554db5dab1768f3adbdf6fd3d0bfb08662436708d5acb07f1b7c02ce70d63d7f4bc3f1cf9316c13d19a5e79600c53a6cbaac4410e146bf8e041ca90b93c22952496f89b73264eabbfc31741c527b5037f5cbefce681bc077377fa97d8e4b9c696d1d02151a394ab736c70730c6f72aaf549dacbab4bb10ed7d1888313748b0a3d76938e369aa6c44555536c6c3df11caaf6e11e3e0d308fb6127cacc8f59e38461b1d58d2a7885c4f9f35e7215fa0f646736d25412f8ec357058f990b120e399239f5ae7d67b43dc2cb39ad105be5972cdb0b9e5d87277351a78e944c6081fe5e302dd2db36cb2ee7f2654346a391e3dcbc7d529b2a00bcd59d2c409a87b902ef4a2f03e6630f371060da4530e0aceca22fdf34c563dd9097ab2f0de077e8b9ffd49c3f93f5838022cef36f59f14b78499b839b67580974203eb302b8e6987ed5ebfe7c1eb3d73ac6871be7c0f43555b0c34d88ba3f41aaedc08c57f156e812b1af5d45fa782b668867312c678ec3f1cfa76ca1049c19aec91a992dcac275a90388f576fec01bd006a6c86a6c8e4aced6292277697e74b75b42c4461e4b9390d5ed97d9c4119da39df8e76cb328b0cbd719ede10d7a6aeea5e0020c9f8995c3fc4c7cdb5328dca1d3a84cb1e1efa019888640802fb4656aff65f4de8a3c7f0ff4ba430f422ed6c0a60ded38314f29a7d35b2b040d1b19062e88a1f8bca8fecdc0c7a6fccd1c8ce9d9fcaa47ffe6f93d23879ad71e94649f02eec788a05f006f3fa728d73d95e0048bbfbd0015608eac5842a08993901cee53ed2a9a90d139a0608b4305e383cf28270ae9cfb1d50a46426267c321365fe056354bfa2956d17c5622609d4263623b0d369ddb40a3b9f1a39585394411a1aef0fc2f92bf672ca9c2ff054a1089dce080c271b97584d83d4458200279171a35ece0ef2864bcbe8491e322c349572bffb4aad8594ca40eb65bbfe83c010f2a5bc5956da06eff2f42081434cb60db2e6f034219992f2d9b97f47a85715099f82241d2098138922a0e03784742fcaaba990217320dd3eb8f3ed20732d8b3da6d7b23f921020744b7d5d1092607d95fc1387c9d692e32f4a8cd4048b7f291365b645475a632d44d5f7bd727c6092fcd111341da313967d73978d9c7d7a75af968782c4cb42b42624c7569f5945389d9d06d9c43a8ad4d99d93d6f3325bca5b9454e954cd5630826651f976f8f5bfe5b1877dba48658bc944424999d31aa3fcd53dbba4b363eb0881738b7b4e07244d885dbe51931348ce2ac15cb377ae20b39973fa9a77ef1d736d200d4f037453b84e78b3725227e2b9d8ca373dfc654568b355c0342caa54fde98fd7d572d4c67fd3d735b11cd67d9ae8d9d575adc24fcd83e66565435fc2d58dc2bcf62b56276f3cf646154949fb605451005fdea7d152457009456d55368766bfc140507ddeca1fa1a5ff743fd4aeba91daefa55edb859a6f4a7063c111ab56b26d77d0cc41af96a0c55f7af31f741a683c40400c1cbe6c8af4cc49fdd83603d2d0c03be105c8e8ef781cfc1f8c1df5a6053c3a93c07536a3df1ebc7f04b7418c5f782edc438493ba03f7efde0acce0fa2cfbefbcd83d0b9ff2cf7398751fe90922346d19166ef044ae8ddf857d543d3c26db71c350e728d02664dadeca88fb408edaf84677ce93672544254839644b7424d40d6fa797bcf9a9909e7ff7310d8072effe07af52bb8c73b397ad524466194551dd6c809c9d28a3b6ba48cb89e22eea6aeb4c5464e169d0d591cb2cff88026f8d08eb0724c132d6ddeef918a3931f2f1dfd69e2fcd3a964e98e57ee82c7c88546a688204e0990a88c53ee1703aa78040c697fe336c5fef54a8107f824133c6451dfcd0a0d00a5f73c7b4c6e72959695fa95c223eab3d09f83ddc01d2804cf2748d4cb1346e2df6d07c0d15b6ea40b214a50a971d8c7c764fa0887e5802239ce5d8a6de5c611fdf81d7be4f80678a9b95c0c679e2a6e3da239c8054d9f18ba0e1d68a4f97e6898cc7e06a20647861b00da1955c35f6f84bede481f1122df715fefab942426da0c148c7b05dcc53ec64f40fc9d95370b2e6a8cea5e0df5bad71ce8d71b9e962932defae65ada1e81477035b5ca15fb40b2cf15835a7fceae16e7330872464d6fc8ce3ed1d553d181268238671572c86d18570424669a0d141f7d8a429a50793b51d83bd4b2b2972e913a9b73c55f47eb446f939d9fd4d8c99a432ac7522ccc17fc2672337c71a78b0324c4943fad05b79dbce1166cb7d82ab8535ccb8c3cfacd280fcfb05ecc23f36b5078b9a08e3e7106c02c86c0150a343dea3044bd7520a9d722ae67043dcbe22f86d7192cd4ff7edb1659be6746fc81e591dae18f4860fb6018d4bb00ae3de9dea47f82b4e01d5eafc18c4b06784d439f352dc7ce9f9aea90292b137ca2eba5129e0100928d2e16c4d0c0e44d83d172b1f666d07519b1d0e8bda7f87dbd4d7e26373e9d0755f63932812fd51f6070c92d9293adf35241d6b305e94fa5117dce55c5319bb64474658170a391708121fa88b92bb2b3c19ef7ba4ac8fdbc4b82d8fdd18408f983310d00934f84f45d405b12b46f43e7b490208e282f9d8b93021da4abf4064b3f04c6a00b2f895e46f6f7c809c49861cee592686b447863dff2fd0cb8a4fb3d99d515e005f1e297e197129922b5bc6409a8e61fe50d05d35f7412de9acc5169875c6abb2623d1f33c899aafcc3a1df5b55c68d6c14ca83f1bddce35cbe0763714ed3fab918b282ee67ab7e0839ced9a31d35a674b3c4118df31e1600b061841144d2b7a19053250d6acb2cab6472369d9da9e3ed76d258870da28bccc890026d1d55342af7d28c973d0ef4dbb0441ce402dd008a3a548b2fdd6222c959f28dc2dc5cc2f2c1db8ecca950db7947494bbdf590aede3452eafba6a080d403707858b2e23e0631d84ac41db972fdaeabdfa00e70ebeca5c35944e250291f75962c0997cb49b46df7b50e0c74df1d5c9327b037c43d88ef9e053b740ea904c78119c4bb75811fc035d3ce96aa081f0c1363e3583fb79a96ce5fd4d2e90a280ce49cec22927d226939e24f1570aff2f1cb7c21572fadcd57c7234b5021","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
