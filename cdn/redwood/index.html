<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f9b315bd354b7356da724ad008063ba39bf8b4b47469451c1dbbd0a8c435bfb2e31a72ab5bc1e5348e06a1b83bec1fd3045f6dbb8d193b5f7f4907a65bb3d76eabb19fcee08e35dbec8acb69791c79077482f39970499f27e920708052565e7d692e7bd8e499a8f895772406415ea8d81272832fa1afe55e846369fe2ab4c6b48a20d84886246dc3b2a8509e9248d5b57c85be9212e1221881ea552949dd566e6f5f99a876f00c9cd1951ad7c2b1e0356504d2bc55dae547a632dbe64446e1f6d898f68c0868cdca8f062bed0fb8ade04cf153099fdd8502685cd019a7a67f06938226478d48778f04ad4289d764c577342aeb242e3b317397b03119144c0810171eeb3e3a0ba5b728e9f1b44d954e633c2dd516bc6e8de0ebbb9aef8dd0d3e25d80ed4af8e1eb025e0b1c45ac9be30eb005f1004fefaf27ad6854011437850f8b8e363898441691cf2e82d2dc275eb166295797fdf83e54260241ef859979dc7b721ae8019f463e8b79d34517e6c9ce432f9009d847832b79dc07b889f385681dadc70cefbecdc9b0db2bcbb92d0894ebefa9c3fe6fb22bda3f940cd0b0f27421bd4a5df88a5117bc89b2c8cda7210be76b9fc7af4da8e853c90a8f349c837411abe24c56cd95346e6c96335b363b4386d9442e3ad780746a7ae276b7fb95ec8ebacccfcbd995b374613e9b27d596f4ff3de3d8f753994f0946753ebdd9a1f21253ecbe5f00217c5687f024ed748020198fdfd7d7ac78ec37d4536d3f026b65a86df84da96db0db56180f33c380d28e01e1e859c52e45ee45c5e0f77d1d478bac5d9c1bb5cc5ca45f31199886bef7d4825e5d8bfac6047f8bc72a156e097312d132ad54745cf9f476760f03f183f756b032a32fa63245f65eed97c827c63621d1196e6edb995a3e4e860a6050bbe4e8477bf1b17641facc0873162dd2016a3dbeed17b6af915c3ad53fa59443719f3e3b92c2dfb2c0af6779037d20671d9aa344459b6d8ce5bbec296e3df631b8030984da1fc36cb18c958556506b773d8989583b2fb790246af1caca3e5f1f742fc254fedc1878f9b444bf33399ff0ffbdb2da19a853cedb7b4181cd8a0247f0db459c4f3bad5fd332878a3e6efb2c457ce2949254484c4afb5242611d61bdd2b6705663e8af462615baed58f665d3c6cd4fa22d87ff0ff47600fdb05b8081122fa403ec250e6536a56aead8e48dc027e6f4dc5770532f434c5b4125f15289d36fe61b36b13b038012e38ff3e63b9ad5f3dc3070fbd3cadfc9419b2ad933ad9eb868fc1c53bfb6538bab4c733d2636e6f91ac91df02e708e8ae089e9e13668e75bd744c5aff11e17083a9227f69e766f9ec77eab229eafeeac7a0e23e334639c367872439dc3f0f3a3e1be75ff599b160f1870b938095f7847ba7bf8f4b2c9f061320bfa42b71f83b6406f2472ae8e0c9d6625660e87fe62a6b4e2c94b3bd92e73f64ec5f5e15b7e173f30f108b99fb97a0b55949bedeb94f093af93cac22f3ef630cc419d1d1cf20022b062ce79c6ad114001c99d66a02e5f7a16042bc1616685701687971caf28d0075dead50e816ee1e0f6f614e2281097c2322b436e722d13a87249b00e4b5c7be50a587e90421cbdd11b01e07ad35fe9d99da5bf4e6feb80606a88267dac21f76dc4a036495bb00892772b3b47f8970b203ff3e6e7a10576bd446a8e0a412fbafa3dd58839bfd7d314aa2ae4a6a348079a5d33d2d302b9058d4b98e9947438c5f6b2f41e3d9533785957da6c769f73c531fd54f7e56c2f63c321b8a598c0bf51c8126172176962328356ef67e954306f33e616356e5f8dbcfb87cc9262fc8f534fc7ed51572fd3ed17ad72d32d32d64667d801c6b5c1c701ee4752f2aec31946be369de73fb3b81d66d56df6abfac39802ac8bc123f230a2e17104cf66f508a01cf46afb02e27039e0db5b25ecd2c7d0a7d39dc09d876ac2ac5a99b4196a3b47fbd529c873e411408ae89fa8aea2cdc4f67b7fc63f87dfcf5a1df55b4789908ec5ac3245188e02d7674575f1af96df094d76743bc7eac324ebe6e8d7c21239ad1c5554668867ba299b0d2669d148ab3dfd94600683bdab1cc9afdcfc6861d20764945a5241880ecb6bff5f6a1f85f835ab6073dec1681defb57b3082e013efdf15a1df9a4f7a784dd9994d3abaabd9e7901e51431b62c6606c481a43f1276d0939ec0c39ba95dec7bf42eebfcbceb705815687fe66971716e2224094d3c6bbea074052f583f04efe24fcc3a2c45f5f739118a9e2f156a7cc12cb470dff32d110e5d0094ea6c83a34ae7212385ac0cf1f75b9ac732d07f1c25b594363535cd43d80354ba08d163a991c862f39aebe5c9539738909c4b83ad19f58f5496aad6fdc7527896bd6359863e32f3262ff3681a15fbbbc42defa9316528e514bab8b7658efe3f2157bcb7953403806ab36506bbf2105e649a18957b752ae99d228caa406dcd66285213c36cedddcbe14c6cf09964f2b7ae9a40e8381e2e771660c3062ad2c6a4c9179b4d2e85bb36df0f5549fa2f1addc4f7b1b4ae0777ede2047eddee445dd8d0f1fffd1f8eac7759444492758fa2dee16e38737279b4e14e66c257ed2e871e1c7037dde50006b08ce5dcc9f2e4bca4f94390a26fe850e4585e092a93d6e71305e329c5e15f80e0c4ae90af8d3aac0625c2e03cdac39b7c6a22cf942a3310bd98286d295ed39558d5a64a4448ad2966090b58f520a96a0e0d17aa593f522509ab051f33bd59d4e7939fcc34cee2e7b9ec5ec4a6ecfc2b798b1e969146800ef1a1c81c76c008bbfa6ab96ce6c2f4bdc17765f4e47b4d447ac237bbc4e1cfbb0d8d8e2fd86e35e35db29586edaa7c347c29f0c01523469200f12e0b0930ece93b3d4a9e5211bd9e38303d82ed9e98bc48bbb9162439b8dfeb007fb81247cf2297540eda6505bec1c4b80b139479eae8aeccaa3c69d7cc5e7fea9a0e1eb1760ad40f4e5485346cb0a11395070242c3d64e9e535908419dac4c63b7f382a039d806810d92e6efd9a218ea1cb96c731f063ebd6caa0e22d626afba3f8d2608c908b09dbfe696fd0f59e6f124f4a955c956e320f66582b95a799625ce277164da1417027ac60b7ad0d586f62e05305616212e89a5da2b246165e79a47db0723dbd7cfc7e8373ccac75918739b4df6309142c499f6e962f0899906f6af8aa444abfe164c3397c3674940d24fce0bef0ea5b430a14dc548bfa57c598c7fddb7f88b31897bd25e6b9da79cadedf9bb5cabf56bd030c5f18b8887a6ca0ce16d78c93da7ecf9a59d02ded1f6e8eff5cf7b8fcd7b7602fa8176f48d2db7a41f5d02474701214b3009fde1d8304adf07ba9526fc0dacd9616353cf5bf98e7cac0663cb51b15487b64ac3776de031409b5fd2461e3c2690ee04611b16b586b5e3a354f63d7cffbea82d37ba3276d706267f74f66b05408bdfc573e20d5471f923fed18f791f8a40a8f39fac1ebe3ff93db65856ab7b90ef41baaebb85bae8ddb5cb00e8ce30e99377085827ae30d786f40195d750f7ca5fcb92a7fea630c86734d15ab7dbf236530ad9d9f8912f2f2c8dff68a72272afe84e714f6b0f1315b576a90b58ae364083e7b560b751d6ce396abab2b1f6e1cbc55e3c7c04119768b614673054a55e6e439ee6db00d58d7eb8acffd497024f448e5e1f1fe8dabf8e8e995b673a431db4cbfc5b452dcec4676cf1ca3e1510a7d3781b351a388aeb39afd0bca6760eedbe2c1c48203dea105b34b2e44bc8791d51971181ff41e34f21121ec988cfb02c54296d75fd52b6032dfe283647c181612e6f9ffb771df532db4e2d9d9fae30a6b657f432793ca45087c86e2b11edc1cbc4073849a3c28c5866fb8ef827983270e7b00069a2149303b4f036fca71203aa572e67a9483b74a6aff3d441aad9b83b464249d072078b2aa491f105fc9075d200a9f27450983a4efc59995cf0c0b16d5185c89433cf4b3b2b41fee9e9664eabe2c8663c6eb177496a7b1ecff7216656c1f53e85b64ef2258fd59b1203bfca9516e32f7ba17e81f0526765a20681c15541ce5a0d4644f974ddbd50e0314312b3f5bd1bb6a64a4910d8ef4d33eaae3aba8f5d3d4cb3a8bb9971c3e93aea83c34690e901facf4f8cb7827f91c9f500eaa3a766638789f09c1f00a62290d0d0b52a555d66af609520059ecb69a6c9ec2fc96743de56202f4b2659910d7f867b990209abd0ca9f40720244f7587d641aeffab734bed95e06ac3cde175d762674adbc817feb2471c23e7b47d2d847d5e12e3f49851ac26d7de43d842122a06fbc1da374e4af55f1ae17242084786de995849f0cfccc5742a217d0dd2a08d1c1fabc41218bf8d205a393dd7f68e4dfa0343a23d2b1ac36b27a84f88f7c662d000a4e58f68a14f6655acc3b874a88d94fd33bb278062abf439577d83958648a042822006bb60b6fa787bfb91556d2efa32f7e1ccbcd82ba3d14fd49dbae424f4325c7f6001a826230b6c5bb9ef98a4971849941d45a344a0d1cf90a2de5954bcaec49e9e65cbaac2309da12524127aa711d508f17b49bb71d97d53074afe8a487cb740144140734ef1c1a96a2d73a602cbd85e40174c09d7ed17088d450b65db461be95d652cc694bd780c0d91c63c8620b035442e5948d51638f2c18f04e26947e62681aaa887d5dd4adf70f23db431892c57100675a6f8edc4fdd4118e551489f3018e4435e72231330645ee8ace9280dcd674e4c0bb5daa205a1e006db0e139dfc9d35987ed42e9f31c0594c5883ce0d99a58f96b625e6fc44c519f29728a83d20dfe6e68fcd7c94ca635ef2889aabbca40e474491b6e566a6ba1d4a0ca195ce25f33f3ddb261d70344a4606487292f293482fbfd0f1a48fc7cf24cbedfd22f32724ecbc2ac04c755ade6ad9ce45a78d061b20329fbe75c8b49b51e14fc49f339c77714b7e236e9e6ee78a7fd3f1646d59dad87542109b5dd0da62d49b8899bd1621af97fbb5e25a213bd30b84539be5f5ae148a77154c04ae4b001e630c2bcb76e06752b6383c6fa91b8b8960d450f2970f3845653e317cde6605f121005e2e1a84fe7382537c6cf5e82ac7d13354c64dab1bb53ea5eb27e9a5ed5fa78cacc8105d34dbe29347eda949f0377c5621897be502086966bae1b6efdf4bec4d497997744f714a490eacc0f8312ca706786b5844f101afad980ad105dd63d5fbb83ce4a524cdd97733a4ec97d5c785f7fcd18abd6e6bfd3ca4c37b67dc1f1760122af6d6ee9b946343c968a966af247eefaef33b7b92431d259cf679135c5262820cd7e81bdc298228ebb8d16d51c81a3f5fd52bfaf1c9db941f717442ae785362b7f95fddd5ccd901cfeec7857ab2f8649f608b0f85616bc9c0c845d7304b1017227810f50b14482a6a9f1ce178e82e3c98084898ae46cc97a44f1778e06cbe7b8411adafaf8364efac0b461c44002dcd46798691b1ba1479ca8ecceaa15cbd14359c13be95807d14593fd2987b0884a0d799b9d367ae7f080c1cb3d6c50eeabf98319721f8ed74f64cadfe4785b5c903521db0782c5f6ffa44121140b3ac9ac26259d95dd528b9e6a63779068633f9abc17ae6800fb608813c657298cbb1b375aec40d38ef115e1048e871fa980b2be4c76ae6afa6f561e07cd283fa903567552b411f53e6908b284b0b3db3e8366c3ead719ed346b459867b6d8baa2a69bdb01aa194c662a611c38d5b1b85ef904ad7262318dcee841fb82e1b3d876fdfd1409c1d4f6affb596d17193a499b50fb80bc53679225f4471e5fff2e50df0c09f93ecfae30696d7e44397a1e6ada14c548cf1a8449dcb0e7d72163260d72d7495d92c3c25f565ea3b8957220ab9f37921ef89a41e53d2c40957469e5dd4fbbbf75b0466714aa72681097a545b62c63078c329228b71b0013bcea744ec5d65e26ffc95e5760e76986167265f0038080c10de53c7c17d4dc6c7eae6c50d2250644bf74544f9a6cfde1de13b4e32bf95e01b169c210c823e1ebb73a3ab15d64f1e19ffd9b1a4d13aa8281b5ce20ea4875c46ac8c4fd25093db4201d894cc8e6038908b907fe520b9e15fae93684eacaa9aa0595b8d088e19e2377894547403a0a589a7cde51533f5849a3954cd57a9400876e43037ff2620cec1ba0b920c687068917b755e4a5443859a54a8a0e14dfdf446b4c203acca90df7fc56b8b77d1baa8a49970272b2d1185053fbdf5831b7b4315245499b3ef1b68d9cc167ac3fe2ea3bfd69c329e66b633194861616606e557d6fd74ce72e5c25bf4e1c824e84673aabe887b24bd7665d5d5910d143fa1ca4364ec5722a083572f11ef525134154c7fc9ff91c59125d0a37b6efc6acf6ff0ca11ca891fcf0e6ca97289fcb5e3aa81da019258451d41f9b8ea44c60cd2df8a0e25c94fc04e125b96f5b251e1c4b752e4924cdcfe67e488e8a662f4f92a82804b3f3653db9222dfd653db68e5b530ff42f1d24ec551abf3101773d61f5f45f33a735ec33e579d23c187444cf02c9d5d7e131e062d02e712cf9350d4409bd75c5f4115fe6f1f029fd976332ed0473b07590915cb4a2efce1ece4b9c9d9e654d590f452f7253bc7f2f3ee5b5ae4a7db733b6f166bd08424ad9a26bce577ffec34a331de8accb783a090b9c84ded1802c35c2a8c255d6de21f15a7f5193ae4367e943f8ba44b80d76ef5e1bae3fce933a01adabdeb3763fd175f948e235978068ce6a80ff84fb4db8ffb319c406a0233fb7678e757672b4849eef9260e2745659e57689a118f5280ec1f85aafa6daa6b64dac3c423fd4297557caa6fc52e2a41ac83c40b2b9f465107567dc2d537918f93f4a79d9abb25aac157f88bd0ff9d21643fce780ed5511c091d3892cc80ebec010cfc59f3c0287bfdab03c841c0c4eabae542a72a45b1abfb36c6679a19be161490978d3348cb7a7b91ed788a84bcdda240e970a30cfc34e5fd7ce9082cf5bb560988e81c83c382c57bc11dc6f6cce02cd6b3c07b336f05486f522cb0538fe708e5e1f0cf45eee46d5242c6f353096aeb12f426695a5778504ab0f18249791edc749a92c44644b71e34ffd64dc50d65add3c9c465ee6138223a701455eccf4778f213de191dccb2db4da151bb195686e7886a1838037c493b585ed41a6c0d0be0c8d9e7fce4b99a483e4d18698afea65bbe946ddc409b3404e94f454edb039b41e95e95a3d11315e75aee3a8c0a55aea5c4458910851c5fbc40f9076ace7ec82b1048d91cdfe6cc841ce848fbe8ae0117442cc083933d612c7f5c5d9ead71081e76fc248d0067f2787d6be3abb2ce94e01205f97d5e74feaada5b299b1b0c459f2168413094168949ebc86ab55fa849a66c60e9b4abbccf54c3eac957710cf7cba5843bdc3ebb2d261fea13388e9632154b0e8feec93123952b87ca7fc6ba2703effe459584a80fe91773d99e43703abc3f028af53a17f4e8dec885a499a194884a39f9840edd5b75d6a4060d0ccf4d0810205d1f748beed393a5db3fffbb31042b9c425af764886ac02b5f984855ee234e2845f8304cbf227cab184bb7dda51cd82ce8b82879db707524dcf2122d36a143cd7284c9cd975ae0914e4c4bf8b55e902e81dcfdf30afe150b23e56e23152435c961fb2b3cd7e946bb66e964b22a61f253b4220bc3f9db28c33ea48268bab3b6697a9a6bd2a382006c0dbfa4f6fe8ad0e41192289e66a91664ca02bba259fd2abdbac2322c25693e9c62abf647119e6561fd1b23786d19947fee8adccafc50060acf8110f3de9436ed2938f6933495d2cf6a229399e5bf190e13b3e794b35c1b1e956cc9009364423d0c0a19f5c27629e866eeae4744eb35323c248d4f926ca58f6939119b9b7dbca639fa9929096fc1483e91f07572413dff82d99190f6d1e490a36ffe5fcef75b11e630f99f2fc2adf52825662c13faf39bff63844dcdcc0ecc80394ff1067ded95561d432ee18039f9bf6a8594e9ce704dbfc814909a1c33548b53f8955c949cd4cce4a0a8a5c281552620720822b5ee3e57ae5724507ce7d6789684e44a7cf11ab6afc033964df868136c1be9450dad012355f1ea942a186bc97df92f9b242777904ac024f7cdbb358e177326f1f5307ef567ac507f68d5bda1f43639d88963d7eff63cf5305314a7b05a446259824db568339da85e62166f7e8a014e9e6a7834cfa855a14e9514d56d6c7413a1ce677b5d7de1bb2df1e2f2468566ffab493a27781b5dcd1d2dd9451648b15cfb2a8257970135464e89296a651a55012158073402400b0c6fb884bed3a7d0f2c6afc03ca4f27689ba1b85412fa83556e1cb5edb2fb795593fcbcf8cc149e886ee6dbeb97069dd8034c178e5491384840791a79a69d8d792b81ace90074ee8fad4a078aab3bf6d6eb43b0e9edab57a464108696beeae2d39fe68df11ffe91f56321134c2ebc0fa2ff85c44fb0ca53ff58d70a41d88e69eb18f3cca20fd889b6df923f3d44fc187434ef6d2b4846672b9f0c400012a1d6b21944118b76dac811fb538475a43742422b3bfe96b3d4d96d95f0cd75c44ae62ec8b1ac27ad321825a2caafd73e6da7b23e5dd551e1735c4608b0d7fb6bbcd853a15ebd415ce6b9ca84759dc173789e169e6fbe339643da526e410d18ee5c8115d10e667fdadfd8f98b64f3727f673b5773185f0393310eeb73bdc891d8f4425256b2f47ad39e0cdac96f81b15696cde41c56b705eb0962459e5c27a5a982a219ff5a19dc6a76ae1baf7ae7b679f2023f7c0edbafd1c77aa4e93db7581d8e3d9c96547e95ce2646033608e8bf9a182bc4ecf5f3d0c809591d9cbe8bf4efaf6f00f8d8fe4e8dbb583fbad55dcbd1b2da28cb8e3e5282b6b4fec58b8503cd27ea081333a05a239ec56817c373ba3d767cf1e4450bc3418be39c84e770704675e1425ca1fbc1f4fe1696deb050ef76e2ab526061eefbe768d98b42454f1e53bd34890587ebe25d489c14c8b9eaca7e8f06ad56150ebcc1982d0727d43b33026ed29f9653191fe44f9b7f4ab27838ee7b2a394ac8d33eb85120851247517c9269c6ae3a56ee56642ba19c219f540029d6d4391b3ae7412d535166dbe24f4647892aea6298a2301d0e9287bbba0ce525caf522a0cd0be39b508122d0b309b2bc4aee11048a7948fa2d08a7b3aec93a095f90ca5367ea6468fef05537896fe48ddbd39bbfeddc0bde72388ee4e3ca51a81aadcbe07dc650207548f5b21d08bb827cfab95b7d49c3e2b6e73b7c7858721aaa52cbd3ce7ce5bdc92ac2aa42786b68b99b4224834bcdbb1d6049d92ca859468d07a201c3cb67932f27bbc526fdc3381053fc6f2cabeab8c401da8edeba4bc6654c6ea2cf0299d408d1872d97fb40d11bce4a67c21b33be632adbf09e19108d55bed2c78a922d6885cee1f51b70b6bd0e900e9ad6d59b9efa39314da77d4f5a3dd968eaeb2ea3f118cc91d505e43559d566247efbe9e41efa3697fdbb36036d7b7166b7d9589513a8525f8c703d0df9e55256fbf8f8015c48d22f46a1d951cff220746a2ec8e0c820b5c50143b34d6de6e2c9b97fb2c1a750cfcc680b16ee0f132d53a2b70a0ba24358674c2a6b9b8638297404fa92da84ae0bc30ff96cf7290d453ca5848c5061bfcf7fa9301a3adf905d7f57e9afe9fb29845e1c996a2d646e796b3516c217128ca3f2f9014ea6705ec82748d268675e6bfa92fbfb1c3cbdecca8ebff1711d9cd5904481d658808b17b62a325b52120b284f3d8a314efe1646152ebb008833a9bc1ac7ca7087e92bff0baa186d5c60811acd789c67f29da0c0694954342b805b48dd50c99d3caf9b7c1b3e0e9e9a2e0e67ed99ca0fbc68b7e807c9b93f71f9d702c84f8b077299817629028f324724cd2bc95c511cf4f086a95301a2927de883ed92b3de92c93f8e84cc5284c1760a954846c8b6bf82cc9b5b1c500312fb44390bfd9d23f6613bffa39fdb61fe3a67078274a602593dc5888e1c0023b09378ae5bf1d4d7e2b0e6a30f580567ce80ead6f74298253db5665c565803a1cf93b69e249c0940172f5257f469dd30cf28582a2d0815ca9dcea242d2acb7531c0f0afe1c990a30e8cc212187d54b9c7573713b4b74480e2f890e3534f9521fcca7f1297f2d63ea7be1b8d52dd30dd612ab14d4c8861a44cd5a9e0158a4073c92151b5c53f5551e91df5f66a8ccea246ea1cde733db902a38687b6ef5904c9f6ad91181eb87d5a77ff5c6d2c994200b3264d5dcd4589aaad4492cd778c2f3ceb19339a2866a019f6aebf8a71557dac2b48dc07a6e0cf25cf7577d17a5c54db1708fd5494fcc027e638c18c8fbc41690e52628c613437220caf648d7a0fb1427886bc7612e866b997061f0028e79247fa0f80d36cea73773adc4f17e3103227521cf0377796c246daaf7baea4ef128ce1ccb39ad135c78e216e6ae98e0f59057f0eaf4210c5b288a8697d0efe44cfb740257a9358aa0d876df9d48fda4cb8e367d15ea61bbd7cd20a3317b5d43ee598ba32a399bf2bdecbc073dd26ba2a6da2f0f9b81cf450864715f4f2a2baa111f59377c4a6214e2233c3b61a56fcdf29d5aa7b0fd6f685e7fccff6f4a6b2b57955668931e23095ebb2c233874da3bc5226dd006883cfec3241d755319d1b8cc325e5a35365db8c1cbc5bc65191ce3e02cce2c9e153e484cbbe3250d6feaa09822a887a7b7ba968567a42a9312e7f717053b53ce2f3bb8332db79722dd7f14407e8c4296e0927dcb10f6e56a813fe68f91a9e3b8d9bf4517013429e6ce5913fdbcd4ffc09e95846d9ae647398dfaed664704c1e965d4e78fd457880eed7f6d74829fbba9818c3c915d9683bf0b459d41067ab02f1d9661c55b4c9656061a4ff4898b935919a66515733651d9b69f6b9b5f10410d0638cf23195e008b0736d0ccef96b1f2f99742e1ed756fdcee723e0b6b095859f311cccec7316fcb471f7f168042cbb397b1d8e9e38cbc580698776e4727fffabca1b86b8bd4aee99b0098a183aaab63487ea8367f5e64d7e88d5dad14618ff0f62b066604585e405156a13a703f99122a30e3834dfbc94a726758389cc9d93d0464e4f04498ff3d48ed283dd14b0c347d878cd625884284d5eac0d44848a04cbe6d5300b3492029d47d81a64595aac7eb5e8745e215c8bc256124d362980bf94c7ac3fa29c58337e2673cea6ca8bb3fe8bca15931d518079a8893b51a6089bfdf9d3cfeb296e3eb905292a1b75f5e20e313e1d5456cf86d2d12d1bdb8acfb5104d077a626e35441fffe39b01ee83c1026206a066fef3e3eab8ef5749308cf4209b952ee93ce70cca4ade186e31acbf3f1966429c68765dba61a37a8b0ebdb27ccc63a5318b0ed897bb499c9c768de46cb84c0cc64347366201f574482c3d786c3862d5052007395c66b6a3294f63ff63c01f6b1aab54bae2a18f82b3f9383f60284efc57b3f1d3fbfcaf5483b3a5833e740b3cc2e806a37149ab9960835ba4779d47e6f43a4b227212d7dda7cf67ca607271f77b268b48b9b977ab3369be027e0f12a59f94f01117d4c5e609237db2ca6e0de53d7d7e7e9e195a50644e2373019494e9d2ce187f3b8ef194b9aa9668554a6683fce50d1374f7fd9f4abd8a1f7dc0ee719dd9cf6340e64ec45584e654cd1382d69be92d62a22bef70d83341f05d84dd639ee4338ab7bca31d2f4d7422d7db9af56a0ec681d0f0b5f6f2c462911632b1c154ed18832e3dbcfb8dda1e092d13fae53ca173636423ea046ad2d4fe4ad3461b0a5997d3c546db7e0e1dd549dcb581123655bc509f498646c84da071834d68144353dde0ef0c81c3b87d0764c7c29c0fab8da49f76f98fc9728428ab80389f67670a3f4b708094cbf1b7818770c3866f98cad1fbcdca05b0351bc0281e0fdb7d0508654f0bf21d957c46b673197fcd120d8c8919da91a353b716ef97383717ed6298d1e561e1f9944b3cb53829b9b1cca3fecae308c0df4b88162f97ebf30ee800d1d3190740f71a082b1dd919d00eec52372d946f31f4335b76b2b06c2b1c9273d3d8b940051e4f7eb6e1988c9354c5929ed10e1e4ef817c6be85fa9663981f702d3e16806fcc8b91050be413b07732ffc396c601f6b14c123da8dedd1b4182667ce9c7e47b92810ad57460b3b1c78cd0be6910fcb6bc2ca9c980a1dd8438fe8011eaf9b9beb13dc71f77206c8d88e9ee6609d1867de4372b3d5f3864a1a1411df5d218d7d476195c2840d4ec71064fd6e6143c9b1e270172693ad85db5cea22f5a44f70b23d717570d97d8f15c340384f5e7865249e33e2155454a7f21cb149d32ee22056ff65b94e7f2b50207c9ec46fcc27a45ec18b26b2e50c78f958551c0f2a4601ff3a6475a2ed1801921ffae12abc85cdeaaf61e0db7fb3589255191f657723333e504e7986c7a95647d0e9c68075340e0175a41dfd278ccad94abd72de83b03f1ff7057e99bcea743cf58873d5b4c0d182a912185604c7bab18d72769835a244ebdd3cec59d3a94e3c228efea5474f1d42a626e7fe4679557869d6bbadd8012f148dc1cd5017de748324664423493ab455f264d858492203ebbe52c090fb5691b8fb7c8dee66770ed76b3e1aed879f879ab31679e5340ba3a85b479dc32ced53b01448727b6c1ae9ce9ff00d4d9d87aea4f8df4f0eef4c5f13d5f9f2b948fbc1b116489813cca0871aa73252aa22f8e90ed497a99f06abdd553cb754c823c3c48d49931e3cf4f7cf8a2a9c731b79a6a0dfcc8709f9020976f4c98aee9b2c5788da9e1f9312c236a20d9fb654dde0fa61c79d9250dc0233534a483b0d04e3ce5db00b74ffc7254bd2b258a2385ac9b92ae484874d8697879ea5043fdade0dd96b31bef61064e33a5292864eeff26f685486d300f86a0b6f47f0a40f6386d7e52440cbbcdb2ed431059ef2e28275f3c26e2340395e052cc6064c93c84bb57867226a177b985bbb85697c1a1638a9afc0876c44fd1c7c50b3a888ba8563368c81baf399e342bf848094ce870e183b82243c5a872667973e3146a0b8fae507054ab7ba8f347f2575be8d1a53616f1c272edd95bd64d0c833da6d1dd59a17d8be148382d14320748786fe464094984ac73b46d87966813387fa8f23e7895cfd26f7d3a21bfcfafaceebad72c1689aace938425ccb0df220c8adca6b8f2ac6180900343afaf51b3f8a6bc13375aba3fb7f09af04c4b5ab93149bc25e6f04ec34531d99d02cefb306e3178ba28cdd57244f5669a1814db99f7b051cdf3a3e5ae9b23ac4e34f947b56da8a45aca0eed62d3fa1f0f30c39000b8f7a76688270c8ba9586380efe79014c9007803b55e1f46ac5b8cf1ceb17dac1c070ea733ee99f010e9c913fb3061d7db5c7ef18668576595a6b33d315e32da2a55fc9b054fcf0bc44a5ba307ed8dcbd8b8f6c4e96c31ea48e423ce25fc126e7b9d66f385eb9e7db8a56477bcf60ad69f7a8fcfd227e2fb4f4a1df2ccbccf64d1b89610bc7851f5f9300c68c65ceb4023c54a2b4c36f9323ec3b3b41b3b84affd84f162b9310041bfddd82d234b752b913989e1e3e4bc37bcaf27cf8b32b6322736f4e1eecda6a72a4334de1abf6f8b3d0198c3b62ec0deedcd215cad794eddc57fcbeb14f99ac25df0b689cbc5a4572ad394054b80dab1b18e14eb5e26afffec6b6ddbd37fc9b5db4226a9ed36151ccdc028359af6b79a712631693f9bc02395fbf6ff0d3110f7a4dcb2b3c2339da5238827475461700e04d35c5c2a488ab15b7ec314e1020a31cf838f157d8117f1c7cd730a96190a0487d9a3b189e6a284d38324a5911a8ed3576d10ab41b3bc034825964e4ee0b5ff1caafdeb910414da15f9fda3e6aa78eec22c35521fe68f38f3b0c28a6ffc2dba903accdb03e5c709a99ceee08dc32740a26a19e8a182b0a52e95b6c485e7afc888d2344027f361fff824245e0d62a34dd7fa1411299f965d2b2e2a21a00d2196dfbcd48a0f5184f5f1a2882f765ea40ea52bbc9e23b95a7ce833c9187b378e9edc6c6266eb984043c1db60bbce2720190a299e8a58854f13ba9cc331b9e0b3870000f69ce6d6a742b51924854eb762cde85b280bb3299bdc293fc1f171ee809a31d5a75cb82816ed2be670c890ffe1852f236af0f9c27a88443293dc26ee7eabcd2344c8f437bcac6ce7e68eb066a8d8edb9c2e30407b996259ea28b9e40bfcbf02cfff77358156c40a66ec303202017363d09e67e11e3abe81429c222280eb1c61b2ece0966edd8cce4e1d112d70b23c8c1ac70c5a8ef9c36352b7c497b77c19b2887d6210014bc2421270b58fc314bd7cb29b9f8b0bcc486a41639afb46f2b2a1b6d04aa391869a520a3eecbf4c79a9e4dfc2f474749424ca47f2ae583d7d3d5fdc38857b2f54365f38c6881968039aab2667541adbd8287a0d495ccd168c01258565497d94b09638709d03cea81e11a17309bbc51910bb3bd7854959283df658bc99973584b2168568dc09d4c10b1ab4663110d390249959c8e1e21126b5422e9ab8fb3db301bf2c7f54153b0655b8ec4c32679e72af5ab8fed8a1bebdf8b890183fc85417c9ad39d398844304aa4b3ff1983fe3e3ac238ea65dea4a039e0e46a64711640261b07f6eea53831bd5f705e143b25a16e5d732da62a24fa1dbc0f18731b95206959f8f9f9ae5717ef9a70f15a0cc87f44e7e6ad8a114ff245b09f13f5a6ecbc713a5d77295cdcc265720bd0ba804f1347d7795dd90df2bf4c2eee83b9270e5b762b870d9331cfb974fec2f0b9ebcd8ce2c918e867e6d634fa8ca2fe40541bc6ee9a13cac64197145f49f2da71e371abad24f3f577b3001eef30f3eeebc56530257bc0718d9823cb005760f4ddebf0f3187bd2ff4272c7611f9b3b199e0d3a59a06bdee90c5278d4680895872d51c869d37fd7dd695f33956d7cf4be228f56acb8618da37b44ec79b794cad629d092a9bfc58f9ee8ea28c5fd63f124373b6ce8edeadc253d675929f61ce66b70a2d49b18ccf2d1b06f17714fe04eaa52893ca1bc64e262a735ed4a40eb5985d72e92c4d62996540bb5b917aa28344c89f8b3294225544561df3ea81961366e3f60d79605d81e8414d5c84eaeb9bff4fbe7caa256b62dd261e8e80d455a287b91d5074de9318f72da1288e0fa93090b54b2ed325a7724484d718e2c4e4c1e44578aeaa8f734b568685f279ae9a8cf4a2960c11e36cf59d32f20d8e165b68094ee74d43f8330b6d66d79301054ba04a844c3641e6a9292a7dc8275ac77176df69af6579dcce9ca1d27c8914c0051cb46fa36a28861b624803b9d4537aec47e2cd4062889ba4ebbb4683123444a984c8cea243b6e73b854edc7fc9da47a5ad9f95848f26824ea2a3b143ca12601780dae79eeb8b15eaf2b923e2b79e8edf998c100fd9dac53cc3894829301322db6380678e8db486314eba9b154686887369318a284173df6b1a2042a2e148023c6af93d8d3f1b6d95b63ddb66fa0837ee24ceffd3d39abe703348d45b912c96695504ed5454bd654c72839ff313c879d176b139e1bc9e415900bd73b24de7e00787e0b09e6c8a4bd1c230b03c68cb753bf9fa8ea1d2e4ed7a7e109902eed042ee971cff4794c10c52ba8fc573bf4599219c39fae38598dcb9a44ee33ac2d3bab7473402b5dfdf257ce60ec1b86d27fd978fa135e472ee6cac2e9f83f98f73af8d63e0993198cc02ac1669ae00ddc9d54ba78b9e69399203f4a5b4651bca04016feddf61221459b8545a25d90f1b0b452d6bdf86001613d27460afbd4af5e69fad356d1f0c1344414a50b3bf5c98df456b22b62edacbe60b862ff78f6f1993d3b8f3164292ecc3ed8b41e6543222c9ff0dc5ad9fee2760ca9a650c01c02f0fc3533b6e581a339ed419bb26ef542759f23228724d031669d15405736e02808c2b96c34af80ed476a58b1c2a834c0d697c7041872afed5359baf821d4a5af60c8187a6dd85a1390e0353599f734d7e1280d34d065b2e5b6dac6faaece7b98b541e612654e27c7d3a15f57b70324d16a6d5d0c41f0c060381c71973296705fba0e91dd17d39af9285fbd9f90ee0f904ae24f930c0366f7f5feed31a5348d36b91aec0e6c42c46ceda990aa619a594b1ac88c5412c0230739bca2f6610c6f067396ac3e1c4bff044a0302ffbc1dba6daec19b8c935f76445e23cc801c6d97946e91d6398f050bf536afd4fed83951af753a89eb7217812ab302f3f8108403f8089ff5604a5c8a6e84ec8edb50eb001f93b21215c5beef07d4940c85e19ce0971154facda9387a8e6faf5c6d37aec59173e22aa28675edcb60359812556d0bf204cca30d1e6a43b490775907fe29b1af4f9d48ea327cb5351dff4862a164dd1436341e42dfd7161f3ed4e9487175162cdd1f5a001f25e2a289604b8699473e57233a99cb22a3736b10775553bd16cd8d395d19e9e1adb0e985a97da1387c50ef08fb040ca19ac1cf0f7f966596325fc09231288c4f70e31b7bd5d9f52f901c4f3c6952b1662961bd90174ec1621b625f33c8cef33c68da0ab7581b66f41607f70ad49adb546d1844033f4aa57308e4067c9918b27cada212bf816993779ed292fa30b372a6665e9f94e3fda174198bf40a537a320f8bda724ea352c9804a5738799fa96ae5ae4fe7c4a23b7ab8f3668342e63d864cb2da6b78b13c95f24a6111581b6dab3bbf839982f1963ef4d8d18f4bea889a1241b73730b3c6909288e233aadc8c461a1a233088e06edd2782a6255a630c7348332b8fd0900a65f5f20517274232c2ccb16dcae4faa905dde50766c2ea2b4d7a7a1f7b47676b97b05d88f792163c4c13afc53f5f7b0659f0ab1bfe32a3d4aeabb3e0a17543a27831c58f7376abb8c3cbd86a52bf2bc1bd1bd12b0d74700081968279ee61fb6974a34abd1715001145dc6f1f2518212126ec388fa8671353a2b56305412932e6517db11b24ec5a5287581d704d3119f40bfcf9c9ed42d521c42ba97de5a9fd715466e971f8148e740c3e03f2bb35ae41de3d87305f5301270b40d48524be3070bd7a1c512f079cb69927e477c98efea6a672ef97fc8edfd2882967949c69616e3a419f93a1ab8f19e90ff9a74e589943e97e1a53dcca943084b94ba0a7cd21710d6d33783f7c0053b5d07d84cb672aa9d3844f77c334a23fb351c7e23ce2dffe8648069ef4fd00cfa27e57339db738e79068a61f410c7d8e7f7cfb80be6674ed79678cbae09ad8f9fe6e002a0e0fda900f93aae9c4d2034977ec96e2eb3efad3e20c39f31de876e6eeb42811508254bca1df7ffb634558517d37116eaa5080725b2dd7fb96ca76754b675d781a922c51552563f8634c0e646f525e7f90c0f35d861af304edf0556ca0bb90f5fbd242f41dfbb41334aec88c74dc1d75220e337807f8408334d9db0a7ce2ba589016140bc36d4b02e498004d257f7505c4f6253ce65d5327f7b93a5d667c040e761e8e73c07f7e6fd62ead38186267bffa7f0a2069ddb13fcd967199824157a8ce7ad6467217e5f723e8cd2e55c86ce5abe57db4d6430a9c5b9eb7076d4cca638370eb7efe182361349592e388aae0a76ff9f1d286d23dcda4910eab231b0e21be34b9837304b50b15a681b968633dfe25c198439fa5c1a581976008bc4918fdf72c31ad6eaaaffea676afd6123dd09bd9ad34cd786d640c443dbca4ab34842e64b7c4183ff20de398455d9aeb3d98c0681c562dd9aaac0d89f8c470d40fac248f96847b519f73699d3aeb02b058ee27ca2ff4040fe52b7e82ffa0b949e16ca60200e2b82e0735351f127442b05b7983f19c21820dd6f312618e58955a8dde1321a5bee70c870ff407294b6bf2387bddf743780d572dc8f6746924a7e9b06940022a7d84f7395d3cd8f0bee0b9d162862ba37daa41a7d84012e3c7eaf111462b28134d24db7210ec105061ae44b6dc050a2060d2e576e52f4648379ea0d915feb577838a6d4500b12b84ae021d0c9a1305a2a136fc5beb5a8a1fee53c0e32594bba4c3de60b5c95f8e98c907563679c36c6354a1d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
