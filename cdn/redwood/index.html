<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fe5e70621c88c3c9755dd87954326dc91e144271839db4d9e46adca1c5f85efc64633291723ef369f8de4e095b44295ae82ebf8b455f816ce0ace7fb6acee67eb487cf4682bbd6193d977a53deb0ea11e0cdd087b03ce5c4e6a0a92f143b59de6fa79ef794472ced8357bad94796c2c3f068e60c6a20c01618ecb04cdcf72c3aff6abefa19ee7615a28a7375cb3f8b602fb88e3bbc2b6568939d293949bebd60e7b0493d3a047451f1fb06ebc868af9c75e2ba0fd50e4e6fcfc555b873a58fc5635a950ccd40a4909a8434a4080101f90b75b375ab0e273b063893807860db9c8159463a0b9cf60223e06abecf61875f95b88e0fdc61efc2f3d28f169ced64621c62f6eb745261cf858bfddcd53a40315a412708b917b87670f7e9c3af8485cd4b7caa25113a10fcb731a3a314eaca756a4519e5485fb0c0af288bbc923cfb7ed7f73eca1c249cbe848a51f286e2213d2adadbc7d3f48158a85b49e90c75b3cd5f94a06e61420bdd79005baf75b1c6daa6e7ad452ec5074afc83983e82d4cf938e7bbd435b02cec05132362b6e80b7ea2b973ab8d6a3e54ac4e57e4c3fdf0d3e542709713f0687036e21803ad7b57fc02f3a3e704dffe29288891305015c77e7ff487da0c67b688a918bfe9b883fb68d68726d11a84977161e27f284d6d8a343bde8189853f0404f68b56f93288598f88e98b2aa05dab741b0a83e912fc6e38ca10eec8c855b35e242f2c8eb7e52202c055e992d41d6ea542b707b34428bd6b0f0af7b295b59a608217c908625a9ff78eae12be1da1991d53671c1e1864f89ed829c0d54f9d9e7dee0f1ed2560181fb2c532de8acdccd6069a9ecd79ed6a89db591da0ca6a704c7af2324aa3ee62668a2d2e293188c4a5486fccfd4a51600ae532ed40819b5161605efbd71238485a7fe1a928177c2b54549ba71935802784785b968dba9b435cb6a69bd3b039cf0244d88aeaa8e48405f8f2c00e4d9dffea36c711c3733e93347455c053956f435d85d9c276280b6ce3d907a141843d685c04560a983d7ebdcd08b03c7e205a56698d85789dabb4bb2e7a4cea5b40388bcb176e2cb8a9567e500ddd6725744b120b0dd266dad02f37bdcb6d9403985f0b2e80016f6ed4d6373ae3a0098445d0275f95f27846b4978b021372b0721adfb99f66583fab91163613b5edb37910fe94c24a65bda1834a1f3f69fa38c5a914783f0a220e35cf3b0f0a14b5b74b8160ff7c53ad42bca9d23297e3a7434fa12b67e3715ec84780933f885626edb5f70a08b49774c36f4a15bed44f8af6b587743ec9ea6cd14812f8baa53a3f4873dcea151bc5d1585ff0fa6076bf33aad6492f2d5025ab46099b1fb1200f260d35a8df69eeb183721d0af6efaf3e02359e5d75cd15f4d7d32532cc611e443513b0e0b86ed90e69377bf923eefe6bddf5e963e6a92f9f9eaf3654268009c37f8fb4d113dc1a40cbfdf2097172f7a4b72c74914ef94e8416b69c1b00ccc8ec425834bd35747d7037621ae893781a3bc8a16e8cb6c0bab79508010bf7da5720db0fa89cf6d5eee3ec63ca043abf4be79aefc27b888099c9600a4fc2cdabf305691b7c1140491091a398269cd456e8ce71e030fadb0b7ee9063ffbd92496f41a058b42b467189dea81c4ca9abae7b483e4dde977cb51901c5c76bbd7d27a611f5619eae6a79b06ac4b8e1dff5678c995fd9c053359c5336ebf14cab79c239d660099c2f015772d8f6c5d06f22f68142ab305175f05dd0bddfe810361a1a18f4744f99a03de3628473d07e40de34d0676521f0691f7f1ba02dd63b392c7a875e9f427aae4587307ce80e7947ce882d68e5e896d94c66493172b79a7c79cd16825644d71c3b1588cbede83ab9c65596784894023e57e9cc0cf9046d0a677a20ddb4a9fb5c50edb696195bb108c38a5d7d51258e73f4b072aad7217bb30c5168a76c6dba0e61a9bff0af66463ce16fb28031b0711b24d9ed3434d95a300b77a8ca2711a1ae62b14122a962d8092703e3bfe9abadba26e35419449d270247034e26e9c9ebada4c9d1aa82cab8abe33393940a7b899496ca8f78021851432786b6c70dc046f0cda2921004ab73b01ea2b59612edb657f3674e465722d323e5fa9a5e757beef1fbe75b8dd43d62f5fc6d07dc094d3eaf49a482886722993ef3c9b962fdbb9a2db14b8b67d7ecbbc8fdc4ce2ea768d54d612f0849cb7143526d5d94d3e6edbad496c968f482709928495e83e5871f01a64bb5730868e00c9f270a647323d358f977f79fb1be0f996ae7dc2fabfdace3c5cac0360e43770ee923d0655ef0e7506286158f34c25895930e6f50a7d0ae4b563eb5f77b2c96bdbb99c275c4a6f64beb1d428f99cd6abc3a35ee3513a17dba19a688999c8928b26fb910edb02994933775c4eac564f85a741013911c15cf45d5b229bc6025a74f258d3368a7bcdd08a3e6d90b0bd38f20b1d7172bd8109ecca5dce7b206a147437a5d8443e11f9d20df036a4f952bff3bfc424e41f137834a2bd9ae36256e97af650aa32302026e4582528078d742daed9f20ee843ae1bb4c037c87a4afe417bbe946050b838eef1ac06cf9dadb74532b1c1edf8688b20a932662e7a47eeffc56c8c45b1844a4d92ea792038e4f7e33abdc7cd31c7ed08490dbb8b5eb07c25f271cedb736ba7f0456c3d6c518f0ac9516a2aa7fb30d33da153099db3e733f02aa02a692f991a5175013a3ce2274f6b6502a11359e2664a4da282ae8c4bbb4e6c1c2edfaf1c79a35527aa74a20411c36e44a1c07693bd1dbc763e4b49bce2384ab8d0de00f55b53fc26765851ba3152c9bf013f6e6c8e3b12ce5f9a94ee3f83687a511a8ef4f4ed1ba2d8299a27bbb38f977272e418eca35abd2ce09146b783339445bde780aa6cfdeb73509b62e301e829821e8614972bd7b6d15500a676ea28c2f3386a5fcfd820f3522c98ac2b5b2ba4de5a787e8dc67ce79d2bc6856715b7035bcad4f140307eb816c0e931f7247bca63ff9c556281371170013e6da93b81b2a8787d00d6d9cb48d7e798e6da4ba0e93ac87ec5b4ab21e1c2edfea70d296ca4fb29c1cedf060619f929f6f60a6f3bcb05495d8f668bf45331152d3f0247c95bb8e81efd406b994eab030a14356ebf39b9f1218e921de1943c09d5cd4fece170c85b4eabadf18053a6b5afcd4b9183d60b71b0002c7e1026c52de032dab0ea148ca32e8e02f6fd8316d474e50da3416ed40845abb3dde244440c674692b4fa54389b9399afff50f3b12642fcc3890d97fa5c01c347728776f1a68b9aae48ed764179760dd2b6ebe2460990318049b814bd484c3c3389cdcacf65064037fac172e770325d1d88ca3a8d30e97e018fae8c123e497a2b0eb3b3ce19d0a9f52e07344d331e9f518798387ae07acab048b5f8053868cb6db2b155154ad4f4e2168f27e82461098d2e5460148413d7f0d38a0641d1af9e832d5fb4913294c2b8a4b44b71de88a44ae3321e5f8ef68ab8654a01a8f01270d336a0e8b248393096eb3337178d609c3619a42937b253704e74d584b3ac32ada59b6614bb13d89ef881fea2202ebcd9cf389a3a80ccc2c0c0802445094018af0ee6a4cc8f7d12df067671c2a62ade5591e781b482076c8f5fbbb4748aa2edaf8f6b0e8f51b9156d8066122dcab06d9a1459e94efa4fcffbc7ebed22cb230cfa0f5823ff4ba6f76251cc22c1cb307a2d64de9462fafb8e49160eee2679d4fdedfda961b16590039e669f2698396214c85a8af06df72b0aded3d8e85527523f799bb7b90289e7463564270ede24797f4b2b1a2aafe1618e050d4a6f9379d0a93266b344ce437c0a18950ffbbf7935b92e311edc96fb9a99ad62697e755dbfe698eb11335f9ff55af9af655167230cb19e50fa3ada48c5b779121119d9ef28ed10f8fe23ba057eb6fe64f105cfff20b7211f51e672f3a9e682603579fd5da0441860a96ef8e5b2e8f42859d7872a2963c8d70b9fab6bf724989b49d1a2442a5c75b7a62656b3bbfceff59df3447ab4c6f9dd95ccef96ceca96f63fd13a206b1a21a7a6729b91792512061e7fbbfbb885833c1bf97eee8ad0efb005c14fef6973f447f051cd9821827ef8214a7296be7cde0177ec7530dfb0c7eb895722149e47156ff2ef644427d3e31abb18844ebc1816f9a5511bace417b7c733ff65c6d4615f11dc2122d19811daba1fc1fd02a8fb412df60d25bc6e767bd06512ac15991fd35bde5490d348191715093e80f3ba6f3f017504aea8c171fc71eff3be15e74eb06dfd79da413d845b13aa9d6344c9d0707921f9fdca4d11bef5908cbb7805013d70dff0cb3775826543d4d9e1fb1aafc30a50fa4ee74a96b26d64f45118a7ca8fb8841e6c1f10914fc12bbc46c7d3d6b74fe5e674e83577ccc43e54f719ea0310bc1c05e5491494b42ba0b3a4297ac4763f5b184bb579e466c1d42ea7865caf92f6caf35dcbe6f2711029dd1f1d0f5c33da98ea0e80cf6406430d106e6b28baa34a3b23297e930bf30e1793b354c6238f0ba81150eacca4af98c036d25f96cca8741dfbc1e7e5e4d852b9b2987ee077ee68e1a3deaf70a0ada5413736cbad35886292e52f3fb5c300f52b3eee81fda31d070c153276b5d211bcb3faf57e881ffade050fb414d6535ef91afffc4ac3afb2ed5fec7bb60078477dc024d309ba9853b9c8dd80145e29e8bfc76ccab1529696f3ccae46eaeb228821d7a91cdf222693d74f87d9c0b2306c4fb93ede5a0206f76127f7d213a0eac6deb87acd8a8394f44b3e698b54e51d282c495b5ce00d8028329f8b219e6c7b43bc89660b4345683c15aad47b2a1e3e78ce526d3fa8b203bdfdcca98fb9605444984c960b3ebeb8b0437dbcf6e38be2225e3ed8320e2c6c6924bc4a8a7b936b8d6f82133bfb966aebc3f75ec840443bbac37f5ae0638c636c05f688dd5b4884950059b52901e57f1b34a5b3cde8a1881ff961be7ec2a103a0d30b30a6238dcf97057783832b7ad150ac88334c98f614897a608b7a073f037ec2498f2daa1a6a642b91b7efdcd7333e8b504ed0ea97aaec06d398852e4bf7f3f3c1cd24a50792621f8cf88ce3f5001571aa09aa24803869c09dcb38158c99489756b32bf1249c1bbe09fd283cdcf8877d7deadbf7f1819f815f5db750002927d121fe81fb7abf8d553f24e2a0f630ee2e890a3449b61fc9c6507284127bed6c42d14f75b2c1000124a61ef0f34a07f8340868647be63f3e12ff97c725a0438faee479a6ea1a79dcc7e4a66132da5edeb1147f30ada6bc35026005000ba8861a06a2340ad2aadd07d851ca2b17779b2033ff9fce0070735afbb6f613e8f0b083a4f1e590eeff9209644c96bebde0e0be1d68df52c7cce38d88175fb9c5d862b910cdc9b03f41e07d1f1324a0dad4919752930ab2306786053a3c164925aa7b65178e1d3155ac119abc1989b6f576150faeec81380e7b14e076ff06f6d2b227e4f7b2f642779b861f9dad64f1de131c48c9118f7e584816a37689e21a5ed060861b4863abe35558c79ca909d368b23a2a122f3735a25f59f79d91294d6014fc35e0e43b445aa478e0485b8a8c1fcc972e622f1708ccbab627f2c1f190c82e1243a90fc8aeeb372dbd3408cabc5627fa34545cda8938831133977eb38dae1edd1bf43aa58b1ae5d50054a273c4754aabcc100416c91c3c86c33e7c3222dd1327636c4e874b348b88e8506da5f3a6010676c8d840c323a6bf2529b10812b04335a548e95462bf823a8f786c3cf211e84363a6cd61a902b3393961ca85f5182bcd19ab1697347c71889866e32ec6f6d5bce044f071ff31fb59095d1bfdf863ec66227a7884cbfb9b06cc8d23c09fafa78d7bf00655166d36ea9f5bb957a86cb4de5c1305574a2ee1b53c7fb94a4514f6c5655ecc6842fbbca70bbb01397e94fcce7880e1ebc0f2016144d34785442634be145c2df162fcf924f4ef68c2bce51b4faa586b7251cbfa37028a406186da2297d19b4a90cc7fc579493ed8f70408c963b381df8f68edad6d1a8a1e4f6dfecb75ea4ba86ba8280cfe8379d5fb010da0faf7d88180d5390ccd36661f731b6f82cf7f6c5c60f08d86fa69b94761a8cdec8bf0cbf2615f75b49b34c3348e549989f603e229096ec9d50bccb4d884d571e68c341cc952f194ed812122bf7362dcae9a0783071410e5be05331d9d7caa3f772ae3bc5486fd382ccb9bb0ad39d6f3b26528027f0bd984ed891d69fe5a707b70211441299c9c9847a93ec8789d94963e08368b02013f4a7c3b9cb63c378232bdf4f95c766206f5c8e20dd42fffb0c1f716976c9739d5f13054db813b275632f4be66509cb43c349ecbee69bc8a91574c1037fe9a25e2803705149b0c6fc3e669b2ad4294ef14507e64aa7cc5a63e0cd5b1b502a61e9f215c8c9bd2f5d2308e5998ee51868e8233add79f43e7cdf438b788f5fbfda0bcb5f79e7b33ebd2a5e29ef240f03698635d8e1cc54715d660f7caa74e4d5f6e55dc41ae60294f5b176d4e0c5c536cbf85750116ac20c93619068c0516c3c2032d848575889af95a3030193e72660fbea1ce14a72adaf66d44cc621e0ac579ebfdb0b1b7c868e8742f3789d67f95d805d37be4d9721b8df5efe466179fa4893d372b3727fed9c377d60d0c0d0f74a8e6581019c083ad7bfaf432a9d8f15245b6f8ee9d16c3f3cf9a8c5945165ed2eb35d042a3ecbca009b49b13654a79e749a06c16cfff7b60a44dfb46d6125d3f1e817b2e5aa9070b1d38a2d523d6cbad7ccd965b52e0cbb31e12f57644920baec8914af9ef62928371dd8c1395d3be2ab1805271f4bed84912717f34d4928f7b63b030f3374433b3abab99b608c29383471c262d47feecb1f65ef6e4bd8177f0e25ced9823e8008075c2e8d70320dc6d089b799784423eff38bfa942c2a5835c80496b097663c4a5e1d61767a530671d303c4e48620e7f179ef85379c80a3c61079291332770141fd2bf0bf1d71b7f60125314163488dcfe89fac0e45af5f68f49641f300a1cb25ed40311fe59c9ef6209d1015c2df47a6743cde84689bdfaff3ef0c2faa1d391d5df3e487e4f2b83a31802e6ba73ffb28a6ae5dc15a42f796abb92d0502f41e22f179bc2e4250e0fd8e7beca9ceb0e24b366f666c64c53ef56fe8f2c544d068d08c5c14fcddec8a37d9e03d0dc566e5d221f2439690d2d3e68e8f1bb40e5a42a9441bb2fc889fc6a75671d7cc6f99f0816abf4bc0f5af4d5d3ebe3702bdb65a655cc2a4a325b3c2d9bbdde5b46ce97e5278032f5226041342cf7c60a6c6102f87c90ce63e5bb1c43a27b05120f3f9662848c282c4bc7f85410b0d0383422700981cd31f4e176275c1bb344c8eb769e0f2bd7afb6b246965d3c7f464fc2b45d426facddf26d6d8b928abb1ea116bb9428fb3ea8897272a000f99fb6bd684c33eeec8cabcdbc7ca617edfeb5aafe0122f8f8aaf6b345503f5129e5916cff88e8ed68a165cef9cbeed4ca710e3a62b76a8fd8930004e6a42fb52f26c5cdd099a2d50d031dbb464da421b2d838ca4b3c45af2787e465e0f40b0b017f8903cc6dea930a5b314fef09c45103308273c46eb92bb88d2a861a48ad46d60fbeb3a1da5d4c183d495ed254801c8b327672fdd8052edfacd875929cf3ffc264bf912541682e8659b16407242debf9a55684a0d2ce2093dc203c3ac0bb82a739194b37190d82643920c95693b1ab8190f5c48bee39dfbce61281854259dc48afd14219fca86906c5f6adb04c5a0bb9ab12bb716862ba4768838643ab096ec0f2265cb696da8029aca427f78b2ba90093c7e55d21e30ed18070b36eca0804688dbeb30a5d76ff74bc66e791e5ebe4fc9a2b1e0078aaec33b9d937ee5d4a7c569c3d95677b29d68899d7fdc94ed3f60be34713af2a56f63ce2d0fa9b027950a8a22be79dd1038bc97a28b6525b3aacf1da1f7d2cae483ff5a59fa3e5a0ed341e43fa96b0386dd168238f027a5693e0c1d97d862c11fcc5c90f0a6b929e41b4420098c3634aa6f24af085d732e081335a884181bb306903d4e227ccb7187ac0158e0673dda4326af8d37f951db5b74c26364b4436773c3b7f65296b39ac50487eda39c2f1d3cce3579751d7a1f6eace4aa3e6bbaef28e93394c474707e3fe86a1ddbc8472d4dcd45182f45fe6a336aa2b5c18dbc58ea42bfa8b3e8afc3683e135abe03cddbb4b22776b0cd4b95cebd4ff6287f0567907b216505ada9da4e9bef37f8a619dfb8391933b8c7e47f65833bd9ec8987d9c8ef425c64c1abf56824ff4bfdf48ec353da33496dbcd5e5a4c4ff99c63e7a2e2109402b5ca6ada7a9a947a3607542c046b854081b26c1156d07dccec77f512a85be185b7e17dafebe30fc9f9ce14879782a3094aa42569f13d79a32b79250ecb0b83aaedc500cb94e3202883364283872cfae43f9846e5fc582e0873687b45aa5f4f96543a5f8f2d971d709cb5c16056749827818d248659383354cffd1db28239d88744ecd027b9320de227e6a2a555cbd25493a4d620b34f094472376502cc54256780a2037cc2e593048b36de515711df250ad4a11ab42f12010727dfcbca278ee9ad7e1214fb1615204a5517e6d468bceb89687863dabf02f2c86978346f6fb73595b54aeb2dbb1c70b41a2de102a67953ab13540f70b5f835f9024bc6ce699836c65e1455a411aa8c4971ff2edc18615f7bbb30a26749dfd26d6fca6d893c1ee429af0b412049d9ca0e2690b92258ffe348d2f197cdacb2c7c6bbd96aaac5f7e2425d34ac71143d4dc6c5d4c585d01769100cc1836c6b0d2b274fa2abe7ba829aec342a831747755c1891cd908e90ae6e7214a2bee8421db9afeef87cbce4c980653c75b9f0d7c4ab377516a1242c041304f791b521489816eeb7d3f1b0c144497d5152d9a16663f03fd0917a72b2580954221bc64a8693549ecd106f8d24aed68e1681100802984159e9cb1354d4c2caf96c9e3173ac49f4bc13113807ebdfae64782d915b5c0765701343201fa2099a396245d48dbb360f11864a1dbffe9b8e9d248e9ce28dd27b31858858daa9195026bf9de9294981310cd917b3f6c6272fc541a22dda8bb3beb22093f246d4b59f7f0a7c622abf64712e35c3235e5be9a114b0c57f3bb82194a8e25370594ac34de8b653476954fd643ebcf8ed2b353d7b581304b6bf3a61af6637d354d376c4ebe316fdf615d42c3fc80f02a537843050f53beb3ddfc0b90ebb8b09e15d3524c6ec914f4a2bd950d80be597a7eed7c8589a446957aa31c83712a4709afbbc1388902a6ebcd7ea151aef0413d4ab14b113447b5e92e349a1af951926e95b7240913b36eeafeb5581313e46ebc3636d344d6d3f93e5caaa0042c5b4ac724ab6e55360356799227a4ac1d19c83dd7c4251cbfc6011ebd12c3a93c011032142b7f946400f1fbb34bf1be923e55ab75445d996070882a3172a2c420d5137fc7b27a881124b6e5f1d6f04e86bd7ef33c0c4504ab3ae1eb24b82bbf182dd3c2608be691aeef0c301288b13811e98c21524472d6fd24102702c2d124efdd2df1d10c78a08a6d1f1ef5d81ebc5fad8481696b6e96e2de97c029e90cf0e66bc18398e69d6a58da778f9ea5761a3bfea419f68f86d2d9f50d400447a074f41e0835259ca02f48a5c66958c531eb09d1b2963a6c24d53c0820436d57edd5030492e015569c0fa04012b69c412c633134b2dffe073bac4d8c537e80755b395dbcc56ee169af968eaeaac197b6d971c0000b72e6fbac48d0083443d190f02e27ac66e5d742ce6f50ab69cd7eb96c626eb6ca5c3f7d8d0b16f220c8fff45b791944cac2679dc476e509f0c6af2fea431531c41a2ed7bed2157cb59a830209e3e93c7f764855962bc963c43a34a282cfb4106d1fc7431a353d5ca056889ba8619be347986f9fbfdacbdf272e388a7457ae5954c3b6859d4df09b14acc57b2dde87e99360f37103788c9fc0791724c8766e4c480cbe4210246d5e277d111eb2ee9d3074facef2c4aef5b2d23d8605c658b6715bf4a98355ad6af0ae5bb8f23ddd0a10afff9dee388ffacdfbbe610df211e6dd5b0178ee3c6bb1ebaf5b7f6589d5b07dc363fcf414611fdd9c7e9f0cb1d6667feaf5a040a3f4565adcf413776fd7ae8169e96ca7c6e1e6a538e5d76dcb35df6fe0eded2519563efdc43981af118c766503d39d4188cae7414467932f3d52d19084ac757d0a1b2793b12f58becf497dbd9582ee9457d8a75367b85e76cd32643cfe08da92e817f6e1a0dcc319af4e93fa776ff6fe902857030a16a22e8dc506d8567ebf0700a921ff09afd3d42503d5744745707298bfb8ff29b2fa84009d2b245853900e50f5a9c795f5c4498d43565aebcac2e65d0416b100418d3179e3c8a84f4b2a8eb92b068332dede81840a5a6a3c249e09cd035b328a04d6e39b47be27f531b1cc4b85de885d846e7c678422f5519da7aef67ca91cbbd965fe0a007fd10214a355f99ffc7a69e0851904c8bd540bd18063020075eba672da856f51898f65f6603d3714edc15c92d08ccab59763025c5e1aff78417cd2f91360a62270c9916f4199703d1f0ef61cb42114ce5f15fe86b30394de6f50196f5379b1e66da054d640227a7322662cf0e06ebbd090ffd1dd5e909d000b4ad8c05e5ebfb8315cb378ae1525705b3a56f37bb173b98d1beb3e4e8b092aacb8b48484a40ec7b37e7330cb6ac48805c4c4dcb724bb35deacd4611a0ca477b57cd26e647e3d426e6fee9affb8de0c0e271405500d8158273eacc784c093c626d1c8d3fd36a250ca54862c0629038ed7f572190078a5c0b9bbf021246c58cbb77639bfe4de2a22b9dc0c1dead8cb334f31d78b5d5c4c326033001d967d91b7e8a0287f79a62c5bd599b3827ed61f78b49bd5fcf413ae9571be6b5c5a48bd7ea58bbfc2d1477c5b85a48aa9025752e29ca3d109883d8ff2b9a335ad86d8d38bb29b45335d508e0fa7ac208de49d3ebce3e83c30ef0a434ad42abd75c280537da80f66997ce13c3eb14d0c11fe71714736b4c8d78327f35f9d7fd2c7fb57e01707adefa43906741149d13e65ab503c25da49ea19863cababcdd09d14e086729603dfd896e0881989cbac31b56a3cb7c07ead73a4c77d9745767bd3cc9babba093c113562b4c0ff03ce4a97b41249cb7d0235d94c863008c1e8dc9d82c515b51bfabfc9212d318533c31e87077583d51f268ae1c8dc5f49066ebe92ebba99ac5dba9616cb81ddf1da75421434cfefadff8c6b4665c9230de30266f4df3705d14d6b37bcf88995cf040c479a9ee88bc5f3a79f2af98093ab88b91b0273997255d448272a554a27f80424800f7e75a3a6207d478b087589142c6868aa2360145816837197b130e826d212c13aecc59177f20b6f9255a9895eceea534153807a85acc34705a261145e84f34cef2fac6535134664e7f27d76e060fb7015832584800778468fda8ea022a7199414a1966dc3df76e709efb6c5d8be7031e6d9d3562dedd80ef2c6b42826b54e43349525ad4130c3e5f2019c469014f02095f524db4eea424d7254ac75b17e7a912eacda6d8a4a85972032f9fd37f3f1fbfe05871607f222951b26fed515fc1185f103da40b496466ad88ea3d280383adc6b33c4ad76d481c2b95785c507d443e277febf453188384921004e93bae513a4727a4100dea90ca4bffb73614b80923a8c73223275d2531d578a5c3a97cdcd963f32b4ce2e7316a43dd6478869632ba64c39819edaf4c964cacedfed55245e90cde34a0c38e79458aa2f66877229682330e7251fa8489abae068c22f74e1e9fc6477f180448f9a7a0727e3ede1db72c42e65d5643526b06fe0da747897f0dac7c1b82b23e6e8703aa24f9c33b2f746d7ab6f51d10429a48af9cbd798b3b809e2ba351845f4d6ce53f594486364334d6cf7e8eeb6656f746f8b2770a4812b3e4264ecb4f1a22d563bde7622546613add7031abd2fdc860edc6b0c41379748eef2a415281c690f512d5c90edec1b6a79f499a458348b01777a61bd5804e27bf1fc8548781d5d852894037b15a32829ac7448893e5a9b307465fa939ba7e9133ef94fd89d231a76efb5700c440a2387c442e3acbda35feca980191da50fe2ef8b5f756fc0287470114820433fad0d60b0a20dc1b321dd9e03d41ff3922f717edb7e44ef7578f74d2a08e92b5477d2b118ebe61e26e007c809dd59e28b380fc9a73152b59c388641cc19924ccd25cf8d681ea42b0051be3fd9b3063f022211a44a3003e3c4c0c912d20c556ff2553cc6a116b39ed3bcadbf45fe662ae9694ee09ae159a1adb15444b368f658701850cb3fdbcebdeb02bd0fb70e0c610b5ff0b3c7d839bdfff07319465e27fc03ed45ea790cacd038dc8dc10c8e89f7ecd61f4fbc0c618f29a06d510577761611e2cbdd474dec3b35440be32673b5a2a32eefbb27c9d0d26d117e1143407a1281faedc48091ecbe09e747589cf7b656732606b0df8c473c29bee37b33d4195e34b100f698f941a77c847061ef7f01e2aa659c28d076de8e497d6f97d2210bb71ed3ffae1a55540c61408d5f185b327c1ad32b21a54d716c806641fed3e3b7bb8698ad0276d755c563e3d13c1479bbc10cb53ae4767bcee9675efe2326f9e1470e1c0bca9058d4dcf7e607587364a15d0576a78553e442e6d881d9dacaba4da44f9ec1c19dc2d07244eaee805d06b03a3fd0133193b99456274fa942665b7f8845da22e67b0d8a224540a8f26787474a257102dd742de0b0c166132761f8e5c4923f157306e7b922022540c198d8bfa609fddc369891f61cd3e86d15630cb09f05e6aff21e0121722a739d3221344d54363f5254da7ada00f7c7eb9a87ef8f30f2a294bbba9d874ff0795ad71a9abe6710864d3f1b139535aca5a6b7c6a1cfaa17fd94ad69a4ce3a20f370bdfe4971c711dac4d503fdbaa897d3ecba142eaa2a278e56fd872d04a257168d97ac06ce4ae4de60213cedec13edf57277fd3b05e000ef0573ab179dad5cf83edf256d1cbf2e2bfeca3efdec33a30108d0a1e941c96e41bccef51d5ac7c7e23245a3d20e1a9408a72f84eaa7f7adb4e01416da765bb6216dc63636cd894e794793aad865eadaab344b939bbf3b43bf0467d746a3b6b66935d0dd98242add7693729d5b659f4e3e1c2ee1caa5b6205acd52a74794f5812d8043cd880b957c9b8b1409413b52f1db4bcc47a82bf41dd9417adaed8acb0e384a844a9203e79ad510901eaa61b0ab7c4eb3e885f83a890977706a0a9bdeef9fc56362fccb63b07c679aabb70e9b9a03e88fc3a7f80b6993fa8a0f8959ee1d486fac8b8741a1db4ee3459aa1c57c95933a49002279c0f0d351452e44f55f1dbc258ad543f39743005da781310160c8d1ada02dd6add06e2bbdc6422aa0f8d7050d66ff6e9be37af9c1110cea02e4ac137fc53b553b3000e5634045dca70ab8194a43a0cce957341c0a4487632041455479de536ee48a5b81533ee4106a52614fa1b6f53b7e743757ab0d92b4f81170f39eb8dbbf454a50486d625fe67705b9fce18f6d53dadb478cfcfd11c0da747a6898b254102dc2da7deebbf533c0e63fdbd63076795bb3aa5fb08ed10ee2fb25edfa7ed1445610c68c0fa9decb8cc98bb5ab5aefeabe248c286c04d2d7cffe2afc031417835019f4649baf9dc45b41812eb80d0c8426412b8600d3da9143502344638af76bcea97a7fec8010bb129f4ceb57a60ad3427a8d0f559972417273ef72784582088c875e642a06f74b2bd7259fe4548a95ea58287fb344f0ecb228f7b01d3f281fa536d6b799d6887fef6bae91d20dd1516d2a7528fa0d18aa327e96c3abb185ca0fb249aabef438a05243bb722a52b19da64a29bc117f9d6b2e650c50348c7be5c998cf2cc1b18c2d57e0fa86fc687546c3e07e332999e07c8b62b49de62133c27bebdc1d4d09842ce7b8f03f5cb6b6e54721525f2588aab8172fbc1d01ee2e5c8975d9740c69e3f63403773b890689744f36c100ff73b074ef364b0f408fd67cf7f0623d6b2aef8539f46ef8f48529cc1b1d8255f1736b2377dc804a9ba523a8d95331daaf00d57f54e9ea0f06685c96473140cd6f026e2811b0442a72cdafe283462b3cdd19f7217b8ca87faa330aea61143b190d45dd634e9c1bef582ee215051186550f6504b097b7b4e228d027347775f455621a515777b57a52d58c520b9af5a808c743ff0ad9f40dbdec3558c9f42be5795fed400d528f12db73cdca33909274840c2d5f4a5fedd1c71b590866bc489db4419a8c6400bee3f8c37210bcb9e6f730e048541681e49658fbcd26a42d2aab255a26a6f8122f7186ab43f48ef46f6eb67354be780123860195b9fd026a696c308155563b6cb98396d4f70bffa17bb622362a6bfd8ed5ad8731bbeba09b1b184e418d4f46338c11a2b7136930c2e82009306eea8bcd008d55adea2a544219a6a7223236ab5998498484c561ebfa56fb3321d84036343851737264365e0fc499a8159d34cfad4ecb17720c43f4baa948c00d66fe17647c99ea60aad4e2cf71545870e92ba6c90be99d58b1b91dfac7c96021ca1ddb9ca46fdac9c7a98c700c661fffdb5831103bbda22d7541f39cab09af7725a09bfa7c074ee3996fff983003771e19ff3b9be5e6953b4f5ff05d5ea627c3fb683593f37cb15a7d88e1ad2ab994eea0606230a5e2781813516ada3cde736e70bbd2d46836609471c0113c95e6422b9371dfb7f5b08471546ef16f03c1ad34aac1209e41a99bcf7a67b7464db4e28f624bcb4e7edc8ec0249e911c26c1c96af5ec6fac6e0f4fc486d907a459d6dbd0f1afbf41ddbc3a0d8c8697bccbe9c9a04cf10c0c6f531374edf9d34f004a9f1db10766605627513ebaebecdb1d889bc4e2f4305c27519ccb0b347611de4080a28a30db8a14c4d34bf71a5a101f58b15ac9eda29949af41df59574b3076c0b96e098869b6a48a4d4117161e250ff1b8ba4eb1abd9ad58d6cb61c431b4f8aa25498ea5f4440608775034c043fcb7edf6414f73bb18fb2a7e670d64aad860c11291ddc121c021584f91fd62929d942f5e36ef6e4154712c024e25a8f6af1c1e6e5458ab997c78a8c22d8ebfd3e82c5a5a7180b545b413c3028381e3d6b7835360512508e0a61ad7c70e6d86a7933c5aa35c757302117716870dd1ff6679bcd548b0a241a8b87ef01c14476916c9fe95546b7033b41aba3203d09bdd8569f27ba846b110bae9b8d5a48fbe04b3a0741eb77020266cb0db58843d8f507b48f00b10790fec172ca5f9d256006374feb65357f277a83af12d57d8f95922ad0fec6ef92fde5d93ced6abd87bd256784cd3c2630f4cabc9dfdc4ea6009d5fef8253b26569414b91eb3b497d7280520f194fb862572506cc0c9d54cc070ed7c8677a8146c7fd05b2f4b791d801300793360605e525ccb89f320e6f02ecaee6ddfc2274ffb424bd54503e85c2038fbee76b3c32c9b4f90d2bfa5f975617a640327ca618c20486db33903869a71697f606bb4a9245229c839b6b2828c673a288b02309f7f46815382b017e4f9d5ab47cfc13e4ea5d9863afb307a92e654d0459f8516d12af18c69e82e5bd250ad1f0080985111312ef296592155be09c1bfe8ef1f6f6466a772b2e8a7279676debe2263ba071b7cf8ec12064031e7034fb522d85442f11ea204ad512d73cdec075b2805cb793319ca7c8bd037e0cc9d17130b6a8953a385c1ab14ea5149a0be43bf2aa4b431bd4452b21969909509bb53d5be03aa13ea3433551fa18812e6836767d97468b709dfde0f92e1e0e14e77d86c2fd646c900fc3bfd7e2881873b8659494e0f1b7bd969d923a4bef455fb4072e342d31c534243510d714e8631c313092c714310df45f62ccee0b9b3a4b3f8974aeeb6f9db9ef6cae99797e492422cba8a3574cd6d1377187c921ab89fefbb32c8a76c34a06b21b183ad860770ec785b536f0da6754d0cb124dc763a0ae62039a087bd4f987ba5b399d5579f7946a6029b7e76838058953d9e82ab4f4caaae5f9d4262372a66019a6ff04b922c30b624feda10f6654f20d6e7dc09c7d305b2b26c2601f1818385f4198680330452585a81a8c3564d959b56202ee2c02f32b486de0c12ffabae99c65a08d248d9fb818676945f8d25a63976fd67ae51345b36126e87e1a497f92ce7d547145c4e172465f21b41c53d05ca97c84dc73edf7304b16dd921da170e9b673bc9d37f7678aceb1830e1fe0b70795baa912539c6984acb271ea8862affeb60d83bed66355402970ed44f11246aeee604c4f56d42642601c09cc976c5ce05c678d423d6f0d63420f4a6dded3515eb939969805c409d1617e162569aef5bbef3d07b3aa6b35c4abf6b0857bda8aa5ddd7fe3a0573660db8726e1905f4d581f6a86823e5df3bd622e3f58ab749d08f830aab9ef543c8e13a00c5da02dc8078a57175035a38332d89ebb6f2dbbf69d6af86b4fc6878f44d3a254ed633c2624c4c2e481ae5654f8575599b1d3ba30a55c192af00207f0e752277ade6f4ca72b396d8b5e5249c2c86b2d2fb5556757785787a2c40c5f4763ee68f5f63b8fecd4d7697ec93983452b71f560b5d303c1224d5e64ff846c16c0571077b36e70d2778e45ecca8c99fef4a4d7ed0fe316a93036c404275b4e02c08b6c88bb39227d6b6c9052682978d432f96851117efc6534e90f211d1bb622b3c576869e33131d12be402d7b41841887c44c9bed8671c6e5860d4142e4973511745e5230356620f97b0c386680436459e78552d170eab5e5d35b2bbd673cb0d0dd9234bfce28af50122259e9f292c5f1733c661b9e9f1838725355ef5b092d53b4584a4b948bc394d9610d9c097399d4838197442e5389ed0fa5e4f8e8e3b38552db4e9e1b66f4a88fae00dab2e46b786228aca1ab557833e2454739790a6887b50b6699ec24d2b4b04d345c42a1ea2622078e207ad7eb9513f912ed59891887edd543f86956d87e69949d2f12496c4866ebab9f24f62d62eaa982757586dc28d125e72ae4e615adb2c0e38510f48fe14799598b58484eb9b1c5cd6b88175d178fb2e0d728572decd329f9653565bbaf70337065848a961c5ea47a6ec960b0cd3de190e719de876454e33143ed8ed06b8e7705042e7789670db354df82f6a7d0e323449418afab47a80539fb1edb1ec5ca76acf8722e3163ffc44f17ee2ad676e0905be03483f5e138d31d94bc004247127ab1288ac438fe29348b5fa1ee856e2933aa9d1f190aca4e22539b13da13be657fd7dbbdda99a1bbf1ffa52ff0707a753e2d745cc4976e7c19c80229045ac58c6ae3027c7f0be2fcba72b3e9db85a723286a97abb77211f7b41b08b56762bf1e83c4fc4e4146355765ee4cf0f9ad62b192b25b239826c25c822d49d0b78d90e8abd06cddf25ebf1a1f498e5be0aa777603fd6785461f54ac9667e94423f91f2059cac7f54642ac75b5e8ed26ddd3f34a84c286575ef7f0981806c42664e61dc31f4de8b65bdc27b1a8c810d543d4a6361a6b74b6f4ac812217ccad3040acbb56e532a6d2df873ee695d8bff4d3ce9a4dadee9c5f504f9adaec2758843ae7b2173af1b63e1b125c35a201108d630462b37e2941c9f1cd937db9eded01ebdad7726926a4e71b47e07260a4d22b9c5f809562e4120c627a492be18c1c270a244dd0101e08a189b14fcc6e86237a01f2c9dbb570bd843304e3f0f1c631b6a90ab6c4a7121e20f494537a9b91cba0dd5cf6867ab4f030b2115137bb882734695a599e51ab1b230396ce93260a96f8606bdfcbc72a2fa978b340d4f12b8bf5e78ddcd174f2cfe96b48199da8510615d0f15eaa09b19b02435703de3b479da2435bf6e16253ae5e25d210f52e52d2c6b964a4ea78a4f36fd7d787adf1933bb9850dac49053a71b39a8c71b89fe10840193241aa16f84dfd621216429e11025e86f5cfd883175eba0e0152b74c1de3aebbd4b8d540a7d7c9f39a468d5a7ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
