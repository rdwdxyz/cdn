<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"868c3d3f9799e04d45ecdc3f551979eea832612158c5eaa87113a24876ca1fa0721f7d5f20ab6215347a1ab1646a8cdf93fe70db932e4c0838fb64de338df5c5f24425ef67598c2d9e52f3fb9a8faca9801bcc9da5f07f49057af340a87a2fc88d1e4c3e36bef97ac6d2a312cb80a90db711f91658255157252616b7191a55e2d314b8da9016a98e72f66b76c70f1e5f9c5d7d3f766110435828f7114cef0b2e921f8dceeb269f06725d38373e2c45acf626c242b91d8b2a75cc17fe7bc1ad81cf2829509aa609c56ce6cfb501a7fe7aae1b070566cdf2a36f26c69265164c8d88c03ec0e984660d63cc29cbd776bd18265d43d2930ba1052767989dffd383515f0ceb9485551d8a87e8e4422abd3b164be6d38b8e296071b7f455d999864629784d5c5ae2fffd440006b220e9ffd498fac08d24cbdbfef06449d5e0bf2d88c0a4ad115cd2982282ec320a6fbb1bd477690f31595b2ff17a4603979dfa1846d385b03f71d8121af01df026283abe7cd39dcd078a441ef754e8f131443c802243da6458b154878ff1e99a09eeab5972b0e8311fe4778192f990b2f626898d28c50de4f39b2a26fcfd32d9767e5d32a4b520c142cf57b93f8535e2e9ae5cb6a68e79ed43bb56b8cfb694549c2cc46cd6751ae007b1bea2918b6e636112802c45f8fd69cfb98c78d13f42f4178afbc131364cd265ba62810710c4b33b5266df9a7bc8f1613390c8834471bf4d9f093a951370dc57164370d17626caaa4e1ae9bfe26ba112743c75730e2ca7fd48abcac78ee8dd2df9f1f4c88e46848c8d4875d8afc3921feee8b66fee9c3ba629be89be9bf21f3d46e07a5d2046b17e8c58320cc11dc4b6dc334e430a646ede19dbd6d5156ae063ea472b66d9bed33472a2be57e5e3834120d9ba861e102b75d7060de3eb0bcd78cd1657effaa466f81d978ae3f6818f7d0c938e0110c094f75a8c6ac0e454db5328201358c811dba1d03868b5e80dd5259775598483e6948a8e634021fbc02c250caf622e118f52c288d736af4311bf7f3e8cfa6446b6936155e4b17264a3c58776a4939552c31cc07c46823064f5477629df30242cd485184645f11d6647f81ce4c78c8150318a70de7e0f9b459f3e22957d65536cb7f73656a3ebe48e79551552dff27953cb14418e0102fce2ef5e6d16b82b42ab27d4183943af426181a87069f50e3dc4eb2cf8c887ddcb6ec7e312922ee1a4b2f73b93b087a7fa4156ea04c0b84a6b5058c6237aedf1d5050435f4f7651875c235ddf568603899761d1f11e10262c3bff24a0d74069ebd57521c509f6d5b3439c3244456aa71b9b9f4aa0bd904cce9f48ceaa4e5cc2c5964c7a9320d47cc103eb9acc9114eaf0a9dfde5a05934b1ab1c5a491a821b616c085ce2aa1034d3a0aefeefc0ebc0adef94f46abce04a72280ac6b7ff39c04abd86d92a6756d2a43623991b8a1ebaa89ca26ccbac7c2e21794f8c135500ceaf6e9bd74de17df440878fdb7321f56a66ad086b4e418e4d44e6e1934b312780c1280e7ebd067f14fc137ac1aaa07b68a8a3fda152caf57c79571ce8693cbaf5d8273731a63b1958d4df56829dfd11400e793887bfa0eebf6cfc8366b6adcb37ad27b9e49b1d9bed4d029576ce8f5de88b790e8a4aba258933babede4373048ca1eb965c93115a147b1dd441049484b6c03f319bfdc2aac9cfb6efcd1cb68e9a7fa707242a0a120dbb401461c10633604a15d3f7f73e09b316a31c364911f326652f7e8fa6d4ea89b7157907a6ee8557318d9344adc69284d0eaf88b935342bb269c53145f091f1f4aef94927c9b6680da7f6721959eba48935dc7a7ce930a85e0c427a83fea6f84268dc3d8841b8ce16e02c14b347eebef408f461a6141d6f34449de3b6c38a94b6c2282780672a03586da559e50ad9dd64428f31a863f91b6365e8b7447e8466d9c39dec9b528b227f952bc4b1c8ff3f53613f38597383c86cc0e77c41456c1bfab55e77dedf47fb692ce10649f135f983cbf75b2541aa26b14683fdce3031f4d39cd5745cd476a2dfc6901033ae7e0e4fb2f1d6f6ca25c54c3f248a00de34dff5f4779230da2e3fd6479bae24a53f0cea99a8c68d88697de8c4f326ad32791b6abebdc8937706d4584d6fcbe9d6625b18f2908015c90ea7f7c92d52eb008c274cd21d5e65eff1605679fad21c0fd634bde452245d6e621a67ea7ff129db8bc08c72979ec8ffc67e6a0592916d3ab87ba5d89ce56528576452985c90112c437bec7ae647b837c88b9650cdb7bce5d57e1a366462dcb476c7c5a9f3c9c5bb5627e72836bce817ac3c07a554588c4117a9884184923e01bcda0b7434ac6c97157253afa1eeb758ef72269e7ed59ad82a3645378fc61566f29dfc387b3f8896ca8d124f93b0298758bc93cf1e64076a701810b8dcf157ecc2d80ad56389dcc384e1edb8567e4519ba6b14cc4ce2793ea9d196f81768c55eb43f39fa1539d3eeac3ee6bd7b3cc0c141400596fdcb64422ac52269c98621f93fcac5799c7ecb3862ddc952039953af934e1e1161480615e7507514c322a72387dd9600418b3a6cb9527f044777132cf151c26623762ab97e23152dbe77aeb514f52af34fb3be676c381a5ec36fae5ad4d53073b4ff4cbff4414a1b22b55e1bb013c907247224dceec562f74fcb218e92ba1215c6c05ef2dbc02759b7dea3b5a639af8207db8359592b718882d075858ecb552a948d831bca3ef64a803009a98ade40a96f8a0ed2235e1c569e0b74a3e75027b6a567bb540492be2d98002882111112bc18eb884de05741fae8bd0511bdc7bcfbe0680c43b4c05e349e5021e164b2280c1f4aa2adec36dc8554784c0b0f668572e150fd21df760c6b772d98e0b7e9358e98c785da59e5fed932df095ed6e3dc94d927fde53d378ec0ab42be602ca256900d89e3c55e915877405933b4f2ffbef49ad9fab597d7bc401813d80160dec1c4c8574946b5f0da6eb560c3f1f60183a6388e915c3abe9c9851e144a8961fa4b6bf2fa5d018a8e0677f14ce0e5155286598fc64fe8d4629313bde2976a9fdd4460afa2bad2791abdcc3b42ad2635f424fc346e94f179b74181a2a397899ebcb8d1533542b210a5b03bcc76b3fe7f9392022da3fe384f8211065f82eb23558314e3b4d595e179acdf30ff51edf848f77bd13250bf7ed97248c0782a106a6d919bbfad7795f35593e1af88613b00abae92b8712bced60ad3b0b2c27aba191cc5585cc8e386de853282779b86dfbcf1c309af64a724539d8fd3d9160719a23ec39d18d53f770c6528a2ffce2803319928fb6c4a359db01e63d0394d84c9408537fef1fc63ba791e060e79afccc763dbb35e2279f665a557e20833a47fc3dbd27b7bfeff55ff7a13ea5525b6a87c1cb97113e9a4c8318962b919e01f57e158109fd937981577e10a423c7cc4dab4f7de99767ad7eb5153bcd8c3ca7841fd4fd74ccb4371b3a042b0d0c819cae6a6a462caa4c043c19c5383a0dc118df0e9646b48762c7b643ba0d145930c372b1e9187cd0aa7186ad139fba9301e26cc2eda63b6c46867ebf806e713feada5daa2c3f5f7ae410c9e65a73593c88951cc9ff19b304cf06638f641c2837bb074bc90159251ce88ab01a20a52faf49c380da4f3f434cdc86791329307d2d1ac0419c5f5b1ace8cc88aad46b68ae871ad3b530c7a58cf4b8ab3e78966575f45b6a0939891518d5f747fbf554ef01ba6bb0339679071ccc4791118ea6909d5411c2ad9f300402f80d17e50d873aa899d55a8f24e3b8bd008619b365b77441109653a2f56265d55fae9f51f7ae367fc6d3498df32a49f4395b45d0d6ca1dbb66315bcff2c966f476aef04584f0faf2658ea8b39a8ecbe61b1cd133eb28c8dda0f7b922ddba123f876fa4fc257fe7edbdd6590c5a374efc3184b02e1b658b4e905158021cbdaccdd8d8fed4a161e3f515242066a4d002519b3a00c9fc969197deeb45c1b1741d5142c43deb21b42df0b664aaa13fb039d0b4c0da52a5d7a742651980cb442cfe4584804833b51350626ff4d9fc8bf5bdc782428a6c08cdf0a4231a117241313e0d7cbef2b36a71cdc9e08cdd34b3e8783c4a120688aeab8d3573e15bdcb50f3676d89a8a87be31a0c18db45d6e450c6a3e7a951194fb002564c9055d2ea74f59dbbc7638c027e22969eea509006b8077637a80e2d911a3e408110c860df61260ca78fdee1e246edf3bee0a92c30594501ccafa5fff53fd5544ecaad4c1767016efe5c992158575f0bbb116351ce49dad0ae5dbe3e723238e7c59183101162951ff3e8b04e601bb28bafc3bcae2421f7044b643b2aae0cd37baa206f5940457e626c25318093200834812f193981857071d39ef73ea79259e32fa646a16049ea9bc89b7d949108a940c8a00c29313956787d3694c4f57aaf019344ee814491c37507d96c7e779e388c74f228301b846ab5f8823ba3d6dde060f2a6eedaf110ddc0ec9a37df5e0d406839422b7c026695f0d2a21bbc833fb0f4479e9531d45e4ab8959ed31de232892ae915ddf9714b0d58b7373889d2d5f7918a7c4e8eadbc504c433ddf23a2812444efd2ff9e8304be133bdc1b9bd92c8ea421ffff929322a02fe263074b0f14f17150e4da909ea1aec48bced3f80ca1f22d00ff24ffef7f2d88313b197c856cbf55251b2b925cc5061f2d31639c6f3a855b4ea73f6e2e17c6ddab653455592c7f92bf5a3daf1f3dd70b5bf76df975cb78b4ed1241f03dad550be32512c24184ec256588b2c67786cf05e007115d24627fea0b0910a5a17e965274ac461df97fdc96cedca6fc02196da90b345a3b45cc5fd6faba4a1ab269778c2023d6b8b9197d7c2c3e37bc34d45fed23842fcb598166ec19581e53ed7821965ac79b05dd247bde031278fbbf91637821734fe1132d72b42e938c461787ec361733533439f287a61637410aeb0bbffc4409c2adc4d5ad02982f3ad244d052eacd3a4f939922c23d10343d126c15f512145b17338056d07cff7f4926b314084a17c2d1678bf6ab74abff71d731de77b81e3d022e4e0af86c1ac255212ebb0bcbfa92beffd7b2e5f59ab69a307c2a8a8ea3b8bb4b77f4b085c6dc969ead6fed87c68e368d8842f2dfd0b97d37d670560b6692d25994dbd54407caadd193b2f967cc1452d6817582fd5b733151a6743b31d42558605177a5810e4f300895a51b729eb710fa0461ce61d2cb49316abbabeb18377a4f2f3d6bf0c630db9af53500e20ab76b9ab43002fc815c1ad363462c6890feb426a99b0ba1b4bf0a5e9fe89e34ac06d9d8c624794e3bb1841cef27bc220fc0da51b700fd7ca11d88c85cfc79b8fa6cd580efec2431c4e78e969a1e7fb915b84453ddb03ac2984bfcab7d27069e83ebe5b66853f40146fbf03c0e02fb87c302a809a150eb3577966395ecd95d3c50f7027392fa5783e068911c1aaef05b4933e5bc085cbb04e5bb277e46ac94c87de6872715475b4008064b9c997a5d76accdbb0c07627c1c0bd0d902ea9399d8bc592be0ca0abdf3de703bfe7e5188ddae18fe7eb1d0e550b8b1814d5595c3a80fe71585ac264cfab8c784c98ca0afe690c5afa19f391a5185c9b88f63d5dcfe60f09875f25d7e59842ec75bee86e28886156db9be4caefbeae6ea17d1ee021c47e154a3ea045a72a0b4e2819079e82536036a9072726715c9c47abbcdd0767969b97cca60cbfb1c6f3cd1af0f840f561d22d9744178c9b0cb34b60c40d33e0b82a724a636dde72ec9017fff27ad2e60f4cc0706e244663c902ddcad4e472696ecf2af44b500883638e599adaca6487922515d80256842aa3290f96e5d4f33f1dc480441d76c5fe404e05c808bb5fec617943ecdf63e6742238fcd2d5969b8253e716132cf21358a96f8c53e7022e71a3c59a69d5ec185fa1cfa4b0e5f5ff80aca414c960a2abb9a5e823c5f509255fb2ed8a57456b24e22bdce2319e966b676a4386cbde4d7ffd5a18020cf1e9c3c91ab4e1e88d8f59945084b34d3a4ee7aaca8e708846913d4d466e67c2b699cc06208b6f5a2a032291aeebf29f5d8f535fd368e9f86ebea8d6647ba36be7ca84e3c00269101e39da03f2c2f3f7f3afa33a2f760396fa34408b9cbddda8044a2379cd0033b3a3a8c46a42a971f0f39e65a99f8c701c52d4b9db3ed2ebd9c9218c19455bfb7b03e0dddfc331c07f804510b1c1a2ae8b8bac6e70901304762192dad60b07fda35ee2ec6341f20a27288de039226c223db184d753d799a8754d9436dfe227a56ff765765b3a00d79b0da02d09bcb6ef8a42ab2233a5b6376f53010dc652f3fd545b2505041c0bfe38e3dd9977257f3195273b23b703ed749b55b018b4c1acac2597d0114495a05195c119ebd5444c8108054b0a1f7dcc74751bff263cf5f2f73b2d33a57cce2eb7e591ca997675bd969b6358a8da9100d50b3d6859784a03e6e3b2cc5e0ce9ce019d32149ee2d901301133883775b48e53feb603ab8198fcb478bea89ec36ae582ca2f66ca056edcc9ff2462477151086ea381a192ce88864701038cbb1601fd54597009c0f11a876c2b067f96fb722f64abd9bf82e15b9cc491a5bfcfa9f3a0f1e28b116e26d1ae65937f2ac1ee3ef6021ca39cd39edc74785727e174ca691ed690469c2997942056ba6b2102dc146c4d0d568dd62e8f25aa827fdae2e0cb84675db7f5e33e50309385e262d24dffd897c8e7918a6e140c0f7478ce92988cdde1c0c42540847c94e0d56e81bb55b792dae95412ef3cc8fcafcbec858e85f556f917b430521e6ad3bf5cdb11d963bb7eae2392ff849ade9fd6caa1bf93972b85c9695cb071e85b0a51dcbbefab4ceed3c3f3947dfd5cd91cc80aee5af9702ed2c97cc526c5745eb36e67721e5c10ac2c702633ffdf858b55e852d777a789a8a485e9aa5c5109d890f96d6860961d4b188c5af87624137d57d4c748aeb38c1482322a702bea73b91c4d9e687c0b7d84db1a866cee622bacd9e295540d7366f806559515de0a500d7a51ace0a403d2e81619c72a6939df71d804d0024a66a9a3a504ca7f9a6946e0c633df26ade32d96e6560e41e4cf05323043cc16285c21f57015fef461596bee5581329ff8fe734adf040a81ab34c8057dc2ecc76192ecde6ea7cc333a8d4bd48652e79e609c7317015a559bd700261c38ffc81a5a85c6d269996472bb4b92547885853ba224b044b69f976fc3229463be78074b36ab7e4f7c7c1205e6c495fbf236e018c643ba1a1896cf2ee7cdecf2f858fb046f2041d68acb3d71b19823b90519393c3040bca0742495670466b8b9b3a78c18c94ede75ef63c7e455fd6f58cd413f573210c280b0c2f3c1b399c692464b1fcf93274d352150b15e9b3cd56748cd90bcde2b5ba9213fa0a4ebd03e08bf9ede331881be5e444b4664817f58716b6d627c5121eace9c95b9326d22d5b9f3b6b2442ec72c0d9c304b903cebbab43d0616d13a1274d969555474b69a850618452d0f3cfd187b8cfac07defebf06be93c2b2b93b1778d72667df3496e92eef94404180d33669dce9838810f488fba0035f735f52a373e6f8a97036234bab7368b4172278045d934b92c3a5c2c811c96eef83b60e0717cd8a4982252873f3aa55a37ad87b58ebba54db9182e3a5cdbbcd0fee155ded7f88cd2ff7deb136c76924cf239584399a57df92a07e0d51dd65aed065d1a9baacd410d61204b832a736bdb34fd2f0236cc4877aa23100cb7195e0dd0e8200b7b949782f54ef6425ebab2192e4d0c9170a7ff4bab8106bd976d76e30898122eb3879689885840831c774e347a05e69318f49d8b6d74571f831b68f61c5ab6f535b805db84239a7be94f50e661c9f46e9e7081830a33b984692755d95ab17642afba23c8cfbd1a5006051377313e4248542e5dfac5890ae297a6e8b135616a21ad7669b0b793ad06f1fb96e92637c620afdd6f47728a7c66f8ceb26b532312926d9f4a7b026debd703c6f1c91d29f79fcf27bf62b4010efb154ff38170151adaa7b4ce3cc8a1f83e96c5cab8e8e3ca3ab94a901276fc53c5a587eb88d17eb704a1597edd900f9726411fcf3e61aaf58d413f0484bf31f0985065d22c485e691d6f1c13e21e75a830ef4f171c04a0cec2ab2d63693c2c5cfc04674379a547bce24a07f49c36f1e7b754808a984b67c65be8f5eb85ed5d5268bce44f94708d98cbb8368ccdaafbe397157bebafc1c130cd5b39c07b5707b070586dfa084e31749ff5c00b976fc6762cfd7d95d913fceeb467dc6e35d8d1b103dca56af8f4c73378a123a975b8d1c7c2b9e9d7b1ed9539896f8a01ede6e9224f2abade8a833352a18a85ef3135bfe01afdfe448bda7c81201dfd3aa95291423cae0bc114f5f06715c4f3ad2d5fa411f3a06aa3b606319d8c5d8c68107d99e68ee45aeadcdb15a2a46c095d5fd5c24675ecef67ec44fe2a4fa051d52572c7d8e3cbebbe1bfb83bdb052e3fdd4ca3441ba2e6b9fabf2b7d38d2a54449ab8ed0b1fd66acdd9f7de3d81737f2cab90dbf980a0e43530f6a6b1a34fb1dd2e28ec301935fe8918caed4076a297654a0e0acedf1e4b6e8ef9f046e71fe7b13603ad9e2f3aea2c2619e0d898cdda425965d7651b8f36a5fa27da23698e3c58125bddb2d8e4dadc525a002e2e1930273d5b793074473ee12ecbe6c7be91b89eae72124e005fa6e5d1e0317b40af29ab55594c97957d57dea3407044aeeff85b73567eb904d378ad01f56447cb75bf3b3376daaff6c4e5cc3508e0b263f34b3681aa8d1dd2712fb174cef060526bca42daa6660c4b7b390d3b0448829feae043910c8b5051d9f9b8b08ad45feab4e9a44f6e88574c4c16f98c97c3a4c1d20c294f54ddaa504d5e38dd5438c167a9993f0dab2d835e83929a8749a392203f85c2028049357591c402e2ad80d9d256a9c5c08201976a482e8c9bda1495b59d9213ce766d7ad1a52b63c4985e9c0b5685a8bab755e51181cdd8c18313148637e0b21ebe8f34d16d59137b6b3806c637c6a3b84205f57f1fd94b512045c0674ab04f8ebdeb13708d7d90eaaeb14d5c849a6af79ff1321ed0bc256a176765559c49762cf8cd97b31bff9e44c257f508d3438666c4ce42986fd5ced0ce9a9bf082bca9e2109278355ccd006ede75e522e695c18f06306cd53998a845412320d2105cf24dc03e0d218ce609ea294aad9ccb0dd21f2f57823b5083cb264401d0a40de42b2b7d53c2d4613c6350cce01257a9eb50399fdfe10ebe7522cf36018b6758b11229a180071cdc2b03bd91c5c095ce99a9c0d6f1b69832b044d750475a769d412bafceebef0e6e46a88d26e987133aaacebea6ea4a46ce8cdcd5e21daed6dba3730dbc9387b19321889da14a17c67b492d2a065522f9ccce0f33877b6a07372d495887f9274775888437ce1280e511d3e0f3e505f1a0e45e97a1c1bfc93ff5589bc547a70bfa238bfe888ccfab998d40b7dbed05e01ce6c87d84d2ffc53c6e4021a443f8f1119560c7f11944eb1373d388c9db2e6a1bba752de85dc5630535aee76936e173855ef93630adb452016f985caf4b57bcd39c58d208e701fbb834222dcf43f9c4aed1435b896428df6e3a23f7b88ed9e6a8dcfeee683d2f24229030aea2a27a92078672aafee1bb329308c57485d19ddefe46c220f4c5f6e4813a2c52ed8dcd2f6dc9257aa947279f40732ce84c8fd11015b7cd24460db8392934227668c2badf69a297b1890c1649531c1e617663af206c4aa8ca9befaa6d7a30160730ebf6cd21e531be05512bef65eb8f7fe8b3fe8776981acaf47509cb1eba1dc715fcd0ad1d1dff0f738a7d0e4451f20d6c478c4d907e9b0bff866116108bd948d9bb7e82ab67d478d2247b0177fd79827d2e8681d609084e86dc99e40284080250cb2daba7653d60e37f91d6883ecacd183c7ba9f633a8ae110f3c5587913fcdbc02074f11de572406bc88a2d2e2f3289510db983d00ed0bad44cdea77bedda32dcff656f85cf152aba99eecbf527eadd2d8c79df1311da5dd09d4c7a41fcc56c3bb1136ac4235cbcc34e7067c95b7c06853f1705f7181f043bf08699836cb5eef39b640b18412576b0fe4a8a2f2b8abb73115fdd3b143ea8b614b8ccb7724c722a89bbbf76cf3bf162f870d496d78685e8f6c1b96286d77ed2b0fb056d92e893c711b8dd7ec37a6ed4eac70a455eef3d41746a67c4e5475e90072d36e5b58c1cabc07fa4c820ef935db2cfd33aec4dafcb1c40589877bd8544b3cfc732b07f876c9f2e09e15d30d1657e7201d9cc0f2e02e7bf2c9ba642620b3247ad7eb444235b304d5d666df0ff8b46defa0f902a81bf8b28294d3eedbf43897034e51920fa2351f5cf1d00710977a25fca326a37ed3acca56ddb993a93ab9704ffb710e403a1960b2ef0faf76925b53cae5f18f98adee7f129016773deeaf6598eb3652f46184e77f4f21f2437795ec4210e60631af9333069fda62246cf4780a4635e617c55972cb267f0b3827b91da343425e80a8654fbadab688eac89310806081c77d00816eebe25dde3485f6a809b1e59aeeb4fbea08cb76d9a6f9460e008fa20a4b402fe3bfdfeff09e80186baa71fd6c134f58b0a70e6d497fbda9cbd90fd045e365826ae63c3886b350bf9e00b973b787ac6a167ed72d52310be0a4b4d940c8fb9b7d9e84b7a8a22f40b0ddc625494c81d454877a23563b366a83e101a3cc2399094f2a884d6e51609c743fe6966e0a953d65993da0d7aafa582b8a5b26257c81d4e7f1034f002410fd0abf1f30e12c3aa0d4261868581f0a05184f8d37ce0f5405cecde7588fef3e51bdadc0ea812d4a41e9518385e8468597e44c0f04b750f472609bd83012fdaa7ee308f53abe424644d3a63cfde43a2a6ae524e9b4bee87a7980fe93b07da8ed3f858ae3650531ebcfbabb89e6e0135310788d08f9594756e9b7ec3cf0b1650e593872ac2dd6b8451fece8987dafca367a97ed82f1473916396b3d4837547402a18be6d972c18fdf877a24b0ba385dfd096629ff4ff466c34d13b48f5d1a16c81b969bc8b728097274f311fc2b0c4ea305e0a9beed817b3803a18cbbd3ed8a6597368df1b2814dafee5a1d3835390304653789fdfa1721d4f9742f29fb7ad5a9c0aef08b2385bd8ff9219d97c19be503fd72c16f895d49493b5570d9174d9097016d8db87836c11bc6d597f3b386d1d6986e7ce2d82eded18614e33db2293f58113e2cab97645f93f3518d1cd18240f075f1d27c16cb5c83ad610b5d368c84462142d2eaf35101edaf773c94c7dcc0ab6b892de056676581e3c95784d405017578f97c3493a3898c66bbf487807ae5a7ea891972c53e1fb7973e303022af5d3ef673210230c3f2a692e913ab1b06503e64dac6bd88463d8969c256944a19bc4df8fbae9a44ef3ee874d80027f77ee185624e01d20b8cc2e7db092bb65ebb11f835da50c83df40221aff37bfb48a9b2c84f52944831fae42012d6313ecfb08d74ecd561616b7695bbbc3f99aedca865750b52147eb09dcd883c749b5a8ca852c22412c13c9d98c18ea2f5adc83a376f69c088d9f8ac8c76e942c7ea64d8af692ef6da6adbdb49e30110531395732e1097a3a2ab445a1c019aae3abbd87e5dfae0dd66452111c8528d3f8633a49d88eaf15850068bda378c30db25b85dd78af7e57ebc2df9a3ba98230000ca19616926f8a679b7ea03da215f40b1ff69537e82e837ec5f9ef8302bcacdd8842eb2be2325f2a9d3b2c5dda4d844d95cbe9428b8a4180677df6d745f88bf3692002725717b357f6e0d0f1c221f5cede902c52fae1ffa40d2b6bbf0bebcb6864fd9105755fa14559c0ffec78ded86e9b6cf9fee75a29315bba7e0db013df89efd4e3cee11ba958db81a22d29be2f87e5eb657cb2e3c71f66beeb6c5fedfccabfaaba3d88739387274d8ce5e5cbb1eab82849cbcf630c477de7cc70a244b10302726dd720dcdead5cc1253def0e54c6b84ca40a6a29ab9c4f02223fe01255cf4c079fbf03f37a928244d14db3bdcf386f79e09b52340a3b0be5e84c3ad1221a3034e72d85677b2184d53de8bb66855d7ceb30251a290da7f24fde132657ae0e951e645027209f968d75a84b585fbf181b3420546ce9c2e5396373dcbe43a8a75105c8abbb4ba88a9ff77e66bf27c8099e4af0b4707670b43931a9f6eb2329c8678526a3d37ce882934f0711c012d6bedc0a5f467a18eac9d433d972170f74de4a2ee47cb899d5ba2199ac37f1c5d2be59595b5468429c9a9395ac80392e650deead21f7009f2b90485fac83ce82d368fb5fba2e9611e7d88ac5bad3408f75e00df7586e211e628ae45bec73aff443d1ceaa6a9272b04e0851b6b0fb4e95a0d4e00e9f57693af7780ebb13bb4617d4d7bf8e07be01c5a0cd72d9a1f34d39ac5a54dc1449eb3c976dbdb1564ad306bbab46c0ec87197979e477789eb087b1fa562a9d17e2ff034b1384e47985e76d589d8507669a53a53de25b3553767340e7f060ee155fd06d2e8a347cc075d8327593b1739398c6e9ade05441a5160fd34bd8ea41cfe4c0d8c18c3ef5ccbd2c1d1b14ae8b3bbb67e13457496e72bb1d394ab3f2b078d74d00223da9a56bb938945938552fb9afbdc8b7d428478808cd6619e9e5e5637aec535ca8c9eb20efbc4978fcc1992938613de5a0f66054c5f616c1d22853b8d5cdf16448a3dcffa3b81ee85051a0c01b37e9d80e4ff9b076b1191cf69a94ee31253b1b83fe6c52fb237eed76feea78c853382fa9fa34245a6a101de4b257eec6d556823bab97510b0e642e847ff34d1aa064c65a5fe3d643ea47f35ae18140852efc8bd4490c094cb0aa3edf83b257a1e708442feab28e6b919abbf599cb21580b175601de0fbcc86eede8a52dc5ad64cfb6612d736fc6d22c746a3e9d1d431a353b1970d0e186c27202dc3ea3c66db65583b127d670a3ab648e7842e08a88ef769bd0178bb6c09411dd0c36fca506aadc44df2c202cf497ffd4a4f807fc7cb524d15383b0d111c696e390a57b73d62f5bf9a135c67c4dac2f189b6358293b894cce726cb5c149a9ea84acdc17cdfbfe0dbcaf63f5dd2ee82c961b2fbdc8269a82392e5d866293c958046174a0685c275f467d54de6a7cea484d5928bfcb2bd74fd364b362dbc84df89d09e42a122bd40a04aa5b7b30d977f5b2eebc51b7b16f43189fabf9029aa67ee5c570e8a23c03952c349f9d8439e844ffc54de1d30c5753e1094ff6323e3015092189cc32fa76e5c9368420af607ee98f942ce293d20c8796fc6c864f9c9028f946e82ee5a959145598e9c7a6c54b87c280e161983041a7beeb49cc70d20ae1f01b7c9e9e62b75a3368a849046a04809248dbc3ca13c7c618307b578d7a423218725d12705f06cb577f5a24766f027f2e674e8cba6bb5cc12f820664d43d145652f39aaba11993605010aad6c09c77746b89a2a669974dd3c8ad71c14ad9d33db1f65be445aa10def677a89a673f9740db38951b111d5433bc5a7f8c37846be7caff6f05a9582257f2c1c26733b2543af303b2eeb7efb4b16cf5acd7c4733a2bb823ba8aeeff55de2fda20d36509cfbb0f697fd2f6294b6bfeba2a10903f4f238fe3fa8c86431ed5cb9512cc942b2fdf6b522559d5a2241b3bfb825c74c5b2d2fdd2e9e2b8776017e271e87a06457425f76b59bffb57310b3c90f82e40ebf2bdfce6ce5aec7d752815c6949f6018efd962637799888348692a08a296b0ad14bc2baee3b172fcc24943882ab73930b6c81aa6813c721098fcd17081700bb9a6bd856b29ea6da52e74cf19685732a11a36a993b6a1bf2e82defac816db38be1492cdcdfb4141a1106e98245ba1cff4859162efdb92081ec793a957ca13fdbc309946c872841268876fbcc3bf6db221888aca93a8a1c5acdf6674651176d62edf49463da748159d8dfd5df5d85753da0989e3083eb2fa7d08ddba3e5a2e648cde875e6997c63275670c69bc889b7e7696e85556a25daba08c63db76f7113afd0f951a882d8da86f9aa6bbf753e456ff0f7a769f7937e71f67ce8717a65b23a7eafce84f1aaaad350c32e3184836acb800a014a13496b79c0703105c69cd5aa3fdf2db6d2def27bff272c4fad04d72b0f6efb67f7207fdceec4bd395e092eb2f3e164e175c1a3d0b9ece28dc30fab20f016ee48e66ebba219b7080f6dc9f0e4ad62703517b088349293b083fe4759efbe6f9ee23b13a2aaf988169eb59060dc0537026ae0393ee3ddda907ed770e3f705bf3551d689559054ca8e774c2d100cf817b92baaf44df07f25f833e1d3f8cd449eab328f67df9bb509b48f56938d476bca9e5efce8213a23b8a47c62206eebf1b14f597cea9d6b9b953f9dc917a18f74e2c5797fcbf0817e15c7ed90478016e76cc39d5116bdd3dc562c3813a401344da46e1023d6e3907c3bc1ac41d91e45e5f28c016605c06da522b57ee547aad9d06f82a943ee0d6210bfbfe1607b9dba6f993222173a033271eec072b39334747062d75b3ee5c3f03b95ae0cdda5194ea080989f58ff93cf491aff20597561a5e4d826da45d9c21c2f9b6832ff854353a30d8685ffd5557fbcf2acecc9c59eea9304d909da64943782995a128c5f1e32d5ddca802d377bdedaa70da444b89707c9627dce16c1dd2b435a85c2cab28dab24a2a27878c7e664098a026a16df7e32441594e7f6eba7f705ac237d1c9f744a086f8773ba9a5a78e704a8e84bab84fc1293e102462e5eea0f86a7b559c6ae8d7007a50ea1df78abeb43d83083197c180c99b49c33f709a8e381faf9727de3d9813274b0b9c9558621e582012d767ff3db9f170babe596d2af0e51cdcfc053c1353e78a435bc816832007e314233fd9ebcb484e52177296b3cb9e5f65f070fdcefcf19ba3dd202b8147a343132fc94468dfe50da23301942bf0052cb7e99ec63b0d6f3ea02009537c3fba38ab83dd2e52c93eabeaacf63c1cfbb5046ecab4ad048d958e91243d7ab3069fa911c784ae663fcdff2ad9b8ffd5090e86f3e4550bfbbf7fb8d821328c79eda22054a96d8cf831dd61f750b8ea6505f42fd2f87d6e9d64e6a347a85ca70e7a7cafbaa2c957bf32811137c9fc7b04ba8dc65e04020527c61c46f96c7a14d333cc371a96cbf34cb4a2b3bdfa9d86a3e6402883b63ff15e88a6e7d9f697fead794e111f6d3bc035da44988ea0e417381deb128eb07f515441f2dcc8c2da33fb777d44016ae7a6c1de88f363a8981e14d9d6a93b78f8c0b4171d4977365f2b4e3d9d65dcdf8f146e63b76b6bda5956916275becb7ecfc13bd58d047ef6b671b9211ed782dab6c2ab8bcd3904dfbb0c40789b7c65672d84e7a7b43b80584989b111bbd73da00102926b01515a9e9a028bed46bfc84d19021c47cb38a9384e78f619465fb22269d7eefb49ed72d4a88bc8919aa340c2edaf1abe5cd67a111673669506635ae9e3ded4e9f37af6e6a9f4516d033456af33bce75b2ad8fe9b949cf384981dc3c5b1368f4afba000a5d06a156e5f9d2a3b512c432da27e0504ac742b338f37d468887f0fd9ef0fb1cdf31a2eca9d1d22cc975728f7978371eb168434b39a31e44d0f76d8b19cfb33d4d9320d4f2d2275282d4cfc51ae1f7d076a303e481052418fbae8d0b7768c7fbb39cc60d26870914dba8a3e5968afb9e64eff138a2440727fae730b06c6018d11e5552748a90bc5ceb94ff01b545d3d4027c03482353d561c7bdd0f68308e808d4e6fcf04c1f81635c94be04a739800f9cfc3fdeb62b3ea9a99194c18136834326b05511274f57695a08eaa9704be0c14847b3c3ac1b3f3076f6ad69bfbdb387e8fd5a17c590077a593656895a6ae979c64d9956a790b28e6abd65928715a7a5543b31d2a7d368a89c0118f9359697c25a23bdd85427842836e8a790db26b7fea8f96e553caf46681ffb5464dc2d51ab53e59462417b71ec2cdb7a4b0bbcbac0b734611e8c74c9ab75285324e25f2b376819bea018a11f71a1fc6245b1bdff6690ae36ad3535ed980d28293f5481bb7087e30840aa0077d3e7a05fb203b61ea28a634f83dae933db2a4523405bac8b48eeb4090481b226ecd0481bbb3a2cdc9e884cdd480dab2a18f2f44f82906f65efd28b5ef7fa674beef888447fb24121f1cbac1794fa014e9fb2695a60851ab439aad6f21b3356e2ddead071150baa01c2b3e787cb9cd4040923092b4ac89356a853a4fa7179ffa72f65ba2debb393683c8d479b18ffcdb4d021dae5d61572c3ba605200c0bddb5f5e118f0495079554dcae352d7cdede1a0e1b7cec1ee153f89bea6df82798efe10f7b610058f54bf8423435f09ab93b0188c9bb0c0f7d0b65c14390a8764f72fd708f2e2560e0a05b7f769a2e3c7c32b4245b1f14e43916207524d97c3942b8ad9d7a60290a0f93561ea5cde0dcd4fbd7876154da7d6ac48e3f445626544f85eb79af01d1f39daaa6d18413c543b7f6d43ee17919ad582c48af9a6a3926465a508687493929f9ef04de44ea695eeb9f9ff0ce701d6734c4c443277885a321f6db6ad993335abe029157ca0236564cf145974025f9edbd25d244873715330f63a560d054eab8c6ce9b7c00fe0f8da3af932d3144f2f779e749ab08a25610fe6e2c1ec444367d4cda54b045273bdac627d2a22d897b91fb8e6d6ca50ce9c90eda856715ec67de2245f34461ed7f9f156db1276051fc59c795dc978459ecf655a2c8b1e57f42be753b65567f1a53e1d47699dffcddf455ccc19f7a0bbc0c42b86ea88e318e90517e80e27f8095391bb967a807a5d097bb011f4ab6982f65352e49c4f49e73b48f8154290bee21aef57257aa9b0cb1a5218394e3026f1c46106b099f1081156bab644b38a2dfc59cd9e8aea773e8cfdf23b5b041fbe7f598c832a13b5a86deaf6d70372137db30a27a5f14b92f1ab2056f75d312acaf8c38aa2359c86851e04628fb4cc464ead2a2ed554bc8ff2a815af6cd615bf04d82df2c2cfd4e8743fe0b25857fbc708ca2c318390609a266a238892077e2f6da7095616b25b83c5dfea07b8db2629aac635a1b7ab89308d41cf3b1f0a57ffb08094627bf3a4c1ccc21a72a2fefd9cdc7b7f7232d18bd151546dbd6ab62fdd00eafbe159db2a745b5bbc4fa632ce137e29b5e6596576aee56091793b19758f03a83a45d60151f24d6cbe15b8cbf19099f9d000f49e1b2507739cdd420a07274b0440849ce2ede692287419b27540a1d2b985615e274a234ad8dc100cdd744f5f8f68cf63d013304b5ab2df370bcf8cb7187d037ffd60ca15a29339c9756baca0724bfebfc16ddfce8c982cc0d1a0976b0a3f396a5f0fde39f20ee22cbb6082a51633d1ddfe08a76d1f0ad189bcaa48d42aa8b29ec95c8e3f2b90c7948cdcf7bd92dc4276b8533329987666789fbb7499447be3e1e831d998abdd9a87733d5691213f11f746ccfb4b0026cbf822d1ef730bacc0e6ce84032c56b0f4d0ea3dc1de72cf85f44ed83fb90da0f28f257a0c41ba934e5498e04032370579eb3b071f7f32d645afdac31a1ea8108d40b80c82af6278f6eba842f8f4fe0f566ad37681a8183c6aa6933aee5d1829315c7264288d2e91b37c172b72c2137852e2780e38edfb01630b2e09796fcd75ecbab66114c97584b706352f09478086dc2d6dcc2d359e66f90c4cf441ff7b1a1340a06e220e6edcb9ed4ec97bff4c8a114b5b8013d2afdb5b605119a430ebdc0d4cd8ebf9cbb7d693019f8890894fc45bc8424780764b20eb2f086a8029ec5bc760a6d033bf9d9c530d15bb4f3dd6f9882158c4a21f8fdc82ea7131252050b4a8c13494c6bdedcd49185fb0647e06e109c13ecaf08d3742071fcdb4ebfe2e0132b42914d840f2d08b6d92271e39393e0d9655221bc867973f34757cdc30a00167d6466dcc3c7b56820783fda20962fe769dbebb796b8a024d59b734adb249eb1dd03015d2595dd5f40b73814eef1b0f5292981c85509b22a39a769961ba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
