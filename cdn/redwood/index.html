<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55217b3054467c1e60c78aa94f9eca48550dadb528355fb459cf137f0e11b04484eed20f0b98226e03356e05f7f0a72e58aed3da0d99d5a086923efde52282062ff8367c8ea281b993ca00e85ec7e51a1657a33dad62d90ec647dcb898b9050b1aa0e87ca055e24b77f00d786cc269ce5fb3e6effefe35696e09bf1d3dfd31d62dd09c9342f910e5db33db7750cc377efd4b6887eb1ac4e2f390b8c644d961bd7b2826787dc105903bdbbdb03d173c3fc431c37d1388a49da1f81c72ac004cf7d8dfc42106e699e92674698df7205d114a06f17ad39df3830da7f5eec337536a87af96649b22750e546bd5e16abace932215bdd538fba6162f41808c5e105cb215d8ccf7c400c54846f8e99eb369e9fb6c0b6c6c9f3ce69b128c335a609b07c7f6ff1c52be56f19d8c4376be77e83c3e32810abbda43383b8fa05a92a49b3cd97d95524061c8a06c3f833b6df5e5c8c574ac435528a1d8499aa72c23a4f071f4d0038c5f1eb357f6896000e9597e1592860c181d61b3195ee8985750ff1fa6531e37cbea6c06bdd2d7510daa19257714266e286cce8e14822088c887acebcd963436dbd6e3eb337cb300054dfd8c8ea245736c279d2409e56329237d89ad47e000f9534249c6ad2e2bdb26253294094347d41c11b55d2306b3870cc6a93ead77d2d439d99aee74d3b7d00f8ad8760c463d959408aaebf59063adedbc5b9a0af157af829ffabdd45c2f39ff13503b0f4fe939afd07ff7bd946ef48959b120c8f839d5adf2b414592e9f87f96d6420e25672912928dde8617cfd5d483b5e243c87c6ab0192d9cf6c392a20af353b6ece8b0c74d37ee2d6552a571bf4eb851f3b3f21e8ea661cc7f89fedebcf8ed04e485522d9850e74b1edaf60caeb6f1a05325ee90f7a1680b9fe27e1fc1697ca793f2545e0a25864ea5b9272302421903b64467d618a7d36ed75f1561344ce06cf42e0ea18c3036eda374206611a92885f05269b0d8594521b4e21c505e9914979de7e0ec94acbc2159e3ecbc2d9f3092742a0fe9dcfc89e192e4f55934d2f4875f7aa821a60fc5f3e36d82d8878af827acda322bff2aa0bb0dd99c940fbfe4b4c6b9d387ccc226a39e76932ce05c723ae082509b7ea24875375cfcbeedae265a32118a09a9772a15237f432b9a351ec36d14dd754bf15e4f41e1eded01e3bd4e6d0d5f3d0bb1af87d2362e457cf6631a5c544f1d228539c5e5ccf131aec2ede4a734e2423c251872a9357fa00578a5b863938c44b1fe4edf0d1849992288e7346bf1837144c9802125c351f8c673cc4aee2115c459016a32cf87f0792630dbe6a06ac2a86f26275039fe7b8e466f2de7bc3e64a232bc518288c5e648871e85f320359f52709c5ef87f227f22f444fb19b01d31a8e88e9d111a4491a89ad249432bb7c6bd828b8aa0431bee365748920127cbec893d33a48f801c6e22285cd42bfd3d55e06e533b4de9067032f545c923d58a98d97617ce2b6930e6806f748c71d8841e3ece03854485e0165ce0f4e16fdff9e3f90a3944a9af7d1717a377d1e2be51bccdc11ea5a3cbc55c31c54fb4bf6d842828814ceac9c9a1426b7b176f37fceb362e8a87f323f335e6a84777fa6436f3e8e127d6916f8503cafa8e69be74566ad4501c0804cb1620683ff797ddbb2e1e4a35d4562faa818750c07a0753b38948a4a9ce3bbc1f5fb4c9a619fca7d7a724bb767be009b4dd9c31b999929e9c2d23713b7edd9ac9154a5c058b15109073809590795022829200f1e1ce228b5df2f55438e84e21b85ebd0f212c37fc80be6c4bf139d8bff1931d3c35066583ba52cb06a8d04581f3f4a178f2c3430e311fa5737038dfe93495e4dd0263548e82ac016fdd670c4b8c458e56e34f6edf4916d6b2456124324815b689062b3bec809565347e3f8e2f64e04eb3c4c33eba14ca323008def94558870fe4952b41674ff01e2a4644f140785121969ea8f88cfd39ba12254ca2ae758b5926518e6be19655c97eb8f82548cc4b2a794596a66f1fe3b776de5a4d369170b317c3cd262272136c4e351ff50cba1b3aa8060628d283a6b3fe6b2aa21785dece199e5a1cc2dbe4368736985d43c82e0e84e18f6b3b855b94437c35ca081174fe4969aa7639527bb41e6caaa8bfaaa07ac8c212bc685d9190ab0cd49fbdc0d95aed7635e5aaba5201534eb0215f26ab11f9a533ce37b083ae49518f6d7bb67ae9a076790215c3a4f811455b4a2f725a6057ec250c1a66e58ee5c2258d0e4a5f13860e07ed6296b6d72fbe7dc5fef82c6ed7fbbb17267bc4b1a329719fa95dd14d270c5886e60afdda323072f8d8c083b42c9e06b030d29cfe7074875335d17cf439935dbd40303ec3ba75210042652f13f6d5efe4b8cbd8f64b85c2e944b15f4a2bbfbe4b1c76e74a16362ae492c206136bbba9e2bdef8aa5d384fdab1327c188e363909216cbb9e2aa9ed4a45a9ba28858190f0ee3b61614355d32adacbe0c293aca0df25af1dcd7130916b6efae9d5cdda43ba1208f1188bf32330fe0fd2cfa34d8a3ce571ab39d6d288513ddc2d70ef858c246d950a8a26bda37de005d8272ed31ca126cd28765c43c739b7d5a221fef1cabf27e99d01cd9c6ef49e149ea970cc38b62b0bb3968f50d542d56eb7e1ecea9b0b141d2caae483c8c8fc52649651051a24411ae5869e9da89a9773f4eb32d82f6793c141e7502700a159c6681baa7b087a27222a4298bb710e91c85b7216dee623ede1fb0528623a36cf52ceac531557f7f098ed6375a56ec881c94ece9c1208d3cae190c149f626dd708eb0ef9f62ffe2e6a2e5025f67d70c037f0c17d1dbf224d84b8bffc1da745044de50d6f77439a3489b3344c01cf6b5d6bf1d2fedbf7bff6c2037faef43c17c1d6ce0d5994ddd1f917d5d2aef3e72934af2a45408fa881c02ac81b7ea36c881f519424e504088c2461709fedd624b5f9b53decb6dc18995cc034b59ce39af7f45e45c219703b8d97c028a104844354574415d9ff2a8fe8eab89d7a45d853ca341d494607d4483de6058049069caf0f6e93e01e115f514f32d3b0a5ffaca3e17edf4973d8a17ad23d78f45833abd9ef242d1f72103321b178f601683aff870dd733ff7ab099aa3a0f57ec23244709ec94a19301ce928abf99bb9f98b24d7de48a044d850db9dcba9788dcd891f60d49cc25168cf05bcb5266d1312897e16ee7a7b4edd971d67613814a3c7ad3f2bc8280b66d7ef0b272a186cc263cf628a1410cf66bf107a86514968138e85f3286dfa1ad42e9773cc395b9af73e00470310d3842fcebab157d9b3172b6c1e219fe84b30722a55bcceef8871dc1bf2e8dab6acd7fad625925b68552a0e323f5e93015fb411c75e398d74d4b62c63e6be5e3bb053e391093f4321b60e51bb310fb4d4a757dbec4390f95d3bab8b99089171ac5fe80a70197c8bea40c4dbed7163ed04bb9a60174023d46cc36a1f3053e61110a56f191a4c3f3435447df8e73a4bd01370ebcd991eceba74e72fca933d2f8b53ce47fbf042e1b5a83e48649f8e15f1317066c2e2bda69ef0d0c878c06fa03573af399d91f7f279022c9011290e1d5330feeeb470202a27de09af230ece56832a0a35fac34f718962fee316dbc77a486c05e79ed751255d5dfbf5501150875d9711f2c6e6726d9ffd8cfc57502646afdb91484eba8415be0a534abf422218ad3314c77383b7559e01f98a6843c6378fa68b2e799334947390ef8a7557c4075341c911a569e04d224b1a16af081dd25cac4e2b81bb39a44274274866a3056d02ce21af228365708ef211e48a0e86c3a9c01fe9a30ef0eb6eed261eae00ee3daf9ea506c6bf0da1e07362de564668dca59993f26bbdb765c6047f0618c4bb07746ee5b073cc0e2a900b7b6b7c023b6c933610995fa08978e038ba886da01211c95b96618007d64676958f63615e1d3cff094f955d58fdb3eaf4f9864a2ce8f40c20f66280e973316c8f47bfac1af74f9866b8abbb0443e59ab5a28ac2d1ad7749269c7f51602e4f0f62f0e7adeb657dc0ff4f36cd50975a1c75faa3add4c62f75e71944c104008c7f07a72e00f5b50c61e63a55b983b3122cdaca5e4e48786ba09471635d8c5536d1a623a4814d610674bf54733fc712ba58f4043f5c53f965e63f0c0505317c4edd1fd0ea0b81236fda04472e9bd6fd1c9a9b6b2045099a977113937b69f2d58861e51dd9b2b6bdf3a227bb7a771203a29486ba4a983aa9f691ee9f5fc7b3962c95b9bd880419d0c4f326a9194f64714f6fa576de841620fa126f098e591c39b667aaed3d15b9eb852f6e73611ecf1505b3bae353635e6431e0bddb2b43c2f0cf3f97a4e6e6b6a7a5fd1180d83f981bcc4df6b5aa864c6e4ae2a1fe1e87b009c888898d8847a98392f8f837a3523e3708f82791c212229cc9ae5b5870d1866c68371df7b268e23a9d656722b837da91620c45bf758b892264b74ecea5c1e59f3b7da6dcf9a0b8b37d5fc75b35804b5aae95ffc90d0bbc0346dd577e5ed7f3248cc1d8cf0342283a2fb6b74394b8c403e697e55615b2e34c841b73da81f762c84d39345d49b1c97a80dc68c2fbfc0da1f210a5546fb224f7672262e3830e7c5a48ac2c467ac65bac05214c6f87bd98d6db20ac68197f911922681b7ee9b9f56319bcb29e54422a253ac66c233ff3cbc3156f4ad56820c4912432e7e3ef422aeb579934b2a0cced2621cef51b6f1d1635ce27df23cca5a86547b37cb0da283f45c7cae184b363d7dfe676e6588bebe3de8e90684e6d2db606ab279a5ac2af7e360f5f32e18e79a7ecece68445f4cbbdc7b0fe1acaf6b69cc3e009e1ffe167701a82d90ca52ef8c1b8bf9c34c5bc32d89890793433c22cb24dc8a270f6540699395d12be27f1d5d483558343f7c54123e76c91c7613c1dbe02bbf0d64db307f0df7ab93471df6a7bb6d275ef42ae4e3e9f99c6dbbbccd1a3322203b57cb89132d244f1a746dd8754806568ce24171939ef696c9340941c1b2a7bdfa43c39a1ad433f73cd9f2ba07936f61d931065a5569acd40294b829f44ce4454c14ad573fbcd4ffc49af7e02e590f889f98795733b8e0df5965f1c77f34188a5cd55a68dd6d91638cb36145e4faa09644868d09583e718cb40b0c253c178efe54dd52cbc4fba0e3b9c86457d52463761a76b247e80ba221fc397a6ea95ae42d080baf3e919b51756ef489d0db944720d7af82484638733cf9dbb523a49605cbf6c16286dbfc5d41a7a0729e469923290cc0c9e4b6ac20f4d5b9d3738ae8067909896c25b6bacbcb3346b2eee16b97b0e67eec45da92fe4a236b090cf2872f67a9d8004fde9b3d932d88888f76c9759517d866723eda01a4c83c3e57e528295236065f5a1c0c6c56b34f91e653371e0c0ab2b7d9d7c0615b5ae1d5231a9d9bd3c514dae7fbeee3e0c81e20a1b4f57a002118119262531d9fcb8a5ad3caeb4b5e133e7dde424e963e59becb3e30b6fc78c36660214b7f126e7c8ca719d014ee4a2f62ac34074b8142e18f4692a512ffd0b57fbd45613876fdb69aaed445a0d832d1273ef7364760f72e97d208d5017e583ef501b2c3a1aaf0e27e8c78dacc2482e5511e5be61fa90211234c3f37da44f6cd18e8c553cd46dc1092826fb83f3613759f12a9dc4c413b91aafccc77a30099933bc2c2986632ca5b8cc2a8721e1cbaa0ca8d3a2f973b932c82c43756b34d1a497418bc2f2b8c0a89252e62c82d45e5102e9ce2d2a1e7c2be29880ee678fd676b0c4916433e22c07bf1601f4df443c49778718a3bfb38ea5575d624480e36c40e66b9976acd032c9ae94466b32d1e0f6ad6b357487ddfebf8ba25d289fbefad9e96fa9936dd576c58c459db1d797eec5dedb4a40b6dd2b2625fb4e3efafd83a9b273f56e37413f430eea5ab7b99a8800da02dcd4a667bd5329dc6b1844c2bca859e1a1147c94d547fe4e24d6300817cfcb03d932c91ab7d8d9a0ab28e2fda774d814b9f03f62710c2fedd72c8ed0d3ac92100676928baafecf0dda8262b9b5bbb2f23c546ba6a1edb76da3263e04fc9376e064e95ae3f45da6aa02a998000cfac7844d3a34c85bbf2ad4f9fb4ac3cf63c749e0eb42b158aec140daca879e2e5f5165af1e2a63ee264071d01b1d1a6f74b14102209eef518a5f055b953681445b8513b3419b78da67722ebabe38b9bbe592dc92c605aa2cfb7b4abef685847e5b4b116590d4858e3886f4425defa5013ef6c4873de2d021a68a62b18c9d372fae97412f116bb8cea7a66d99b30d6e3b32c0fa1d2eb17bafb953d0dd81225f5e6a836f2c0a9ba627b51730a54ced5106da954126f461210df38965043cbd304166996ab8ebef58ff73765dfb00695f8433afe9a8832a2e31fa022e43baab959761111e128b6690092a1be0acfb5ac44d5f632ebf4d5474524e07f967683ef00885f48442cde5af36a60fb331bb44b32c33ba7bf8a38310a5f663a063f6796667e1e2198b627d6b5fc1a391ee1f8fb547aaaa55fdd331965c6355358c1ac6d98eef42f2bb85d194cef5c89e0f120292adedd1335c4f10bf07df74a5271c22fbdc6b820f3c55670c8fdc200c0ec4a2a985d162e406100cf837bc46f8329f8c834fc621427afb9c5f82cbc7651791dc15c75eef73677f2d54b2d4fbe5227206dbec4e32b6a9f646e7d6aa49bc267180b1acc9433cbe238e6c2d3301407df1c9b213cde61d60a2e2e8b7d590de73ff788dd492252b34b735fb77acad93faeafb34466d6940fd7dc62c7055b808a7ab597529fd2f1a0230ebe22276e128df31708e839c59d198b48957a4f6ba8feae5d56f10b8568acceff3bcbc1f6ebf1ad4849c9ff984d02a093e33ddf54a64f278bf3dd1317cf4919b87dc5fc781dda1afbe36ee9e7ca98bb59dba84a2ee68847d9df55fb605ec7cbd3bcc076c67794a9dfcfd7cba344216c20c4e0d8c55bdb02542ce9f2bc441ca490edea7031dabb9cf1215ba6147ccab0456df92fe435d565240c4fdd02928f91a340d43c68588eda0854af0dde10c64713e73904bed001dbe882c20812f844e6eecd056ccb08a5ad87cfb9760ae80137deefc9cf099bc0ddd39d47e3aac00117ac52e2d3a342e82e470387811346d9e4929a1bcc4e2b61a50540fc390548686e8b7d2bce75d8c9a2d163c4941b2f0bc776c9710f8eb414167686dc4cd8704f1fe50a71e2119d1077fd94d00245296d00f780e0a3e7b117e3a19017e3e1ea4dac3ad7544f43a29b703d55f56a0fab073c8bc25303b3aef73cdd2a911e01d6d554c1bb38826c2e25690205f1267d8e1ad07df1e2bba5766ceeb252172c5903ba91a580c5b85c41b5c381aa2cec861f68d033401206bc9c809551ee17f29fce519c99b1d2f2b7f20e69be6e9f003566560d91017bba1521c62874e30c62be1127603f6b741be752b951ce048e569ad3d64a4764e6d2b09eeedb46c5c284b4db1020b239a60a2d572d1b4ef862dda3ab0e835f92adba3b31263ce6ee9e7b7c01b280f87b9c5d458a29761a2fdaa3d2da5723ef6a4f58fb6f6c7da7a02f9ecec8af0ec02aca12dd695eeee7ec95d97efcde783237276df59275314f25ab20d7d89f7e0901a18ca2d6928c38a7d7012cc60b8f0d4164c4093fb0d99253ba3f1df34aa4adc5faae36d2fe1bd72b93612907e657dd91f2a8b1da1c2ca38d0049920b6c91b3aeb40e8a69d475c57f73d2808b01b2cb41ee7076c0d96ed343b261e2ff18b9ef8d7f2419a590b787d8b2333b7fd2173815309dc5aca7a9461e7628f4e16496c72cb4d92948691a5dcd456d84195a0fa8c8828df49c27485bba1ea92d76671020a02ff185c22293e1901598133139f8d11068898106370482e678aa5c2bde6e398f0b44f37b46b5845c3c976f9bdb71e5c49e2a087bf70a58859d19f2ed8af0902682c2442f570f696d30727ff13ff4c1174458ff13d06e6e06cd6e98c99688de9f6d9905c205f922ae876de1b0c85ad26d24fc87d9a957e072fb3a9cf7eef3304b7d69d98dd4d46a61325dcc49e3d1573d7b0e1825c46764c6a30afd083c4dd93958a73dc29d97796ff0fa6ebae80898f0ff53da739d99b24b9d2cd799565c97f8100bae0bf2eb4e61a1536f149e9f403e52ca3df016a2579ed22f3e97f508d52af743259d1b0c0a6ba48fbe663be7082b71d206d4cb34af404dcc14a6e018caf5f1adaab8045aa80eb32fca21017b2d6129937bdf1030e78f5c3deaae62587115e5b6eedeb582d15b2785c898b418d6fe12eacfb2afb438e323fb3e620763e7c713034f386864a431272fe9eb7ddb16a794864fa39b2836d8825cb17851101cff9088e172942ae6e1221091a8e02fc189c3b7b47e0aa1fb04f49db1c5313e214dc09a077900368f270878f87b4d0438eb39c8bf492b78d5302160cb8e039eda6a53bc9d2e4e243e11d26fda10e492cfb65b583de70af7058cfedf2cf4c173158c4f78d2baac959cc3be9177ddd4745f7a37a5805e648be8d66dbec04fe3d419446b58b9b983cbd85e170dab78c5324ed5f644b61421e471bbed1c2f9a656483c2844fb3c8c0afdfd12a2dcd2c43bccf3f0cfe741bb4cdf35a1e387260c97e9997c8aca409effb558a78a783e3b65a50c3171718396828eba45fcfab76f9fd2cf6a9facaf1c68a1189fcde24b1adf94a0abdeefa43ea855db20d01eba53df48700ada04ee346f3cecaae21ba626697e1e1b0cc60244f9507d754c7ed95a0c5ff5d0d82228b11d3fee5bcc6f11ea2ce4170cd16f68850f926785cbd576679838d9d9e9cfe5d284b43ccb1d828c5918bdb823cd519b025ba5a85440617646a791e28d0e69607ab2085ddd88a6058588fa92305046460d5007814ffb7fbb1642a79def0e1e27bc0068e049c47e1e7b5cd3e4dcd376a6d628e97a3d8a6d66bd61ddc9e6fa97078a3d4f336eff083b5fca4b246951cd1ccaba9cb2b9d607461bc8ce499078bc7f5cee7fc3d6442757d775da7edcdd36a2ccd645809e6c6b2776d9075830d18db832b78266056073a9649b8d32cc3c6ca54035e175079ece0a88b08f771b0b0fff0973dada1e2f93c49d723149f0e5403d7443caec8bba4c2c3d1a61e3becbfb8f4c23be168a78d686f75831a3297edb78651b4f3b93cbfd246d4c2a76377e0b258f4ce464b833c343deb359cf435d5501848d60f4e24fec18a82d6cc87e126f47c02387a06d759788b2c4c35c0fbea5ce177f7296ab1c88f602062566de5e68ba2365a50f46d70a73a754caec7306f81af2e5e1cb68076c65359a4bad975f3de08d9afc87766841becbb4dcdbd2e79c5562b2cd74b6a5b581b68c69b7d80b7c4cadcbe0133a422ed3fa9ef23dd686c95a2b0b2d3666716719c42d9602aa4841fcfa538f6a7d3eb6101defb9ad96bd474d66bc4854ffc239f2474bb04fea0a5e4465b3c6bf97418a0d0a628dd9a003d0f7d1d7bd86b7b4e913cd7c0b57e4a488b082623f7124d917bd6f83b2c9042f6095c5e65a3cc6ab6e186999a851abe9b049bcbd04a3b89b186884efc692f56cda92a31a59569908ee1b51baba6d7fa7595f809447eea756da798cf37e55c078869d0315f45a765339c7cd393d586fa39c49eb4bf0006751ed66ecb2cbedf63b19c047bcb6cbef2cbfc762ae6159a359f39038580e1e9d1045a5fb8a83868c5854e5492076ecff0918d3e70e692334841a6d21bd66d75f5966b71078b6124a5bcc34cf83ae2e3a367b0deff1ac3ef7625abdeb108dee279485e40bbefec836fec9afbfb6f79b2ea33a2829548909df9a3ab3cff138f281193a92da06dd05b6c13cc87093b78a7fde7d6a20d20b13240ab9987caeb61ffee872ac7679234f7d9b540f60bbf64b16d3e31f7c9ea05f7981ee106c36c0b681bbe6c7e51b6ec542321ae57ecac2e43b49bf003d104d3f8c8ab6e0434f0c901cfbde8aa78d9556ac36ea8357546e9935d807e6301d9e8632a56dac3e1bf9a7b7289908f795d203f5ab5a4f91c52aeec7c9fe8975aff47b4ea20afc3bc24c1eca9058579eeadea189a55a509702e4c13f84f4888a6333d0fff2d7d2bfe879e03e6f60b7f220c90674f5b607620b3a741052b1d3af4270a0c029a336d8be9037f6c3027ecc18f08edda10547cba1ea9be203994775aaa307e95a15099fe6e2f6998dd4f857d771fe8e1d512ab6b0d02401a644496a0dfc017fef137a57a965908147a53d388413c9594b0a47b00ea85e50d99228d01084caf1a5c69ee45fcff95f4a7849b7651eed2635685f4ba5920e81572cf7af28bb15251d61a0101bea6510975fa364e9b2f31f7e82fa4090d62b47d3e9cf0473f443dfa834e99d4701df7ec152fad3efaea80a1480b78219e4e71ed1d297f73230dd84f7df59502bf63cbcdec31359c21195bd369a2e2a8c99293221d133b1b2a004cf9d0b236849e550d0c8d70b8ee0535ce2582e411769d6fd8ca9e28a00b612225b88197965066d8ca7ddb5bde7cf6ef49e891fd87d8d5601492c1815012360f50e87591baee4e44ca01838b65d705d9eafafd8d2deb2a07e74eba1dbdc5e441f708951c112ac6eb41290b94832edab4f728489468f30feca0429973c26b05a3b8188adc35b5a8c3d928df32ec939365aeb7b264f1f00259f0be2e73eb652e095742b317fa55f6c53b3b3e2a8ca016833803a002f6dc60db5a9d623edb5bdfa976cf3f78e366709fcf61098f8c4382d081e17fa1b862a566b12346afa876aa60dda40d2e4f55b1db91a62da6dc96c4fea242ce0f93c6e85762e9e58e28ac94306c0efe3cda1007163e6e9c1e174d69bc0c4907d00f0f1ce516fed8305da033405c8077676ee14950a93f9a95dbbe7b0c6fedaff334a2e01c1038b02caee049bd331e0446f1a8b4394907b54c8c8a05f554276f7c5a00fd518c794f303ac4bbd4ba583637183e922e184ee0a7afa3d989b4964ff3bb9023ab5cca188a0fdb68f0da66dc00d53b905a033458b32badbac8d318d3ca17ef8ebd58d3eb26e0558c809517be152eac112c21651d051d2833f1df4472fe2382b5e305a66fe56d077c322789d0e3858403db7cc8485a106e10823b6aa2e7ec01396f46b81501010b4ddb9d454ca6d98d630b436a1611c6d4ab40f451bb894f3b65b59a5e0779538d9ee86203c6e025d80bbbf4f83bdf35bdc4362c9a00ba1cfc3a3d4b65f899f7fad2f56a2f6ce1ba84f7badb54731b4be260c1e941dbf22cb81a0229d1583f49afc543a650d77f582245591980e4c8b15372bbce52533b7152d30b5297251566da6d59ef924a9e230fc12ea8e81f9d6aeaa654eeb12799754327e63f016216f1f43ed81e833076ed808812b7f7d4fe7b8f3efcb2620f1cee0396838799c8ac6188b36ba24df4a55e8e53e088d024a8a9440bc458d519236f5f334dd5905fef73418e0a5b309dfe6a229702bba8f315974466b03ee28f798cedf8c466ba4c1985dd562f81e4259c6cb59756bbee3c9d375dbc125f0b06548a6f7bb50925e966e15310c4e090ea3ad177f64de0d2513fb39b0b617db555fbab48d03066d16e67bdb58c7dcbb94035592719cd0615d50a4be28fb53c60ae1ac9e0e3630c192a697abdd10eb704a75d463b481573fba3aeb3b8182f854a7c9aa58fff4cf7b6dfb0683c8604eec8891587eaa193fd3ad9b35ca55724a5b3b898da105116f2241ee226cd4a24d80aea3a4209f9fbef66ed35f5283034273e60309c90b5e0ecd81b769346f7974c4a5ccd6cd76e4060bd586bc733a7846cc6c5ba18e4b585e1eb35ecbb4c21aad1ad36eb302e2c297e399f2553826c05fe4b61e1f24cb9f3b3dbe4bc6878bd16426d9b731d8de3bbf9511a1fae2225d981b384d3432b803ca90d9b07ea8ca716404ce433eef947f9b257df25e7ecf7b9b88f8aa295fd7765041d6ffdeeaa90cc43be47d7ce7f710011dfa483a5aafb39a3e234283672e6be637c0075d6a8d9a5d47f23f59b7b55ac60f6214d7f1f0445c7450004fdcc617fdd2ededb4e92caeec62457766e32ed72ffb647b984bf22faa94d5ff9e9214a69718533d51308f7ad0b1778f0ff8dc6ee5058b01d7aaba0d01ac3d62a53fb6ba906922e8369100edbe7047f7ff02b743b1102d6934e770dcc484e7a68985d3e724b30610d08ab9d1716ae64cf61e8452390ca41b49eed54cc239956419b9dccedb6649d67d855072de601b2667cd2548abddfb97220f2e5ea14783d879f08064e40aa77e7cf5c606e57a6c8b0f10a5300026d96be7648602a53978c80396eb173ed28c52c3effae69cc2ad06b3dcffe7c12ca0c2b70b4aded09161334b6566d969cb078346d82c8ca33275b61afc07ae22339f072ec3255492e163c276a30ad9767cdbb607d7324e605219e098da86d1467a32f11abc5037dcb3c354ae47a6cc538bcac0f9a3c3e17c5aa04ca6b38e6d47543490ffa8fd1b041118fe207e3db23e7b50f0e738f7fb33b8be11ab4de334affc18a6101786ea8d0492f5de3f227052f366ed807878e47891570e03d7ce99b8c5d9cc767b64d0df507862fcc6d609fb7ed6d069bdfd3ab20fcd7fe748b92307e13d9f606e2c0cbaf42b50c3b0befea3577b2e82c80b51131aab7d49c3c6660cbffd0cb22909e8dcb41e77bd264d768325ec0cd6321edaf462a51c7296185c0b2df1f2916dcf6e1f00bff11da7f13f673ac093e8a4468ca82238aa1f01925ad517e06a6e41713dbb3ed60024602902613226a23960ef19f6ac44bca5cd29594ebf7c0ccc826c17844907819f41e5624018ebab4cec250db9cf112c521280e563461b19ecd9f41c2bb151126a3459d26d2a6c6bc23b239f817b10bd3ce13f926c9aa25ac70c6918e3c45e473d82f2323dfc45b91ce5b24f9af4a4abcd0f3c562ce2d19559b2519d280f8d620d0172fa9460ba21e860dc5b0d057a9be01de1ac00bf53841ffd40d3509105c497f8c2dbecd8ac82b50aba603b1ff600bbe385036533cfb6ba9b8c7311fd3e8f3cdb2ecbdc02c04e9cbfd42398e70673bbb597d6cb66dd6dbe5057d6b5a97419dd76c814db5054501a28be155fef698d0fce0d2a0278795a598c25e2a15eaae1a37fda1518aa5e94af00660714e9be41361455b107b616f2f0e17fa43c3058fbcbc4b0c773c2b86631552996ada20942a5652ea5f0c2da8e76d47ea0b1dbf78787d3512c9475549bda24c8467c5475d8b5d2e67a01003b0a838579592415caf513bc9ab63ea133e7a56ec1a5d40245c7efeb05cc43a2691ac430f600f44273423305559fc130164ea15754b4c272499bb3a461b3a3c5a33b9b69ecf8fe3f9e9461854cc79afd3dcb01dfede38c459a12b7b37186c354d0479852fb3df7b0fcb7599d11b28eb3ddae8d93e4b398c8c13008e884ffd7bf2a345c08c5745392bfe7f7ce899391c51a09b80875cff280a69baf6fd366a86aaf1655d8fdb5dfd41f63323133a3eca925848131f0bf5ed7d5ef99654e01a0a9de9b2c6e6682e8e65498647e265c5d877d5e0bdda86f3cfd14fe7bc99adfd089e9969fbe9f44e388c1b56495575f5b0901a91c6c93589a5f5316ddccf87b3d9187fbea43614cbedfe9d1dbfa8c42a0ccaabd8eb337c0328365199acedca2468b5ce26c3b311ce81f2d4f6a1f897a0a6029c9d69c777277a2f071cec3a5e4bc3ade0a53bc2a05036d38ae91eb089cbeaf33478688775ff00c98a3e77373ccd03b519e7c7296ac8614de010b830e0997b94a37bd51c3a185710a077b3caaab643a5d641858a598f89c0924b125f825336c723d876580a4bffe5700ebff0c335127e97beb2c509d7d5f51cf003760f55d152a7c88b8dde259bbe7aad996b3d1c62a5bcc04336fecc8315afd13e48d01f40a56101871a1e5d6b1cbd4d63539f36c65d992a448d45e80baa06705226c843b4312be4472e90c98880fd721b379ded3fbc00fb8fc68b2e4d53404710450ecec30542f279c8f114c5881e671a98617c8150a27401be5abb3e81a8ae5ea0ade1de369e346fa961c4b77e1c00db687559a80e59603979d2e8f2da53005ca2f555230a7b9dac800b249d37801f08f1d208ba7b7781930f8697df32f301b351c7ac6c55f0719ef8f1d0f6de0c1f72b24dcc6f31debcba946567539101f6cb91d910a0ffba56c4b0fb32fc1c617957a747a2906693c3972901d124781991228929aa117e7ddf30e4c82781f09c53cd0589430f1277e319fd68329eae0da5fadef0c78cbce93131f3865e6a2299ccb862a00d835e609e08d295274b8e0ae27dda1ed1061f7e8dc02fa4407f1bc8145d3f8847ea159e2e1762f6fa60581a54cd2f72cc1c86bfd9a0037ba45a48e39b7d1a1d0ba2218aaa8781cd62a2f34f26ffb0a00174e04ebc48b1e1b89235ad4f4de27fa10973d59ecbbf99c29e74e5e68671c1727e6b1bd20cc297f4c603dc390959ff2e1ac8927866ec6fbe29251a061752e8ca97ca56fdf7549d34d304a6a9462dfac798ab16b1b696dc6c179c686ad6901b9595c195a878a64124c98d094575bc6377a78cf1d94b5a48290b59e2a08c06e519d37f5108311c3881e0cb508fdd0a976e353d0c03d2caf0abf20769c7366c4921c7b27d6f879fde30f8de65638de86d8c241b2e9fb14342b55435a1406872d280e0a9ac2487e5a7e848450e6af196a1a126d07c93017357a46b063a94eac64b463165dd3949789af57719fd6f310f771d619b76cce91497f7c1a89c8d91c125ad150b0f8dcb9c0c8766b09b0ff4642133de2f1df1de9647066d2a8188026bc79f1869fc9bf661ae6541ff6dd208fd6d945ea458057cdf381494a98aedd8cc0904a75c3d4945976ebe45efdb79e66878b263d5a9405b566f23bf3320fc80f16f0fc5e28e3af6c9a043b148847873bb4cd9fce6ed892ea4087be67ef246b86277dcbd03c3a43ed92380e3d97461880f68ffcdb2453980d88314e31bcbaac926c25bbfdb149a3c87e7cc5bd2534c7f85690436623756d052b68c5638be970bd148829f1f4215b9aefbf1f0fd29508f8fe68ecf4e5d2db3fe046942ac6d446d13a8736e0cf28001ed92e0a27593962023dec51b9891a573cd0be66b1cab470d0c011e9b73d06e1649fdf5aad85cfb353d0b4350daf737d851a51db675e56b9dbab327d0d64d2781b265aeac2b95e8046c90a3688f36544722530a2e18e396983b2cd980ae41755e96efd1b1672c862efd7b0ae175ce1a3d6e530e3bdde86afffc5c568ed4e21f1f4f89af547c5579cd55c5c4e2d694e207f435133adc2c5fdbfa752221063a4f311799d430ff291e1eb6c8e1aa8398e02a5890bced8fc3bebd0746d8a75481bc9938f48550549bf7a01752528876262d2c72f283528ad8e876038e221a9b777b332abc04b4fe60c59b50f5101b80cfd6c622fa4db5c85ec6caaffe5b9f8f0e02597d1aaf1e4ba716b3be6eea677a0a33e61f1ec7aba707a66a7162738b4010c3dc64b9d79577c76fb5c7adda5f3fd87929b676c6741eaf932c4aa6c7dd8369eeeb0ba91acb7ea0b482d462541a58e4f10a813534ac97c811b49678a9c550f7c7ff372712c5c8f978a4cb179cfc84fb6344f9a6bf17c7fffadf017b8e2859c76c4fe0d58c46153200b253157fcb6e5b11c7570902f17b70288b4c4513624e2fd932ef3dfb5f00d9d31f1ba86eb72925acdcc8e781c57c5f7981f44bb5d895004ddd6fdc2c5608054c981e39df00009734410f8cc69f3fc2813c94e69423be5c84bd0338752f3fb9455369319dbe0ce2cfdf3a647fe7ddad19a003f000d4d2c707c9de6ad32679727bf82a23638c4a3380a3ba60b8130d986a23d3b0982ef023c4c1a00d956cf9778a8cbd97ba11954ca921adc4f3ebf052c159db2ef5e39b1bf35c988f3a943cbd5fde2aaab6390f085eeb575188f6d9d5ec59f1a1f4efaacc6c2daf74744416ed21335a029662e726813614dcdb6e6bc933509adbb5542b528db36f5fd21c136c014952e6ef0a0aa2b676d4ec0b53528239d09d960c844ecbeddea911221c9c194b2eaa7293c5efeb7c0cf1f25bab8095e4c2212e0f10e1dde6473ec99a27a839aea6186cfcb62ee16dc875635ebd33eaea13cffaeb6310d2dc70ae6d2500e29d5af005502c50be01524182cd08feaa55f8722637e4e42f0fe3e5b74492690a5c195c9887d97071e53b011603372d96f515988be2a17d0bc419cd6871ff4940c863fdf008bbdbc910d0629efa0f283843457c505f7cb72b7345c92c9e6b397c1bdfc76db232f94029aff502e7ad3d439dab8ee708d787e6acd76463830f9aa5f08b17a198cbc63efd044dda9d6fa02dd5540e11b7dafc2a6fe44d58b9a73b448709b4d25f58d0a49e3f6d534f3688e36e0e8cd3db45d5fa10a1c7ff2de3f93e9a058f4e8949d26db1aa40478fa16145c941c83984d56f0c1946c26f0e07d001ed000ed17d3907f511045cc9c33d5bba43337e77e44a778a541e37a6c1132a074ac10ac767af9dcbd471365c7bac8aaa1f864f28da5809f860f91a6fec60a2727195871ccd34dff49661636b59954aa10dc8be994b6662ec6a1ef88ed833ae3a58039f009b569f6b1e6be63a78a40da499cb2c38ddb55a25eb79f5f3ba1c5952f12416953ca15cbf53a2041201019e67402f8f57482cc3c333a993fa5b859860338a9e8055288e398b41e84ea9254a1a679c39e862011856b708cc643c9f3cdb740b3c8aeaf93472268f6c2317dd7f17961c5058664f5ffc9cad0024f5c1ba704c69078d164dc22009a83d2861ba9015808071a30b4452c2362b65968693c76649eaaf9d597f492e592d9403f3548e1642eecfc425e6ceeb5168bd2b6f9d9502d5ae2f600965b70b47853c47e10b346465d0c5df6dac52908fffb12c1187cb9442f3287589c4b023aa9fb81a60eee61e47929d38ad3b35f12041c78af64bf1eb5b358150e76b422bafb020c37e64a727f6fb49fe96494b9a002a1ae8073258dee87d98c8f4d87311f03ca02c46775ade4c5375b0ce669c2789e44dd826f63e04004a62086845c5bbf377583c2230a37ec61ce585ce0fff0c1d3484167aeb544394e498cff3aeecc408ef6b228f5035a53e502ef87b8bd38ba4273ec88722607d89d7e7e6ff260f948558f55014dbcbf82a1329f2d59437ef3b16249fed75b77c6fa653df40ce8b4a232411b59e14633ebae6dd3d8cbb57b5a3bccfc08f29910c920550bc422c1900519c962d2a491101e4848ca5074b35e7d2c06885ba381a77eaf5e08bbc0bd743c2474c8ebffe7ef1dd3f4073dee2d3ed4039257b6c6344cff2595e1a2212192269a71a57f4a8d3cb9122f2ec83c125b27cafaa4c4e6fabcee488a1e03d626a6ca8d0cff44570bd4c1c51c8752e8ba861735d7fbc718ba2580a243abe8aad33b8609157c5388dbd38a13da5037cc3da496fbbd7c78b461c91a11f83246cd03e7f6fd68c1acf08b28235222a42cac53b589abe14f7770d15e8a26a9f4e9b1b9ebe33e880aeb8516daf6d2bb75bf6c5b7ca2346b38c31f10a4ad7d1ac9048e6599c08c8bcedc7c7b464e6d03cd9df9e2c986caff81b06b5658ac3db8f6b786ae10e3245abb118d6c24102fdafd09fa956fdb632473eb1849814d891d5fc433d1216bdfe280de5e609513df9373c6b65a9ff05a6ab32d8d83013e6067ce877f04fd2055faef163c262750457349830d92e5c7977de57b2c1de8c8faaa48a08b1a3671f68dea92cc19617f6a29bfb2b831b02d3d83118464fa31ccbc1151aeae91a8d554a21854fa7e7792a9c1b46fe4eda8829313df08fea55932628e12b8d414638f39078485c8f5b9eff5d25a6fa3544d22e7f37e3a0c48b6b302a895814cbf7e524a93b09771c6bfd166ebfc8755b1cd61894b509cde6bc90ea36daecb88d64360f93039e3389cb7b6ddd893fd0d6164862abaed86fb01c23320b71fe55aec2f2c1f95feae60b074ad159b27c3ac2a37b26729fddbd68db53f0585d060eca32a6e398738692cc31951a2b8573122e491f3764310e080937dfde1b31c11e36522f4a8e3c5b2733aedb70a61fe402afe7bd5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
