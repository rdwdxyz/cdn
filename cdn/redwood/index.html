<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc25c51431d63b66297668e7fc99282b73bc4ca6590d60dbc8cf3b66ebf99ea10a289933d9fff621e5a4468b008d056353c02dd9c0dcb1edf1a3648e637861579185c9260eb1e8aa0968c993a8efcba0b54bdcfb33277a1de728ce2f318cc1ddaf4b341081539cffcd8f6390216218949abf926ebbd569020d411d306c7891e365a8eaa26ba31a4750831606a491d494ed850e1a5edf72e35ab51a23cb9b322ba1cdde6e017fcae89b52286755caae3f36bff025ba84a3d9eebab3ba2eb7b64b0b2861deed9682fd693c124db016aeef5f1c78eda30b0f7214f9eacf692c2a0cb621924500399dda8ff65c5be597d88dd95a60de0710219165d67b5051b85b683fcd9b926b264d32860fd21c268d8c31d38bada554f9653ffe289d81bc1998fff4eb25f3cb177f4c0dcbc40c142f25c7cffd18dfec8f50529dab34836433e9bddb96b8f3ca6f6792c569f0da994811e11d49f37cc648df03c1797459f210b25f96a36c406b44815ad7abfdc27515d32405e16d572d746d011a19f25a4e74f1dde6f6addda28ce0ca81366bb9473774cfde1cdb5ae0e42458da433dd75727e626e6db204a27a62fa3a13ea9d243d51180baa5bea087436afc2c68dacf505a28e15ba4b509262b1a4bf7afc4e3ac76a9681612e93cfde61e5f1a2793a2ef52b49797c05ffdae347b83b5360fed736a7c93e0e3265cd07f2ab345345c34eeb99df40a126ff41b200ee5cf2b0e0d5c13f3bd81235eccffe0f2425a1e34a9e3a107a96a3c5686a5f9b7a0d09d12405de577cf2c8e4383acc5d3a735f693a44a1aef155d1a2e46766340df710024de0699ea634be0ecef8558c8c884a59e36998cef338cf93fc18a6c2edca878acf7079ff69643dae51df67d0f2ca4e766fae0f78327329aa39f9cc7776fa304a7b66793ac8f8db616bdcbee416c0e3aaf7cbdcbe6402a8ae8522bdb03dcf185faf8bf64855349fc3108d4abb23346b28c268033e971c80027ef5978f0b72c5334fd51c8300123cbba6bd047ebd24b27284824d9ab4711fcc23a81214fd8e6380544c06ca16bc8d8919e0af677772938d509c14fad472002a0b1cf7b628d96d36e38151874f3d3fe1cedb5f6eab634dad0c18a1087cddca6819964201918cfaae8ac9e52e89400d92bc266c7eef48ccef10c9f579e9a7bbc1ee58a8d75408aa0bced4f7a7470739000fa037068f78eb8e062c38229bcf063aa2e1a195c1c1291a5234b5dceb29347ae3f3d18bbc9ea1b7eb58e6cb0101c4d7f5009947ba8a6a2e37392635cf22e1460e49185fbfe76ea96433ef2d15e3293eb59b3af663d80352fed63ee44396eec50827645ba4dadb366f491d179229693b62be8ae0c439fe8320d0cb900bba59864b9881b2d3de58ea3be5a20649c4349c64b8fac13ac042427b2b71f9751f5a760287f2062af9c35af441c5cd080281f458157445ffad54160fb01b093ee08541547a6d99c0498cf288b319dfb7f1f1c3ed6519feddd584408ea179ef462985195ed06b13e9711fcf03023703a401169ab0740616d8ba9498c6dbf3f631d2c5524ad8eaa6f47e68da60eb6101cc1deb62f3cd3d4887d89bcb03af5ae4e62d632cc8f024aad39a5e2ac17b5da50946f268cd8b0b19f9e8a1c4466827aedfe8e1dfad922c63c88d4db1e932097939cf813d5f34c254129a8e578c836ab6ea7df78b2652c9bada30c4e537d5eaa421ee23b9d0e344b07240cab5fbfefb0be26852d8b6d960bf6de4b73d1f8c0cb5ce64a1ce31cf8b7c39f4da28205d23a5fdd7a2ec7c51d531fe9514cf5815130f7a7fd592a529aceb77562187c5af668bcf1b0c7201f0e3c19f58c0efeb6134a8696a84d59c78c862b5a451384b1b4dfb93266c6d25661914f88bcf625f957ee22559553502c848a9f14fdbcbb9e1c05cddabb323a57195118ec8e4f85f8be910fdf092af1dd162f941325dfe782ece45b302090e9cc84baec215f2391518e77ef56d9597ea3392edf6d7e5b0f567d86968f71ad89a53ef18f8819ab9bd44c2c91b0ecb27a71811884fb663976dd681955762e5c6ac7040c414eef3eafe96b8dac698bbc2d7a60725a7b12ed60e0031287e4b1fc5929f30322e295c3e478f96c33b5031104c806ccd8bf6376af71d86927895640cc42c8c2db55927a03473307811b4f68e7f86a938c260211674d320b6979874cb97330334bc88749e405df3895afb02003dca3bf760545b136820f3636d9df3ad429f0e9592c4a313f95bc1f86f90956bbfe7ff28f2a401e4bd0c49f28be7f75efda562e1384c8339e6c64bb502bd46cae74b9356a24263d09ea24dcd1b297c3595f427ec547b49990407eeb5d739a10e72712040c8ae257b4d23f4381644f2c215cb902bf986693f490a69daca99ed3464d79a00fa8833936d0a4f9e7e967488482e311710854023d78a3ed0ce5defaab2b7dff987e398066d7680099e834a5f1bf9bf58146ed824d07ba599ed6c08dc465ad6b05b7f3965372d0ddb6bd24d1840dfd5490fb6810ced9a5005fa04f78f49055755270a7052803a43d9b4ae11bfe0639d056399977da2b575377c330e92b57181d4bccdfd22221b73773bc251230a0361868be9ff421b2e1f7ebbae428427c402381cb689754176d1059c93d060a868affabb00a993b608a88fc4031f8e2736a7e02b4c5a14a77bf4b6b5635c545d168495f7def910c9161e7b4ac4d29b7d113bc580eedb766233fc1ed34d49604570588597c6c5ddaefffc2299a0ee216c741d36784ea12c249cf47d275b5f1677cfacee67c5236848e9b5c04d48b8342601287abe6db63775d59d8325cc44cc6ddd4e6f09a75b9e7be28bfce1e4079c267cf94a06bb9c1406ef6a104135764f0804343a340b3806517c4460e10d4fe536b0e9c070c07a62dd41d22f15fa319515e22614bbdca85d3c4a5c5e41bc75384bf23c072f304855db478a51a1f99ecc1d63a9c973e63e19f809905a6fb07cac47bb879403d2a9f3c4af89a229fd58e60f266d3619dfa04d61875cbf5f6b63ebb13172a9bbbfe82ce661add1b518dcd1347785dc843b2bb87576320a5b9acd5390285dbab7696f60a0478db4ecda55afdab95ea150968f300ae5783517f57600ae54fe5bedf05480ca8cb7e2d8bd680ba74773226aa93a7ba26f3257f448a317979456af57afb95dc36b35270f5b7502e09ee74a3478a39050cd09b7e40a626124e8629150b7ae7cf7f98350d5be2fb9be570006c917c2718c72da5e82ea34da97a1a814cc667c38043c63f7038e885a135871db44b611f2048e6892773457b242a22520c28983fd2bd6d94357988dfb390eeb8893f05a0a3dad6e073e0280a6cd8cd8e6d65f8b1a4c3ecf4c291a71583eb8cedd7880a219b5d23eca9c261cc944bc90dc4b4d612fa71d0f2864343b90d3828aeea99e2e3cca3d398d6b5180031a56962353c892ebee8557850e16a8b24f2881b2010fdff53b06e047e4fe60359abe883c94507e5bead06758900962bbb86878b81c43784d82398f766d3bc80499d4f1045962b2724e45a40d52d9a925f7039cbba89f7f3c0c35e80d582c35396b77f7c9f9237007bf4eadc8f9602aded38cd4f8c57453d221c04aa0a470eb242d8f178b3413eb459e8173122e494f0fc81717271489dddff34b4dfa3dbd1e608aa404b8eee6741ebbea32567c073d8224624ba5ca62e00c6fa72623a1535d3af2788b9bcc78d4f3a16b9caae5b34d697e2f04fa15d67a69c1dab3c4f70419a9f5c6282aa81995c09808c10e64e0b5153f69ab841f9d8743facdee2a43476f26036bf7fddf10cf6f09fd38f0886ec8e69bee0b8c31e6f2ef5154484a1025d3cce125d784a3b05c4af93bce0106aa8163e17b05cd2fe606bc80383ae80e473cc9696f295aa544159c2aa086587da8371d34b1a669845a2179da903eb47797711db04016af35539778655fbf966d9d4601b6af94be74e5bd1902f0ebbbf4359c7914e48644c75fcb78a8b67bdc54616e779f9b488edd5b030c48051c2ddca7eca8f51dbd92f2826b7fcaf99e3de5704175b238382482f660cb9517df2b17fd43fc5eb5554fbcc81a4ab5764d205f92a1a62ee3735cc2504b3cb7f79e71d7a7f7724337831429192cd135fce7d0baef15871fb3fafc9b8509df826f3fcf5dcd7b8d3f034bfd8c9ea2df028acd89e306d723f2f79de4aac6f8af434158d9463548c61b3c4c48bd9af1e76a2e1b653d075921b92eb75f967dc6f41eb71c15030bc713772e25bddad02f2fe6b03af97d2a48346e3b6d0dcf11ac31e70d2ef8f9a766b7cee16805d83b6f10da9b423550d192cb6988fe8f269e6d00d6f15dd9f7b100bceab1b09525ad641d79820a3f742eeb4e1448cde3c3bbb4a0e6b12948228f3f45c1e0d44c866429ab08316d231bbb7d7b30794490fd6b9c7f1eaa07b01adb4981010da2671d3a48d5dff70538e2c20fcdc2ae0788e87811bde87d935f14b95b1b06c704f6807a88d16fa2fde252d948c57a5dff4c4144681baadbcfd5fcdee7e68d5a9663357aa816552393de4a4e29d0d7b0d35ba36111097a926fd0e72b38bc04630cb92785457c918de5dd2d398fd0e1dbbc3b435f9536d5bf78b4d8fed92fed1295c3e7454e146dcb9ade705fa9efaa0290f1aacb0df17c911bb7db087fe4f3d79491e0ad33614d322516f64c88b60aa8649491a771e72073fe6d57b65b5303a0de80828486ec50ab8154d613b9ce01629b47613c14627b791dc0e735293943430bef843755e689497c4666ad727fb4aec3baa6032ed64438bc8c30256cd8cc04c340cea8060f3e0039358ef333b3794572d4e503878ab8ff57a5c39b0b2a85790b285c52d079b7cc3304f327db2534d92b47609d29fd5ad5a963dff5eb707dc3536815a2e4b7c20d2e5d3bfacbbe922ee85c8ac9a4113a4faad50c0328d77e9176b1cd0d1ed8d2dc81508bc430eebd01b16a40e0d26f0d64a4213242b04c447438c96e01372c240dd8c55f5756b2694a927e482f77571b14e29eceb02e30e2a83dd9929bb23a7290872b25cdb2699fb8838905e4fd47d750036a007ab746fcbbf1b06ec52940ae1fdca1df2b4e746b67c9c38b21cbec11e905a2f1d4edf9e4e95a8d0f4de6a50d996c49733fedb54a3cb81cf68c4f9aadd68998dd5922cb260d687410e0edc2839d421f88420c05630dad2ffcbd53d64e0008e9998d0f7fa7c93151ad2487f32aafc34c088343b5dea9ed74e99e2ba57e25a49ae7aa12f5d77a2926399efe8744d7cd8520205d49f1cdf8c137e0384770cbe5ef6c4dbb17f83079b5703308c6b7fd4b8aa1f0f11fc615aca41ecc77b4e9bc9e8b443ca0bdeac94f6c2af8d78d02ae85255759842e268e734ea930653541bd16a818b4aa7ac03b0b5793d9b359de6357432ef142dae3ba329959b4e1e029b2074375d116fb5f3165fcf0c37defedb8a66c739cc0e56aae7c001ddf41064afa6b178569e06cf52910dd3908237a50bced92c795bd1a6cbba4f5e526e35b0955cafe42c7b84b879aa618c65efed9ba1d51ae89cdd5a2050275163712202fd116de76a1eb413d3fa01d3b9e204152ada93e62e4363ba965f590837f122b9005d27c487aa1a2463d2f9edfdd8e40e69b3bd3f0a47825074030a1459034ddcb8fc053b01f67d6e4c824d6a5b2276d023ef2c6f2c25aa2224109f3f52d6735ca9ab4764296575817bad279c9083e0d5dd152e5e15f26fb4da27abd9240c15bfaf23ea4c9fc8dfeb37f15b85b759d427fefd7ed2064a00dac9ced5ac9e496aef9928c968aea0c3db465b7b8c959256c1ebc7458d8850235a43b98d91959085c3fa5d4a3ac4d3bbe9bd2732b8822eea3be4befee49572e8c4c7c86822e80a68b308bf6a3eb35ec0f04787dc8dfbdfe89b3325e5661764325687b0cb897b1ab0b75c98d4c2bbbcb63ad0cb85c7d2f7b9e26729d9564beaf8fedb7c516e0fa99013f28cd02e5bf3738dbe77ab599c171894fde6a35f4c304f74d03258e114be11dc69cd07c803f01d8c25845f32ac8b85f8ce2c8e024e99c8a23fc664b0be0218595e9af87515b0586f424747fc8613d0a9e01741baa356f85813bde5d8140bc313252be7c986722b8f8deeed49eea44eff72285db593239501d850c651d06e6555d23bedc5e5f729e476c900708ade97fda3617d9bdb83f54acce46e91daf5f230adb2506fe06678627e937630f5e49d7c8cff8aa24d52faba8296be9e824fbd7a20a517f66294cee9d18e5db6640180413bdc9306d5dbb5be9e10e13b452b65e8c471c681af5d7fcb063897f78b7a61e246fa3bd16667e9111a6db29d6e2ecdb8ae8ac6e37f0ba1e5081eaa028b20dd40f38abbaa5dcacb64c8bbf11d4435d0e194d7b1efbc855cf313bb7832b5efe2319cbd66f6cbae375d32714d36c1ad7cf53a55d3980bbfe76f7543ef6c567b1df713fd96e03191b04c6a7283193b556dc9af6ab3605e6a6a7e8d63fc50130c7b636d9a04f178ecad1dc1b1fee6446eda3794bf25573a752b7630b3e0da2beed539aa3bb1b839e85bafc420b7382c74262b0b18bf047148ffc2c988ba668f93bf55a9c6d5f2c75482bd6460be8c767cbfcf8958a52b5fd2fb4fae309aec09ea82742e8d110ee961f5afae829f5158058319b6506b1bff468fbeb2e6f2de69792dfbb4499e8f578faf6ffa14ea683774409b01d67b195bd3b65f37188c9fcc4c0b57c7f22b9202a85caef75f67d9b70d54c34b1bd337e5c4ce7fa0a0326496111df41a9d5556a73effbea0b8382922ea43635f84036718f83fad668c005863836067d3c65e677f9e60cfb6e38f06029d8e1cc3776e35fb249c08888234bae3d710e7fe874b8fd39b2d07d964bdcddc3d013f13d3be7c06583b872b45a3b5e90933346b58d1a84f0b1185b2f0925f7e90486b1dedd1ddad2731e32f7c4f3e2c7b2bf9042c3bb9381be6df18bb6fab08ae75133990c1e828b140aa5f89f145ced58149bf63b8762cb7aac75f19987cadb57b47a06c039e1822ebcae1573bb7282ae57817e186a9d512f9ec070971ed6f202b2b80db02c6a221d20c09b93d7b274f0234ca823c34de1da90305cf46f057497fdfe90eb2611b4cca796813c6105584726bda7bb71d1f2efabda219eb61064ee92bd41ba864c86ecdcc1e959f47343aa3ee7d8f994e1f602a974442cffbbb49723761b47fe44b541e020b633a842c18e5ca096076421a495487a42f632f327648d646a3903e018d3fc3ecc8ce5084465796b0763b1df9f306844e091cbd037dfd358a414f2f523bf5d04657c853ca863157a820f810c53e51a775baff6db9518dd80ad397ffdcbf3768a561bd554c76b580994295a7fc5e3e939f43c47ac724faba24d1d2ea7fff76addff63e6c98c295606617198a5c44abd46c9a5b2ecdd62f86de7ae5bf72312413f4cfebe9bbd2165588807dbaa085eceabc92d8f2060489524be2a0eeeb73d409924c6fe2cd559575d315d97aab72fa9ab58897bd75e0d123bc700641ff09e9e0bbdcafd03cb6cfc93ea90faf35e5164617c5e822c700f8fbc1e59b5df3fa5c2fcbf464e79554c705f1ccb8653f439c5ebcea3bb3029ecde59332fe0e274e0e2aeea47d8d8752e97cabc7ce27048d2aca6c40d1a08b5ad6c2ae9a95f4ba6d09003dbdbe5c52ad62a3a7bbf1db72ad24ec8ba74a61cf82b21ed81c3189e62add916dc1b97c5b529811469acdeef52435447c394fd2161f4670edf9b19cb9f81550d00bc292117765a1002f437d0bde66703efe70e874c009156989873557e2ea26079fe969006c43c0a481a0850648423f031922c05b6e3f25bc16f7b2bacee90796503659044dceaec7188cc0a64071f6c108e7f7119783dc32757745c691a5d70034108977ab7a1ce9e97ad47d6c78919b818bc8e16737dbea20edb0b61be9eb8609704a07e8cdb0855fa4d39cb8b36cfafc6d2a01337de61365edc529ff257afb2f438de7c794cb54f9d800298bf6356d3656a7f0ae39ee30e323d5cceb8af691e4ce35471287bffdb39c387384e2ced1248e9f13086609c394c72462df5ec27ad9ad15d0fc70b0ceba823df19d627eeef9f9f5c478f5438026664e854057e1c4fd7b3c4af6bbe95ac7d0abed67ef93cab787bab96b51d6313d9c55b4be05647d630e4407d434c4bf29d556e2577d2876ac3f0175a8c209d49ea7fdd4fb5d4418af700c467bd591c59ab3672e2e67fc0491ed5f8f99e8c1b68b26a7492a11037ccd858b72666ba4fd787b1b3a3931574bd22339f451a62f37cdba74adb186a4094941525796614855df3948d720c293ad6942a7c369d1ff800a1d2697bba5124efc8513716464ff6b1bf3f76bf1f75ec387e2fd8c960847c5a1bda0cfc4c9aa4bb05dcefd7ca44a807b2d6f231a3413ea765e46f7ca59de47fd7b029940cd9f106708edc70af18baf5d39431aa4294acf73f292be97cb28b7d7c414393282e966cfa535b2ce79b15d0b013892a56b2b0300c7aa2fa7d93ade2591430c84dedbbab50512688deac75ffaa039c5bf97f98be3afb6a62fb89d9e2f045c2f17f0ba5d71d2a8a35d76d6e3b9975866db4f25fd9dcae1fe44d3852a7a5c015be435508bbee2a58d4109a6e5d6aa7c5f9cb91547dd7c81edfb8f3997e0a739ffe667f0dde2f029bee0f763fd68deda09a8d007c899f4b95016860af19e3329a3a85bdbd28bdd9eb099cb0140d92c8d81b822eb1cf91475c902f51917861a6c84c6ca75d6cfe61110aa61887b2ef360281d3452b2c3c62e3ea1a1e9dcd6d75a173f35a32a4c256cc321564311cb9c15e638a4e08074f3756d595123fba6963ffe265552abcab958c9354cd383d3632dec1050c06b1ece940055cb4d94d40bc591a2114bc2186ccfafe9e3f85dd14e85dec2f3b71c0ec08c3df050208b88a613f668753ea2477234505c3cfa78115a4db1e0b8bddea229c093963a6c7b7d8db3d7fa25d7468d255b0491735ee044085c98420c69f6596175076a871a8a7b3c7629451628179e84f6fbc97d4725ef3833adce7bea60918848422d8cb97322179c2edb3355a79baa929a93aea5f3d7cbe082c6f70255aacc0edc4204f8ed1064826aac74e99111a8987a493a6dde7908232c723401230243b77941d37bb95b1e6e1044385011fe61ec58f7a83f990f155a0af218cf26b80fcaed4aa2ddedef15e37debd294d096c0c6a107816cb111e78ea9554b716939b84a0f72b2019ec891853b08584f8150fe3a26e5cb27f431a4f08055dcda105e4053d95cf1312846538ddd7e6c562e092a1eca64cf58848b524c964027ac1cb9575df38740960ec28066e427d84904979436c7b23a16ca64640eb42d34e08618908183f43288646f465aef578e0954f7cd1c4b590a5fdd61858d3aaeb374c64a38abdaa976dd090733c52633c7b26d11a3731544d7342cfcb041780de89964f47f1604f5c11899c72d79a6f63b377a47a78333bab13b273e9d20d82a06a8e3d7fd841fd11779f8cdf42f09fa83f2099a0c713ba070101277cef22e1bb7fc070061fff29412767bd249f94a3497f88baa0f2e6f0569c37e21b05c35af1db18dafc97ba7adcdd49d76448d693261a7640bd3bb5825b48df7d4543f0e6cb5abe284c4acb48dc022fc42c17441462e312a2d7986b865eec5c882cf96555a0fa42f55a0a0aa4a7e46b0a00d45e090db7ea0cff913772f42e4552d160c48920faadc04198c3889d6b725d85ad1ea42b1d6aeab170490a9540f49ec524ef30a25e5e227f5d7c3137321b414a213ae0950cfd6fefa08ead16baa14127a2f2e399595ebd8b370b0b5bc92fce641dbe8706e51de867025e16c83b2937b904ae7b50025ae579171a2ac6ee368c69ca40e0e9fc61fd22f9b4fc3441b41bc247e87fe1abc2c88985c727841922e6cfbcd4cc1abf222abe11fecaad7357e3adef265d2f44eb3df582b957cd75da11ce4a7e9b87b2a37c3e9db35b38ec600ef0a12ceaf67c4e185289e5eb1d87577c9b4ac13f1ac36d837b77bcb45176667c6e8b161bb8ec52de5335cb53a6eda4fd65782946631523d68205637d16256d423efecda484352b7dbbb744ec8cce06a01c5a278586ddc5bd9aa9e4ba6c36ad5a97ad97b04f12fba67a7cf03714e0e558e5536e4f17e754fb0d0db6cab555f3962892ce087b88c2997be78f1ae11090072086d3d48e87c7a76543f165a5ffc823118357daeae87f311d1f77c033cc744fc75fb4cb440a5b3633f3c1a8e5afb37ddf46b9efcf4b7039361034c0449b531327687ce53b0c942d082a0530cdda2af4ae5975f46a0c7cd301e72e0ab06776f02bcbb94a6be3ca3a44d65b2eefcd9cdde811076c9c6cd92cda40b69754aedd2e04daf1144ff49893cde5ee2c5c929316475ef5e8686a5ea47879b8ee37ffb3ab5e5a488e8e22b94afad5c99b82ff35482128100f46b8ab8077e0b3f8ddea6b44dcd1fc091a0026d8118f69e0656dc91cca760ad26afb366d63b8fd6737940fcadf99bd7e49bd24841130dacecccebc3acfd2df876d2f0a3ac0ed36f5f4e2c8702897ea7863d08b1ee8309208f8b4dc0e2832936cbe5072874695715345f52644508ab46320d46d085320c527c70a72b93d3d9d8a387ebaaf12505e466cdddac7117177c481eaeab4e8cb1bd01aa8ceefd62feb640294d21e36eab337526efcff15d6aeee8c432559a2c512de6f2d9443ffadac6cd7fbc62ca36c4ab5422278bfe217d97698e41e86caeaf8573c3c8447436c7c05063371660eaa7fb7091e51a3f9f1b4c5867781865e12beb451f634e87d0d71b6d3f32fb3e505825435b0f617dcbe17807c5b598ed7abbbe93dcf520de1fbbbaa6b3207890465cac7c91f1d4a3f6469e46a3c4b988958b44f37801ae33909e7957ade384c6f8a44e382380b300b7bd79d79a71a2ba4ce30478cf43479d78d1be591940dd01254cd8053f72e8d9b4ddacac0dc40c49c9ecb556fdbe6009c62d2d7399e0daa9c79eea237b5b12762f4db476629e906bd7eb703b8fcaeb44cb8986e8a73f08d51ecc0f565df05c46803cfcedf16d9da4ba15538e141db024e42b4992eef6433461355f300b963aafde53f4a169c7db2fc4da3adcd3d68c137976a2f6af651b2012912949f80987de4f9e1afddf866ebc6cd3698b7baaefd1d2f0d588208d9a46e9342fc0937da679b3f7c69a6e9f2d2187d1d964dd0ad21a08ea34247039b721c8c85fb5d36e4466a4eee040d035bb293102d156362cea36c198bc8b4730a032f9c47cad8c3bade639330b3a24e086b869bb23e5678f8390038e9928aa55e95a79a4c65fa1120ff240271ae8de81c8fd345d10a29ab55250bf575af3bb312ab70650d3d8a82fb0d042342abb1a2475e5dde93cace2a1dda43f8573083fde4d2c504aa39ba7e250a6c169bc97101e0ff4ae303c9da25c1de59ac3bde00e9e718ac876c4a86d5c6a967c61e87edb992819896ba743028c76b99ddf95ebec54217f12da9adf335c0cbe5d6690561cd031d91e17e55bed2e2758773ed83064300a1adfe4be15e7339f4d573f24cd95f0d457619412fe888e393d2a01eef9d966b86f77fbc6c07d2a648e78da645a26db3721f4fae238a46bb060b5f6400435632fa3906cc2680c799bcd03f01f05f90c5d1f5dcf80b1d4a109ded5f3bac0312a7e9ef16f52dab37cc6a4430e4b820ff8caf921f012bd2d0a1b92397036ed7b64e5bf99af971c07eaa1d127eb077f8f54c7f17478b0efe5cb0677d3726b82ab062675c6f485dbf14021a59d45fbc94737034c1f1866d73589ebf97314693129f303b29044c0e99cc12a192f095956a8e32f660a0beae40ef7c95128cbd34dd089e908cdcb0111afe753afd8ab89cfbded4996630f22b1f502684549adc8135545f6035af8f1876e3ae76156c581ae104fbafb4933210f9f9092b28e86f771158e6c6186f47cd7112bb6da6f1156955a92f23c308a80ada02770c65c2c06b9e744fd04e66bdfda977e6a328dbd48fc21ddcc36aa8123f5656001cc9798fdabea79986ccd11812360bc4c6d1d5e565d411f8a3bd9ae62fa6318378bcb88182a9933d4e64425fd22d4d7b5815552bf22046a572775b3fa14ec203086abe0c306ade3f860611c59dfba1e4022aed017dfa75c38f4205204765a04d95d32904ff32de96757ba2e87d2366d449ffe17b837f031a68caacd0ae5a8a47c856a86e764d37acce23cbd819a1a1167ea89dfa521aa1ed668183ec42c3dc642d48b449d3078823a5a7bf74e56836f2d39ea738dafbf5ff0f5c16460a3bf11d116bcaae2d08bb0a298c23dd7f22af9987ff168ac7119ef6f67f62478b014d0831c00f9268c615c88d6d05a01316311883ce627e8af5fbf57ecc57f22828fa741e92c41109048b9b8ead7d5c0db07ebdb98a21e4b43a83dda1512bf300c5ca50d772b9ab4ebfd41e30b44784fc350a16c82108625aff04093a76b594080e667e6b1a69bbd303a453a1dcf867fec984ae3db4bd6299aeaaff3cd90d60a27102d51abd942c982ec8cc8b0e127a00807a099f8830a32471eb6095a42f49ea9aefb87c532b2b490db0d83d3ccbee66fb7f45292b7dffa868d97ef81796189b5b19158dc8b50483c082511739743247ca4f05cd223a226ea04e0652e62b80789e662f0e46012342be6b7644afeab13f2d9cbfb0a0d83879e87205ec50c61af8b3eb0993019080a2dbd4537251e641f2a0de7bc65b3e06b39067bd020bf02446adc2709c3cafb6bdaeabfa2e9751dd28d1903fa6ca2c2b7047637c7f22ecb4c09d90873bdf8549fa5728721ccee5b4ec5d9b8a59f02756b294c8129372321493d3c8f9c1a920acf9abfd8bf43f4888bdbd0c17c8b8b1a37c3e24ac592fde4f06d65637b4d91b337a4d2ce33e3b7903432ff353415d3b962f88a3ed3f42856f8b430c733ba84fc992140edf4490dee98feca24f8d637cf468dedb5d499d50bf2bf7502229baa9ccc456e853475ad24d58ec29d0436946169a73de4ed7f98090d1b4cfac9d47ea2aba89990beae7ca67508008d5db919134e5d443751b47ed9a1dcd9d64db9a7f0afa92e098f5597ed188db7ba1cdacfb56a851ba844f3cacb09e51d0d3f79703e183aeaa6fb9fd1dc3f96765aa499d5f1771bb432afaa65b4796d4965f1382b2396bfa67f44dd3fed00635d6574cb141ef25492c58fca2ed4e7079a23427364b56e5c3127163abc33542de6e4db0344c72d766c8688d69f24accacc34db948b268d17289a4a8d21658f88a46ad015404f43670cf668d44db620bfec2ff3d67e782f5ffdc7162fbf8a961bb58d46d64d92e49266f4458b883a8b883f25fc990e30d627370d9e22ff1c8bb5cc81a8bcfb04dd21b994c6fc2f81a80cb55412e9da020752173ccdd0bfc9320b7d98cdf67bdf01f039aa3d5eff4d782b728fabafbb442cf9f3c39c056ddb9a91b7b671dc61fa4b508f3dee26837dc5ef08ad7eef7a0accc0816020fc7d2680136a63fb79942c58e2117d291c3a3fc0a5956d2c5153befc433ad02cb65987c401431d1108aaf8834c917c312b7db9ecc65a53ea241bc858eb99cbd124573e6a266ed3c680d60184dcd1d44e39594975c68f0b970042718b9199e9fcc1f788534433b69bd477b374561b03de8975c2ca03f1dda59c66443bce1af801829c3090b29ef3cc349df2d137dfcbf1aa96c7af57ee96a9b2636999ea2e16b6debcbe52ba1647c12845e2320a537044cc353e9aa35d92ac38046abb435b45db39ab62077469e4559c15d59f0ecd1293b032e9a576c7865b95903354e425376886f239fa087289c0596239fa702d97dccae3abde2f32496bd54410e8a1ef6d22d50143c346347398a298ec914cfe5c6e1b9420b6b4d6384b11d3181327aba7bc73ada79f7d1041c15777280ecb9bd65939e53cb759085772c398b7f75efe9ba6022397651d9242c8d46d4064be64c64b6f8f14cf6c80cb1cc20d8f0de52787db63e8afde75b46792e37f6f2d996e23ea6ebe6da9b220fec1d219aa69f6813194e4623e510bf3f4079e8bf48525dea5db8ac0d5286656e88a3c5394147231118bdce9b51e461d358878e0246230819619e0129e87750f069414cd69b9cb8f4aa9d0107e7c973141b100d17b0b550e06024e2ac60fb2b82e2b7d3e92f8eb9ca233eb4605dfe5b46de62c3ad800413f48242a9cfe01b0a9d9e85852668a1997e49b2ef704c04873a7e702d350eadb3c68906340826f702dd23b2a036dc62d78ef579b7912add157912c76e906016aa9efaa5ce5593b3030cad326e6311da7353070b9df873a0ba64426327204baba5d732809b29ab419fd4c8caaa55193d030cfec87bdbf79a2cffcbf6d4c8673531f9845325c7d8ea0400c113cbf20093b304cb7a3a500dc57d4c52a916fe476dd6785cc3d2b846a970c0436d00944444fee694d7ef32535802265a2b2b8eec5eca40e4bd43404a5307a2946f0336a64beedf541cbaa35d94c69419d4386aa7cf51c23b5af3590655deeee3013815a0496a95d3edaaf4e0318f0e9d125bdfd8c8593e541f582bd6e2774f8741782a9ced1930302127f2fcd60c8f588eff792db6d2f1d4884bef4aaf8d3553bc0b5bc06e774a86a345fce84015f32437debd726219ae815e161e6ff2a956d720d2cc70a2ebc4665dffb87c85b463ba7165a4b73ad89f44429727b6d649aa827cdea7b379baa9033fbd3d39acaed67a911027aa365b6a775a934af5c74af11f59b89b0978b55f4ffba04dae41e4df49c8a42f6f7f60c1c5755f54a28b10a34fec86629a46b61dae86efcea73a9b15a3d880ac2ce03307d99b6cce99c43b5d9c6b1033585ce6824e10793cd32c96d707b666152ec3af1344792e7f2db84477ad9a12dcdb8478e7397c113aab5d05c3776149e87aea5a2c906c5fd423bee6a181f19683a9b5e927a96013496e9694a36ab70923a60ac041d2e8885b484636c7a68bf5ca855105a6d765e1880d1d5cb432d9640ac1b901b6b1b87508362e9563eff60cc40428bcd34b24aff4bf8140d487055a495bde3edd563e655d4fe8511d946ffc28eae406105e78906887200281a6c88ffdbc5d5e36de2a540b37cf3d6117e32184aaadfe2792fd227009835c233b583b9f8306571181397163b036c2cda80b2755eefa11288b0b6bbf5c33ec06f3db0a2f2a8f2c554a7a4662d06f0dd261382588aa85f35e2a8c635487b53ea1515645b29c566d8506a8cb4cbf0c8a9f1477f902414965788801179c048bd0b9b5d98a4a6bb8ce81661e42f44085f65330ae90fcf4c52ebcec2fd6833336b9753a02d4b22844cdd22dc328e437fb0cd1a6fafc889ffc5eb81d54b110dfe7f9cac6c284e4cf132e6ceefc9f63d75a34aff898386d5e808ab0dbaf4f9c11fcacc13c5e6605b4a742d19db385c2099d80a299687c1a6d6428d81a6c26dbb647e6501c12f43d5ccf4b83b3160895e525633543aa7de7dddb0d4e4b6a556b1ce1d67b2c692e5e8b5eaf5543de17794cfd735874940928e0c0ae5fc27bfdd176866ed568ec41d24035e391f6d20b91600e452603ea0d9d26de99ff81ed4d97c69db08fb95be48d79d793daa83af64f201ba5357159585ba4ea22428378fd6040e5c3bfc827e3100ab062b8d6a70b69a509e01bc38c6ae3d9a8c663f63403a48400f8b92e256a06754922176e4b4616516900a01ade4fd586e2d4dbfd5ff16859dedf569a79756de95de32f5289e271121f9d33c463f259a88aa97b7a990640410653113ceddfaee5dd5940aca23951a3efe75b503568009d1734d9e4c183839ff66ff36ead7f05e9350f887d6a43c6f802aa14371c5f54cd384856823ed1cd704b5a74efb7bdc27402185cb181fd0774264fdc1c841fc7bb5780e9583909fffb901da2724f311c72b591aa6edb66e34cfd19bd7d54c6bfa783f2eb5b5a3df7ba501a2e70d8549e3b03ecbb402c259da1ba8f61aff9d562a05847cfb1f1e77954320037651081b80c5a4c7f62fb6c668bbce03058711c042a14e97e70bdc742c14d0fa330c62bf73a8500fc059af149dc77a6febc70ec11b09bc2ff48c8b8531f1f99b8c046e75069faebeea9f1a36b4360078fdec4aa0ad216e53336b8df6359ce6ea1a7c500d09ff1b94549d38ce42bfc04a5a8607cd62a46bcd873d2289675cfa845866fa4944f0fa92e933f6b48da0a94ed3f1b8187b5315cba69d752e4e9a66b9e4cb5e29f105bccf8aae34991a1fea83a4ab24e61caf4ffa3b57aed40ce4b28e732894171612b037c0b34ac69f982a03e271258646a632522542447a4afe039fe741ef3d032f6cb4b721241c31cb13a42b8669bf6123ff05c11ea2a3a5237386c22ac1513b1d9602e53ce367cccae009dc03ae0377dd1f2010a35913606181666c68dade35c173cd74681473bd4a9d51bf97f74e876ff3f94ccf2cfbe165c795f1336f4bc7436905bd4ac2795358ee05e0cb96531b57876f4b7a353f0f20436a9b785fc52262c687c00d9f48a8464d1c95bceba9abc93dd35404512cf2d6ff8313b33aec3b6f8b95048bbb4d0a93b01551591bd46b3ef1c45fa623b842858e2496b70ec17d59009686b9d404aa7e6819c2ae73c46c1c827eca5a846150a929d3fce104d016fbb4870d1ea92824da4bdc6fb9bef12def3c0f3f77eff790e937f9219af300b313849d45581e12da198eb06b57c5073673ba517264c559be5094441604f26dc63f48da2eaf683af5197226e7cb8556903ea2746451daafe39352201657e375ff48cd0f37d54f3ea31060131f7d05cc24d8ce256c28749a798cf20fb12ef1b347501b8822cf6f8822dfd383656d3a1f18789b4d328aff7a430a048cdb6ecf26fef90de5bc3a0d738f7e8d97127d4bf67ae39a1cbaa07885cf15e3f1883f257931cf6f115a7dec6d8a06876aef7a0371175f41e19bece18cd2e7cde569e78e4a25d7f3cba0eca96fc888e608d69d3c68d83dd476d0143e3ae249804abb7238ba49f78828edbbb3e37c4834097fbc96725bc0f53b02dcac77b26f34f18c3f2f1f1d84eb23579166a6271bab33f08f94845e4be502d66bb6fe4d25ba1499bf086d03a5aa680c8df61d80399be70fbce464f252308b04d0dda49feed4727d7a969893bae3e3469215c289528af174ae337d629bccae2fbaf774757e8ca25a18448cb45b1ac42cae451e5a2ec4d15f80a4d8223d29935b2e746e30bc00455033f8b8ef9090b3af0bf86e412e29e7310c44e741fc33ed0b9d2b7adb8d18e16962608d1b7f835fe6d90125776fd29f91c3f14eea7825561cf4d9836da3aa10ce9afd65be965b31342cbc1d073f83d376864ff06b2f8859ee0bd397338815820079e2d14f4c565fac2d6dd36cebd84b264e2146c930f907fa2d488b61f400b4bb2ba84c9159ad7a04ad3e7f83e7ea6c9601c2d10f740ab813d9fd01d4aa08b85bed9f17a39c3ce12b6dfa0cdf53ba78d4b61767259d7c28f9c0bbb6320e30bc340828e7e803edf4e2818c8beb698d93a0be0ce065f5e93effa77b3c197aa373c1c629a1211b6f525c63d65142fe677a059d1d54d17fa671d8d38b5c4391e841a219423b5b11367bf59b5340c6cfbfcb39caa102d0f9815dba6db5dc80820192a195c1fb6d1788c9af4570ed706c84a9f80c0a65d7eb6dae9089f4b103b14cc86aad997982532a4fbfd68a3a06af7378eea4b6413d685e5ac1585f2723812de4edb41886cbb9f46d41ae480bb410da2b65c1f68cf9c8709d68f70f7d6ae5a446dc8361f8dbc1405dda9d7652499e9cf9e10a79efb4240bd89f9252e55c0c1390864663ade1f3dca282c5a1019bc2f34d39b1a83cb1c541ba44e7d80370866cbfc0dda5c2692a44d8a394dc797e76927ac1ba0684157838580b926f37ebea3924a66a27270a7c2cd7aa52aff67cd795fbbb1410523b17d8a8ba9ae1e957e4dff42f4b18a4fbe53032f9a82f1c3fbc0a8aa8ac5d0318755abb79b24a8190da241f8cae3e6fb5f250580c16fd9da5d0436b53f0755d451220823c3cf4266fc7e5be6df852fa7da868","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
