<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a04f417a93ee3f950c5b483b8b54083170a1d2c264e1277c303a16d6c449326cfb389173250142d0ec6871c0ae647cfb2bb5fa9d13fe32c961d168afd04d914f0c5edcf8e02f5ca647147bc380535313c3dbb5f74228100414d0c40a1c7a130d8aaa97e3d5694334de58222ff7b2ab0c379566d2451eb666e6d9bfc60f8504729001e9f3b586df1d63aecb79465e520deee2c5052c2ed5a7712f013e80ad7eb1f9050924f1965862572012fe121cee3a9c85ccad50d5dd6b9dea0b5392fdc87d678c8d805a8e11afd5bd272556cc734449ed6ad35a35efefabb2a75572e1ee25abfb740c063d01e9d813d5b8af4ac50ecaa2fd30110551fb9eff1a2300be5c7a64edf6b6b835f860b2bf046af534c4b98cb35310d783d81639fac94626fb2e00422ea2bf1dad5bb639e08bba74f5ded99ab83bc7b7ed843568d93664367c5a5a5f38ec84a799e788ac95aaf5907e125c3387dc9ff508353ad303db2459d1b896cf6ade17a48c30f296488baf2d0b61252a3cc339dc9715ea57c14b23e3cebea5a0e522df8357bbb24622c62794423c61aa7a296719ca5160c418675aface0ae5b41ccb28156ce12163585399747d6a8b218d0fd7cbaf0b19b81c9b01654e6bd89ed961aaa0ebf80e03523240d4f79ddd3c34b59816edce1a9e047f8b115e69828356ecb0a98426bddedfd98d8b1a432ebe9e52e77238da1276f6c083b93fbc46c7a90dbdd671efa907000cefcaceca21281882117d26a54c22fe79d85a5a5fdc3eb01ffa1799dc79ecd7b5d4e9d8ca1fd4d1758bf6f712c379564098cefb69ed03409852a32a16009e0da9245c73ba9a826491f91d0025e9aa0bcbd8c0cbaf541c34030143597e94c29877a1d0d12fb66bc194c3b0c1e293102e4e9f9307664238332466fa29a504e1108aa9a3f150832e64a7ef1389292a0f82127d7df8600f33b29dddd430b70f96ce8f970c0023aae9e89c7126318d8a0c60c3ec69a6b87091ca15d2550fd1fb1c3efc3cf52128c9b1ad168f55a05c31b30fbdd22491cc521cd7a46db8d38122e5fccb30b69fccf0e4377354ac367a5622246331aad25c8d7da5ee0a3dfd5963004cafa770de7e5cf7c3714e5c0aa291756c0f465d3b829072b5ddeefdf0bec6595de0253a6e7e66aaaf61524255643ec7f1b2793f046fd89e85b19c68a1566046700082c609a57ac3c8cef1c182cd4e9499f48bec37ea6c319a9dcdbe8b2c023ef73b1a65af4e318e708e88831608a38a37d7aa4645ee6fbb568ca69a136078885d2bfde8e6c465a49adf5e0818bdb90a087148af064b337b47608eaead7927bbde6cad94bb0bf9eda0bca124469f2dad53632884ba53d7c5ea1c452f2d8fb67f945a223159ad6895aa787dcc71587c4f5c2cb4b98a8fccb039e9a47c2cc516b0fe242f06c5416d0de8abcf10fc1888c4a1375442f103668637b3e836411a3344785bf216c6bfb20c08ff673c99a28d0e063cfdddec6b41a0f08dcc9835210d304aec2a03e9f0cc4bcc07168eab005fd134687c1faa391c654204d0b597fa2d7a1f001a49f09c31087c5db41dce038ea9d4a68e9e7bc54a99e994a4f74bdfd993fbb236158a32f3da1abe130c9cbfdd1ffdfe6efe2ff2a081f34e94bc9685b889cad4223d5089537b65ef4b0c471a4011695cdb633ea8f2d543d61bca7897f9f074b870fb638f7cb736e1433798b20d878e853095223aaa5c6f0437c875fe253c91a1356c649b8b98237bd1188860158b07041cebf76456e536457c06bf700f727cc75f43b9b3c094aa07fc0d18746084f408e4ada19c8c096f841862a3ec04a81d5713615ec81fac5a935f5830647abb54b30951578ad647a63dbb6822b20bab3e6b03a2e59cccffda1bbe92ee7c9028c03874626bdaa91ce991838c977bf2b5861b11e0b53f8244bf4fa48eaadc4b35632c0bfbb73f3a52c6b1a0fc126e7b1136d3094b61fa8fdd84c7605350889b035d454a172004284a1732354259e937ffe374b97ef6e0cd8b097296cc16964a04daa331d8797d8b4c90a3e5e271be2b49fcfd5f1ee2275b5e52ee1649e7dfd95f17b59b3230293ece179be0e0ea2729cf49101aeb0785cd8e2abee38b9eb63b05f38fd1ecfea8376bc55b01481e6b6392d4889d971c5c6cdbc15da19128e0658f0c4df3da42ffc2f75176c994033ad52b1badb685a646dcb53239f433271d34e362fcfe5206fa6d82c419f093552229ed5055d1999a5c58df3576888b427639903d3902d77426aebf4059fbc18e8ea7066579e5b169aa3851e1f83e9cb04ddaa3cb3febafc27dc15c385ad49d5ea50571c24441f961251c3f101ac040b90e0e58bedb276da5571db0cccc31ce82aacef94384f3e6a1c7c8a18883791788883e7a9d11205b352b9888f10dc87b19ba26f1fcc38be486dcff161a374b87e101c659be5f06e7b71116dc4ee4538d09291107b4753601c2ef39b6fff37fe85abb3e1fef2d98d1017b9f04ff5615e9b97bbc59d591b2a1d969cc789d9df2b0e2c5e1da895a11363c437cab3b0d6e1aac873ce3bbd6711e617a30d20fca80f1a6a5bf1523affbd5847e3f784a27e477c80b25092da84962bba3b65a3631622755cde4efcb065ba14672544c8c6e1da543eeb86d2b39007864101c603f68d60bd0d166531153043e478e896cea41064cf8985714e44611c030c4dee1f3c8f18627c8e606e783eee3165988ec2e63bc2ae131c33ff9497f46265aa798674a1a4d686c6f9c1f84495b536d7406aac9588d0924f95aff31fc01c3528321a351b1fc3d10cd7fb5b22d2371b29898191dff44fc78aebb05b509c6226f8d008a8938544a6ff8440657cdca4a9e2f87aceb6f3e9b956c866ad7a9a698417cfdc7a209d724a7ddca79c4846250327c923c6fd080f66770a487bceef5b07791594570a088b653a399f28828cf209ccccf517591c6428a613de37f2b82242ae4b356c0da466e09048a50b2d7af8c31f78d1da9720b03640fee55250319597e27459f67e8b4e741f87c78a04c2af0601deeb31101e24f8004c5243b5ad13ea43fc952664d132f088848914910d7bdf662ed28354aa7ac2e7e797a7df20e5816bdf4216f97c24264f4d3ae5acd7554a0d01cc9afe7cd679f592d86f85c4c58db4f2048eee4e295e7338002f2fdad7ad77cd89b9a655c42cbb73e06cd6be60ae466d2a5d064b196847301a35e817958ed53f92cf2eb5eab806ad6698337b3255a2594946d65198e909818e38276d702f48da1f6440dab9d93747d5a61aa534d64e2bbeb0be7a87e57723ccc257979fd942be0a98b182d71f4cb89d0489f9b55b207102743340176bef2c60154636bd408d5cb9338ce02c6f7097b75a59b2891748813c111ab9026e6bedd021d00aa567cb7e5b88a22ae11884e28da701a5e77cf47bf4ae68aea75d672b8beefb0d657cc2ba604f4d29a5f446bf6719ed309a5e3a6e5de29fea00ecfae5d4671ce528c14656040f418b397692de09058053112775c17c6ee99bfed5fc0ca393242cad8895e744e36f3c047ac2ef1c4e59adbb92de2a63794d50952464a9d4580a4abf866d5eda063f899e46743d5280ca397a01672709b94a6cc061d4dc19b4723598dc40561b1e397fca37c9990cae7438e26448b2f3ea0c348cfe7026b0e5425d4f3192e16425f55aa290bbd3f6c8d93254151c0c07ee4f5ccce4240b03e54826b8f83f3c0bf65c393ee500fa1db782932cae35af4028892d4d2523adda01fba33160e5272758cc5bd2c9692926690a9cfd5727bb5dd1779d725139f937c1ff6b3f3710e65609a714b960d463a96e54abec3366d1a4ae43fc739f0623514f4c76faf0a09c4ead960749e7d10f0bf78909b3d4375c2cf24d1daa6fee49bd70d3c6660587717a681aefe784ddb82fc44a439d795a00a3d8ff7862a2053d2f2b108a3a8b5e252d0e7b2b2159b26dc6f56c37829b455abc5a3d4b385aca079b532e81d23e048d9c13cd9c1bad7d43de66ce0c9133b76dada2de8d1461026c7e4f6902da8e8825dec23b92e2b752b199c100b503cf0d74b17a23c3a8da5669a49431a5c5f9ae724e87563cb438a312c5a5a8c9a4f6296e779c0a6f975f2693b1f7b6a6cb02ffa37d29c88cd03c4909505cdda0befb09d9ba9a8dcae23003d16b073032f8faa701e1e5672f9369cb3ae2c37d58b633b1779bb7557366f070b84680f7fe381fcf714de5f8e66934e2603369a9fa7c2379713b060ebc753c6140da9b915e0d38e216878610bfead235659794721dfbef6255243dc0dc2ac57a596d9a014d395cfd968557cbf82e51ade2f4711a2ede5827221bf6b17eca389d25c8e8793559c519df0112bf90241ddb052b536e18848031fa84534f3847f9b5cc9db4eab81c55c3dc079abb5d9a9cd0c936cf555e8e66c3ba42d2f795867dea0a6ae689896829e2009d37de3a2945b50f6cccc27cc4f02f9d840f5b12cc18b9d80bf00cd863118a41b5f7e906b69ec87b06691041f3c1a10c6b20ad89d79dc7a90a2003a58485c79c54a255f76fc190114150fe186654726f42ad6e8817d7b041c9388005496bc000fac762d736ed0278a629fd2237ced9a7ef92de0bcbee9caed05d70b67f595b22c022f8d605d206f1b2fb3c9d6b9b93644ffff034a96dce04e47862347f3868c5516128a4f3de9cf55e4d6480bc1e57406d5f24c2339e5c92e859ab96696ede47adc66bd861034bd351761371cdfaf48b44b82e132efe595526995b942e5ec47f5d43fa534b4c7bff38c014c424acbe1d30e5ea75a070db5e0fa12ceaf78123a84a304a262d1c5f69dd3402f36ef53946bb3e3d17677c87c3478015536a7be7b90b2af570f3ddddb5f273807fbd868d0af2e69cd7f3eaa549b35edcae1c0e126d17bb433b4ca2a1923d3145a619012506769655e6f9f8713eaa4d9612c20f1626a33cd2c2a204f4d4863495ab8c0b201acb377e310088a0e0314d9937398a66edb92e176227a9f3baaa91097e5268e9896968b9fe1fc7cbf8f56e7e6e6115a3abfd2a94b38dd9eeb2eefddbac81a82e1fe8f1a8a1447045b2aa14c8758692f9681f6c109dc2b774eaaf46ce49e61bcee304dd83e8809d188dd51aec4a78342d3ae6bffc47226c312a16fbc845e049eb89f595ef19ab357d605047d0d2fd14a35bb76f51bd015d0f6e1fd4be5560b008c0ecc1c7d5246b03d885636a5303aeff88b3029aa3fdc22c788e3f6d61a66757c09c6cf2420da115e2b968301ec22a1d9dddf6f788cae010cfb4d59cc6c63a626ebf23b6e398b5a5451cf93fe1771f440e11493c7353e06576a8282b7b8bfce7ec6e5346e689bdb03913ed966cd84e30c9a6425df30e7c2ad41ba4cc523635d8eea71fcc54dfcb34083fa54fad10e9670b7321f0799cfb820639aba5dd6a7e5fd6e6ad24b2ffb53e70ba214479194c1e5f946c7651c73fcafd3928eebea86512518f9b40a6026b344a057f34ef6faf0379483f25c2eb62d324f96963818f3880e308e8928383cc0597177c38f0579ca1d0cffd390e73185fb8104ec257ee8b787a3e8d27c869ceaccadeef3d2c89a40520b51ffdf3235a6123a18b81594b61974dbb1ab23649d1900080180b62d3530df66287c9fda831e6337d7bf52f3fad63231a59cb0200781b8ed948b67bbb25d3a031617d42c2918d6b6a5f58e08203160c7654120e51e3fe40355d32cc30284b184c58e31976e2f2c415df2b1a38130598d6693f6a7fe59e175d55f275552f50a772504197d8279b780c810ff9833a3578cb73bb1306deb550acc8ece8102762e124a54bf69f40a6af1a828ce8d484ff5d6c409d562f41704acd4eb5aece2df0933ae6dd289496b79e78261ebfd98561d5be2238e9238746d7b86e657f1e9a0ae22101563775c46e5ce1df218b168f9dacd1e5992b97890fdf4e0e8303bf8e53850bc9a493925e2cf032cf247416faaaf1c55b5975da55025ef59ade7ab01bb59cfd52c0cb635915ea718cb86dbce2ecdc5ca29f9bb51b04bb6c44d370e54e2ad0b8d2249b5f0483df4ffdd63309172da70a634e63f730e56380bc1986fb28dcf283de36f8da70dd7ce7470c2d6edf7650017ab128cc39dac95fe47a1592fff2ee474e8d8c4b078698e2b87bb100a517d5bd12009e1208f21ad463b538fbdf6ec7ab2a10b1ae77998581d5fe6ddd3fcc76ced7ff8de9b4a2d2edd9b4c0415ef9c1df7ec9bb53fd6253f143919e06ba57c62f9ac18ab9e0b4b0ff6b35609a0b88ca2f4b42c916eda3aa874f37bd4f81eba6a29bdf597cc37176050ecf7c8f91608258f1f8823819d23ea4c3e7e16a84a3183d5a8669fed6e2e19cbf4dee801edc812fc1bc3b921a18964455755285a3ee40bc415fd73e1843ff86c915cceac31aaabc196fc50c6c0bb3946f3a090f9262c0393f0d105143924961e8e94476aebba596ef67062e9a16b66b56fe8f321e3c30bafa3187c915ed4063f4a7ba501903cb4c31ec24f17ac578fea7d9f179dda3da001acd22eaf59ac7099a8b2abf59b145e6eac4ddc2573a09595ddc59bc141095bdaad5f770ced3337472a7a786f17bc9342adabee356e2e2031b8186a8c416fee342dcc2392419c15670853845755b3176fb189e7decbae28cc5349760270d100ab827fc092186fe381684c43ed142035fde2328bd437b2a5d8437b6c75aca9d6f3f2322890a981d35c5d5b00599b5fe7b0cc15f76ebe0dc27cf05da8080095366b3218516aa4aa53efba09290ca4041fd1515372f88f871ae008b4226857015cac114c8dd902667f37fccb8ff6d32f97d1081a181a44cab1ba9379b7a281e14b865c404440ee4606af0dc08d60f6e372870ac9b794bfe7c585dc0ca7d1ce1afe2bb914c1ed37b0f5318de8b8c62b3b9f0e211ba5bad6684f9d71b9d3759bdaed37e1f49d105f826822fe97694e07f9eb95a1bd5683b9625857396b2c29c5b58e4df99a9ace0ae521f51ff75725bf9a6a46c9d97e84d8225632deaa441c5362d2b44b65d8f26ecd91547cf3ad4e8233f011a5948b953480cfbae32037854672bb891b64c7c43519e1822d6f4d56ef2ab928d6d27fde076618529fc9ed0960132884ec48a31972a9fcca0d6c17e377234996aa8d29a6cba42833277f8309677e9731d8cd4a944a052d795b3e7447dc7d542809183867d6242764cbc8b7562caed51124607f9fce3e450e576456b9fde7a1a4cb4904bc86106f49241227038804216082388a708ac7caa5015e1ad89c508dc24fe8a399fcadc6b2b287cae7d59475ee04d8aea1525ad319864c7ddfe168ce62d430aa50a4201fa5362df45c321cd107e68b9c178bf27f84c8fe3811f2d3e164a0eafe5b0666b324fe44fd3c1fdd5a08b43da92fc25394de8927dea027a4a69a792b7260508aa6e9cec7272a2c2409517f6dee979320eba819541c27f440e68ea30cffc9431d0b5f74188340e0b88ba3823c7d02638a2aeb7ac908341d99750cb4b566291ac1028c70da1d992184e0581ad344f4ec517ef26a0bf146f50a67e0a96780f0cab85e8d4667ae99b54c86ccb7aa216f75aecd93d59e9e17bdf3d0b52ddd01b614feba01a1270426749614432ce81d6bcc205ecbfec1b8b1b85d61dc9e25625808e486e1a50eb5b9bb6674b503910690eabcf147eb774bbdaebdbd1774a24b42cf163af38c07f614728b9582040ba886edcd8caa2b91947608583ad6c1bbc33ace0ae8fa5dd5080300cd72a6c694b938ed7aa60bd62d41747702848192317ca0ec69312c5ca90e952bcf0da95d898565aefd6eeaf66d0de97fe0292063b8f8b0714549a4a2499c2b6ef8228a2f749f63b44ab237c176f7ae380f2fa648064b944af956911c6395afaa65db6b1db01b768cdda116e7823ad1b7011802255fc5a6cdfb32b7313fbd2890ee5bd5986444c40b52493fbb0f05229eb5d2d66c3c4b8973c3054950a89739f73897af690133344e7c98eaf38a5d99a5e9d5d034d2d1e7bc5e55aa89069f2575a8bf6c397b78190eb60ab117675b2f73ccf196d2d7809a1bdddb20ae4c8d87df6f06a59d710b343e277669d23d62b31b4dc057d6c218a21ac23a235a52e4432c4fa723e510e9760d478596246c4359eb7dc7674764c41afb4d9d04a6343f0fe80a17e740c3ab1ef4406a92fd5cdb1142156aa116ee5c7c6094291939df1c29b7d81d4faa1cf5c72cef614f12098f6d75ee4bf1375244c0ae9dcfc78cf509772f85709465fc7936dc695707de76e0188f2f028e715e93f06dc3e79cf459eb4a2f46bdd9de3d08adb92206468d2432b05878c2f733db3d53bfa047ee6206f951187629969294ae16fa765ed000bc8cbf142dfa74f1467895a62203635bbc814bf37b9e114f92dc9b5ca09ee325d59882ac13f877df7fc8aef16bb5f2636c16f8469105684cb85948e916ea6fda2375363e6a0949ed5f0857431c9e81cf4b6ff26a0bdac1befffa7b8b0aa9bd06c64c211a4229cafc8431e247050dc666bdb86971fe1071ac2b34474b1544278e841aeb345ccf6cf95da563af17901474f0fa239371a722129b205bbe5d7b3cfbdf663f78786741ec688e0b7839d34e754ba69e304a76182cc32a68ff7dcc0889fe8c73b7bee27fd9175b44c6dc566b7dfd93354d36b403ef58d107096c484f78073fecb2c5be3c2f9bee1a84a5eb79ec74350f516c3aa8d0814d8b1827791c225ef195cccfcf40414287c8696ea9fb0bbbbbafd92b7bfc6260f7702d430f611170c6c2ea97e241cb894a5bf23ac0e3af8f71a44982006b940caa4367b4b64b878c59ffc77b29fe7218906eee39e57cb79357e214239455455d10df5c47efc442c418bb82196768db6b573c07a00da8525478a37b6a17df86e834f1996b7ea9885d339616c9a374defc2aa0083bd20a7d4f0d1b66c9fd0112590c8015c57ff617ed92e6a570e106db3f85a78ec9a2a850f2f1e3a018f1e9d4fd519189fffa9733f09e66b47520f5db2df4dec1fa919b4b380c9d57bcec598b0a61c6924a7469f2e8ac0d067a88e4fa933eda879793d2a6da27018a75e24afebd2fc42e5e2492a7dad0c5cd6b7d70e2be86e7b611b5ea30696ec4483689ed9133702e327c6d6013fd82ace6cb3b53ccc2406107246464e4894f0c827fc50721cd38fd5d2c14b4c5f34d5d4e80cc69d7f2d6fbed63cf4a7c7f1f38d65214ee77b59561101cd2fdd8a17331ff3541076c7d8aef21f20384094cbd63158c90d64bf889509712b5a596f9f2b5a6b6f8393c06fabd41eaff8d642d9f3dc00e0f76273bcaf489fff8753fc4438f15c8529c4f39e9c9f1e8a22157659bdea65ed2b79f684962a7f02dcb57584c0ef915f3f16c4e75e90dd60d46860b2dd469985642172cc43e8763b2126cf37fd6ee6dcdbd4044d6a94667b903ef50c79d1dde19120bf1f5657939973e2d7760f6b146e19f07079da58e50cd865ab6be9ae4a2aff9d2497f29dead88cccb85fd064d2123caf45ae86ecf42a3e105e5dd5fa59eec2a5913dfd1c224e87b7d4e2c640051e949bc7761270dcd0731c4536285a4521f5a78eb074fe54a1a0dd205aa93c2acfb819ab2989af090e1678d340881ac9a779cc155317fbc609b5a882d5409c6ce47ad4d6d5a6945f21d1edaf20fa9ff63ae7507ca05ef46a8901cae76e7fa6be4801ceb92b888036a73fbc636e5eef7e373d19f06f383ca7ca2dae12ce70ac5bcd4d9775a0fd4f9bf8b020476f222349551d9e416bc9e7ec40de3c07b726f5e962a9187a77d7fae7809052144040c813e5fd58091b7b9824da3314620c843b6308e9c9881495e263ccb6cf2e9a150519cf842f0365ebfb86879f4af9637c92ea8721ab52a2823c392822b0dce088877159ef4c478948202bad61a6584a2d58b3dcf0c9cec3472e9e362fb7e7e51a141d107f755faba36be7931ae37481fcd7ee49c2c4d83132fdcfd2adf32ebd102727f254004910eebf9f0b7d114bb03effc20cb2b8e981f2d6b8e69cf4ecd4aad0fac87a69b46d31ef136ec404f5126ee33563266602c52b54681c6c45826cf587f5903173e6a5b50aa1369cf229d877aa8351f2b6aeec3a71164d5bfe44aaad59a5d6ab5d2559ec07b6402f8da3eeeb345dc4ec4f27b9e8469d9421c950606e761660ca1fa7434d6c84293ceac389a64b9978bd058bbbd88b1ff5e78bb8d024f4d7eaf42ca57ff9199491789c03d6682ad959a5b7cf72c443c3147fbd29e7db1c738e4a2f167eaea18491144cc53184dc881056da0080b49df896829ca988780da61f6dc8ab521b3cafffee704ea39f8b83f1015039195d88ac9896daeb3f7ea859a3aa1e8c8e12aa26e0fc9796b289f67568067c0fd71d127f61fcffa1332d38529a4a7fbf3d854ce71b3ce363ed4348287e2fd4d0e585229bd01fe013601acbd3b48417b7827185883d4fad77d10de786d5d0813453aa07bde0b719df98bf33fd4656d0a8088d3a3bf999c641e1366edc5659b0eaef07636a3714da158912a9687e2840b9dbf484b5c07fcf30a8d78d1c0bcfc2114c16b0faf2676e01e3c7acbe8537eb98e7625fa6dfe69cc3a279fe4d18e90034b9b0292af1ff9eb339cc9935d4e864a2f0aace2462de64f8e9abb39d90c71fb0d5d124432ec1be739dedcb8e5b3e6872033a0d10dad66db29245bfc010b6844956b68d6215b970ee6cb64898eb6c09b06c308f7f2c32a2612a33aae28d95c38f2ce7de8c3ded1884cebd6e3fa99eb288454b61912972f9087ba2dc59aa47cb669d66b62a6c85ec0819379fd6c5f278c411809d72eb90a605364fc34a5715670f6005e15bcfe24519062be90e2cf39c011d3a6ca50f7de4c2615dd92fd9083250f1fba99f9d996e78e27274c8879df765a11070033c9ee7163258cb2fc937bd229349bc46f4189b216b93fe59698f25241ad954b20547691c591ebf596c6fba29d3e5d5d4c54c5d2145e77e2939ef7e66a4366c3eb71982edefb28cae6fa9e0c970ba05f2f67d421ff8a7b12869395a59920aa4988861665e4b96e1744ae8dd68ebfddae7f8638af93cffad14709796aa20e6579be4db0e50b5aef9bf7b0f50d02b71355cffb5ea27bb42868c61ec3d149d4613e03a24c93321d985cd1be639c7f1d21e20baaed1bd0ccdf18e0a0ec8c933fef78192bd97975d5d7e367b0b9440a03b4a318aefc9dcf41e6bce847f14f9e869a9d9c9e1521134254d160843a49913e1963ffa9600e6f800eaa45b15739980d30e8375aa9d0c05ac09ec4369a43830241460f610b919e682f76c473794ff479ec72ed40bd37c2555a868da696c09287c575169fef13f6d3e3021a0c9218174de53b67776d8ae9b9e4cd35077e9ea54ceccb0b04d4862df8a8f9043bf9504503f77612ffc0c550a9e97d3724ab4ce5eae2d45bb383f3dc7f08c589c6a07dcba2a315a544e5197ac77551f760acf94400dc0f8565a0fd2c9b173baedf4dffb050085c2ebf17896f2bcee7a1e8db6eb266bc6ea9766b7abb2dda07733489d70c5fc85df084635545d2720ed65d91177fec4c0c538862f8e1c6af499d818ed6577912fae1e86b498da1fc11a84937505328e018f6b14167a4117b937032bf25b47f1a6b6fab441d0f6c4589c42ee4bcb34a0ffb965d74b75489e85f7540d1b4bc0f9d40d843b73c6da943c70d21e371f585a33f9871cb7295ff55f1334c0b6e989c34dfccf06507354923895e115f6945aa78b55ec894e95573752b69db3a11c0ac73adf1c269940055bb5a8fcb55b6b1cd32307f69336060de0bad2d1d82c55eff45560c8b8e39ed205d016616b786db1753add4785f4225d1e8f78029c48619cb6c06d1bbc1eb597e4228148e08b4be9c2cb47ee75efcf0b6b5c075ed64ba6eade8f2bdc7a7f8a22af3e5fcdde811f6506244d7a6264c15c4d94a6ed4c1722077095723e1cd8927c20659d123a664a9461825594098b063e13d95440504ffe3a039b6ca6caf9d7d55cdc88103363b04af9a324daf721407c7a6c9d404c03fc4d9becca27fc1000b554e9fb79c577991e5f8eb4acdcea37510d4e874f91a914e2a595a099ef4981a42aa09c957f825c554de0635b162b6d2c30fae373cfb95ab0a24a0320c0c9254c9fd3475201a036dbae56042dcfd970629f59a9caad5e1176b34c1cc902aab19c48e693351af6c1bda1b0ed12041da867d43e1cb7f6b2962eafad1cd20143acc41aba61599fc5b38ae614862af56bba97d33b48f14c87be868552b839b5c82d0108d060e2d8c526cb44384d42b6f295b0ef54131b10b1ef546aec8335b9d3104477c7f0f32b63359a1442dd4930e165f0f87e30dbe84a88051f4a0f927ef85413d322eb099c169f1fd91e4248b465cfd16dc7d199ce38fb156246749b0fd79dbcf69d60cc813d34a434f4046b9ce388d95cdaeb4e8f1c128953897109c33d47e41fa7b4d5c03220ded9dd2d4ceb419d629ae77e9668bd3448e61d85c294c2355660da8509384b7cc6cf9508076db182de9bee2625804b14e64024bc040997958fb882b8d42975ea6766dd84079120eec5c57f9f74e7301f5424ad6762256faa081d6fc6f1e7f229f307a2ce4f38d21a5c99b6c1a248a9a1a0e4d95a65e286ed897e520e5cb387514670e578ca14723837e323d37b2a7101c7ccff212c128b176b568b8f953a192219d3dbd74e498b82937781a90927e7f611cc33148969b0c32439448c62e1aa1bc8c9f9d5b302fb92fefd94f569889db7c2321077b9da45827f7aa7f2885a4769af518bd94e1358dc3d8e646afbe2f609bb60aebbd7a0a42a7d14b61afd0c1eb6bc4682827a37a8351b2b14c348db86523bb3a39dfe0ed9962c0f94741c30a06157445b407c6d862338fce38fd65e6be4d94b05578bf0ab31f356a600447ce36590edf3a395c3035b64ac81aaaf9641a619afb53a1008310a2e47d5a65a36bc66348a41bd682dd16060193ba590a2b237f942372d44a2e5973729bdfefa776061c59589bd809abdc0a8c0ab36548fc6fed830cbe11bdf3f75fbf57ad852097bf01212cc91be9a9df73550b7f1778c3379e917c66d53bbac3eb4ff3625c0878322919f570faf0ad795dd34873cc2588bd321e12c5c96c4e892d2fa6f910e8f7293e66a10b7f88cd2e0fd9514f2fedb88b4eaa65926b3e15babc9012ef1482b08140400bd514e73a984db791eea78b6a297ff354376bb24d8aefc161ee7cffc19620e1ea206356028a8d01a6caf1270141e78266093b6681215247902969d0ed28cbf7d129e9d0bc298b657515f7657e9f1181fc38c8e817bbdd2a19ce30c8e8ddcdc1b4bde5df4e1e63dbb2c7057baa5ef899a2f0dad875cce17b59a5d490831e715aab23249cd72512e716ed3cef196bbe07a2b38ebc9b7f08a18648457eed1c55cb7d58d03c9eefa41210676bbd9ac2a7684955828e5bb149339bc112b8e226670b56f22c46f1a72bc6fa2bf53f88551dca9e0b3613f59c2b8858afa1b5d01387066631455ccac670257bd75801eef9df9129b033d244b3260dd37837d615f865a137e40c784619498f60270ff399b07f06b1dcfa73487a6244ccce969d3867aade9d01e419580b5fdabdae5fe73f7c9431d1df499f07fbde0531ef063485d19b457d2914fafcfc9911ac2ea6878bb2b13d7f741888bb86af8dc8ea064f7afff46f4eb9b4ad8cf2abce0e65bc515068a78a0cdc69f6f24cfbf88f10a371778e0a614d912d1829fad421e1690776a1214872aa3d742a21d8ae33bd2541026755a00b33bac993d4709950a9e92cb4e2a57dabec5ce926a3f68d37f6814aad19e9f82be1a59f983e1e353154d577f63246892100f3c9b6d85244cdeeda30c8fc621bb2b619227b8bc39f68f9a6b40379d7ec325b709b07ec88d0b54b81f3bc2b524c8c15d7c8e33b9544e705741ca2b36c1b46ba531abadc13ddb56b4caaf52eeb50044e40b54692742a9b627b93aafcc087e6896b9b8b4672afb2fb3aaa29db48974fc33c75a5c60ceb2c1710952ab86a5adbd7e2db0c4e4bf93e765181613aa8d58a477fa83813c94d919b6a2b0ddddb5ba18d30b6f72cbe9e37d2d30ab5aba93ba26875746d537f5109ffe2c626bf4fc569db6c71319bfb3ec4099ea588984d7ed43860e3ea47305819cfa32fe5b2f3859cdd3be0e2141011ae3c71c2789f47fd8e7f0341512363c968c2a06984390b32c22e8d964c57d7b15404b467dee72028fe38b390bff3a1705e254d39cb27cd5b3271ec3bc229792efade31ed6b82d0f0938a4bdb6a4e9cae99351d56088d5b515bd34630fe1a85159885fa01607dd62cf1242854bdfc744c11178cbbc641916ebadaf1f2c703cc65df7021b59eaf1f7509f5365875517b94fc3d903610dd41879f06e472a25a1c5e4e4309c836e7efc28be7641ce7849fd5d1b05db81aaf123f28074b70dc1a50fa9a9c4fb3eb3ee0db25a9f78095f4e01514b242b80e185d3ba6ada47d1b1970ec2536f180bf3d6fe5d00e923c16cacf9bc0b8666a045bc0810186416123aa6880c434bf2277019d8dd44ad7efc88b452d3c205bc8d60a5f8622ad8f94c7628f383a004d6be768fc512cf03f28acf78aab74f69a512880cdc58a3d05d26c36ad75a5b45422f7ea6bd1a5561ef055933f16272a049d27e42279393a7740caf7540f9a15421e84a2c283a1b8024bbda8284fad63bcfac2b16084bac15e33a0c3a5ce7e928b94aa6b38cd774b77fe3d0969b0841c1a8d3b22659d63d30a9d10c7fe1d6f4e2fb5b0de29f57af020dbca4ba05ec69f2c15fbfa14d6fed5f83e24138fa436c4244e4b9eab178968990c8359c5110e21161230f0557e9b4ad8eb2720df70abf5d861635912e4c2048cd3203f4cf40c897b6ff399f837f705e675faa77c10477b16000ff129160f830d107864972368b41e3178671f4803ffffe66dd6286b873cade3f62f01744236f04e9d70af8f14f3ebd925477b91b6bdc204e7d3f1b83270ac52906c24dedcbe81069c5e504258f2dbdd4910e7baf7c28bac968028256037756dd12cfdc48abd944735850edec09a6441cc08d816738712cb19a27d6612439529b027702b87f2a220b882f1fbfe5105546946715b930a4ad92f9058029bd37f99973c9e38ce280adfd72e88564b5a62695a4ad1d58b78010e03886577779d29b802e723e3941adff7bb0b041fa51e9dc0fe14748cb74685fd1485e47072ede0518936d55ab087ccde1b52624dddc9f4309d690f1c79f54728d8de4778fd2cdd685d8050012b4ee50cc095a4da2513578c9e0179342f213c926d1c6113750465b3ea36f9103dc5b7d7abb2d222001a20c6c6e62b3297244db90488ef7189373c33b45e353ffcb8c129d0feb4cf7a0f28cfbf0179b862f435973036dbfaf22be47b8ab7be242a6b7077e4f5d37af4790055346e18202ab16636bcdad6c431bef05058ed0fee4241d292f0e5a8326dea4a101f162e73125924cb076826609ed0b76d15d521beb2e41313be2458d797c77b4b0388fdb8d895e0938bc3ad57cf64d28ea88d789cca051e9ec7a440bfc9008b706ea411cf6f2f34b5ee44102f12f58df914a06603c79fc99094d84d7ab6d9d57657602b3cfa36b235f076c9aa9ed21148f616276a064053a75d01f762e73519cc8466ae2591ccba623b8bcf20c083d182294817f3b305f70f9a56db30e03dba1b6fb06ad4816142a206bdb52384502cf54c5e2beb8fd4df77f673914be89c642c6497869ed41d7bf64fb5b89edaa851bce9659df8d23ee7dc7a8f7c1196702160766ef0347df64ae8e6b740cfa34757e3c6ce24b81e22288648667414bb76f6d0e99c3bb036efff70a3b08cb11527c0d41857132e6cfddef624aa13759dc65ba79a024d0de2889ced25095001ae1858b5f12a4f36c958890997baf70d67b681780718934b4fdcac4b12af6526d66f5f8b5ac7900fb93087ec5219c7fbcf33d20040277f584c4f7b83c94290c237ee9a641f81ed504bd0eba08128789894a5a5a8dfea2b0bb1eade7bf9af1851120b5fa44c1270035a0dddc827ff67da552080ada624550560e2c1e22ff54a22297eb10fdffb4e84e3091c0652e61c83221ff253b083ab9739a700649497a9e55d4c22a9ed59a76edc772904ddf4135e4193bf6b390db171d47a85721b7da32c6692c21cf0ff335a8b8d104ba5318ff6fcae0f44c955a7b4910b3c863d31c1b3e181edcd8ff4000c35c00ede7cdc1959a6e86ad1e31633ba18c2686a1fc41a8737ed0b84841acaff1680e791c7b78fd0891c55bdfe723d6788daf719f74526ef858153ef9ac8db764aa32a2129ac1bb546d60da861b93c7bf24d842deb79d3a51a13187db62f0f093b038fc0a40e72d8b719c6a7badaf184ba3a9eeabaee09090b434c1381fcf1bf20167e200e1f448f74ed75e849fbd0d6e046ed880de598943a8f805eb9cf4747ba7574c51a882612fca5e47bbcd403017513c763442ae44226a281973f2baf247ab8618f798e96eaadca56669094dca7b4613d5c5ec16aacfe790a8544f2f73aa53e0bee7544c6346b3fcd5a4bd32c7eeb8b05d235042c3154e5414a93ca3b199d4d040b139facbf42194971693ae744691b855313bb56efc63974c07e2ae5431fb8a6b8790c58c59225a8e56d4e1121bd75fdc4df6b55017b3f26fbcfd771f2a234febd3d72eb36e387f1a621d9be944170a3f331e022e3ec694ec0dd99ec88b4543df59562cd345610ea52c4175bbcc037995a3b4cf6b6d04f15d7cc8e1bca242582bd4fa360860970d28b3f1040978f18fadbbf1ebff1f70002c7e884462c608fa3bc7dea451fa5db558a20468c61d19e00c64ca30bf96bb1052085caf3ff0180d9802457c132f47a11344f01422d3c39f645779f6291541a457070af709203d388e2739ddb099809d878a12568bd9fc60c1e175ccdcafd80a3f77ce9f63ead6ece370eccabd61b8b0059c93673b1314adaaa4e07d702b81fb34d82bb36fb8ad7af10d7c5002a921bad83036fa4e06fc3a70ed961b2703746aa929c6b563a171ff96ed8ba8722e8ad3d60abcbba596c271eae2fd805c4b9b197e2ae3d8a2a883198beb013a9ff9b238cf4c2d14e4f52be7931126d806b16afbfeed825823b6b1ea2e2875e2619c5ad063770bbf273eb769efbe54f223df96ce8a27cdd21dabdac8e3949365ef618c6b7df63e247210ddab988a60ac5d2f5f64cbdf160109f4ae46cf0345468e7e046fa2cd2ed52f851ffba19629908d1e29198b5ffc617b987fb91885458728be8584beabd62a80587ee903cb0251c35c59dbd9ca8c640b26f6c61d21f47602747fd6b9e55fce43bd92abe6d219d49a052a95b8ec6397c54451ee15b25b03fd7141dd36da35c1cdb73fd31e51aff9b1cddd1c9ba1a4fdd64d0642ec45f768fb65b299762944b6b2eb79c03bdbba4c7417e4baf100ed2d83219ecbb406c8389dc921e9a5259947e45fa42173d8ef12c439629f71b706ef47793533c10437099dbfae03b94337960e2598e56970eadc5070d1329c38bd3775f2d516a189ee46f8242c2633c829a149b9fae902f3ed11de177c8b98778b80f8055c2da10a74ff12e4eec1b092be8fb225361cb8d1cbcecbd75af8742d5cc8f428270e4d495057994ddc50becc419a50dac8a5e727a81415045ae688edee59be3629bc80101b7d273f3a986550936df8648e56af75638512421e5125e065c0b8baab4d166112e6780b792c8c7cdaed8e9f6f94b5fe3e73b5b362e82751b5d1bb46eadc53cc919faa513f07ede243f9ab5f75b488206f5c05e480833864ef77c63861bb117511424c530f7b37ca61145c244cc95991fc4a5a077c0f4d93ed52e7c1a508fd9d84f9e9ee878f54ce714d48aa03516c453fe6965cd378754b8230da2d433c70988d292ea92c0dce8bb0a2c18458cd6c11b17886eb5c9a8a59a94668361c5b2985ab47d223484be814a8cb4dc7b274ffa33e449b29f1143b466060b9e56c6852ebbd0a2d2dcb6901913d25637350c858b6229e2c901c24c2d48622a3719ce79a98fe031195dfcb68ae8556d8f83b959e37ebdad92ef292381","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
