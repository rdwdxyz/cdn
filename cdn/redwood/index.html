<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6d7a2476e491ae4851a1274ca96fbe39ec39645b488df4b25541c68315aa9465312854513f5ef1d1d281adb804982c2ce8c18caa8c43a4655532611cfbc97c284bee0c5da84b4c2b89dfa41a831d4a49c1e1491b37ba8daba81e60541377f4e9314c2ffccb09df96b6a05c8f2cebfb2da1f819b1fcb21e223071af1a03a390cd0d21e8bdd692b6046b89e8011a6686689be2859e60845e17c09ce98f98c1499a097ca7bdc9df0ddd30c5127ad4924fd1109a6f1a92da303fc2421db41183f5e9d5ec799475a122cb56978716a8356882fa2e11edf83527e38a1d8c4336efcfbe7b5f862cb43940bb8120e5937689f802dbb531b65f237603ccd8b278221ff981a8102c61318a15eb67dccb46bb980492fbcdffe91542caaeb5dd27552ea5502b2a39fa4251e301d00328f9b001627a42cc8cefa6ee91c29e98c618b05cb69b667afb7861c4894736ed11bc237e638a836130fd2513a377204489577f03a033dfb308ec37b9bec1521be0de5f90609810918f552b7a24454db7fe14fee4eaaa6f6e73fc9d788f8c79b2a9051a37734aacf717ed8079b27890825e67e8c9dbb8197fb3db8f435eaa11bfeeed71cc86ea338d94eceb83706a779b7e98691b952c414e2c207603af822d37506efc53a1ef6115ba12a244b28f41827e64342ee3ba509e704a58d0edd3ded4c3d8e6e30145b52be4018fd0d59906a2169acbfd3099262459f0a706b5b447d05bdf3d73dcfeeb474f9a6434286f78d844b9c1a6e45f63403ac96aa58c797ec70ac0578442ef54136177c200a9117c6b1220f0fc25a49ec8f9549a6d0e16ba3986005701a3c280050187d3308cf10da2f8fffe30edee69f565dbcf8861621c95fe531712cc9abcc987d6281aceb770a0cfe0040e9dca51cc7d91a6e4fef45ebb728663948be0d93ef7f3ea3e4a2376e5eb987a1249ce31db27a59c91fe56a6408b9693274625b508d8fa84ca7286329484de1e155b04091ca1ea58ad85fc0e36a95a3e6a91a9a4edeec49dd5f134f78e7284e319a1e28f734f14f752d9afaef6fbe1b85a7b31e786577a726d04b9fa1ee47f8f502b423a455119bba6c061548fa2ed056fc25b892216caf0e70e8ba386cbe051d1634c9e87ca2f72fb257af7c3d8b37fec93f69162a219e802bea13668de2853493033191eee49e5a08987e0582d04d3d4d426690633ecfb65d01bbeab545387e291b1f28df2ab4612899a999198804284f9bbdc97a9ad481b223bf947cc771992682f8ec248126c11704bf1ac0ccd4981bde417b97a9490f00faa2cb10544254560d6124d8b253405661c26555214da9e96a5025a0aaefa170affaeb8f5c875412b6eb612a925dee5d5ea99dad395ddf42328a5ecf6a0eff0baa0d99fd15ff6b77c6f518292caaf529607dbd5af8b837d1ebd20bc4fadb1579902df948bae7a41a2723c800b7a18bb3e4c0ae62690b4b948070bfe9a0a5effac43f103ac635915086b37d85950317b7521088e942790a9a29e506e110c9453a30363a477ffe517cc97d3f496f0d382b4f0d44649439193e9781ffcaa1e123d50027399ea36c5a1e27f9af96eff4cc5374eeb36d3a7222b2d423aafe7e41881776046162a549d44e23e24536fec0b3228fdf43606713f0c1abf6cf866cc13fafed5c09ab91d571f6edbe633f0f95b5a0e99e97c702a96d32fb7b896cc4a1415aa1d109797561686856c4de4760b738b4161f85e902f3d3061abcfba08bdec1d9888b3be33e06496b289f713e85a21c16e4d9e00b7bdfc9b317463de2e2f3ab5c5020941f1bc36a387326b611b34393f881ca58f215dc865b78e2526ef1a244fcc60930da0b3f0df016d6250d1a064362551f7d3d223b3fd89c3a8a492ae4aed0c04bff4258206ddca8ce811e9752cfb7ffd65109b4e840e8870209128115b7913d32d401c9c87ba1c5ba7b320dac45c6eeb38b59925d6414772da16c9da0658e3129872bcaa287f9fd24a3a50cc300fe3386b5c4db51ebb02d60d7ddd1a33fcd6613819f3ef23d581908153b2fb6de87c274c63ddf8246fe1410d5248ff44ac3e2368bee6ffab34546e67c93b639f49aee560cfa6bf04050ab6088b387c0137af3bb7cd9893daef1e025d42a3eb979fd9a7c5a30e1868e3d228d00941d899cae40d46bbc72c828bf3baaf2c655a403172d136116a96b6c2d28ffcf2148d7bd0eabef4bd9d16276fb5e5bd5b36863df22a28932338e65c757f097d893c59981b5d85f59e2084e2e0e882f8dd63a06905b0732ada7dedddade5a1af66bcc4513e80377fe71798d13e80048490e56ceb7d28299064d3fc8f6c59e357b885ae82a88a7e242ccfdbc9bdbeb897f54ee8249b5eb846d3b179f4fb49459d0c16726c2ce3bb2ab903bde69452fd301ef114ba86ecb73c7126d4484f7069092b2ac7285a002ec3ad29ac39abfc1a92cab9afe3761e41f4586e1c78dc795792631ce97fe495c432f51444de67713c7a6fe7ed0a1672d43ee590d2fe37ebb89bc986cb0a05ed3f755351bfa7d5bb471bda852547b4faffb5f9e64f4346010354cfc24b2806bb8137a18a154e2249b647a82172d2638aee57305bfc79eaf3888a6d9130b53e92a6139e9a5092ad3e85c91252c1dbaa579d0add60576ffb78490dcb1857e337c430f748534b24f7a872c690fbbf4b84bc0ffbba5bfefee9a185ad9baf77b919387c1b4ce80dd3a6589df8b8c48f2ef78c6d867c16ff5514cfb2f89b00f70e749a4f9c4f1e59704840315a79b0d0cb649a54dca013b047a625ebd7c5482ca84ad90c09f5a62a994d37eebc04cba020890c03a087b628869e730f6bdd3f86c22888540887ece0d8e911c316be30e1ddef9faa7f294c0b341f8bd343a598258eb163fbba0988dc5a8584b91af5d0f79d5e15907e30857b27b47dc87a9aa1409f7f0c599a275b17722b626f8d5c2ea4d423d14166c1b7d778daf864c897ac79d0e17d99bf522125c7bffcb89476682fc717c438ef68f85f3cc1921b776046cf6c3271e936056f566ec7f30669e990aeee2325f335882ae81ed05e81a0098c29594a03e46de7f611887de29fb3dda5cf1e064c5be5a9d8edad0b8c1c60477de29e2ea505f98a8e62d5015798fd058104d7e3f2781dcc4eee8f9d3f8614a4383636c3f8d8fca9f24f27b9cf5a2c979e9d083377161ac682ee9304a6abbaa5dc1dbffb58fea4b56b9fcf201371e162e5d89aa9b78afd5250cc1bb3d510d3d1d0a7853d75fdef52fb75c776fdc3831b32e15a6507172f58c724aae3c2220befa6e70b257a7f9ea8a702f99c3003a02b0a089c9fd7335976d14f585d4eb0d8d911d5ce39c0b34f8f3efb63511fd26ec355f3e3b2b53ab73ab9b93e5c8c05ed7663eb5c935d2541f189d6d90a7e1aadddf7d08717d796fc46679c430ac59b7c407f7d46d0c0e7f6e075773c2dcc1b9ef2da4d06cc4b271f0a38ef0d7be9d1a62c77f8985a846b338fed16abd69b9faa1eaeaa4f53874a2b7192e74843f77df305024516a7bc365249b05a93068291c5b594b126ee931467aa47e1a43eafddf33ac791060c489ce373e33b0be42552fc9575567127ca80e513b257cece59c9f1daa0bbe2648fa3c64b10290186072544658743e0e91817dd807e9899ffd492d39f58d0ce3627fb9dd1574a00a0a46224f8b1fc44f35552666324a58b5387ad5170e27b059bb3a17c376908dcbe6515c706673d94c990b27ca443740e1b7be00287316700ac2139d0fcad6f588ac7b76e7d958e762331f4049accae7144c970857d0ae4743df58e4fa157a37364992ca41d61044626960c95b626b5ac5c3918dec8f5a44a151d14b83e93be97cb848e7c7e7336a5962716382a7b2a6d574089ee1a749dc7bcad44acf2a487c4ba12588cf67a6289059c15ac4b83ca9c6838ba0f8af621d7dc768212ea20dba26c41232aff46124a1fd120bb3add5afa03ccf6016bd6481e67b3837762eac7cf7c9d09d8534b50e84934baa0614031b3b21236581e8949e7651dbfe6777f6defe8925f9b9032049bd9a61475c3482b11f12a67f5e094e69fc80ce04badf72636589d941fd54314f09e58ce5c842ed95bfa21cc7d5c7e36cfdbd3f27fa660a37094f30957fa91ad9cbe25ca3e34a818deedead4340d1c5203373f2acf9d59132915d92ac667a353257b45abf0cda2cec80b39cbd2cd546eec5def73f7c72573ccd36c5fe033ae900626105d11183c6b7c7744694cb6e7884a8384c3598265c6bb8ae796e770ba3fea9f5c7e6f77d6291efa67b7de50d7d19460f6dcba8ad58d215423e9c8a5ebe73c9f63dfcaa9103cd324fcf6fafe348f1f736c63bbc5c572df824d69f8602d09c11d639da90627e1862c04e14e2e2c245103cd16c7b7bf87d28197a1c5afec9c6b08917647958144154cbb7c7c2cc3ca24905102071345fe6c7453c2212b2a64acfe149f6099f8c43eaacebe247d0f4dbe64b3dbb14c4e78ec838a3fc223698ace2b4ab4146dbc011b4269dd97388eb820cf6c0212d4d2c6956a21c8a950b7ec9c26214e6a54ecc41796321741a57c8cdd5b262caebe68dc152277326b95b3c35a81febe3670e605cef215f73aa8af33a7ddd030f8522952043b4610ecb7114d4d7b23f99894953f8bc4e275c0fca65455c3af8c2e35b1c8c832cb46c3b18c9ffccad452b1a354830c96895eff9bdbbbc2d0499f6a5021eb314c975c4e34676c4ee659ac62a93bb34e092056b6b87a74d512608f537eaa3f6f86357fb5e883cc99808dda932563596bd78188f85124c594e6b96efd344d59c7cf141bc296e0ae8098610187d1fbb17aa7be3b6346de608d8ab5dd50011440bd0d7dbb5aca14f1c7b41b3a97b6536f5652cd8bb36751e4483074ecc659b6e26e82b835acd808bd4f178b4aa3c35ad886f066494daa080e2fbb909306cf809908b98b0ba9eff98f55150b262b9a7e59bd4a1156f667c3e8a3f696066b820bedea22b16901fb596c574bea3e643648df2071eb7fc307434f3756129b9f9ca4cbd42e849f0ec27da0e78e11d138be27b3467b326fec5beec8448d555ef2f96e31ef848d15a7f0746a2c7864f96c230eb7d2e61821eee91d0953589654fc3d92c7c37510ecf4db7a1611ea027b266a197ec035f4fecfaba28080e64743772189692e6777837cd55170adf214247433bfcffab34af4de342d3f6a5800e59a12c0b1f781fc2d6daf09044ad1b76c54a4ac3990454c79f936b63a718a7a9dd5f1d01e7bcfa3a972a5a7b58c15af78c910fdbc7e3789f80928d889432fa730e8642682a23d62906f2da7efd5b3050b5e0da13dc98d3b4c1dc74a087f49727cbdaf49b3beadcfd20b99939de0a3a575a09d314e92dd8b238bce39684cdd1549568603b072e924da5d57eecbf365082d8c7d628f8b8cc712cf8b4ae1714077f018864cfd1b28859ddf696bf71bf83e8d71ef56a2777dded72a7d230a6c81380776ecaacdf89819982f90a82fba8a58eabde9254ba5bee1f6b0b8277083eeb1db82905bf83fff4a719a65541b0ecd06cb875882c5121439c260e01a2717fce1c986365a86f83fa1bfc84fa2faf6545d966814d94699f97b14fe94e530cc9783d1570db1c56d04e84a7689d303ec96262e45917f71202b8792c026843875204143ff89fa8ffeaef7688b19d494feef5e221da4e14e3f3827b8a1c2cd506adaf71551b15257e27004ae68baa260456ea36171ab2d75903d90d3a8042adf28c20f46410aeaf8e97315b11b23e15d3644c0749c0ead616faa0d024b04d7ec40670f212dd493209c136da887c1e743e6381def889bf22dba5e2a7e6e987cee9181ea009afe289efb312a637fc5b0ed0022daa7c21c2bbd920138b2718e6f756a70e112345168d1675d6c2a1c3455926eb586f7ccd262ad660888ef4eacfdafed7ba0af27bb12c7b2ed1975d5ca2787e1c56138e2da2035f773a98426e0d0888b16a8fb29c98f029a03307634c1572303a59da8aac95d7f233424c9534141a357b66c7b3510da5cee0440b8a90827631752468496396c9db739999c47b0d3b03ce1295e3cd640ecc00fa475100d9ce89f8ca53855bbe9e359f08bb69780ccf8d31c7e9c7ab50324ac283b8bac549115818fe07d1864b3e737ba9ecbee43998a572691499ea823de8ed726fb8e9851d18488d96a8dd34fe211528e3a1f9d5d613922ae8a19488d8bf884ca9294e3efa88af2122410877dc10e1196cb6e51b1edff64419e605f44843671ce922c892645513fbf6b543d4c990c7416dcfc2eec410e2c2e9a12c470abaf86cf2318e98b57b5d9cdab1abc6a8e65d36570c80eb05c0ae768a4efab2f4a18b461f5daab63b9efa95547837f18c874188a2c519c90fe7ab8da25b89b133c261a6dcd3b757474605578f1478a5c75dc05293dd1558da4a335bee11973d9eb06ecae99573703b72e23791df5203a8519a68b984bd581b106ca3a78e72b99c61a4d079c052de7a92e81dda825805f87a80e79684c7de02c9b585968f006bc27192ce14dca4513cac14c5c1cbbf42608c184e1aa114d53bd01f6e749d4fc17266d5bfcbfef685dce19fc6347cde51b62706c15bc141b58f6fca45630579147e4ddb31aa3171f50665a892bca88ce3728bdd1408803eb9a4462d82f398a01ff558330c87eb89c9359cc9a1a282a4cba8c71c0872a01773f2a12962f92bde39d6ad9bdd39b2971353742f138020a1eea4ffddb2df70694f7aeeebdf6a684c81bb7d1c5ee344ee337793dcf89d083af171a73bf9c57f65d2e3a5dd4eacf40ed1d2964af4a97b6cae9484bdb875f5a47abcf43d70b621f550911d96e44228eb236fee5d94a75165850e106d075a9dc368a51acd7d0eb9037aba0ec1aa3aa472f6431d2eaca768e329841e938b3ce791b9e260c7d1fbc9d9c8296db27d51466ec5dfc0791378da88ba1484fc8047c9b95b53b33d27bb42038c35b2f07f727ed27fd4121ee2e7710afb6f082d3465b347490b42a0093f5d8aa82e11254736f67ad8e00f37149ac56127229ddac0aa94e4f4d7909da14c444e1e88baafee7e79ae40899844dd35dee8925d2a19b9fe2726262300c3f59c7b83434ed849c7a97d19ef003b88853a198ee6789b6eb2b90c26252e7c661948600a63eb8360919da2bc0903d237516ad87a59fe4d719f28547155156aee74aa5e98b602cef49346d8e703255857c9d51bbc7cdbdbe868fb70f67512bb40175bd852c80650d1afc90745eed87eadf4323fe5eaddf0b497feca53ee63234ec4d01ae149d681670d27d4e1cdb7c5ba739d7733fbecd4559afb1a6584d219995dc1f688731dbe70b319313c90e50ba2c1a3885d0cf99624654a5f72e023e9e7edea08d20b326dcc953672159b0ac7f21d80b9f798d97d8c19024931420231c33e5877cf507cb40313dd77f56f614627ef6ca5f3bfde196bd8b8d5edba84293a3b8a3ea2c01539de3af21866aff5eca8567cd5a7d6b0d4d9d9e8520384ab64ae144022e4a2f8d74ba89b694feb8594f32b586d26b0538c4e40f3b1641bfbad478f6f940cffd5231c57a1fc3d099c664f2e1459e2bea25c99279c436a53d982059bba1447c65069bb4b784608a87e9fc19878ba5298c7e9695fcff7b38a7a8787f18670ae01b007d543219acaf97c00ae366918cdb5c38b09fde2370cd6230fb8de127260c666321d6e924e862013a07ed17386bfbcf967ea382063f7a23d3bd81bbecc37cf196adc2f04863696a5645eea41a11cac87b1a8b9e0ee5c2b17ac8633fca46088cd9a67de88af7033f05336f5a0e24737d60d9bf717298fef966cbf87bf9b92bd7c0e369fbd1d8965f17c9357a70c0c8c05c6f65b68c6e9acfc19ae3c0ea13793584e3c1b13b1c91d30ec9d23d5a783be98fd212ebd57423bee8ca9afb3ead8c8a1a424a3831c6544f561db6ef5a20564709dbe5ee3418053c2856984b2dfc502df6e9750ed74efc8adeb98edd6ce434e6341a7512c6c72dfe1426182bedcd4091f31f446847f103bd4c80f852094a5975bf5c8cbbd263548d221ad096d7d9961623c96230f02bffaf0afaac82a7f2c168ba4db442e4e773ae378722bb9b2d192a0fac49c220bab6928f260bd2928fcf06a679faeb3d7137314cb65cb15a1f912a5c8ec6a4716465995654e5cc0473ea5688d1bf734b696cfe56207acc18ab0134fdb2cf147e05c0b20e696fef22b0ba015f0e2eabf97d43cf88e7fa57b87f30b5defed9ba47b46f9d6f4c87f2dc390e897b20e6b1cc84154546ff825884dde969d88f4ec3a746fb5b772c3968c636ac5221686c32878f730dab42d7c15564e5d2cb13f90eae9f7f4ea02c0321e0c2289584524dbc46c9b37d8dfa5605183e15548edaa3f3cf74b786ec952854eae77bbfd634246a5e0d038dda60602a51756041fe865853e6a7150c1eafafbd36bf96512a4587c0bbbac7501a2c10ee8d2f0aa36583a2c91062f528487cafca19cf406e59b023b407235cd6a963efea8173834896a65d169dc2a812902ce2e557ca69cc55a1f542d40211c5a8557ff98d2a19d530470f0fef7d144afe646baeed258874e7296a2cfe00674d72c2a4c5a91dc207fd91f6965bf9e8a713f2cc5f6be988abb7ac4c4244ff9de22a61c61b285c9b751596a98249be373267af52a0f1626a4e81bc9252882bb9692d2a40402a0b0fc10cdd8c70a8ed9e6792a24048b79aec020a4b85245058f0c2470af1c846a30f8a18236226f4bb320b13d0374906caf05ec6a024551d34aa0acd7d2e1023081263c2db05c282de3ada9f60d81aa514afd739ccf4bb2cc7569d61f3723fdcee7e04cc49958825445aa1aff21ad1eded087e36062f4efcf7796feb94333552cfc2f0c3cffcaaa9f042e6af494800fdfac3480681717a167ad0dcc5ac0f91fa367a997d28b2db07a47e1ca86334ea904bb3049e504aeb959783267e1d4bea78c87b5d484de869dda9a83cd1662fa778e815c2a199d0aba9df64e08dbac13aa0f47d3095bc891d5dbef5089d1f0cd4e3d247a9f3339987571065977875ef102860609f5f5fd1eab1b1450e8c255b4bc25bad4b31dcfbf6ac8cb103dde4587f56883228b14267a0e82b52e843bd4108d99edcac7ab0245f1715147ea993fa313f9e83f049da8479e97007e5a282981503b70f9c261087c656f6334d86ed444c9d1c86627e3a420a79e0dce258e45ed24d3d3b4c7d944044020ccdbfcaa56a6a4561b6b4862004d109d16e8cbaec95bb9e865dc55dfedb5edfecb048ea22adb959cc47c788acc5c392f785d36144e14676c87006a8db094a098b5befce2b1b70174ad38611ad120ed31110850d75cbd418d436481bb4fca951b38cce1011667c7eb99a45914031906daf8d4c03c12ef183fba9190a866bcb855d19a1deb0cad82ceeeca7eec521c6d54bea7d42212c9065c08d27c142d1725ce6740c00fbc21c651e06d0e0532a6fe5aa7515e1f57a6e42a25a482f82f25c43add40059d65cebe0c4e7c2157149d0a75cc64284ec9a2ad66323ee8b8906b5a70d871dbfeb55c110145c68d8893b63a37084b84a8ccb8eb8ea77158fce63108bd9652fd87577e1f2cb27e87d16b7b719fa35cd188ad9bca6e045b3a6e6ca54f662738eef59c6ee09ada0651a1289254d4c6366eb996c186c8c0dff9d20367392c68061430ca6fac8b05e6dfb8081e774608d02ec93c9bcb714688488a390a70efa32d4b5196a020e88ad209f46da6fe46ffb52f1e5d999d609d4db4d4e3b8aec8ee61d70f753293f21a1329413de7e3254cf115b11c551116b6f10d177a0556ea4b0339470ab51b96fe6e59c220913ae7acecf2d00b88fed404dce8f7cc1b1d2b74cba9003f7619396a1981ce0daa4c9ef53748fb56bdff0cc15eaec634bbf0dff2d9047e44bed08b561b7cafbe9104bf58ed8a4f9a4f841680cc602b7d45703ecdf9946e180786b566ecfdaf3172a87f28d6896ed6f2b07fa0d0a7b6032baec1a9d797dce6322c3b7a1e9473431f41b9aca2a63432c07d9a702ce219979192d353b67c405952beca64c796d9b1dde356f4127c8ea7f42234ed5934883e6b6924725892f6e9d91d23dc6befd9fee434d5c0d3f021e3abbda60904ba339f9dd20e1c33714fde9734169588fb3c0716da3c86899e1a82206ae89e783bcd889244857cce7733e76a445076417928c2d9b0222bc3459e4cbda13f3c8a9e0ed880b0c84e68d3ff9f086cffdddc5d78136711761546c4ddd2960174a819315eb873856c59ce5a4a26ada10fd70b40d86bd3acf04d04ca7a28e9d1b40ce58d4f52e4a75c1225e3edb50ff02ec6c97ba4ab4fbec1a9a5ed0c0f4975856a94f264cd0c08ded0483af0c3a5f8b2029033e1371bbd28916a6a60305de3d2c357d8a8a566f01c159bba7d5c4b0633adffaa71ab54661129636d285b0d3d231f289a02e5803a46ecc6e72ae9785a557c9f4a7843e9d8e035b86b17fb18a5ed2c720dc81dd687086090b1bdf9abb565f2dd51dac0ba8f1ebf2221139888bbd2cdce4397c2f5d4a3b7d70a5de09f1920e16516abf0ae03877544615f5510508e228609953ebbea50b3b0a04015c30687dae0009b7cfca5d070d83c0a15aebaa46603243dca4076ae7020ac09f998a8837b5932d439577328f9b2198dbf833d9c599e486b6ab9307b1d9e1eecec7b4f47487645f37f1a75aa48e08430e90d245e5b9cc1308da9ea67c1d79dcb4a3c67e09d776868f6040be013714d9f22559c5ae1e61c60464dc33332baae88636294830a87b463e25a244190133789704d1843c7da8b06da2025597b562bd20eded55910c77f4629504c7b232bfc85069313150866b0a1d6287c5e4fd0b819843027380395e02374453c3cadf4a7a868b2345e828ba37f7fc0852ffc0674c56bea213d4ae3136e14cd93d585e320aa5fdd2339d27e70aefeaa43b531b57628df5a5d76c3b96078790031275c90613580e22a16117b4a44c53bf857fde25a23c4b5240b39b5526cd0314d8d776a2d84d7e48a65f867beb69dd6cfded3173875a3f2551980c63f248bb9b00b9d023419ef654c5c7fc5f0e62326954fe9e2665c4f0596fec0358dbfbd8124c2753737b2c119e7d308f45705be0a9aa1296d9a75736517d024d1f38a5d12a6588f65fff2885d0c472755bc20a9bc0edff2b38d95c3f3459a84078863a29be2bac0dafbb0f57cd554fa43020c697de784a5afcb8c80b5dedf358fe4795ed7f0ea7f10a6df0d108068e52c2e45ec1831a00db85425a3299bd390f70cf47bdea2cf2f04ff721e9f26a0f0174479a520fae1476a0d5cbaab9471d9e8f5596695cf885b75210ba477067bd63afbecb40b778aef1b712f118d96ac25425467cdd725dd0c16b13b5a62de3b9ce61c854912103cbba6fdab580704ef7ecb68ce98a887063f281511a7cd15d6eced7c0d82b18fa1401c8713acdaa536e8a165a73bd377815090234def61e998cfaa6ff18f93eadf8889e479cd2ea5530edfc995be53b8547c8dda90f8abe3563a73f755863324a3aca2ea7fb24b78bafad4a3d1e7cca2a8e5b99acc044455eb046156bb4c7e5a318ed826fb69cc193fb89b6851d2816681914656e7817f8d210b491777a509ff8d4c025a67f5e7df4de3e233f395f3f3398cfda978404905dc205a700143d04ac0e1c269c02e2782459cc3a3105f385e236c44cb75ad34ea1988641dfc7971f09a5feed604112b893ae16b7c16a46576b91770affddf10fc5a77b676d45518c9b4ef44d17e28b9e7de4ee7f971b931a69c243b32468e2023ec959ae1d7a1ea8eb2677433608e7705f111f3495e3e49df69d6536200afd6d8263eb50737fd028a6a39d8adfa7582b7a3d65917f2aa14b5cc768e5d1af19ad305de782db52d5878854113c09cd24f50eae52f67be284332ee1f857104002fa4ada61e9e151010e2f01732240c57073faf9a9c312263515ae6b02ac643f449ace18db097b9fc21d6ec3ee29a99b3d586c079d84059b6955ffe3c88d848f8a6eee126b5dc0ea72f44a8fcb7083d2045735b9ce78c9a9bf53d111ebc89225755739c5d201dceeaecde5793039a14c984f9c8c55501271033eb3b0bc97180e9b0a55eebcbe52f4e5c23562970890c4bbc70ca4d6a8355131ad3e8d479ac8758403386b259d31bd669979a1d388efa59dbf70a5bd644c9d5c7dbfcabdd05636a3c59de84b57e9872b174076e729ffee8e3ad397a88d44972f61afd9abce86596a38ea597f1b606d08b5875a169c92815c8db9c603b019f8e5257b743af1b170b01632ff568007901d94b84e1daeaf9e3b03b893c9c033b79971065f4691ca1aa26d4a267b177ee925f29f5b79e27b6c59bb7e4f26ad01cb74ed3b82a675f2d18ae833eafc4c5ebb421a52cce569fe126cb1d15056f40bd1965043aefcd48eb030cf46f88c55608bdadac0c9b903039f5b655350ea7c53a2c80ff31118ffe7de110cd2aa8c58e64361f710ff3c9fbcc2005274d4e9325595524810a107f15c56985ac2b39675edada95b7b2b2402cf6917cd8186f458f298f0e8d0213855d9eb47e68636a3b60360095939c7240594053d1729c5c344defc7dbf6478fd96a79fae9b889fd833b0c09889f1584affe026f06310217459ab5265118aa6b012a85451327b67190991a93216aa7e923f6c9ff78521c97ff5f44e2919ee161a23d7cbeed56514e326e79c144cecca99c10057709765bff22dcffac3bcbd683f0bab3854204235f3b4ee6fe8a239eca0e6aa365d7250fbbdcb1ea4ba496632d342169062b7971c513230bb720008df68dac89fc7dd56ce56575e9b7056712d001a93f59697dbba4bd15ca22f37f339ffa3d7a7026928a01d7597fbf6fcad21b697ae2194a3d94f63c79865c57de4c12fd4602ae2e365f9aa221f97cdca4d3528ce8b4f853be2ac8470a35996a3d306f857c5d5b8493c4f9f26b319eababee97953322b030214e821ac7e9538be8241ed668d2e7f7bac14dbb1c382892ec39a5327d24e90934be70e7e0f28f067402ee4b25ad7e8b28e3e9c5c7e9123a9e38894939da662c88052516ee254e6fbb289f8b92cfa9ec591e670733e242397d57ffa08bf04d09dcbee185085ed6a9eaa2ad2eb78a76ed10304f68ae0a1af47a2306f9c587162551a5b7dc4440910f7a042bc40fd8f98ec106782e79a4cb113e63f2cf51c96108867ddc5672604490113ae9939b143c234637b9ba024affa4a66d6274873fabc4765bb10a42b3d1378ec9b185c4ef09885cc4c4ceaac409e0a6984791083b69cd007e8d427e87c2cafc525f31762eb8838288ac4ab9a650bcf3a20f08c822c46be9ec9316bfa61dd88805142699cdde16a28cffed7efc6e43683828d627dc6bf7c36889f06566f14dbb4698efb68c1258a87cd681d37c2a74664988400efaf34cc48bc57923346988a17acda7e8bba1b422351e04af06f41cbcb4079554f9cfceddf923ea6d40978c7addfa4e7523bdf3998b25dabfd01a39e5802261f973b96df21cf6bc535d58c01dd1745f40bbb35f1185757db7241cfb080729391886b5a9ff6c22f39502b42b358720d9bd1755a229122007c17cde64d23266002b6fea069e1b72a398fa6bd6ba935238781d6aca321420d74672b74081b101a4c5731469cab9b0f57339c1551d2e831582b2073af76120c8df9f42ad4411f289ad380489a51c8bfae0f789437de20b05bf4526bd0291f34ea74a680c79f6dbf8500949fca56ef9faec6505c1b3bbb23cbc35eed7326589e9e550a17c1659118732d11e491c37f4fe85e2c7278a167d442e28eab5ab24486070f1b9d43a9b62bdf233604858adc3f3d673ad40421cade4b70166fa2bba410de629270058787653f0463de1b751a6a6f054c01ceae075630c5cfca2a591ad3a9dba5b54aa28e89d7ba47e1957a97009ad23f584e783faad27df08ffe0262d4e02682ecaa0df46d55102b5ef0d025b8a6fe0788efe4df4a675b69755b785fde2fe167e861b5b724593309918f06d7719f1c8d47a3f91c67529b8f1e3e1ec5e20dadb93cf4fe69483a0a62dc8f31fb5bd4611c8d672be62835fe83d614e51394bdadb9c6f7d055ddcd93809883c51ff0a0ed402623612d6cc7927b57844169655e278aab20652e8b3366b560455344b16a2b21b3500e072630dea1d2e39b1884e8ca12d2e42742cbf6c480772615e28a0029e0576ddb03494b2623f60e3a8bdbe5b3ab0eb65ab75bb230fc73f0b0261837c89b074047ca73f4c24c869110d5948ee2a6eca8af38cc0bb3a1bfb38fcf02fc5476f99a96c752aee9114764700ff3e191522fbc664d418d832edec1f4ab99ca202cd997d022e8f2f4f59859d295824d360f67942996bac7f8d5828d4a0e34724357381f7358c6ad9e2a7756e31555bad37753c293c07be9a12f1618a759d6759deebcd5bc3b94a92244f603d1d4a89f0d54bbb7146c76e484878c4f2414fac537891e5dcdbed4e3a325a18b177059a7018e259fa12e6e135ad2f0af20b5f36cd2fb8147555feed67947a522b63102c5eee90ae85c345918659e662ad770bde0a5642ba9e62c4093e4c433dd2c802c9ee285a79b18436bd5e325f39106b8398bb36e1b055723ebb429acf59bf3216247c0755f4dcd5aa0d120d89ab470a75f4a0b33d4f9e799b8a211f5c82e5e2bfbfa8e88be99fa231a77019b6300446d056d26f3504887d37cf07670e79dc6165b601d6942dacc3ce0c2bad8abebc1d6c1dc81d2f914da781a2a185db8692b36ba83af6202249834f6725b684079d489aa721c556b94796361676934283c6a5ca4490f2fcb0a6cf188a988dd3e655185471fedd4ba8a6211431bf034288235288be658ad9ea53e8d6c58f08386d32e01a7d3392219ad4c8155c568b20e16b34362f25b44e7f784bc7fce0590bf89e60977f358c19375f88b09ac0a993ca665b1d0bacfa470e70f7ba0167bf4bb84c7e74b1f2ebdc8bf2cfaea4579abd3f61f7f3519d488b2b9592048c18fd786e83e562ccc600871bdc69c5f9b19d0bb8e5df758607f92283df4a286565f084eb93fc51c1ecb221f3c5e8b903c839dff4c69e72bfe0e55255947baaaa85519d628f213e5a63e650e96d39ad9f623a0d4449302fe4a61b8cfc7e9081b9b1dc246c1c5e819530441598dbb4244d2a30b8e50affc3b00d9006ab9138811453b18eed2aba2404eb26d4a7d97be3794497dbf59e9296c0190ab3831d2a333913358630815f420b76a0d10cb6d22c9195b02828b0b2d8ad0e9033a8418b346aa80070720e424b716d4df086a4d4d77492e6394c346b1197877fba8d44ba218c977a2d795d62a59ec325bb53e3035fe3046d996e7ed2b9915e5c64926ca28a85368ff6b5c9667de4343f589583ca0c0bd8114544a3c0897be0b2e904f88ad3182588fb9dcebae642d43f9eeb54ce84d59021f0e1db5971eb68a68ea3f7008f6e3a628a99fc7ffce365ebddd91229ddfa84652575c9707559219193bbf286bd9d810b02560d476a7513c8fe622669052cb66d6d47de586470cac5b8c7274e61bf997b9ce3f3f84262edc157a4f4a6b67786a1aa9d66db0dcc6c6421092c5573a90171f140065ef53dde6455762ad6a85232fdba53459969243d0de8afbbfa13c792b22eca9b5cc7dc827d41e052bcb1f5e2acd16d754fa593fd8356469af7a9d66405d6512ed01bdc4c630d0f9a391c21184f89c0db9b9e7733cc537e84a87df9896d3e3ddad5f34e70b6f242dc2fb70423186782ef9dc61c7ceb828b5b47e7e0656bb1b872ce7bc4c8211b9beeaf186d57c47a43d9f00409b35645468004bf8fbb4841b81b312aa60a3e76a149a24508522feeb603fe28e27d8dda06f9c4a7d4b5da9523c578aeba1eb885b2c9c2c5fdce354efffbde5003412fdc5a4e44eb91d9d8c3aa8b669fe610577bfda4a4b4f36981e1992a421135c56acbc5a83002e81e875bb209b6709e870914223fdfb4dd675c779b8598b73668fe1378827b99a70215f18e46f5973b1b31471a7b85b08b520be3bca0cbdc6785ac38224068b54da801cd8aac7de433f45069cba6f66c53d8f2f1cab4d5c0858766e06494c9e720abbd369b95868e3439d72b1c127fa7ba7e3ef0c428eb9c1a2e67aaa92fe9ec595bd6ff4556197ab263a1f4dcbb3ea033bd01ff66abc4bf5733b49ca3e734f4f4ff3452c27472d8c9b79fed67a8425f4f1133227f0724f04a1dabbc4c9fea799381af503d7fbc50db5ccd08b81f94e9ba1b580e861bb01f4eca4359279d49600d09e22a82728689f142807b9b4282c8a3d919776c1d8fed7f340ae015dad1b7de89c7f6d2c4a4bff964a651c13091e5746c7377a583a669b43d9cf64bff0f945af27fce58ecfbfa77e67384f464298409824fb560bfd0ef39de47bae0b262451189196d600ab9b371a1cd92a18616ea5daea4cdca25f8b3f7511f919028525e5f9ca15ddc0c1279f0de223caf1fa654db024e9d5413d814a45b554318def03d3778ec836020ac1c0816bd618ee35e6f14ea3bec9f5c9193eacdc98f5361af13bbeee05ea43de2422385ac42a0e0a16e8ae1ac264a77c3c0e9f7b1177023d8a4fb7276140ddf793ec831bf4bc622fc9fe9f18ef6b5b1cc9b8e17f41925285683300562e55156cdbf04525f87ea0db909d53b81794e19f62b2a74a65f064ce048a9b7ee7efa64a3a1d69d0d86b4beecaeee4af12af14d8eda94dba996623a969b8a9246ec2256baf3c12adc7441b8c1aeb083524d697423b9140ec9f16b741374ebcd652a51abf3abd3489e901071ea1b333c3e252c3eb55967b41e8a691a612db1bf45177e9ad382b2300d7052e04af4bcce8104a7c8f7864aedff37f10b8d463a41c603e73ce49f66956502d2a9f10af40cc7ef9b24b9ac2671a50d5b6b6dec5720dcb748a39f61603ea7ae7a657d2d101ba0b6b446670af6c0c1db20603d160d6aeba66ee28984117b0296b478142672427fcb9bccbe3b384240a707c607d0d5835cad05399f46455b23fc0c8de2d22ca8eac82d538ac58946ace9d45eac1d9837f89690475d0f22f442afe180898fdbfa789cae0d1149935ec23605472066bbbb5f4b4661c4ae9f99061700b88c61c81d03ff30ebcdc66af03b47fbd189add8a0fb473537cc31d5ed92ba17f72c599957d262bd726929253d1cbcc984813f0c7c2c0d54a59eb8c280a6d11cc014bd8a293096b7405b73cca628d1e13060e18f20a038f63b13ede5ec29e244588c8ae7c36bc00624710ca051d2d659457a50f8349b38578158025fb39f09370f87d2f2470b679b6d84a68e0f9bbdf810b40eca04013fc0a118f863b55d94a4495996a276b8c267e113632db13f7a64b9d2242371cfc12b5d40c77047f21dac65e67de25656e8ea20228e8ecf3578eea92c51aba8134a24398d003b450e90e65e7758a7356b8851efd89c133326aceb18635e95257c259c3161b7368b628d4d9ef9f995bf109d1c2ab1df75ae13397400fb23483805480bfbba139d20633cb1cb08fb92654840d93287b321012a5e20723cc5837675c55f4a07f6d7d53d05ee6cda551aa13da354c4198da34da6b7aef42201a42c559973154dcd5f3023ef01e758df8e84d7359cc8212fba9c8ec4f3bcb64a71a9d2d0f2bf5d384ddccc546d6f946212cb61817c8f538acb536e1520ebbfcdddc17af7d88ac99ad683494f45c7107fbb73e8319c4d1406c6c555bc8dc3e8f7d299cd2fbe46d0e66660bd7c24da421d189948e6993c8ece1cecd95e35c273c25cd7c3bf8d7118c73541284cce02cc8776feac15a8452ca989f41e4cb07a3b49cbef27400a89cb11c3b3161b9b54216d52f0a22d222011ba30ae5028cc59b0434ac0418e8a5dd0f4366cc5080ee7ee3529facc086ebc58a99aaac3fecf6219cbf1b7085d3b717a334c8da165cce2289bfc646b6dd1f3796d1a6dc04e65021ce42cd7820997037ead738ffabf0b6f378a640efb70a030dd18bb8956f8ec6e25971474a75df6dc28a9ed7a7dc8b768e8b16c81e26196eae297c4085567ae0692dceb4a7a3af6cbf4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
