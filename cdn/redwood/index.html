<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb2f58cbbbf1d52879ccb485a3e95743a757e6583d4c788fea0fe80231d08e1bcbb1b2de7fe9ae36934d24b67ba1294e64bf686fb7e16ba6b13adce5a94414cace785bd6dc8b8d8e63fcc55f2b77b1ba5e5dcb1976ada6da9dfe75e7f9aa8702e10fc96b1d17c4072bab378fe7022d5ae9b3915dda733d0e54371ae7b5bfcc564ded9c34d8a02040b575ee19667b5abcb51d771047348d9042c64b86f58e64ba672b7a71370bdbe079ae93b67fe9b0179e8e795a7171f496038de264bef2dd8c65f91e50cba40b9a2cada9df7ba53c82f0a6db85c5421e381f67651dff72c6ee74da7140288d17ff089893417d4a8678a77cf7c09a8b4a46137d4e6166e662e02a5dc564dfaed3dfc9cd75db8ad017f86395d5f6cd719a83498024c55dac076b28d00b9e307857782f446934c7495ede9a524a445da68546d4f0dd14ba31f2ae4fd6d172c365bb67f46ef2b5b87f0aa54f19bc0dffc2df40cd515ecf86b1f3f94e604e34a5bd8c0f63b8d650d3ee1767829f8c81c5e6410fc53ffb52e59d418716a250128a504e102f84903705b7eccc29c2e50ba6663f3ea0311dd0ea8dc7289a84690b97dd1391fa4fdcc2a8e7219b980c8863510a787fb110c9aba120c50b9f4f282821c00ccaa0a6e905aed311630c8f35de0daa03c60c6d992d44502cf62712b57af8cbbbe644fcf79177af30a66d2a7127055192220939d0f8491f5190a7a7b9b920f6a2f0d259973f2e2f8802a1676d1c74374ec1c3678efbde763b834739390707f9381ef25a56be2a1402e28a0efc18ffe1a152bec09f772032c5d508f86259e3ff02dc5c4bb9e03894325e66366d7f6770db4fd8139723dbcd271814227ddce62669881f87b84be4f1e879a0e7cf22b52fbb1e2ee571ceca8d7dd56df802e96e3440153109e782734f4f8bdf7c6731ee9cfb69488e18b19b47b8fbafd589ad2b0f056794950f0b81f4bbb6a4b854e63eb313d5df892efadfc57aa6693bec78f7e870b301653c2b6eaf656e1b848120aa8b069f3ce5586198523d7101c0911950bcbba42326aa28771a86d87f2517d09c35720dbd7e46289aff732566fa665a15b22de1bde4be43a5d17015e9f4fe84680e02fd7df3f5a62007c7c98af4d92fa88a90fa3991c58dc8d0838eb190d2ceb21372f368831e5c58da5da50ac5627be334fd5712f1c139f339685e9975de0468d393741114ebd6f2324e606c1a8c594ee8d791f24dbfc12c66bd3ade3812eac0b7abae8c76fe85500435a7f0b85736e4bbf6f1cd83c47aff927f705028aab3c33f713fe272e01ce1ecc7489122ee0a230e2f330c49e2bc0073da2a85d04c4c25196640178646e1fbbc743baf13400173016c03d80782bd2b894d4aa0fa76142551f09329324ac9fb208a40a2d28767a39547c1c1c44685255c322e4e53f7c4734c93cb71b78211e9a796c8ced092e63c49d77244b65ac2bc70b849434f8bade75dd446999d4b7978e2005f940a3e0fec85932937e88ce91a93466888dcb2cabe8d413385f25c54efaed8c9832c5c20c9d98fc0e3c1c3694a0eefa31f48f246925cbafff200c0902996cf3f2a80168dde535cd9a2bd748cf0a590b5f42785f3789fb517562c3c4cf991ca1f94346f186c8e53aefd346c88be1892edbe49e7be0fae5d75f39ea9501cff27e6f8bdf0798f54740a1c91e96391121cd35206b268dfac15a9809baeb3c17c8249af2532bab973d680622fab50b40a8f2ee17696ff1f4fac87f2d7a15b6d2b2f289c256a14044d1e54feeaa625fe579f58d50be505b4a44ec482ab55f3b6b59c4a8ad2c846ba86c1af2e97c071016bf8a9b63ff5a5414f7af8aff78d082a1724b31984dfc254b15cddf782648ba2576d91ffb22ee979c575e2ad7ca763b92ec47f9a52f78eef1a43a337813e2c462c680115fd836f8722eed5fcc8ad15bf2b247e3cd24c5f5b1ca4eee8ad8182bc10ca064207687b72532641dd88e351178689925dd46105ee9ffcc97801db4c216e6a5486d4549425445c2225a268fa2265b91a40b05f98a603ce2391b66a8554adb05b442e0588396f2b0ac8bba1e4e3f0bc89da4001c47a0f603edf7046584fc8ddab2c5da27de7fc488269fadc35a1b407dc4a80954c0528ad6ffa56c19f8c547c3eae3496a0f949dd281714bfc5906841b4421998b157e567f617ea5cc8c47224deae817a4ec369850cd38288095cb66e1122f1de3b08de18495cd751ba5f0ad425875dd6b56c4e2d3aaa32430baf2bf126995cc651871b78614b3e3633019a5e0314b4009091cd272de4b8873ae8def4123954ccad9639d5a3d2d5a2550e9c540dd91216e2e9127d37293c31b092a0b52d4df1a1d0a0f057e2a15f20b9c7d5293cc8ed792263b79a7eff0a288c04f43adf08285a2bdbcd1ec826404fbea05af6adfad2a7c0ee1f15289adc9a69d7f24851cfec848de9621f874ce4d016e6c82a4e43af00d630afa94e3d9d832d52676ba9c5f700f553455fa28502cbce69e7e17f944e2b2f0d7e0f14d469b4c4f925c4d44ee1caee2cb938d61f05034a7e83a27db0141881db2ac815c4abbb4f62674829f60a1048a9ad8f2d745a3c9f095fd5b89462a26f092e79f12831f2f6d1271d3afa67cad5c4d9307deb8110cc7418558ba0127cf4e0104e0f5b013b1eb4b051405b9fb1055ad7862f36e43b9c21c3ac3887a2eb5daefbf9ce5126e48719eae8ca0f3241feb33ec0a9e6e6a94c17e87ebe97ac7cd350ebb9245af024dd082cec32b2499b33acb8949c45751072959c73f4a1ffe844ffba48ae2f1482578fc8ce1530c61f218a46739a9a28120c097214c8799e48a67336d75c9b856fcb6ab748d61ffa6b0a9c1aa23dbb54102efb3af5b811e0641ab4581d4e8d68c19ca98c48503aa99278bb5fe7f788d0ea8ec27423a67ef3968e53bf069e289b6df22726ab088595421fe9faa5e4735b69e9cd8a44015da7d6b8855d19348810cd00ac11dc448fef60c59992a3ebcb081c31688806d63fe775e05238919efb80f8d1eb0040ab094080009a8af57ddb00bf6b99ff5612424c78a3abfaefd8a9cb6554ccb7ec22388633b7af6552da2984e3efdb5a3c35b391b50733b7561601ad3e60843fe94462630e7f3897a4d221ae8fa02d0653ea3d4649d2b6c3572b86389cdf1954c7824d4428a94af270583e8f8b5a33a01eac160e3e31f7aa44554bb0ad705385ad5c9854efa61b906ade338cc9986da7821b61cbcf11f8beb348e10c15f1d9c2acef70f2affcdb7cf9bfe3f7f6da1467f0268143c7627bd13250ee202752467ddba985f4db0137dc183c2ffe6c5781050a79b4b9070db4dfea83bade06ff1f43436824a7b31c7a90d5f0eadaca322858377e99e42c53ec2fbc9bca10383f184682aa066d6c488d6e87ff40ea93998d9766409a114f38f55f50f60225497435582a2aca4828865ad414ec08b620fa5e8674e9ee2753f6ca1bbb71bc75312c0481da3c0b139152f50ea92924da633eb24ffb587e18ca3e8daa16d272ad080babbd03a1c7faf07b7ceb5f6ad1bd454512f6850b1f944d05b139e5a8aa96df51f191d2eb6187a2b01c9b83a44eb21753ac0c9fbe0bdfc647c5db11081e4ebe553420a6d85cc8a0fd62706aea4e7d13d913c4f8e0200f7ef5c3b57f5ca53e48507910e72451d87010b0bf25d506c75bd0e7d2ebdcbbdc089123fd23cf2887d721592d1b50ff612b0c53ba56c12c76928bdebd4eb7c5dcee593bea18aaa3a69c1980261216a90ffb605e5f164eb72fd18085f427796e87980bf3afa39bbdbbb43181ac3d98b0c47f2cb094770fccd335a16f19f9e426b4d3a69a018d6a40acbe3ebd6bd8db33ee7af4d165e2a6a5fb33c0cdffe218146109016a8577ecd57a4d20505bfe6246502a2d2778fb34665442d26e399166b2808d0a59f1584f2f729fe9a531ad22e105ffc93e0a557532d6f23f4ac2fcbaad26bdb3bb38a8635f232bf98aa49383d97f489668df3c3a243b7643c444418d9945da91e01c227c72d6bcb976af98c0cf2687a00cc5c851c2f07e1b2b8323a309938c848e697123ae2ca152f1b4128a396450d4a24191e81241ad43b51b82f5383081cb92911bfde0b65080d1bb6ce702d43f5a8a5b3fe3580bd0bd00f6648a5ebd082ec498373d4be09d86890726f2b60a11a5371e0b1b212766830484b3df7c4a1bf0e0ead6cb31d2f44ebf077432868ebf23ddddd89cfd0e00ab352772f149890ff8f606c5ec39c0502f6e0db8159c48a0c316b70212ea849dd76da4c8ade9478bd0a85467819f89d1f55592f144d030dcea7465026ace8236447e1264a2a0063226bf47ceabfb974e5a37b93c07cd1a63cb0b98980c86d596485eb6993fa2d38cec8e431547d0b9538aecb47c997f3658b0ad3b026a928de85b6d10e14947d9b0fdec27c85006827a8c91389c0a8184f864881a9d9b9207231142635163bdc1f3e5355a45b762472c97d9f48c1cb6599fc6ee3b774c5d95116752386e3fc395e6b3783984b60dd920b041deb4a252a6f409c7a7fe5c8d8f39d2c618e40f2aab9f5373eeb86637fd3f8adc0f26b3bf442c8d6480593a0810c76387d7ac3474b954d3e18dc7603fbe549aa87c2ab365e59b43866f90d48572900375be42b624aa185b5b8702b33f2737bf4297e1d2a331075486819246987ff8683181f45436f9d2117363d1b6285db219e701f57440f1f1cc1f110bec4d52319e7e2c9ba2ed9d50c0b64dbbe9e4e3938415cdbe23387e553b28c1003e9ee8cf07c0c492cb44de82d99e9d3adb5714fc127499beea73b3e7dd046748b8dc00bd8c968a5124547f83968262b9d00b0514982bf8a358cc4e6d7c59685e00fb32cfcb45a3d56bbcc906f078f61eb53c32cb2a9efb79272435f7fe2a66b85c3fe32bf7193cc2eac410a9f522f62f3b1ef9d3507f08a8e64eea6b617747bd35c70131022edbd643116064a1190a334d2b3a90df063ec6c815de85e117f49b109204f58ea4cd942b06dbfbd1177b828ac2388aef1782f0bd1de58fa3425718adcb83e4b99345d908d1cbf4a93a26ba24167661bc736a035acd63dfbee383fa7fda06e3297e7b3266a41a9b5c99bb5f5f026ff53e9a52d3c0682bb1e70ff8bd6147057399311f4f51dc5c99a6f4593a8ae16081fc5b29f285fee7d5ae9c2785eb681230efd7d515cecc2c4634c6350ee80634e48ea31757771140970c0e0d1097b5a6f74a6f56af72c26d0a905e815e456149508c37d2b2899e788540b5e54771e89415403e2d50e4e4221bf52fe9117035487f0aed5de5819916c2bd8ee28418dc6353f2fe3bd0aa2851712dba01407bbf9b19565bff2169f5d346e96b30bc172234fabd88ea0e18219ea3af6240fdb4a06964068e7022e91229b988620a6a2246203d30b1c905a124b3d09fd60bd5fdc2574c824c36293fa0a8fbb97681071e2038e10c90e7d9dda23fe5b9a17534b8bd91b40cd97427db5d63047f012b588af6d4936c5f3de0cb1302e548cc85e221f35a5586d54dce07040b103487e756439e5c2e964d455f1170f8c482b0a3a2d730283733d9a182fed77cc7c4320bba4688b6347e4d7a720407e8976dc07c3bd2b45c7d5a6ff72eda40d9ca2c3d14197b80c71121378aed15cc531b1d89746ba5871de5ff88fef7d28161463780bd3a548d6412c37b6359288f7448a8a5d50217cca8c28fac004875bbde000952257520d71c368ddc8ed0e3ad1edb1592962a3942300709af5338916c395c8711697bbd14c5a3237b34c33de92149c369ebfe06b84422929117c195006cf881a8be79356caed6f434d445d541f9ae525baca4fe178ee23d8e42adf976bb8a45c2f8b55b62be47f7d441b00e2c993803e877f62d78a2e01c39cdafbdfc75d4de639046d19eb044cfdee84c157fbedaab96b0f321688e6a08484a5698c54d08c7321a588addce6cd6bc900a6bca259063a047379cd037b93c7cc00d53502491b744a5866f756d91418ac9f7fd23c9f42194b33393ab3cdcda134da1d549197658febc69c079eacfccc70b392698d9af1c83369885eabdcf7e6cb19c57ccd08762db70ca49fef684724be3b64d557392a55367730a2f154e34aeef91c221ab5c18e4e9935b3b1bb62b6b7500f7e8a4dc483909c000d42a3a5073968d138b1b083791b5e0a7c1b0d244e05aa78fcfece39fdf8582d27f94cb95abee13cb254c33ed52ae6484630b764d133d61c7b46b1fa2c1add6f102ce81f7018a02c59812f0fb139d144beaa2025e099d8a7f9ab5c699dfadf893ca0851e368bd055b161e1ab96c4eb8b37660387df67c62ef1e09d06adc9a53529e16f8e7019610b2bd1f10db7650cdfcbd4880ca1a54e504eb24aa56ed081cfa8177ad69e4202d2d7048be2dd4bae72e448decb58a2bc158918b0245c2cb723c98cc9e97b59d2bb542d550a2af71a6edfd14943dfc258c86bac5b3f806e143e109039f8a8e7661de61baf4ab29591b04c8a22d1fa3b3476c1094c15f637eb205cbc764ed34bd02d619961fd5eeda3d5c4fd01d6ac2a2a748037079b3f5694e5f606a46f3ece5d84282870bf5bc9cbdf60ab8454ad14ae892bca4fcac6d227fd7693e8717ac3f75e72c8dcc98a62e411313b504f57eca5343dcdcb0501ffcf1d255bd215850a470568c65415872befb0216c5705874204195277f4d988be65e7424d811e6d4201a8c06829ab1a747f05f8993e7f727f603a295b9ccfb4ebb6f5a894fe084d377ad46b61f848c8596118b12428740b3ab84bb506507bab6af868fac4ae8de2eec7a9c3978f20d10281d75e1b0f6dd598e3d35855b8154ba4e07963146a771a9af27e65aa7aa203d3e6af314a961c48254889a79a89273a90275a34751f06c1e08439f82563c1d6048122c4b71c8200565cbe3a8521228b915ddcb69fa403d660e90aea52a14e88be10670cfd4f0bbe513ce90e08e0f677b3dd4125b5f2c720c42782d5a7e09237d35e568e1c9e4286e2c02eea16069daacfbc7d5b73c31a5a1c0a8f34d92c7640b9bffd11f5f8ecf2325f2e6d0b33f257c9ccd26bb898b04b3ef9aebe54e21c730b4cdeb0db8732cff72a26238faec34bb6ab2c21adcb6f0098a848d98239ab87fed5ca126cd8b55de67dbf365862bf3f6f03404587f707917ac0a67ced2839ed79e8eabeac49c63ac84dff62ea3313bc82f6d7ac4a8094e97deb4dddd82d90364dafc479c51fdfb57864ad718743797ef7cc87d2403327924d778d9f63e82f7a6a7253b1472d82a4cc5e7a9b05948464efa9f464b6c956b41504f3fa398fde224bae91ed771bff826cd755f26f46667f0bf80301df611919be7313c36e758be40163ebc40416b4ca7f8cfdc9ce5ebc944618c653b9b3dedda7a997ea97ee8c18942dd811741a9b660877f7160a7868005b788f5be67267458006fb17a58e5a7dc84b3cb95a60579953043c356f22f51b137b5fed07238b99d421fa02138dfcdbd2bbacb374584d41ffda1202dc94938fcb6890bc4a642b21ead1d4a715a5e02e126da8ce34d9fd693b79f9ecf57f29030e32368110a8a4f63e48240c97e450d40eab33e860c5b565a8f195a598a57ebf7321110551dd54800759d7816f042ac96b95db2332b8afba19cfe42274019778bd2a02b0f0557e297ac1312fac50d1df76a18aee3230f39e620bbc39fa5e3a053c1de8e42a93a34b535cd6bb13272b2886f0860c0422cac5673afc092af1cf3db57e36aefb64406589c6180ae2374898c492e240aee6a6146b1ec5fb0e4146a2ace080b5e0e05ba965f4bd239511c5bb0d91e01d103713860250cba84a1f88a8d12c2401367a3ebcece2400939fdb09bd2cb8de8ecdc22d202e07d0f55a9fa357ad14cfe2f5f59c428f1d3a1e2ede568c6a8408851907fb8ae6ea3c6cda65ade98fc9095f288ce25006a4297be6f2d0bf0999abf14c5110b66b33bd83d8d3a36fa87c0963323e525ce9ded7549df906e30778d215f393435769c5c9a1ea8b68a85fa3fca4dc5431f7d67e1c3aa81bf94dca769529f5663c68f0f7e0f05ccb20a299c623ae823d4bec0a915a8e4cec44f8dc3109b6dfeaa486cc55fb1928a4417011177a99d6d2aede62f6ff034aefcd4dda523d90bd15acc5c09317bc5331af82de29d2d70655e68b53761d0ae0e3e206c1f6138be8646e1358a06185454f4dace384b18c65469ecebd3fdfb6912adbc618464017d38efcaa313129c047519d0e3a1d3027468acea06d45fef052ee235d80937c0b79c3b17128ea6299908dff294bee444667abb55b213daf2061985bdaf47f915f2fbe3c1c840b89c09d11d62e48559cb30ed07cd1fe1f461cbe5e456e315bba5951a32cf3bc22c2e8dcaac1e7250941780c714eeef5bc272b750066a8757587821fa2ea9595942951c36b6f524ab1e85f6663bab3d5ccf0516a0c4bcf3afbeb8997f9985cfa18da36d1f8e6ff1a029d9186b7d01f927ee4c9bd343623cdae179197411edd6f92adfa796c29866e4e376a485888b6b93a8ef50464a04f5acb4919bf5c74addd83fd4eb7cd8f6abc3ec4ca9fa94ff042d93f2e6308c74c6e8b8a35f0c6580a27b250f00a5b7da6d1d95f2ca904bce07473adca4e6ce50bae75b32d8d1d82f9f9761ba9275eafea2134a96c065bd2adfad7630af350b2e68c8c6784b5ff7e29afd2ae43c147aac08944ff34d36ed306fea615501ca9af7efd2d512dae5ac4cc73db242287f9ecc494ebdf0b6c9c939f45ae946f248dc1b9a728777d109fdc959d3ee2382873439a22b87dc7e507965997e235156c56b995c47e84bd7579910731ca305ff4651add089d1fc0bcbcb4d7e7fc93ad9b15716f22c5267f953cb94d153cf0477c45d30ff1e00f5e3fb89853b0963d7bb5d969cba9e3d7f02932c5f8103be935b1ddfb7c1ce3e4f0097a8aef7562dce4f796e4edcabdc8de9391fc1909270933f0c67b05314355978d0d2cb625458912a67bdddb113a8228f3f18a1c9ec54b39b22aee7ca76795a1f11a71eab7a38faa292b857e94bc129fec2c4bfd2de1e30ca9440089ee7552cdfb15426b4da03418ea27b77130ee3622fd9fcdebfd1e90272bac8d5f126dcb44325c7926f0d0986cad97804a13c63c168e07723fb2053a3695c6cd9ae0acc64e1ab5a31082d2336add1c8f902fe8e30dfb97c69321d9f230c9e21a41ce3050b3635e1f9a3744b2b03ab60165bafa2e29d7a1c1e39f79483d9fcaf0780e4b56afada3a95e92235cc3023e24f547c32a689025e366b86f9891e1365a3f83efab14345127630b8d1076c880c87306ea7c4b6937a7396667656db4f9f3c4a5ad1b3b77975190c91bd5519a5da17de8eaf58abb14acb321bb129098617c16dc7c2f679b83b617fc0eb438d8a3ac3951e4dd2e8c8b4c35dee6ce18169f18aedac03ddeb39a96677f3c0d82e4b5fd2684df36fed735ddfeee6c949e97c508cca06bcb22ae3482ca5d01eb7a50ddde7142a0a0b923fc8ab65149e5035469eac93d4dd65ebd924c733b15c0cea86363e467277d7b01f4787d130c97863174deb6fdda809128feae85d23572726437cce47d160393e3eaed47a1d4a7632ba5e6d156036f351f158e0a5a383e0d0ef10d67d443580c70a2c6c6b1802b8d7b3866f0aa0c41ce8793938d84d708bf314d04c1e29fe3cf64df6d8eaf20fd802d453fe426a0bbcfc818a2bb2d9ea9d00f7b812b7af2f8f723fd8e746912f655d3d1901c188778c972299bd5d464b539ac070ebe95d74e169ff0d3ed996e23a077aaf91e36b7412900cd6a416a7123e3c491088e4a979640bb7ff5faeb336673f5234f9fc90ac166f068873a5fd60077739bae4d5e6e82751679b575b0ca49c31ca3a61ad226e35bdebc9e1887fc26152fbb455c1f04cbfe6f30340ce1015e5df0849bef2e732fc35e7f51a8d7198a7be6ddde827df8f167ec3695f07551091f8acfefe9aeff36cc3fa5f1d63bb8186bd1a8a16d00150fd037f66d614bd01e6de93e19995a23ac9af8e22462565069a5e67808be12e743db0d844f537a9dd3df9f3d2f290b0692c2e3cee6ab762fc892dedc8eda2aec63f5ed9368e1e09dd0b7ba482683e86b0d37f8ba381523ec9f9acfc0166ef082d2d5aeb12166ee7f9c150ebc8031a319f7fd10a4c14dfe6d733dd64b26c154acb1597d01e7445c28088b418137067b8d6cc1ce72f042de2719ef1acf854c492bf1e27053b5833ecc1864ba825c7ee90f09e75b4e6c80a3e036f1e24fb1865f130af913f7008fac4e22cfe270e0e84eab94a03851d5f9a8743c39774af22b90045e480f84269946ef1ccaec2a49169cd138dd40ca477d080bc2b0dc0296f9f5fa00b8541228e50184897251574f69388ff41d3f59d9c555eb77145c4724ead1d33134e009b990c0f2afab5e1ee8af04738f32f1549e5944beafa0eaef79a399d6b6b3e71eebeeb68ce333b778762fff8dc61b3c8fbcaf6b7bd29516a69f907e21085ed26b7436af2848807dba78167c4495045fc8d2fc244f892d768be1d1cc5ffe5c22446772d155f4a44b1b1f900dd94d6a013448546c155cc08fb0bccc352fc33891cbf23aedd99b26aa0adb50d515484389605b4280824d94abe44cc114bff999a76db088312debf076282538ffda47d6d7ddad69906b30084446e1f70cea7ab2edc34898d404353e1b8f18e817eb5e22512d511de90e2fab8155e74628119390ab77c444f798c7e806c5d7118ce00f1080c695c44f2b808597ad74f40e615d4c41f888cc41486b0ef9f3125c03f91a3f2f2d2d377f0947d55f061a87c293cb90a673d53d7c776f6662c38058d001b9385187ea3e5c41dbba40d8f892fa55b80f3cf149180dc421c8a8aa8d20beaeb42a9ec770592bd1a857ff6d0d5075f5c5c42e50321c7d076b6881c9c5a36e3a5bba98c61dbdae3aeb161187768f2907f82d81cc3970cafdb0faa7d172135a9e2a3013c12b197e7941473fff8edd28c4bb3013a6cc3bf9f3481d5c4d0e3f3e130b0b9675316a62edb18cd9e50a5d85b2e5d91530d0a65da79896e30f8b0f68625d07b576b879ae29d9a4a236bec364ba0009b5c92d48c62bf20f20fc1f9b2d69f655f6851605551c1cfd07c1b92011341e13348864e91b6f7bf860ea79ec994863bc2e565742eeba54ef3f6ccf3bb5cac21ce12be9415ddf277de324e797715ee5bcc2934fd535c05dceff87c997a8d85d612f2a7b2448fc97e596dd2d2d1c43ee866794d84e11fcc261a88430c3ecb84afb2d2d68355751ddb7b576d69ecef8bf636010bc07be47a6bb508494abe80fa755334fbe81c4f2c2b4f167354cc82bb551eb7e0d882e925ef41528ffeee39cf50ab4fc8e03d56873c3cce15b113ded83f1335046b79dd2054e1263c4c462671e42e6a8ca1502c88d17a7d5f079edad4f1c81030b5572ab04dc87861f957f738465e68e032c755d3aa88fde249e0e5d32142a37744c47791ab4699f486eef9dd5b7bb52eb2f209c8a605039159e3b271ca8436fd45af5828ff9821c47bdbcc449819dceeeaab21405993e67dcff0bdd692346228c3b3ee5487cbeacfde64086effd7e626b4d2fb605c1cd54c29e8da831dcb9fa685764d221b4698eeef9dc56fabf7e35d5cb6bcac838af31046a814c78088efaafe5bd491c28d8746cd12a96e7bf32d966ed1ffd2561fb43ed716fc349119504e52f2dfae3aa89f4d136a611f82f352f25c03a0a6ea783f26909c802547926eac73a35443598ad3777dabbeebfeeb8a2a69cfd99bc1ed19bedb64db9349c188d47bc564db56c9350b7464a158f87bc11690c84f3a4d51bd0940bc055a2abf5e8e58c0e0a400b21fea0c6eab89173fc1307cb1e6b84cab31843aa9e29bdbf9d006641a424af5e7de33fb087f044a2db3ac4f7197b20c1e996972ec7dd56beea881d210083dfd653a75e99d9d24023ed9b9e1d08068557c40ac8b6bf9434e0d745da1c5af59ac78fccd78f7377faf6a587f683242d75de6cf23692076f00daca04748ae78384dc68a988e6c4fe28cd5b94ff7cb1fecfc5e6ccd5f574b7ae7a6a0448f08245f152ae74139d4acfcb3da687c2a2914427d764615f90d6d90999be4e349554275fc1cabf03511f7cf3525e45f71eb447f40b7dc3b52518fd1a63063efe94f8220d444c682d361631a324ec3ff3e5d4bd188b02b5d135e32f9f6e8630899f9ebfade0d57916401ef5b5b818311144d22139bd44adeec93824b62966ae1f4abd9a1f7c5276fcfb6f717792ab724bcf465e0fc7da2efe4c8512b3c8719d707a4c40bebda186025dedd2c0ed53e88b0f1520ee47c18424f6537ffc1ca5cbb3e397dc148ba1fb9799196beaa2f95fcca634e472d42fabd3c76070344a0aa47f08f22b1034384165db6939a216e5fbd14839ee82d97908c77a9aca3157a4a0e6e0382193375c2707f60574d5ce0db8e11f6b340dce39c295f50163d75a4d022c943aaa919935196bc3b24faff643cf1b51c0a0c0433b8169a938b4492168ae9479d65371de824c04997f663443e8c4c65c92ba1957158cc377c7351733388c57ff494763639ff46e353c60b2e57d1d9d873449c7de1e5eb00907b174ed18d4f65375340eeefc5d5c2a99d726274a87f211cb9a687510840403596b8c9caf59b8e41c6b4289515fe15aec33af11b084d6c05653bb5c06678abe6297315555c805d38022b90e84c1d80331b67d8fa8e8859161328dcc84a443adbe5fd0438897878774f8b399f090a560771b0118ef5fac7263c64e1f44a8e96a04cd5e66e4818aa795fb0ae740ab8cdb4491f25480e733ee24246cc8c3ce11195ad5f9cc20497e40ed597c52562371eb758a578052172f7680d7702afa57a51835669480413f5e34e98ac8741162a47ecf477665595fa58e8d1c2efa28f334702e5b88302f9f6223aa5cf4e2ca21ef2a0ddd6e786eb114d47b178c80b7482d879953eb86f2d9fc254aedf2bda87202647cc9477146934c0d1e25768610a6c522ab19471f88a325eb58c9c2660cc439ee1784c1d09495f799a5c6064836ce2af4caa5f081c9ce9c4571f2116536a7614c4ce7145cedf7cef050925d4fb3b949cd2f31ea0201c901df35a3446ccf31d55f8d6b599bfefbb598406b638755e77f7875810cb8981b4a3d8f402b96b2532171e2cc30d27d50e9e276f13a71a86e5525d5b8d9058c357550f028917f7e383a9a4e0a4fefec3954f090d0cff7dc343bf6ff9a37676aecaaf0fdd16220efc1b7455c88d16b29813786a386c451d20f02fee91dc58953d4f614ded3c9bb3c55e3bba95a7fca69b3fad8e49cbe3e3b0b95907df5329bb332e799db3de8ad4e3b789d29254e4f6b004b567a09df97d94ed140c3182e459fbe2db3386dc719673a0fe552264ee93e6972b3811495d46c028828dd4ed42e81fa641762a4744bf3b4541fbf0e0f877f27211318d08e417fddafe7b59ed0c06fc7c5c4394383840d5894ee0742159b58b424e9fa4c60d027c242d4a792682172d488190b491127c81c5e815e65c5b40b8b21e1c7566b93f22893a6291c027174768cd15bdf1b8c6d2efe66f352eb266348c92f23e7bbc3988fe0eda7983b2b4ece5ac019afdf6bf9d230d1eb9b1be10b02e4eb290c1fb83a66b9f22d2cea883537f8f134d51507f0ebb160f3fea5555facfe2161f4e4b1e7987afa517a0d2a63fe2cd77c50535d9002c5f8bb9c263e328dad1a57e327fe2ae877dc3377d9295622466e81b0d2a04f46e38829cbd3a4dc767858ef4503c223c9c4c3140ce87c70cc2cb9e24c4e6dff9430117262733d998ea58071cd6d0f1ed5ef1e7fcb29647d20223d322786e23ebddc318d159a56ea52e49655f700f1848442c07eab1da824e5675614f994dfed8cdaf45f64afe84351b7100afb757d9774182a5369e5bab4fd1c909805bea09ba8fca9da4bf2ea864fa58f59c3048a2ddd6e221b4de095de742433d1d5763d27b0d761810b828b7b9140533291b0d2b5e4963926ede435373d49794ce3bb7a49ff6b5cf7c203f22b528ef40be379d38f1ccca2c4677ded53809e3ed7a16640d47cb71f607e57410d411b29cc1325754c9f4e9853cf56d0f9a761d72657032a6c72e630af5b674d5dbbb7712e15d9da520e5462af23b6b970ec6d5dac2abf1906bdb7a74bf97ba3f3c1be61ebe973c03e99dacd7d01f3a676341077628a5dacd61159db88dde15dd1bec4d7b18278cfad702e6fd44ace285722148f104cb3697596117ca0b6ef0f3e09d3914a0c3e424e0fde4cd4a7b71bbf690c298ea8823409049e16e7aa160e35fdbf55bf86292708db05dda9e25b801450207ae8f297274ccfd9e915f768704a521629dbb6e8c178343d19d7c588f64d0ad205a03e01f790ea314225e8d4217dcd5021ab17ab815c90f58409c647f87c47a1a1f5c162a2784e1462ae62ea81effcb2b2343d28fbaa0900e3653e772990f2cc89d130a5223aaeaad378165a9953f9900ed519b6ec02de4b54a1e235e9c38f94195445817432ad7d77406fd7077a269797798b4d28a092d8fbdafe57588559152b5255bfd3724b19f1f6f03a43c9dae0814b93d538154b99856ef8f8e991b022b920cf8e1bb31c062f68ea34fab0a93800b3a380bbb9a59d5a5dca2e1fcdd2e861f5ea52d8fc70afaef0aa3e75e74c557b6963990bfc70f5f2967178781fc23674ccc9dd8b28e4f8d12ee5a21b486e90cfaea670bc303b54fcd4d408acb0c5aef5eae1e52b2e24ceb6ca999a34d6efb956acd81f323e16ff9379631e27bb9902207bf77f96baa0fac7a77584becec6de235085240c1512ebb22366c6e454f92425104c62ffff5cab1c4c5e78aab22f7376f1a2544560b83e0c65e794e6c3b0620b8061a5902d578ee7f945344ae582b6e7cea1fa306ef2d68aa2e4c36abd2c76872d88d0c23e87f7c5cf1bb3ef22e2c6fca5a92969837d2a93bfcfaba1ee069d9033786b7f56ec35af8f1fcf5beb09368f05e4e4b89c798283930e6830d44f4070d1bed1031ede261d4c2f7411076db0b70191ad7e8d7fc29842ec07c5fb6038c7f8bb07c7fb04565693120c5994704fbec2a19b860dee83614d3f256ec235b2d76500fe86d930d4620093d5a9d0ccd3cdafbdd4dd8a6e3cd09f734a3b5c001d17c8fb0f60cd5b2832685c118f4bf6368f146bb88cfb894dd4825f8827c027c09ac39b90c7f3089e9e3b284148a38a4c38f7717a06a815d3b4d2f879bcd5223d5c7a850f3a663b2eed4399bb3c61d25354370a46873fe5857f15e66474d5426735a50f703af915286e9d8347a65311b7209137fdc83f673212abbd11a6705b6cdecbcc900f48761187bf5bbb26175156ce924b44e82466fd3fc6b0ab437f215eda5292ac2bf743e9793a74b0fcfa040659e7cf6132b51995add6acf493b9e57e9884f2312fdae81c75f7c8008cd20f3f7c5452df544da78035f9056dd467f8d2d5cd897bcc6f66cefcdae7fa4f690f874dc3ec70f4882fcd338d5401aa6b1bc2cf3b01be90f194a45606058be2390a782fff131e0b0ebef663f8cca9e7e8c76ad43f6a03509ac0ba9cb48ad79bcb5804cc3d62be0460af224c4c3ec6e6672cfe9ecb391e759c87249e12fcbad9abad011ff6434c3bf1821f0a310cdb62a9f18117837a88d4fcb81051dcb9bdd0af057e0f47b9fd3d7f3cd2e6c891409954bdc3b14a4f69857759762356bcf67b9972fda1ab80b1f9572138de2f96eb5494a48066723eb289c2c55a2029b273246266fc2629aa34f328e1186ddaf96bd946ca15cd7140c4572d293425c2f3c4f0672d7cb353692d7bb245b81a3ffc198b9585fc676771513f21f792d9193e28a616c1d1164b4ba4cd57e43feb4b23ed04eb42441734897ceb30140f1adf181e06a87acd5430e5f3b8099c708d6db2ba9783513a9d025b60dfc15bd5785403ccb58722aac183251008f24c4554f58679a9158d80ce00b4df017f0b0c4a085a10b0e48f79c5da87fb61e22f89792671f920c50fcc916f141a44a7a0eaf6daef7c3206f1ce185e5f724d7222a4eb51e284cbd1fd870f577f8d9982b86cd75d216d7d363ca36823aefff76d984a4c071394e0f1ee6286078e3fca7efc6fceb6aade24bae2b58567c41cdf7a738d450be23cbdcda1311f5b59895c4292dec56cf5998032a0c9b6d664620583f6992f032c3482909e49981bac9a765fdbfb7f3a7974abe8fe84e4c69511fcaab5591e2efa633ad51c7c2e47abd035dbfad408e0020f4ccd9b5dce3a1db4ba63b23c2b488d6c3ee60279c77eeea9223c2ecaaf8876f4761abaead80cfbb214019e4d259a8728eddccaf890a6b7de7b693e230ed0ce538af3744775f68b7d1327f2beee4660a434db2bf1ed57241fa624a5ab402cadf64560a394bf832fae8c56c429ca18ac362af3c1e8a1a6b756ce6d9e6ebc865e515acbe42966bdddb546b53cfe55c8307040ca6a1608ce6c5ac07c3a4236d51bb4829f405eb5f5345957f9c7cc4af050b66f0ec6594102b1464ad2334d42582926607ea5a3dffe21a64edd044eae8de6b741d8d2bb03c81b4afae937dc297f5ba3936081ce7f90efb8ab4e258d41a1cddda9c822295fccaa6ea5b3bc6910b3bd8fc7c54b605f6e3c93700dffeefe02afb9402e120f97eab07197131bf56f57e9f98b596b9c5b6b6e698fbf2ae795c1c1b47f8335f2fc9a5c496cbd0d403627269b02c527570cf9f251136496940ebfc581c53f78528bbd3ecbce2367def9d81343a7da3b891fd2b0e1e22be0fa62a6d7941572468b8d25663d537b902b22118bf6c5bbb96f4c2960ac8079b56252413021e922f2f7f72f612e3a07cc94b294cf298ce15a95e0f5866cea1e72c0a6523632e45f2e05f9329fd589641bfefcfbd2793a805b0fd99d2205ebbe2aa0c28b57e48cc9dbafbf55901596cc6e6226b115ae40674f79adca8e5aa42d7f52c9d38597103891edc305350776a62c2245e0005487e113ddb19150a85b6fab6027a38a11bb060ec7413bba3008720633c4f4eda56a5596a4977d3187374e55e4b5f7ff05f4f849bf763dc63cba4513e82f5f69866535c8e89f7beaa681fd92081cdafee8552f683323267f817629e00a5470dfbbb02965b633a30fffea901c61edf41c67311591b433460865112a0aab8002231232a81f03538af9a604965b6dcd21be87136daed12d1f2e4c59460dd2e361ea0c923d627b617998e0ba4ff9a83a08c6161aa46d6ac784022cc29703b37e1679c1e2b8721bf585039e3bfd98438da3734a5aa66c3b2aff296628aafca656a07919abf621595f54fcb80dc04f58956763c5799646ff8d08a8aabfe7894515a722bd437a49a37550a88ee50cae96134548af4d7417cb75e18fabd1dea9938e01f9cfc5f5a0c8c07fd6d7cafed88f11a94e1abd26b4dd641e12c75e00d085c62ca82fa9743dea3a5ab4b3e47cd65ae838425c10ae11c7eaa9c59ad8d3cab2bf565b8d8a09b419961600cf682fed1175c88480cd9fe5fe6d186c8b44a58a3f51e2b7ae82b7a75b1843f7f0b575019c12db9eadfd9104f33b2733db1ed5b6f85ab46fa5efccbac42889d58315f885af4306409f5e188f70d03cce0fcd363fe663d6bb1abf58ed6c3c8148c6247c963641d369201755247d87619c30727844320f442354282f9d925b03553bd7a1a7ea8a90f742256b80d5244efb17ee03fb48a6cf70c66bcb8fc061e07ee98595d1a82feb73d089d631c56de2ba855481e316a97fd950813843a2838745a2c3af21a46eb756d29886099b5b62b1b0a4e174511b626e956de6ce7046c873c4faa7747624618919e6cc993c79ebfb7b4c6c3ae12d038baef82419be3bac47a35892fcb276ad5e4753756bd11dafc93b616e4896016e3c69e456d3c7f84c985b4c19246163f7c2fa169f838cd3092307ce37fde972523403407d72d0223850a3755221b566475f3569af8e74f13f4d4e7dc1aa0ff724665d5e557584ab7da901fefe5d8b74521c08d0eff42f75a5617e1353b9c6083020ab48af2238cfa5da0ae978a4ed2e68bc74efe99c1a97d9a7c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
