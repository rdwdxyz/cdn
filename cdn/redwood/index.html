<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9cc59afacef1504a4adcd9a81c4cb6b36728f5d93b94c4d752d1733578557fe7d0d1a8a9d61cc74b5101d0c00381abe351ebb7c4895712c0cbef3955cfb188159e9431e991093efdfa2e8760e788444a6afa1596d1af5fd6b659890584de1ee0f095ed3853af33822b947ecd11c9021555eda4d43405f3901ac8929cc41b5a9fc3c3b3c4ad8fac3bd57062e2c26219e7c5ab633adca53a054987a9fa331a802388679fa8d37e05c094e7c2e667f8565d7337527b1cfa4c0e36dc66e07b1e2c1c4647e83d3f464557cfad1d06c2499f3268ad896b704f1635ea7f900643461e8131c48113c3f5288bf75110f8e05514093be410691fcd10d9c7d9d4c62eed536c728521938c0f2e147d4b8633c7eacda5ec3ebf1506da6f72320d6c4528e45daf566ecd3d598732cb90e5830acfb5d883e7fa44aaf52069f26355ab7e7c1c75282dfb9a4367f7d7c3052bd3e996e2e9e1b53d0d28bcbf3579fcb46d8f07dcf0242258f51d58e6681f3cd1a1075e5017d3980cf886a9c74188b4c8affd8581b34966011e81ae38d2e20abdfac32edba242b5e715816a6d611961cd23d55491a745a95940453d8cdfd5775a69d18c5f2d192ce09619bbd66a2a9eab9fc4109415f9cd0a1b921667ec53637ceae2ca4d5a70dcb0920e77597e0d190ce7530a6ab20aa5d1f47d3c5e658f431f19d38c1a01e26db09535d7966e1e307a586fae6d1e4780d4ea0c4f5d7de49f2153612402aa4789d878ee9d08b6484c5863b8684ac1df9e523d8f14f343efa8f6c10a622940405795c422faedb318859748a026d4d9b7bcd38731c6a9e2a6641e77044e859e94c30f681afb18e5e6c1fc62476791d91e31c98ca85144107fb3ee0dc92ca00176fd900db52fece7ddfff9ab9137589681f8cb65eefa0e3598222f701578d8ad0808f394b0e4360cea1bbb881bef4441b611848e3f6d1974f42f35dad949e49daedfb1be347e76679e07b7a810f31b52f5c4db3712377ef284bada2658e15ae93796843d6217258d64c1a0ba80c54b38ab14d974005fcbaca5321a116ea20d31e055f4a3c1d23a5ba734e1efd9c4282bd0c8b5fa72ddc010ee43d55afd8c48265c2f112b594e1590216623aebc4e6a417f7367f4ad58b39011161bac8d252eed3aaa84c264483072bf4beaaeb927c4a9d0d2135315a36f1ed003b5758062c28f82d9df2a30b96e3d3ccf98775e95c56bd350899a4be0dcbae5439458f87e997686d98aa90ba268aebcae407ccd96fc72366652dd0cbe5ec100f87093086ea337b9aea20dbcd7aab503ad6eda1aa925214e429c83c12d8b6994117f8ddaf0a337c108a7ef4422a5d402d1bc4a5d1208f0988fe9913129177d80cf1514426200bd85da79f1c65ca451b48a47cc4c13a3d953cc298670b8ae152207871eb255f3ce09c45f7a9bb437772749f908ca2f2b08093e4dc7363bf3161756f8ff2f79d64d2c01d9fd4213ee593a30db7f5e49996be1fa1128af6c6af2d6686f881ce0a2dada25a403df3d46f54b4e2d898290d1b4dc44ea2adb865f10980cd1d9ce44db4dad43708fb0d0badd98de8b5cc5c99914b7b89b91ba373e9dd7296fa985f6f081e45cdb51ea1b7e192542ab9535dc04aeb0d0c2706647dc037995a08707039a5b2022ffa7f6121310da7a77d421034953ccb1b40a5c9a7e7ee6d9f97e0df482d5223fbcf1da111a14fc8424bfbfba762023af9fddd6b7a2c78b19cb603b062ba94d565c5281fc49783ac711647421c5b405e0125228104580fd97db536b6aacf3de2b069426d06eafd94d4bd2743bcaf6c5b40fafe83800b8c70ed2adfab7f3f3454d8b570889e61cf91a0501d40d4019f2188dc68da05d3c11222250b692b0faeb01932e58d7de9ae83bca7046214c6b87858ef28f982619bbace7e88a7389977bab451e4f5b4b81a227a18083004ad1bbfe4c2c195fed81f0a1ccc55422ac80e362179fe2ed00eb7fe818591efe32f0abfa505015a31c44160973090ef5ea598117818491d0465c843f9467e26e45cbd2331d7961329fcf1659cafd8e5a49c82455e2cdcbc73f9253f21b5a03dbf9feebb94cc364eac0d1798314f6339096c7cc942513545fedc5fb101b7ed311586135b0cf763899f30f9ceda74bc563ba1c10b8878adda9c00fbedf7a14a4c394d0944938d275c82db28ac168ebd4199949c67a5bfcfe3d80fd0f9bfc5dfb13989c53376458b3dc739c54ed59e1a7367b967beb86861da2a20ca6b4b1e88860d09fae8e31036e093cb225f7c1fb3c9b6d76699bb325b58090bd6e778e34997bee21c44021a47c87a060b4688e26a593aa03da56a757a85985028e6b2b6da8be32cce06b5eff8eb49b61c17164118da464cac3a66076c94846b779831586a03916863956da3b52c3b3a63d8cf80dbb40ea8065ae5511292ebbd3ae13f7d9321bd352dbad0cec11aa9525460583df57933dd7a9e6ea15d8fa149311390238ab36a3c6e5d0dea7ac47daa268f1d4ef0a0cb86adeb8fe7835910b8f6ef0d2ba5c1d873c42b290cf7fb78773ef04f77532f728b5899b5db4d674b6987ac882637ca2074658e2a8d8c7eb96395315926bb99bb895e5fc8d7428292f99b5ed799947f8ab154fa3a76bd8a71c17c900e8e7a065ea02e82410d57f08b0ca9a00a63d8f29a8d10f08fca486754b19b4792d42a2b87777a15088bbda453811454d28df2c05c70916b9eb387c0703ac2f38729acf6ea6c5155897c412c37fdf09455f5bfea1aab80f9f3c19b9f419d8a3ecd28f5de9637c15e699cecc59522d791ab5457e124d66cf7e664943ecefef05ff62ed2ae50f18380c7fa0ddd75eb3a7318daacbc212c2b87b3c1b6f57c0e5c895c3459249dddd9db7655abfc21de80ae554690741eff47f45e20f59351aa97a483ba7dee05f946700a9b574b6306a170ee667fcfd3af76af4b2790792346e64f87f8cf0affc8ac2ebc7212fda8ea1a275679ddd79ed652bb243b8dbb4603ba995630b83788a66b15056e7e82b9064f2c66cd8456684ddb5f2f23f13453ec5a411c2a3485ba2d36c0f6d7def8ae218337ea135238f38d64cf12014aaefda7ebbbb0772eee0f416da66b99967c4f416e5a50c66404d3781709d75074ceba0fe9d07577ad85c7899756bc49b788af70ff70800319fd510cb4140b72df77abb4db32a26d8223aaeb810f0e2500487e024bef84252cee73caed26f4d82ea1482db358b1d8ed304dfa419c645d2081102465773c707508b7bbd59336037fbf23a67424984ea4083aeeea7790d335d77ccf4fdc38dcf29b38a95c2ccec926047377e25dc04bfedbe3094f29d8e2ae4a1bf81cecfa55ee5e09adc21dddf6b1da03395bc3f6c7e9febf92d4f5e052613c4c1eb52292ac971e398696669977c5ffb6812fa6c3d852d935450002fa8509084f0132d5e945091bfc538dea962199e857512a6605a0d2a444c1c5bddeffea5d3a044b0282433eb17ff9edf50d29d69e55e4cb98c5158cd3a79315b3edfe3a3b6c7e890643d6adf69089a555b6a5fa3c5daf1876d3527574dcb2310557d9ca2c673f038551c78a1ae21df40e5d760ecb9887bdd4933afd40f933aa933f8339e4b16f58c919a89172faf617f8e479d629ba82cf27064ea4f296d8f42ab1f49e605f5adc52b23e6f098789c2a166bfd7c0db51d92ad45c9cc276e7cf898c1245bf853d2705192bbbc2e8674fa724ee40dbf88a90158a320e5d1decd66729cffdf6d142ea96f5967503246d0f52c6d2c18852f6e44b32a73fb40afc25e51a57687d51992063ee2da9bb3d3087daf8bab433671c73896260379eac27a26ffff49687917b245e15d93db8f33051878303558cbf6be2a92b34d581f44f24fb462f47ea1a6896d6ca0ba34d50fef860f5c2ee3dab5097f3004f294d4f8fba77d86cc61ae5e243a1745d0b7c91057b2fd860f8d47384948d1fd25239afcf56f48de8b7a934a886873ae0ccef3afb79a73180e5e2bec8170635b595e7d93a1a5d4ef2400cb85e9e887f37248cafc4c60aadbdac80ac9f309434cac249ee30af3a361a38d2c1277bdb8f822924d3d9ee91cf43721c5a6debbf7e6d7a5923f0c82f2684803928d8eea38ddfaae41c13e721f1d4e60cf0281e679f4d1005960967358c0a191fd577dbe3cbf8a73919418833f8e60dd78d7f8a7a59155650092ca7be11682e17947a7c4bc9fb2421afa2219f2d6812a0aa081db268c1bda913eefee6aa93e9e1d84ec658c30e63473379a808c4827548806de7399e852a60f058b70c4e090f9f8b0ce8fe927c8014baa4a98c182a97249e21be443b9b4baacac9f9a1ff60af127b34531e159bb29b60d808839f682ec0f49f3a4a77a33fcd0a11fc8889d0e5040847b100d3ff84540c7f9c00063051d67488059b09a87eaa8262930af0d647ab49d61beb3613bfd47924b130745cc57c7c7e736255811ee37b9594059a153d85461511f491902483f1757e1a2bd19af664053c83f798b2d462dbf679e2d554a81e5b24dbbb2a1d68246d2ed7a0954846f456ef3ce1c8952e07b1d91618747eeeef2ebe7b79befdacedb8dd9f6375924ce6d7410472da0d04388b40789afe8bdd4c05aacc7c995e854079cca5e2bcd1f98aa7684131a43aefdec42839d4e49e97802d1b32af292f1d9056cbc70d68df3eabeb19fb16f76da2c8fe325f3727c52aeaf740e2a568787d7c7f4e2ba653847bead12ed0b2e3d438f903ed473c084f2c0b3c47ddae63e31a7e211adca80e3ff40e395f3d88d880a9cd898233777bb536014fd703005b2bd940b7e3812ae0e5283e3815bc168ef1a3c261f9b25bf8438708b2e7db2f0e6345ff5ff889dfe2f5f2fd6a132116602598a8e7eb0c7afd518f0bd116c32fee671dbf9465bfcbd4e33b1f076bf9bd85bc1d73f5d86be985ebc6f809888429d43e8025d2f44a3b848d3d4e435fc68ba65aa473b73023b77fd5e61553ffeb6f8887d215a55a352a777fe485314a149520b7bab1a1089eed34878c009766d29b3c522f8bbd3f77ca6c4c96e41495981851cb8f1d8c9c37bb7961ebfab6a72416ff76290836a26d7d8878498c28380bf9c44aef200f50dec8458ed1e253aa0d34acdbed5d09fcb9d18bc2dddd10881929cb9494bd1f954c473c12328f0032902be7245dd6206157052a73c47c6fa0b87979e3a1d0465a5b19fa8affa56f1d58a4c6aba0623f23f118eb4292e2e2624772ff8a397fb2b525030775ae9107b1a6b59ed21923b75aae78c98b6c9ddb045e086b368fdd17a1a097867084bd5c6c43453f75b72cdbbd2ab64f8b3f2c69aa9d684bd8b652f271651a3a13dd3acbd77b3c226e2dad08fca845a47420180f0527681a5c6ce01d1830c5ea1d0cc4853c225927bd9e7eb9447b6c16993e4aceb7a19c9903b85344f2ba68d245fbfee9233be2d302a99d375f15db7b939a44bd75ec40862b0fb1787a245a3cdc26f34b6c5d30ad1bd03aa9ea332d1d56b77f9afd6705dab736f9b0faa8874d898071ab0cef0ceb97b06f05596c0dbbfafcaa1471243cf65495269981bec72de32a90edcb09119186ac4fee1ef49a32442218a3a1b7c9f3fe652b8dd977dd67e82f9622edd65072229a3806a4928e9c0d7ce0aee8bfde469bc803eb6f4ac766d8f77b1c4ffc35ffba153559c2497be089e7587be5f3c9ceed1866503dd79b32b842d9b6cff563dab8362799d4bf011f34023244c5694d4947972b85a836230fd3edf6760765b9e4cc4f24628a55bbc93e1a868da27595c4a1f9b23a2c702bc7a3b753fe156a929d4a9412eaeb55fe3d158b064edf5a7dd8dacf34a2826b16a75cc75eee5a1b0539f71b36d6c3dd58f146a707ac3a69a243589634334c04cb603499bcf5fd270542de56cea3b68c7b9ca68179804dce514312fd9677bfbf4c0ec795c9785670289710af2b6c643be1997d535f54fe1aba1d398e7d49cf9251678a745786cd67a1180f2e2242fa6c4ef80e7b04b6d511fd67263346b3df67f82056f909fb1f8abed57851ac0dd755c37d84fc7690877e6d681be0bc2e8f6520f4aac91d00b375fd78f345524ef3f3624d7cc85af0fa42732f5b197822c3ea8749dd84c2fb9795fd4de3388c586d589a9c11f9b4438b600cbead826439019514d468fb033b542eb6c6ccbcb5602778427f8f391ad4b0a67afc5f8f954e5fc5dd13171e10e0312fac8e93bee588bf6cee0b445c4f8672874ef3584924b796de69a77c74b11ca99a5fd13da3157ebc52f4ce67f6a0dc89f066e2149caaaee87658a4c786cc5ce62e7a8ee319e99e0931cad731a25fdf80b8ac10c5f6e3929c7e27d80330609a76d7b056ae247ca331aaaa05cc6d3ee0849643ae01525ccdddf08a06f5f12fe5d41946038e63391404b50087dfa0c3134f71c211aa30bb6cc98e8d561691a5efbaeb15e54ad1eec12de62948a80638b4f3cb763c68cc38f083cae3a5ec95b41a33dbb954bacebe70d4cb5a32aa97f3e11808f5b8ad2699036865d79b6d458bcfb26c87df8b77573e4b6b3005261754cc115974b07a839f472cb4420011fc47bc3641f82dacd713e8f2b20f5320a4b55bd4a77d6edc45f68008f43b89f875abf92f24ab945cde1eb85a42a3a426763348fe306ef8089db0627655517a7e5e578008ba854fcc7ef8a7fc8463cbb7829c41725e19929ea9ea67a4b9a7d4d7d3215e7789489f96d23a63d3a598a9a94ceb1c12b39b5218fd2534f7998c32c5f0b25a216045bd44ff4b75e1b14a0cf7967fe3561dcadaabb1b8cebbc2ec9a8d9753e14beb9e061703b8916b705b4cf3f202f2d8298a939cdcbfab9a530a40eb7a1afa3145325f310a616cde02c9b92407dc29238df8aa10513ac216a67a04337ff131691b33f35a54f7263b7d9219ca6ae08ba64542e1f5c7a05459dc87c64f49d446e55283bbf8a828f06aafdabed6093c77d58545aadf23952cfb6a445d3c7526e86ac1564a80440813ae8110c4ce2505a87d1ac3fd6d49eafb6068bda5f38ddd1df965f7a1aabc0810749458ac2433a656269603ba1573a6570fff46cad16b634b14143db4324fb92c13c2363dfdfa8bb4c3744136209702a87c10ed3831e471a7f70c5e19c34383e4115b7bfe946dcd5c4f4a0e1cfdf8ed085c559c9b84ef3c25057eddb4378bb620b98c8615c3830c63996f00f2cf7e3b22294730bafcc40a22ebaa354d495ba75935b50a5f1f5362d8a23dc17e389036667ad86595e9043402240f03b7d0de0788d28deaf03f28b966d83fc2282d240a52fe45992471914221a0cd0930f4cb7b207f891457c05045672d79794a4e2712ed649cf7675d1996f9507234f61b7fa16b5c68180719d54f5148aba9530ec4547b91a2dd45efd0dbc52508425f30b5e8d84c6f641ff09e1a3023277069905f1b6459d5165acccf3764a0506314489bd7168e2e22700273517de9ec15036b3dbb9f27f57403dce8adf50d787b5943c0bac8d14319598286f6659491a1a7bdf8894cb68a750d79d7b6cd8bff524e1dbbaab6399a1c155206ae5e7b8f20885e0ccaa794becd20432a574790dfaaa039894c338c8883abdc1428b9a8e08409c3403a94a1a2648449dcace3f618f4be7e41e9b97d940481ab8fa235751ee1c030fcb2cfaaad3685a5dea7bdc61b9420c97ce52097433c3193f19dc3bbee26f216aacc8f5b61a4ea21b4edab7e8e7a84af1f99ce4fd2e914bee2b3f107cef4411cdea93f91269129e669794d4bdf9cd7bcf0cbc13963fc079a50bea842b5f7975b0cfaedd52e21044c56113d4e67db1c98aa6a3eec7ee07a0e77c50e57b3cf2162fc0173f69336305017969b6eb55ad9b10fb5c284eedef8eee365cb745e61dd998747d95440b33f8e4a5537f1ccabe8cd133e435ed2329345cb67b705d6c0ad8146c12f11c4657c8ab89c26a154ed8cb246af46fe2e5932c424df1f3e7ae1a2a77c78af699a4a62550aadefb53d9717c9b898bc485639c571609ff1861703d38ba670149d3d684cd4bab4cbfe5fcd6f0fb1d13b6efd46acccc9597dd3b2f08123893429489315914e0e01ea4dbd2d9ad01de4f3c98886ca819b6c830f7114ebcf15e5d9a761a1079c891ac4ba65504722fa8eb7e5952556ecc397fdc5b8b9dc1d09d2c877f3dab33d1ab37df1c23500cfd671f525d5245715b0196dec444b4ae1ffd6277a306a3590351402ce1602b15f1ca99484b06ee7ff5b5eaa27be585283052642e09f18c8fde2f1b049867ffc73a3566a367ae389d98f45eb81fb4171ce7d07e923b54af4c323048c641697ca6a061d2f9f1ecbd42b46a53f89dba0986348712ce6d449435a47d6381b74d7d83006abc869c2efad0095f73ed1c7add833533e38ee9b106d0ef059a08f242637f2f0a0e54de1c2acbc1224c2c2979b62d13fbdb133f7c25d7057b6bb3738b0da9f53a114fc5cb143767b410e61ff1fa6561f4ba9d3d4b655cabdceef1abdf3de9b08a1f027c4f839c2d568d238a5b3a0a4adef986d117d8d4eadfb1e1dbed856ea99915afbabf79a975a00740368744788226f6945664bccdfc675150e3029d862051627622576052757b6e081c67e7b5b78e0f55b770a4a2301390dbc1195cb938a00cb26a22b0517ac179b8e7b7ab2f53537fc155ea1a35c6da1a0a8c54bdf04cea6d479316ca44498c1fc13617e3cf4d0b156092ca05c1e67df92856d146fed7f87d182f793df5e8985226b3d68128f1ccd0db781bb80f54ceb2c0f682d3fa1382e3eb800201c1f718f784531c4d14a51732676080b0e6e5a83c4a658565b0060a7b7a94b799e1ae4d48c30c3a3e4ff5a5d3ea402caa48f5d9b47652d9c465dd14c2648c37386766ddbd59a6297fe7e88f5f4f485fecc3016e69584f453624462fb9be7547443eccb8c28b60a7097448881ccfab824aefb829c15b3241023aac07abb8be8e25611eacf17ad167e481dfd4e82cce81828a8a9fd14a63002d94ee86ee3238d0655adc14d36acd9b145e65f57de4473ab8a0a4b047bb419bebf7f05d9782c4327a83c69624e561abf95e64c0b634ead382a6d49e133db96ba1b8ec709b9c5e320b06ec81e46e682d35e210a18b268f8badb8596aa09471c3469f57df8aa45317d2e491b17f9ed4e34519c60412db19b55fddc4dae588569e8a91429823f43e3c3ad27a554e3bb7bbfd381b7233786662bf333306aec28fdf4ac5b1399b315a04c217d22c9453698c0fdb7449b8ec79c1f7ff4c9f5bc95032195d7c3c744a02372064a62b8993952695e9df94fb1355b41ee450881623b122adf6813f4f77afc0350217071e1db62da391a4c2b0a6961e3759c18ab2b45d7f105d0538cff3ee268c87c95bbab5857867f38c7bb65ce7ccf3ce9a047124da67af71ad2b363883b024ddc97e70431dd291769340ef0cef5432034dcbe881f19aba9b2c0167a5fe2505f6d2ecc04f15502618958755edc303c2431a633b4df95428eabcfaa05380c3724cd2b41cb15ca3952f285732bd7d958b681f83e20de3ae3cfaa60e2122dfb3b096509a6eef546fd6e86586e2636dfacdd4342eef017bc7bb58c8298fca98841b3291c7aa7a3790def1221ab5dc6ac9ace53f8cce3b98395d139a941f78bc2a10339700ac6d665f578a873b4aee50c0b0c7e8e813d042318270d6a83e57984abff8d257d086acf4e8d05514d0e862c50a267da8342623417f83f5981375055cbd442ab16585872c1aaefead32b84f387790241f6680bc71c3fde00a992e51a283ef4d2f3e7153ad8c6afc3ecd9ebcd03372642619f436f770be5592f7e065e6dc5c76d079ba4441896891090f4169ac6f67dad796f79b8e922dd46d9d8929758c30b2ea03c030526496bc5be7a21c83430349f4228ad5515438c1aa257203c41a47f7d98793acb09c9ac00cce4b63fe199491d740804041b4d5d442c649a6d1e730be71dcda4dd89a2434b1d27d5d02d587ad6f848f0e311f54f011232676816ed3e830acc3f4ee669f291a0c7c0b657402fd97188a04eec5115894593d16de92ec8c173da7be80faa77c7115eaf3ff746dd2a0b800e280ac1d025fbabbf683cf887d1b8d6d743f9e4f32af3fe7b6e7bc3f6f5541b5850c239e1c40834ccff2355dd225b69e81f3f3cdc56febc125761712e05e3961dce44217336ee4c61186264e2f48b13bf16d869ae89369946ce7751b63847bf0e2348e08ec8b187d817a1541d7559e27e0246bab95dac6b69e5e36db497334f2b7d2ec5928af7022a18737a3fb0616470a23cee65bcc08ef74a2799fb103e7b5ed00a8bb1625aafb44b3567477764f7396fcac380a2afe4372205094cbbfba1c1ea3430a33104b2985234cf140a3bb2a9dcbb8fbe1402611c617b2dc717b9f73ca3c58fefe77bec6b1a0483c55445fdccd5a92b39b3a53dafe9d62af3a0ee29a59885501c520995c6cdef68ad1f7b6ff5cd0a079e018373c5e873dcdf894889af46c0372a82aa4eced5c50b7a4e6f75fd7d5e5154184f8cf9262f4f4e255f1ad9446e9ec9d5c43ddd574b6143c1e3dad35c0d2d7ff805a25623dfc3c4a75ff61b23c26504f24bbe8c7e63d753f11aeb0164df6ae3a61eceab0870463774892adc4b76395e82066586faa104f2409d1c48169f8c79aef8c4ebcf3a398d432ed4e53babd5f84b72bf94820eda6d8ea011afb1e61401b160e400b17a6c4a04bd5594940fce081cdf6856cc7c4026fa43a8806fe22960e08128cabeb03240d04b7bf50a46c1fe309308cc1bd4e85b9751aaffc1cd01396512797ca242a0fb33f67aa663c4e660811edd9c17fb11f4161897690cb5c92fb1ecec92649b5bc3d04eed4c7509c55c607c82828d070e4fd282f55ed2fc008e27141710e18ca7eb5a5ae6019c1d58e95a0cce88780fbf9f186555994a42cd84a569597dcdd2512c7eb57b149ca4a1ea5642b19641d37fb2babff89c28af037d29f9b1ad86a3f3760408525bd19c0055805ab8321051bcbb5e79a21040133e466e1459948f7327eed013f2ebe415b76fc96075d66b41df6307efc6eefdfdfdd9307f5d3c40c26e51669c15bf8f9221fa640c5e2a71b50fb1d9b5c1a1f647f5efe44679db656898d016d556534cce27e3d17d2fd5d256afd02a997d1340b5fb39b64343e9ace1f24854b52f53263ef869b308add8483cda9f7b272781ed88343426d0d6f3398f10005ef5d69409c14af2e255a2d942593b92f72efb9b5e68f4b763b3da4ccadbb3f2ff7280b26db9a8df57b98a74ad0bbaf84c39b069d9f943474e5b992e7d7070957c236376a6537e4631ed7f93a7765108554ab49e2daf6bccbd31adcd6d37eaa26561a9345329749cb903980af296b224bc9a4a0a2a0157e18b39a64e98e85adae15924c2adb327ea6560e1dec51ede6a2f89741ac5deaa3e252cbcb01a13dd00fa6b8c6dc83e4c2fe90bd6dfd369a3578df7ecfe966e6f4ebdeb9440bb9c12539fb6c4b90558be80512c8fe653df0fc4c2a2fbd1aa70fa0fa7e4747d266ccf6f75426fe9cd7bf35d53436c932110d2c0a9e5176bfb6833f323541869ca524a9399b031587bc57c3e5c9afe3be4f31d45bc73c7aca05fb1f9e707552f475fe1f7c7bb10c068fa8929f31349f5a5546d3bfd72cebd799152663a19ef7a5954ef7ad35cf0ecfdadbde810d3a48dfa162f6b5f96942de556c5451dcd8e1156e562f1e68cc5a50e1e86be2d167d9760f5a0be4462e2f2062c41730cf313f5f1ec11c78409ab98e4c75615196d0858465a610c526424ba947831f7b60bb732855a2fedb8a55be7a597d1c085969c19d9be7344522af9830a084787bc7cb71d87276941005c6bcbb5d31849aafeafb8b727fcd4285206b633254fb435a46699d9af0ccab7fba346aa89a0d0f74e12567611720e1b7b920444bb21a66669ee466acadcea8385925b5d31ce542218ebe85341efefbe8ba16f390d5577f270c89334a04733aebe224c469089bb40a03a60c2161fc88b835a90f9f8b13c70419263947e3aa28ea86ba1736095f5df18eb35141b72148d6a1f471c86692591d78614e138da53dd41be030d7634de7e7ea09cf49e46b32e6dd40de92a0e3bb072462a7a0638d7af0ce411460d3120029114bc99a3071ad0536e276014c9c18c5ab99f202f708649e94fd0263ada67f23c80e442f475d85a7363dfca2713194864ac11acacd72cc570ae68975ac37aaec7d4efe8c8cb849f126388600d5f6042c0b10d443ffadf145583697fbea4119a68f9c0b8564459a8cb847c538780e0f2beba27a18a7000653e0f9dd17a3e8656d6fda61c1352a974c395bb538f96115dc1df9243cfecdf62a84070df2f971380cac309c97d04beed8b19490b6f8ee123a5db9a90ad34d3dd1ff369764b2b4c14b18eeb4574c72777249c1a265b8cb6c76a7686d5ad25e514dce5fcf0440485ebaa62aa1797a7f6122e7e92d09028d2307c6ddecd4e9fb3756eb832de179dd3258c4b7f5a855d5fb98fbf6031c6e7bb2a2a6c46409c9002d255bb0856051885a3a6713e056b332d0cd222f3a7022b04423ad4620a779aaf8bb61f706f353953251827a53fb29cc28f02206d0ecd9060fedffbd514102dc490dee7279d987d456cf1031a3dc2fd0ff8bfef32739119cdc659994b7bbd70a0e15eb83392ff14eabc06f8f60c78d14230123f1942f90564c20383c730b474c98045ae0d82a0139e04e49f467906618840a1aa9e3048c20e164e771f497849302912ec48d9febe3953300b573a0dc2282eab4f6ea7d510a9799abee41fae8b72086b08905b707e68ede7ba94a0eaee3dc2c3e1233a75f95250949d4b134424f5b88ed29979985812bf5188e4443e978915bee797338226f967d2c2c9954556a01a6429a5d353140991442b313a017fcc5e55edc17741119facb55f6551d6d1067b61a538f8db5f29e6c5adde3c2c43ee353c72dc55f99cfb981e1974d2dfaa689c3c8817babd4c02e3ade92e35ee192c655d7efe0ab5d7aa68c5025443329ecd5eb7fe6ddde71131169610eec0c535d2434741d92381a26b6b94fc5504e7a888cd0c0c973d6e11a5bf290035303d9be85b7b030fb215b9d7f4b9b6408a60a9bcd4e727a30043da8c596ce9ce193fce1a7c82e0584023f02dfae9bf6e261434a5817ae8ddba9c48178c31dde626708da5dfcf5807d57579f1be8a198b2a561f8b0df8d333f6a2c8440d933298e2f019636172d23b9fae37dc4f7ae83fd5fdc4338aa75f98e4fb5bf314d585bcd204696a17194c7959bf81d77d5cf494ef89c57733cc8d504bab70d8128ac542e9c1400e4fd49cd93290ccaefaab11b6859e903f983581937a070ea798c24dc2349abf46acec94293a80ef67bffac683359cc7946b3a6582eca072f9f55afd642758b39a724575bcffc5ecb56a18e3f236e8f78de01c8405c044cc508d62bcb1c580113671f88bb3c2e769c2dec2ceda5c73a807614774fec25f2490405ccb67fb506473407c70ed003ef8a39812f1dba2868f748b811554d2c68ae7220383e3364d1f821dccb01d5a6f2b5fa285343262dfb43a73c98a9008dacd744dfb255aeb31217d64f59be8b991fee9de96fd1e21a6462b2ea34ed664d6eaef905b93f1ddc01778ddbe48659d36c610e5ad4f46a2ff032c599af2be1c792e9c5b3ad0b051afcb36536dbc153bd5a601c1a451f67f3d8dabd5086392810a1d3a44ac35c689a59c645c52e0cb168e4166217964cd833b3118d366aefdc21ce15a33e6ba6f7e5d3220270e7668ac8c3ffda3671c4c0b3505476065791acb058d2f7b4bcb5cff7438361319ecdb7dfa20bb62e5c61339611aa2800fd1956fc9b72a1a3f0bed443e583f17fd5bbe19d3b13e666f5a9b568c7b20a961d41fae6e00147ff3ef5cb0ae8e0c156ad7303c9ef5c1b3c4c1be62669ecdf45a6cf1e30ef8dc9ff37641138c84cb129d9b3ff04965b70e50939597c9f0ce79b0b89345b61cc3ac2b0e1f82262aee44a412d37ef08aa412f21382618746f3ca075914f57c603dc06be459ee7da73e0daaecdc69473101f1ecba5b3ea0939dff14a4cf240f4e5d1797c1c311ff95805b58cd840335b82b9fc4de5a47f48674b2177bf923f79f5dd244f5ccd7ca8de29ad4af34488f21a82ec6c55a4c41258e4f6bf34241dbdc56f131473643207601fad84743fa7edaaab02abee06c3a8c29abd47e59b58b136cf0ae59266c7d97f81f522047ba0cb4491a3c67952468ae879b533ed698af3407834e8b508a5ccfcd492d9d09924b0844c923afaf3d9e912e044ce4af2b813df013902fa2733e6ce2cb22283d4ca5b05dd27afeb0bb25fe114631859a6a54d227e88807315fab9b3a9ded5e6367df4049f28844b08340aab5a119a9cf419fd03f41573c5c9bc8841b5022349572c9c67d0699e9bcfd7bdd987baecb487d71fa019b6e6f27b2d3eba15d9f9c5142cf07b49182a68468dfb1edb6bf7111c919fa1838430a0597c19674368f2ef96357a4d8dd11a4455037e634658dd25bae9ce558da550de530c185dbfa18aac622bf51025f5e55f7de6532b2bd2f61449eb9fc408863cae715983df339fc86bbefa81a0825eea25c2e04f66fcfe3361384125983ffebd05dc6384e7d149980394ed8ccacdb885405ec5f35a2420addb7d12769529c2ebd5d48656ca6387cecc5ed4c9e9f9afbfa26940f0b443e7ae3c824fb11aab58c0e4b0a9e7530634ff9c214a0a8e12ae7685713e71fad0b9d7504b5bfb88e3e5ab2b341ac0f661cd014ea2b66fe4c80a8bdd8e4f4d763a02be2a4606b6298dd37d0d81fb8cfd0908995ead903efc3869f681cdbb222bc43ffffec24c9b4e7e7a9e204b77b15484532922fcdd4ff9634140d908a79264def283e3b4e76f55750956f47581cb18961269e2c66f2641d8a62a2fa206b011d8ae0cfd841df8050c163f8e0a5f81371747e644c5e7df4ad289266faac47927cd1db6893e0394979c4514d76cfc4b5008194f43fd853715211fb424fe563a935f018f6bfc5c08c3e3a3ce3642d7ae7adbba0d09e9eabd4cfef2516e15b6b594ea68649b753d875275c932500212e5d7d8fa32e932c8c583f7f17836a6a3b2a288fd4e5104ad1f4e0c7b82926e1ce83e56173bcdb7485719189ea0aad6775203c71200b29acfefba104656d278f2bb457be945269883869d246c881616f9981d7650f62daf7804b5e733d828d41ffcd27c13740e11bb8d25c2620423f3cc6a374f3464f9b788d239d11827ab98f709ff3394c8cc95cae96b828d1d6d53ebda0ae5d03c8cbcb10c979c0b1f1571add43a9a8e03af430a948a47c1d51949e2ac918386d57b2b60e1ad15762e108eace1b76a5ad3df5e6a931072c6887e748296e5f6e3933ea805448e757bfc8659bbd72739db307411cedd963ff3c671ef15af0c1617373dc63b682cad529a60c863b796009301cf2a21a721d0ce059a62f28ba1a7bb26c65dcb0005dfcf37ab044bbcd9a2db1d9089f28ffae97dfd0effd3bb644788d38603b10da14608dd2a06724421624e3b3c682c19b16cb84115f9980cac04c995ee80e86f5e939b66b9b1e91463e2703a1ae1a016523ddb5028f11bff14c770582d6ddeef7deb128e229337ce668dd667d99a47eaedd59470387e472c0e54cd02b644e969c7e6912ba6504293ad3e3988f8896f4346d9b3eb37b8fccae484228617aefcc7a224481c8379bdc9f9b891f2abfbe3ee3a3760170705bfb140f930ca38a59cd209b984fd8a42777e3a614b36bc7c628f8591de1c55481d8f0f4dc2e9dc6c4427ae7acdb379cfeb8a184d8a241350ea143544b044206c6fb133710fd1f213aaaeb7f93e18b2e0298dd571d36804b82525af665c4fbd5f36592f8c5fc188ddb294b348d6a22009c20be74f15d5cfc6974298ff47a420b97e433b5cf5008436874926cf55d855e54af0ec3aba6e6e0c5e2c4dcafdfec995e33d5af6e49217654384c403bea0243aff0fe2761d98a47c741b5aabb9347404caa7d15c32c29629e07446e3d3d7220ef0c3479ec840733d58c6e290468469ef418561e7e59857f373170931224b9505f4c3cb5966dec3370b805c47aae1ecf077de8a10be5986434a8f864d8b66dca597ede53e1354a8a34aa82906bea72f708450e63bae76f5bc808cbb22dffd52d8dadb4877d2a3ce62f03840ca63f0832e4fbfe855bc1ec79ae3d207c3bef1798a167e4e0accf4d4f32e13c8a7ca5869fa991a7501e93071605302dd5fc94c324f8d1117c4356264e83374bd42bb717f7a79f8781f13bfe19c06e1f7f2a3a362e8220268a20eeb9aee4d112899c6faaf3e70c18d0c854f489545504d81e0e751cf95f6730dc5823c57ef21d4021d0b8ec8143162499eeed43e4b99a9e5692b8d3b37cd8998877619aa045624f7912e20f949e3e75222d32ef51ee325f711b4b8cd034d9d56773c7626eb7a6164c570651e0108520616934c83f14bfe4e2c2545d586668681f5075e85f2490e7c26a5bc90c49d8a8776db4d006a9f105721e0ca38acf66a7fa6a642c42a41f22473ec29908df93d3e75f1a2e6de1202e304fd73c982e0af4839f16c1c6f82abcbc808085bb19a9544c27d13bd07c8ef368afdd71fb3ce2172873f2d8d29e3c8b2b5feceb8ed54fb5510405d142081cd2dfb77cde037184af14513e6ea7b9279ddcdcea2512d57d2541d54de7ef4a9c14cf721022d4f027753bd00390d1cf11fb8dac4b1d9becbf313a03830e41cc1b304490eb233e59c56c2c05786538597775ebb17b00609d63c4243867b98e09062c0f5fb6579b1a34174542f6a98d90da4451bac2d1a0da3568668e41e0c8a7f0ae2e546da0e07c3789c746a3033c442871149d7d2b10d6a021118df09041283792d59aa1af29f22aaf31266680c98d4b9b6130cb7a59896373f4de0eab3cda363336972e1d634c90c207a58ce9693c10a47f55882371d795eeeac14ba3d460728b8a8090093c50da85a88a5276b062bd2f4557d61098c4e2dc646a8a940907bf556dc2e233a07ef2754a3a174ccd4e9f6cbf5405d379a9bd784cd3abec3857c6e5de150d8a65c397cd584128ca4e8784ee2293287b8bbc6907cb8b4aeff12f892c5e432375426ee2bd20bd27f9cc061ce536c84504364fe397e15363dae056a35c252d8d6b3d49660d1c5cb9136ba99deb29a8191e9d44ef566da39058e3d76730f166c195ad0d399c33b46278f4c7be2aab22a3d47b64115ff8970cd50ecfc0a9a7fd3383a00a2534e5bfa3a38f12974329c706d85173fd059edd6cd22001ccebe76e89d431afa447a4bde9ede08a29898c3e423c6d3ed294bbbdc1db562c1940bd4bf48fbfd6edf99b72547e008aa765b3bf14e30fb719c6180597f38e01ac3bd05b229b9671eb199ae3000d3fbc34d14f22e7c06baa120dffb41b89f9e6e6c5aa3f3357706c437746632f385f0e4b065abf0b213629ac36bba5594e9db838447ccee393456edf720e0931ffc1ac7c61e3664e537a2ca24783d869b0a9e01863b07ace9aa5ff37a64701c010e2eb42a1e20a6a0cdbbc8810e6b46f112e195c09abc7c7c2326f3775146ff45ed718bac05e3e16eb994a20fe155c5f3d0555f9c3b5b23f6623012f2ae4dc5c6d669e943b37c8d45d5a9b4245f63139fe6c591b2999ac1d2fd6e2b5664a987184deee0d55503c68a39327d8c35d45e91d217c085ca0f12c76e83d0d279d8b9b75c741471efbcff3baaf7b9fa99b0aea830ef80120b9efb7fba5211c25190b844b43dcd536f201087ed94d4cbb6fe3f8322249d1ee0433d6c043fbf2f38d212896ebf3f743a9d0cb500cdba4bdab1b48f4a5b5cac6b5936fe48566b033b707018e84aba1bf322dce2b96691c1ef3833260931666f537d55abd53e5ee778c9b195bbdea24208c28b7c810a077b340d7e71ec759665a553c746412b135fdc3cefac5b7495266920876a22bfff3c17ee5b6cf9062f98a79605e16f5c8f543b329e091cccbaa97b1efc48df6cebb001c1747074f79c902e89c4d19337ae1036e2b420f43c3c8f2795626183547ee08759626063f5979c99c960ab16","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
