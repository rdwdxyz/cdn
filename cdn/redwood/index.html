<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72d162c7c4bc6e98d99e440dd5e60b0638729c997d855345aa9774ecb9350ac37119802c899a37020a872c426d8c0a799d7775f577ebe6a1541f5c0975ed703108ed8bceaffa68f774737d9422755a6a22f9bc2dc5d3e1cf8d30daa6ebe478ee62fd91fa670ec8c7e15204bbce3330b6854a30cb37bf92da568f31a130d7a958ae89e9491728762d139812460b4eb6d7e5e5b44907a0070dd10a02a90f24df71f576eb9aa854b2069a0758b659d7f8bf87ac502bdc0eeb4324925f23ddcbd30cfa8e546345308cf013d0353731fbb45bf0e98767301a68386d3cc40e611d884ef6da42958e3c227928fe697c2075f54cc75dd94397b8cf9906d25671a1bd52dd31601a7f4772d1fda8aaa5a29f26544dd42f55757100433e4629dd9fddee3329cdf80f506f392d3ef492162af41a95cbe7458dd1f32867038ad2e8761a7fe7f61388371186d6fefd6e591b491a67f439c5f1500e9d1bd225bd22ce717ba6001c5cd6f480d26dec25eb8128905af85aaea7f502328ff8cc1e558cf9f5d8e40d395978b6192ad73a8685b01e2bfa654be725684483a4bdfa9bde64984b394c92c5fc8907ca1aebd7aa036efbd6bdbd84865e263407c096f4fde73c5849d6a9070b9143836dfb4e0fa3d9b1982ee8d69738218a5e5a7a7041d236966a4ce88eba06a8ecd26b1078e2cd910d2fd38f8b9409504d77bcff77ea2df828368940b782cbc8d41a02637843ccea12da2d9933a2cbb6bb15c5aced440b706901c32638a202b8ab654a439a0195768dce51c77d4e6b987294cb989714e23febc84ba8c83065690ad6287c9d18e254ac51e948df99d37745d239a6badc6c8e6dbea2918aaecb8b0d945571afde45226754b23a3db4a8d9cee633f4f9466648ec718fa02df6e3061bf0eed2d902ba9eb900255411223194a3c12ccbdd730c76c2b60b9800c742fee8c970d451f27903762700680442cce74062ddcb8e7389aeff3c7cb974f237c23168233b1c5dda700427c7fbf8293eaaf407f3a323ccb6224f501aad01834b1e24ad7c78d5170a72c9df022457d03ab639575802936be31b81b0356928a621f61fb0aca7c3ca64d5a3a53f8c83163dc9547f855ff8ff4b67d9cf0ac6ee02c6d0307a76fe7e5b0b09a6279ebeb0247bf09f59a034875279698007e465ed3c5e036bff2e0b84599cf00878f5d020e0531b85b2bc15092814bb3e43670f62866e3fa6cc41a5d77ddc82c4d6f34352d82b4d883d080ee38ce6d351c9e0f9b4657ca6fe405456a123f539fcd6793a67f2a35074a7e24676daed9ff5ede806a88a5cc84ff2dc15fd8e8c218e80604f81dcc2889c71bb1c2a3daaed8b651b6b2cc31df1c83d386a1ed7a3063c2db17207c9138f81e4cdca2762fa960d1fcd6ff05baae0130d64855120f3ef89d8b5ecada7535f78e630e4ead7789a323e459771339479c9aeb484fba449085b0a02c15b1854a59f4f1217f27a543940c27e0e16bfdd5d4065c4a17f2305eafa11d8a3e56404148ef5cb4125bba9ce00bc8065c5da3cc4d32811a18ef8caca65d21c316a0f49c48b52fdd8b8e8567b289b17e4a957a87111d9f1a68ccbd0afe281d928771c4c6922bc744a440a313f045dc490bb7c9c0403216b7db9256e1f7d5004940f80f1b5ed44555d5211e609cd57acb38a52de37494936917f92687792e01a8d2f1b1efa928ff6bf9498bb2aab095e1371aecfb03403979fdfff2368389b809d666c5489d39085ba3757facae00292b66a30df81054aef676c78aa700f9acd475e6d6640aa53fcf9ca9b1f3fc2188b96679711b3c33f78760ebd08356dafbadf4284c5a1266f43a7cd168d0a65fbc216bfc5998cb438de3632d634eca41fc90901dbf4369b602ca54aec8170b625eeb353362762a93ab9287d6613d2e0d690c4115d4145f828bee8b5a1f90a89730d041d278187edaf6f539581819ea54b58a140d8439c86122427f95c2883497b58f37a71f0ae0f515128363f28ed14e2aeed8ca0433b93b9fff2f5157b1f15fee00e03a9bf8b8e4e7c433d211126f898ccbe21b063343c31ff7bb57c836e7ee833c7a383030f1044412cf10a317bf0fc8241c7c40f2ab82ff2db84fd281fa9ad51c38d5ce88afb4f63634d9e28bfaa040d63112ced3691d19458d7645b062d1894089df5b31244aa96cedb21a49671b66d98c9aeeae5407be00e23f564d9ccf2db3a9876d858aa5b9b067b498837e2ab3bde7d95e33a7384b5bc9cdf10d9f5518e15f0690027f8a9cbfd28fd49c9e3335d772d8d0c2b6383e18e86f6bc758548f72d80351d96709b7ce6938088d8e3e09e4e04ccf0ec9f8c72f51bd2c61957c1ff9d90807a1fcc3790e6855c8a32fcf4062a6a5b76f1327781f96dd82078857dab8af4e5535bff5f659398c330ff063ef89897781f58ce8e4698a231e5131b6acb61f6a262d7842c0bdf388ba41a3eab89ad52c6e5a55e6234d30d007957b3a7e26ff0a6947a52f0dbd24fd6bbad4fa049060816d66abe9c5d46fb398d9fecdc5e3ca18d97cac8a05d629e65b6fa0e6c91f950fd9afd096a1022fbf058845ca0bf3fad3a3a49095375521c4cf200ec921af84b748bbf6d23d07d04a72981ed9568da100b232706b7d9b279278a2e1b43ec39d8078aec3b331e30fdd0b7e9c594c9645cacb3271ff0e79f97236edb4e7fdbb18c5f90bb815e4403d95b8f3966d8c2266478b54ac8e2b072022a2b28befe2d863efbb8cc027fbf4ffa5a0dfa04c8d0d85533e2856b3ddfc29e2d4cf3fe32055b653b55ae4294d54800070a64bebe3b75b3b068ea0d42603c76ba13fe94b93d829b9b555e0f2a9541a9be26673ff784918ab2a5c7f11dbf1be12c561a49833f01e127d37d45a4f3ce951736c0c07159b50171bed9284e885a0b8d7cfc7594d58ea17f8f809816970241b49e09fe90e644c03a03485d5cd76a869db84f2236084ad3f1f1c9ae89b1602a04133135cd25c196e44cec2548ae015fc1aa56b77ba9ce8c336d6c3f72ae5b17729002389bcc9c4aa345553161491b5fb11b7bc344bb874fbbc7e9c960cc29e5e068e55c95d9619a9c4890686567dcd6d86da132e2136cee2f382a20a4b12597788653287c69c6c534680e97363c93afb0159dffc50367159d0c116dc1c292adba90da2c6bc034e04e8d53787aed0893d3ef78a4aca84194c4830a2eec96568cb95ac36457bffec63fd1171c6d79be9d1e5e7db048b4afe65369cd4687273dd6cf007908587255f50fcc1f7878e4a259441f31be60de557c0b61e72a5d9b03243f7b1ef2e29b569b7703e863ddf87f23ed08448958bd35243734d904719ca4f844cc97f695712d7ed0e4e55e362a3ac4d127871e1aeb698719d731ed9221beacbe650e3e73624ddb2d95912e0203103bcc78c26bdffe8bb3ee938da5073e654991ae0404db03d0c5a8714ec0c41369b310df4747cf8a7ff7c5d70d9c0402a313c73765d795cf12e3c04325bc1d5d42b8e270c3df12082011c23077112751c6721c4d6a6428e47d952917e20982dd26618e7aaabbe9b1b4b539dbb7105eab86574faf5cad0eba782efbebaf126a12fba607af63cf306e2cbe1b7cf675ed6501f70a14247db57f3afb49bf1b1ff1302e32b5d4fda5cfd6c84c569bfa35f797c361fa964631a5ea18ce80ed0d5d82ee37858e9be40064f6097320c8eae4e459f52beefda4c3235dee58beb942a3e376d09b149a8bcfdb3510018b9e224de94c89b2026fb60d9bf1f73d2cd82724f9f4bd2f5febecc3b1be4ba2d317074cb9b90250db8025d5dc9201b60a1c59948f1ffa938c6d50de8f522f66dd34155447451e252d00b1c67f6c81e8e29fd69f1ca43f2f03cd79777d25d02249ce993334988c7e69b65dc96b8cafb79fb2ad6edbadf68e44c6b89866693122e98e06946c680d0d25cf49c24cff6b12eeb6de8cb561001651643d18a9426af92f6b4e2953777134d38a8613c6bba6987cb9acbd35817db1064a9af192e05890a367188de094990426e471e0494aad400504dd19784652de225629088eab08a486ac643ef859b15c6ecb39b0503b139978f8ae842021fe2b611a728ab3bd1ff3e6cae6259cfcb2eac964ba1308eef253d06f571fa52c50fbef2139c5e77fe71838b824cba0929032e09bfbd5ac9cbcc7c013f7187e3ed201559400f0ae68e754785458c5dff2b6264e1f15386632a6da4d045218486b7155a0f1170b6a767bbe18db29c87a6f6165b465cb99cc34fe461cac17d89fc21b7d51d23e0cbf799b00291a1604a23098f82f5a951736094904685b42084883377bc60fe4930219884b8f4d08873954e3af2be8979b2384150b345c37bd8b5922c4fd1e0c243046b2da297ce72df54a9989af506b4bb252ddb8f71d745169b250711940eda40030edb0b75bff25cfe2eb1f05eb348e7e46df75b14e6eef2a8437fee0f0a48e4775714174bdf010bfca08e25d73257c39be17fd87c023f8328f3e248dcaf4df46fafb25ec26b67e47c498c33d9675bd2ecc6f79900e538e3ac22395eab31c2330b9e07aadb0858c81acc0de86cd093abe21a0e3850c44eb39598a864b9b22cd3754f2d65579651da2fd8adfc518ac94d1503a8ac167ac052cc816b513030e52cb1639dad03bb8476548e4df695b2c956f677f8ba51e1ab2c3d78ad23f0aa0dbf5ed5bf9a30f932b88e9f52ff31545c55a4c768bfa40d26eb0a9ff8c8df47121782016c9fb57470cf45840a39675478f26eb51b899d1d42436b0ec73e3c7f9db40633bc43add20c1f01484069204608dd8d54557c28f77df24dedb6d36185a2f4e930601821e2d5c9efb11e5be97af14710c685f7be6ece64eb4369f67e3854b5ef714f00ad36e71c3b48f35095a1fc9118d42a2011d33c5d52964c65c315cfb05f61af1178dd926902af52a960f1362dfd4403e29a23926cbf6daa156fcea11565cc7d4949d345cdc477eff666bac2cf9f6d538633efdec91ec859cc03697611a9626b64620768eda4132f32a4b21455af7616690ee4908f19de606342f93c0b032875f95da6a4d59ce5e7d4d78c3627b7a1df583e81f041e44f3cf576b97e10eb8fa32ace2a32a65bc415ffe99b756f8afc1825b3ef9d75c1bc88ff373c25a9178b1a4b9a4ec066d7501d427fa170220f1b4eb55848ee97d0efb197a8458574a2380cdccbfd69542587e94dd6c4a44f53e6cc3de5af6d8253f460f0df76db2d05f99fa58893d2c9d27ed045ebbf4a12456de86735fdd66a15c3cd975e1dad592a6053a53be4de1cff068b1606d7ed292f93c1208647b1fbf6feb18c5fd80d9dc92a76c05b2818c548b690150f5e057b9400e6ba6b526890d1fce121e605e120752c6408867fb90f47457f219907eaa93ec1851cae4ca9b0ca656dce0db175d2408c0d9e8c8b435491e490dc1a79fcde7c7bce560dedb36ae70ddbf5098b3968df4a26c8e347f8517ad88011c600238911f8fda82c6453f837b763b5f8cfd147c8cbd40687917978d987e2d8c41a274d0705be2edccdf11f08de4a851268f5e52e7fb6d599e637b0a899942422dabc16584653757450ed9c1044932645dca852b6b9ae441594776687cb8e87e1ea7be9a744f84a2589de552f42403bdd1eb9151aa8b844e9c426790f3e9ae5ffafc7870bd7da1c41739782dc80df5f3551f2a9e1ad7d55039a6cb326290edb7cced1e0a13c87421860be77e55e3bd4b52d0dcf52fdcbe6c0a506d650ec30b60978098c1776d17acc628d574fb22e1acd968b5358f8cb7f037961e035cc9db90d809a97f9b430f12df23522141ff7861a7ba88eafd1e2573c0c310111fc6e49eec58ae171cea6d617e410505bdff148fce580956b2aaee9def61edcdd4feaddde63b50b70d8c78da707f87791ac76f5c26e050960ad975f439842cbbf454a1b5009b929bb014fe673b94cde06ebc6a08d7f63228da058d72655b02aa3785bed315f2655cac73c1a5dd803ff95caf8d878956a8e1a2c4e83ba70a4b976b40b3d179291b24434e2317c8e7733bad5562d0b8abc41407ff8639009d27953f7bc4e3688fe720c7d29c54d57f7fc6320645ce4e784b6d6827e77fb13a313610dee954764c7d933bb36fd2b8b853ef186af9b27a6722fa58d5ad7dffb9dc7638d10a2eae38a0c5b25fc6f616019a79df0fafb3962332b5a0900eb15b7c3dd5aad116e01cab9feca02a9c994fc8a5fc531a6eddd8d0fb4616cb49c215cfc18b329846d61b88335a6ce3487f8aba8e506ace56587674e57dcc540be704866ac89ea6cf189ae7cc6a28112ecb641f30513fc26f23c1d390f84ed61d61dcd2ce7861a2feb9bad18ddc1e1201029890c42f4ed80738d0833deea171908a36d76cfad4885ecd88b0afc95d74059c9d08c378f3a6434c420b45be101e8507266f89e08297284d71a2b8631d53a2ce587b92e2ce795d9be9580c8e7368700ba149ec50469a66119842fdf93e3e26f079fc205c52d5d83f1532eaa6f34a96b88fa0e6c1eff98260a1658ca9ca560db790cf5b8cd230b08f04ca7e31049802a72ed3ca9d2cf0643254b65ae97d89e665824574120b64879a7d1d65bd8fd04b8acc896d369978ba7685c0fffd04cd5cbce08288144a29a853dfeb4a3b3812a854ad888c26da217dd162b4775c92b292d8fb7d7e30829f7c017fb6e6e2bd7defc01d8bf9626da93a254346ab02d56801958b1c651992ed8a8ce523b193c8b43f34497da0c477c6dd91503265dec507db76c2167391d963531a6817663c099b1fc3f7051622ca39cec3bd79f4b6d5b2d90c31371fc8667fec6a623e88f2c1b555564f5bf489d8059cfeb86778075f897b7014cb4318b862f88b84f67f80fc98b23ce25d03756e6788e0217af5d740ca44232f4efd813dc798a8725cd321b38564c7b14d627ad343da11414996224560fbcc697c4fe6ca05d8134929a5960bb92f8e6820de12d5dd84686290b4f05427b92fae94f2799e9c11100992752e47793f268896d8e4382a63e0263f1fea02a1d8d286a89e8d10b60cf864744036c75897c0a383568e456c0ae444dc3874ef17f092b94187a11d18d7f303d3b80c428f1b175b2ed74772365ab028671e71d211287cc8c974109654643bf0f00863c301522dbc30cadd927987151e0d5d2f352780d5aeaa4d0acb27153cbf79c5512f15b5a56c3aac069f62b681f58c2d81a3db1b69d2464e6e99421472f8ca621b736c6b70d5ebc8b1e817c97250a55ace574f66bd4f38ef3e54873a00bcf12d7766b59436ad613198432e0dc0d2813f8b71b8a0a6497981b0fc1b3f74a139b33bc7e9a9aacbb0de27b73a9562112020e268585736b4ffac5bfa994113ba24d7d175a7d49189858bc20907784da3e575ee0a13581775ee188b4ce958d3c61f64975c34b512ddadfbe9eee430f4d83c4bff28f0ed7ccf5aaa50632155a70232ff6167adeeb70358f35fcf7d01fe6908e76a0895c41baafe3ea152d9d18eb43074ccabf6168d9be1d456a626a6850773b437b5b5258e57743a56dbaa7961d9350e7699e475da8f9d515c949d0d6d0da8cb77dda6e1b7fe68bfed27f2803b1d1b1c5d160209597395c20fc5e882ba696c7a5a8e5cfb5f675a58ab7c5902df92aa27f324c55fbfbc2e8ae15aaf4a5d3b647bff0614f350c69d132340455a7dc3983ece48666ca0e401de819d5595e3b4d73e1242ae385772b238243350d043de05f1e52d7cab5b756d3e43b3a00da670f89c156ced432130b015a41b1a3832d7ee6e7228affba4560f2cf3450c777f4bf886c758c09e5edd065d1f383cb8196edb4ad5a8164f57b4e18255bf31da69c6ef7b8ff2c16a7f2285b3b418de56c04ed9d9e065a591541b9bfdad795baf0bb86ea798c7f31f21b8c6cf8623eeffaba490765d4554b1336fae35c58bd5e3ef61a5b78b215267ec25a62dfff921e81e9d64f8c6064650ebde67c4411e3510546dcb6fe5ad0682df9ba0638f2e8c0f2c908bd438aad7636d2890243ffcb1cdcab735991c39e248dbdba93a21b9f1225fad03f1eeeaf199432012475e1c74e6cca539f73159c2af59002cfb32b68eac933d77d142a318c22f53f3e9eb7096b8704474069aef851c6903394370c66463a4b0c52e2987542bac24299c6ec87db2c74eead11e0c274ee1a8f4d2d87027e1fe131b67718b2e70c7a653db440da46f783b612bf9c421d475983662d84c04779cfbafa5069b99df4a1a6f75c938f814f4431b0142c88cfbfc9d9c772a13312ed135c94cce48375487e213ee49c132d31dc3a8dbd84fd1f434fb3a47561528dd1dc906fb3cd65ac4b24fdffd9a57aa634a4fbd2668433afc5adcad36321c578dd6b214b52b4302eef3cdb57ab037cda8d0846bdbdb4bc7c4885a6b529f0e0bbd9b19f5e88834b4263fe27836c4e0d6789bd8481187dddb226d753e64b4d05e9768eac4c03043cb5489782f31d8f2e6362f0fbaf95b81ee5053d7e4e30764aaa1a821b7da3c06ad7e8e9d22c695b7ef3bdcf0a6db09b6e0d360cb3042fb3379fe6e4d0970d0bc192b052e9147851f0279e937d7f19f17514421e6bd27df2a3855060a66b350fe0f63fc432ae9d4636ed448d4421b45bdbf04f55127ac9d52d5af9589bc66bf0b5af8b83093c3af245e119dbcefd5a660e69b118d23f6bab6c646ecdf910a8d7ba5dbe4979af28748e0a137bd63eca8a61b9c9920fa73f6ea4d56b7b5e3528656db5dbe247b4eac4b9ebcfe24e58c3a6f9954a2a580250b432cbd78cd32ef5c4e3a2e9da907e14224780b21c0e37ad59ada26de82655f6fc8ae4d51e29648b975c68578550b66a57ff7435361456de07ffc54c1c35ff90c451ac6ac2019e33aa656871ab833e17ea7f78ef7a2397fc9d7c0621dd2d7013f96f868fe03924d1c8c270710f061665436d0d4fc1b047438dc5f024f7fd9f2cb7870e181cad6b39f454ced8ed72192a984aaef8054681db4d7086b832ec5650db363d26c64df95954e4fbf284bb7977fc5e33d02f61bf580d8abe92e9ca233cfdc9d9df59bf236eee31f1e353e929d1d9724b1a1389c181d92e2fc80afa6b3deb423964c65065a318b2f2f5d4493cf6bb4a6bd4e014fb926725bb622c82b62b914cfff917b26ec4df152c69c421faa2eb0e7cb86556ef308f02c275a6ccbc0ef1b50b9511f307ca66df2d801ab30ede7c05f256fcbbb9498dfa5150cf1131f30cde60729200e122c846d3a8a1d96da0afda13cd5205dd8f206323fb34ed3fcc0764d903ecb66aa35b3f51f2c6b6805ebab5d13c55c733ebffc66e6f5a64e721c6a3818f69c3e8fda8baedd960c143b00ea5f15622ab57c103982ceff7b28b90e6aa1c7351f73c52e12ba9f11e2412f44d1dc3702f10843f462574aae0bba383fca206a70574dcbc5d281cd104e9d3f639fd844e12ae63bfbdd812f6781b6182c216b58aec7b29fd660554aa1c46a1d02be5738a6831319681799930150c8d7af5af84e0b121f72bd0fc78fe2a73a266bc4a31b2083eb429defb5bb15a4e57b81f4144fdccb21bc840f8e0ca1bc3c98b260eacaf0d246916cbf5b08e1c2a134a58a9ae5d60628b782f693d2612727fbcf2fc47505ecc8b87397bc1f7da8a96ace6f2825a2510a03b71683affc2d59b3e9a2b072792096090d8125c20ca2d1d132e670492485509d57cd833adca8f8d2a3578e9e911d6c5230de142ac6184448059736839a1011c0cf7bbb8b85b2b2493c1fb2b61a2afdcc65d8186bb6f10025a8fdf14706f0bdbac83d72acbeb4d811f0a5b888519189c764f5c4a1b3865f31548fd04abd02cabe433ffad43a7258d3e47be3576f58658718f93871b2ab6747e3b89dbbeb5314d60d29cf39872b1cdaaffe736387870d579d2f000750233c7ab27916bb6f6639a2ec79d5ef2006860c2967396fc7d632ff6b07c5845a0f15260d17bc7e7a3c3d7bdd605ac72e908ebe5a8088a8add998c6f3e772415e4764f77c235f3d76aa5661173485a4b3784752332ece5b507f091dcf28568ac615c812becc9dccd394c2e31e3e819206d643d112efb242320e0deea2b0988d8986bad487df7e1b8afff9f123891e5151ed97f5c4db8020e88b956db46685cd341423756df0141179caef82c6d1debeae4dada8d63916411d39c3335a5ba8adc2d462c2807c3b1e3c8472b50c74e6ab7913b131a5dc5753b268719a52a9d7560d4ac65db14ae76e8cb4fac555776705bfcd31c2dd5e29aef3f2238a25dd5beb2d2af7ca7a962ca1effa4b3a0b28dae0a31dfe37513f7aeb0eb5ada202d010dd61f68e83ae2b2f041ff3951017159f80a369a98453aa22a849a9f8e4e82dc97b633a3bc5f9d26d461dcfef6513e22be9e13a809fc1eb6a0cd951a8195df407db7835ec7cb0c36b45d78bcdad948ddd8741e7bf3615908da7676663a70066cbe52bd5c5f04e120710d7405a6638d5fbd3fc96ca99e3f8c8af8a5b7e8e9a6bfacb0b75ca63a6edb9157647b72b5d71ff4a55ab241398d138ec5ad251d038755a6c93bfc5de0829727e90ef1a624a07e554aa7c17fc1caf9d3368eff8db7d23b08344db6f3f29c59472058668973f0a42c7889e0d544e5284290fca88fa59c48ad0e9748e507e7a4a833ec62d37c0696b4561ba4cd258e3e93596260d6b165c62b2840736e5e36c6922bdeccef1810ca740c37b49ae9fe5226759d21a9088fe695fbab9665462c168ded56648e14aae156c8f6673fd6c90e27bb39917cbd93cea2995c41eb913a63739dbaf008cba50cc2b3bc066f5afe28cf50ffd44aac91261fe3e71daa5d4cfd4e9af61d82c4e765c91ac82bbf712f710b2508902ecde904a17bb43bf224a64b4b8ffe6894190e95f1270a82e080ac8ba8b2f85a7dcd1b37e0a296cb8a40794b3b0e3f3d7d9b9a511c07bfa9127e65e513fc361a27afb12684091e0d6f09badbe3fb9cd5f682beaff877437ae03edc4c681645f31b59625367a4e41cf8c1c8f332c21bb39202e9c16778e9c6f8c28f4e5071fda6bc373d2d4c8ed29fb3791d1ebd1cd86c33503d83ceaf172b6ecb9820420ecc53793681b7179d111b81d749b8b50ca7c782124702d6e93a491c3457d5926c716603f738600d57c31f5ef193d78ce88678010e75fcf76687c8176f575ff943494049600f83c35fc69c8f435a435df972742b27cf185e5ade7b90856b52a42784b69cb8c702be9c4b2df071010622244fa53c775a8abc7e51c4913b50b2f203287b59acc06b45f5b01cffc700ed57c95e219b729af9441829708a0e7d02e828e236ca9885aa6400cb7c8e27e7c8d65358b737719a556281d7b409e53a5e526fdffba7457573cf486f4d652e37dad792274555aaa3899f973232ad34c295527d2f64993adf81f4799a483e387a9c73dae26829c77d364cc52434c3087aafe997d018da22b04768d6da81dfe8fd74e37974886766454a4873a2b37ffbdafded2c418e3860d7f8d5c11132a287f8297557392311035574c3f09f254876a827293ae39fa14c67aa97e8d74539fd6867fe52050074ea485dcec8ff2945b0b55be342f5a13a1a863a8cfb1dffddbc727c1eb4381d8815b2d39cbd030d244fe910bf125004d2529693a1ca36da2fbe6c90e0341a46ef7950af5eab0166b7b8db05a7924f9c61816f26eb3bd7c6e8435b7eea5643756166a27aa6568954bd749dfce4c7946e3ba520b2c986260a81dcf853baaf6d0ae5680eb3eebd2e04d043339a62a1867b53f4eba68783b6b2f938a62206ece2008be443a625265dffa787199f61d51b43613a66bb8a76076a5757692c0332670826a56ff6047e69c31827f740bcb6a08640641b279fd0e0c1fdccd86f8b777f3289ec05e8eb7738bca5c05844e2fd17b8d79bf4970a51b6e803d14d87b5bbc68799171b8f744a3d2aa2bdadade492f53ac0fff8fd85ae36618d5f1e79086fa81d9bbbf41112a6adfb1e4a755e97067183f2e611fdca131a94a735f8b54f716f6d1a57d3714debbd853a32e935d8da95ffd281276391fef4df4d50ae1c3b18bb8f7305762b34ea5c9e2601053f0c23317166cf9f3331b5095d1656e9a45f527227a25c4d457d2b0958c3f6f7dbd636992623a7c086a4c278599b6c3e79901d3a1e49668a8d74eebaa258c64bda46d99733724ef2afc2c82ed28d6f6a73d79d39ae688e974d93598a2bc3e2805513beaad697270da6947443a2f348ff4a9389a9afbff314082f81d10e75a59352ab7386e551d1af8dd7c9cdcccb257632619083b0eac03e133869c94ceb2a6641fb6736bdb2b6b0363272b5f51791d0006f46be49df237fd61bfdd30539574fc81c9b2087d5fefd3d1cd18ff4388d628b50d9da67be103747c6aca4c43a45aca390b0c6eb4a4b763214834577b4c07419ddf310e366a5443e28fc2ecc1d631c64219b6e3bd1b28d2617e83b6d47e756fe400c7288f5f14e9448e6e872548d989a11545b63a351db28f5db448b8df3ac9b4a41fca63565290dee18be55b501be7cdca5e70467318f1f554f5efdfedd14f9d2b8695690ea58410eef0bde40dccf3afafc6917e324013808d6ad921007930549542643ccf1266a2e225aaef148eba4b4697ac3a0ae30f66f2d499ba6a3c78032506f30b2fccc23d96b9ab6b2990b0504690e0d897aa83a424a97e630071c3928c80539e63ebdcedb714468f6cc44c2ee13a2d93463b12d2037bc209e5adf156fe78e84fe775acdc47e84a2d68779793b478ec35251e4053c4218bf89e7f61d32a17e24efecb1fa22c8cfd958b0568af7ad2324e69bd9bb90596ec43bb8fc0931744ec6a3e0c0ea000598a3e2856bdb24b28840192f0aa6464106578e738dd154d207d624873e228cbbdf82c56f116e46d3c950c4bf2345a724c2a63283bbbe86c4f46045e1d298070b89a76741fb5adb4b131c32c0597380a8970c16b7ecf13a389f837af864e111648c825020ecde34773394e8150476a41321e3d733c98df9fbdbcfcf44b92ea444eb4396c6c21108852c747d2766f31da6f7b08483747f839eec108cf0c1a969f8473aab0b4b347a6b2ff178a43a68b37f82107544fd870e3dd72b1003e46fc44b5e681ce85bab517b3f034536a463ed860dc5cbe176b5029b8e43ba9874a17297ae963f92ba359d9348402cecced824fd8e5dfa58ecb87536959da71da0ad83b22be1f9905cd12084cabaa7051bd0f86b94fd0d21d03a32a888b806fc4541246fc3196ec03574af8ce3f397360a06e7e83bb44f29d4a059c91d0f0efd70004c615f320bfa5a00caa9958ae4c65a87c9862ddb01aabece732e16a460875cac18ef65907f0d15fdeb5db222b32202758551afaa2698f8daddd433250f6c3297c51dd48785fd356aa4263ae1c730834abb7be954d8843e3215fe6e443e7c15559b9027115d595c83e76b0dcd1636296c6528c8ff859d6b9b070b0047eec42a353656d3eca1f8c738c43d1a83754df012eda30bc08e375175116efc19dd782117ffe5887ee3d5c1a716ccc2d7236b8c43e9e9b4b118ad47de2e6dee3ce3e444474fb08e8783458f265c460adaef0b9b33691e1bdcd253e9612487a7cc88ed7a0931a017ba09d60adb6770375c590b108c34246205786b642cbce8b97ca11a321edf0286040f0ea9ed8816244ac00142fd5f33efa52e93ee5e38913861c190fef888b408a66465c1725eea1c6ce6e8de6e992db970231a3f66508ba79122860045d1f94d2b8db0e15cdcc3a24679072ffa75baaddfcde7cb9e725cd4375648ae7b085c1dd80a1a342116a1f7b22790c04a2fd61c42f2b8d8f122c961cefd07cf7ccf4b6f6b5c079dd775db3c23ca4de4e4a37d67891547ac6c1488a9a62b25c98916f3a1561d73534f150186f469f5c02aad2d7b9ca3c392b63036fcbc0d6e9ead4e406b26ef3bce49f2c3014a612239059ad4c9e7f7d42062af1f266b3c5fab83f53997015f1246903a28ee4e6def8d1339f1019bdd06834b77e4666b8f656a76583085bd93bc8ff64838d50cb407da0605235dd5b1c46c8647bc6a2a158bd90743969379e3d6e1401f827d2cbb7f4b911d4a6fb088d9e3d83081f0094e5063377f9b5f1e2a5758e659bb4aa119fbd7c073dd7f179d20326ea5e6874efe1b6352a9cd057ac9c08063d36100a327593ce85375f45e4cf1243da781f965f58df9d4169272fdb4a98e9c71714e9e8ef48fd0d33fa2b94ec4eedb0370108201cf1b70afefabc02138c7363d813f665a9a8b3d5ee8f333fe2d8e63dc9a98ef274823182d5ba27663938f8c9099cdb36283ce9ee7e4ebee306af19a60fbad47c9672a6079bc9babf77be4bb2729031075e5c46dc589f966e7ab235a7f1220a7541912c74c8d2fc298367bb6b5aad69fcd7caf5dd01e5a70ffabb21810d215be3b8d49dd33473399f22461f078456b8ef533105d76fa55f67361a326249444026dad845a81d573405d7e32d320f34a890bd98b1eb2774df2f3ad2ad7504723c1ad01b8f922aacd4ad6780bd61e45cbbca261100e7ca6b84ee7deb1757a7aa0b0e38fb394fdf8f48787d3da94b5530eef0c707acb94a7187b8c7194c8fa265288fc4df9f0c528aabd066587602e021218293a9dac8476356606c563dbee0d93a2c686ab494957ab652ef38a22fe7ca1ae4453a43dfafeac9d98711c89c93e41267d9fd7c2c67ebcd49d7447e0a19d55735dbe96d51b5dcefa8dbeb333900072bbf9e7f2eb30311ce3ad6ddf4e66272712d8b30caa85badbecdf38d0a1f4a370455182906b058fdc4cfa40bbbdf42cac6311f24eab2d462efdd2721531fb1793962fc3d11924bc56d0c3d366d3acd310e5c169e273e96089bd0fdf56327668eb27e487a9d75370812a7c75007eced937bbb61d61b6d79ba155ab974a2de73045f6a60119d57260093a0a6f43e69d503d60155c28c2e4366e9312858e09d529ca5a162c239d5b9aa089567b8a87d36d3ee99b13adf9d7bf9477a06b36869c152b372a4d2e5562309fb4e97a6421a605b906bbb5341cc03269f2da9148770a51c4d70bf8d78e1a96ea17cb8ee97fefb720695e7fb012f6e60e835173637c48a6afaf888b1a88647a728fc17f6f215ff98ee78520343d2c29bf0799ba34ebafa68153a3be86fe3cd1b8601518babec814a089581a148f2bfed38","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
