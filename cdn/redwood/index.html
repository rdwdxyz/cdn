<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f161ddfe898b9c64b7c566d9bf8ee6ecb842829f2d1d344772fce5d1fc3f31a1fd9ad1f20272700d4b1b85703cc03437d1eced7cfd411f819ae406b413c86b4d41e897adaeba91f02cfae18b0ff63e85f1b99e87109a57d537b931a04f7586934882a27d03c732bd538881475509a7e6cf3d33baeb09659c52c564dc10761d4daa6035ace98f2d747df102c551e13cbb2789ceb14cce2fe9fc7b4ba152e8839b429f175f4eb8cb5b5c47fb3ff42f5033441bfcabdcd6c5cc8dc227c1eecf378db7715942e6f6ee8de9e212fe029e38e0de9bc19b6e97cdc5cf3a4ea04480c90986e5b3fa5798029328fb3092f8bf336ffe4cf5ceddb810d9ab0848d15b35541d3d000fc6d81424a204a819fa18c95539528c7448b7c4c28359d5a0927e94f96104e61452ee23d8c3c3ca756c9f58a3f22a7a0bbf5b0ccc2b1c7797f255ab30e31ecdaad7f48901938f285d942af78801bb42be394738561f5cbd3adecec7f2df34ab148ba4c5fe0bc6ca3efff93ca5cae72e6465012600222e9408699dec51d6056e456c058d3f7876879a0a599dd62c1652b141990c8fe02c5777879093f1b51a9acd4b8da50f3b6999d1bff937c08b0c50da5cf3f0a7db6ebe1bfb1c22f1c4fa8462dc013988f9eb7b40596ad05a3e0a11563d000cb7917eae8eb5d88f6709a2f5ba5bdefdbded98e75db6f2f870cbd6a07696d712998ea95e41260a30885eac5fa6998a96978cc61ca8188d0ce2fb97d6fb98645717210684f67a0c1c9a6f997e2e400d5821cc62d07fb18a5f4acb257ddd59bc5f3f99514223c8d87a1211894b7c58e67b3a3635f4a488f5f4f3cde132f9ea73e81c6df95b29dc0715632a23fa7bbfb1ae7334aaa0500f9b2970c4257ed2ade7070c6ba48990af9b6fc5d675afd8b318973f3b0f30fbb5fe5e8035746b63bd472cc1ed592ec8bc88c80c5d514a11db135c29108b697c49a2e6cfb5850f33e39acc1007af1615c712a6b30723739fb3e9e6582a7dc900116a7e2ede730358e29b912f31cf0decc8cfc9f6485326deac4ffeac75015ce7a4d7d43b183ec908c6ee7ba0e7cecb3047ba466f94e3042ecc7d555c3042c7a7c941177948ebf469799d764c2e52fc90a7c374ff1755fab1fdc258f36c6a7384055354adb23868abf1de0ee059556312c5c21f677c0ef9cc8d403d1bc9971468942cfe54c52c4ed7530539fe5df4ec6d49138b91cb244db928d7429d853f61f4686de5a2d69c4f74df99db1ceb300bce70980b0998d982062f0f6fe2aa30152a2db5b3fbe51ed7a03aae47435e45c55d131eccb005773f3d505d8366d5dc9cdf22e28b991c176514546cd3c4d453520d33421e05660c6d2591184cc8d9abab8f33b2d20a5fd39284c7f92cc285c33d6ad680fef03e5474fae0088873bd4be63ce5b83d353f11a64fe97d3367b42a0727f766bfc77a393b200850888728208b786ee5214b9ceed3158e1662090f417d8581f6b40c35a3de62a3246f45373d504353db96aa3db354e683bf12f0f0d37bac97144c46613bcc4682be8bd91c9e153b7a7d586de12ccfe5479b0a2a56658ee0775910731a035f03d64a92c37e2f3b1823840a9dc6bab5a73f7eb44e6e7545083adfd79221bcb0c4ff98aab54dead45e48e0f49f945e4e4d8cdc1e357297e6b45e48d893f57569881cf28c1bb2aff2d75b8491d297c3e140ff1df3db5ff7bd97bd2150a170b04b6deb3e413b4521b98469330f3edc816229a2e2027be20a5df7a6043a1001b66bf18a6d9eef08ad5896775465a4379959bb193ac06d7428b4cf1e28bc654eb516d84483ce353deaf87191afefb554df0434c12f9eb43dffdf42d6fb114138cbfccc765c8d885b0625607f592fb5212a727c6becd34fbdfba8441c538b5b547d83920a666c2b42b01b947b1e675c55dda400bb54d95db4e52d789ade27697a804250fcd73539b8fcc5c0261fc2efec7591354b234ad47292ef35f926d12236cd171985cc6b3dcdbb757b86521ea257ee9b437e46344a15b8a3d144481b785d090fd2babb9286c29674c15c952f0c7a69ba995af8b56e5d56ee85988ab2b89f741b058ec350e9b28e3ffdf02eb7ca8713c4320cab7510b1464a2553ae878f0c63052aa10d9eee0846c3cf0bf85f5825e5ac6fb949f0eca185c6e46e65c5bf2df65b5d55e0eda1d417bddcf1c13597b663cbbcb48fabd775aef1d82a35efc954aae45d0255c983c69e1e4967ff45d89e8439816fe3544d3ebec4e70a2921ef3fa4b75e08b056c6e281e7aee0ba3ac26427bef5f48e5a32d4cdb749e1a44097ea9a2278d330f800f458901265b61c6a0c1faa2fc8d1dcbae865555302a35343b8d08b22b23b8b7c15ea1d81b76bbc9938d0c70fcb83b12573ce30a4f4eb84dade3c7189e90716be82f6b078e25f62923b26eed6676ec3d38feba96ae1494d0d2e9f9ac28ce452df1297b8805eae3621994ce277fbad36ad8fbbfb371d40eee962bf1bd9dc19238388b6be80735e455d61295c6a3306962455fac368e3ac8474062098329933605d0e1c9d95eb8c6a24acecdadb4a6ace0a1ce328c9f2e750f94779b4a584c9ea895428d168922e2bd40e868cd0ee0a2cf47e6b831a58626f249ed92edda73bf6d032f1b41053fb9193c4ac7e2dd90f331be38130c7c4c430bf2d1492e2d0e5c9e1618752716912dca0ae9ae8338dff01bd059a5c95e4ce834e968b08dbdadda6c6e888df774cb6c06a6c5c4076e9d9d63ba537b55e7982bd4aaa27de13777a69bc985c469ccc619868ce8d2e344e0e59a304952b4be03fe2138810d1be4feefd7760f8c70d157d0dec4d6d54d3b5c7cbec523d4c577bed2a3e3bf5fdef5f734694756537c020ef2090e98fdf368f9b955ce47b57dd03c853ec2afdda653b5a95483f5e97cceaffb1b7dd7b173199ebf72212c8fbccbd59693fe98cae64d5ed0a3453686f16639e290a8a8d977a4fb36b7ca346bff8b20673fbbd2610c2b16120a15edd3ac29f5dd6723f62659bf9ba440a176ffb5b7555f4d9000b9522cede2a718149eea44585990736cc5762ce4d86506351d91c0ed4f0980eb9293c03d2ad933ef23ed523b8417d8f0fd1f240e27a02843b2a3b2ab00c374eb51c242a4692958d3a7ead2ec8101298eb275256e0619808e61c7cb2e6a4a59d6959931cd65c99cd6700b922c1e3874d1f9b4ee384149bfb6169afefa6318449729e3a2cfec894a2543b41373a259db37abacc968efae48e08ba212cd0c21f106cad059fc911a6125655f5bcc1007d01896d65900fbd2398a4b111366b7f347414b45a6fa5fa68f1f6714f1b69747d3e62864cbe365ffb181095c6a817c43958e9681942d1cde8ebedbcc147cf82a3af00c2cd09499a48b49a570572a9ab2fe114c4b24336eabdddaa63a52e96db2aacd6d30a589597fbfc369ecddbfc4a9d4fcf5de3e3aa679d0d125ac9ced40549939f221561c82ee62d3d437b38eebe0de2f4e6becec151f2b9659a3c9d2dff5843632d01ce12270416f69cbcc017c6840561b2cbede6dedace6aa4470222cb5d92a5444ed2c8f006e4c233e5d066d77b071268f5a2e3c35fca438235f3c218b0dff7a181ccc79c2ba5828ce14879b686abf7e0dce3e052890065f00df978b8e471821584664b80f22f7c75d0e56b6b1c3f8243213003427baed44b18677367b48da07a1b7c1f68b19f5c48c0ff8a269da53313e964f0343abb8c2f9e58017ec9fecca56fce7ad2e2c7f3be337daf5397d8342f7e823e03b8255c9bff750d0ddb9200b67c8921d9a00f5cbace1c5be89ba0121c9a5908870967902b8bf89644659e0066392c412941aa7889cb2bb02dbf800503e827d64178a3a4e1424b01fe827065b52441e0f0763f4409836b417db6cfb4baaf80e542019f6c261ae78595fdf2f86f5c790a58eec5efdc0f0257a4eb403a120bb78764a8b5b3050c4520aab4fe86f133174d42c8617cd741d44dd682dbd2e71f8003f6fac5151c5a72767de4252cdb803e34a8474d14f99e1f1d66fd04373276167519d30b9bf685f53ed5624698467dc24be4a0d8e19631992f0969dc1200e130cf295b3cd3ff1756a50fdd2f41ff8b229ecf01c6b1d225df2d73069b0aff0588362a210548348f8b2d229f52c6bfbf5e95c8c2e201fa9dec1a55333e1aa2d85a9851475e679e0d32f9042ae0605935023f29030b2ca2eb3857540242bc8070df91005fdb5595389983ebef586459359f7c3d8c71569bdab59abc1db05a5c7908924928b42864ce54685dfa812538f960cd6a6618e1d3ef091ac54c6838616e7588e36a02de5ed534c384cd88a284d96bd7b9e1f1c1f99cf1ed8c606185e523bef608886bb42dfc44b62a598462ef4451e2ecfcf9ee65a4425680b33beb59a7db9d78f7db521f1392274f2f3bd29cc09d37b7edf226850e53ed7eabd7d12848434a9081569dd708487a0da3182df9abd5479c1921db6eba6bc16e7ea6deef1ef67d0a505728713817dc7a48ee5b391a838228d1ca1571b9acc658bf95b96ce88d797bdb19254d030e2130cda5b063f1b41bc9fec31dadabc52b2771f0e3dc0fab63bcbda90cb29fa63643d2124701162840f686dcb44e795336bf79091942cdb9e9dca599c2d55c95276c695a6d7ad25ba80a1d5b8bafa910cbaf57734c83266f1c9357f67e389d7ea9223c72321ee331114be23a6c8cb0aa9c2950b67e0e7edab809109e7e25164d7798e4a784664929a1a61e10f57adaf86847aabc304d3e7cf2586c1a941837853f07164e4808a634c135a40e164d533a26ef3abd9adbcdd2bfc7fef881fa731889de3d33bcdc880c8f6590d0cc7d4d47ca98821ac9e20c9a0af78dfda5a4716002b777d021ce216aeaaec71c555aa9d41b06bb49a3b090b1ccf0f257fbba8969ac1c929381c62c6f6076c8258176158b1d1924cc24669d2ddaf8d25826f8fd46dd94287fdf6c670bbd8c7df7e36a18d9e28fcc291035c4e43ff4729cd9b1977103949f5c9eed9eb94fd94170a35ebe85b35ca464fcd1644d98b8edaa68db2500328445da4aa892bc00543d65f1ce69e368a02a1bb6a47bcbfdb877606e681b0452d0d0f68c041eae38e570a6578b78b409a276dc590d570b359a3463e07844dfc71757602e74508b59526402ffd2726a81f11cc2ae6af99bc1b3d80c02a9c6c4f7fd20869c2d82a24282a5623a1081b0458e5db594c28b88f6b6d2570a04b536f1700922724cd85971f3af161b07890e3b51b443f1d790a89585f3531f8a15e3c97fbe759bb625ef04a44775eeb1f3ad7f14ea534a175b61d9e19bcdf53039735f5991ebced9c371961491bd7c665146d3cbfefc151920e4956530d54d6857ffbd8417dc7ede4722cadd735d31fe206c6781b0f5d08767db34494f96f1872d4288069b2d85fd814d0da33037f75ee87e764c752b8c7780949fb8d9ac9acda1588cda6e077a1ecd804def48872e4869f4e07f85aec056d061b70f7c83870399abc3522913e5ae9471c05e72c6fd9a258d662f51673ef8cfc1cdf60b047a78c3d5f526bdc6f5a5c65f13b23c9f5ec23d22875a50f8243a87f14b88f5de885be0a89597c4b5710b9d32e8e55537c4fb7ed9b7bd06879859bc4b30ad66f0fd16e71754c98a0add7637afbb577dfa949e2e9a33b3d8c3a25dd82f80fbf18e24eac69c974367c54d1315eb2be1eba590b392dacda4f2fd744c6e9e9f9e82d9c21439e196e9ba2bfea5076c3b7884fc0a54d7a47518b6ad14718525fc73bf3adfdfbd2a094f1bcf2de84403980f63990bf8fdb4ca7fcb2b2dd9251214d5db55c2e9447d9e4c285d85efc49fa12bda4381c4e29d1556640fba794f0632a5bed778bd2d9deb742b7b3ff608e83d3169d61cf14f12aadeab145ee40179759203ba16e1ab6d2efc311c0b9993cde059253e1084d1cd648e24bbc1491611395507549416d96839d602da15e749086b3aa7f798a657782cfd84d7a1cbf3328da244bf466b7597d4174195211e17573e9df83a3469a105381ec2312675ee6691b4ae92b9da477bf94a80f163edbf46019e48b2956bfa5ac8fc59e90082845443c101cc75fc865537c52bed88c120eaf12e0cca8e22cd8c37be38ae935ea5754f86fdb4aca0ccfd97e1b6ddd321b41ff2337d4d5c89148febd5849a7c5975e7a89265d162edaadacb2c1023f34f60dc883052269fc8422ccbc3cf30c6d22ce84cc2024b4db69c5c5e955506f7e1ca45e5bf69aff2f33534bb4dbbd65e26cbf55548559c03b0cbafb36194ced1191364921a2b6bc15d082c4faa4da28b512e9e90bb6a36c865bed107e73c54ea7158c3c97b941d606e2bd5314899795b76487fab1b019c48c31ed411fd08af8adbb7ec2d9feada2249646273aff8c608c0c72255dc9e001c88e4c60d25f9f66e70a0b08915b96a3585a1e4bbb64da433777004b10d4d6a7199dd67331d9f1dbe160f84ab4c535b3dd297f219c8ebd74eef7179b91774e3a8a85bc7f7c51017def66d478d127ec57552dab7e2fce57dc21c89d566a9d31da4a13674eb2d6bd223389b14338135314264f282ceb420a24ae75ddda1ed267be24116acfb42c4b3a82aab642313c279d3932c8c00254abf68d72ab8e9b664b503f5d34edc237048659945fb7dabea173edc3d73d5db029ea82fc0886bcbb83aa1ba701db6250c0a2fbea1cf91d386e7e0efbc7e8e0c2bcbcbe05bca52d7c958214d5ef8c95f10fe78864ba4d2a5c02b8ce3390cf6a7adeea64d88897aed8330c0440c810f029688b275372ebe82ea1779e92c263969ae0a93e2290747b5d2c35072dc0959fac45a243b4b338232ec41cd8b860ad2015a35566d435b728bfd3a09da34e21ccee035ac4fd0875820e72fe2a8fc7b2b4891ee81082e882cffea8c152f5d052b83ee73875e54fbe3a1656b26496d2813c639dd881b0a3c9c083ca5f68d16c9dc39ea57f43d71e1d12fea85244cff283730fe31344fc1a1d8b5f9168cd631a62505393b0085ac1e8d335ea8cfbe87f8951dca3852b0fcf8525348471a2be39324600d1b5ee41ac6e935a948fa421a94bf0a84a24fb5df18991eda23038da074b3bc408a53d60479f3c000707679a7ec92b2b6131b1c1da450716a42b95a1213a64a1b864f73721ec26ad2b4b661094f44fa7ff3703ad638bb3ae9460b54011160ab32e39fe1a48387627730716632dec2cae2eee9acfed0604b9d85e7a6b4cf18fc71ec4382c0e56af93a91b8da643576669bf33d80d8421418a964798794a4e1fdded9f3b8fc5f4e66d05f9be2ccbe8ea838faa9bb96a9040712f98a26c38b383a6602256ebd1130fef1c0d809ca64079b3cd24dd6e4a376017e6ccdb509ac33a871baa239494cf945dbd585049bb089fe9a7ff9d3327ecc865448ffee2e882c30311e2e8dd93eed2ae16b0da620a95d8f8bf0942e4630ff6a1d4ae7dbbde1a0c66368d5494b96e2f13406b1bc31abce6bebf07b0f638dc23bc74893d6f6eaf35ba2e100cf524b9451358b1711b45811b05b6292aaa0bbf82baddca3e745c43ffacec20632eafa77f0f873d0289c8f98a6b587f0b26360a6f00e0ab042fa8c412c0be6cc9fd81af719c92f5eca9df08f01379a3fc162311a5ab0aef70ecdd5dc7c6602167da7020e4b10f4a109bdf828abcf294886115c3174bfc0caffca2763827b5532554f09682043b07ebc3cb970bb4c9611722871fda2c1a6a50787f975f777e8f5942cf16193132d2da48a729b4cb281a73ee7e4fb10c39cbc570d5e5e04e840b6860a470739587799cb5b2092571cecc7e7c0a5149185d62c1048e52382c50890b9ef31ca72dbf2dcede42f542d3ec0172bea7afa3e2da18f7fcc59ddbc314a86764cbca5fb141b31b00f61622dba43a39e1393ac6784bed9743821742239b293283467b1dfb61a6e2690ebf4fb59ea892ba56b73c283bb24cfe1566b694548da46379f6a2c31111ece02f11967e50195a8c25af8319c645e8808fdf4587899592a60d8805c9065ee6cff4e5a21ab316a8fbb9aa368234a0c03d4e07c1e6532d2cafe4a5845c4bcec91cb19a9ff05e0840aa0be300ac18338f82b4b22449f76e3041ee585c39018ec19a6ee8cd623495e8212f16699e011bc457ae045aab33a599441726257a472c491d7101104652c3b56b00203333808d59dcad9fe977e9e40ce85f9838d41c889277819cdde21838add97e29565b8ba33d3ab7b818981b1aba04cb3ddb3f43d50a45ade48aacd8ad2d2cc16031381c44a5cadebaa2411ac0930bf2174e0680212dba457e3c3987e091d7514a313d56ca906ad915e023a1315e15940271b4bb97d2f8ee3b900e141f5ab8d02f1711d4adf314b5aa9ad02708e1269d9411411303e9a3951ff9437ef59f1a2f61cd2ff0d31e051cd239f6d2d1e0c1961017cc67987fcbafd0a4ecc7fe7a4f9b866f04cbed902880f48f1834eab3d9d9476a90578b094d28ef178a8625d428ce137dcdda098adc1d20f23111ab5d3f6a3e7a12775fd5690aefacf8ee7f05dac156f7068b7cedc82de3ee528af788772febb2069e21c78313dcb344d272011e1f5803322deb0e856053f7ec3fc0a2371f0a4bd72fffd24ee7dd72698ed5ccf7fdf5ee57952d1d96fa7b556ad43835a9b11b1c9c47231619b3dc8f16f5ede39689495c8e9bc42bac100515ba541b55ee6e3eef8640c29285d8c0b9f57d292f40c54127b007073b55bdc69f1659937cee8a9389c036d180e7aed219bf29da1764863130dc75ebbbdcef3c2a23ada7d37f57ad3401cea6106863425da7f6b2a62ca20dcde717eb33cfa591e53013fd3a03ffcd1c63dc15af8230aa131fcaaa486af88754b79d5f4bc46950cc9d7213a1a8ce5261169268eb60526ca43a6238893ab1774d4fce3f9293f648feea294b230975471541d8a4dfcf051c80aae1b55a0cbbd7b77c7a34e086f5276798ad9950cfef16d585e2120d79dd79cece1896d7a364fce4668818eeda22d0fcb53177739a3d6c62b19656b570f1889bdfaa69c3adda9356c9e6c06d3f6335a61d0ba72f338acaf036c81b1596cd06bd3ff570d62cf04deb6700cc9a12c63b679f824a43be39c6b0fefbb9d506a5cdb60891792cd243bcab6f3f422dd6b918548bcd84182c5e7e7b6fa8114f8ade9ca0bd913c0a97365604245279711838b5708f195d4143c9f222a8d6c03ad28918b658b2fcfd83f64092e4e2f3a9158acc20a9a829f9cd63f706558c803b5d51e6bc101ab474c3b082320780d0a34b8a631cce5f230d11ffe825d248bd45315c2d3d70ee924c3572621f97f821636223613c3b8d29a543ae725936670880db1985e5f193349858a4e6f1fae59ab53c54ad2b5f0828018fc97b73ddc876b852144e5d5d53fbd1b41c918e12144d8092d7691d17c9ab4dcde6ff0db8a90042f71597f00baa8b8f8185f1554383eaee0fcacbcfee5c1fd4f8c68e276d2fa6ea7068daf68d266f26f6ff556374229613fd4e98fc5ec68ac0a9c8477e066e6c4f2c1fefc20dddb72697ef184d4bd82406cc301725ae4b10f3ad156fe644200779be1ba6e28cdaae9c09970f4c6cf698886897717bd996c3b72ebb1e8c0f46376b855c0b62902b4442d2d55b041741c689a42fdb8c35589bf43117758cc6e39bbe642ba70219c4140551f048d2ec5f6c3bc60ed6631c35f076395b4156d3a84bca7376dc2505b1a487035dec8b41e6db0c66d6fdf45c9ea0f2d0518b95990b4179dc9df1b4b9ef8a478d1699e4dc2a236ed5e76dcdc6ae2af04a82bc33afce23a476cd2f32b5abfefd1dda20d9ee56fcdb329dc931ac8e885326d56d9f915f55bc05f20c8b43ec911553b0f9f61c0eaa1e725d84c742249c05d447be7d7f81e38c6e8f133ae6955422e7e18875475d2656462446d19e2536a370eea26edc0a3c7f62b6d0d84264546aab5f1875226939d83f492e20f131884f00c89dff297fb419f61c4fcdc381bc398252dadbc3c82aa0ce23347870098a1ff89f2c753d74a78e624d0bcbaf6ded1f7804ce583abf51bb2c8437b31bd4003242a567ee6b6965e013723be6218918e675a4924219683dd3f60c7b1a09dfae11391d3b1b55fb9250db2741d93540e155c07c86802963307b604f279c1727d1f0e733e20a69c46cf83565fa9a632c8f62c4337ce0ce563402ec49d839422a937d607bad5d2ca8fb52b37d3cb9c24bdd68c3d9ac7209eafd3bcaf6cd9167e75c8d6bdaa23ba194b0507e5b7afb564495f003ff49c218eb02143ed3cb07e99b09ab7b2d9a546d242d2ccee8d8b77508630648f63c709da57550913e4db3b76fb72efe94454912ad11c7e1038d848c93132622633c1ea25b7344e10ea0c7ee91a41e5b1710754d3b4ee150fc0e3fc512198b8fa9f2f1865f6efdd963aa7649a11ed975fd538a7a91b449fa3ec924807104de7839343e40c2fb5b8c91845d5da1f93e538eba9508dd626dae24b82d8a3130e891f1e2f93e665802ae790afcb20580823cb3a08bd2231202fc8a8a2330fcd853fc81557a1bddf3c2c88226d2ed883eeeccecaed859f0bc3ce6622485b283dfc096eee4a8de999908fe90535fb6bf562e656cce843d8214a916b417bda0b255f2b7f57e16d32f335cd18e2afbec446ae1b8dc3936d07f089f04bef5a311a0340fb33d17b356696a55b0caa6cdacd451c73a51aebcff42cbc87c184130b640b08c34fc50bbcba827d65778f40e20248af8dcd268b001c155871e3692e36a717b675d2b7d7095afdc0f10bbdb0f4badbdc37524182379c117f3da3abb2e7f06e24b5400ccb7baa530fad6f78a2a3901eb000d8a3c43fd8e20ce9bbf76d8e1d8cb31e46b0073dac421115efed17bb9b049b7fcfc4cce7b245052699b35b4c9eaaea8e01c07e8e62b7d03bcaf2c1c3aa7f264195f869cca12fa62ac111e5f7a8b09f075ed81d9a1c17b18ff114617ab6cf0abaa9a22436781e9c3235dba5be061aca739841f26ed381f7ffaeacaad43b12690f00edd04cb3a516e4726d930e2af08f38bcc441560a5c408749bf4f4fde63cd432bc04be670cc294c842ce9ef3017f86e80192e220a79023fe8b78712ad0a0313e7c639eadd392f7a91396d61c51e75ac7c1915295212c1bab51dc713007f6e5924f75a6a72de806ef53494742cf7bbf4d7e47aa56ca0b8ce69628bf88f3b27de46e5bdeb9e4c351a065d8ba3ac2ac811cd25c6a3d7d01250e7cbdf4ba6fc1a609e3855e3e0ebc2d258ab9ba6139afde400751a722b51e3bff9af9e7c2d4363fbe7929bef935f85b0120178398d3f277d636b1d0977fc9525687a70d7de84618aaf97535b74899ffccd8392f44f10658279c5233deb740fb2e2434a552056f3ab8ae55fd3a4c92660a41449fa1a9114f927979b9b01a837dd02c4bad93c017ce7311b33cc16232ea12ce3763d35f8cea1fa36dc0f68bef1ac66bcba1d4f46bfe49ae6f7f16a68bcdb4988ee0841d598e0a03426e8f2a69280c469f82b4caebd6ff84901a5fa61d446ab61ad058812031decc144193a4159bd2d5ec96d9a52039d8d0ad276ab0217a35c906a259347fe464525eb5c3012f906d341b79127b50d5db00962b5c5ee3fbdc426c437cd340ac3464a1e9bb620736ccce8be6af816545e9072f061fa9e9117b7c474b22594d6b86d5305cbe510068e0a1816a4e41018d04d01451ade9ddea8152782a0154b96d7482f21ac6a4c6f9164b9026fdf26bd9b0ec6bdc982a2ff10e4f5c3fc3767cda356ae89c5a1ad99fa0de2e9ba89170fed1ec76c14daa174c73ed1e665a9dac806358b934f83a5215cc4232c46dd0106665d155b5f673b91d25b65fd5d30a8db8a6f62be665fd723e42fd5a5464f096e86d2949122decbe314fc0fe8e9792f28309b2291b7682b51da11229e9a921fc74fcfe2a9d3feb3289fdc2b7a830a0dcb478ad37d7d4a1be83d33899e58c7ecae4338643426233fcf1d99555755c174c5a05774fd5ae85407c683ceba06fe6cc0c5ccce95c029b92c4f620ee163e7b190d1fa434e613875c5555b8ad202aaa686e177f2610e4f0936c52fac6ce52c1f46568b2f4f2fe61051fd139e42c28282ac0fdf8a73e8ceb707ff9bf8cbef9ad53302dc08aea2a0957222df461277fc428dbdbbfede13b04dab82c1468b4eea8a0b1ede53609ebb1cdc62bc115b21310f5ed50b80af624b7423c5a6ddb1139a6776b1763205d0570183982c59cd76b7b15b5527b34a87119fd427eea848001a4ea41b5bb98e358a6f3ecba52c926edc5eae5ee1edf984e4d4f8072c948aeb30a7b8d1d7e7b97c6eac99e0d304d34567e8c71dd878e685e100bfd3a83c449e0a7a3a3269761112c1f7da7468f5a3079f4ae86e013617dc8e34d0019d35b4ac4ae501019c640640a4eb9764f611b5e03d20325a99bceb301a479b06c8635894781ea5650e5bf4f187b1a54ba7bd6b70355e60cf5771565594cc2dc5319c55adb8f1cfebfaf64f7a54dffe82b3107c4ef65445db079cebf2c01b2af4b9bce66daa09573787cb51b6ee35cc66249391af31b88cb1d0110679617ef9c587896d3d0aba687d4f8989dec5d34bc1ef4e52b449034b3ea2e25d0253475a9aa5ac067a1b01885db387a1de40de6df339d0f8110d30728e2d9af508f3aa136f389e716ff9f31598d2cb8a7636d8580b2f49db83175bf55c39b816ba7794070f3df60ab8b0beb0e54907f8d5beca7b433a0bee8d28c4b9187daf8035f712d7cc14ea42e9f2a9f3c2a5a861140bd30c04fe41b81315227481a3c1188274b8ac0d3fe7d743a79ed38177271d82b6a8ff9e45fb651479f79b86396534c3ed474f8b2dbed09f4ab959150e157d4b072d8f123d9c8e67ea58b0e834d157b27f815771b9c4cd3a56dc8e3012972cb1cbc10c288ef8d50e08019d5521453aa85454322b3208cc2dd2db32ceb61a2224a468dda6660a1c4317db3d5c32cecc27510414582ced9a0d33ec37d29c94acec4ec9a4fe9f7bcb28d2417a77182382aa8224b108ad1f57c2444199bdbb344d5ca180d256149df5b3fc7e643fad91bea95bc79d91412423e559b695fe1dac6a39e3370afe0f92e97ff5ce362dce8ea1103eb7deca537a8f93efd66e3a41b03896fb9b9995ceb79a027a9477748821222b735f9bfb5d8985563efb608033d016780a38e48067ad47b3ebe480b7dc4f21504e76ea6ad3b2efe95cba3d7606d9b579047ec57e65ad5d57f40ea37511499e39a52839b43728d3819885d633903201543da3b49658ba8c78f89d5cedcddac9bb24d8b5d36dc204e368b0e7159392e0653d7e6fcb6e979a092ac30357f7c6bfeb42706f03a3ff56d19de2901e498594190d1564717da7add151d951a967d172512697f2c2876da6d6ee0ebe6ac8f38ed0e7fd08f6fdaa16581a57927227212b154eb4559e14d775165ecc889162d073bf65c92ddb2045680f6c145287771bf2a175ca8fa4937e184bcb8311b71a353b47f8e39116bea4437ab5d615dd4bcab2ec1bee17d7ea75cb52437195cfad6aede96a917efcef2f373c7e90719b47e7e42da9ae6ca42ff2a03b11163b7991826e75a0152a7a864b0021fa3ddc0754994043e1dc2893485ebb29ec48644d1bd20e0049316ef8384ca5abe4e3ba77a0f24f73182ef0ff68c4ad263d3a65d70df3ece5e06028e155984a4e70ee4c60d1dcf591a4f71614c623deaad32d1f13f0f4c2606f5e1129974b73e0d11e7500e48817e3d74383720f341951dca354c731badff5eadb30cf03a3aeccb4061b52cad50056737920a2cc015b9dbe9dda859952a4f61a17e715c41769476a250d8d1405bd6034d85f3ae277daf4f8b7bd7b77aca923d84234f5b38d45fdd0f19616f27b1855e82ea7c07e6a7f1d20af226b3a4ad050151cc6a913812c7468005abcad7f203c0b48eed68e9ec566f385fc342f6f7bdf636c861f785b1d5257e192c65f2e4bbf22794c104d81d11af5b24847afa7db4d6cd61b3b9e93181dd39afd7e8afef156b64d5f9462562b94aa5a2ecbd9a6824f43094bd79c2f65388c78f0ae8567eb5ef6ce569f6c73cddd8072bc789bc2a0a2e373fc47db3f5916b9d71325252a409e873cef9fee154363eb0df3382ee4bdaf9d7278c6c3cc6729312f62c82ea50d19b1077a78f0b963607e25d196b073e16c487141bd8caea6a4b7d5e848062e45e795acc556b4bdd76e4692061b4683cc70ad2cd24fd79083af54957aaad760c27aa5e7c2b02854001cf55ad6dae29d1d7b2eaffd9bd0714a31012dc4ce44e7dae567a26f95fae344bc46bb7399cb8fb932a231fd06f6075fc3fde44903d276c1ac0a646722bd7e9575e2903801b47e8912b8cdb0b311b8ecd240ceb219796c4fe3e3e96e9a167f3bc6d013df1b35710aa962a7330fce6ecc339821b16c8ee598e67a41e989ad815f9d0964e9c4c79a5f8567d98435767de2439386ed9f820024f5a5266c7f1588acc64007665ecad5dcf7165bb6d7f1be55a213c4a919a8c54a2c59a4cc78da308d3a766044c91fab220ada71095533f6be689e56a8dfcdb392b418914e7a6a94d02830936d056ac4100cf9faea510b004a84839fdce5e0d7816c700f8f562bee20999e9937f5060ef88f5ba8b3042502683dbad6db68425247125a071970d35061076f1a8563c49eb9d26b89c82a00bd1da704bfc5491887ef7298bb322af6671c986725dceb201adb9c056be3666adb49d26f60a1145f0a8413e458fd5ab7b343e75f6daf34ee351ef1794860e88c8fed1d7ffca6bdd793d2e7dc8b63e7eb54104f869ea29cd5447e9e9a339de815c51a711c53e7e2958d620c34f56e79a217e3dd598c2c4e7579e6c47af06430704a7d9c3a542be493982745ff85257f5527a5a4f65ad732451e4c6c419aec8e183cdfff2c999ef3e753accbdd660e54926fbc29105251bb7f05dc6ca24fd45527953ec3e5f4f367fe4ed9a252b02a09c2b6a5dec05a2dec454846c463e703381b88eae9f575c76b6108b937f9b87b05bc57866c52d108fa3c7e828981e074a57649d7cc878a6ee299b4629681ecfcbe8c7aeb7b9058d8c08fc6965c9084015b7eca8a5d4650b849cbd0b2a892ddbb48504180b2ce9422cf09fb6c7f9b7575c200af6c057231035bdf6cded18e6848c094dcdb814b6e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
