<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"064c90642b376ab6e267bd0e2d8d1538d57171680d819cf862abc65389e81a49bb162084f03c1829608cd3b0b96aa986c9149c7d2a46139b26993e6acf8363a27a069fc6339f05bc92496b60ad53e006251a5d2409e1cd8b344cbf18126194bd26cc318bec15485bdbc5e12ce7ad184def381cb785e64734f44c553a7226ea411f746608a9e687ad49fdcae77b840dca2d4ffd5262931b6c25a589c62f48a9cd12b8ae8c83d0b314237f4ce421c83267838d31c6b8f44e05b560ec3345fa39ac947ef66f89448e8c3a7f723007b7b78b2883dcc20faba66932bd4dce258cf38fb2aa65e9456e182f10f1d3f5df1a7e36a4181f34ecf9731765ad2da2fbd994f3b7671745392eb93f5bf448abe7a08e63b938de28950d3add7a6dff04e72d939ef15d410f4e5de0a5a490d189b9877522cc3bddd033f1ed8641e96e04e4142cfe31be1ef7eeb0a0aa5d11bec84621cd6724fc2e48eb7ff3a9c5e33f50bf3ec511340e8bfaf2d9e8774b3371f32380749f6f839be6a71a606b4889b74d77fa62ee3282ae1d2b60478188ee00826eed6511f005325ae327763638e66dbf65c82639e2c6a17441c7e416ef1f757c1ff2ab5c91fdd730b27653f9b1c837aa52cef2468b806a34e485d28a4e1d92cefb2cea8e66c9182dd32f2f0dd3f3a81e60ee373aa4ae10392103d474993dd353223e39353fd1364fcb57d14a2fe43e058f865be5c272062492fe03172cbdfa8f9cb870a92993b1cf4013d8b6a65baa819b05f369ae7c97c95c4a287bb36e5d61fc0bfc462148a61eb9af3154a0aa7b1a6e1f3a399fb7980288d5df7bb83c06e12cf0b9d55b0633f13324f347f4c76a33dbf977ff4669b9cfca92c32b76d104ea5e4b261f2693a5835efa442e93ce4e5143cc1b7d0c0b26717220399960f649135a757aa161f1594b782efa3be1122fca3f58fb7d1a6713f9816a61b40f0c24bc1ab9140ded9b4f9d0ab3cec119af013755961b2ed0dd58244939c249e9973f5abb559fe2ff531953d209a2994c1905003491293c828e7321e6a3d9042847c170affe5f3fc31e2dceb76e877b53dfc65926201594ff98e14e7b91b3c26dd4d7e6d0e1b106b4f7f0c38a6cc9779eaf972be3dd34c12e266da62a9c7cd325048cdd49017239d77150b519bb669b82491f85b172288f202abcf2badcefb370d1471b7b7614b6b06aa1533319b55b24cf5303584b3ed6a29d77c3692933f4a50e4e455edba48797d544d56b2eb68ffc0b87cd666731cc6ca2cb65523d1d4db13a481b5a8fa733d253459236544cd38c4920ec2f012ec9c80a52eef4aa9d5e177fee2759323bd5fd9691873b28854e572af804790dc0df82884a81421ff2d54b6846b3998a554f9e0014fcd4720b139155a77055c6d7785b3af230b191ed5bcafb353563418b0498766369fdf988489358bdf58f52efa599440b03206259e2851bc075e81e78c202385b5ffa792c106a871855313a585645a398b1c980ede492593ad3a62737ceb3bd901316cfe4570b52dd9d7c49a36830baf452c0be304fd663d9fad36068d788bde520d1e74edeb3f88ea81aac86f8628b333b144b28307972586e383937a30089c600a2eb8769135d3b13ee104a09e1a50fa4df65094b16603f28589203894f2b778cb27d243ffcf2b35978fa802a9cbc1fd3c5eb00636eae892f14b2be28e310e8aa19d53f6c98105422006313fdac9c6c0a0e82628a543efcec028a511e6888b569463d63ba9cbc568d36114317737e0146294a8bc3372d912d6e8974845abba89de42d9901176315233a1af2b9b870356dee8470d91e1decaa30a8bd255ac0fe77a124046b571897a66094f80855ad53136e48aab3ddbc94f147e50fe8779d4390168383dbdd57d445ae78c55f5465c7be08f026b7475e16285938dd320c57257281129d68f1d8deca6681ded6e8756312fe725f78a946b16b566225b91d2b7448e7ba4b630f46907d7a97d7833d18bd0f984309ee3702e939125293bd7a6fda49f30c360c112782ff08729420286660716061ac03aee4a307d1cd1c4c32b63c9c90d76ced6ecdd6a0183b549d5fab1fec8524814fc8600666fb8833cce96de7113afb9f8cfa64c10c985dc7528fb24bdf7bb58e45a1b57baeb1d10e391bfda764f54cf9f923c5fb1610814e704ac5627629875e3eabd1613492413f3802cdf75e41e3acb61230fc51354ff0db2ceda4f33d2ea0ba5fa1e908995d9516575265fa5d6b4545a0f655ee45da89ce04b2bd9168aae4df0e56246209e7f061ab44fa21f07a0d24f7772ab43183c2615b78ba41a06ef3853ab173affbc67ffbe4df2614cceb2bca3c5ab4479feb53060743f896cb770fb806c941f405fa161eb6dc07d44f134ceeb82b2e8ba3d195e5450e37e08ddcc0c28490596e284f8ca21c96af9bd332dda24f0591e091c6d1aecaecc1180d693eb8855a87b54521433d7f95558bedf9c63c007ab57c9842a6de5662a589de2b8456b7aea5aceadd9928cf30d9153c338367b5c4ebbed9da9f22975c33d0e5e1f95a4f78bb7bb419110f6a3a7da787ab08515aba18a8e238fa7609880879a53584fa75a93bf34525115e6e4d50e0114b8f783e92383f3fad260f19421eed861c7d6ec5a75776a4eadf004c5aa4227ec4fbd04ad6b686baafd55ff531141a0ce20901cb877135c6c8230eb540423833ba8fda80907bd3d72bc8beeb710f0c68bff7814795d9876a7d970a6cb9d227bb9940b0367637732907b0477ff6274e8f43e507189d3ee36c162a435be48e247b0a214751a55824d5dfe0d3f3f03e4924fb7851b77cf559231c46a12a7aca36fbbb0f54e02f0676c6092a965c1abf51943b1e74e8ccc0f4b3e6d1d4861381156a3929d6b7d2daa53776fd377983c4f7111513f6ad1368e5a2c307c112b4beaee89785d061f44a0081ac697467cad87fddd5c3414fdb97fe8d077361c916e8e0e1af67f982b577d965d56171cd3dc41d3c720f917e983a0c7487c95f13e60aaeccdcd859c701b84e21e6e328d585413db890e33a3d5434d1d01296e98a2fac78b0c911367b4de6292f608f657a7af5ee508d3c89a2b936a9a8838b28aad09e4b194c43d02eedfb61fe7d1949de4ce4613222a921de021255fa96c7ffcd1b1871f58eecfc8653008fa45d28ddd1ec0a21204ed67e51c897ed20d1d1d3902e7a9e0a650952a4a50f80099d6d5ea116fed36339e30ca05114298acabe0089ab7d3b0c19e12c2ceefdd4886ecefa4436f054100cd4f6f0157a32b92ba32d84064b3020216767def74b3069376bcf84ff670f51c746e38a1018fa8b2487082e7ff80e920ba8a617b1a095cbf45021a4d8fa751809cb96624a2715a9ff7277f2d097001699fd4b6e1378e7af954c5857988a7b28460f573bdc840f9bd201db927c5ae577861c2f07d2adb2d80494f9f557b3f353f1a4b3dc38f048fc48e26c6b1f59c19526270bcaea2ab7c868d0b6e749fbccc67b87ac5552572d1e2815d4a9926595944c45ca343d729f26d1dc43e829dd753c8c4e3fd066b888f9399b822a4cac4009b6315d9ccf3657f5919de19ca31ab1d7b683e52a966172973f5808aefffd3ab96b4fa2004419386f896f1662d8c8f22cddf42b54f130271611ec8449b4fe0399888dfe0d161522a214090fafd513b641d20e22152294983c709225d67783641fc049e92ed029d196f5a4d77821686f2cc0c12f31ab6cb42b8dc3963994d8837137a7399f6447ecbdee09e3d7285228bf9732b23d56e4e6a0e9a66b6b38625552fc858f3e64ece01ecaf4f1a2e106d960ad4add448a723994eb93d30789cec92d48245442e42ed5d9f5e564693817529312c74ca61191442e09e0a3faf38793e2e493a9171382906692bcb5bbed1cc9bc163278bffbf32f7a939a678ef0458a6155979ab6ea594daacd6abb463c8040c66552b63798f6f53aefc34263d8299fc112a0ba447d6d1aee449c13db938219324510f58c69ec5e1f6029bbea508cbfa302b27e5450aae2b2de50d9754bff4f130f8d88e21d037855a2dd78283b05563a584b89dbcbb8438948565b93ad84ad50e18a75600e90133216e90e64276af95eb2bc63e21535e5853b9be9b63da44eaa68e81dfcdfd5cf1b335071e263e0d36125484aae82e38b610dff0b125e5fd1584775dc1c816714f875b19499edd70d5126b611f4b419aea769278679bd81fa22ad3b1564c262b7df5ca0643071e697c8e813d6bd84dcdebba30ecf44178704591b35c825e8dcccfefe9f0fad03f079413bd50a68d9f83db2087d59bd1b41cd7f312e6db3023f893550cbf16f4c694ce0ce1a521ca25e26839b0e6d34106341c966f62968175d10b9d12cd18f14b028d6c632d85639738c45ddad0d57d4bab589b6f362a0029c4fd739012f08effa57febe7a9f02081208b823086282c01d042de8276ee072069fe1bb6179de9d90d213cc97dd06dfe8564e75062dcf191a2aec74c683fb17f250418f5a502677e9ee0bf90e40cb0f5fb0d80ed1945f5f00f0b7047a3d46dfd4512bed749cd8756e43e5540f826dd683562382ae23c8a0cca49ce36867feb1dab5d0643ed8440262cc81e99a2d5c90e838b402f2b3a59b8d8ca4ef89aca2801963d4f1d4c95927fa278207bc9b54de5a11fdbe67bbf3b69f255bac117cef6f7c7d095e8f2ddd2b9653973907faabc23ba0adca0906476a29b828177f2a83e30a1c4ad4e43fd13c43124a4379b7cecbc013be4dfa941751ffb2cf0ac49e96ad2dd29e36f72d48e514ccb30eff7800b1e07e53066397cb93dda817573ce9b12b64fc3ece2eea9b76c8e2f655177b9267d5fb1f375e644f91071db85ca69ced861564a5d0fc6ebc80d9b1716df61b6d10eebc286986e82fd667f5b509bed1e4f444923dfa950881cce1c3e424adf121d27cef6067fdae67debd364d4d6cd7795e99a4bc969464ea3c2989200597999c51962fdae22b931f2f9b94c7bb4d699b92d546aa330174188eb17728f9289c17263b58b3ac0ab2577e60cbc124e4d9ea1a76a4ce4bb5ac0530720492efb6906c41080d7ead4270170bda41dba412fbdc7b09e9c11767ed7c67ca8cf1cb21e655fd03caea099d0cbcb63e43927059dd5ac74ec5be8b8fc7eefad01d0cdceaf08adc6fb8406952ebfe0bd580294775e41c486d3d028884a75b25a25035e111b5a110bcc1ca8513f4194ee6ee4e64da1a2583fb812bf7a5faa7ba69f9b24ca195bdc6f1f7b17713dec1f218513651489c9269c433425447f728ac2e216429f8e3f86c9e35d5aa3a8047a13ac45093bfa21d89f98f4783560ac4404f4c5e46dc37ea2c6ec4e55beb2ab222423ced04866d928958be90e2d745189a756e6f9c3e878a72bcb9a7c55af801de4a51a6845456a52de199bc4a1cf186334431466606a0d349e994a96c54e03286112f24d248243e4481e289d4932b67777969562a6d6a07741b29105d0046b65880efd19b7d3870bba9366b4efdc38995258a2a4b9b64aa3e8b8c96e3db31569e0495202e1e2aa0d73cdf06c77f8758d5ba767342f22904925ddb9ea68a1c34f21e4a8ed283bfdbdd0e00ea3f8bcc8875ae023f61b0dde5a7d8edef57134ea8e3e069106082e68f0a1003ee6c03a465c7ee9c7e12473984a74a1a133a873369d65cbdab9d17ba806385021a579c803ca564921ae9e1a0923be02b44b2a69c19f0f2e9d183cff048f90674245f72cabe7c5b26b341c1dba2e0bd5cc498efb7deee02edc19929554cc894f396ad413436fd150668392baa788b930bc3595d88a12fd69089e1c2c949df34abd739f9e34c1302dc84ef19dd5e80f84a4a0a8fd8ecf1594310014a8749d39eee18af30264bffd2acae5d13672db64f531eb910d84c7d25b962af2b5af3567f009c84390a5fcef1d0524fc420fcc46d6ffb57df1c9162eccd44f59af3fa358e5e2f3efa4d0ecd0b7111105e5afae2a55730522c90b6cbe016f9598a87a5227701e147c19cbb31da2de17fa9511c5e11ae01e3aac2a3b412d3f6907a51146bd916fa94fa0ca120d10329cb88d9d818e62ca3b45cc91b40e6f2b8c88cc29f5673289cb6c50b70008afb2b238e46329bf1352a71fcf2ff7ae24de23242b8d386534e1a0a8a3a506586e65c33907d6e19a909558f3c3d2aacbb41ea276ea8d11e977b51047d1e26be68ea375636a71ea17bc46565db16e88e0647200b1c214d29cf6558e36291ca3a006117cee4a108e8916dd8af0e7b1c83a18d662f743d464b9fdf8c59de599431c021a1e6705573166b2b190456bf14a5b90a77128db83c5fd9dd56fbe79628b1d89ca6c1bb6812e48acb92cc538cc42c51469289cb69c148cd7be9a5d37d26fe8fb9f156eff8d9eb88188e7bbfa3fe4a7686e800107d954d52912feb4915d6054eaa171ce49a8a70fb0e9c88beb8d2a8198ab479c2890221edb1eba7ccc5ab9837c529f7b4d2e30bf4fbdd6e5260d1439f9de927528871115fb8eeeac3eb780d6ffea79d72c28ffcb2881eb2a7cd1cefccbc7a597303754b4cfe82ce10d9d644d336b265e54886e78e7f954d0a0306f7840c8ec9f0f5344eade508cb959b868833fe6284f15ceafab2b884223253d57d6a97faf658a8993d478e0b24c7ec93ef35dc5c85b31f8c0f35cd173d8b847270afea5a2ec0c85a4a724ea7755205202b66b68603b154477693ceb2bb8db72a4f8c4c55a0eaf44f30c785104d36aba9a96cf61eaa53cfbbdc7462a35ffd31222e5e5f420cc78bb775ac3f37f3aed45784e49e330a83b83d9d9d467b2369731e69aaea8ac0f21d542b64976aa69ce5f14149b1d8db6f1a99470c1dcc0ab5995f8dd68c8a528f4c2112d4cdc59b6c396897583346d4c7a47752957b9c59ea6b58a34fddbb2db250633b2c41da31fc2db9b6627bf9b97ad985eebc70b956d43cea8547dbe8eda65bff985eaddb2197d69e006797dcbdf45179a133da9d96c98640c59379110ab99220e5e9d1918684fdb30fbcab520701de2c4afcbfaf27bc954956c823098b2bbd60e38cc6b0406b4b3ac80cba79c29390460e9f4cd0713dece63b9e72883fb5a97ff174a0d27406f79fafeb874a7131e71401da7ae819ea0a3b14fdc7b339a869902ef89857a15127a1f6944b7e9f38b6481bb334649c68059961b42d9cd7f1679799ad392c899834c5006b7be22db1de5872bafd380ad17ef57d6990bc903cd23f10de33cfab8a7e95bbf78c118610e3bcc7140acf6fe7774d9bba8fac90abaf293d5de7f7f77369b9c7561056dba996f571c6846a75c04d40e3367f705ab1ccdc921fc199e191579ac86a94e491f5bac844aae49fb41b51a4112dc442b08fa60672b18c7a937a58d39ff361cc66cd16af905b2f6d04e980262faa11e70b49ca22003cea6ef0d3e23c8f14a5dc2e53f04ad1bbfa6e0aa405e3f22a1b9c4136bdf89ddf8cad38095e0b76b11eb0deffede0121fb91767369f756879992e4b94b8b67fdbe0585aa8a1dade18e6dc46adf83733b530b9ee6b2e29334b984acc6003edb0566820875e3df0227f3913181369322633d264a7b84f12832cbed656486e590652b4105339417eacdf6d7fe75f989b0e736e2a415a41c3876d26a1bd8b7738a9f92505e033cbe959857465e4e9114f331188d67df999b808f25126c66e00d90eb0ed19b40f067a3ed3fd8ef80336f61256bc732fe2a947321e57bc425cad3a839c0832e6e22d609ed28390447701f8921651c4d80391e8ca43cb024d974b448b3c19a99f4029c374058f7ea47b49cfaf24e04e10894feb2078091f3b6e859b1c0f25330352c01e969f73767130237b3fc18d33fecff32203de2a49ccaa0f743e0a29d0f4fab50373632f6327bf9077f4165bd3ecdba56d7a751c4682f7c3675fb244eb8f156298792ef93bc8735e1b6f6fb00feebd91163ef83d0ce24ff34bd7a0ab0fecdfcd42de5217dfce6705f5f7a53cabd25b11d519ac99aec6d7247921e906249b645d1968450ffa4663b29ee42cb06cb428a1feae81b2d17cecc9495db543809538bd51d898736b4cfdb214be12f097ed82ee260eeb44aad6e326806cfc23632a7270d837cb186b808f6c09d686f44cd91286d8c025df0d433d00bb92b07fb56c0db3247ed6792151412be9b77bb32d70e48f2be027b159a264e104b39c5d0fd843d06826d7bb82929784cb38f2e981b09deb32c545d6cff8d4ba0d60222f41ae743c97e8ae96dc47466d91a25399410ca795da2748f9b9514a44218e0ad74d4635f522638a49dd40b864db6b210d23b03b654de152a4038c883089d87fef905ce1804c82df569bb0a9d98b0b7bfb431b7976a5d26339a1a38e0e4cef79d4816fda7d37949ab6cdc3092d6828c97115646f3fc066773b0a5e31f115dfd131a0bdf36679a4c5c1f1ccaa4669c4ece2ce9d6bd471ba90d9c1deca3a8a718e14ecf8137f606d653cbc34fb3e7dd6b075e89d2ddef8da53a4e45dbe63f55165c215e62ce8c8fc07ebbc66c7b3a20dfe034c20b0cb7d595ed4cd76e15fd6ab0127fcbcfad51acb432f0b734fb16ede18ddf3af9acbde3798c109eee59cb79bbdd15714171c3a6de9859d2b4f5d9c6a66621e8d4fb41cfe7302051aa3dd4f54c0b5994fe4efa87e6f3edad77db1e75bb6d666f30bd2617a03d6a00b445723d920c94dcf6ff271a895afa76f73e6176d57904f9d51e3a655fa60aee9b45865cb656a839e12a36f54dd633250ee76d356f753940798a32468b6df0457019939636909bd65b0585050d1207acfa3ffc8cd0451ee9143bd476e1123c420fa9ebbf637e7abbc461f1880349304dbb24149071409f98083c11f1af85a43b47d12dd3c41f4d3fba74d94c8e1c97965001dbce44f51383c8eb77546b03451575834b0e71620b55f3f9c19c737d56b1af0fe760e1f29358a44d75f6ffcffd396d501f4c882b7a4044195d79ccfe1e66ce460c739d9204598a90b6417b4a1d15aa5906f8a92d87f7801170ba910df5e0210501bcfb0bf9cd1faf27d0c09d143cdef472aa6cc211e88d6a5b7c9e50f248082701a90afaad3447ccfe452a3de51ff035dd92fbecc54999ec908904af2d0b8f7628c24be4440033b756b57fdf21b0a85592645270e73adae0609c211adf39ed2b722259140b384f9749062f0ed1cb1def8667f04047915336eb707a8f1bd4e7a04d4c119d33fc7ba0a888590c07596ff52e753fe26e15994d6cd806cdb9a86069e168fca6b3a0df1d2d1a4a9eb3e37fdf5736f76fe6692dd5cb67ccdbd7a4f2b0a7abbb489caf58845dbe9b6e93666cdd90f3a28a4b1ff954724bea35c052067a54a2db0f62e1843ac126c3b01cc37412010547c08eac1cb72a603725aa753f8137b999858f5f89a8c0442cec9a466cb4cafcf8a10e6b2694215610b6852bda5908331ddfd83b5489a83db97d54667b1e2a356561fcf29e6618b09ca98ef0d6bacf0322d9b932c7bc54d3c84c19d9dc884eed67b9c256052a1a0972b4da13d3565c3d0bdfc5216343a4c5779170a1b10034bdb7e672266e6e86f9fe1ae0a2c5bb61e709ef0ac34da3f5dcde2055dc6c4fd0742df50bedb917253cc7e6e4a2433c54a4faac5dd5fe419e0bdaebc8af6158da517a3a76685cf80d8355d01d4fadb9bd598c919c8ae3c21ff108d85f2b106176cbbc9f3776421f00a8ab4497435e3aeac0f8468531c432bebbba585aad91deedebb3f8564c2aef3f066c95fc8672d083c396e803ea0242fc50ed70da4da613c879765a3fb23c5256e21bcf6528805d1fa559870b2605476ba019deb266ed62bfaaf2ccaf21e19d70945cce8433729d98df78b6029126cc2deb5c65ecb240a53e0660d897caa0a03540d86e6be059c37b917bf1d27f8b7f7516b8582729684ab3f9fac719f0fa2742d187ae83716ba1c62e8bc7c5b88f67cdb0e7a1d0881dd152ad9c5d7f73a558944fb61c0b6f650e7b6cd455ae5c88bb492432c6b118495f0db3f16253417c0b6048de49fec00925c05816bfaff199ddde6188599ec59a7ef98a903abc56906aa770594a090ad7bec938a4105ecaf52982e15376821abec54590814069261c4d0c2b56e31c440cefb333aa09c0e5921975eb9b04b7b838e3ffd7c5e2ce513f57cca242f1b3eadde219ab1b49a6c1ef60f3cc4c91b6161e233c8c80883cad81ce6085502cdd32c17bd3e678eac3ec59b76ae8b9d28fbf46751acc1c8dd5ff2e2c8d63a358bb4b7736fa7e8268f5fa351cc6eea2f3bd3df781ad1da8c743011534d7700b182bad7a7d529e6099e01300614b5275dd56dcf481532d555a7e88184fec8709f568c62a1b19379ded1892a140d9c8e87cec6a6bdd6074de3741dd234e4f2c19657a796d8b67cafc310ee02d73b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
