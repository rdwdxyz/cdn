<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c05adf6baee55b5e0fade5c1f07fda97f9d9d066b793cadab3b03e081008b3ea195af73c88bc943157bfc9ea8a033a7432378c585036846e030438beea0e6a40d751e5a0c91522577ba070f421648b89856ffc3d9e8d028e83894b877394ae27d52213e3c15c3aa270ded2c6cd12881e1b4bee63da810957959903f30606a6f50611dd65232cc4c863675388cfe86c4867749d657bca2e593580485b89e1879955cda43f886c0f7e6522ca88194d182c167f244983872bc643357556034bacee6a6b9048a151c7f5bcf6945f8252a1d7c818689e6c9b34a74242953eb1bd708658d28d4defbee7929666354196e988a456cbde28823f4c91d60754c44a26c476fd9ae185960a671e5f95cebdfa34a5138bbc2799806eb7bf87369fc144a8d550a39b90b75554a8b2d4e3d94c6690aa39f29d18325b1a78325d94bc49a0509027877c8e2a8bd6277425585f7bdde9f795a5daa3b8b2b7ddbde74d3fc02ee8fa372ed6d943c080033ae254ca762a093c33b65334733e15fadde81c2d1d238cf060f99d87e2e08551aa8324371f37bf956da037e21c6b7a61c096b2791f51d546e1681d3d4808f9c11cdebe424166ff7eafe5865ca149b69676aae49511b31fd689ac4e4f1eae576de08456c0b1b95c97c914be7087796701d6404aa0d26de15eafc43c9fdbe2e835315094c2e49c6d84f22d32c0f6b1d157144763b07d6d23ec13b0a17fa70aabc74f995673d5fb365884c2ca800e7681fe12bb49b7d0535938fb5e9ec37cb8412061bdacdc70f9c745b9a69f9b73b3b925983395fe399f0b76107c978a9085b73f9743a1e6be45d609a66aa158b748dc0613a9e81932f444ee10ee113ee8b81c7e091ae7f8eeea95be86ffa4878dbde79a15e796e5c72c124bf4d7c831d56212f2f9e53c114bfbdd80dace54151d3512bedc25c31fa1b919317de5979df4fc6e1f5911d1548f278672b058dac706c8f1f9019c5a5bb674221caee3c4edfdc237fc8213ce5d55d0500a588687ce5313574a9865a9cf09cbde9323d56c9805ff935e274e71c29b76dc1b26e079f13c0fc5355033ce27f5b4ede32b32d75b06c4e4451f48c2cb6ab071c33450f4e53f62025b69d95ae3cc6d42549c0594d4176719edb9c6a6e800ed0088a98b5cce2407ca2dd6c157a7fb5ea9ad99e8dac658f75deb4e8aec2197b1268103587dddcd2b23a61e1886d018415ae3a31c019d359c48f300b5bba43eaf1273cad1ccd161551417755fd6dc86bfcd28811a3c0e24821d1fdf6b35abd88a24512a8d3fc488d13679f10045b88893f641e99f8a88a0e4c3d838bb7165dc699a52d4d9bec5fbc52dfa4a5409a4e6c9c8065aec93db8b69e26adceecbec0e3492a784488af62d9dbbe096e558c6a46fad073067fca7d47b60b3f5eabdbdf1cb59ed42cc402e211cce8f6e3f392a0e22dcddbf9048bc5a8d78e9ff07765f6d153d9fbd11f9b027293d4b50e205210c5ddb47d68225e115e9036ff82e763a7df99fdb6a81e92b35648b75bf39e76e3f8192209cfb775aad8ac3edf89b59ee7cda7348ca6dd6a2f86c2429d89c1b58211cc9ae3fec7a8a30d227a37d36aa123dc1ca6d6af2587045318bc5dcad2558bae84143b8773c0f986c2cd7b508d69927b11259d0f531416910c7edf802e052e5debdd073d9ff34162a43251257dd312b82b124aee25b501804839a3a45a839c38b948673acd2d48b0bd6329ba56cfa5880e3f9af05757f073a42f57746ca026018f805f04742b425993da9cf5ee9393c0db1bad0947bf523bdc2479e3d359829c0635d39347cfd12c85371e5562aaf811a6c79840b3483057d8a5a42fe320732070471825513dd7e003ab83a60c3aad95a438381ad5dc60ec00ae43a7cb00afe60fa2837820f806a954a0376f05fb24ce6949e8ace544ca203e46d122403e620e68f5f18c7331fcb46703993b126c86285a3936ef5eac724e2b849011e35c6ca2e2f00da80326de08cc6b094afa9bb95231f08557847e519b3e59bde70f207860627479f945affc2b11aadc0e266699f13c2db791c62d569e52bdf2fcc46285ecf1374519589c5588dfd49e9860f48cb22656b3662fe978b90d067aeadde6a27e2ac7ef139800c8f4ec4eb31f9b1061fb4b6e80406667f8c55c612a66acfbc10156880849ecb935c72e17e21795c285cde075dd4934452a81a81e7c0b35c04cd413f0e3add58cafa31829a07105d7d16502c31590a49a02aa012ddbfc3c6922ba6417e101e327cc43c092fe610b292d8aa161b8ea6e81fd25990411c92a31cb684bb24c61f2d73de2e21d9191f0908ee420e6d83acf250e62a2479f7b077e4127006858cb485e445b32a98a85a80ce3b55fb5196ecb72328976ee60688ece062f90ce9d990eb26ca5784f26617f2eb991b688c5f3c46e2bd3355a5a726eec1ddcd8b7b6f90d4819d66792251d55aef415d7dff0c240f7571183efa4ecec39e9b6e5316cf397b93f664147a4621201c6f09eae0b9f74e854da76b3e7e835f129e3ca18ea0452472e677e0fffe971f7c6d3496217a7a7e74e43ce5ea65c8b86d83bec24e4e89b364c6bb2f21816bb782b1481ce0968b076f658c298d750abb3cd39a62df201dab969a0c20bd5d17f2dd9bf591fd4f4b6454a0819a8b811292c3086913c055dbcfd9fc87314c39f02c3612ef546039f5302226f0d3921e51de7d82897a8dab3494f1e293b30d1bce0eee54e5113843b5e6dc190c5b1c839f0f1db5867ca4f3b90f5cb855f1807020e3d8464fa14d33cae6383a8c65418ade45a54d40e0654613c6dd40949756249d9210f42d7ad1a1303f8fff20bd7034a022124dc0422310fcab4877b1f4cdf3fc99d2b8cb4d12e145900f562bd1807d689c888f3012669617bbd9f12523855e1f4aa012d5c2b0af28a3a0ef97ad2e97861ba95f9396b428ed1e622c4e11bbd552a4ecdadb3f6af27530f1d40ab644cf69672e1d827a27a19aa7fad22e2613867fe902247bcf12dbb9d332b405a30c71afef8a5a7f9746e20fa6d05d7da9d044595e9a6b0dd72a1d8378a3e9c89ff219e140b1ed0b42113f57180f7a7beeb7ee3be21dadd1c4a3c6a6ca6b00bfb40205de4195344ff7fce48cf463c5632b3ab31707b319771f0369a83196cb81ad02e75377af1f14e563ede960185a39a11174c3c6910f570d88791b1ab5ed0a9bb12b971367afe8535ccf016ab6166c13b30db9bca9c26dca614dc930c68bbf8ec43974a5f7d8c549d3ae9143aaa856dda08e663bf3d7b4dd8d0f42a03c8435081f832ec0b4f72f445eff0a7d6baaff37a7bc8e2fe5a4b785246d252d183d06f42941bdeae555e5e949baf95d3d014179fa4348caf3dc1c492500c46c0e90dc41fba92267e0baa965800ee1507651351cbc97116d33562c7194900c98da1266832b41f62ec2f40949ef886479ed563d60f45eedec1dd53925fd501ea36222ac4fe32b8177adbc65dc1e2e08ef9b3e32269c64cfa777645b50d28bd18bc37204776b7d3fb67c1fb0e4e7bd570f0d8b40056935b8f04b8b9608840d51d813870820c18cc2aa6f5c61d7264158fdf635dc8ecefa93b47087f6326371f4ed08ad26f225f1ee51a472c2c52d65097ce927c671df400b17a0aea4bdd07a9174014395e5e01b77d67020226993514b79ae0b5e47551f349a734545077cb6491b5c381b9b5b59df56683655ab424e201d5a19c0fcfcf352bd7940168b58c2fc63e191c4ec9c28214709f9571f29438e28aaa25c83f398d427ee82ede140b1ac89bc1f36325f77630fb1ee863b63e4810eaae1a1dc8ceeb383af0c7025fed10308a2c216337595f664706bb282ae63487009f355118cb882b03b66261db4a117682e53be451c769843ab9dad056d852149e980281c072ffa86229008024cace2c992d8ecd0576646c0288874e1787e9071ec3dccb4173b044f09decd955220c54bf3f67c02072aa6f35029c94e50d8a23a8bc60d7d3b3353203f1f9d337b285bea1038ac2bc98d249710d30b9e36f7899681f63e3832aa7734bcbcafa0284d7eb2ef36508d539db8ef63720d35bef3552e4c16a443ad9af9bf84114bafc753c8f947817ee29ec18d547bb69204d5aaa2a58346ca8a1292e1dc4ba91bb90569ec9f6efbac5af7ed8bb839706ee9661cef008905b8fce5e4860bb5dd492c76c33b7771ebbfcbd43486a984b457040581a894dd857f3245a38aae1f24d6a10ff2735e43a83f93b15f0fcd135137b2b2a9920b036754477cf169fd7ad942652e555d981fd2d6901b6088c1745a191fed42ef3527016e6ed1ce88cd006710d87bf085958b1ea7b70cb232fd2fb8b62f47018130c2110725e881c3d6b76fd1bcb7978da0f3528c21b02f9fa11128e8b787852e63779390bc14f7d6fa627785079ce7f163db72148d5e31bca43008aadda4f1e43a03373c8444428319d410987a315359bdabc31625f0ed00038207dfd4d01a0c1db7d91df4c3d886b1a6a8ff6ca5bbdf8cf1a00a369f07a0f43141f1729f312b114f19b64c5a19eaebcc457bb596a1f14833d9153c35323af745022b1e710f53005deacdb97082c769639a720a8c5f924883ce93b4e867072cc75c9c0ec0adfaaedb53084c902a148cabbcb20a8650fd36afe93979375d7d39d71a76bcb7420f3b7cf9fc24b953c772c134f7cc5e0deb8e2d1ae5bb857e152c17bd0d5bb753cea623c7b896db3d9476a9a2ccd6e868c202f22c93d6a7177f4bccad598c373aed746c531923ee2d2def03d28ad31e2824f44b1ef279d6b246c533feeb2bfc4b47536c7a79f3b699e137d7f320e281e5b73e786bbb6d24502c88eb7a8f838bc758928daec0922ab490c233ada894bec4c2e58969cad4d3c5d94e73346df428bc39dd58abeeb1a3d27845aa7b0eedc7235ad0c5ff22f2b74b39a669fd1516d7481d0e4f701c39ad33df050c1f1acec43145feb66e741d940b1e65ccd3d762865fe5bd7195152b26ea99601837e8c8e60bccccaa524665b31312d0d7f79b55bd4e8147b26ef041af2c32de254056ca46abe8d3be2c69a63feae97da64b131878ea8cc7b07f5ac1e7b02cc8a562a1cd474fcc262f949c71fec61dd2768870a5a316e7b2c0defa136df080b08b7860954ec2a8460e2231a8c594bed5be6ef596623304cf443f9f18be47d14af6c424b55daef1cad07335066a2fd989ed585e31c607f0582fbcbf23715eaefa279d1f5e99a90d16ccd9aeb374bc8e8be32e5465c6428b38e4a826ef36bc612107e4d1b8b871be9df93f64a4878ad4ec2869887e63a5d543bbb5a4b5154944f7cbe6a59464edb6b7e8a91a2dc5eb62cde0a0ec9fcdcfcb1158acc1cd87aa08b4f737da5838f39461e1fa33aaeab273104b85d318209758f7c33a09b329c777d0ebd0406ca01e3214ef089f3f557b4a738fa8a2ab9009f36bbff713bd4c63a365c4fe819add29147f4d61aa7cc791dbfc563fc9cb89c52efaa4fb1baebd2ced48592db9b6c974d078b7cf5992f3932f3526a3e6ded5a4fa0f0c3151ffb08c2843bdeb928cbd9b4b101099818607136b51a20a6e7d2bc7e01e67ee028d8651ed562dffe3a59df2801b68a53550beeec165dfe5c1260d23ee21cfb7378d3322546fae0fb1d637a74e56af5034cc4c8e91dde592317cc6bfab12135517db4a011994ed33339d1f61ecfca0e70688db0c152db7f09c0827777d8371cc990774515c0b20de6f2c0ff409ef4470d3a920e47c2117072ab7f3ce3d4928b4948feba86ce71e74342e707621b929cf022f72418d674dc215dc04fbeb4d80a39eb078f7ad2435d821153562e74009b677e8602bc4f35fc216febe010f6f15e2757bc6df139f9bf8d493916d352741f6e31df566b564e6dbb29a190e1486191a977c11bb47be199dc5af8aefbbf166772ccbf73c3c034a2f1d23b1a000e77b28ada1d80b34da649185f8a9d760c2d2bb31a1264c75ad73510f424d22c1c792daf4ae650e2eca369c7069364e54b0d7f2cd94cd5716600840136dc93828316a5c8638a1bb9fa2981bc349f0586efafdc8ab7693b57d989c7f17581f60b6c2edac099f42ab16d652e34470fa66a36d4e824dccf3276822241c575960bc5934322bb37fa7d937d9c796a8931b6872552b22933ca7f64b27aa558d6197a90739810d13e7767a3610cc1f0afadf69d479eda1e2d6e1bb2020b6f796ee7974a1e19092f7400e62fb16dec8120b77fe54c36f61f5f99bcc75b9ff18ec13fc337959d04bbbc69084e3a0e07f0613c35bd7467d50372399ed221306a82c4cf8c22b866d978550dda4cc072419a32b2d2b77034c211d777b31c80f185c951260b56ee90d17d2443783fe82157cd6969d31c9ed7e3886a41fdd5377ba4453b793a627b4d52663ba9d25cc25917298966e0e8185b4405c25c35a2b66ee748c20f683d4fb703b66f8e6e4ce70ec9fdb2c82d6674fdfc2ff6abc5840a5247520a5a6dff35df6ec1394f6342a0a714150a12bb70f3d1f37f51e272fdaa54593c2cbad3f07b8e1368f48caddf97c1de542ff10516a4807f532e1d3af4ee66f5322fefd7a2067e8f63d3605f361b9174e5d86c1f033f633ac6e819efaab6279deb2e1750fd0e1c2fc4be229390a3179ffcdbfb0e1b0e71d286cb1455e70e55f24e8684e863b4f9cab3ea805ae2e97153e1085efc8c4ddeea9023e8fc5bc9db99313e8c1f8b4f3d4f13bb23ec990c3ee0011e668cb78dcad8650e28c7585c333573af4afb520881b0d03dac70c961e5c7825bed229305bb125b2af2a95e9b611f9055759f3054ae19b61e597512d4124b9f9c5b64226c13d1a37980a931654ac7dc460146c1ce97bbf9f62872aa05cb9864308807eb1b563142fb56810b02367e0e8ead8f75774a1dc749f03979cca1fbedbd66d5b8583dd57b7cb8f4004a60679802cb2f5e4438243f12cd636ef83b8c1256d589152367331b65ed61905eb579a41b903be5c9c3520279a8f18772b0df6007d392792710d5aa904d9ccefe7fadc78ab2ded842c318817e85b399e392fc03c01b1a8b26427d85e24f515abae929b74c011c43738e91d8f4850ecd791f0eab53da18e951d4d61950c7f8d20fee1bb1828550a2e0614d8ee1c8caab1a428a1e911867b12e491e5618c9cbaf1a8368d46910dd06e8fac73dd2ee28504e7384409f287fdcc87aef2c5081aa443c551d6ebb6e5b0a8a3ba9a310c7cc998755c2c34321a5dd61c33d88749ed97dcc8d2a642bb22f2fbfd85e41c246220087a051c6c88cd4ba1c13fae3318a810fa09cffe7f7ca53b9544019e9d003b982904e4807982549a43d6d99274dcf3c49c0bcc2335e2342d6017554716667d43f8c51b6f9b0531f5d86c1ba46eeae127bf0932a7c4562fe4ef58931dbc06b8aedc8c29c52030974575949b07e36e0d04814d59540df9ce7d67bf0d239b69eabba6e0837be796d2d4328edeb8af1ca3fc8a75dfc54b28a9952edb60a02e6701e9e540c86d5aa8742f2895ef3b85987ba645895ef450d64abdbe50bbe2fc41365c6288bec0d712c9b968300245260452226c1ce6e018f667552174dfb5c93e86a28ec87fb43bfaf877dd8197b32f7edfc7ee2461b19dc62a63913ae3194ba042cec371779d8c18e0b94b2b6416efe8b7402e07bcb9f0a0f588bd451b7c3b92417cce4f2de5eca3273e3e4f419ba12dbeb1477ad63a03cb4a8436336bfe8836d19ed6acbd03681436920cbcb580a61e935bbcb1d9a76ef5b6049c2d955876b6afce76fa4655df62ccad0a8b33a3769977f3c3c2f9bca68e5bc77528f8dbf58642958944447f780b641d3e73df320eb6466c430612089e9d8ab94a7a1bdcec7a9a918f952331a0d213357613b0c9c69ba7408f3ff2bbc6704a8c04957e6d99aedbdaf0dc5adaaaad1269d9cd3a7adafeb3b54e3224b72a006a99d210bfccef277b16dd24be57e3025feb3b2d6d4dff4aff88ade23fba1b51aaf0379c1582f46b0f1f5450c23240d0ed99f7780918ff14eed002a4e6887b2cca0cb241506e4fd8c0f08a79779d0b314ed67aed0f80139e8948e3c216180d5381b4344876cb66f70a85b65d5ded49856de3a46fef20cf1a501ec3c8cd7459adea57140fb05e06558700b59e33dca1ee5917b139abe2ec1064bdf355140296010905d2e2d2f94dd9581183378d4640034d1ff0ee890b46d9b6706bd148acdb3022c535ddeba91ce097fc2c0e5e79f0e845330b016203be44bf1d9202ecbbb360eba182fd299d0e4a09d57f9c3643118e4b30387e22f15dedec029c7959859e83b65b957e3a652c6582fcdb6a3c4d335fcad3ab51f5e3c4cde8136c2d73d51f31442c9af5fb945c1200f908102d775a7ef19eb18395c0117a7332fc935e59a38b3f5d4d7c5f86064d66376a05c05995ff2a8909540095936df403fb5b6db2958830eac679037d36c03cfc8abf0cb3b3fb4e4361368d26fdaca21d8a588a1cf3ac46881ae543e11a4befb9a7311d0106059213e63cbc0c9ffcdaba5a8890f7de6339136bd5181d19fc4cd92669cadb08a727f9421fafa478ce499d0400615642bd291d25b39817e388f9d68f5a89b42e6f7073bcc8e1c389d7ab448b9c9374207c6b2b14d7c4ddb006186e18113a280ebec4bfa755b35e00a60f29e903b325e18b20b4f34c3e0c6b8d4fca7d7212b1fbea3b77c5f12a5320487cfa6803ed23eaa60733bab2d601fa471997ded93cb41d55ae3f26b43d57c3058c253f88cf62870ba17819f8dbd59625321a1f5cd12e10501104fb353d4a3f086720c19d2878429736041007252cb44fcce73074784eb8e09c082ac9e43dc86cc2e8798e9571cb82f1642da805d061f69284c4536c420a903004c2e9a52fdcc18d304013b6e1bd915b98b330aff1c53e7b4c84eac523128a8303cfb966e3af6de5e59f62919a45d833145427eeacc08c376238e92e6c30bbd14742ed24279119cca8703ca7ac015f7dbda348e03d507e9bac7cccbb483ede22ed20ef92bf500230792fbb847cd03c8a08eb730c5bec7aad7bcc25a7551fa24c687351a2dce39503166788a632e4e42f4cfdb103732d3c31e045bb1336281df5bde03bea479de62e9f3960ce678a2a427d2d7d49d96dedb09348b1181f202dc7b05ec8cce9ac4a43186bd3a4f4acbc7a6c7edcc3bb6e0bf2c4a1e7328aaba1ef80c070c36f64c5c659d17e81b27911ebc8a1589f75eb507155fe574744e50b86b36b5041b2887d7f79fe074763ff334f2dc75f48000e492f604e65dbf9ab2e1c7def409ddd0b05c229a9e844a3a29824c944ebe56d8ea697efcde7beaba344b15f6b6c9b171c96b8bce08cceecd2f518df5afff72ffb9c85a5f4690ba2037b69193ba5148e905719aecfdde311f7b0a82984455a4a2f0b0c27cb938d293e7d0362f2f762d4ba93a38cb297f14524385c15562c5b0142e44018148e962ce399736994f885e1b1f8453294a86171139cfbf6b64df191ca05eb038491616e4fc9ca86453acfa49621a35b85748be5d8fb1ad32c419c87803926683a33fd515bc5e754f45f83005d6520247e468858a539e95aa931312fb9b0286bb7124e23b4ebe9fee4a1ca209f7c3b80a705f1cb651145e6ba9a6525994d9079944026df30f282c5e736aa69af4e56d01b3b54732a3291726a00845cde3a7084c800da3d4e987616d84c0793b51243b20488b5247d7092a12483c2642ed97bbe362a736498190e871b64313ee8eca0fe5f2f0a967f4caa220151e292f7243523f0b808a419e9e05c155f81c08979071f1876a7f55d752ee268225c56bc019f34ab3fd248e2a384861e09c7a1b5bfb552cc73d82a9651a9fa0e9aa5fc4196747e9c4d0642e85f2c49efa1cdd6a47c6c468418c4320d94b3a32dfc8de70d19f7359a33fd60814ceed9a3bb16a89785639392cbad5826c2c684da1121d08e49f9a4aec0c69cb03e8b230c420d2f96316735af6aa6edebd8bfc783395154b9d0e0bd59c64c9dfcbd1edfb792637de374b7131f365050a60879c1da158118c0046669f86a61a7acbacdd441d89ce19f19d5f1d1ba9d12f0c7683f137bb778f834b5672b10ef4518b18ba9b7cdeab9843014475ab043cc61cd26fc96b24930b607f338b5e57b39dc6617f1f9e533f0d171d8417adaf3126fb5a2256f99aad4b0100e14c2a6c3ef7bd2390c2b980991cef0edcb2cdd9f3025fa943cf1a7519fd82e762f55c5fe24ff513ea58739b361f174bd08ea1d896045d4b9d4d3e9e8c09231b04f039ec522ea8f1dfd9aba4fe7237db10986e3b8e0376e769894fd710a508bfed69afa6b87832dfe46d40c87c412a12fe17741c0a68e2f1cb89dc51b9e7b4813d946d0832e7db5f887fe49c1170458f6a2f37a769c4b258ddc3ff978482dc3bffbba1ee472a97ed82b67bd43f6498b3d914f5fb53c74eaabb4ecd66fd017dedfaef205aa07903e00b83c5ea3b1043d4be40349a4387b6140d767972d04832b1117d99b397eb148dc2b2ba20eaa0688cfd85da52019fb06455ab8218a312fcce861e0912862e7efdf0bb5fbd2e68e7d74e254170c40fd911a43959a4480010b8fe44c7422d0ee626643000f130cc41292dbafecec3b0249f01b51e85ce6b9930c7db40ac6901fe1a689898ed8c4eb4c60d95c1ee9dd8f6dd57fa4b3476968ade35441af3e9452d7764590a9582721c3cd18bcfcb387649a17a26dc7d19d188464fc2c8127b366fa6ae6b17535a1306e310d9376c18811756a803e4ff8dfacb89ca3212b378f344f0c29174d9e8104c19353b5b1d1c2fd2d4c0394a212b1b34bb8a1d1db882740120749f2f4f306040f6e5f0406ef444a44dacec00b73cae6ff9c2cbe407174e3379d023a2a58dfd6931e6ba98a89b288a91a88e3d889f5e944ae870af9ff85f0b9efe9de32ef2ff8aefabab15839591c449109b631a3531fe9fc01093ffc3bbd0e5f8abd4182172dc08581f90d5b71c06df8d80540bad191654a7c4d78bf8247a501c93d2197bd5f3fbf832afade99588d23f1480be53563d0c9f0b7834833accfde426f5924de56c1e02d69871a695430e3d7c71a7f8567df356b6bbc7fb3f526d53a8e8bb035d301a85fc5978b486f8cb03fabb6bfe5e5a97f3db06ce9e5e7fc3cffa9aa6b00c2a9de1fa7ca8e5ad302beb4a3378ab319d5b2116231e34723dfcc73aa33ff1ae24ee6a47beaec9a55300f40e49bb4b141b7ff7a9fdfe9bb91bb49ff07db809b21dbc5d6aeeff3b84a1d72fbe331b64823708f07bf29103fc4c51eda373bb7627bcf44eae4963241ebbd8c3ee6f1caf2ddd7df31c50edf36cdf53e472c737616b05589945a1619772d3983489eceffc49227b53e327b654a931b6d05c14aae7e42e7dd72d6b9c316b30b21cb80c5763ffeb4cdbf20701112a78fff6e10982507a8ac2867ab5149f2dc7a2c9bfca7fa1390fbc09ead1f1b4cb03bb66f31480436b2569673b8d97de9e02416f87e7afd6713df1cf9cbf52ae0769a7d5857fab56e69a570aadfad7468cbdce64abd015ab78bafe2b0f82ede3820dce3b7c3d08b91d95a9e88997c215e73322aadff94cf4ea28b8a0fdc6989dde6c82b877dd6b7f00565527f0e23950e97ba75132b0e8205753c622840673a09bbc5a5a291043c584bc9a8ad2955f92a730df1c45ee1f30e90ef79d7459defeaa4853c6f4b69f59554ca710e107f21daf1ca677ae2a20e83be08611460aea422902676a7393690711f6f23e16eb3cfced8b21c042bf7673f56a1d6b7b62c2e5839e53161c5fd5369ecde34599903354c5ba622aaebed03881c7d589d412f636655a514e977f188d98a45254c5afc9f2ec635594b47a90ccfb3718642d56b9c99e9cc4e12670562c3c69edc65776459292fdd2837b44395f50805a00ee612a7871090177bbaaaef3b70cde81f3fb170a96c183592a3618bdecb3ba6cda312a92841db076c06f58c3a2e38321c7c33ac62f81fe1343772369d8703ad3e7163a74a1c9faba6c00325e4e043ddbd2e0232b4ea4ad539a2ffb1ebbe8cd00b06d547c22c01bd8b6b15cf22c31405e08faa4d62a12e94e1eef20d663cf87fce9452e4a2cf00f95a59f4cd179d847545a091bd3887d85afabbe13f6263f78192c9079acd72521df4d4292310e159e7748172e09dd104985ce79f11c82643728ed0ba18ff1f468bee46ff0e3f58f4c1dc7d021e527d9486bc2fd75e9f263c40f5f33865a4d5c730996dffec406157b91f6fca4115efdf7fe65a207468714bce86d88fb70c0ef7faefe7b35eb2b5318596cc0db5c153750363a3e5805ac9a952e95fa86f0de1058ad3de49865c4a97ff80c4a84dcdbe97b76404b420ef2cbcd3dc7c78414c994c073dbeb79cf57f17737935b70a55c79e450870aaf2cb8f1e9746ee2b1a9c36cb5a99083949a60be38ab34f6d8767a2bcda6372effa5a04ec5172fa5f87a7bcb87fd7ecd9d61bd07146c3850e5580e446cc2c06044f0b0f2c7725dbf546e3d4ae32d5104e4bd050f83ffb375c652ea8f6bd31390df1458c4b51df587706bf91439306eb796b43b03a5fd1c5215751b191ff86fa7296119d0727770d8fdf7388311917cfb26881becf49a13bc2497e5a4d28a62905763f7d034a7146c6b184c301dc64e5c9af979f2771f991c325b8d4d62a872fd8729ab03762d55e08f387804fb5524172850af8ab25ce74c6a4b9308d8367d77df67bae37be7c06e690fb9e33afecb9a9bed7671d90ea76b06f3d9ae9a82ae3d14d6c660fcae106d940bd02cf645cb11e1c05bfc469b4d7d643ac2be4800c2e1fcfe06bf649017d9437f44570db6b2067761dcc22c4ab6c8a792682ce213d32f08f4d4a40f9cb1995d0c49070692ba58d8ca788ec7783640d07bd6c420f7b0efe36f030324a1be3b80ecff33558e37aca47d747a0e9cfe96a1644834d28ea9153ef5712d10b5dd3bb0676bc2631ba8200a04892f8ecdd7a5b4d23421c9b67c7cd7ce72797c5941a4a0c47dc646fb9f5a8a5e02f20479961fd62cd83faf2561104299946adcce5125c972d01720d62046f25d45b8f99df04e60980b8ff3edeb2fc7ecd236f98781c5539193a0bcdb242a47782f2fb0c02121a99ff91689c1969e0f493e1321a7e4a74382cdcc4a792c2bd2d696ad4edf01d61939211f8d5b4ebe6f71097eb33ba432bf684b46c13f1aa4e2521e0923ecf59cb68542c56344a4583dd30ba86b6a5f3843d0a6b604399106e89784cd9bdc4d8cb705f3bb5de26478d47607d16b49561c8c1a9069a358bc5f75b62cfbdc35f9bc429b594b9d94c335797bb33be4360949a5649b11e16878b5798e04cb67309f4fde402a6535e5bee4ee1070310cabed0109327c020d2b054cc051131ef31b629d8a37de0be83be716baf3220ba3d2b6d67db4b5e1b5228d8fe00cfd3fa663886051ef3f48146ac869d93f7cf32a5302881ddc285b0e4f97c1ce59883de26e1a5a19a317e241f46f5615541d403d6bb770855da668fae08670c2eea9432719a723632da62e9da1aa0391efcb028bbe5f3f7dd4a7a950a11a95c6f6689962352797053dc05a3f110ff41fad71a58511a8350a2f7647edd901bf529ccd3c6f1e82f5c83e8558027ce27b335eb1369014cdddbe8c7a12e67ce8b9a5824dedd2637badf9ab954d48e551f9aed27bdb5be7d9886119ba9cae19e21f5d8797b5b64d2d8075320ba3cfbcb92f7cd3b104cd60415fc071f0cb92f8622c3241e2bb710172a0dc7989567d12773fbdccd6766971625a88e77fc0dfb59fff65016c8ef79486d114db7246d4447da721ba4f71a22bfaa7a6c5afd075ec7f9d30f80f3ef976b155276af7c00b73319f3bf397ad8db56d5e68d0102e0acdd88ce32e3f362b5f7e74f2636cc2e189f7b87b031cce9d4ec16971532c908f4d8dff82bc77487d9aaf941f2434d7fa30e0e1726a4a1bd04667a3db5fe3fadfbf50e7ba86ddfc9bc8732db942a72035ebb9f3a6ae93f2eec204d23a92109435bae73fde30c955e21c3637609d77a28de96b8b1009e1c005f274fd6a0ec438057b218c00a24350020af35637f7b791f7fdf55e91ec82521761f1f0645c0f4b397f3a5bf5f5072ec0a61803b3116ea52cbb38aad31a1e7522f4be47d98394b2c2bf380b0d969586afd160c0cd92da74d888df021cf89684b13eb392103b5d1581d7b998d2526c6f48a60faae231ab319a97d5c55a4a3a0f1b564d4e79bd3323a465a76ab07351a0b00c5c31f2b036326f91bf2345440ad10d08a703a32cce1d5c88f5e0d807c5c2d3ee1d843cdace2dcdf3354f1b94cd68212a4bf590d2fb1c717fb9e562c36a93d231ffbb1911122ddd82492ee2596da3823f92861af761610ef526f193ac788c5d4a49bf0990d382301e5e4869e7ad19bcc82122c726a714c632b19e6b7913a1dda8a5d85cb1a9f8c1a48e92cbcff3b6ce1fe9c9ab92ae1afba3e5ff3ef41cca60482df05de37659458242c871d5ebcf009e801a63431ebab889cf4bdbf82ce6d1117fc650da74884b660ef953145014f80a114735da36850c4f226837fdbe1bd73218fb2f7eacf475f4aac75b11e252fe0edb2dc57a264d3ec3296435fe3620525df40bddffab2032d9c11e544dfa2bc1e40f0ed3c0b129abdc4c33045cbff84ddaee50fe375a8863714dd810a9a57415bac079f0185a1c0752858a21b7905d8a7cff02ced3633737bb6bca459ddab0f896ca4c32a78f881e2afa2797c2197d3c5a67c7309ee2207fac0c952ae495134e53117af4326c557689d640061287cfc23216573b0dfc347cebb0ae44b1a43d4903b89d9cc791d5bd4fd4dcc2cacda4f5a78928d4ccf97fbcb41955d8852ce492e263cdfc79da95c649ee6f61958ec4a2d8cfcc349bd4b2758428c35282053e27c9476dcf742d98184b840870bebc11eaeeec3915948cb66405c62751ad6f56a3211e60491bf6575b107e6294c7cc0e451b19c58b1ba087eef6910c9f3842b073683b12a8d025a5897b82a9f9d39c25aacd25e5d8a51e24d070f1d55561f9f2bf8d2c1188c9539651682b45257328bb4ef6e548ac76fe42af90e944216783402bc07d1487f2b79cdb21f054136d9a6ddd3133855f5a4a6d8837a7e76b31bcb38f055803d817083876c31d3108d8087a628f4c3bd65638d0b8ed4585074bf7347e5fefec8d6b68530d3912f52df2fa24076d040bd61be90d74ed5616bb9cd6762a7ab77f6639d67b73176176e847bd9630191d1baed107ccb901420577a8f73193bfa307337c572f0acbeb856796cff3234700e582a19023dfd21682bfdecf088c69754dc52401d1ab78dd2fdcff030407ccefa7ac45259147b6564a7e794d0d754ca300043c9a8b412767174b73e53b76f5c215224da1e7f3450d90ae75db3d362f25cf46a1fabfde13181fcbf0a1858c7517be65c0db2a31907e676d395b20570d8c955de43d90a38a48f86009528eeddc74725574054539d34aaebbbed420ab1bff564033c5160e601f6cb2ad2826daefc47e3c2e8e08ea69825a86042280dbf1c68edb7aeebd49b2effa85dd3e96c93009814a9ea9eca3e31ab96bed8d255a7918014ab5a6b2570280cd0f45066781396cb60c87392642e06f5e41f58496e1deba78cdeb77142523b693cb9c7a793fbe5f27fe02f4a0209908ac2ef452cf3b5421311e459368bbf23aee19915981a9b05c53c9bb292ed33699b2a43f97c847c734acd67da7c8046896f7998da81117a39d36bdbfe9e75e6de73a448c29afe3295d1bccf474ae996627c0c9d0722e02daea46c4b145831f4d011dc752da3b02ab96e628dfca1d9a5abbb31c6b30c0806ca830e3559614f3adc803cf8419ef8a2518d62d236c686b1f5a8a2bf2059391c6c210b36535a8598a8c88a9f1b157033696f84738dff126c67baac13a2bb9adcece4e232919fb53e9a4b95a409d50466c23103e5fec954dbfa4d0dd4928467e27cbf33782328769ab33dce25220af49dbd5a21cff704234a3d3d623f6b9fc8e040558a0a7b5d9434cdedde1788efd5d547d3fa685400c91c949f5b15ca776a993dda0164a747119d073ed953232ec541543f16b4145a186633747742ee9378c9a6047259ec6d4fae11d02e853d8dc5633adb2e1c48ece3d29d705a7e7532b72a350f2baaaef655a2a5c81b4bc244b95bbd2beac48b54ee6d2424c305ce2b400df2e2bd075d9caa6a4ce837005c653e1ec8202902c290a0ec3e4d10b739f3c46bcf326fe3d74eb535d889c19fe1c8e4e71e316ea4d93675be63aec68abda5687aa3d319e553f877d7c3100655392f8b51611d2f787968e43abae6b126b2ed5951b7b1d2c60a2a7223c5a91cf9d0e4b969b33268ed32b18befe4093f70aa51a5c1f68b049bc7fdf156b55364bc4a9c908db7c3cbbdb652b4ac655114d211f8916bb6967111f0d8be456f5cc7198ebf7a456f1e2b4c1e17e934c6355e93d618d7083d6bf108c96f2bf363d90d9b07eabc5a7dcb0f06fb6d7f3ced071b6898ac8fba82e0083a6765092cb40eecc3a4944c28ea700c1904ebde2e0a7ebcbf49e044b6694d8446a8963688706010dab3fc354c480b851e22c117e5bbf419132426810df89c43555ae19d94b88824c2354171b05fc542e5ee3203f1390b1fd7eb0cc5a0f5de264e5e8d676fbb41e00d0ebc83d785f3dc6990be830136e3b3f0646eea820919a1a603958942a4ee5db5029d7d4f773f536b522779d6933dbb4145e7561aa6e58c059b353231647f975699ed7af9e03265745406cac15934ddba0b355b18479514e82af3de3ee666a4a105c1c7ea2ca16fe5045a74530cf2214de135f4e6af829ff2ba19262e16a17cf5a5fec48e454f43c1374948f67e4ef2772a6f539980a914a6697acc83e36ffb263c528a011a5d77d4b13b32a61cc8bcbe5867e2424da3c5daa98085bbaf7448e01ae6d21b9facb917dc170550a5e84828f5c50be3a081b7c0bf8ebe9d2a4ac8c95b4555ddc33034e5f24dd73a6ddf33fe55a9f3f5d967942702dbf345a3eb30e959db517f6f53b1ed30907df915f76cf200160f3a039069e2562d35c1ed189aa0845f99e526e7cd8881fd47f857e3b1f8ac0376b7c7acf50fd7757d7d4ba5f230b7f7567cbdef9adfe2cd1b8027bfeede5dc89b1384fa43c08f275d3902ec1ef4c7455b74b6225f2513ac529c50921a3c1aa684c1b13741457f0aec61a3bba656b6e918c75fc2354fdbc45a8f91e569416f50f7d6dd63686934eab48201146a123ffec89ad6e96aa99798f5f4001fcff3694b7071362ea5ccc58bf2f022a6cfebcd72b1db735e42f8328249cb0653f058952c18c84cc2bcf1891040aa4f5fb96a5ef185f721ddabdc969a90dd11d57a028d944a7585d71f151fbb71eaff8fdfff8093e9b580056615cdded88bce70b8efbe2fdbed141392919c36a188a2ff23fb158b288346f1c8ba6aad6e6e524ecb5bbf6f8fde634c01fe0843529082d68aad6cba4f18e8b11ce7481c3c105ba1362240a62a75988c27e37420c66d9849e1d339f375e7d2bf39447a64dfa750a9dc8cb79e495bc577b35f3ea01b9ed53717ac61edf5b4be918855669f99039dbeffe1bd38d431333206f88205174ef75a559c55acd2c388cd2ec5d1ab79e2f551e7df57ea09a312cbe57bbfd7445a97aa29df87923fb6d524c611f575ac00087ed636c2a056b9201b3e20c32d0be2fccc99935db34dd05dfa1017fd0410f484a14ffaffd6cc81486bf445e8463f41386ce41ed3261d7b7ecdd7afeb362141980ade87f20b243eb1be3d96a898b6b55c41bacf356ee60c2950246e7a92e81bfe5301e28643b3099ae23c6d5c6bcc0c765aaf4ad1a56f9de53ba7386c827194498e20a1df139deb1c818ecccc731fd14fb0834df4ebbc09b0d47f00b2b83a73aac7fe863c7100b29bb2165adaaf53f0b9adee5788d6601571863ec7064327f5da2f3dbc889ac0d518ba9b07294a4a4d47b119887518617ec2ef8b74ff00553ae898c7b5ec26505caa9503480d3089c75699285379ef0219930afbd2847ba689ce664fff1ab316b3f5b2c043cbf71f9c05","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
