<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2c2caa20e389ca56d20b070011f6d54744dcca43fda9f781d7b81e2808f388eefb8da2873d2eb89550ebdad29428d751f74ec660c2a391a9066e51af28191a446af4519a11587e7aa6157389d5c27938c8763b504de5cd20c082b3d2be9a9e98900f8fe0b8927369da7d1432a1f701ae60148901bb6e31ac9c5a5972469e8e093203074d62782f9c61e5af2cb5cd99a967987aa1ae8d3134fcc98abcb844af86613678b6e3d71aeb4b2613cef712c0b50825770f351205627abfd843f20e2eb26e0bc88541d111a291c219cd69ab439ea860d39fc7b8a604eed35aeeeab5ea6814ab6f3dbfceeed16729c463da2c21f10521c3aed204e399d15d7b1cd4fccca7f72b23c06df72608f3267851dfdac6d953747caac212d95c030f5bed48893707a387297cf4daa3a1c76b5fb018e64f2071923bb06ee6c6bc9f812bf11b31145cea44a440a7594a515b5684adfe5b68c88b0e2fd38f276f686cd4717dcb9c98b38e1b63a41d08847681ad2fd63317ed460be87d81c710f14d572886c2eb3a2b3481770e1fb9c2c6b41c31f819f29c6209bf9dba67f9e29b1c8a69a454eb099529499dc2f639ada3734babf5bf6efae5b79fd67ae5e701b19ad411624d3e986a88fef5ef00aa0a809b20bc9d4b888469f633d81eadac73576b7e2d29b4c10a534c283e96b03fb15b794a68a4cf8c98d04581d3bafafe94c94fd3aee2e381827d98f6c66f9e89e4c3d7e56354ebeed6b67aaa5448167574fbbe1ba88eb36044677d4676dbc315f9a265d5ecf0d62c92702a81971ca6d04c2b28913c772f4c0db39ddad9c11ddfdff810f3387e2fb8947601c9d4c0ef32b55285b8cdaeb512a938c59aade739cae71f3c525e474c06c6c425dc9df7ff1f07ac6a456a9183f7333d62c255302d3298284ebd8be98377460897309c2fcbb7f86e0090a6b940ecbead80ff419fa74ac2e97115947e9c410f58cbdf4bccec8078fe6233d0136904103fde0b78e200e0308ed1a3608f23925ff56ba561adc8d370ab5f101bf25ee2ba0cf2c1ab67073ffb56b47f9dc8e2112a290f70b7019c8aa14159f96efde6aac87d0987fbd9093d816bafb731b551d73e9ae32b695609a1d50d0777889142cc64c627d54c9732add0e9f023cf2f760ae7746be30f47f5f3e18362f33db5d664490172e47cf3b5c772fab8ea0a55d54b20ad0fb8fce45955caf503f3d62f7842b7d64aa29846aeb46d7f39579a8ba38c03ee48181e88bd670953c82fa8aaece9fd090b7e8ba3dfc5c3d4466078ef9ac0c4e40156c45c2b3a71932d6d656713c79ad7837fa6307892bc7a4868cfec052de622e0eb519f87181e4d562520f4f46695e1a49be8daab27b33642e53e8b3840c7b58a92360612f2e1f7614bc52bbd7fd97e2058ccb0442385ca2da2aaebb6cf9b7a84dcd2edf9c829c3e38e864a53d396fb45d64e9577bea9e93923a6a184518d28d04890e4491b671195d698c9e271180911ba05cc0b1d43b70225fe67568c16619c67d1c33f761920e5d491ae5cbce2479244e81889c5e50f747206c8434a9868aeaa5fc6f2a2904a59ce6a53cc73f5c687454fc7060057218cc3b4505ab6950736403269df2e3380cababaf2ad3785fa219a7e78626bf47d9342ad6698f023740496d905fa872ac258d822efa4c45e74c4c47480feb81f4e61da1fe82a962f8425a77e6cb13231f714faca3b6f84c00746de489708c6dcee9c353068fb0a1e2033b468831dec99b60d5aa70d05514b4b4de5f9ed4dca7c76da150cdc83f5698a0c7a805a8471c542bcb1c9abd5c9d523215a29a5b46bb0d7c81283711819bf38b81cdf056de72a51ceafe349d8bb584a799f2375386bc8bc776848e2322afeec04a7084e1a2738171d5005ed0da0263a03afb23475a137bb0ae38f34a79474feaa8496a250eeba354c7af0d7166c633ff6e2648da94eb1b5ba980c4c40af15973ae35e25f083c3175bf29a5bc1d1a365c2e696356ff26a7562ad7ad6268f896b91a2e5f24287d70c072a53d7edc17317301692b1735ba7c3b657f096b9c8a6b9f3e1ec92156d2c559b35d183814f82f453c80f312d7ce50c5e3b8f4a39a0089af72ee55150a6b7d40abdbb0bd079fe8548064fa8a2e484e76336cc244ae21913d74eba965213518da52ffa8a6a28c259650acba4c122ea007cdd8c1adb7e788092ba4193e58b1e8869bfd97566a669bf36c116ffc812e53d3e6442ebb4a1377c737ef776f5e222edc9dcc5e5f5f54f503abe6c60778c57d905f444d8debcb02b5532cce466b87ded30e8164b250c5552e662d84925f7ef160b9754731cd52366584cea4e709c52582098ddf9fa8cd4cd5587a8385d7c668c5346c21ee477d3957df18257b1bb3788c3fb39838272324c7564a1ec8ef524b7e6533411555a6c425f8d964ad5389b201aaa3a59aae22d3367a2f74cba7a92f485e5d32bfedb1cb5be53adc4cf82864d014f1c9ab7b6a485bf666473cba22ae5e6531d454fe5559a40903d9affeaa7cec4476386b7430340465da418687b4e2e47fd8db845c609745ec4e7afa49da3bc76035e1d63de5cdf1a5852e8a7527a204ee76eecf2660b0916c4a9fa80776945639c7f21a41d0fc07aabb5e0213e58111ea823ee533d4326942c8be4dfca133588456c757615deb405f08c5ec7fabf123cdcb985517102b54f08be60903629a88a54452f7dc21f2b7250ec2ebed5385dce6ee4be55d81cfa935cf02c5f2abdb38060c0a7e2cb071d9c7a90039d948785979c260e87d58ce63d0d57293a354f5d68b6918d09d6d74e0dc04c1c03b020f5de70acec67f523594739461759a1aa8ab5abe8d555c56acd75ea99a0689bb3744490c231264478d5b634afe2c923ff9f663cc25f2ceb60e241b6c260437cd724e41bb18b73f200a363ab00340a30301292c1a3c6b86567dde64164afeda842d40ddb6098fdc1bd9fc918284b57162333624927a33cc9a2e5d5bbf85e4c89986d7cbcdb18f383d67780ad416461e8b967062cd13eb3ff55cb5213995ee959cfa7426661fbe4eebac5c619613e44110a27dcb80b893681a2de429f31eb7c971d8c58ddbd76be40a51019b8f56942f63bd299dbb8875470f9671e5513cc1bc25ab03527388e6ca1dbefac1766aeb5994b1bb56af748dc25ed33beddfd7880840866eb8c9f6f7a10e6f4b1d5ed036889b8691c4b953e14c5ff4e61775cc6bd8f43e789a70526a2760887606a53a8451487fbf6d2387ee144d0325181698c707912539bcce559722c9254b668a5fdd27a3db0a0e9fe3f4b1b0ead667648a3f8438f7033cbe022156e87c43544a1e6f42d4ae8245c2b6d74dbd7c13e997607e01e9eb3bd01a12a3c6ff99c11b942a2c3a70da695ceac504108f9ddd787c03176016c90e07bea37b043947ed0392124e4c940560eca30318c1ba87ffd11a743adb1c65cfbc995e0062f865f0b3aa9154473ff21d059d47e8feb6fdba5bc21598b6ed3dac7c8bdc7a4dd3a2e3279e0fdce3678ad0c9c49555e85dc57f5ff81cf64fb98f00fd80ba67579800c8b669c46883a6081bf8bbeaafb5a940ac81b5656d83184f0c63de156bc0eb8ae9390f10ae9c82eb94700256e0d190f4bde071cb359ce608db23bc796459459fb6c536aff0eccce9193b4deccaa4feeec5be3b45a4a0c642a6bc1a00873c6a9cef1bb719828a85826351c0b2eec77b7a77465e953eb57efe010e97daeae4423c5a14c5c0692561fe6977ac5a453289ae61dd9f803d17f58700bb361dcd14810d61cf40b86de57fbe64bdacbafdfe7dc47a7e95f27aeb92240ebca00bde36a5624fde5fc625db8f5daeb8c5703c3d4d325fa30e5a681a90848b47c1ed7788dbbff0fcb2beb83d4b31b31d1b5f882c0b06dcf9dac27eb229e6a345b6683556a5f1be4d7bb19287e4ccd85f0ff7a6dd65d981454b3bec6494d7f9b25736b17765a24877a534e0fae20bde97f132ab1b2bd088e8bb71188274a2c4bb5ce9030406707e94fa478d905334df2cd1a5352caad944abd4c7882b9d978c0012c6c4cac6d4370b7f36dc6422b10916fb6ca67bee1c1b882bc3b7874ae89544e6bdd376b1be4ea641ef69b19bf9e91914b4dbb0d1537be6683489fa5d0e09364153e90665b602252b1ad658992ac6b595b529821450dbb4ce8c91af3f1e2f671ce961184582f6cf84e719ca184821814dbf8ae7d2fa5edfb9311b40bc9f7ecd19ea757439879ba72f6b1a2bd13628143fee5f5ba7b247b77f90d37b023e8f2bc97e09d54c9a7c8cf00fe250f6f6f052a9a63ce3e90fe42a5e8b3b46e6eddafcd09874a645580558b6ca884321f41aff9cc928ad01dd33f729180c965fa273e6e3562a7ba7d038267f503fb5b5c60929ab3261c3b0df5b4b3df830615b69af1da01e34f50c64797e7b17c89a1657a2e876de7f3ecb708621ea9e37adba5ddcdf3f736204497fc3daf55a77079686ec26c0eedff5b383c465e1d4833496791afc3f354dd184039456a38727087458fefe18dd1bf2f01fe8945eaeb121494428a1b0c0bde00562fb8f717d1b91b7321d894355b0b53ce7c44213bc85c4562996c12acebd290ae7cacf9af9d2539f3baca1948c7a24faaebbb76dfd743c9812aefa4dd8bdd4ff68cf4888bd1ceb2e8f3e33f0d30435159fa3d9d44be2ea8323c058b036256a193b28f74af5f615baabbbcfa8741bb30329ee8e38b80d7452d614719eb8cee5ca96fcfa22642b32ac2e2d40b822aa94e5432ce61ec07e45fef78661946054b6af90428f411ecb4a0cb3aad9d877c5d4f22963149ead7024e7f76963dea4aea6a9b8ac1d0b6e4da4d860b89dfbaecfdfd0756df537a86a1199dbc46a17f482a9ff32ccd19815710bacaa042407e9c18695ab40f3162f573e69a175e2fda94aa8737c560e59f6f9b0b1412e2a55ae94475a818c4ab55aba16f35b9c9837e03236dc1377f68864e2bbf590fc27578588b5faf1843d487ed9a863e14d6ca0b4f6fa824e54c71af83158cb93e5d602ed1813a846c59a00b54f43b3ca0a0beb225ff5a7f611e78abec3e467ca31730ec5831ca8c65df456350075360393772c41e7e3351277d4e6e146687d7c28611922a96d0a1b90f63b5d633c04ae2b73627ebe7b2d2612d4810e7f15fe59f51bbaa8e2380ea004eff2a5a44a484517247861d9d7f277f8dc3a82d09c7fab3422892967c72cec3c6c5ce14d6a835f1b4c98318d314467ae171e4ca9769660e08476df65b73f42e2c9f06edc19aef186da82bf06cf15e25fd17e9fc4a2f96adc7fe0f219ee49584354659e3f5ba6f7e300d7332e75b9b24e8f5bb58a55cc7636b01c68282cb6fcad9770a93a14c12b815f93f838c9da0b74c7125f87d26421fc86f1319d0e3a4120eabe85302085c08c34bb9095bb73cb248817bfc2151b225151bdd6acba542d85dbe40e809a82d2f376f751281d7c26218926f6d5f40fd1a88f62cc1b1c0aa55011f5b2c01eee8c5eb8759e01709c5917678664e31d52ad71a17b758663a9429c510c505d483c78f27d15a15e9fa7b1906eee5c15a88e80a1b6d32c9719d3b0185d070baf3d672b718960b89f804b750b4278ae947ac35ce4c1848c5bae8a2925b98da55698e78b58aec6fc9cb1994aa911ac6be4712e62ab62ef87fecd26443b3b6aa4c76ec343ad17b707441b704103ee8d3c05dffa67d210a7098cbf3b5ea167d8ec49cc2aa31768a1bb4970f378d99142a603cc0d62afd87604c6a2669d18ba8b505fda8c9be3a0c7ed142070932eec9a1ac14376f273b14bdba5ef18e20a58f6e6c2a9612d65400c098d33f81f7691fb94e818d9533ecccf7105c11514ba98633bddd79625fcd7388f09ceedf3c6bc7369bf95fae846ed8e185ad6ecb57a864cb7b3f99f6518ea5a2383f1f9462f43c047e1ae0252da9b6d6311f12ed94443e16ce1a532c49ba6a46c02302e1cf9ddef8a14eb5daba2b6e44bb8d8c114b554de94267ebbc8aaac0814015b706647e4e65de6a22e8a755efadb6434b262d019e9e77270830cdd0c5695aabd392f8d291849ba725e746eff45f21fd8385dab3a49ab2716aeb5be6e562dcf654ffb974c0ae48a84993f55e7f6381786979bb1f84d12b2e2a5b79f3cca33879227be2082e09dadf534494227cf75d3a7c809bb99af80179a835d9c050c9de390fbe94b5b5ec8b76e5b2e774f9c325f70c3c134a5b5834c3f49b2b8b2e3a03058958281005df6ea3f55aa1cb22d198b70ec5fbeb082f66e51322c613e19f0c974f4025cc901243264484b0d9dd5b71ad4b3db826de0673bca16529ac3053c0aea8c4a1f7179633564bdb1d96c821d76b73e45107c6ccaeb8aa728a939cd2b541b74851a54dc7a7430206f556492c8fc2426c727f26c4770ac0333483a77384fea0d576144af35a17b5f125a4ca9078570e0ed41a03db5a26b4ea4780e800bb37f2fe2b41b9f6770c7047a14aa7dc002032ecdec7075d05933ed4bbe770067b69826f8feed10e59983be88cf649b63188b33ff0956a1cc8e1a9c6411c0447e57740154d97c7b8e32ef54c38d966698315337e531c9ee40e3cb1eb2bf62f11b64bde8461ebbf80b5ba431a9c3829b537369b96de34234d618314e458c701414231556e7dfa1ccf60778479e4ecd47cb736305326cba1c5890b3f68b946f1792d1bbe275803a545145a83ac540c378bde054289c273019996c868875a75ec7cdcc02e4dc74bc007c8436b3dd400bf6371e0ef6ec4d9e2beaafcd7f2440a874668ca5442ec083fcc0d6889409ae7838255fd14c28dc2988bf43690f3b712d4bce8eb8320094c38b0c6d5ac5f9ba6e8c2ddcea6ee574c512c3e2b2388bd7d702be86a9ea765dd8934c1933b80fa467775a904b4ecfb081084b050dc1baa88c4056abe72a879b46bb265a1708d85e565c6a18975b9c0ce7ed03dd2869b7eaf0f12d3ce287ab3d2728c0806b3f69eef730e0ca914cacccd6551cb5584cf852d13e1c664f7c94d5bfe396c6f621ad11b4bb08f193ffd5c4fc3e3a941328dc7e7c784b28580096909f8f57895b6916702a124a4c30cb8dcf7d7d5b32a3a7deba2b1933c0dcc9f3befebdb07989a5b963f22bfaa35fe53f9d6dd4bae25c066a5cc9bfac09a8921da0448b76988dce1b0bc4c6de215edaef57a0625c08af0c5db3c492145ea7031121f1428294e9282b11278cea63374c255fe1bffea8b296e8b7c84a288a88a023b8bf6b867cab243171991472862c218333b0cfbe232497fef600c45c03f76eddb25fca6694d7a7279ec2cd7c3573b3da94ae768ce35fa2201d22b6361bb9becfc53876a7a3e2f00ef0b01a87a2b1b1de89f78271c5ecfff156f7bac5b5b48fdb0ea166c20c1408e7028a38eeb68eafdc4647fe0b3c7c3156fe43882e1ded4fa14f507a4ff60bd5a74a85430e60605d63a150766d2965b62c270e9ccde628ad3759dc65e7fce2488713ea7cead44fd341a1cf4eaf68e6ff01c9fba509c657aeec95f0b087edf984cbc9228e90b8fe558e46d5fa2f556af5321f311bd8e08131335cc7dc7aab88c7d73294355c7f56bcf459ee6dab81521f63e769c3b3465a71cb1b11238913e0bb4c5fa95093949a72973508e416e4d810de077fc68f10def9121cd47379f674920b1dd92adfcb5b84b46aa388f2d6d822a91078ce154dd4910bbc0a94c4aeac107753d33a2a7a6504ddbf7bfa6183e60036b229fc42943f9c6a48ef558d31b4a51daf4ea7660b430819bf3754c583446b3d2044829526cbfb649b9c0df717fbfeff4183626ea55a9d68a0076aede092e45b30c3fd8ce9b33f12fb310e119a08a0e02dd2f2dd1a8d7d85a8f94c5ba186d1560460ef5801d9d0be729b33131b6cc6b045d1fea8a6bf405ecf94f1f9f8dcaff09a0c4e3221b1183d97932f1ab1453ad321b926faf9d18fcbeb64cd455911859da98207cdae6d074282c25358ae5765f8b9f3ed208b1a8700f333d01f9ccd83d7c5940beeed18f08585c75e35a10b7d0196472fb9d781e186d3de725fc9be2d1ca3e1f8ae6fb1d7ba8432094223a9db8e5e09cc4bdaffa2a5e54a527596821efa7f49012479c9a579cfcbb2011357f14e4c93b8007415d7714583703f623a93dab5210da24bd8c6ebfe9b563eee2b4a0a88b5880fc0058b62381c8aa6d18d2da6275da8227ad82860f4b7221e1e9e82430703ddaa254d0eda163a13360e51e0c1f550b03be82b62b965bf9ea92c2e4bf53c8955275bdc12345bcaeed6675e62d4fc0decde0ac5c75a344d8043ef2389c9f6bc35c279db2479684807cf6d433866ca390ea6e39b7b628f7b644827fac91e7022fe99d125319f74688a6a14563d1b7a69a360327a605333b2fe7bf9ae3d42c4f579131abb27b19d24137d3b608f199240fde72f7d5a9b2a394931413c8b6d84ff3e9e69163cdbe1c7a7dfad81b7ef3a97843055db4e2886c54c6093a9a35189d72c13cd5ed0d008a200aecf114a8848539ebd9451b6080f3a47abec6479105452479417891c4c66c9b463adb80e6c384bb594d331a38ebcfb04afd282bfb8f9039c0e67d77c332447832a409493829a4acd480208a07dd72094f953787d65454265987da6fe3fa3858b80368c6c6990440db58853c32cbad759e1fd4fc0eba9f38b860f358665472059746545b488564d610f82a4a0c239b1559b1d70e622b84a9db40e745eaac663d90e8a90bcf617ea4dd63f1da27f5d1e58ba43b16496a6591848a521368447774a540baadb3ef646fdd49bf7eda29d0152d3e06d3cb22e568604f675d8055fdbcd49726a5db008fc2c68dca6253e92ae9c8402531baa83cb221cc28d89b6d39155e9459a79fb0adfc12068c8689b869d1e305ca9fa54b6e7f4f00682a1d05bd74f408bb47a64c3be773b98cc234b273c74a4db85ea07d2b47fe39056c65eec820927a5aa8dd7cebfcdcd98c5f045813392dda8bad632f55659b543497469e2bb9d4e9197f4af5379a8239ba71760ae5dc06d53bd8e70911ea2501905624a5e6096d4bd754173253fc3842376a5932ba94fa58d12f31a0cb443b6d60cc9fbf2f589f04e102bc20039b69db7e316c77af21960a2eed593b38bbfe47675df070204497097921566f1616184a94a7e91b15ec55afc4fa6592c10645451b651517ac02ef8d8ccf758a0e795e98d03b7cd38c3bb5157c4281a30f9b3e77dea8e90c8b156ffdb9aa810dca88a3d8575dd6c070b6065fca7cc2bb4feaa43fb84cba1d08eadfec4c10305f09ab5eeec3384fdae2bba84463f0f3d20140190a3e827ec05aa233d24d625c563cd1bd62e9d2de66e3b3aae60ec12bb0cee04ca31bb18b48654a470d41bec57cd1757c92bc8d90ee943b6d142d3d78a453279272fc0cbd1da918fc9dc5df66f5da4a44ef9e55eb5fd7baed4c3cc01eb3afa44f5cc59d04171b9484cf675d4998c3fa5d9d634d78a653ce9f514ff11e366dac247cc054db8274ca7aac6a0eb4f0b9bafd7c7e0f3ac722c206f272fc145c40f1998c7d6d7ecea0a5811f874f846fb6b785b1a945c9a8427a52d48bb72dec1088cfcb95be5dc5fecda9069653627b5f0801978acd8bd1186c289c3a1a5f346275083cb738967df42ecb79d8667631d5bc6a0b3222725fcfbf4aadf87b5c1c76cbbc616979a777c9b95d4665cd010aae410f2e622b41c4c225ee2938b9ad9fb2d6f0031c8c59b1de464245527911d05a3ad3a835ef12837324ec61f7b70d48082230496da8a9b80679ca39432af0621ebadd8af33bf5a519890ce0226f25276e4d45f83a5ab8a56cde691f4deb9abbb6286d5c82279c893bc9a9fc737289a934a6f2d90349589d9e3a4341873c6f360384fb3ba2f126cc006c32b05702e960dc5363e30a7f71986efa9516528e5c667452a9a88c864ea23d0b2d2ba03b4098b23c61e6af297ac58f5df3e5c4208c58fcbba231eaa274295c8188b13143f45590b18676864aada8626d120bf3b389f7a19ec5de28e4c951a7355725aa9e55a369806672a7b4cf408be5797ec966c7aeb70ba51ed51db27ca9dcce3fbff3b0d117908e9203ac3fca8407bd23b605a970eb651c9253461637bc0ff7e3bb6b1b2f37a0e4f020fd9fb49a0385c3931d3c15744a9fdb4727f521725a4fd7dc87c7e92f5353165ab7a19ada18c7d4f0bce8a0a2e52adbb4c09fafd13b3a7edf148b16afa756ee98650b5e1c4af57eea063251e759697bb4a8f6eb31ac93c2b8c439fc5e6a032e887e31138610219156bec9baadb55cc00563a445e7d52e977cef181f5d80e7987c79dec3bd58316057faebc7a84bba55cf7fd1a7fde5500694812a34d9b6f2eda3e595d3510deff3abdfcd0072a1ffc88f5c86faafb58f83561158420f747f1b00ca5124869282f13f9804abc61818e1b2c4c81b44ab708a1345113ba71a82b11ad91cbc716b52e4f9d844e5ffeaddda2a7ad20b46ee2606a05aff2e2665954d9ea82b8f8637e7173064fef5fe20c463d99d6c19e9aed2fcbd5891f29b9fa276e6e284830de5f54d8f10d5468b2e91f9f145d311703f5d917e41bcd38b00ed9e7bf42c5d459f8f310c657180619b3f49b9832f4c11bb30161621c1963c94af15ad840fa98d1baa4c3c8c71d737dcd329838027d9ef5c4630b457bb2d4044d25858d07c667b3c56a688fe025e623ac0182c2e7b8257897ee020241d48b006bc4ee5eab93defcbfac5ca0582272b6618e714d266833b8df40bbd459df76fd9c035d797f479ac8cb8d78a9b6dd0a86f7af2921bb11bb392060850f79a34e7ef3f4c5134f6990a9bd741531cd47ae23186c92b4319e03186d883f3f2192916e3db77574f19dad61541ab2876d7d69c316dccccb904bbe096ca606ec8b66c78a376e7fff82a557a8b255d1c8300b62cd394b8778691b7bca563b3ccf5630f7f5dff8e7f729ad8d86e12993efb1c6eaf13f821b4a1fd76cbe26836e380c39679b854a00782ee72d560096af6efe57bb53fb029764c7a18145511287aa3920cf3b6f77276e73d26c38b5f9dffc67b3ed4a44427c15540ba7e10e6855bfca16f6018d51c9234b4e6cc49f5ab380574491536852dfd133efaeb7a1ddf9e6b67d9317adaedda8ee6dd70a83e3ae0177da2644ceef73c55877f99217a320f929ebde23693c70e1ba37ddfb9b43e30833af860890076eabbc11f4ad1943610d7577a27134aa4c81122cbb794a438c7a81228d6d62b848538513b181a651cee868278a41293123712757dd82bf5232e50c43812142b43bf715c9e058d4e3f824dec693ff5eb1bab51f2ea99f69073165d905cff363a0e7d00b70ed7efc73ebdedde3fc755875ed9d042721d1a73d279105ad37d56aa6fb9aad0b009a3951169b3a038749eb53c9983d3460e0ef375bbbac1b0c7e7ad04c87836040f26ff806bc1f393ce33b433138fccef00c7f4ef99197bc41c712eec6256539f2db8a52f10ad2df56a15ef0ba737e053e130cccf0953fc9a5bfdf15315dab2636f5693df3dbec7e6ea06d795027aee101d7c243d8086e74fc6d01608bea506b4b564091199240bf3c85952985a8bc2cb3eff16f69c1b43fd3440bf02bbe6e05d084d3ff68adbb58fe54e0651656c925e9ca60de14c1b61ee782d72e921b72b68efc35825cbe23c138a1d81c98ac08fab0755229bfb943f3bf483416de96f397ce437b0798f284be7f00bd012293e6b16b4b6af555d166d6016f0daae79c34c837718f66685f74801d6861f6668a6f8d444dd9c95620d4e654a8ff2103780429f6bad51a530ef04622a4ac26425d06cbc29710b03ac0790ab8334c77c4e43a2b28da23c7873f3caac0970894675310ad6c014c34f19f6ac9ba512cc9532f7ec7291cfa6847a62aa18c22973bb71e5cde7c2cf53840ab9e02198d70c7dececf45d8a88907aee8250683e371869c2c4d38774c3fd4994288164d50d5a6257df2ff2d5fb303d0d6331634cd86e503751ab56a93c999677f8ad73ed9073040f49ed4f1539490fbce1269521d05e20dbe934f1eac961ca186ea8f81c342fd966011c4235cb6df5a9f7d956849a3643baaf44c6ad671c9bdd98cd44a9c489f44c13ff34ba1b6d9f86e48275c28542babbf9fda778e756dc44db15cd221eb3cf996a1765ff143d69f0c2b8beb28ff3528c054fa6f2207a483c57dcb3d033e8e0a08fbb1c8d670998d0cde201ea27d018132e7f35d668d3551b477fa96ceb8f52e1f3cfa9599f3e89533b2b1c34710ec19c52d9884b54cf26694a69d0b2bc6fcb42756a8b5fcbbca3d22dcba4d8a0098f7ddf030958d6b2767972c2028be5aa59f08cca504531c27b45fbfd2193ccbce1725a5f773d15a7a31945916c048c529a64d194f639bb7c78e03aa41d4bde1040887085bc83f1b04ed7330554688d7eeca84026196d304df6887853c8d175e2e1a8b34319a886dadb30371c5e19186f5b27070fc9f58b8103ddf3de8e9c0a940f3b928e54273e9f2fb0aac3d3d2f7c1cdfb8828428a8fcb9e915705107c8d596d4f1c3803ea83e51ed13279107dcf727f3f085db81ed382102e8b7202aa6d6c2cca1780f7b9a74f14105b573b7ede64c8d3a7b25cd959f47e2e36252c25f61be1c3f3832da7071018d3b1cdb6eb8d7a8d76c796fb20235f0684014a6a473bd897b9590a4202064e20371a825ce3c95169056dee252ca4c5fd7e1aa0cd850746ecfe67c977b92fde6d6c9d9962e0e33ab73797e2c02a610827b2c4ff5b56554480c105ca8367576ad1f02fee7e676e7d2a82bc0e52dd5d259f6b4a19f8cb9c3972c544b5c0d3fdbff26513047996c8cb015808e385400d3c4f86ea6a0ee2cb5aca95805d9451466032759757b5cc28f4e20593ba0819a20a8fb94dfdd40d4354ac196dc8e0d2d71ba2022f3262e2a33359ea85ea2dd5f0ce6f6de86c8b626c06de4a8588ed46f82286023d8d37a1bc2f427331a120571654cfa480f2ab912377f2320144ae9706b98d181bd9c792670a9e7a4a8c57aa9e6a9ceff71f960fe866b39d127e8808416d7aaf6d33a05132d8d0e082966ae8279b478ddbdeb300219c38c66206fddd45994d5153789d9f1b168c774ae46bbf25a0d77fd1659cf0542753341e8328ba1aaffd12da923416c784f88aa1d9e0965b800bce63713986861e814b645621c7749831f3bbad6991af531519c939f40c3a288ca2bd51e0eb807ba24e25e8bdf9c98adcf0fefbdb6a0974487e192fafd69dcc6c2f37c8746de5f9e0e3011d91954d1d9acf5eff87365354d1beff8e55c6ad30e24163892beee6ea5e9167fbfedf0101a88cbb304c7a441360719268d9b264ab1960ec32d362822a04722a4f78768d8c6c135af78ff4afab515ef2d310afbba165bc6ed119e3e4338dae76212bc1b8aa1270019b53c81223d3550c7a0e7bb77614856a58e17cd60c9cfec25dcfd197992dcba4c68108222787af25fc74d91b0a1ede95098a1d8bc141c19d809466c860fd6e7469c66deba26357858d79dbb6bbe8907869d4c9448a3c24633daeea3dd59017f35aacbde3febcad690187f1367ad6906eac2709ce562ad58b8ee4dcede2831fb6428b68b38e25bf72b04c28477589c61e8797b2348e7ab091ccc65ca19252a7a8e6c998ddf4eafb8bfc830a85fc8396ac0550ba7425dc1a93743f56b9a207858f8fa47d3466da088b4bb3d6f68f0c684ba3a166959d6df9de5ee0e258face034be7d6693fe010378d399e6fbf00f93da5e05370e9ddf40a7b0c58f3b1356c5c604d82f58f45408758d6b8cc4c520e63af57a7d41bc3379d04ccd0e64376704d6f7b44cb7ec5ef15d5b947293bc040974e529e5b44b5825906697559930701950d835211d44a418fce98edf0360a425e19b72b9fa06360b287aaa6ca2826d5cb210e96c934775804e314044dea4d9cc9dc72dcb209aecb202c06543839383b338967825504f3baa2f5f633ffbd1ffd9cece457fb2c51cbfa9ac3528d327f7a134c409c39ed973ddf830e9fce8556f9403727b28409f306027cd7a6ea58f561c04bd5d72d3410c91381f795d790ba6fe9e56a159364c4e26d42db9045efdffe9b94550d1c8929b3e1aee5951d66d077e276ca49bd67370def8e329362ebda439357917badcc05cb857fbd67690334616ed0969ab72da41ab8429cf996f82046787f638ce9bbeeb4e36360b8fece9a9e555ee9e5895428d84a7e1b77f0aa08cf782f2c21dd20e897236af2379f379ee19067a98d06fdba0f83ef1ebb20c3cb36d4bd64321cfd374514bd549a7fcc2d3eac35ed18efbd9dc118e2e4ed8483df6c02b14f088359f775e6a5441337161c5f33cee5f75a370ddef4df9a049fa8fc93a214685662661bfab70bd403fbb294bc75177dda4f036dd0afb6c95fbc82ca71618a542d0b26716bbc604a08ecbf760cb8e2230385c5c8c4290c3884cc02c92cecfea8147fb45d1db927f69219670f4dcaf616ea17bb2fa7ed80a90748e020b4ea2d72bf4ac579a69b663dd5b04d12cfe0b037fcdacc3097ca1cd7185758617c14c2dbc72130f71e91a8490818167db700b9a4b8e339e906cffcfcc8b24b1eac95bb75f2119d7c661a7b4792359e050d66495e508675367291e34de473f2ac3bba0991380f21c9bec808789db888fc409b6d08b2f325fa03d125ee88f5ee16980d95020c4c5420edec181bcfbc86ab582e719c165d7943dfc0b5d8260d09355961abd5848af78b3b432125ea39c338c2944cde8005bdc901a47fe4584964e6fa6566b203233cd5b7697d1ddff968bbd90e425b53870fb80f4466633a267addb6d93ce88006af716967345a9b20e2438d3fae4c30545986740144db931b29e99ca0688c5b00177295a2e2b4f1043bd7bc56f57929a5a9609eb9d75ef4ddd06e316f48f5832bf9f5ee777712ff9e1489bca3f9be24a5112faada59079289a0796b29b3634642bc22a26a79e9f294ead2d234024fd685662eab8fb1fa8c942f2221766abd153eeda092b8596db90c2422979ef52dbeca1833825092d4f26bd18ecedf3f552bc7c1454d6efd1207a24a3c3dc95b146a840a8f7103c7ed864a4289eab3ad6aa5f11a396f28c01157f34f7a211557d7211f91f82087c0a94ac237cf1e0cb2551d7fc7d2e884094e0a09774845f5f6420bd960965ef384063d9530bb1839ba40020789e3d1ebf65719804ea2ac45b48cf476675b56576c5b8f70897962197c4a68cb599fdc379865aa6cc92fb81e4c17cbf2c6dcaaa91cf3f278e4339f744b494d7cd833c7dacd7e89715d75de527f44a1d2312154421913bc74507a9e8537aa33e7100e110b6151cdd5ebc3972ae4d205f689466c140647f233f7bb2128bcf117503ab5147604fcca61883ada963673d86afe1bdbbe2cc8199cc9f4f92f95daffe2db4051cfd1d11807d3d52fed19495732d69f9bbe67019f1ef94c2620905d5a5961a24271a3a257d974a0054e3f58e07b13f987329dcbdc00974153bbfb51d8b9bf1601334fa21f94763f60d72c2b9b10dbbc188dc8fa01eb6f3e5a2c291cd18ae37d8c9ca0da55ce37b2c66ebc059022d914046678833348fbe008b2297d3229e6697315b2a98f80664354b4473dcb5ec45293d20909751eb12f965e1132efad3c5796d2d2bcc5a8db49803cf4f63da87a725011f3e8b7b878b551abde623a54fe79b9d4ea71853ee68a3f0a3b9eeb065d6a99d1bafa136ccb4ab5937afd19011c6e7c1ca88e2bc0a026724a6769af4d36c88ab9bb711bd9db6deda9c1b032f60a88920708b08e1ba0c6a5e3d39545465a60976df2f7802659b64b4ea8570f60f7883d7551b0b4352c4a10c71224af0b296f17da271c2f80afc074f17c4c35f17ff4af5928061d9a7900254fec806e6dea65f1a4c8b1883191084765e263316ea149bbe44a6ba5db8ae766bcfae5c2f6ea203c99167cf92e860c6fcde6feb253389e30cbac254993ee91e8c8e8e46a4345d0b6296af4c3f937485a600e8d735d3790eba63220d817449df9e405d6fd9738a0b6e2c726ca1f9439ae3cee8fc661219a5f700b190085add790becff3644a49d246e9fc67950e5842be857a56c74de1535437225aed34ec96143c878939e63a50bfafffc8afbf83a8f67b45fd777f3863566d2b027824b8c4a6a73ceb33acfd7f726be61e012fe39326cb6c0580e2c5bac738ed7fa2ef85238212092e205d0fd6e6bd3f514f8b84daa61a2930df261f11d0f835e53ced763efdec9cab36a6a27c454b1919a3356b95eecd121b7fdad7138dc11833ac7fb16f3699ab52a36427613a5f550ec4fd1c5d1003c79e61892ef163492680dc28bab8ec9f59e1910736707fc034de7551853c58319a898c619418dbdb0a89e0f228bd04176a01bbbd858c1ffa1db2141a3b05b2d8e50bdeeb914cbed50ebb44381fab16e098e08637fd275493f155112633de1ae1e265c5443ef513022dba1f1a0358e9a91c091f99e742a53cb57df57d2b4a616679d66508e1e238b3515e57cdaf60c6b5ccfc6c998dd5621ef5109adf9bdaeaa0eeba9e5e70cee84273db0600cc3513bc1ca9facd56ce37fc373d8accab56fb703844affa467c7d380f84b744a8de04583777aeb65749b56d7ca360329471056f346c12dce53340cad6ecf2a29487c3b0a9249777d939493a2eb7ce2572c75b63ecbada8e424f6e627440bf7d3383a9ce4ef76d4e123a693aa0ffbdf778e7ab4d89037dd4e1c3d1e1c14e61b49fcfd23ac527c3c9ea038f343a190829c1c080d5587c867dcecc0830510fdfd6c03318a128c5329d41a6f16d90a5fa466ee85cb7315efbd59dbf67c9b74fa7c3a05201decb7a4fb833961c5299188ff5a0d8a05b9b2bb8a8027cdc7ee9a9d0fc1a27dff6ec28633f3909bfdcd0d3da432152b548da734297e68f24b047639ef997615137e8fc856622e5e104b7b607b06196b63e052d95cb324af4b01bc524a493b60567dc1aadb6a6153e1cb68e57d871383f4ab8559582aa2a2452298aa44328d05f3c68f9d073a4136508c2d35bd305379b22e34ea6bc8f95642936929d86f97e11a28d0a93645c6c0dceb85dbdae44d2af9b345a4224126bab126247a49100721acb090d00b1ec60da86fad4d6a528d7a21f4664611e9b9ffc13724c5c68ffde95dd579739637c83c9ab798ce42504ed5b444ed707c305eeb7482604ff5ca7f9df104ed256c1f3f3e68cf13db3b4f75a9b4334f36b648237027a6fec283cc7f0eadebafe2ddbb5b9c21954730023d3ae8d125dff4f6f4dfefa93619965262df38169e3bf643b4043ec70e97dc7eead8d9fddf3eba115e8d559acd52394d3b131ee5c47fa04a269abd44db33972e7246c9042e0f9a8e075bd0aef77152ebe375fbaf89784f683168074bcdf2eba84959ad0af0ffc4f264a90212946b054a38e506c6cc58b40b105ea6ff3956074e7257e7a8cac480c049d59c8863ac26c47011f245f9d4c8666005fcf27e9f8ecce1f026c9758f34202fc48c5bcfb9c763dd6f51153670e37beeee6c7d852315555072f90e9d5e3ca77db75da544998a7b9d7fbcfebda73fbc02755e327b9398cb60f57c8cec859d3a5462d2f221220a9ecb84bb2ade6f8958e5f1113ac4f81f48ee79832d0bcc0aa2af7ae00ba099f790ed0f641eb0568f6606c3ee6d17cd8555848d42b3c3419d6a26f83168d94f31c41c47f88e1cd733d0ba113667e9d092d498231af497ccd640c09bef94b92136b8fcbf43aa2b99bc6943d251b7ea9b02c853fdc3f00f666bf387a1606322f71b5c5b4cda37a34030958c8d848f483a9a58212b4fcdecd9ed0709d78f1cbe929fe5f885191046873c982a8583124dc439f410cb75d92df29e47f835c60b71bfad33f237803ecc8cf3a72e2e43f63c84e8b05c770c33e7f3c015143f0c51854a825947597bdd3c0d01d14b8a8a4a689e9cc8cb4c2a74fd58868c9496fc15695a929da30461487fe4cb1e61feb7668b41588e8e40dd3badf029bca54c339a79ccfeaa6c64cf88f1040bed7567ac5bce85e049c2bbf2c06fa85357f74ee0db7a5cc9e3dace63fa40e661ca13a0a42ae16863dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
