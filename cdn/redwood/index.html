<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"618387e4d820b7a7abb9fad948d000043d4d64397488660a4fafacde80525c78e5eb18274572f7a1d6cb450b607b599c8c2c5f3d0ea4621e642d9a71a2d0b448c66218d227d02d2750b1cfed712c93a39799cbf66e9e2fa821a19fdc113e918ae9b5a6ae6657ea5d4f065bcb1768ce384f675c5d3bf83024dd146a9937cb67e5418335ab4a1ee745558935379510c524346aa423d802c901c3f3eb43f9247d13d27f71e4a7fa1e4895f48ccc0c5ab83eebee6a567204a7c7d89bee07e2033e54f80ffec1684461064f8e13912c82ba24f7096d2ba1c9335ca1587f1fe69ec61258579df58abab75a1641b07f5c6155229f044ba9a37c67260b8b9b94bcc0bef4825b352ed2ad8395166b955064698fa00342031c1a4ce7a3f7c775bdd6d3286bea22bf5e01628784166b5e5881681ce61f333423d8930082ab60f862202e21e6304e52fcc1539393678c52327688e40920f0dbf8cb364830a5773761d3b010c75f382f4d49e4677e7b47297a60f97bcf78243f77b2485b2e5bb1fcdaddf3088c68c7c857a7ff4e479acbc2f92b69bfd35382532a6c4f8c62619b73487d695e73e8f3931b7e6d14810a544ec527fd79b63a7fde38894465a2d0692a1b0f6f7cca0218f4dd1b712382156930521e22a5bb9ed5e892346415491423031ae3e07d5697076e2be66d3392d3982391ba6b43d9acbcc8749ffdb57f40bb8f31a20ea06905777940b976d9c76da92bfca3bd81d0d8df547b8060dce4133dbb79ce3bdbce924a2ba48c9d7c1bcc91f09d05a61fafc1c8da6739ac159a37f0c50e276b40c2c518d85847dafdb7a37582e13d0d9ad04354c0184c884d47c3b4768748bb6d637c06aef4b1502f8d6039f975aa56d8d924e284263ae05a90b76e75f74770e52df6f396b6baf6832d46b72353a798877f75a648337e162a83c7e9201ee52d63c36ae25fc630c4633e4c21f6dfe07bdc1cf9e9a08d329be31e60415d91817259a7121947abda268d3fd89df2e83c1eb6ca5c907583357fa25b0b2ae81fdf603c0dd743ef4a3bcecf35c813df1be6147dba46a995b3341f0941bbd5066efb3fb66e3aade0afd82086e6be156f0e23e2f1a6d259f1436a7bb78ee03d1a37c337fa9967db86ef85d74d0a7513a7388251e6679c980fe186a099941be7198755de940644b71010581d9e01256e84dfa98d80ba16fa10603d0084b1664d411c168261d1f4e77e83a14994418a6895ec8061d6e44db3e0cb2f19a366a9d64cd6a07ffc7a49b0fce06969996f0c60b4bd1f246ef25d66f9b6918918ef7a0fb7278237aad0191fb18d474fadd625d5c68d9fe9dfcba2ad43b973c9535b431196c8e6321437dfef1e728cdc92805e89019d9f582eb9c1cc05a51420c4a2a2397f7f7bbf9a560313ec77ea46c3a417f89c400ab91579c916059678cfe1a92c27c62511ea8329c37a1c39dde8009a57ce69d413f7657842126c5d3f3cc5ea8fd219a60bd898ed9699d617fcd7f24cf3c06fdb6c46a01604b5180406eac44799dbdc8b3b09abca021b958ac20a8a8f3b13778c17bff4bfe89f5e379566bb6cba4a3e406943d8737237bcd1a545bba510958fe50a86bd0694f3f8e7af65fb80093bb0a0cd72b903df440d5788a312984be8ac000a983640673488782c7f375b1238b79f1e3b6a0344a0061abafa88fd0a3bdcd39d07ea95a7e0744f5db4f33b00b8cb7fe4dd6dc36bda875d32d26d9931691635731a92cf4da30deb4a9d9e4f4eacde8ce5fa893535b0a4f5bfe336da996027fe5b08d8ef4ce50babac605ad6643a5d6cedaec9f1f2f974ee9991fdd32efa95bf6ec12b36aafc90b3f6b09ee4ada26108bef8c501e8c98c8dbb84b6b1c1241ee2e46ffbfc71e368624c35af2094d8365fd014158c64e40779251c0ccb15543cfa588c24e2f246637f94ddb59d71782327504f7ac04099bdcc2d39d8b966d916d21cb11ebab63b346116db93ff364c981a06afdae1805cc39a7ea63cf76cd0dac95074b28fdbbbf224bdbcee631410596f903f94ea9ed33fa0e32e7c530978903adb0fbb7a1e88f45b538e63d869c85def28fed6ac913adeeb6a7600cf4fe9e799339ad0ca7f0d24b1dce9077947baf08e43ba9bf9ec8950ebd507aa3d8cb8bfbb8f565e75baec9ee8a339e73d4757d8b0d991aeb792b2ec308b88c867237fbcafd3827c571816160fcbac7d504a71d7f975e7cad39f194f7ae3dda45deb5b2726f21ce1da53c5809b385eb8dc0720696925df4a22f93bfac147e05cb0f8d20a1ff1f2675b8afdab12b731f3ae83701c58b59c43ef95aeadbc07eee3b344da463bbc44b30ad3fa8d52a8fd2a5ebcc8dc3647556d71ecefdddc192e74968352b412fb42f7f52c0723b7adc348086c8946140087cffdbcff90cd5cedb9dce339741d0e4a1a25a5632f508a2a1ecd07de82c84fc8f619e505390ba9c62ef6bc992b92042b73ea1ce1f96d7e09f4e7394f92e585ded955d01567fc601414b763cccc9061895be2d635ec4c28b99b5ee58f2d4e0805eb45299268836a922a1b81e7adfa1839918374ba235c09ef9e69d2c64c8800165ae7191c2018cbdd973161fa1ef6cc5d9b5f334f6853f38238b9fab3a1d8e8bf47bd85c6447269885b1dd72ce036ceac8b908ddf4dbb749982d36c12ecba54f407c319ca835bfb4b1f995e5579125e85b787fe19a508f9a7e8c905a298b40bffb654fb2ef52cc481509bc0c09411d99c68730cbf42bcd99fb893e8653e42a502b6b69ab5320d3ea6eb30401e292a6cf47e284692f2a4741d9dfed7942277669e5368ba617fd3767907203d8bbefb3dd32478f441c2ab382b3704432c2c451e9e229f95775cbd96b2b574749827afa24c8f652abef4adc481baa7e4e432ffe29c0eb2f749155129c170ca1948ff2c3ef2108635b1d3a85affce85a798c7dfe23feac05408325dca108c9fec77884830be02f98912b82666736fc27c87fc5bd3874aee5bc9931e48217e89533ef84f8b71e43a676d288aa9be346823f3c0e817a9d4e7ff2aacab7dbef1e03be7204a9049a586589d066ec9d8079d00d2c8ca3f6680ff6e54bdcbf6852eb9cbad8492e40c251577d46251b817edb1eaf764592948b536a6bbc1e3b092b8646642861a91b2bad1de00f7cf6be427a0b46844882f69c77d3589169f8920c54e3484354acfbea83d48167b6dc9348546cba8598ce7a449876272b8942846fdf7d5893e231f5809098198b8cf312ceaac6a0f047f856bad7dd6522a0f61b70583463fa849bfa4391794b82f6f2adb11ac1d66898ad6faec6bcf0d21305ee1c089b0e440b6c61ddc2f3b903c3d91b32b4b05e9a77995f7ca5bddd842156a9b73e37552637fc7a59d7fab233b02f06eb2b41574e0eaa0d08e5748f0094e8971df03b4afe5282fbae112a28f27abe9699a8ebd314ee13f77661843e950917926eb59e0665a0b16514800a78804fdd9344e0574fbe8e938f112aafbdf95b2f7ecc9d8a10f8826ccd19169583c7c13408564de5fbb87d916d80d3e431bf425d07d97be038682d0b37bec47b1d3b6a8d8cec9426c4a5df08b821e11240aa42f8c2e411ccb197f33db137f4fafcfb02a46ba92eae6753abf2623269eb7a5b41af86c9d82170addf2c730ca74ab05d313d657111e2b7a3d92021b375b7b5b5db943d8574ecca321d9b3c67c14f38b0046c45d38b5a1ce2366a63b83b915dc2bd0f3b83cc9e2a30a47b4ce31223d8e243c1e574f0e9ea89e672c940d98473c96b0a003b709b02e6657f8b527a4a33fc7553f2a10d648f1bb73bb0c5b0493b0412f671ed45a76451e1720f8e870115256a5b3a1e073617b775e31d47c1e1f1f598c8baa59b1e731cb68b86544804498f1e78180a5cfa8d461b3ca5325e4e74a1bb2647356741d9a1c5fcc8d4bcbecb29f0e79c467a922babf9c4f3802d330e4659a2b38a3dcd32edc7d952e8208125919abe6232ec93e64ddd7f758b8c26891085d097378d8dd0972597fdab4e80586e36280b4ee7c288932b613a55bceb43c5078fe39ba2b43b38b27c90308c772840b0259849f12ad88af797b74ba51338554a64472d408cc38266796c9e472222c10b706aef30b27b526b3e1e2d8c94ecadc1bf3ecce2cc3bd52b0ea02be0dc068e2fd8b1c02f8d7e517054f6bcc624b8e7e70834600fc43d6531e8510d4534a29f6c7344774e0893436ecd81b099623c62d82b7bc9a7ff5ea7459956117ca35956098b474634c609c665cede0e023f2e1d5abcdc32955de2618d6a3360115a060a15dcefa2d641362c0278379be4466c2bc11bbf2ed37c2c77b91634d17495bb8ecd9967fd907a634e0c29fe1fa574bb33cca52b33fcde01b659d62bffbb4c49a62d04f7a388fe6bc0a04d8aebed6b0184c1b9bd8017d06bd6c17f143bbc2b85c4abb2723580210548db0972e58ca588c632768e0b18fb0b9ea4c1996001fd61cabc68d2fc911f7632045362292b83188c70165c32cc792ed9df1387452783eecd255ae1b21baae140ccf9ad8a6849334944aa7e1851aac439a86100c769ff2da02bd37a56796b12e01477e74b76a3e1cb57a3aaa87442dfaa3808593c77ea87ea0468acbadd2022cb3bf0af9121065a14d47f0ec747f6051ba1fe398e6472168f12f41bc5fa771719860633da86db78671063aa86d3c39a4f54fd794cedde996a969bb702fe5cd89d77421d5b6d149ad81ea73e6757d5c29fb2fc0e1fe743ab072faeb1024afe5c9e4717c2b26bdedc61cf52b67ec2c523d6777787198355acdbfe5d8213ea8a4964991ec53122a245e0835827cbfe454ee8a33cccf48c62c9b42c53a6efd6facf4417a32f4ce067b54a09302fbc8c287ae5037d05a25e0702caa8d6591478a65d88bb9e4b9585058b67ff68e4e0d433f2b136c672b2242274838ee5b171815fe79c172f4b8b25d4749308a17d41b846ee161354b6720be22ba1b3adedae2e13e3338698b3bca6090b1c13c5c8a392991eb21d278d41a2b01719e77fa8f91c1ed73c1ac5a6595ef47d184a7327d3138f464aa58cab961f3d5278162aecaeb97dbb1425bd931663b318b9abe433c61a20222c1d7de42d4f4f1e576bb536fa924529803da67c4d3d9e970ef1854775de1442113578c8f53fd90c9b46b6da599acd57168518727e81e3b7cba3f09186d40bb190a58e9a870fc730f6e5e10a1e6f45a1d2f9c312e7d9d0e6f73e5146669b29582ab4b0881b989071f8e7d5d8db4fbe722064390ca5d8ed13ee8caa90a331c00248424f916336b6e5f65faa22738ae2dc25ee56ad3b44ee38dd14e88139d9dddf25a4b962d9e2153ec2acdc963b7acaaaa854c3fb2c862ee1640758b5aa2b5fa4ed14169673cf2b5e2f91c438c1f372a89d039836335ad02d954287e8d3983467dd67aa8f8bb4c3124b711cfa0c2f513949d9edad09b8416128b1479503906d090182b6eed417cd7385792c5a365687d08e01e4b6208b48371b7d6c7b2930b0a876fa5a062608b022c9d8bd9cd55a635cdca35921020ef1b058d7095b390caf3b01f368adcfdf25632daf0b5f3b2ec2e030be60ca7f76ae3d8a430bf27a636c32421fd11baa2c6aef5b921bb0c7251dd5605be8ab1bccb3a93d2c8e5bca84c33f58a7b7ddb1cab7b1c67adf5e47c943b3696d2bf3a41f6547cf766ec65e7675d86f84342fc3a4305f8cb3431ef236e4c9d0083292f72c68a9d93f906a578c8d9eef7369769f87d5b7c1e0f7cdc5030f4240109fc2ab36c8b650afce81906c48bbfa13d5308a1a15f65c7302b08bce53a24dcd2007d7b2a563c7978f52e8c689e4d0a94493bc5fc48ea1ef775b73d693c43f1ec4d04ab7011bd3252871d6f66075e9c8be2c8bbea46727badd254fca321ee4179e83edb15e4393357173f723bded3086ecda053f2278223556fcffca3166909bfdc6bfbb1f01a6405151a94bf235e5d10b9aa45f8c410c7825d3c2847c7f504708a2f82b52a3c3ee3b7458004de2f816351409497e653fc18afa99da9222bd1ad5186f72f6f11b43c2d6a5f1e77cf01e62e32447f5f8ba2ec113dd876f4c5488bd2999b8ce2519968c738e5eadec5c51792c435cbc946da1ce32a7a27ff0981a31ca89ea20ad9af0ef62f29a212d1865e2de2ec224b53bde3565d834ea985eefcb06ceae240ecd1739fcfa9ef1a6bcf32c52baedba343515a26595d903d282012c7cb27e5d502873ee38a0adb917203dc434fc13d6e3f6ee5b7f2c8f3d9bda684f74512a05b4ae3a0bcd3efd88d96cb6ec21d0645d044a185170cf857027ebfc71b3a9bd5862ed59879dac50012183dc45fbd77e9a712401d27edee45570aa7568151dbace02196e64c306f3d5aec9e4115e74181351398f2d850234051b91e0319e352e87b8b1a7b981de36babe90ca80db6a9b553f65f5829af0f8d7569a1bf9fdf31201c2cc6eb1e21ca7db6eda546f520633540f79e254132e0b596b5a9c06519f0dd50b11e8111d34a961a1f44e1332e1cc0506710f07406e6b345ee2fc8f6e20dd19d36ba3a53a44fa1cd1495fab238ac342e641d21cee86ec8863bef6725b9257115e71118e10646a971ffebf25ff3d38f1301bce091c9bb4123ca1d7201747e0d7e054239740c55e57cf19c0da1a473dc9682ef1b234d3f75e9dfaa767ebb7b641148e670be9b15874f8fdc35a962f4f89ceda758a2fdad4ee37321236cc7a4e2b0e630ff3278d7b1ac50f12bbf0c45b8f365eb1a3d1a318b1fe24316509aff6d607e4ebcc0d779ae04db90f1fc8c22443b04f96296a0aea3c29c8e34724feb8f12a1479d13c72d6e3333f440de122105270b0b6109b6a00b21375f8613c29e112417760c69025b55ec1467a7bd553768069ccd10d75102862d0cb1034a54c9600feb5ced1b498e3ca443cc923b37bfd41fc15f2e7e0098dcab59da618267e57ecee290e5f2c522ab6a6250887088382c1d43d91556a5520137c744ae66d4a233e0e359f77410b9e43d3fabafd7cda29694448db42149379c784f0395bf5ac71233995e723abd7efb767f5da2c8ff8c12dbf614f2b802b67139b8613cb6cde5c20654626ec64a375e6156305ea403a31a9fb1ab2dcfee30888ee72e80fa19641872844a9127dc37f4ec7cd17237b7eb8c9b32dcab89b57531b7b9c57948fe98449472029d6d0178cc24403fcdf48db895de34075d89e251c62cd053ec880b67310bc975347d82915f07b8a2a648ee41ea53f78b7bafc86ed85ec58c8539baed11c8c65247878e28724b0075d04ad12af6c6a7697c82e8b42238d33f31e0dd3020d472995b193cd002c507d64e84c648f37f75530d730620aefed3721af8efdd465d727860b82b8714fc44db83c31b0af408064dff9bd8e792d77428e3ec2e4aa2abec33f5779a91db2902d0fd21e64d3ddb74e54c4343a30dd20a020d6376ad807ed753f93a4ba6f95322849b6d1f1802067e4d5b368e57d4d5c9d8343174361f37cbd44e4a550b36ec1f5ae1152aced9c1f9b9538a6d32489ebb7c58a508d1043d9370ba6508c235d9739bcb72f0c50be9c4674e5264b0836079de62fdd8b7df4e6df525b72e468a07dbc35cdde4cac396abf8620dafa0868c585876b0444efce076e3cc7a3b6415533a81e6f3c4f6295f6cd0c649af8adcdb4c30917ebf2718013e149c9f5efba6d5912d5ae847683b2f666ebcf8d805cc16651ade9924c70fe2c0bd905cf2bf33fae7666869146fa1f6062ae851451a0fb443898154edfdc457439107a3840df24576a41f82779eaa6be1b9975a0ba728fefdb4a4f23f78b977875e1275510097113d31d252306976418cd589978004d3b7752907522e658762439a5d0a961afb189103b530a894c4515af844cd75fef664c74c8305e435b744b119898cae19a4370f0ae64506fab84b101536226523286e5afc2e166d60d6c3689646bbc6c617e4cb87fcdb337eda8c59d1ac956746ff866da87aa7955864f836064a66102c083961b3b8a0a58bd9b7374d748083a0f7c2ecfec7cd4c9ba0cbb0701e9ef78a3d55eba9b731902abca38eba49b7296eb9aefc7d182e2fb516e41e913c0fd0662330d5c1eca6a7adf74974465946707c66854f49058221c0f7b517489347264bfaf6be37962542d8880287e9bcb9e1bcc771764546e552cb6b58b803b390abbd65c56e1de1481381c4b6c2360b71f9a789f276c107c6f1ebe9f4cf46dccd8cce41275341d9ce3774418f33fffc2e09a488be6c2dd6a5aaab599178e67c1fde5ec5cafd09daa9584ec5ffa35c6661e0977cd5edbe3fd6d930f6394ac893dc71aa5650ccd76a1174cc8ed2a52b31e6315e49ee4103984a383bb5e62a01f17d4bfa0c6a22d4ea23760c8e8a137cf5e1f84d66d29205a8e429a0e1ff2c6cef473838ae5c5ff2f5956617679e23315903635cae01c8251c46e1f53285471f215c69b88143413e2be06c113402c41cd3e94ab61fdfd70531ea75b614bdba53667bf29ef230d437311d57b25c73a214fad3a6de966196b7e106c4877811d47a14c443c34d1979ccc75bd02f57c735e822f6e0784fb1879947d972e0c0a87d6748b6801d21f0403a21f5108a48ceaed0217c27e147d15588be7c719d1ab17c0a641421f2268876a311e0ac8ec2d18cb36fd339fd854141a9de6fd7f21faedb2e67fb2397dff2aadd302f1880d518df0920ce4f1e20fa27ab1c1267b84bbf1e56d91d6362e073bc50f44534a5c4685f21df9d9211d07a6e94cc885f127b9c0ae046a6df673fcf01f64dca437849f8694af3c88efbb88d4df9b5dc240e21eba4211323586f57d9363a18ad38386975118b331aa7e339734acd28f6562673cb6486b838800a4de2a83c34f91fc6f891bd4d60eb6c9cfe1d7a5a6a3faea0d249c2562008a42ec0a1eab781bec99f8313bfe39e81aacca1270b48d98ef479ced0b4806ca4901043d89c39ac54841259f50e03cb83e3081e2d9584f696751b527c65081405bde232e5a336361e87a26d32ee3f4dcb0d7eb55df5e4f45a36f5089c1dd825b3a89a6518e9a583dc2d7dd5326c2e9643a88b1e06e073ded93f5a4166f4571c675a940d8f33ab9a9cdb153d28b389ff9ae69910c126dbb08624445c3e51d983a542f133f133cc66d69dfb9e797220bd583ec2d7fdfd112e948c5c477ef99f683927cc30afc797c1420a55d5956e8699cda788ea5850c023dcb5073d14033deadc195dbfbfd29cf7ba7fdf7056eaaef7e8791c9e1ae3f621204099b5946c5d7d1b1341c5ab84433d1b6b6f5a862db87ee91657be8c4d4d9ba135842f41f66efc2fd9132749460e67ac0e0f575c811971440745f15222f6e8376c15fccef8f3f8531670c3c1e8d22bacf329d2a5a57cd17b4e0d19c53e1430994fcafdfda62764e8a8a1a9f3bff47762610896018c2aecb86580f976f114893cadee0bb5d65f074f68c35b568e307badee59eadced679fa62bdbef1d451b09bde9a8532de750f03dca2eda94750972100cfb7bdd1258d01f83f1abb2386d4413b6cc40b08bf47b9a6300a8b4fa27cf57b9b6bed4e7283f0b888de20581c290842cafc59a418e90e72e7f0a91dda6965d6451c1d59430794afbbbff40e7185f4a53518b1eb77dfbf7e8c39e208f8c2e4efb2148333edf09d5e24d521f015b49c3e4c7685f1a90b09bfcca337bce1b5ed4db9709dac7955a89190dea83a8e3ec3e6463fbcba5b5657f590dcb0c369200fc1143898870498c5ce970c401aa83d62345a3dbb341251025509004c84309f1db45b2276b579de895da8933cf09f75a61e4f40bba20c49968db9581cd2375c8f7ac3db48130c441d6aa94956f4c48aba12d6d0ceed9048b6f5277ec7f71207f0f77c67741e6a3deedc89ad994f755bacbd994f87bbe5932c5f1ec1b17464111bc3b2dfe3ae0a22cab57caefd2e477cec5f07678915cf9463a4129585032a68b18001eaa256302f42557182017acf4de6f9a77eca6e3840e96d4572fcd19c69e63c17d02da2ab398fb9ad55fd6833e8723b6e803b11c1df33d68f2ba77c1dd13b610b0bab60dda5450279a7b8b59bee6c91991e88df65025a49d41e2588137a706453418f2600654056187dbd3126e6429f39b42fcd9e4921587519a566252649d19de619c35920fefda568dc0a7a76adf50661f527788a332d58b2789e9a127999f999f9ca011f728aab48864e32b73e4d65b5d54be88cf5ee07113519e43fbf27fb08212cb082b6bb4962fcbca7f03121df2ef3e74da3c08b5e105a0e1744e0e9101af6cbcf681f1d804a83c9f57cca577f5cb5f2921d3f0bb994669745bdb59072dbd97fd82a70a124324c9142da3218b6e51870f4af6358544dba44587aaa15de3aa5f6df13f6153b9291a65e2796a635130f9cdec3d9ad5c10d25f26b569774b781ae326d522c4b6dace683d1e583a5141f5a8ac490f1d6e5afb0ab9dbddd086dbd024fb23d0e112703a84c348f4f903479cc8510b60d3000a888d28b60b96db433dd251e0118e906dbe9778c10eed10dd49e0b6601fe7d9193e380246d43f7c87cd374aa3d36d9a502d9fc8bd4532fcfe6bb0539e142543a334fac42782002c6355ff95a26cc0c16a3a5b686344fd2a9192d5c96d5172b091ec371fe55d91301a788e23b7f8538b4548c59be39350a09ad0bffa55e1f470ff6dbf167b2d6f0a812e24c323119268b2d67b33c1b3a56b0367871f14b4767847df2eacddf5a3706035fbcf55eadadc2fb5ec41478670cc205a285c1cf6dc6d2ff022733709a0eb472d1463b52eb6f8d589521ff2cedef75c79e77eac442426ac1a21eac5b1cb34593b6b8e5275883525be1d0e4783eb8f2f413de5205c7423f73e72fe39a6b7994e952b4a6324f01c1d5a33e88e1966aa383d086b2e27a7fab43762e429c1a5f2f59f654b71690ca0021ee25a74db464ce69846a9b670fe54da76634040b03fab2df3e6a1283663d78140ed37d992cd95ecbf6679510bfa87e732469d01a6b37f9265585f076d881dc0d00f28a0e9d8b27cb5afea1ed51a6375e8d3f3a1b21e3f7f038f26cc0cb671fcc3c1a024394831d5c66f2992b6e43897600e352684f55c0929cc6d8b6918183d3acee5e11c0e74f1c121735f4f63429e0222fe0309fddc815f8e6caae33747eb52767caf27bd0e9ace4dd21de04b77063b8635b548b8e36e0edbe799fb40aa43a9157b6cd47c80200fb20d2c7a183a054127546858fcf447c504e1764b31960a88d3db5185ec0d3560d3dbaaa94128aeac405d0651fbead6fa2387a4107da96abc1d37c7ca7799d8649e357d65b19d393edfa519b2e0383f5b39f094a79eb0fed499c102659c031633b26ce3ab1b34d7047d5cc2715baf2feed5a96637520a87f505820dc5f7c855e72b77e095d0b05c70636ee2af4e34c98d87f3aa9b8885fe5dceac2e04d3901d4e66fa5d3dbb70312bfc7893f69faaec2a819291ef4b4bf0c8122424d9a7097776e687dae3b925ab65c79b0a97406757c98fe63eda1a436162b9f00ba0f0b8d209a778cc10ab914a1c90577a7ff273db21ea02ef2eed0180fdd2bcb3ec64ddcd9846497bb70b5656efb89b1aff3bb8eec161971eba990b1de0afe035070c08a5a31bbb030c6c3076f67129079b059497329d61c692b82125fe50b8b707eaf671dd3937628bdaa8cd1d222ccb61917044bda9197bb26ba862fcc4b4b47a53eb94792d2c64fb80b325165417a180e88a37164355787ee33a3109e95596976ba505c52878121d27a3b57ed240196bb8b0fc3bd7a02e6fc3699e7b9c3332b256b27c1e3a7af81cba704be1b7e543b9e411cb097fe84f6a77e0ecd5f124e188352812f95226de3336ed440c5ed7e9a3818b4673107d864a35d2bb41049b1f4495650813b7900aa5de7d4a2716b6362355b821ba0e2dfca7f2bcc03e64bdbc0cd80a5e37c335c90d73863a55ce3f19d238cb20d881ceff16cf34ec9260f0da4df7b59c0d8a43ce34627028968e37d50169c4e25edd1e23c99ac81fda3be587a3962a68de2353af834a3e9b1a1233cf9485dfccc4f87343432a2c212eb2840188171ad8a2268133710c5b9b37c4ea8f1e77dcbbe36c1fa7e9ea1ae420a1a06ec91af902346356eb9aeaf526d8a7044cf1dee4ab8fea90228a236cf46981a56e6f296c17e43edd94d7e8993e743d8c3d21877a6832320d64a50e704cd2e04e003ccea5c4c011a8b1228d630c0d318de8ad51d5b506c92e57e5fed702cffcd5b9210e0a97d7e157d30841f7d55315122366b3bc6629e7d209def9f7faf11cfd7bff01bae47194a7fa32c595f9c8b7fdd707b923d3263edb666c79f4939c67a4af25759751c902980db90c49fa7c3000caa0f53c46871d13bc6d629d4180a28c02ab80018369b3f715b37783efe3e7694e7715d6296d5c5f3a214203e0d0482bb30cbe93cd6ccf135d82bf1c327bab545d27ea5e081bdabae7682174b4bc3d11355f7edafca4b71c5b82ccb57c1664081f3e772b8158d6c955855135f349141773c5383f92f752a1702ea3220ed157b61c8f8f1badb3f7176a559a25ed2977855ced00882458028d05a2279a2b4a1ba7f8e9001dcdfde63e15bca7acd0400f48eee1ef1ccad3c917028d0b3df2dca006aa6093b30a19132dd40a53bedf20966f822d4dfb0cdd889727533fcccfa9e6eb8c01f454bfb01e09e6a3ad6183e9f793fe385d45517827ce2d592bd6eb73c6589e9066b613399bafc8f00274afc45810fc809a82c95537d7f98ede77e75270873de92ccce5fb11ba54c6f9f9fb93386c9a612f2de9e05da04b26eb30fdb57b5af2e58b4c59486ff54a79d9dc7b0258589a093902cfd36c435fc6642e0aa04b77374849b37d9fb615f155ed9c456e9dc8fc40ede510cffd4f189cb630b592286c0223f29d6b8bc345438bfcc360ec3ea8712fb009fb05c8fc476699716a9707ef321e7669446f14f2bc7addca8e2852c74e7f198d300e4cd2a7d8cbb05eac0be0e81ae2692429d379340cd77bfa236bd77a586040ff00c3f1c8f06fac8d51c4b6aa2f540301b8e5a8226bf83b0d93ca5ba3871f4a3bcd2a46cca796dbd25d7117d8371128ff3f802f5e42d27b347f1e7c353d12544c51a52b43e7dd72696e59af1609853e913859e67a16118590bb88507442d67f49b4b8157f79afd108eebf980795b90f4ed1d0900a15bcd2938a1e951dea1f05f024092c3eb75c25a3750c5d734521b14ef06aafec8187c0a091b5a70820107a7177ae08672b6c6f9745dba461009575da8148f76f01daacf9469f6efef12c032c836a95c8a1f639b0762d369f2ff3f5a84fbcac06ef7e1fc8068f232ce5117783647268750e6c427db081945da41bb5c423ed2f0ed3c7dd1fa279f69e77c2a8bb6c5a5e1f0bc53b8004ce1f739772972fbabaa73de7749bd085e07e2e6a0bd29de27196924ae373c2ff5f5423d363f1dec78018f2a3080e8f9c0059a5c29762e38578d2a96fbcde2a80faa26ee21bbb94ad33af2905a42da907e890986f45b9890db06153054a0523e0c422c64234424f3be2bb671984e089b0c8df9abae1dcaba8f6924f4db99753f50106cd746acb38b25638165f545725181ed2a4a64b19975e65135892780f4fbbf677c54791b2eae7b3972c53e9edf20bc4f68d53769f1fe8bedcdbf8ad72b801d970a7e72389ed509b8d61f69e2dac4eb2ab0bcf9def3ecc2b107df7506a25552e4032c05089c177077b28d2100350b730bff72a928cb2226d8a29db485c74fcb3be752bdc66811e9a61cf0e460ab674d41462454a04a110a55381cac3ef1084477e81e1ca9913dc44cb9004c8f72cf430af8a88e837428afc5f3ac2ea31f6098e21caad5a9572a7211a10c5c48b3c4c58d6f3860e9a133f74881533c91de656cb2ab6c4cf61b9ed8a97656140621b2612601dc7ccedc6e51908dfd1cf0ed5b3c2a297da33b2fa40fe6fb28abf9dcd197bbc14848a98ecb00ee036317a313555326e9512c950a6bd7f4f493f4cc228eed4caaf1967b53c4d3d70416b9b96b2abe9783adecfb319ca6d2ab439b634f6cbec1c9102d9818209281605a38a6f6f1ca3f6f9bf8a7ecb25d721d927c913887704c7e0430b04ac46abb69018e4bed0506e72170ae2c3b64452ef72f5f2217c3ffef28b89e29f82ba33cda168f8dddab54493d0e325cefaff3927883bc846e889c4b70b4c1e6184336b300dda1006f17535447a7cd7179c77fc7b81b226751ffcd39d897e44880b78997ea7f3e5ff28551b57c9c31a7929245a20fb4ac565a58bc315ae80901779565c60bbc20ae4a1fa8a462c3f9eb9bcbe87c88b77cbb56c0719003ebd227c38c1e371407ba3c1f06b645c6aa2479d01074a3c92fe3b61389ccb4d3808378e0131cf0710415c7b646c25c2b10d2ea877675d1177a20d30fa3fbc0ed1f25b80f10126311c895d2155d25a3b34f8957c64b1e46dca5d5ac62f74648065cb9696651127b616106849ff794fdd60793d3ef0bbb439f56c38ae44d720870ff295d4d5274d10f89c096d55b76d51e5d4663225569f7e7ec30f1668a6b66ea855b07a6737b531a8ebcccf11f329d1bbbb5f657a050b5fb28b12629a20dd94cf316e049a428d4474c74e23e65ec165b7e3d87f58002d0966694c34b5824561e774e60838c156d7e61e4e320b4036763d307d94a165873d91243e40664b069dc8ef2ce3c5454b882597071d4efdc011ccb777d433d41bc2fad3d16279d88f6e3af10a8168da7c4e39392758950a4bb6948a058dde79ee383ddc2bab89a0ceb893dd94c4628f2e8b53f9f21f493c0f394d2247603ac69506b3358ac8f0e1fb25852ce611aa5fcee94bc0fc7bf422446dc1b3bf2b082c415f8398ceb9985f71d29bbf8e3de203473c7c437dd13d34fc78a83f21a8cb8a38d6e323f277c17debcd70b8d89042ac49d107a3de17f950201320e13a6e53b3c73e75b4072dbf601368c6d4edab37099337cfcc451abef6a6b4c8f18e6e3c8f8eebef95714e42431750ccc4c72ace66b71f9bd2aaac3e5116d632a72ebe0280c9000b917b4fc4454194ac8d4fae247f0e66b46697939d74aab23093c7e76894a85015939d01f13247908d7b78e8bbc3e386be2ae31bccdd5102c2a0b1119e7704d6f7529cde2ae3f5ab8f41386ffbeeab17a2825c7d9e6c9df3619ec6bb5040e4fdd3c695ea105cd52415874829ebd4d64211f45c43ca84b46b4219c6346561a815bf9090e52f78b36cbbfee2b354f4c6d625389ab2db35dd7305f22fb9fe6c04bf053f82ead5d8121bfcb8d9c8a6fd1e511b0a34df959ee33cf6d598252150054543ade45fde48a790be1b1617b840967aae816710e30573b6a93e4c7e319cfcb12226b822e3267408eead7278a132492d15e21905e0c487b6f66d7407ed55765ddb1479b13cb16655b759f3bd1fb26b0dd8cd36b96dbfbb34c6429e94c4d92142631a6cc7c5e93ab32e25fab1e9df61945b0fc3e7ed87bf37dde69094cb13b86141b95dce6db4fb538841585c34d93f3d3acb194ba6b6ba7064afc8ba920fe075e93fa268ab0e9fbaeb382a8eb118131301a3443cf33513b12884f95155fd2a0c98dd8a54b19374d99d17c9ef253c91820d79f77d6b4386250e58788093b5bea52104e362b1c12b75b2722e349404aa39e2dcccb447cb876e91ce3e2c4d8dc444237a5a23866b11e1f6b5add70bc4fdcf9de94c34cd7e47d65f9d258724402ed5ae7d42a76094ac90b651724c60a53d8d9e4279127566c80ff77d369217bf6983eaee9c202ed49c064b4498e6b92c0f409a5a178ad2fa15b3ae1bf62803afa8bc425e4be98ea33634bac744ca3823306ed1ec1c8f69284da0349b07c6f421f8ebbc24bd85721d0fca86d05051541cc7046dc419a0f02bfb15fa30f2a292a9babaa1675863dd11e5e0f3a78c1091259121769eef0e34cf5496ffc4be2de5a4be9fb33bea937eb5d1608f3d754d4401b9718f1480e1b5f98ff35ef8e8fca88014dff52bb25afed48c653ae541d4021a8a292da4a1e011d7490a1f9614558d2c77162d6daf53b1b42ae6613410a4832bc06022c11a95a063d23210b1530971ba85b5a1c6e5435c7c5ae3a912855304f8a992cf224fa3c5360c06835983af40e9ff51d3c4d66bf766400e2b9f13dc5964d691a274b2d6e1929d57489437db2e1a542dcabbfea06995337f6e0b7080b929ad5c80fdaf6a98e6444bec23c9d9882dd5cd23e6de874e166f889a456a87509e19a2d583ec4c7744fba089b4fb0de8c89c0a81ff8e2bf1f71b96cc105d31dec86195bb0df6fa3cf5f83dee0e522f3dce0647f6fefaf5a47f54769d1c094462c2afbda2e6dbc388ff5c526914d1f21778664819ac6039044d72d77228e17a21b2ad8f1562d6c098c74126bcb2e38a64d380838912904553a51003f548be03799dba2bff5985be40a769ca67f2c5ef657f826dfb4fb9bc0df4f3edfcf8555c7b8bc0d63bfbd385c986a9f031329ccd716b83b06531c23f37a34600c85d513d863aeb2ad5bddf1d19ffa7aeea3fa885392e0f163d67a1e9afc3cfa483df1bd0f5cbcab7ab16d2c1dbe6f72a3e5b55051d0648fcf6d373b00d56d4fa7e040b51da61e266a7fcba1e549e3934da4b6ce8d5591243ec24bd28fe47082000c15c5b005717e7a9ba4c7bb180fc429853fea55ed9f062763f94ded5763c6af8fb1b32cb39b289405bdd870c86be6e877ebb6d577ab29570ed59fa52dbf6e0837bbd2c9a63506f9e4fcdcdd95a22cc3c9cd5e0c0536e89748b2129b358c86a8b963333909dc5032470788259399f664bad8c755b820676fb2aaf303e34976905b422aaf554c1f1e308dfb06e047d7b614e99ee6ab4a2cb5d957aa243beeee7760ace2070adacf038a33c6379d8a4b6b0fd4b21c896480907a010e8e163b9dabea58553bc898649df22e86524747da85b0ecb5a1b6547f6f6f91ed80de496a40a3e331f467012ecf757a2b3ba08c7d7fe8a537c5dfd9453d595e8f767591e93f0cff6975436bf937ac87651061d92d9342c9622a23e942950e3838b553ff87140eb0431ce17852f8b0df5097709a69913a89bc0ac74a34a1029f81e867d46fb9f1f583c4dbaefb72ebeac1c4c792b98327f5d203b38246a337e654c3f9baf34e30e5ada39b98fb74a87e4e57b51e749b299a86f212bd57b994d94e04b99a5cd6e942c787b57e8b7580b6a949647bb8acb36962346d7503efccdd1eab3e73aff8a04a027d4d409f0290509d0da6a9295f0130596c84fe401854e9b94cb7fe6531b3ee47fe8c45b3b9da6cb46e2f01aaa1b85599286dacbc641b03b4652c2c9b4600c58aff7450c4cc2f9ef333eacdb252e28a3f4354fe2a6ae80ce00917ae3c23050dd35a5af284b0cd141185dce43d30418af89fe079279e48e8bae9144168cd0791dda850299dd7f9a10bab2b41c118d487754c694fc2e69223b96a44c9f565a105c0e6b824b2da5c4af07754359e7fc73b570132937db311958c064d9038ed586bbb4d917cc99cdbcabb6374ec50fffdc6cbff839be2c4954fe14f2a1f4965f90f5dcf3d2fb69c449b883a19ec778c629d594c0cbc1eb843557df6a3a462a6305ecc125488a1e4247ad5d972b95b2ddc3c29afead071996a7b7581852cd1c7494ddd5d4a11397a9b179173b08109f2421b7c7a9b72fb991e0a585c33f4f894a167c8175870df59965c65368efe2faf4adaca435aff7d1ca310e8102b256db51b95094caa0a101872b0b939a91a181e34d9d55e2e51aa5a3705dea34e11230997eceea350d28232a61e000f1089bb08c87c2f0b76b76acfe8da74d077ea87362a28efffdeec055972af43e4714af0e93ddcbf80fd0ef74ffac5d4d95a42d52607d4a35e03e65f12b2ecc672e00586d583a2e78f140c33afaaec00f8edab9bde9f6663b8e474d9e82b5e535ec2901f9cc03c9d6ea90adbbbb17f2d60082585040671e1d02ca57ce5e1c7762bbe910a73a69c77e23d3b5acf9a3ad7f9a01f6271a2fe9b2dc76b90dc64ce84ab4b849424616849380cc658c4039550446836d5a127ba82f3bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
