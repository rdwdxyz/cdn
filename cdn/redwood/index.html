<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19a8ba9d8cbef9e263d4e0ed7f97013da637200b4eced144a72ea672abeb1b81b76c9e3f013b08a5405a2a2f338675b7b18e02fde3af8cb0f6754f668355d8fd4adb7b706071307879ca8e5a42e86b624313abdfb899f21c7f125001127bb0858fce363bd76957f8857c2e14c3cd8ce0f9f60f9fb2f99b54f604c049c81949b092d1b41474c7f8546e8f59d352b304db6db137ccbf200a8af5f7d7af5e5da4f81f2c26423daae1c3502b4645023e2d37e19d729756d5c80b61b6be6aec621eb0baf1756794dbc598042d2f693478f51f9cca3fc816553f860e7127aaf159a2f25e7a1a486e84e4340f77851edc8652850966ae7090b981815b0116e33cc6847dd0eb221a846c33e7368db2024dea1bbb61aa92a35dfbea1eefacc7c7d9df234ce08e076a382758dd79ea2efbd1c275d8129c70695b5e64f9abe39b295bdf24e3ae6a70548591fb30be16febba9d54596e60c78e272feff7474954c7f26dd718bad4d409a0e556801d8d4fb4e292ccb5b7d14eaa5f100913a194b034bc20ea1424a76305af6d2697606d8958e2e31ec2e25b9fbef04e0b0d290aa33f9665fef1eb40fbfbb4275848253e674a0c0853b4ff02fd198b8c8a74b3a1bfce959bd2585024e517e19abb47f2c6e0b53ffe9e4b47497aa71631291bd39d0607cd675268e807cec3e80301654d69709812ebcd0cbcc65ec772563685fbff28ca561043da542538b93ec2db31d901ee02878e5e3fd9039b61b0e593c51f494b423c3945497cfe617ab6af6cb17f2a205006d40370346f0823ab8b710a81ab123973123ec5a8a6cb25101fd00ca0b28d6b0d6a232e0565f6d027dfeab0c202f2dbc65852d6fa6beccc1cf9a5c415f3759653d16205be534590a6e4d53d30707c910188e201c322b2b3c11b9eb7fa86e9b0287ca6611ab5f20a3ebf6e6c858c8ed916e6bb6f94ad07dde6c4607686457d90c017c2c8aaec51fea1af8c01b64ff40cb85d77000fdac894c30b25b3153577282fe0c64c39d0c4090546cf351233bd68f1ddce8bf30242924b683dbe18da9187cd41fe8783eb8ce578e6c96fbc24ba6eff3e77d55bd1577923093c9c1b60490a1833e28bb17a187e69ce643519cac0d4d343434c4b19e17fd6c0ba32d7558563f19e0145746780a11ed77e1a7e97aa5dc0fa01fc30ee70219739f90548ee24bfc0b110d1d6ec0621e2bbbe6af4551774b8a2990d83353f8c4db903d275f0f9e566bb553240b441dc9170dd030fafdd9b931e9feb7515f1398150c25a8518825136962ab7d004ab8d8ceab73951a5a19db6c875f7b88a841a8271c1501c07279b69b6490f3af80dd5616d38469bcfff785ab0313b729b1a545bf08a72bee5d17afb9b0495f2990e2e9dcefea9e524b63b48af66429ed018683ea2491eccac5093b0fb28b238e0dd60a6e83bf3b21af2db689a3411b1ad0dd304c4686fe791faae05003e43da38fa56d61a17ef458c55652d2acc5b6536c410f4ef4977d2cf1e146ba463a3d783abcce84cb1ab0e931175b783162d817ff4bdf315f43d58e9cc25f30635882cd6622710475623327917cace88f46c7294f753a40be41bf7b082e772172ef77d901d6db5245ed943ec897696f8e13acd4e6d9252d429785c4595f04a127a65337d55198ee357223696a2a6fc44656d4a895a3ef28582f2a5a30d155a72db5a71b553b8558bb1f06f7ee92b1bc658742112183479ff69ae5737df6ef8d40791700d5c7f0e5bb82a6ea86e04d3bc2e6f8dc3f89067615d79933edbf382eb127b87a767de59a6760c7da600fa492bf890a362338ddda0af5c8343492b75c9a99c5093e637d943a5a1e57d2d24014d6e12a28d8d60994d9e02b48523d6fd16f6bc86dc6603bde9535476cc2a53cb40b09d56d8feaaf95f43ea2c967968a56836ab439ee168cfab276e9015c89632b858733de173c24d866c22d2cb844e5328102eecbc5b4d5839231ce918bf61e2680f76b9364ca4de20d8f8f5414c801a8c58cf56049a829c99054a9b9f6ab7e5955c220fd1afdf4728328cda658e7ed51a00345e18968d23d128a05108f2b62751360080bfdb412109317b7c034af128d747cac0ef414e05eae9799a4d8d22ea47cf8fbda93fe5d6410a2760f4bf739817c2fc508d6f8ed43b5c43d812fc4f61ccf21cc2223f1743122136acf6f91c0a36b7e354e2400c7d867e6e30b2e1db8f43258b0c70f9c3d41387b060ebfc63cbd101cfcf00006251c76e258849bbd2db8b249a58d20aae9b57ea1b28437c14730e4f9393e6e7362d69c37c2d027679057614e40210f00ba1c2126e3e67d538845a51ae6eba09304687317c2684d6348cb0cf26efc8a253eaa3c0352c14cbc5b65d08a088419b146a9a6cc80091e7a81bbe1c6c0e579283d173cb6c524dfb895187daa7bdc143c107913299ac917c8099462988f3af605c3f82ae71675c19c236701fb7d10a7011ad029ed3e7f38f489b01441748990a134ee4b5647cb0beabf0e427a93add81124ac4ff76eab41649298009f7a813774ea98bfc6ee4de236a7ab5256f54836f88b416f4267666204c0958c577e8866421874e443e076c02c291b4fef55ce2b2c0b6fd1a2f776003fadd3603536792ad0afcdfc1c0d972daaf35e8e7da6747d63420851f4b198503ba8e33b5c46e555280c08755006da27c73de1bbb852e8b2f4e002030686987ce80af9dfe552c674bf7e5364c7187ddbbbf5eee9e21dbae99cf3b7205c30dba1aeadac5552f5e735ca6fed1511e245e5519645e467108af9533266d834272b9a3be2ea34c44f9524bf2c6db62370f40dc25f8ba0ae528184b66803e46a0ee8cca10419f346ed55fbda05f698ef50f665b55af9ed404c6982618ebd456576205fda652702061310e59144bd04dac487fb27400d14c6172ada7ac24fafd61a6b4c24d3b27d2f80ecb24a9e4bff5d27dfbb7b403ec30c0c994fbd0524db2dbde9c466ef665167efd7d2e915735b3f82c77b7d2287328064b2558cb3f5540d67595e95a849a9e2fe530e9cb04e2a4bd724b42eabe2844f0f43efe45d8ffb63adf8ec643f2830ff810c0371194c22862d3f3db5f3bf9ef9acf265b166bdbf23d2698b55d2e194051b4422f0b9594d498e53a5eee8dd017a2484d1bd679f4123a57daa49e8f12ea623096a0673f54816cffa456e7398f9f82d036df8f2ac30056be601921e08854252d886a2bf842a4da7c730209dc136486222c350d6472ed35c45f13390663feae5a4adfa32691c3c0ad176f89b4e70b027b9553867d49d652f10e58aec018fbb34f624680c0ec91b06cffed83b97cfb9f80c5b9653d40479fac33115031f74244cbce6fa162a971000ac820c13f85ee0b21c94cafdc575922ddf98eb101d879d0672aabd995939da1eb44e0331e1b9811809d917038fc1681908b7407fac425a145312ec06740f4739866b141a46b3a5c2ca9d89d71e2a65d9078c6b56a8d6537d1142a10e0c244aea4b25c49ff182e16cb600e2940eb19cfa40b9c1724dcf419002bec2e486768a210368adb30c88f981c15f494d80960df526c947ccbdbf549c32850cd5097971d962672e80bfa37d56a3bfd6a84a415002c76a3e5a2f83c687288321e3f38333e5c2bc059ddd0613e2322688ba4c8336ac819b07e421caf33aef57c8d48805a419dbc6b8d1043e1a7d874fe3af870fb9014bf36ab12c59b906149328623c10052f410732dc4fdfb32f233c4d7386ff175c93a34413730773a29d626a247b81c9083ed26977e93223f16634e6d36fc52fcc8ea98a929745e7bb096953cb17a28729752a14c5c20e24e03b8b8098c7338694472acdd193d077238dacd4902631191e7caa388cfab180020999c64d93db321f9db29bd87bdcd4b3fa761056866a314b24fcce6bdbf3ea41ac0fd32bde2c7578af6dba5877a52d05d780579dd1a62f67d3265a392f6aa8ebd5388b75302bdfb0edea51803b3176161c4f81a3b6b49cf1416efa88e1b0907e67995856faf89e869c6fc619d9da01eb7392492a201125a4824ef00f6dc70df7c730aad915a5691e468dd029d3eb2d850f45c4c6380a1db8e676e7ff4d271230d5e004c86831c07099116270916c79571b2c7ef1463909e3f9e39bea19ab12fecdfc66628473e3e65dc65b6c6554d6dbbbec7778a67172d185057217ed858c9482142f3d994f5d8a386fc6e254fc1df5f5e785d312a57bdb9e059c3c63dd6ddd028136ca7a086529e78626c659ca4ba0492b13646c65d628d08466f793bb6531e1147f5f32552e0cd8cbc7e3069fb89a635fdd1f6b47a97d55f10f40ef228e143f385cdbcb89d0a6df8e584461ddd5791598553826e3a72866fb49bc5249b2c3c648d76ac9bc2d641365f20fb24eff6963d249572f21eb9207655512cdbd7945eaa17ea95ac7630eb4a13017c84f813e45339c5b6c61c7fa9655efd412a8135b1323fd314ebb75c42199d3421d3fc7c8cf9d705110f9ec226a9cb0cd9c62543167c9f02359e5a6bd673b61aa1b61a91672e3669221100e08653e24b2621f12f44f2d8a2aabc138aef0a98a072365e6cde5e54f0644f7837bf2a29ab9f67b93c07d38901d6df5ff9d0e0265bf056739a8e32725bec2b3ab9d6283082dbf26f3250d540fc7c7370bec2df842f9033f0d747ce05757ae571a93d85b4225a43a146b2ca783156f876356fa5520e1757c4ecbf37fcf6c357663244b3a6baa211f64dc036708b3d5b7a17942d83253baa1019709e8accc545b75108cbd1b6c13bbf5c15d6b4ceab7cfd70fa9c582a50d8184e59b4c979c8b24d1c7b087bd1f8825de5606540a9b186c1c213a9dc938b343169424b2c8e3d2d355756825ac39ce73a57cf950b2f87bbe6933486ad0708fbb9d7a2974e476d8ca587bd3af574cd9b7a2acf7a9da409a80c1618e30e39521c43a572c69566aeddf52dcf2ad8f2b18d0bac04b7203bf4e6dbcbf9b53f368f87bdd0626aa30646439831eac6052be7f449bec120e60de0cd59e55d15b286958e11a79b27789d46bfab6fd288e60e4e555cedaf4dc8da08c71ef4da0d7f48ad7a52082cd134f9b1845154b2997512655385355a3af1ca01c770f016e0a8c7a6d123c18b8a144eecce1b8929f3690e31b37b81cc2250d9816b7da2d7ef33939e27f4033ec73a3ff5c68286c06a7991e62227a3318f4c9cecb73addb4add80e90da2789d4d09059256e4a0d628f3e2cbe821b1559bfc23aeff6d8a3a9e5756b7596d5a64f9a60a238726976dd95201542849be1056f353ed7146b1239f5bf5195b29854ebaf62ac6718b6271862de0327b8f7f6f679e3dde388d2169598e12de6105478ff1b0962c3b26695536eb315bab25c0ad93ccb741aa05f7b13e76dbec4b6fa6cbd4ce4e64d23507a89fa493a188848f083790dc475cadaeaa1d631285c780488b17b8858d033e40e2d998009c8548d6f84721b35f945e9dde1f214ff563b439ee6cf902762964ff33fd30add6274282312ac2a09bd22c37b6678a24313ea41bbdb145293de725bf7861f24094aaae2d0cbfba3ef40d4279c15fd4d85060fa783ec0f48c75d3a9ed2b4272dc4bd6a71d8e326e98e762ded86c3def1a0e49779e1e9d217503c06fd944791628aa3268c997b76b0c58a84771774ea5e4f7ba70f8d380152b8efbc3d00b2c8881498a0ae44d93bf4fed1a816e786ca208c4977354aac081e195b04c1fa04efb01dee6580c6ff53d09c0e6d970707a39a647bbcb1217c43df5e68adb5fd1caeb9740e2a6a3ff0e58232a89446aaaf30d42c77d45247c39b432a942236121b2395178e75c9affc991abb0803d18a88473a8c13839dd2f43a2e462f63749a187b60ca761fc55866bdf07c2749c89a568b003accb56ad7b49b83067b1d671dc79b6c1439209b555a3fc9875515d5ea43a9d02c6e88eb8cb78034c0d5cbdaf023f48f75e3506cd407fd373da5323e8332646af3f34644d821105c67b49e00e4d63063351b2332f891740baaa30f1d5f9abd5df1a8d31a55db881918093e68704b98153d31053a1d745b8c305d1f640d7e50638b3aa33173e2bb09758ba06435485756bf4f23fdb73b09edd64facd8aadeef3d4dd0402161c71757fba06752efa1ba2ec6fbd454ad1c44da09c117079ac79ef4f7695b4c9f73a16daf8471a8c1ea5bb662fbb82c6ea3820577c7d39b90c49907c3256f1e12eb23d312084c2ab2e709096b0893350cf1cca6c59506994b9ef212a0155202602a40eb8ab1ecb4391e11747fb494ae95133f15dfcb2e2ca04bbd6e1b094f5c6567c389c079f2fe3d1af990c669fa456b1b81db04fcaa1eada84e924b6ae9b8a4bbcaab27b45571338c4b3a97bbb394b10a0532718ea6d86b99d2545e4e6160383dfd9cab9e46b720cfcc19dccbceae69806065692f224112510f02321ccde16aa0bd3fb675f04de253fec332104a3894a90355cb04c07f26987ed2de9e31181de5ece9076917ac28565d04160088a2bd6e55b82cd8e2402ea7361420b5367247a84a4313f41c0c1b1b42f0053782f5fb97855e0d3b64dfa79dd5223176d7e93ce3fe3dd5c2f66d462af1b0fd460f26506051a304cc339012ccb235582c969b61360e917bc069feb7dd62b143f8f40c620a189397b04f6b1de13c365667c4d368efcf953504368d11b770424cc52eb08beafd31534030b89e0b3cfdb94d6dc95c458fefa44796c7c72cd847b471619b9902ffefaf387c01201ab4eb8bab0a79b965b9eb7551e420ad4865c26b55543e2347025ca721627a67f2beefce71005ec3451a95421b02a5aecbe679460bc32ce7c96ca646bcafa5127a33859fca14542fee646ac48718d8b3daaf78d7bc81bdceecc8d790c50567783cb20566ae4d4f0118c1a617100c7fda31dd535b3097dfe718d3da0bec83682d5b950b5be24f056bda4b4c288e9d427e80cb6745625f20cc875b5d974502f6e1483bcd1c71341dce86ac45505dc461c78f7e53742618872984db996e017cb3e7e22a3923d5d37d3bd442275633531896f5872be831ca70643e8c5d68bae2f23bfff350f4360f5209858b1d77acee14e1898d162cb767ac0aeee5c7cb0c7e2026ebaa14dcbcc6fd17abadf07e9d73547a4c29d06cd2f8b7862736b61732bac6ebd0f3fe32e2d3b0e02f661a8254b43362ad1b282a76cde5e292a9728577b70358f5322a0c6a201842738ab68e29be1a817fc207ca0116a0e452b66f08e64a675376e6e38108ba75f5f3c35a8aef2005802124ecbb8153aaab65e510a628d20a807469e9e681457446570f76c7b63a8cb9ccc1ade4bb38da81335adc181adef76375dcd72ccdd0fc1de10067453f1b1c0f80ad9d752d1b2a029bc6f7ba95dc827b255efe5d58f1dbfeaf4cebd858739151d1ab0d24e77f6f5ce219f55709f0d7b43bba8616dd950c8b20aa6b1679c2748d0c091043b046b739cf727ba3008c3ae148169eabbe195447e60fa1fe6c4431d0fb71ec7d26a1d9741759081b99811187bb380f0cbf290f5a80ffedd91646b8df33b0c7c14b46edb3525adb7299c45be8fd51b18cd928eb5e53bf73408a85cb15fb455f3948d99d343c8ff723eecc7e1851f5bd8d65ea8298bee127bfb421598212a774b9628b9bc6981f5dc0e9f1fd7c04c35eeead2f4c244331124b65ee2fb937296bd2de6ad38749294e72325bfe92c650f02647667bc0ad1db47946ef6930247e03d76c33508ff5cde3cda59a9bc0de1b91fa7a94efa5d074427aa0b6d81e46ff116d832b1f1bd418cadf72a5b276510fc21628e2a8015492664d0abecabf050056c9bf238c99f0c60c3a7cb4129505e40abbbb87e04867aed1406a88d315fc27199968f9f2f17882118d8376e0a1b4068b932fbfb209d6e10a008d03b81229b0831aaf0de6e73ed6976f8a1d5b6f59c4a6f9bd4efc37a75bfae827941b97f58d496adcd6462d4cade3adcfbe558ecd37c0edf52bc3b8075e28a23bfd3bd6c57b0bf175df4b408c01c397f186fc53d7951082d7dd9a03ac88e77bf74818da83c438b9179c562a2c4c0c29fbbe5b9aef13bace689c4499d004767e47e797c3753fd2c659ce43b22eef9ae02217367a1de33d29929c7925cab02368d017004c782fd9dd81e40337d85c9f4871be421febe2a19fcbf8c827c185d2c1c07a3b7927273fc6c060e6c9f1e9db09261a19f3479c9ec4c74847a1448fa5525b0656815cd0770867447a0e1aa32b0d96f742d34045c3143037e6af3c942ec1e73fba952db9c4cfb1acf14f183dacacc3273544018b5ee6f59aeb0eea2bbf93762ea1e5290a9901e11b81630950a1522b1c0382686de6738ce707369091f210bab33a86efb495451a0d86fa9ba82b4ec3f01990242adfc810aaea592caf99ce2cfaf96d53c42e33b7fffa61f5bc0b87f396c41060eb70358db9bb566065bad69b74ba84b013fd48170f94aabc407dcb09f20876aab437bd25a92a1a6367fc58c76c35acb5d5d94161168a15041da6956567c70141596535c4b8f2ecdd211a69a5fd1b8b1ef0aa88ff0fb781fd3b8b9489274ea8725de57ad29ed2c1b86fd228a54eec7b40cca5d8ae916035f2a96c8796fa97bf9e5de0906de9f12c2c4940e76ac0e8bc455f28e5e62a1b0f7c018fe2d0890d47eb062a82748f4b5c5d01c5e636d646941e80728134ce34df602d840da0afb983c435bd5d8b2d8d422f922abc6208aaea7de132ae641a855a937d3d2f246e983b9eec309743326d8b05c963332476064c63f41f3c823c9b1fbec104eddc35ee81c239690634b43299cf8b2713043e5d9f7efeb3b092d97ac2b92f9de4095e428752b4e3e3f29d10da5cd7cfa84e765abf5e4fd087650ce3f0804a3a248a7ad91f95e2bdc856c7cefc673c488b34c80b17366e3d3bc4ac875ad530ddcbff5de2ef3305bb128baf178756f117a34f628c7290e2bbcb3535faff7d10dc534ccb6393ff1c1c5e0dcc885ee54caaf1f099b8f521e791bc5f86c0e79e3c379eb9a33e175d04ee312de36464ff95249244fa9c9161c702600209adc06048c41a7fb6639029eae5f4a46682e18843addc2a125c71dec6b3aefec0e4f42ef4896cd0a47d1e7e8016a265ec67096d456065be618ba3a08bb2ff6728c8f5735ed21276eeea2a9ae2f681efa5939774bb1fa19d4e829353ab929756d2b042bbec2380bd5b3efaf0d38d05bee546bbd34c68bb6317a7d4cc0d667dd8673da7328a4d005b86160da108d5c2aa2218cfcb8fff7325ef7d6ffae3407db1923f1b5c6459094553e623ce743aa3502ed3f40270e79959329f5c4e64c64fd11210ba4319bfde953fb244d3193109be08fc760b07afbe62bcd5d4a0d87dc90af52ad838e9f606036d0832c6ac1d566b8af049b7f533a03800e2de87ce9aae2b89671c8aa2f4da60a2baeea4551bcc90d2f0de9ead522f138a29c59d2bdf301e7dc809f36ba2a626f3432f1a077e868e40610812f1b0d51f99535e823bb6d73e74242f77c90fcf37bad8f275192002408168bf68d89b552c6621747d0bd62e833de367c6652cd80fc46b82489f97a805b9ea53c78b117c8bb4cb5777507ee23e03ba695817216d030da4e0c3f1cdfd8c5eb0887b9896f37fe1cd10c6b1e8c5e15ec000863b9d086f3fa5b9e19e709cb06c0ee63536d6675f407ed13de3c0923861b3eeb20dbf2cde367b70bb28771ba5ee4016fe50e1ac6eaede3c318bfbc01910d1f1ee0432fce01dcba49ad3b7451032c398bc773e9eb7b656a3e8e5ae58022086ad3e75b880e08a942fdc4fd6370f8880ccf22538e35b89292d8415d4e39bbec29cf8af47e56e116a75be792b168c1cae1fed4bfb69487e7003d6f6e290d00641e11fb51219f117706cc7cc2d47346a2f4e36ddf24a97e9b30fdf29a985c2cb27452ba235e35d8a04d709778be0446756ab6b921ae008e11e4b81c8802c7a699a30e921e0379aef850c81c0f247bd235d18b34d7f3b618dd8bc1f783d6acc709ea50951fd3623fd1a1862875d996561b7eddd63bfe1d0ce03c654b8e46c98c453b1d00de7a6ecfdd9c32bd45b1c1aede11aa1c55acdb2ba05e6b9478162a61d5ce506f173d10ead127e14c8d9ecaa181f84bba007c9e93c797a6d8347a98a9e0359a7c11612f819bef4b39f3e15fd25e10734795c28c4deac8b26ceadb9f852807af971d38e7732410bb2cc896d14da2379166566d280e862b5980bae1431d8a7fcff1371b42effde0c8ae06e6ad0dbc455b38712cced386d4bea1c82e8d5374a8a5001ca0304623306ecfea14e6ca6d06d524bff67cf2299e83caa43c0cdb802cdf5a384e9f49e087dfbd245d2a314789adbde6c79ed096cf1a66fefc0a69cf9f5ccb77464bf272765eb51ab8388e450e163b805625b9c37a07efc9e135c98b4a4cd4890204b4bed41bcfb785b10402e14be9415cc25b9435d40ac3c87b4be3115c17f23b1fc6b7b2be2794333e62592e6e4ccf0d6b77caee1d8e6c8f57257f7b05e1fddf14c6e9a5f97fb42c799dcc0e785e76b7e1793ea247a026f621a6603776e3546bbad9fe01e6db897a675516db3b8e156284b1a56a2d3c8d722e489f4df682c83ed97e63ade188d5bd88c15094e1a61f2e30c604e3a67cbded22fc64a0f082d69da1a4803565bf682dda347ade8151ac63c1d466f5850cb9089637039ffe911fceb560abbcce801ab97e7cf097bc5ba519135d2ac08de54a929be0e763fd2a8b3d88012f972ef723b85814c306949342b3d557c858e34f14dcd8f4b19bcbfa469fd375389911bd8f22acd19b0188bc1855c116b87c48c7c2dd079ce9824c4a367321fcfcde4f49c18e88c9287333412e6ebc14916889ba6babc27dfaa7067378da677526182cfc0e2c93c7026457a4d7803c2220bb7d83f1ffec2d309d9f9e35bed993ab169e3a426f316642d057894e207b52a67d62b09fc251df3dedf76b51edd95a9b30495ed77a66c71bba170dd2ff87d0842463f26ecad69a771f8e061be390e517a10b504a020010d99ebd6d5663bc613ef0dabf155d7dd2ba550e6c8be514ff13a70ef19a747d45cf3d203b119e94e4a41c17007a924e77d73d41ef9386ca53568c62f2cd5d0d074d290280d3bf0b836d3808fc5471fa453129777d7d10a1040828ded57a92e5b8ed2c31c0c43fb0615e466b71df1640c360c6b26e2bf79d3b98b9e5fb6349e89dc1cbf785732181bd10ab5ffef7dc5c6e0f4da628949fe741d9224d97534d8c7c82e0071dce619177f801a2b1c540b28c691a81c6d41c20a1c18b46e07bdc807ad66ed13cb069b199a16a8aee0778a5ac03e647c7fcc762735e0e91867844b981d916f031182599405d0be3c36cc6ad8588830e7a3cda788f6c19dacb8be6732679bbc1bdf18e065a13797639efe90ac2b7f22823d7470885111a17d42ddea13eed3cb9f9b75de53898be1d6e5e91b130c30a1d40e4908a564dca1a5b902a698838df46ab4646ec46ed2b180e292107ee81f6631ded922b945ce1bb1a0d63b8dcb640dbb77e81b7f9b0ffff3009ad4930e26f948e8a7054211b403932b5e601be6f94a10fcfa641242c030338eb85c6435e5ee3b5df581a2abf1d6e1626a0e84bc9fc39f91bd40ff614ecadf77cdd9718ef7eb0f969506cdc37e42480f7e144eb38dabd76b549aeb3b73af2c60a9b1f44ecd46dbc607d2a59286ad7755034f7893b982d27916ab29df4d0f234fd22bcddb716b3c78a72d3bb1e625606930ff0eae9cfd8e140c7fe6b13ebf0f5bed51aaa3406864b08037fd1bcf31c3d95d55a144dbc8b6d37d4f0f2909ef0f634c1ee6a0c2f1b57da58517756d0db167bab3d452b4f5b013a88bf7e9a8227dcd7cb731315ee4eb13dba318547dbfe11031df6f3b396113a4da6947be9f48871888ad844c854b732814baccdb7164626757641b724454a652f162805011602171b34b5317690ddfc76b2a9291ded50e9120b70ba18e8350019c23e7c44abe9afbf5c9d40deada153d9f4c50d9c290cf8bfcfb31cb0daf359c7190837cbbf65daa03ded5237c692b27aa290eb7429d23383c82bd3666e3be31dd3dbc42b80648a8527873a8c96fd9265dc2ff0006cf99eec7ba1c2826ec7b4e15d8a6a12c44d32dd442f72b4fda04dda296ea8aa1b91e29f879bddce9a11b4e23f6ce7c3b2b6751accb102d23465f6b8ab33324110edb074b6b8d37c84eb42d660d5430247154d34fc3e9a276b97652b79182d001ae7f2e35b3049b4f1ac30175a5ac8629321ad32ca6b5f86345338247ea35971af42b555be5b5cd1cb2de2d55191c6bd8f527adc7dcf9d8de2aad81bdc50b14caa78ff627595e9242b11393bb5ff42045645b0218745de2d09ec614f92799afc1ec0952fd6ac5806c33597bf83debfd8957d57653f42dd89fff85fd9788e71f08e4715ebae4a816e647e824b425c72e12fade6d8c934bc25425ff51e65c5ee0a14b75b7c1d95d0e481a3ba7d2d74bb7a631b0413ec7cf0dd4f8c66974264cf61c2ec7915af54113dded8cc93f3c5df169d3e1c7e56d189edf6839da56a4188bd62a7c3ada34e20d3757e66b620641940016f53bf84b1251eee2bb196f959492649cbc07e4029d29ee57b24cc5085446163fbd07f71fb290f91aeb89b3c326349815d08f5203b51a87f8195b3cb6b35dbe0b3d16bbc3a14e7c4cd6c5acde223b2dd8ec4976dbe91013a447b6de8c9652bfb9ed3cccee8fb55c564b5e144e2a154776cc25f864d81b2360a2025d70f78f5942939d7c8152db12b7ad03ad63b0b96c5e9ff06d4348a23538ebd3e02c107b660e68cfe18b6f2f4e7ec3a007998339863a1ea7f54bf9267b594d02dda6b19f40a269af5b71b2f117e5e83569531163d89f389b17b21d0cf2e2f103a51bd163524b864a34e658088a86c8ec413ca79ee7d69c65d69d413668e109e2951f06fe16fca229b888967eb3511cebd033666d4a2afb24a8ba957572626ff75fb91c9e782d9912e4736b4e6278eceb1e89c510ddcf643a4708730d6dd345be6ce0dd47892687f557e4f18d8444033eccf46678329c30aafee6f478aca76b965d0777fdf9c5155554a319064beec0d6ea53511cd7a2e46e21f1f9c4f3807c38445172c6796a593fe8cdd2b559c98488cda339d2f140c984b01c333b048a253ced706d57e7e0657986818c04ba84900953f191740f416bb53263b09574aa0726e8f7bd96c9fbea652d6e8601c1702695f76e9b91a499a633b163be6f9cdd868cc4bc6bfb3563fe0fddfae427004e1bf9bed9cb4128cb7eabc6c5341e00ba93ca4fa3a60dd0f1da6eb2aa16dbc04bc9b6afdceed8b5615203afbcaa7082862f9d6f7ceaf9b2e53e0fb79b4accdbbf0b9fe3f36c6ed6f424f9938ed550d4955a4ea7b26f68792c09bcc4b0b24d0aa7019e284733e174cab96e196a4ee0b452f65da3455f36e7aa3b20d0afc87bc82fed47bd923652dbcfe61b4a23ecdc7cfd5aafb628c7176619734bdf48b6c5f9c4c5d0e8bc6386bcc33aea18aaffa6a4b84ad632ee9a2a0f7ac4b35c5685935520b9814ec3636a5eda81d1a272bddc68a99378498f1cd5af1cf6972904d8ce22a0bb51de173012129c6c058401de25dfd77e0b621fa21c256e69817ac63304c54031b4ba7d925aa9dd277f4e2eab22d694f90d8a817b8bc7c1e7750b67d3fc1203ca58603dbe5b2ad50c7d2be9ae33384045b6fb84720ae5975a6f59c90ca1f0c59ae53f1fdc4ac950b37b381e2e8a157b01ebc06ae4c65c6fa58c71a668a0fe9ca8e6ad81a41342b512385bcaa45c917f61be5f9c6f4255aa72970cf8e5d41638f26f931e7a6eaa9e9aebddae754381646eeaa8152f11673ba60753d393ba422aa899930a70258c5f753d28ca903a0cc47628c223bab80157ddcf2154b29e91f71a4fc96ad56e8d49d787bc7a432daf8e1d67571ba517c0adfaee15607e81d7a3a62cce0c4075f96355650a970450a7efbe37b60deefcc7c862029ad21fcbceafd11e78d2309edf7d5d8f94301e24612e9b54cb2c1425b1e398a4b8cd8c4a71e3410ce80911fb1b847396c7ecb0cab8c50957354a8f841c280af734a65ee2d8db9f57e35c869ad8d2c221a6da107b17e31024eeaef2ca16144e08a9e2d716b65b542f713f1a69a60eb16294f449e5344c789b067501c215a9fdcc184d82a0013ffed8779ab43969b5ce542ef1e77858e00717bc78c6e1f3de5c6a5068a3118bf073e8386d8ab65c0895a289135564e743e5bd5990bcd36fe7f1003db7645a9f275aa335faff90624b2815eff87c68a7a12cdf3802cc42dba5ba1d4de6a09c6e94eb07352a639382f2ccc7c9ae1dc771f813691df858b40fc03ef7a90e817175ef14ccc8a6ef5f8929df6f69911d2fc282fe53c1c9753609fbb85343973785b4d61dafa20c7d8f52736b27eb9714982e70165aa8fe678cf8a421f585fa651ebbd24125eedec8553ae49020a4ca68676a25ed7c7f866ac325a8505040242a80ddd09cbe1baaf85b9fce56a9982c56125a7085410f2f98a0c9013802611898c456b4e0faee51afb1e6e949703b30c95b72b285244137574a5f97790ac8101181d5edd3a87e84afdcff5a11bc92defe693e8edd8d6b43687f78e545c8651597741c6ecf2c3d1cd0540dfe46ea47ba59573f27c3684c1ab9d20c9057b50b00f29cd995131f515a7d4e0e6226f72a6eee8a50773b8603be2c837135e79b32e5c1c09e458ef71965616ecac6407f732ebe5f54a9288e1ada0393a1dac13ab21f530466859d8a2979985d460d479c54d6ed33cb93030b9812df512835108910ba0d667160e277610ebd848d20eda9df8d819b5d31e124c5cf7214ffc3eac8e9d5b7a084afd7e0fa148c3b0e337a3197e7d958485dfd9d1d49b9fb24a225bc613d14335d82016fe000cc54717a9992e455a22958660f1d38d74c14bc0ae2a6c5091d0146d9f098e3f3f1234a9cb18e4cb36ea637258d04cc7ce3bad4097eb2adf50b09b1097f3b72f655da179512e5c56f6f72816e156217f1683144b612ebd5445d1ad4b4105ceb42bdb95eadea0cda118d8a9b594353901dc370cf50f2f3558a5df4afd106741cb65a20fc90394a6e3a4ed740236928c52db34391693c11bce17d3bfa0221cfa6c79599fa539ecad626a4b5525200c9d34e7c01da0a37ff9c57b777d3b326f74254ed4d49a822ed1a4e9366da616175db9de34c8f8f95869e109512812b283788adf909959463732771c99ebe97cdc219c1fff64399a69c383fca7c4e8c77386e89aa1190f19d3377fc25d574670ae31c014c4a57abf08d952e09877eeed2bd91f4b0e02832edd53557b5533dca3e2376241530b7ddd48ab00a3d06e1e7242acf7603e11ea3f136d38b81f4dc699fd024f6c6c822081196eda5d81fa32be512fd53fab3c26892d05d37a45fe4e009ec45b7c44bdb05831295cef87998b115768b3cdf8fc4fa49bb34787f1ceaf42fd41f453cfd66e947fd4276e96e55106a60140ce8e36cf754d7f08991e4ef60e8f08b4c5c565acc6c0183ade3dee30374ae8b6bff7946f2f7cf7b6a5be0f89ea49035fd4b3d669ec6167df3a43be074796c27f33023a8191a2b31670ab80c7b9a8b7660c732b0add38a592843e1011d46c6c6eb23fec791dfae956e4daeb6f0621f01d0ce33aa7ec3f9ca0f8c6c1f7d8e98bb0e1d9957a9a8337246365e4d51504d7077b260d041ea3fd56a0771d09de4de668f36c8fefa925df423d8cce7ba1450b61eb5a545eed8c6207a67fb8ea15dfbda21defc0fcb6ced150f7238b93112f15f986d28286ad9597c0174a1f04edbc20ca1e27ad69798d78cab4df7a5e7c2dad40ee4f8fe5492867e05eb6c6286e458614d2360151eaac73075daebf59e8151506758d265caa9a1632a8b5e1cb19a1afb7a0bd77e04e62448ef8de081571bbb33dc6c78b5f8875519d04774577d245cd93a99db81dae1f3ba5869612e836c675d9ccb80c3fa05d9d55b2d74b0d9203972d3e1ecf9db9acf6f4f4edaae6c079bb69273c4845b3f2edfec599cdb95a2ab8f1f9dfbc26f6331f9df51bd2cbc63291c87d809adaa65980e860a9846027a7edafd2c8c0c87026a09653c9ec254c1fc347947f41a535d048c3118a3a0f1063040bb6b057480fb0cf78102b1a4d34624d13f5b866be3141fe436c748b5fabc832c91c27b0d7a65de89905fed3366a37c54ea3ee8773061119007d8375cae07b297ce79a2213508141eadeefe785c7c57fe4268e9cd585e7c986dde1498e1659384007acfa9022766d3304d539f792c59e7f8a1ebb3847d20c5bfd582209b8702da43a915c725d8f070a619e21b527af57f058c9e85aac640ae05388e29e2f286357ce692ab5434c28aaaa9a0d05524c744daa3ce02bcb1efc8d52ed477098c18ed3ab044671f083fd0165929b4cbc6efabc283afd5cb37d845af1247e8515464f8c52b1068726a98900f113b646bab72d4e002b7af7cdef51be373d87c1186cdd1bee8ba4819d3b0966f5447d66946d0d2db3637a25143bae3027304aa6ef1530af9a2f768db2b65e6c2a8d04b1723fe5b4e628558c2c1b2d25c48c42ff14ce0cc409dc0b2e57f120dbef9af8b48b23accdb21415b64bd02c6d8d1b82e1da0f2d088666cef1378923eb761570ef61f9f32511a37fd8d4b877c1e60fbc470fda49a4f47aa631d674f191601e640152cd51e34c556579efb8665a1d1cad5e91e1b8985e2190b1e55671a80190258a8e0b09e3acbbf246d03783c7c300b6328c6615645048dd1c1ecd0301e0b7abfc858576560f7d00f0fb54d2d5ca65d2cc1b91a9f6645cc55de702aa3081097b948b5192da7b14ad67d3ccd5007221cfe280f1dfd1e4e0ad07eab81ef305b137f9daa7280ba7cc35490655d66b5c1d38f4b3be1581aaf87c90a10aff848743af993c2f7b2b082d611a3690679bb18a3d7413690cc7f63de3bda08e5d795356791b4aedb7bf9cffb104bdecf1627ea4c8ac207981c65a51ddcd4ad8377beb429671ff51780ae21b3380520fadaa1fb77b79e57b2c4c515393b00bc681fc461262cae86b809abf022a8920e5d123834baef448695c084fc2dbf390f28900b20efd0af9d5a8a5dc2a82c25ecee43d6c630e3ae531f5e136dd6b9d94b71566ea23c695e69be564b4d0da490ae818f54bd79af1c44c021885c9623b2b4bef2f467a51d5d675fff8594de3d9d4a2337b70fbeec07c7a82625889a47e2c64745a995383759608a083ed6b5ee50643b0cec4499d4e4b944b1d6e4adfca4a33311337f6b7afd710f2d61f61cf1a3617da8c445822c7ea24f13013ef7f5555f85714369cc2f3aad219f709cdcb3e695932853a4d68512d84440ae76a9acd720b1a688005472a7928f021cc46215229b9b880d5dbe113de3277565c5559830e425d95fa1cb587c2bed9062a2b16c3f0614c0d0562e0b6710c688364c51659e547db1e41ce3ea71b898e9798cb7adf4cc2421147420c93e011dedf00e323f75c61bfc1241c6320e13e1aa93206d5fd0c1e19186a90db43b2c826bf90376ef35fbe9759f7aff8586044d78bd3d1edb68696d7d141e173b2197c5afd551f5e438bcdc0ae22fb9383003177083d11cf147f321bef11f8f836ed976b6d6d20e94e58c10fbe449bfba03299810471045b1f4fee5db0ba143dc055c6e9b0205c8649d3ea21a99bb7c5ef6456d4c6cf13776f4de355f2c3bcbb5f46f981481edb6b3e013bb5ae52bd955d6bdb060e883b24dcad89f3022f4fdd6cea52ecc9131c926598288e44323dc8159fc8edbe5f634eda916b43f0fa715dcd0e20c94e7545ec0fbc99ae49cd9906174b35767a1d0055bff9c9e87bf97df3e783cdb1a5e4357d6d13a8525fb5df8a76b1c71ab520fbfbf21d8252e023451fce1a7e485ccd1d4d407fe5aebac38de919e0afa276ae862c3fa2b935ddfa934ed064e64bf5ed5ae05e1ac200a94d6e880f6c5f5313791bbbcd7b91641dc0707b7a6f71b25728c180f27a42c30f73461bdb3ab3249db3b2227e86f93d8e7b62ba5b27607c3ad653d2cb74fe3828483fb99957","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
