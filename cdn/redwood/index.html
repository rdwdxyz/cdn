<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de2d7ca0813f51a3f84771dbfcee11b2ce4a55de18a2c70420d817f0a2b3ffc34c2f0a363ca588d9ee94eace9fe9119ab482e5f9bb82414d58bb9662ef59b2d5f53da7d3767fc494d76e0198e00cf1f6684d66e9af5b79cee7a1e9fe1439d32c535e098eab308bb4f7da04552a9e116d1bb71b0b7025171eb80f9ec026296170c95e130e64bf13cad861ef17e0d04e1bbb49e95b7f5cf9f018a9a68f5c0ada702ffce40586c659781bde72621a658f92fa641f0f26fd38b28dda0e552743764ce8e03ec8d15f4659b61fbf32ff56f993c1bd1f7b752c79ca3e27bf598ba20db59799e16266d4408c5036f90b4bcebed4e0c45a9b033edf6981cfb067c46a48ca0c4af1ff1a6757658d5bb61964e898b199e90a208b2ed71a7c43966e4cbe1cef32c37df41176c5183b0bbf9ceafe7c77fa13cd61b8fcf34f15f132a99f2c34b016634e379a67c4c26a830474fdfae93960d32c1b5f19365041e719f014f6913f48c6495af3284f4abed806a3edfe259c59021e130b73a97baeaa0a1f82468f68f820b354e5ff571e11de33842d77702efcd33593aa746c64b68fe181b17d0c89174b2909cc0b68cab49fc33384aa5b8189f896a39a5b168eeb7b7ba7de4a20a0908ceac4ef712332113e5e7b2e2457105331e5a164fea7a1e10c8b9e9903c5afd2318a5d4df5b71a04f40199e895c5c18527066c29fb41c5f85c9b6d611804bf4868eb9ff3ce4abc4ddf9a1f8172d9c9888b94b65d940cf87ea86d1c9d11ba7eca9fb61afe3bf97351aa56c1700c443044e31b6fffcf07aeba47f2b4722e19faf167c39db39350f1866b741a2fbd57feae2ba39a3f32ca1af0b454e5ddee5958a63f370ff4c56d35aa71023d3a5c949026baf50d5c3eff6e4dbf81e715edcc87a3048fd6035a4e004526b98dbcdc963cd02081d0048ce949bd101b85e41fd1a732d014753e5659dc82795ff7352c0b9805721f016a1b707491e235b8d2d7289190c41339b9461c326b5d43714a7513b00352333180b36fbda565a25c43da225d8111bc276d129e784a9feba26601321e5014aa316a2451263bae572fd34b96ceec740859ae4c3e0132a9204bd4e9b428b03d671d5641fb3a1f9754fd73ecffe064cb541120f48a488163e2f905bb3cfd648bd209ff11c32dc030bb52c3b66faa4c4d0e7b4b6844bc97baa1f4cc32de3017aecb26b4c047bbc1421ea06c9388e16a12b01834326c86c0d8879d1919afab757bbec897bafc1eed710b908f2ac82ae98a62c8e949b256baf5da94e68ba7499948dafcebefdc29d2f96ced1616183eca3e6bb216ce511461eee0e6980fe4f267d644a7ff7235d0b7751fdddc2a1b1644bebdebc3a707be347f5018336b526d8f03d9e0befe3730afdb96c922891097e08a85dd51ae17c12ae96fe2228028929145fe1495fce2736bab3156ca232ca3e1b4a1eeb3a7a88ed9076e2284e51103b516114ff01702c5b5c3db3649b384f9f815f124e635de6a296820a59c04c46c4702c24ceda183a8681a9c1b9e059b230e01e9ccf5ac6edca2b616b44caac266e0bebb0c77e7ed1866132ba44b66e5414a13bb558aac8768b3f8c8d388452e0699b6502d8f9be827b6ba30a6c557acdffb2ad119185bf7c99d21535f34d9753adf2554165a4b4797a376b665ba3fa210fadbdec6def3e01e67e775afa1242a99e3da072f37662dabd3b2a57195e31269ba6d07a5bdf7b35bbcb5bf4fdfb9c63dee49ed2f7bebd3331e60a6b1654ae7d4fa3db72f2840087bb3a1a0475b5dd14fc2644ddd24378002a88a1eeedfe4b7c587d04bcb3c1a8cd1c7b4276b7e0fef05508b8fec6e7fb519ec0436f017d71db4f66e8d7874f783bb49dc6cee83743306d1d7016d69049efce15abb2fd7265b37e75649e97fbd12cf217620b6ef54ca0d7431bf16ccca4bebd77a02434dbdf6c258bc175fac9ef7224512523a60d8bc50e55d3ca0c825b98b6d6de1f52631e8674b63f43aaa303abdb6948687c44bfb7daeccbcb1b3a35021627541d3b77407340f1a760c596d6e46c2f8ec1e0277e59d55c39c47de5395db84de0133e09507d6afad1726186cd6a3e6359120b6dffcc668673c550dcd93dd5a39b1eaf258eba06bf48cd4f9624bb5357245293a21f4af57581534eb933d76e5e957893d49c950dc0cf885b4889959bd922c6d09e55136d0b696d96726191dcea6b8b27c6ead22f05e540d177b5a229ed682fffce1a5c9db94587f0cbe895055c5e6d22db8585ba2f807f5b5d2cc8982ff0b48f1be34d87743c87c6324d206ba9758eaf29db9787b5b3f4e7bfc099daaa1433dd21f7c34da640723bd0ccfd7a06fdb6e348e5707e79a3c3ab167d3de77d1487910371b32abf1a99a2a7df4549b50bedf6c37583691f634e07734d74144bc70e24d07b7d7331ea4690ccc9e7a87ceb676d6d98d96b8e4b959c662fec1fbfb295a61da89f3555c6eb833f07940b0f1f401de377b2dd13539a9295ac23b4d6b5224762802d87c73eee0dffcf06813c686fbcb3b7a1865252b499002601bc9c4261c98953f405f3da273bce9f4533071e804cf92d30ec459c233cd06a53213d5925645b133762042c8d92b762da0938b954782b39478c9353d523f80b0f4f4a2e9013f7c293704c151e4729977b7179417adba7e4d66541332fe0d87cc1853131857a5ec56fc903af07b97b51a09b09a062dde5eafb738dcf0d06a1e90d60f37230c09d93840686d4215e824555de6fd86c492ef421a9eeb149768d549a0eafec2f680810a6a6cb19322b4c00f3160a2f5d10765fe51807c4f2e3ad7296cfdc19e3ca34c9bd73bea8aeda79ccb8383afb9d9e36d6d4aa7eebdd0370748a58c07ad8f34854561c10154545b679932024319d498de161df5fb5d47cfa869044cba3790e2b31982fb9c0fe67d7b3f1bb16ce057a04aa4bd2d825c261080f805aaf8a8ec014e7a3a35dcba51eea14ff809aadce77e64b39c1c892bf56e047105e70be9333caf1aeb9182ab17d4487057a4397a9edf4515af0f2b50292c8a97a346d24747a4a690bc21c025f066a5b00c3b90e8c761bc116360903b823c5552f79dcf86877a67d1d7da4428ae005c529e0ed58372a1f10fa80d312cbf3860f339addcf0d81f82eac9f9d3c774c0b899dbc45c7c7d124680c20d67dcaea2541b82b361fc2f460a1ae62eb6c6c88c0b6af1c9ba0c1865fb158b12e618f6340eda0c1229fb59b201bef2d3de385c0dd101ae8ffb1c155ee0d6209b3fe437b5e825a7416c707ed92a60565a45d72183ec5f0866ef4ffd9d090b1dc8f2187bd849ef546a84d2ad417e06015e099442bf5d1a44ae0e20444820d7451420cad562148fc0f92764ff2d7fb08a6c7060b49b9cf1bdcd00d69d3eba7508bae90df621e0d423084e7008cf2f44dbe98eca55f05a973e9dda0279b369710b0b64c18ca00ba60c3e7b5781a7f49ee5a2320e1218f02bb375a2d11ed9060bc157d8e66e7e307f201d9286a91bb9cb2355ad61249cba29693a75b6d73062b537c745ea0b8fd18b9c6cb9252d98add807eb44c00488ab296d4cd5a4db1feeef2c690afdfdba259ac22efe2179f710584c19fcda58509fe3f4d3279179d69466ef4e0b51dd652c541b95858820dc62b405f6a558ffb707b5ed57706080f4cd07305d0839258a16fc6d01108fd028a9b1e6a5d1338bc11a5a2974a2914c9295beee4c91b245b78cc9ea37b49edf856c926ab9b676cacc8a34f77a545cd73022501b74a5e9e929fd84602fca5e8601f68144e4b6e207adfc2ab7476e3ba0fea013c3fca44290b2fa136f2f8311dc7ed2a87ac8bdddeefda395fd757197d1baf9e222f0c6bb9045fa59e8d13bd02500aac27cd8fba7238d2e2aa4737fdfb9926dd35630eb2c0bf3ae50b0dcc9f46f4be9f5caf48af76a3b6c4c915a2033252279cc5093ec5a3b0b9d56d3e494aedeb949b05ee8cf710ec9390a89bd869d6b804c320443270036f91459bcd8234086b0f7b8658c3957acabdffcb55ab21a73d66c46216a5973fed458df58f196b26bb7183a4ad9f66719c84e8e6985abd602e943e72f695dcc218950c53d10f2080e0c3924cf18f7e8686ff4a6f16e73d3958ca1a4817f96114d667d20cea3458c10fa4fdebb6633eed7b89c2361e9cc6b6fd5bdd6286fbbff5ba7fe785b5eae6b505f8a0be42912708c4e8b6d60fd2d86dddd7c0e81f86e5beeedc58a7282aa59e6bbd8d629721e8c5127d7f7e58a5db4d935c8c20e96d9272a96af1b582adbd10fb44f8d1508ca95f6b2733d8912098c83142eacf99d540a6b0c89ef478073e01b91a4b128eb694f61e8850d1105bcc34bb7c1b3c31c0f3f47e80499ea755a29754f534f19f3b9a0c576dc7fad844889daf2c14701b9e939357fd7bd43f0bfe9224020e23197db12dd2a029313a835f2d437e48c9eb576ed2de5fdce19a6739e9dc00861ecbc0c1cc9c86651809d5d9d70c42050205e60428a65bd244fc41e8d8fcfe9802562ace37b9941eb8ed4178a8740a68cf00ac2ee658ddfc64f0d2a4214d2a0b55e60ef1c72b57cee56e116804e9e98f9162d64923c676f7e8da955c1c982b83dfb9da16484f3470922405e4f559da8f48750e786add8405f60ef6ee46ef9398a21ca76fc26c149ecc0ca355f22a4d50ecef7c89edaabf4895ee354bd1b49d3071eb9045628cd0e72e89bd97a52931dd948f3891e5831c96706245be55590bd6693fccf3a39b646f788daf785dee08126c448004f5bc510a47cd6c018d52fda32b5beb4f89801f6cea68a8affd574c951b5c7e067ea49df0182b7cf4977b3bb222e29322c6401deffea1963b31031cd89d41cb28a1f5b4b1a387c213c13fe18f59ca1d83c23f42102aea995757b726f7028ee800acbe8c4500361a1404ca8d853de2927b6e51eec2f1d0f590bdfb89fc564cf7b8acc42828e21c48b3c9aa377e9a0748e09e4039dc31d484be5bc8068c6f8d3cb15b798219cd1002c6f0a2cb62ad0da32212e709923c518fb00999c2da8ea026afde166dc970ab96b0a3cad22f6c2bfb925ffcf75a67c9eebddacca6f65cad0d78aa6a18399f97984dca1fbd0c143dae833a7c3671ab10eee09dcc7d82a064bbdfea63053ef92d2dbad0e8ff8f43f84a239de96a6000e275586439d7eff6beaad5ff01ecefb9f4a622d922e73fcb650ff45ea285d29591f4d03818c5d4453b7ed0f01d62e4bb5fcc1d8b53bc3d1ec701f187a1bf2e3f60ee2d699498c49e6d7dbbd07d2758fb804326c70252427b07f5049f877794141be6b19af11dc56946efe5c66823b868fde1a5a092cbdf8954f0acfba9861ba5f92a124aa85c13ef938d8a1c72b1560a73954bcb515bbdb7773d211290cbe54b7743f132d0dc3e909e5a9a0a517c60c082d4f2b98d050498cfcf509f4ae704889bf6960161721ed5f82170e10ff96796c1834977b76805cfa01d9184e8347f2093ea4d9a0fa792a2132aaef755034b07c6ee44fed2f1588b3b3cab970c4d3449fcf71249b6f803067ac16ed0ec7455e9c37217d490a3f582ac6e9cfee0ab330d2afc184522521b78f8b531588a46eef03d6ee27a90daff410c203c2cbbf9f5b7144c656f65164f8e40d0966a8eb3c4a41db4ebc6f84a02babbd36488e172263159402a4bda60e7d9c65a1ddd824eb80140d2a6032fd9c79cca009b0fe5886f9baf7d90c51c74ae138a7be90b8d40a8c86f1bf5eae60764b7d140e75748b11de67777afc4bb8865af6bd37932b2226ac7cccbeea82abd992f208bd2a5875b64ed2f76c8a5164b013e989ecbf780d29f5f33ec810948d5bb8bd31bf7aa5681b667b538f19988e24b3cd3352df2a0dfe08ba572ff23237b7f53bc9b816e898309fd1ef2060654ad183184fcbb9e85cc878593ed0af192012eba81c07edc585b5aee826d534d0b0d9cb117e0766b357e55038b2f9dd85623322e942f17337ca994e517a098f8f7cdb163b23585ab860a295bd8afd53b454efe7ea505f235e5bef1ed54a0af5c51b4cd9b0e78255c0834ffdb6742405b1d1fcf836d670439de56dcde4a89cc1fda8dc54729639271fd3e3b097cf31b925332e30b401aaba361ed04eefa0ec6e8dcd65015e11a3d94050b48f73d84cde9fdc0dd7c511b0a775b7f4d8785e667091421e7dea7ab4694cf8563816a552171e2fd03fdee9a3d2ca371ea58118c85b90cc38175447b8014e0d74c7d0cc6ca7a8ab90e0f86da9b8ad28a5a36558d865c44e45f51a999bf9d3ffb88b3ca43ce6a75096e2041ef44be3d5589ee843698069af9d43b6aee99ab2ea9b8a97d51a337b0df5af7a2a92c3df8f77cfb2352022494fabf99173f95192e2ab4538dc67db1858d6c5242bc3645a6e435ae27d76a33ca64907ea894190247a5c9bee764bf61db51807e8e635aa1705091a8eb2b2eef859e732a61ad1079237b527c78bb2784deaa23f9e2b448b67e5617d35ce0f9140aa0f3194780c3d4b429171d2794df67f7f23c6ea5a607016b6ab91bdbf3cdc1473eb58ef7c4bbf96de821c98fc30abaf9e3578672937c14e72f6f9731f8b6b747fa6e2041fe6ba7d69f0d427909b1c82aab8089a4dd0f2ac6dd92c508afbf283a57f9cf29fc32c17de8a7a5bc1dcf5716228815b26e71d4dd273e9c73359ee83d92bce3112b0e237ab2284741f89585a5464b2e8fc768a7134c23d9fe01b3c4d44c0593690a7d60d7978198f15fbe27f59dc987077cfadb31e06d2f4cb64f191a86562a2caab37dfdfc09ce06b9809d503506b4abea4dfd1fed21ff6175759b256c6cb343c9c92890c14408e2dc333605f0beed58aed97c999c6ff2f270cf3dd9a21e12aed4b1a59fb5e677721d45f6d543fdbb2e6cd82690a1e40b95e17f9ba4a193c9bd72c90450004b324c2251677e852bc09d143e678af5da337eafa8993128ba739d79251f7220a1c318db0f457b29660fcd0bb7f1216f1fd456e421701eae01c18e103890e8b927f7be4269a1da5337e83ba5ea98740354a1d794148cb2945007fe0f0ec0df5f6abf9012ea0ad766eacf934797297b9cd89bff820638a713df5fd385126f2171cb5f3def2dd60b2da5d963e7a9c7e6369ebd3e75dccd148a3b665eaabe849d74f63b17a02d83d53b099b5d1f03e113983644cc453d1937bfd18484123114fa2a6cff28e9c09c9d74fbbfff06f305e54d0a6a2202ef669b6c359a2a75b3fdecbb04c012f8688c7af68665c1263352561dee79f2467fd968df27bcb6dfa3a15a14e12e27e854015c953ff5a4d892072f3217a35524c0b8c80f817fdd17e92a879994e4830677951c033bbee0de24d4902a336f2228ba847a983a01c9dd2684b4bd6c64e47913dd1a35f43fe5d6acc891522add8ff10395f4156f9072fb3660bf7dd8a89f0d4015c6f541af61bc053d6efdd54f8ff0e83b6e4433b56f107adfe56663fefbafd3ab5722046030c91d9c4ab3103425a47473577bf42d26e5816a63208f4e32ed7d4fe7840973a5ab1625e0021b89dbbf67fbf00b2ccf2e978bc729f450064144c7c8e1b2448d63be13915e29b46b21f10e17a068212f0dec922763e5921f52eaf13e216a2fc773e8d518bb12f5397c78e55549e2e481789ff9df7a785d862f1a1f7373511edab1042607f215c7b67633868ff8722623ef2a840e83eacdc77506234abb9d54b6bad929452e9f07c32ac3b40a0f9719e59180d14db03e45b32f6b6011ea6820023bd434b7ee15c0d328a0d4ab2bda9d6c41a060e0b2282b87e932aba344cc913fb4180688a946f30466450a1ad4663fb689fabc26f0e6b97c336118d25ac2f4183adb372029f87847b9518db7bf43b34c3fb8f749cb158308fa6f1d56ed2cd764d1e0226fd2096e53440d5e952576c3b5e31b2c12b58c6cb367587c23a8ce67dadb01e1e0d6a6b006391378213f554adc9231894e0079414986dac5fb78fe9b15f4bcc82bca62166b3059553419ec908a2f2f47140811c3430443c2aeb9b3b59f75dedc6956f9ac924280614a59ac113fe1fe5052f1a5394337764647ad3692e68ff8a1bbdede1bc559a94512ba3dc0e9bb4808b29105eb86337902230cf75ce7e0a94ab1651c74a0fe5d5d4a9026615b080d1f3956e86274309c0518699cd195eb74f4ad5fa7f3e8dd7720019f2b95bf8d67bbaca9ba0f128805870918f1d8390fb5f375dff5cbd2ecf575bb84e7cc00049a919c31a244796965757d24a97afd3f4f383248275953c02d1fd73df07ca71a3b32f77000ba194eefdcaa374edeea2e3726562bb11ff8ed825d3e24a68d8acfe8ca80c2751ff3f2b1ed77e26b11c1ce6a1bcfb15455a55c6444390e2e2318635ae4f97a965d2a6159be70faeff2af71ee85fc289ff88375b254bb301ed939d62dc6a752ceb6bb389ab3a31b7f0829c52732c52d6ed443c9020bf6b6d343896d9ad1f43708f865b1f0ebaeba2267abf2a9767b7e201a5278b9a4f9791a74f4a0c217c890f3d692ade952c552c3eca7dd4d2acb566cd93e1ef74d1f8ba67ccc3e0a81d9bb4825f410ad262bf71b29f9dcb86ce61633512210078231166b6671d5daf4480a09424247d98dfa8e68aef10e053d560184a1269c6a1445c3101a995b1bc810da7abb00eec300be4f5e314ac761b39f985514056c986c0fd48c6b497ec3e58b9e6a1c9dc52c23fff629403878df5c979dc8724dde49aa7037741d659e2b12306487678f53f6863677144a2ec4db7a380ffac65f4937288d3193fa89d4b8ae08c9e5b8183052b55ae75a0525d6e721b478f7f3836f42e56e5b4c1eaa65db3a89c682e74cc9ae780fae73caa461e0f13218a19f3b0c23b5e787009879ebfc25cdea21fa7028597bd4f6af51e9745da67f983efe0ff2298c046d7302046d9943c5ac5377739bc0215eb767c9ce0135363301584e7e9a6d7fbabc6d64d2ac2714d511192f050c5f7c4ccfaec117f90cd3e1843134bc415c73b7a060a26aba6a3cc638d7e5f9ccdb3c9cd22fd1ab99b75a45c04359c719f514f235b2d99f1e71d7d85228bf8942125018f8318b581c0b0fe42601a0cf8343eb6ca54a80b2972989b514219942042f1e7cdff692d8898ae5ed15d82d0b174f3f3b44d4549582f7c2ccf5bad701f32f8446b4c5cfa3f7a279b31555f49d44bb9ab4c6c3fba27abec6da85b817810fd2340b74b66562d3829e8917947e7345bf2d4586abdc4a165546f09e7c953b87eb7a422a1720ce6874c04e8774e066ddd155bf91cb7ede495503e51611e3bfae3a4917ddc9fdee85c7b16a80ce09a5ba8f0a8c98fa4bde6a2cbd022185e7dcaaf9a99863adb372b2a23ecac97708efff2f0a0f8c16b3492f5f423aac1d3e6beb771a20281fda5ac2ef65debf3fb73b191bd46b4fa0813b6b7f2e70475268c43490d6bcd590bd9e512804d339aa3ae1898bc7dfe458e12701f0c00eab64399faa796b798c2d0d1b8fcd889a00fdab87cfbf93e4790f0b99fa50306ad655350d66b1aa34999f7244c18bf25490979a0a215ac40ffe33695fa272bbbe247615c73a9169da9f7ddb29b107503d1b8295bebd632ddb9d99b3339e31e832c7361c18a5ce249b589172004577cd36cc87364a70adc5455fff67da3fab61751ee66da791fec2c947c03c0d71f402e6e224221bd3e89f3922081ca1e829978065b0dd10e4d525d3b6b99de6e2dbe55acb13ad6740d24c1c00d5df03b7c6ed558901156d32471442430121cee7738ddf89f6388040caf238cfb0419178d3199de1b50f32d453a60354bd76bca4430c64a4699a726a37a516934dde93c7d2fbf8b1c3a8bee952b67ac367a50d82bb2652570c752cc51330e504cb22aa8e9bda115d45274ad253110b3de41f74155d750b004b08e869500e67290712dd71651613a8896e60c0c2c6a596c41fadac2c0d66da2c9505c474fba75bb912f97473b6893ed60cd07aa6e17cdf979cb61ae2c40e0cb892008a86030971684143514c0fd6b5ba306208d00f3f581583c8126217ff663d6bca6043596f12a33fe9fbb3e22f128b3e0be6b1b15ef0f378e4b848528ca7525ebefbe6ef2c58fccdc5fe2ee0fc0c0f2cdbdd5ceefafc62d085e692132d6ee83829d7973950b6d9674ce0724a845e74343f8c15d2c358255b4347bc58ff5ca2f9b04754595aed4da1b739b6d8164c4cce49acf2f94f0537595f0f6d9f6b25a7e2afd7898a6cc06ec571a097cb100c8dcb94dd6c7825c72af10d649ef5f9732e3311fb00887f412b4d937a9e4656e37ed23e029149038aa47271c1ed53ce1f2ac603ed78210a5f2318dff0c952efabccc00d414f13ace123bd61184820529e98c927f428f35d9c7f1777a4315ef184c49ec8abbeb83f560e74bd6f1a3525cb69e1e02d8c3c919e76059cf9254e0ce6c9eef341ef03b8075a1bc5baa21138ae43ea35344cd4153d16135b8965df8c8d399de99378ecbbc229e2a68ecc335f1aa276c1371c4a81f1bbfbabf0c1de8fe57514ebd1069e5903e11b04ec270373ccea3b93060a72e98223608759528ae9634339f5e322ccff893a32664a0c85845ea951d7805aae459b671dbe3a55d550a8809ced61e9c3a188171cab1aba5b30fe5ebd89a1312649f54ea073fcdb4ec7cf944ea34875ad81a9d0d495f6ac5dadfceffcbce76e80d1ab64953080339959271b54831bf35d755724af680e55331bfafba06b8c785da10877780d8eeb4d8113ad3122fa193b345bce79bec847948c49adb44273554b7825eb075ba5455ded1727841264e2428d5c3b3da0c3c293fd0c9763f137e0c7fbbfa545b98e8154ba02303a891291ed4c4ba2bdfbba6f8697eb00a4a810eaafd1b982ff3d040793bf851f3ec69cac894958b6e89ca342f1f3f3f6ae80bb7f80bb0ac83215c4777f0c098f2bfc1bb74a95d7cc88e26407dd0d149cec5e88742450005a0b26b5a4e3810e8f2bead4d2839e9a3e70ab6e2afc2450fd4684d0e8997bea1770fc4d12f3837b73a895538f1b2359b60984a3c6e834bb9e165e9638db514006b963460f2df2c44e088fe087d9b0ddbede66a016889b6eee350a5046485d053fb8b6afd9e1441687a39d028665f5effaf6db4701938001f2c9aff152681a12fd321bedb867c1c87a55ba6aa429f1e17e96b72299a321d708c638c878683bd52e3173f854c46d06e97ed07a0a7382d73b4ae51e3b71f4b004ed2af686facb298e6a1f31fc4ebee8583522d524e5c27d9ee02082c86ae0c09ceaa159e781774c74c9a62a81848bf2bf5a053dfa16fb71917e8f7aaed2c063e8141c27bece4444b16fd2332cd100b887a634653f1917fa17c60e47b995c22bcb277c78f9bfad416ecea232c426ee093e61bcdedee1dece2eeed703018a947d8713c3b94280dcb88747c242ca462ddcc83f15db52d959547fa0d17043c78254632f9c54dd40f31276e380e20c1ffa4574651e900803507553c889da5671c0b7153876dfd7f16fdf5989c8477ede3d15b129aad3d41bed4dbe7bec418c6dddfdc8cf8b44c95f72656335f5aefbf20910b13509e7ba3e7d76368c7462742e4bfff8f9602325af4193f9813f57cd22d0b1d36a6051b7b0285185b2fc5e3f739a867b1a0776ccb96eb391ff86d5e7ca33f5a254f080e5003c83c8acdf62f918b8a054ff6a96c3dda958ec6af64cb9c4b55702a433b36f3c98a1e612df710d90f5d64ed7e1b683322e1421d16eeeaa1fc213631afb420565f36ab54c8672d87c490e6b54975e4b621ddc5db4ad19fa06e05afe9040781b6651cc03f45bf150f4d2a1cd6fd34141e1df7b65f3f0043157ef07d2a30c4bc6c68742c243634f7f591b920d269ba64eeecf262ee8032970c62cecbd581314a3f27838c0a70db5ce25502178d3051ab94e88f611dc6f1f3c37036658d5056fd280a10986b6b4dabecb695b24d5b8ca1c53dab3e256b8fd2d8346c6f67363a25cbb73b72371b94a3b71207768293b2a32688f4836e208f90c130a3b21fefe2ba2ca4f19643da112a67cef3a319c694ac731cab1a0f35b2628872c7fff7194549b2591b495f8e0d7d145a4f676187481c5355707df138a98421f03801fc277370c759aa9283fde0ea57bc9ce2419b34c0824ae0462c800bd86469bb1c6df462047ff4440fd0a22ae3f2539f029f799950d08248302086be2eec6bee06089387082da058b027abeb96dd8453b77418c03d8d63c20d37beb86d296fd9c8d6a2d8988398c4234061ac6dfa3437e865beecc8b223e5109d203fbfab25a0bcab3ef05437ab4369a5876538a681130d7dad7c1401c99d0b4e003ca056d2a418c3429b5bad19653b5da94c3795ba29e72add495522d57996cf91db7e2bd4ee880525e1918df57ebb51e3d7f467fefcbc6a1699df7b53bf275dcf9631428e56a0e661be583e2f272a72b57b1e01354caf482283d641ba50d51809a0db5f7f617326ec0fc0f0b9892c30dd63a68ec25dec18050200c8f37810c1548eecdade20e8d61ab8f08e4a928f791da50249bc03a24e331509ac950c95e064f06b85ca208ec52db890e9f8b5c31003d0bbce37710296562ba9153a7d219d6b6f4fd34aa5da765541c5b7632d1957cb05681f79a8cb3ba94c0b51412bc88c8a527c71077a89804f15bd201c88fd3811ce50dfe29e6e37267e0a816c3b283164ec70defd7526f4945aedfc009977d2921a804a6b67442069d89a1297b5144c4857dd9056d6e091dcf146eb2677664efd7ae657622d5f2b2d64c3b2a11b0a943c4b536bea38c462db1f88ff5edc495d80f61031f9c7d2de8aa559cdb1378e6c5e5e3b2f1e49face21ee94ec46e5bd95414efb54a65ed1fe0b52ff9de3b2d242879918a2dd3a2e5c73cea860ce97afa0b6645c7c42e56dfe878a539436d743eca4366951849c9c7b2a28daaad5add9914420fea54587f85a19832bc7667a44f042b656d3353ed2cdaeb655ee34c8588b90f4537b792537fefac5fd709c7ca3700faec2c68f23ebb3bf9fd6390aad6f0e4f3847ff17ccae3e6fe36685ac91ffd33e5f88b83e43a8ae867372954ad9b8d84f2ca3e2c3fe21565a519da6afe148f2c6d91adf101dcc4cce3d016ec72f06de23d345dd600d11c8cefd213a97dfa1d22e6af75d729be74aeddcdce62cc1e538c8ae96667bb61d4ceac8b1f87c8ed2fb0753feb82ff51490e66a04f10d77907ecf9b40edfa7043ccd90e46691460ed5c7a6b07594077655aa49548e9a4cc64bf4eb899e1830908ee37c5923f7f322b0c10cbc7fb53069c414a08c85fe6dbfc4b36a3995a6395ea75e74b639f29f48323cbe7e52fe837f2125c94284224d106d708e9f5cfcbacee89665f7a10acaf078cdab643c228af11c31813a9e182848325ac278c0b9faf6e0a9ae532e8df6dfd012a9b3291476a23cca8277606fe94a9668868d221427559aae60250c5752d5261261536c97c2533e745b995caaf098097622666b83491adabf16dce5394da3d4f54d15c35f1d84f334de720b54af9b21e462b45726c75e68dce88635a415a8d93d0eb8364a34bceaf146c843a79354958c3c2f66880c4bee05c6ae5740b1c5c3690a9532762f17ac8aa2cde039f50c532f0d699e956aa0a993483ce830bf99f7a780e8db0366b5c4bb66698de285d2019645f99402b2751c613eaa4ca7f40c172bd9cb8f15c6ac57529f68f4a16d2858437568f5deaa411456ee13b8ed42f5e52d09b98d4445c9f8e43bf3ed86669b40cdc5a739eaae5b29d581879b65d67bd238c3193064b1592443ebe42034d3b24ae0452ab87bca446840013ba09f73fa3c9fb6779887b1b494d76b1fc3fb8152df30212bbca58ff0c5be10b8126957b288ae1d24a1ed65635afcc489929eb62bcc93975b7e7319433a7871ff1209e90548f7dbcdda05bedb7e995b0ec5ab44a762b91d0e8f3c7d018dad04d64d706406b48e95f8d56b92b26982ec2f4f0660d41390a64fbfa2445a4ae90875c0a5adb5b4368a626059ee4c38850349ff9d6313367e5cd792c1f1b6c49c51f17fe855173ec44baa4004e454990fd29648a5c6e7aa49185967aac6341101b436bb697535493b2cb4d3f1470958688e500a12f1cf49b577a9c6d878df113589da10ae4a4e163e183745c2cb12de21502a9bf0a7bcadf5be29d92c3498595400cc38a2ee973a9ad9a6eb68117a4bdfb14d6c665886b4aca375640674edde0137a5e6187f08c39fbca5669b75ef529649c1e04e4b2779ab9596cd6efab7a557aff209a684901999d7fffafc169f8f0a0478ea7ebf81b03d30f1e48627811ddbcfd2b0c776ac166a194871231c5793f57f1ebd9187d99fe5c68c62dc8cfe66e82179c1472467eb56d16d105bc7cdabc387344660ff57342344d9b4028ae6f467976c1b8bfd8b4b1e45f395416a54d5619d34491037abb65d62e2aa032d220aa22ff2d56f3c5ca76834bfa6de2cd2931031759d3ce01b44ff17c16fe3d1bfd7617cc4d11ad7e1bb611c686538264fd7d1b9c0357764c591705a1d9e226adc555243484ceacc959d0df84a6571df1256707a207b09995edb1e4320eb78bdda63bdc408328f993c193fb3ecbd9d1fa6ea2cfd3b85c2e210cf5bd1ceb099757892e38be86826a5ee4497dbef19e0f76e14f506c33229de37e02442e558ed9e7fd1539a1ad5a74fd85451b78e77ea77805570bd89783a16453c12f0e7014e13b09f55a6f444fb65f3a9332210724545ce4b9b3065e7978df45c6611ccd7b877aa641bbb1f89ad68d19845eb0460be53dc2e1afc61e2c36675c2c110f4ff7d61a9eaa8ef644e66d5e54f6c2d82f91bae2de73e9bcb36eb4523444ee4d09328bd5d5c237c2b022cb8ebb1b1397259109296cd2eb5a648790df88ab498754c87e454313d160bf0222ddc45a481314182e8a1d4c9e8abcd05b189f331d3b3021a291a86f382f70e2b45547eca3b8f8f499b913e39c6100a123b19d84e06059150147aca2916fd980966fc234b3cff12e029d3024898c2e066ba0b6e418d0fdc94ff0dd95e20874bc16c61d246cbab2de46890b482bb5ed23ce6e7e541e9e8efd35e53ab3efe7f12b33ba97897b889935ed01cc20b80d1e3c9822e7fa20d94d51034efa53f18846c95bb56535ae44b51094f4a82c6a5ca3d37f7d310b8b48c6bd091bc1038756f25a640125ab1e2e9c95708d11f1501adc689c5d409714f81698daa4c1ba704ff8d4ab0e315a206927dcef2c1381147e5af34b3184309f1edef21247c05b46cb2a4211b3a075b320e7774cbf74016983847c674bdff0e22afad1be53046e3524ac045dfc1f277100a64049c2e6ee6b87d1387faf8f17d97641589204a9a1291d98eac33fd831e356e7f14b52ccf30146314114d34e15ea526b0e7e5954db5df8f0e6dfe264f0c73658670b55a808f77fa4fc07412faccc6f98872df4c6ba1424fd08622acb77f9097bf595fb8717f3f77071677163ffc77e9e856d83eecec9ed5292dcfb5f118f5fd4f3fee3c815d4820d9ffc485075d6c1ff8c96913b6c46dca4d5e4344b3e5677aec8e221e7fee8f9fc4a3a832d8b3eef8dbbccf84a0d0e1393ec2ccad0a9fe7db3e16317309eb793e7d81ba13e09762a6b07d93daea0af06a533920a21513c17ad0ab73dcc52186a52cc0684c0764841c2264ad6c989813d6d0cc1cd3900991f589b6ef8d587d8d037b6132fa3e172b18d1c42934a129c984338f49b8554c07a0afbe3792dde517250290bc2416b14df222adeb9c57f15b3ae0bc5afffa999a22d6da7adc2d9778dc008b7569559d68f61fbd0d1a93e389ef38b0802172c01c1e8a94b85f419e6d304b436c4045a6720e556ab73cdb1477772f46537e3f0c030caaa0d7733f139888bfb55f64f85d752679c29c5dc23a7eaa41ac845cdd5b4b944f39c408bef11d21b3b884373f240dfca61b28719b668c0cff63d4f8a4bb03c14eb78123458e85801b97f289402cc1b2f88f8185a8572e6a7fb281071830ed40fcf2d16726f533d2a979d0d4b5d7ebb22956ed221555dd8a58cd78868035a0526600e5d6f92a245b22fefd5aece574110e3086402ca8a9286711a2a5cfcd776f46a97ca1b79a279fd9f93e7bd9ac8fc37a3e402dbb4e67546e458e7cc84775920db2d91308c85328917cb2404f154a03ed0b3999f231a8c1e3dde4ccad6acd1e49c416e58634921d86e032383644592db5c502304c5d89cef2a15d5de98bd708dbd6842afb5e1cdd46527a1f2f4093c831dae68cb458cc7fcaee250e96073d50dc4088bdca9614ee8953b23a149163186a044bb473589152cbaa272dcd2e4b5583acc571c1c7e9b35cc7e8335fbf08559cde97d6af209281667cf59e7af79d5a5c3a494a4cffa417b5e66c15e96b746d8a5cf6465edc9614b232fe1e890a0ea6ae4a742e5cb6afaa4e1e8f7b0fb83b3706742bc038786a8591d005f05ae8d351d9672198999abe6645ebbbd6064a28300a7da266da766426c5129c71259e79c74ccfa90a0c29b05e9873716b87149d26294c5c0e276570cd2632ce9eb335bd9f68a08572de5240b169c60354300090730b17acfefc3aeb87e63fabc16160d4b720a4bdab0e36601f76f1e48be84e80f38ef55918b77b28bb2baba92f67713503dd083ae65b13d66fe4e71834dca6d4879e73d99c0a5c19475a9735c00799b99a8f29913e5675156821063e6319afbbf33b762e7751fb6f5e8694728ba51c1ff4323e8d596e64bd47d7246b73e8701c35f4080c59cf2de956150decab32e05699dc5b3c47cd5a2a328b8449038ea3c26574a3bf90e8a6836ecabdcfda230bfbd141f2d2e4063af01e80d5218c7ab60505c6984ea22bba2359bc80a1c7c8e897fdd0d20738c4ad6ff2fbb9e6eafc31518bd977791438abe37b8ee54c1253b434769bb053736174fa522d1be9fec22f06bd45360ff9c103d38cd3ab158e624f7c3b49e0c1db7a6026713907b2e3c2025cdb86baa95d8e0bf4127faa94f88765bbdadccddd3f3008390808cc4799474f6cb1b134d2c9b3f3fabd3e6e86448f8bf76624bb3032056d2e281465e1dec27ad7824d6d45a36ac7ef01131683545eb9d53ff1466b27665ffb569b768ae00a068be9ac2956b714064f27a5f3843d332be00d845da575a3e4a2ff4cde36dce5b828fa2693ea0b32be0263014487f6bec78a2e004e517def087bada53dbb468ccb7fce7a2daa91e918967322b47e9dab7d889dcf4e2dd29e4b4a20f5da29022e29799463c0f8cc9a698fa3b51c42f3d78674070fe30b72591db92bfd36f1015eb7b7b0bf8417e787da54a0db546cabe8fb7e259d8a4b96c3aeb134e19eb0605f9364bd303a32cd20b20ede611b191c679ce68992647684ff150f5fc61674c1a421678a2fd7b21ebad58f212fa18f03bfada34e1f634dd6d5b6ee5e165b5397957af73b0d644c2a095fc8b01f7fe95c19cce9be71d6cca36fe7e047e538b068b9f3e2a5c9917ddb3fb2efe129181e88d978c8977eeba614f9e8568222d23131cbdd2e4a29ad4464c4c465c6e68dd454359adcf6595f0266a1154872c10b1ed006428251188abeeb17464de39ec8dc5c827edcf8a5b34e680834eaa01fb5216499b0d902fff4abb88fb434c75fcd919e85e420bb6365da3eefde04dbea59fe943dff239f70da36d864347d5e5f9a95757b3a2c83fc9e796be180fbed957ea9bdb6addcc3f68c579d47ba66bcb021afd894d68f29a94325fec0cfc9e267451e1646c02e2cb78f9a5ccc7036ef4b541ef83b02bb8b170bdf7a003b7f8c7150dcfac56a21702d3485e64b88849395815b8791386e7e13cb5e5378e8de64c7f49c7ecd3e13d3d4b4aba28b32198d080da9d9bfc13d7372b4f7fbf0f9a568ce1e8c8d428722b7b00a16617724ed0723e8a5ad8003a2763bcdcff70736be7208cc993a3261e17a387078c717db23eb3e0b5dae6a162c4bd0e1af017076639e37beaf4c4fd0b15cee042694de1572391451e61ff635c91249006b86f2456fd82f1e78bb667dcc31505062418ef3052dc117b503ed02ed41d7e996024ba00897d2bec83701dd49acb6bd9f7d26df87dcec076c7f2732baf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
