<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a563207467a7c3b4e2dad32579f4b380f9d3c76a24aa2fe14dcae725d879ffcb6ec812ee3624ebdd745a5927f1e5dd473e7cd510cb940920c906c2520bbc919cf1727f0970c7c9e702bf4cb3dc9688ba3e20535ef675cbbd859d39c8bbf0fd1fa6aef6933c72bde74f89d340599aa55767d46320ac1b8036b0330b753e3d9d86dfde1b974e054a3ed72f187c661cd2d6e2542a3a63f566fb375bca4f266a17259f92a66a121ea622a391fdf502c1b796af0acd5111b7f05bd655631041f6fe27d37f09a4da6e7dbae586972205d18faf98e52163e7b48fa3bd5252543cf47eeb718203f16e2f2659d794db3ba6d3ffd13451fdb8cf5c26b9c664e19353f5a5cbb3a1cdc73604029e77e29e06c313cded878edc6b2bcfad424a041f3aa2148d2274c5ba47e7a866a253a2a933a299b226dabebedfd12d6986a0079330dad2a6da7038c4809fe2ef78dc714fb5f9beeb67be23c7e111443159b3fd262246ce7ec01ce580a7c8916d24317bf482e341d514a0cc7bb3b804511d2061763bf0b1646ed8393c77fb5a7b4bbc121b6beec88c963eab2c89b8af54f2620a501bcbb4b556f0d23e52531af60f7ed4e01f1030a28a225a544ec17097872701665543cb1053d914b3ed53a90efa01d8abba4cc350f0f1a21d6c14edc712941a33208dfef928beb80f0c5284d13199d8fbc2260afe61eb55a76d722b8a8696561d4686a7f59439d1c2b3c440accc4eff1ea292d5c5538b2894d786909975172df0c278a4027eb31930af6f135e1c9c450df0cd3e904a31a1a50055823db204506d7b22c340e9e64b927d566641d7407569f432a69f0fe6c76223dbb95fa7efb7e83666079575c137d664fcd86accc1e9b05721ad278004f8a60769faf304ffe4b6e64a34a95282d6ffd3ff09307c35cfb3d9ac0ec15a0bf56f20cef9cfb02b1f72bd5c238dc0939027122ceb4a98c2d0cfa682b90f19e518bce066d929336404d6af906d2ce8ad9f48429d50cd272bcd30b47deef36400b5f6af7aa506c62df7c4d581de22d70a8e9ecdce7ebc154a6407045167146289dea6cf23ff2c6944b38b1d9ec465898a27b78e9a7ce089c5bdb8b58028d4abc99f9f90dc8faadcc37b0925226ce2b60d688a9dc8fb9ce13586d477ab447c208294a1702618294ab8fde4c495ac4dc08f18291ee29ea094778ab711b2db91c20a9d9f999e2671fd3662c9d630eda4f10ec8cdeb9ffc78aa5237e8e3ca28516a34eba12b768f6a26353182669a3cd421cb4f94cb2503d6b48fe2b20c416388f3e7b09807e87e51d35c10f9cc27cb19e84c36ef2390aebaa6691b5e35f027bc38abc7ebc74362fa2c1e08db591f07f8a93f0f1f658af56e3eac1cf6fe3e04b937d7291dc494753d150606124d68db0597cb15613a3365189342fece2d06569d2be6f2e540f640105e1ec5704aeb2ab73d66c96aa80b296a5e6db4cb1b3836676bf39064faefb1a915c10f8dc9f30f8e44b423750d83774e208a101ebcda396f49a8939ea06294a20ea4aa51734f9abfecb942500d6fe2dd21b2c73158409ae229d02be7204bb69a5c3de796bb5af081afa8c3e15715959609b341e4a3a1dc4adcf08775ce0e68b4aa31c5f91a83652521e2525a1d536c8b438f01cdc4af26222a4ed7ebf3ceef8210afd986826dc6587ae5a63b3c4590e11b71a5c06ddf99efd2ac4398186e0006579345380ab16c1b8f74b505086e29fb81b3e68f80371f97eb597f747d0882830588ec2db880a22c84a256383bd2d7e690d3bf8335e48bbc9c6b54ab03dd6d33233874af4cb11ca19622f13e6575e7967e1dabe6d91fdaa4f9115c69d64b2425acf752b14522f5fa5d8526a46f28ce124eb5ca90bf22755a495e5cb493103ef03817c77865a1711804a411a5424721e970e7c92689991ba94fef2e84435a48f0a779b3d9b339b60cd61c9bc22b29497f86fc4b39d83ac3f8127a987417619fd6b91d9f8f28a53c6924769273c35375d361710f3b50454ac942cf7ebb29eadc2fd37400870a7474bc702888672d36c59a4fc0a8f661600d36f33a2d2568841b4c6d5f9fbd1daa610e99577444abf91f6df14ec8a8fd34ed70bf5247b5ab41c570b1851adfa0f390357fe1762640c5419f84377fecf7d08542142bd58ac2f01fde02f77186de437c370cc375c33c10be98c0a33a4fbf66fd37ff3700f572f1d30c3bbbf8903db66f2c6147034dc2646c2748453ef2ab67d415c81ac78415acb3a81da7c44290130cb699f8a37d83fbb1950e7ac1d0cf2a1b84d62ada17793484e5dbad6b29a746c599c4eeb1ca263acf8af0853369172941126e1bba2d20e4d946ed9938d41fdc1281d74580cab657ab5747b3ec3d1dc8e8114d8fda09c0ee31f7aa1b34a7c1d0f2e95d81277965740b213319cae632e3cfa0cfe8ad5603d467a9f91b284ccf0a1a8a1b0171bd8e4ff9a299b429967d17138fcb5999fa731ca768f2b72b11a4323eec39d5956bef6ffb7e1af980a10bb1781a0a0d64f3c27b95aaf7c89fdbd6f7c54ae7ec9672a920230959dc70163cc4fb08b17a85e6b2893d7e8967ddba6dcaa698e88bac1d660d2d299270ee43ac88a3972f114c286e65166bb68f32e76a648b32afa5ac5afc296ea66f0816910e0c72001eb91806445d5c8d4e50cccf16f7787f4991ee53a9856c64c0298b9b03c8cb93bde4815a4ecc3409ce807719684467f1526f11ad02c466adcd1a6f1a04fb0bb1dff4edf6aa555d1bca3da00e375a0edb7b6ea3fb44323709ee464ca85cbbab104b898babf6d31836c0ffc150c30ded3c46bf7179d1504eaaaf964ec6fd53dec6739949bc4ffd9d377c8ec6f5a1a33601fef7775ea81ced7adb624f3e8b39d3f4c8a4e32900ba5ea4843b7189318295b14fa8e2a339bcfb23455a3246d744b4c56d538e67d8770b2b86fae7b7358ae686fb6a476d02db260c50a5d7668c0fc548e1b796683eed9613cb103e817becf94fdb406fcfc81ba835ea4fc68afd10e3eaeb0ba224e869f5a1b171bf046e937c7626772dff918221f6a796724399ed172651e5fa03e7757ed38993f47eaad42c327a5941106897fa4eeddb89b21e1f8203cbb188e23c6b239b4b8949bd40bf27448626db6f4233738b84e9c016ae0408a532179300f9ce425bdfa0b2b138476d269a96595a3f550c400e7896cd39c3aebe4538d72ef4f92c330fb4ac6ccdf4c2fd5f9b4b4412924633d85bb33812410aa9ca0d4fbe89aa62898d1d097ce2625e31ca2ad959c98b9dc334d8da33b967e92d744027cbf2204ee6d2ced00a35a495ddab57cacf55bb2f4614fa71b57b1ad57ef1a582a5554f825f5234eb73ee2ece515c9b92051fc5d0568bf518a06da62e8f83a22e23d250ee2689600cd844d102b152d8120ce580269a66bf0b9bbe98fde295759c8fb42856a05953a2ae289baf5c34c83c9cc4ea7ba3df165ed29d0650e07ac7cdb5fbd0bd3bab4499bc4207bf13175eb0cac35e547e549f49a38739bf498bc49a45b556d3d266198a2d1135f289c7c8600ffe859ee6cb869311638ba1885dc3638d0515314acbdff5742b590106cbca044baa9db4d0a13abe39cf53d6dc12e9cffc4a8b4f7dc3b53ff8bbc361d7ff98eb98105e7007cdb52c1ecb6571e1459e032a44e1f8505d5ce1f2fcd614302a421afdb425427f0514940172280abb37d073e011507800fa4f7adc4c451f093a28abb1717f446fb22aa416b69a4a1e49ce54a38275c7a206cb11b735ce15b011cdf8edb738230a1f49f97016f4a3ee9bfa61d09bb47d6da4b32f8ec1b58c88ee91e067577bcba59286789cf5fa1c280e1bbbf974ebc98a71a4d6d43b3c606bfadc38bb646a649b6e12ea4c1bca6d0f8f4136136a73f9dce15f66d6f0aed7c73d492a1ed8585f54b4eb48b455755714f90d9fa6084e47dd3937db4baf05458b6307554d9412cafe0619a398382ea402097b0f7f59b1ff9093eb45d7ef2eee7f162e0256158e35c6b33a38374a8debe5553b23a0064a1856db2dad6538f93c088454a5708eaab8e78d6509fbfbf3653001cc5497e1d2a28d37153203c698cd374737e8674515039128693cc1183a2b11683248dd12dc082971004362a44c2c373de886a092f5de8d4dd38844f1b3638b4bf39513fe34ff34d0c2d50b113c459791172b7769e11e8e76ec6ce0a08c96e1ec330ee2f57fe64fa2048b2adac4cfc1bc0cc544222e3fd9f6c3ef78a597edea5d2f081200a50d54dc2ed4511c6a01a1ab3287886c630730fc0d8c180cbf94eb05b33f4fea78ff8ef548f8b0deb03a3f1ed83e3f08429ec5e9776a95a88077923435c171b417993c0c8b975713f0ecf0ed1a57242b350961a7859904117b0bf2d3dabfe2299de472412004acd5bf2400ef001f9ce2f5ae0353622e827f8978693ba3a4533e9f5c18a93bfe3ec554ace49fd5430fe86fb35b53456f4db72408c1e8287b764989da0a5a7eb99a3cbc32332f7b3c28d6d4b1a3afaa532c137b49d56eba9a6f93105e3417a3326def51df27d872304b096db2975d9e9db28fe1d9890df0e9458c532ca39b84c71f20985cfd720ef271ca628136f21fa89a1d20fada8f7f3d285e6cb81953cb9fb86f801c9519ea3969d257875cc1460bcd58db505a0f829773c393e2b64b38ccfe8fcadb1d06b5dfe85d862bcf27304891cc5e9f13ce22aa515fe84dea9fb5e720fb503374ec4f5b32e8728836ac832ceba65dcb1d3137832732a6915f91dc8811676f81d1ec9754e059c4e2c254fc0eaabec9c816cc655378f5c5eb3321edfcaedbc7bef0899815477eb2cf3f3f535f6dc4d830045f670931f1a2b0aa441af8654ebe1051edeef9148516c744f62c846ed955cdb7805f50cab2eb052644642dc24f6e13511b84f8a6d9e266e411895373174487183f1f1186aa059f0ff2d5f89ab5b85f8cecec830c734d2837ce64dc65e8cb74564aa1ca56784c92eb4326de75561183d880449e74858d378c8b82f1edb09b2dbd9ab0dee6c3398480e8e56d46f40d7ce968ae91aec8a3a0dd79f9dcc819c92679ca70cc7d1805bd4d72534a38ccab6644f6f789b296f27a39c41aa5fb815949efb9688fdf8f5131be133296ef06332c6dbe853d9b986b4bbb08719182315b0610b95622a741b49f4f6e9d4b528dc38c937cd1319523bbe355640102c53d4e009d8cec5ac86420b6ea09e329537d8d9b7d71b0395fc3d577a75601fcb0601aa5d98d7cdbe72f9bd748b676d687af80a72000a25d77c1a6a03aac5069b8ee371b9797cae5cebd1a6c45267d173ed69567128fa52d54ad149cfdb4d9ce0aff4a617a0ee854a5d64208eb6bf270d0652421d48dc9547a00f7c415ba2bee2f161de2fb1ddcdf17f49af61e926cb3ecbac5e05c5d63f659097fcc3761e1d582bd48f45745ad7a8ccaee919d6757f6d1b374785b1e24f8d8b5f11eca90a0fada75c5ef89ea70eb3579ad9335289127ece7daace67f4b3cbca8c88188aad40c76b03b0469e975578b1f7c5a4fef43df396d015a33a1cc0c26b159bdbce2d4b4a9a7a35d5046c7652436d37a916fe331ccb79e3d87b712eb3adf31c9c78b6a105a615dfed8d12da77a8435681031343baea0a9ff204cdfdf6b5b42d3d37cc900a5cf44794e092049315f36015dc6e3d9c9cae40ae5362833ba73c77ec3af553ebebc2bc7f33ac990bf1dcd40519b85b0dd1e060f51078f11343d3369bdf11d6bdf61667fed50eb1bd846b08832bebff72068ecdbd1d3d03eb4def20d708de95fba7221fbc575cd6927fdd8498c1804de3b6243726af1b096bc0296c5a675d8f800c4e8b4ed5bb48f7a64a7cf3e1d884da165184068698bcf0889caba6d8ca6b91c96340c2c9cb3e5785c99d8171bd999c5af1e619d98d43dfd551025328550864a92a533e3142ed492ca575ef62ba4445f34d69de8d47d4ed5923e4d5a96512104ebe296f37418ecc0bdc9954dd9d772bf6f4f6475e0aa461217904da3663163b917056a0b4094476aa8e4d4d7856c7be5e18dfd51f38a2518a29f0083b0063a532e5c217e12c708b07b62e8395e039de668e39696d0fc249d9c639ef9a021f28dc98185fc8e1a2cb1ae9cb34de3ca781ed0b126f9d7d082192ac37a3b93dbe7f01798d9775142bd954255ba16b8539ba19a9d56c32f7d46f768e5fa2685d67c40e4d2cddd55b8c4adeb792e6689729a378fe0a40bec2877a171fbf67ce73bab4e776d01cc120b4074309ec5d6e652bdcc48b6a944f24414c05ffbc43303afb249ab3b063e0e913fa8a0363535f6ad8eb04e46a342162c3e378af076112cbe83e5547b8d1db3dd4bcd57bc6c8c01203b000d646265d1c17214295d8ff71bb6968a43f2844df88984b4e8e39672f1686732a5d8bc76dee14365a212ca9734fef75e6013cf05098f8b26c24ff2cfdf55a4b49be25f715ff84354d8cfb678022acc833d30d42fc89864743bb699f9d98cb9f7de94e61dbd1224cc5d5afe7fa0cbd3d23423ec3ab1dffebed42aa38ca00ba0698711e7442008179f8366706c9391c59d63006b55650c1ae9e74d64a71a733961a649e26a80932b6a03cf94674da1a8a17b8ae7750faeece1bd22f15a29c03e38537e37aa0e343a78c900f405b08a7a4d9ca0fb83ab5836737a42485b52a6489cd0d4421920fbba6022a9d2b9e7e6452a17bc91be6c6f88ef67b5e6e8070078e3dcecbebae5512f7ea9677ba7ea3e6f3c67f1fd8bfb09a37f2e772077ca4df0bbbea149ec8226d86146cd899a0102d8dbd74d5211f5e1a3c97c6813510508cdad3e3c64d8a1ab54bd8e7dafe58289ac3743d0c7219333ebe981ba5a787cbdc98c780800b538afc6cc245de5e3a4cdc884bf625c0a1e54d222f2b73cf48b604d8ec4f883a71834db63fdcdb203ab01760b60fe5f8803bd85c70abaa774adf8c4abb1f720f916e2e8b218fb1590087224f5a3095419062769d7308d0a0d50dce70fdf745c1b1479996a8b4d7d3676563866a1c7a1bc44ac949133fe81a74c883baa57d12348e1c299f28ca568e11433fef7fdf2541b92c42b0651a1b6abb2a5c97cd4898a8c766a31482738dd6218c96904fc86092007e71ca30289e3c8bd1891b5a910cb0ccb37f2f9b8cbb9fe98b470f455154d8d61996c0119c6597755003af2afd25aaa2f25319918ea490799fbe0081483f6f7d6eff084b2a3b67354ecff2a8246b15225b403e1245e208e5ceb4af47273caa43678bf1fbf8c56e5b05de31a77f0e7cc495a41cdde1d81d207a552757037e2289644ccd5930ae76b64f5c260bc957a70b1dacf27eb6f910ae998bb9be31d2b0809ecf754dfa8f123f3beadf5f00f9e340df502e0db9686d9744e228bd08d2ec3c5deee36ebdfe65151d085d81eeb7e56f6515c060a593f1274c8dfe10b4e1448708ee3d2c5665cd78a46617d2d6b2fbe73fcffbd987e2bb6fa1094d30f16d3a2d24759e640e13a1ee1b0cd381f8586fcd6e7a863ddafb6805fdb34d066c3671bded6557f307b667366e89c4da3034f9e1aa3065ddeb36889098ac9c5911266af18ca70793a6ddcff939ca0202961208ab27fc4fa7380c6f3a68d119e89ba82f240b7f5cca9f695fc41225af2251f36b0be05d02f8a493fa409eee4a43442ddc7a98bb1b358afbd170a622fe6856878426790883e32de9393e0d490cc405444f48b1b0840a3b06e571d4e8c776ec37b2cb11ebe81031e8b10a4a64112ae09d64ffd9bccd28b457131ce80733bfacbff7ce6fdeebf09ad0e29b87d98e22e8193005715ef5b2f66c5c0d2854af6cf08ffb3db27d211aaf60ee4435381a36820c81695499856693ebc99957f842f2474425052cb9a087a3b63d4248444f9c72db6cb67a1d88ec776e84ff791ab3ba736fcc1d3e2a5afbe3e06606fcf63a49fe3d9b89155e8329241816f0031263255346bc1604210442fd798a2ff66ed26fdf30b1449372a2325856a51666f20e9e7d7aafebcc01b765baeee4c067e8af207c6438fd4400db703730e51f5283a0ed7406a1f6f6e3360dd89b18a3bf1cfafc77520a6d36ce73312041f8365636fa7964c59f1ad745f1c89e3c9b250c9b9ff6e4840b408d0c7d0324864a7369100552920d5772b8817444cec1ea04d48caa6fba7e99ed265ce245cce780d3ace6c6fdf7f9004dcfb1cc06319387622218c6109379ccf705726a935d4130a9f03db12b55b7d63c2e3c3836da110f18c04de21ddd88ffd605c583acfd2c71eb8b8728a75036551ddb18b0f48f7644fa6d18d1f73dc8784acc2f3edd8e8d4dd6d5c0dd02b8c6a6de6f722e6079edfc3e39b79feb0819862af65ce778924d24d5f9ceb94d06de71227ca0d377df42ac41ee16491d8fb37b6a834c9b6468d435e8119cc60795b8297103c55971dd55e0428bf3d37f1f0acb7b23b48b8942023f849256b816ddef6e6a728ac66f26c403a480db1429081c4cb0cfa2179f37ad7efd8e762b444d79cbbd5dec99bc10c2111622ccdc5cfb4114562f4878a6eca7d4698a32be287dff63cf7167c16db01bdbe390b526b1315c85e6ab6e19f7176c96e00b0029fae94cc60c6c6e885f90a4c6764099580f8557d5c494b0459aa5d88a6f90b08e6925641ea09756f1d119dfa1e676ffc1d57add48f4239de3ee7953931cc857d8fb2a3fa7ad6c45b766d08ea878d4a80207751f569021cccad812fd740e0aebdfb6e20013d85738abcc07b8324a8966013e4a37e9a063f3593cfc80bf2353f1425c739e9a5e76a7c3a1286f54848b9afa65cb93cd401bc12086dd4c814116a404382e021b4f3759d9609c97a8d44a8b2f0659b878666bd90d9994bc5260945baf1f035fc7842f83868e1737822bf70656d9bf0a52f86dd0f6439f988e97a03785e630bf14f562fe012ced9568723825646da85e2406d162f90195bb2a25d4ac4d799fc6c09cd93c7c0a966801fc6047bca740da8ec1bb4c53a54c9c5aaf853d94614c5bf619c4c0b034df83f24588480bab77ddcbc097b29b74649944c41fbdfad7db6f65fa8235e477b75cf1c2723b764a684a1b050eaee543395c43007d8254adf6fe2b13d6b1c3fab000981c4a023917a5c839c5eca5ce893c03f47a106c185a588c6e5168f35811537c69d7a41d9c4c74d4cb0e1276c0599c182e2881a5ef43d865e8e82ec65c22124e69defdbf7aa3f99235b79c815193987d22b2f04f2cf0b0e020e8c795f602990e50e70bae2b0e743d7688ae7276d66f528a5c36cb54e886035076c6e66792c11644dd31a60d084f8d2e652da8c330855dd6fc70e304a6f4fa104e7acb7a7ac0f5f9f5ed25787d3d6389f22b326f5f6339e25c8fbf8aee0076b2af41e07f9a0a0c7948a65b241924dd80dab12f53e324a01e8dfdf755edaeefc7c1a89395d4fb84e6109f37911fabe2799e0e1f3886067a6cc6f8bf4c630e6797ccb0dfc66b3792393431285fde741fba539a6facf34397f6c100bbef756894a5aeffc61688b32fde37911b690138e63a00ee3b71612f04ab90f75e8834f283a3c79f7e269eb064efa7249589d9abb77091fa1aec72188055ad9c0fc1007f1a1a509338e9cd67d6cd27ed943fe80fc97fafa39a9749afe29d9bdb86a93f21b166282f90bad93995561f0b5a66c6f510cc9a94002c51a843e1c5445da43cd84e82898a3f7501f3dd042abc4588cce6064b1b3e67fd3826300f6bb839acffd5e4670577555d6c350dc67b3a312cfe98b2e073d795ff0cb22eebbefb5e269e851f5db316b898ebaa4057397e83a7f573f0f0cfe0e71085ff82360101fd89a9d4143ef51416abbd51ebc7a6cc61838d8ac2b914aaf9672b8dd3024dbd8c12a004d4625155e564facc0a534756108f116fd2c7e645edb1973d920c10b424417f6373a7ffc24558df7aef3dee5f50a7b2e8fd3f6ba4b937bafdfdd2ce4127490729ba1d5569fbdd46451528ef7db6f32c699c5d0efba6455c89961c599025879c12865d0cfcd41d1734d363f4d3ddf7defc744628f96af0789a230dd11697c7a0600bac34649ed5fe0ed34ded57d06b7771fd4c7a9c387756a51312743b75e973331899e4aea2571a369880ae1dbe0c3d5808af870bf4b2fe10fab4f5c9ac89a9fb97f126e3aa47be0715c66d70c065b994e446b88e6c91918c3037dba71e323924a356339d8f4cfd5a984c6ef0d13c4c3e406feace1167ab25af6e89ee37cb1272060be1941228c399f481fcba3117d57224f188af88a3330de707f5550a9dfdf3833e5da8d71e4c23111ba5afa5d26051f3a067147447535def05637e3945ecbdad8aa28f6bb9479a1cd1f28931ea60ce836dd66a138718ef54b31766685e95ab200fcd8236223826065c385d2bf19d1791f5c763f637d6a4e67247c87d2a3aaa0dcdd7ce51e92ed92d6024342555d6cb43ff3e1e67827001bd6e488a422d99c7238ea38f56dda6f156cf12fdc135bc3b5e535ab95f760e8d381963c37aaf33d3c0c7394897f3e0f2b86005b1d1d1e82ed990dc0d668343a532e828cf7acd4aade501d6e03fc6ddec4b5a622392c005379d1e5fc74092ee22fd54e078251efc634825b258a4fc650f2a953f154802c890b2e068268b0965da86c217e17c71cfe763f71b8b63395c8601491052e512886f47a1494d5bf6882210e5b3bdf3c73639bbc144aabbf6209cfb4ead768e2a24f1beb19e0e28be868c41f8aecdeacac53169f0b64e6259ad941f37c45ae5b2373801ae4bb8573a96e32ed17ea03ca1937d8e964502b7f40cb0db78142f0f705d7dd2c6aca2fce13337d75ae80f1737a8c60cf082f6c63f4194e2f5dc5c8da35efe8e16e2283afc61a557f4680e06f8278e8ef6f7f02a34c1426e8247645683d32f7ac3eeba0d85304b6bfd52b06558ac69154558eba80ce7e89d110b9e0ca092b2f47b65ef8223d26d27744d1d7e40c54ad329b42d887f8545d3af1f12194bd150c5dee2e243c2231f6f83dbf7ee6a587f7b89da7ae53993a141cf585c93b23c285d823a5866136b31ed26ef07b8211b444ae12c9fc356079fe03a59fffbc1bc8028f4b30c84c8b2a84b5876c20cb91867d584b9ccccc86f0590a1163cbd2153a1d304288835744206fa7e1e30006ace17018548518b901faa25dc671400858f404ca784440f4f3778b79e13d5b238b6f68a42c7ba9935fc711854db838619ef4bf97721802bf87c6a7d7b5eee77dc1a8c514d6b22837478e2f7f420ff5bcdc7adeab5ada1aa3f08aec4e8d59931450bf99ca598266786f6e76ea9ca826d3a91d755f320883bcb6a6bfd9d6fcc1e17e5475756ea85106d1b99aeabba4cf34801bc8bc657b4ea84ad04946d57eb5cd9c070657b04e8c7f52b094f5eb8d49085fee5c140b1925acbdc185d6c21d8dd7ba6789b2727f33835b2a212b712c78b5a550a93249ecf60d89e5d772f6f1b33625e5f7a18b34d9fb2481df6f252e5c2a81bee5bf056e01eb82774d58b1b26e05176ffeaef58cfe7fa41d65d828d029f94795129e5653b14647c6fc411c0744205b313e02a51fb82d9919830efc27bcda81b2dc03525741a79d6475b943dca71df05908a72de54bbd011f19e55e34a9682d28e125fad75affc2c503892c279c14ae570c900d627b902a8c52ac56d460e7e13cdee15c0b131cc70cf909e3954aabf817a9e2b38929fb67bfbfe2fe5f2cf25a5ab0f178310ae6d4bedd3b85e36f70e5cad132dc41188b647a291fccedc344f0260fe9ffd5a1398c0a322be3e2c337007dde82a6db68580cb60e79813c0a71583a9da29f8674cf5d9aa42297c0b112d688a9dc59e4770316518064b36012d62ec0062b6a532a49dc3f0a1a9269ca9b0db4274014aab8a3b89da63fa802576da4fea6dc63b0e6848886c82db006f772880ea0ee782d8840666734e2e15ca9366a97027b86ab4f6b74912593469c224e9ff9a3c3136a52986fabfb180764fb2d118d360dfb9cc38d1bdb3535c4f095e2ff854924101b2ef1ef0dbf86c5cb8a179c650a5a6d43add911f2c9d7a0d0c06eb75109c61d933ab05cf25c291b244999946c55d25da446b3221b50669316cbd182a8a785325432763188a23d3432a5581717d366319df6d45e1b7f41e168a2b15ca60f5bce1cfa201b110a118224e60707c0f19a40761ec56dcb96ea73aaad75752fa875bb2130789a2c53af932bafd6b77dc339069c46f7790c07b99f83d59980865cecf6fdca19bc2f708b09c1188df8cfb15ee618dfde150325a3b854fe0c3936e4b394231913324e559a1322fa533e55c7a42c879881cd22875477172852697023293c42f11d27f17bfd3acdc9e69c5b00e993ce38c1b13f2aaf38bdd5f3c53831d4bd88caab83f4698112720e762db99aa93be638d65d61212f5384019e32abc128bf0d402ffa230132a144dfcc11af74eb1aeefad566cf894bd023d69a6e79200c76c9b6a36d31b0679cfaed25dea8a9f1a40d7178371199ad34698a2fab4111434ef10b63e0633d6b4151e21af66160905448b49f0d7b6eb3c778e276fda436a3b45ba73331fd19927ade84e682c1b6fea0d348fe9672ef38190483b2e968e44ab0220dd20b304b96bef4b16b7a579938479184e653026dfc0433f94bd331b50a9922fb9922bfa1f3e54c35389907e64b23f897fa41d2b74b3c58057d1d2c4d780738cd361d04cc363d4d8f5765fa46a24bef0ee93ef43d1670a530eac5f9ca5b191de0eb524b6eb6a2ea1bca2e48926417d436869527a387c6b52fefa11fd3eca90db37940326f5ac73c51feac3a7e605ff77595e743aa760f6579583db196ff42b448375cfab46612a7678722fec97ff229c9e1d86a11086bb7c2a7706497c40824acea98505022d6fc8bec048ebfd12b51ec7d3e6e8aaf2e270c4e23bf341c54a12c4faa83c2311acac551e70f0c25ff9b3b32f254277d1d142d3fc3e066e33664941fc38180e6dca2726eccc050f3b908e516a857832dfcd575cd6f489db3ba1421d34d9e38fbd7ea4a81577ccf34779f0fa908e87885fbb25b8035ed3d5bafd2283265473eb567f8ff29e54a741c11ddd4c3d1216ba9f69114177fd686e975f9a9d7b661b1dd19e7d66687c232f2dd6bc5bcca93069bfaf0fd46b8520146f61a1f50e4efae9b56110a7607b72a3aaf9966360e2493d739b7e70898aaf67e80e4e3df5c3c3905213249047b5e7dbd83a8f604496725460e17212c69c6abb61e3226bd8006c11f76c11fd4d3ca0c0e50aa5f38f3680e2022a28fad47e43ba82e797d593ba7b6e86109d8fe15c9f0817fcb9daa59e63c828a691413a796f83822bf284acaf4025a0a821217efa09c2a5a67ed5d305c9cfc4597869f181fe6998cb42fc82a68798cfaec1840c0164a70ad7652119c040c9949f62f7c2de72bbe2790629fc785bf27e0dd08bf2bb956f6fef2d2b6d31e10f237e4c429fcbca50000e627141e1dcc2fdba7eddbfd9a1815f66cd48e7a97eb89dd543a88ae18aff54cdaef453978ac8dcc90f3132bde05b9ec3668d0bf77bf7f27fd6f5ec50a57f645c4696d8fc66628af2f4b2b30d26e62d91d0dbea8e11aa5bcac776df3ff2fbfc0150062dcf126c09554a6b8f6cfdeecb3638381cf54bdf8bea86fbdd5edc4604979460841aaa6a20257c8637ee1dd1e6603ca52b8531bbc76564953fbe34b44c7f2027c7388460b269f2466433682c3ec3cd5314bf6a6841c9a936270ab363303ac4f9b8748c42ccd54ee48fbdca8e249356e97891656ef4d6badffb5c89d9712d241dbb9b179b28404fba275edd3e0ca60632e1b4e27808808dd16777a20167fac9a0d6a01d9fe8851c1a73670d6f763ce30f4215ec27419ba301270fbfc7d569d0fcce697dade5e06a9eb153e42770563bcf96de16fb1f123475c4736356a8798c75aca295faf65120ea649b44004df51b075acbe4e6dfde3be95be6bd298a858f09d48bc8b5b59964e5a3240e14ac3e3ab1d2a6fbba7a34ecfd6c554d07ed8cb07bba2d3848f6e45e04771b0de2fb67361c6a29ec27a644a95137df4491b1154085e7d84f0ed17668a08e9aa8218b75198e828d04ebfd3de2a8637cf7ec5b8fe922d967f0e6d7521098a80708ca08c32225653f5e4ed75d90957f4482092bc3a109c63c5bc989ad399177541d98ceba0338fe7a8df35326a07330f2f2e17b7bb6ef8fa6d9444a274cd1143863dc297f49efb8eefbbc92c1e586999423527accb39a7c51a42c37c36980b10dc6a5c01b1a0cb2e2674ed1da479eb4be6c1e4ca7b46764995ae8b1dc42c7477dcf4e04ce8a4ea957d0884b76f7791808a1e172a3935cc4f22387cbd66ba7e418088eecd62dfcb15fb3fe26b2c81b4b9844c77a005ba3af918f2a2fd627adfe5bc106e97a27f6bfbc1814d90bb42d2ca0d16f55065339a171f291d0bb6941956a5cc4788d1861d21ce6a8e5b58acdce8a735e79c4a6a99c69d87980b4a7b309d9495f6b1e4503290a66b99c5a376ccd5e20860f2cb1eace6c43523371805928c404652b7dce3c4d884647acf3d88e4aa7676d24937a5b5d73a9f6c227bc41313614d3a751fd33de2a52e3743f8b4e92b8f7d6185a20f89f55403e8e138a42533a4ceae6e77d319b261eae6f764fce4593b502b12405ab24233f4bb859f8a21c1a05cd069c0f1885bd045646b0792d829997ceacf359dfa55c5327b798635acf9feeda4b700eae5a3dcb61eba2c2e1247a1f7eef367aeb01e463832688213faeae662f58547e6a7f5253a397222e879f9fd15687cd95f95a1ac8fcc4b2c07208fb38c6aaab4c268661f1f69d2969d446133446c92527b241ab2e140cabb93c126cbdd43701eea46a83a588b61892e7a57d9f06c79504c81f36ff46cf1396d0e0a7aace5e69cfdd1fe9095eecc33b11a1434fca31dcf9bb2438491c56abea25cd2947ee166353e78932d42b492afa0b2acbe5350d3afcec626d56804479ceace913cbf03df5a7cc12fa7a7846376f9e68967c24797672578162cab11c3a3a4f582ef22a586a929f154aa8729fe758f9cf7312b151f624095a15fad30831dbfc183a6c0589492348d2f8bc1bdfc40a0d753c1c997ae50dd898ba3bd925833f7507c6512ea0ece1bd7ed6016b585e342f1f10aa280ef7f4edfe5b5d77e8563a308b33325f52e8e7b7e450230d0bff8dc71703b4d291ab062efead0c62057df2280fcd567e8c376ad35d9bd9598f8026f7bcdbcb390971673d5131a63edb45fc6362f6a1ee7fa3d8be7584219edca947a3ce24a77d27d4186becbcb855649dd09e64913f91b74ce542bbfcb35f9ab2898ace9028ab0ad0ba1bbd1458bf98c94df724d65cbe81a49388284bd6b238b6117999a11cfdfcd7d2d2e5778f63211de66cad361eb49026b99e13bca970a27c5c2c8ce7538ce4cefd919453c33b45bfc16c0db6e3704de72b0bb2da9d767e9bd8b56a8886a9898baa572a8649c9f75be31f1f55fd47a961fd6fb11fd5f7ecb288ecfbd73e53d771ada4758c2a80c3035cf4c370c060c9e5171fbfc15ddc1fe5e77d898c4958ae2e0c306203f5c2309c9110b8811d03dd369548fb22288ef43cb406923e64bc36da34a3c68455c4c6a7d565976bcbafc00c12c600d2f077846518e733537653dc575d9a5f2618f4bc4d98aa2efca5959e114913aa716d38448337c93123a617a0a7e79b17d81e53671f487fd2ca6f86584404cce797f0dd7ae9e4315e576e179ff0be2226f5054037952340b0b3638ad6d7d57a4e91bc1e0afd9cace3bb3272fb752b0ebb3ceb69db5b25e1f4832cfb924a53efdee20b088a0d2da0689979781abff0f22a7dafeaca878a38926104ada3be5af3e333ed111913e3449ca2f6d0583ecdb8f00d10f1f92f65caa557f074b976a094541288821e4c2e57d2359c1a658ee39b39b58999f90f30d4e657c748d7c77e58b6dd178381579160ce4a7dbf7ad04863417ba7810919ac9ea6373552bc2098ed696d7d15c4264f81c6a4412f8f43e0601a147051ee62a8f3148ff84ebabb8149a5f019545eeae671523fcb0ae81f2544eb9fa199a677a44d1cf93efedd63515c469b8ff8faf62d0c675e882ccb6cc4c1e2c0a369e11657768d0778c4e0e42fd92ee2f9be4f0797e7d5330b51d5597741ffe888d079a7e16d6d78909b677ae270652c9ca2a97d94b865d3e719209f07e19f5c984860b670c85a1e6d2ee435a97156334db5260c4115f2272630d06d33d6530a434e3c9d6068ab42b2ae122283be195d162dedaff9e22c4a252745e8cda5226517488cfbf134a425835cc3545f0fe34f657931fc1a6108f9a00e3f384f204a03ab68fc55c12b9ca35faffceaa212a86d02edb3810bad35b9044d50fc11cbc6e825db3ea45914fc22405b7c777d46dd129d6a360d1c178c0778aeaa204eb697053dc81c17d6b87090097723245f237eb53947688200c08c4a42af3af90fd5eea3efe1fa28e201e351cebcd41924bb4a1692edde1b099ee944ef3e6e09f271a59a249262524e25cb77bca6591b1c923691e5b2491a9f1b38b98e3ed4bf05a715199acbedbb571967fd1937664c7c7ada5b17d89f6293cafc20acbe43599448870f509943e5a6f8069a0e286b7ed2485cc8d868bfb9e2081c71a70b5cf96984a3f009bf5977bc2e72ef0b8141ae76cab430bb42f69b47e68d2ab0b6ed4b90fb51d5482e17b1fe979f97d4b2399675b5e949c29f85fe7ae4307d58ce812ef95a1b40f45f33b4295f8819854238ac77c438ba6d794e3771de6f7ab96bbd19b510ffc5a580c882cf53cd5574e5e2c50e09205e690f3f60c7ee0de21204606e3cfa73c9a3c6e0cbbf6e28166e60f480a91c465f3a5db1bff9f056b7440331613d4a05b3d37440d80c7c7abbd61ef00c4d4472294e814bf282d0d10cd30385af69f59237b27ef0ab927787cdc6dcdd0232db854d09dc9cd2e634b744835d12f6370d7ada93dd81e03c45a4682efc13fb8efae3370d3f20af12c9839b01df3ce6f8ea2c120e745d647627139074cc9e55b9187da3aa4c785d33ac162802248d7bad45beba706e9c3145afdf5a4e26421c359d587a957ce393be9d7f6715eef428e54d0cd9fb522dbadef166134f42b5c6e1c3874746d6df53a37337c7aa4b09f8cd77cb96963e5978fec1d816a7d775622508149ae1a9df8a3ddca4cdf61c06b03c4beae91ca41568a1f148b5f2defa4613c4490c7666f911472b5b699bf7c048106834741df75a25af87880efc1fe4a1258bd3a6818b844cedabd4faf395018fcd8d3f00033e20f0e1978ae577da8348f9589fade62a061fd0027afc6904d07598ca719d81617b08faa36449c502cdc6a086ae242ce72d69001a9744eed2bda13ede3cd284eae60572bd8fe6e8f53c8d36710b8b5c8da6b46ede4ae3645507af2abfc38c034c25395106dfaedc32a46148d328214d8631d5fa1a98652472ad3889f4baea43868c27b21bf0dd4af9c0706c12697c62db8635a57c5c8853e44c2b293ee409a92fab8abf14ccafccfdd3bfeccda9a02dc74cdb228d5a24be205581ed9e1a203a227f141df8c578d62a1d35b2b28c454f667b58182d7ec584668b62fe5fe3596a90d022913655aec4f985037f56ed798acecf07174a84442784f2cb63e9fbf3abe316f320852cde5b1635b47f3564f0b2d172966079391245a7ba8d7eba5499ef0d5a90ffbc92d84412e4a34f7abfbff690aa49f86c2045e4de41bab1510cb16dc71dc8b899e7ea675e827d72dfa402998d85afae03580984727610265d00ac7d2bce577dc94fc7a73cb1d1b38e9198f25fed24291d170e04bf0c9080394933c24840022b34b6499ab0be3e886aa82bce0b37166b78246b736dad8f3548557f72864233125465c3fdff3b3cf9d6a3da988accbd94e54fedc2ad76eed306a7995d43b9022b5e45045be18bcdb4246deac1f47fb97457a3e4fc3238688235b095bb47af115d84b0bb4f9619259a7939f7c306d1a2cfa01d28daa5bf0d173005c27ed50c847a0ae6b2e8a57365b5d188303581ff3e535dd3523200572d376dc488ab1c9296f250767c4f88278aa0d4d387c48e074bae5a9ba6edc2d24d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
