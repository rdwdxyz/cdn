<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60610954402d1fcb402c33c1eec714863c70207d4d3c3249ef3a6e234404bfaf7a6208e50acb8ec78f6a008111c6ca392ee6fa03f0a0f5e52fe9f699ef46551a8ef4b979ae9924d0bdf07b2965bc4cd19180f232ab630484dc5dd0637b80b9b2ffbf9470394e9654de913bcde8ab8cf8db6e879d017db37197f784ff3b681e6f594bee43458f5e1111788ad1af770bed7e2c003629f40320bf43310693e45f1357592303ca1d47cb6673c3895128acd3fc91de662c41403c9765a74e6e7bcd7398a100121c702b19e426da16cb3692ac80ee7ce0cf2de0ee3d26f44cda0129ae4d7a294c97f9937da18e54e9d32445d79fe43921c9e71749d522de148aee67433734ff2ae68a381419bf46468c276c69820f8b182aaec606233c53df6e55c21722bc60875f0a1ae37351bac3f6766a76a6d542b906a5bf5252b84136fc2e6d8ed1ce612972a0ed28da6e900c11e978ab814556d5d3f6b303442ae87588b0c1d1f71a625830dac44c61f193175692d48d7d8e1336b678f9c081d5933d9ac2a31dc9c6ae7ff0a7c5f60d56b2b6ba9402c6f4419da4baabecb372cac076ec435f3227c4bea787b5d7a656586d903e04eecbe21fa0a620c8c74dc00566f020634a9d0260227f086073fcb337980c8aac3db1b6c9386a9126eb52915968f7c2bc065d14a3aa1df0f2b680eaf73a7c3c5145ed8e838680d1fdc60941577aca6195192e914d3b60dc831c84f92e2a7a2239b908e5b4b4b41b17f9154a22da4486ecb7e6e1f2ab769c29ee5660ef965c912f73ff91632374c3bd013a19051d8e208203be142e98d5247a2a80aa54a42b7cce4662b866e8d2248700908eb399717e9308ea85ac7d2ae37f10e649ed4ae35b9ef47dbc11b6b198e9e69e5a2714bba38343451df3c556dec9a236db82e930947f0b3dc3f52c10e3e715e0cb71fe921243deddd2d9d55cec8992bdc8a7db4f388c9bbead6f5cf43b23412a4aa9cedf348336cc78b2a31e92132830789aa944dba6c6ef65a58dedce24f21b8067c065b96296cbb0b95b896458561ddc97656c6484a41018b9856200e945efdd22799c338b9c57d103b4d22e899743290a47424aca3d40719e429c3785f91dda0b7961529be3a3711dcf33adc00cc58ac518a82ee962bf27239a3d75ea7fb228fdba4084c1a73cd1678fb7a582e33887ea4d8bd0b02a330ee04173d6c26e9f8878941d8e8b146dac30a4f12421a2e5a884330f41faec3b62ab7e3743317fbc6dc01abe4efadb7ddab23f3f3b0bd9e98af9ffc15c78647ce37d7238bf286341dfeac392c47bed651efc881ba4db82f9f18bf04e7edb51116ca602a6304bd95a82895b0917d151863c2d42fa376ac4ae1e72b6c5e3142aa82286ab8fb3388c06d951f118a10dce872c356ece80e132fee62100d07dc9875ada6e8f48f4d63856465eda1e7a9ba93e05ab54a23b503109c4ab92f700072631e37d71eebfa90bd35d522160209bbe5950a99634568609b76590b6873384f4e52081d41592d0fd42b5b03deeb4c352cc911154a837c6162350e38401379b59e5fca882f6110d19b54a57fdfc6ee75be067e668994b98cfe33049914037f4de9c37f6564a3bab6d430fa7adabf8bc957bd13fd2054d57294174da1a4a132b95b182ca72d9c80b29cf4e5df91b7cb15c78a9d3a40b7023008d8eab185381071248d257b37df40a9d844e5208f982571f22523fcb988e96d62a076ebd367a09e841b188ab56670dcaa4fa3a974f0480c173c2bf4d83b9ba69519959852a3b73ef1be10afc19f71a706107b67cb52e203c3cde16efaa70173612a3283977ef05df1291a7898bebfde3c709d98081071491192d49efb2bff7000067953cb887aeb01aefaecee8942f20fa45bc1495ab080e2cd3d775ce34f8e9bee1772e07e4a336351528576479fcb895bc485c188ee5fd082bdc841307e57472c89a826e4ddf4fb31b3e3626a8e3fecb9869a839ec388b41540c7645a3245693cb3a1ea4c34efe201955a61dd2b82b6f4c1d00b184a845a6b6c43feae2aaf891af5a7da496ed4aa5d92f09a14720882e245848e3f1d989e8940e35513586dec303cf031f903fabff7501bc0b2398fb92c7ffe020f3beb65aff0b8518bf0f1696e52b3a7a8f7e97f4369021f1d6375db58f43f158b6ac4107eb320dabd4a65f9db60803bbb3f2d2818284c0d17df1f4de429e12b0288efb0b5b123cfbb2cd66d7f72c0e9aec211ca25e5856dfd107fe651baa6566a02b140f6c56a3b59207a5be740c7693dd9cadd5340d9ff177eb5f912336268c177fd73d59f183dabd239c50bbcea7e4b84cf6010965ee4b43539f32739b3a9ef96cbbbfffd485b85a632244296d9ecdba8507923e8dc7b396981a788de677aaac863f93df6433f67100b66ecd9850b95ec9c864eb738029f151cd816612dbdfed3de7ccc848d05616b24a672f34bdb896bb073a713c27d7c620c9b705272fba7e952274c068074996eb968cdab1fc4c545416877e3f943f2d75c13e673254c6beca3b04eac143e57bf3fd9ffaf892a6c24208a01955c6c9449213ce3474f1e9066ef247e6741008a41d5f2e167d4e309f7a4df6310e2672c143d470ef1c54a469592e36bb9614e922eac7a43162b547fa22a28ce705436e88743dc846d711a1b9d3deec957792f13bf5f26d2fa005819108f62d105d895973abba4d29e49a8bc49bb7a43608fd890266e9521ba4b5f75036498dfc84b2c24f6923e3545d9b643c9f207165599cdd0a1ce1d12cf1977d57e421fd4a769e67450657d9724bb8007adf6efc2549367187449fa74f758dfe86f9547e977716b7fb35cd56b98588f28b9a6ec5d23af1283f8d8a35efec27573c8889971620118270c487b01b7a856cb2b52fb97661157daa80c049cde18d82ec9295b096d2d1c928e7edff92b090b37d6aca257c920c37f8c810bded10fe5c2af6bd8cfe0728206db5b8cc8d3ea3e9a41cc6c1b463411893450af7b931081c27cee4647ab7b1bacd1a58418b521529864f1452da7eed559402c83aed555019013fd1d954101e3c22f98719806f4719efc9f8d109c9e08b31e0d72f73ee0d1b9248b2d83990a0e963bce03ce4f5c886430413c3dbbe63decb49ac3b2ad0d3d08d78e8478afa447cff9f4731aeb17f8eef15d637d3ad9c0d48e9dadbd0043a4f65bd84233118d0489717a66b282d8d4ee082a7c720b8c802cb8703228fc51be3adefc88b9e17a23d38907eeb701c4054fb818390af7d22fce05035c11b8bbebd89d2adb7979307b1d451180bca1c416f2827e25b6695267788a3e926e1962bfc285a7eabda4e48268789ccfa796f96397521028628ba894a97a0c725ad643343e5a7a22cab56fb0ff8bcf4a14649e1f32cabc53666dceb18792cc23e7866d001742bca23f6f45daaeb3b7efef9c38111ef461fd73c801eec0ec8497969d5d3cb6e118a1857997de43a600de13a6a9d8b648e94b74008a096ff3b1bffd8b76f9ebbcfc2a09500cc2b18eef9049edf7171ad099a67bfe36a6e65c9efb0be61efd84976a20490ad1c0ce6bf5b6e722e9c643d7a40c2ed69ec5fe361e7239cac61443e561bb95832cd4f3a08d8743da1b21c3da9521128a393e227f2944b962b566cc3c2365d22ffa1800d0d52be0da158695487d49542b8ac41ca14ac97f67954cba60ccde744903134aeb85a30c29853669c76795538feb5c58658d52f19728e9aebf54c7e262c11de49bde766b8f00184b00dba5bdecabf959c5e67b71efbc108d5cb06d43701e101b9107d9668e40a90370ad67769c26ecdfef65f44f60b01343bd6a412dc2218756d83a57f892a8dbbaf025954e63e256f0a991b2309d9fba5478f14a5260ddf7f58e88207d85e34a036c95c0d76019508d264cfd2574f20925eca2919bad1079e53ef42008246f6cbf90b380af62f7f90622cdbe019576da2d378948b7beb7bd36810119908b905a52efe6678ee07c595b15789be33eab06486eb6386afc2b8d6d31d14ee0f1a423c3f8d4ed64b9bea54aa873d1f6afb8a181daa71a2bd99a3d61d8103450698b802b47cee72ba94a128e00b1758855b54a5185456eb613c81a8fb3d43258d30f46aa0af25eb0e1f9f5a6154df97572edf5c4bcfa49bf938e11612c533aa578ceeef67152e12a88e8fda7fe09b7c3ca17829d2b21ef6db0f672a833008b8157aa70b60015c0365d85504f0b26c14411070619507c086011af03652b7af71e4a48887dcc884265742c2d3e367207fe650f2318a3f7d24a55173e3e084ec2ae591283bee0185d3f595b43a2146599d13ad3efa4297dab17a7cc342650931f107ea9d5e7191ee0a47ccac2f464e30398d34f21bfe9e924c1d5a671668c3712fe885eb4042c5cd904213502cb8a5259ce03fb81419e09835db358666be8c5f6983b36e1982523fa97e9d15493dd8189442520a9e5d4653d37d557647f6c982884b1c0e690584d8676eb27245114ed50aac1cee8d31aec7b0cca7ad17e4a04141b3cb46fb7ed204d1f83dbbe8a80baa61552c327a5977f8fbacfa13bf77f726df4bce7a2dde5d6a91e10c8b1784cfcd8d834c7a714206476942eab22b8d13141dce463dff6311fb3d2d8dae67f9c12e9240de2b5bfee55408dad86dda6ce7e9d3dd115073c6fef56a8e398c3b1735397fe4c2d32f4b3c7d680baff6554ef1088d3cc507cebaa186985610d01d41f864d95384e6d6071ff99bf055b491bfcb20ecc6bc397985fd9e997fbbe1f3838f94058ab29394c6d7c1aac2a61ccf1c2ca13716eae1c0b61ce8b9973d360b2f4d8cf0e97ba30149e9c775de5b10403ea8f1509ccbe4c9e5d9a8fba45e7aff776d19e21e60d3693763c6d97fe73fe5a748d812a0c5434c097cd5689c7697c39c00491e05354a37d22a8c8be3b4d18782f513f3bdfe599da11c91765b102dd5f0e9615d4367c3253adcaf96974cd89d857cf3226ab7bb0cfc2c668d11c7cdfeb79f1f6042a8e563e9e288280f447e0cd0c4c4b7c860d8f7b030ddd19d93ee51ace0fbfc53b5e312976f562c07ab64308c5aa6ec1cc56e32a428ad2bc6a9e64c539439c044a2df4ce3cd9160d5e85f6c2f0d5ec9db131ccda307003373fff350c232a49f6c67a7d68320e8fa33c33968e7b3ed5bfeb042f773a3cbb4986b15cb00e8e7dcff37f66aa15edd6e6316e55fbd9d1730dd83c896d6e6b197ecd944a8a74df83f5db0cd390fa34e86ebffe94daab4ca592ed75ecb28de2815aa6781ace01ff2a01a2f9704bee9eee38e70ec8526fc96728a3304ad8a05a8a9fb29ac84a0990edfe5a9512af6ae01b0458a023636f9c8ed3399559cb3dd77da371927f440e1e80f06ff50eb2fe07ed991de7589c43f47db496f217459f806339c7cfa67f44f45a778398f5a2a098d71091aa34c12ad870819d903164792fa6f8b1c36e9def9ec1e0f35f4f42f5a339da423a41cd5a51f51a1abc7d1d3fa96c8f11bc6fb9ea958ca310805266a7407d234117855aa5b3f81d004fa18ee11c26741837cf1ad9cb51ed25a7db4be8b19aa33a38b91b9925ac640b0bd1a000af2212faff5d0ca239d1074a3e2296e1e15ef1b460a930e0f3570a69ed464333d64f1aee2491f4e6c3ad1c46a6ff0aaa913f37775702fc5a723182a480914047cc398b39b2611f46de831f8b7cbf1245e8e4694aa5275c8dbe791a4996804f93daa819074b6bb365169c30038bd9742e63e763c0f8cd0aafbc47a9319f7b8df75ef43418661fd979fd49a0c12a5d9bcdaa1ec999c4806b4bf4982099694976beb85b2f5aeab70f80a43c46f9fbdabe4e9cc1fbd0d79eb1ce9ada7d553c62d719b1e95e320625c5b3c9c25b5f1545a327eabd2890485942fb7be6d9a4e45603896f956f9d43a2a4e4d5c71a63f198516a7180de8097790d069d2bdeb5743d5bebebf3a5dfbc7c9b8110d90623ebd4daf311dc4b352387c48ff4432452b887517e1cb733beb7bcfb4f005cdef05ab2895bc8d525d30d8e319c41646d2d6c726948f9ddb1532ebfcf1231315687f486521a127fc620818aefb7c7edf26b068a7b76105c3e87e26dd7e7dbc2fba07cdc0260ca3e41564daefd296248e654a06e8c0db0f38209080380d6f075df0d4ff04f6e60718571bf09827f2d9448c7cb24ca6fe591f11be65aed8c790f96565a0645f91c7b33cede9fec429ecf966f5766359e14c6629c129682c9896ff4fec94e25de5c253754083440ac5c071f9686a38096456d7fd7bbc8404b066ff31b024cf74bbc1043ef48dc5229dd762a55d03b310b6c19e626f9081935aba53cde4d8653cd11586e65977ef2ffda34ca8fad7e475bddadcc0d5c90f3d7220460fda7a230e6e14d29bd8eb37861af30cb2684efb0092901ad2211a0723effd4b610d0d244e6cde3aab33bf5af53f3e81e37aad38695325095e74a6820df2f7ef41f7f666d41b1fa63ac95602cf09842c83a3373aa17c1b77c7237db28f588a150ec018a0eadc4ac9119c621d28a317cabea59a04fd86e7e418922cbfa4d574a1e8a34a998cbb057136ab51e6a75e112f9e95bd4e015927b03ffe9951fdead64504a0553fec037796383e5d1d2684d9d327611ff06f471460ae8e3de27b8bfc20040ba8de998c906d3902839d63d0f89088eadf6cccda7cff08d63f000e0db472935b384c876320a91ee66da3007af0b1951234690fe1689a687dd0baefb9cf0ce2c93469c6cdf816d751d5cf3099be4b453361be8fd53127f419f656c7f8c42082c80ef42b6bb0f735ba0fb573b9a636a8def8e346059ea73066b8732706f19c8f9eabe2bf32a1f9b2ca19e197583b4fc75d276e252386034c0c727282e075442c416e0be736b3e11239b2a5ac16495f198b4006a97c46057e4d5ea6a8adeb1191dd45d35d1ab5ce6f20323dee4b4125323be451bb3d36dcd5fd512dab3f0e0a921e0ffd67211b17bc3978de2a550e87a563050d85f9c0c41d19a56d28eeac66b55931dedd678dfa4bef29f5ed947d94d279bfd508cbe0039ad6202f5bf49b44b900a6fdc65e3ec87be01a59c0d436a4e249c1d0d23564ebf4d9201c2f1234a005e1569139b21e448106e603336a3ce0cb319c06b15c6af56aa615d51c04fd023fb49db0f961064a1d8d6fbbd11e2b0ade34e169c1a3edc8ac60d22fcdda86ab26ac8a9b33a3187d6eae5df43c1f82389005d24bdb338f3b8766bd96de0e9200ae13025d763ef735818dcf84c96882d5e254d2964f0e8437f026edbe12fb8503140203c8a23a4b6ea3745d9f5cc5b780b7322afaa5ec5bfb5c20982a9f6bb359c164f9055231ca2528f59bbd09a5af7387f0f0420fae04e301b7f1e23e957cc83de6d6c5a1933decfae59d9cfe2569a70b14d9a07a6aa11ff32661df760390805c8a32ae0f04a8191e57285f14c011f1feb79518ce9ce17e1b56779f560eb7bacdefe30dc3f29894bdc12c40db174da029d01ab5482f7243213dc8aacce8129db518a031a47eec444cde4bb0198c1d987a1ad79962835a52a2f8a36d75ee663b6754914564120fd45368070324ba5e44a773930a09a26f4e3ee478c39b95d6435a153fcb543d189addc44e2e0091acb3ecbff8b78f600081e9aefa39286ac32a39c2c0e3ec0fcfbb7f06ff349faed71a5f2e182d77f01a43fd7097a991e74188858766e586c0354a15aa8cea9c8af4279e66c43079803a494f722aeb7eba192b5b299dd6569cbb6721408478540663e7fcda362812642da5608ed9b8f23358b1c5ab1131f396ef853fa3696a2a9ae9871ab8da7b4bbd4e59eb42991ae55567104e9794e69106657fe6cc66e5c5062b512f2d030e85ca8b5d21dc83b0b4c254a146d52f718da9181a2b19d5788295b68c1de92c0358ddb022cad35b26b86b559b33bef9486ead996c423b04369fe259ab7b5d0edcb5800c165e4a5e4cca3b8adc5e25b23763ed945b022a96c8a8024c71019160017d3df20c3b972a344989d889e349b4c0966b83c8a1b3e2a0ddc9db06a2e3ed7e9d0aa73ca1df14d971e681433118117560c5cec0a5c54b97dfa076a2a1de0dbba9d75534ff90ad7cdc14e8962e82aef18e388ac00d722e431e87ede77f4f5de0b4be82ddeb13d226dcb661e3ce73e53d0f05e24205ce13a7533a66f9e59a007586c24e9ef30e9f480bed0a96f6e0ba396c004dec91f1a47c5b6e665d69680ec43ff7f494b81499dbe530be4589440bb027d650022e94d3912bb4d9fdbf6a5bcd1ab7f2f5da93247e1c95b556baabdec46ca2a9aed0a6c4b1ac1c8426f66fd6182a25ca7111209b21624502d6fa5ad3b45403530f1e4c768db3b168f8957c8a29ae7d5e95b8ec80c49630108e2f6a89416400cc5a227667c5a94cf8dd58fddeaf1b9d69b29cc621cba4a20ec99f789c1e02146fef9b815b6300d3eaca7151ce47d448742f86a50b6626b91904991aa43f86de17c3a86bd3c1f2ff2fc2536bfbc8ebbcab4cc3c60be1310c4542554547cedb2212de18549100fb070bdae435865489aaf20a1cc30af4479b62868d1ae96a987b3e36637256998cb2f8aff0a3e041cb16559ec03e5c19d9627d593ca9afeec3e143d4bd6e56ae6a0e8cd7755c228dafaa907e526fb03eaff3210dde97eece38cd456de984180e1c65f55987348023065edda7c9c9fb3ae0cd89a198af0f02e786821d481dbda890c234acaff0f80fcbe96c62ee3ff74b7c35e63ceeb1b3af7e82118eaf4e4e815fd73ae7f650032c88238ea4876282f6c61cd51574398de940a7e0faa48f2d1dce68a198cc31b619aa47fd64ef35fa33cb79afb39cb2ea5fe733ed38975919102803889e89b544e7bcf12770262d05030b4139064bf935240cdbe5e8678e7eac5ed9575ab13cb9948b133dc002c4409f06cbf93ea1026533a4d632bb8ef8fd80b9c39832ac25dc834d7d22541ac856d6e14b297db94c8992598b8e789f6d8999678c578978d1112fe04e6412dec6fc16a12c9d2522983adca563539acfbbf2a45dc553209ef2686b648a8889460e1d6d5d6fa77adae88e0fc4cd0cbf3da4380fee577f94cd66dd60125967cf9a91c36e55fe5e2669535dd3401e00090eff6b75eaa4ca3405afe539fe30d656d2e77b236bacb22f0703967782771a4128d9a435ce8a4e85ea1c00eace214963a1d42079bad4441949e439608758c16673202bc8d3ad3e214e544b8b476b429cb8be72df9a2019cfa4eb792dba7155d4bb5c747f1cd90f3ce8018c67bfd23da77f83bd49cbdb08fdcabfd7c1b7116d2cfcd9fc4ed85bcb7dde2f8f4696a45af6b4b37c6054bd9ae1ebd161221b4d4767112d38d02663207763bb303071cc7cefa7a02c70850d404c81ecf91ffd6c9ef33570308ac58bce4f793a008a8396a08e9eee5866c3b2eef28bb0cf12e6a368a310a02ef9d47ce02e1974c466d9020b8286e7d534ab9cdc15427a21efe653484a260add02c3fd08acbde80269ed450b431b6f373dd640f799ec4688530cf4b28b9d27c946f1fb8c824fa9bfc663d6dba855760246338147055939f71d0c932e1a33b2b3dc3e110f66a70dcebaa09149be2a483e43b269e96b8b5df8dbe50531efc7319a022b23a63661587dad8254c67c3d59d7cdd977647aff03bbe360120a71818c4e38362130655b192a09e6aa2669e2e48a73eb1feba95e618bbe1afb8956ee37e5333f9857d62b41015e484f7cd873ca86c1b709689dd0090cb4731f96966c6ba449f0de09ed01b4050120dcd06680e20e5ba02c3fb93df78fb96cb465cdf2be0a15dc30f772cc038ced0bb78c2eb130ac238b10f71c7a308897b1a5cbce8a096cb4b588fc2df775a594f94388d713441a3928a4f31f8e02ea4ee6158620761f6fb4b5d94f01dfacac1dc4756a337355f03edf08410e6b149922ec6374a475252de3e782fdad08128a350333864e4eb7e7840576834561c18de433c1cfe7c922d7b91ef77adaadbf0b26a5483da38480faec92ac460af4f52af32c9e94cab939bf50e09f6d131064f1cbf12d9be583fb9417948204f6a698ded008bea957690fb543158e446ade6a0d3e9ce6f75c85c91d878821969d82045abcffe26cd53d56c2d1658acc16758bf42d67399cf1f0937a9a7ea25979e471f4fb9cf7f122b335dd7b2b75b8274be94f4e4a62f66aad892f64d1ca6205d73f32a4b1552cce162740ef29d19df8c4be92c7234dfb711672d27b5b429571626a9f16187f9b26e93d892f4994199fa7e5d76d6bb73c0c89d88c985b621ff20d0b1bc5480e27dcfdeaca11e7fe2a346be018ef59e221935f522a73463fc76f97b02ec5aca2b21284eb265c74ee4f747d40ab86539381a17cb388159e0342ad91bb4f12ce33a3869b5e4461b1d58c847a88fc5a2904ac1b2c0658c665c55a9bd63cc0a39f4fa38cba6e8bb5069890bcab34220112ba9775095a54ec018d6ef547dd2d4a42b40f8f655476ff967ed667c65c2592ffb715ba874110a71d2df260c9ddf3af572ffd4f673ea28b30f58c49c1eabc21034439a7ad76956acd9d74a00c25bcddc20a4d79b1f33efaecfaee0937d22cd05376ca892a296b685e804b8b94c5125a7f82c35a3de5151b2779323f443844d731e52100457b9b85bf80f0949d9b3e1fd13bc5d8c9bb7b636f1e0497d289ac1a98edd49a193e53d5fa6b3216bf985596483c09527bc30ff02177c253c5dedc142ec5545bb06391ac520fe262bcce6cb98d0bd0802611f9a96489490b974fd9b386f37e27e08bc6dbd74f179ae10b0b6439148e44f57d34f62673b52a45ac7d95f1b3fd28d5c6e5b16ef6ff1f3ec339bc4fa4f0c2ec36a8184a6ff292d6609b467cbb862eb8ad860e904598af196c67047c10e94e3ec560d2df3b940b012454e3d4b0c495c416a2a2cbf051f8a9d729561835e6e32870112cae01fc165192dd9a2102a0fa8640f6e51a50de5973f821a118d94b295c30083648b9282a94f9ed985adbcda2acaa2efd9bcde6e92596a8ca179926fafd018d956dcc6ba34bd493e907b3352be11778ec3be7ab18b90eda5c0a15b4da5a5304ece363a995dbff06c6bb290d7d37e2f8b9036def4ffc63fb26337ea1dae6d6552b761740fda4bbd658eef343991d6a6ecdb8b5244da31371ec26aa841598a58c503aefcef0fe67f41a9dab7a830e6569099389322dfd2065d4e2080853b56b51a3b4e84a087ad273797601dc6a83dc25838cd6193e76178e87eb3b1e21e8746c3c6083b4aaf3db7b23dd71def4b43f02d11030d1393758f88b14ad10611b7fc01fa6ad5f6d9747d2526df3a45cf918f9d93c1fff287ea8e8bed66a465e3b987b787ad80088466381719e2d56c5ceea4614c6f408564b04d80160ba1c672ca1d9b77197637390378229c9b68696b1d8b4bc4ff17c90cb35d86520f867aea495d241f6ffc4d1f6727df83f40783974c6359869d3faeeedb6da7628cece1cdddbc1912192af5ea9505a5979b90b1643a62c3473332d53ce4b9585b7681fb65ca9088dde369b2fa4122e001bf34854f0f0a7ac85d47266b033a6410d4a4a79e3c9e00f617787437100608114d5ae6b6cda5550b5a82cd3e43288d807c6ba8e61006584cea2b916484f629a607cd1f7d8f7dd29048f0a6b846fa2e2d681f1d2b04c9f08540e85a1a194ade92f97e18faf807ac86ccc2d9cd836cce3e490a3d1b169201bf4dffc14af9d230467b1c32619c9a7a8e999615b90d4099c7eac0978b6cb60003f688a37e0d9bd66c1eec134f79990b71dfda64c569e5e4dd73fc2ebd53fa2bf7b4f81fc71c8da5021b7ef1744906200b0726ff30c519c2b5af0360358abd79cd79466629a80aaa82eb6bca29f260f5f189f43eba05d672a605a3c80d0232994c6cea4f4e015da238cab6b1c65410d21ed322c4a08f41655a9c8f3b3d2a522d18f4284da77680db3168edc02000c0b5f455ec8bf65866d1d416082bab4ab2da16c8edb853ddbb29c1cd17094ead4dd99bdae65fefff8e989765fb13dbf9c2eae29cfb9624c08bb47ce0da6491c0db865084fe3a5be868ee9aab766128dd1083219ce1c8e9eb4800ff9a52ee5818aebdeb291252f486f547488106541de819b16f73a0135c362b22002bb4bf5ad0c698846e5bdb12159d6a1c323ce3f2863db47a08036e21842f48275612606f7fa7c58e2510748bf948c7ed8026023235c9821d6410d1b42fbcef47ce8c62260dd4d4aa08901c190709bafe13cf7f5e3003411e9386a0678dd450e5fe0eb93e8ac850e8792f3878924d3ccd155a5641b18cc4d10336d45212f5741808a17cd6198225799d57ba6aef92835ca532944f1f23afb3b632ac7564b618b8ff111447d9fec2326d1d5f10fca69b52f4f2969881d7856f942c21fbaf691db39905a2dea797b6e0ec8e1e357d7d7116d492ecfbe7d2df760f882306205dfc0576c2f94274b1b84e9ea6a6f5748bdcbb62267edd7f71e217dba6b53174acb56eb1abd2cd60f8224012fcad53186fdcdda64f20e1f40b62a82ad454ef3679971d3784b7fbf0caf278fb163b4a159196bd1d7afd5210aeed5283ecfdb4b740885b9557b6b052bf312f34b2623b28e9e2c61e69ec1d94988eb48ea72a813013de9d03566076acde79231459eac1743491757b0ee0ad0b3e8c3392cc60a7bb7bba40f098ce102b6f6a797d1f0940a119487481a67a10bc08ba9c1938894352bb41da22c41f42fc090e3a8dbe0585e13415e4a508311c576d0803d18a9ed984cf3e1c34a18821c5d73658bbb9dd3a80aa7c6cf757325921b07e42a091c3f36081fb723d30e520271dda7b9ee566a70de10331c928c2dc300f3f5fd859f4c1a59e66ea34c197ddc289062a34c6ba270ae1cee17e7a261ab3e05901c6380adc863268e6ed91d994283a378da88c19305edc697ea55d77888d719210ead9c0d1be1f5f7ac7813492b0fd96f86043a77402875550a19615cbc4008c01b4d9552308d0825410a7fad60531a4d8fbe34aa7f08470dad08c7707a6d480200b7e64c72c62a9bfec0816f0eefbf13439a72586b976b944b0f7863a517885e31f378f9a3c7437239fab4e78548e76cb0b3666f87a579e0a64e511501fd9b311ee182cd4e3451b308cf63020cdd63739bad2f0724dea0fb1f052eadb97f0b9e677c37bba80cf26c11503f0133732ad472962c72c51cd483a86f75ab6d5084d669039eb2d5d490e4fcdfede2082ac14f413854ade2eada1df1e14b8feab06164ee78a8ac30a03921ad1b5e34fb0a60841474ccff1ae64632f693fd619dd566c9502503a00537115855c5a4e6b52382675ef969a3f9c504243d97ed76affc1bd1755d65d864ebe797feb38e7e4dd7c5a474ca58c28e0233176b26050a976e3a01ad1f266e022c34fe3a71ff839f9430201a10d0f4b349b22665aced72e6db9ce858c0053061c154229c27e2756e977958c3252ffb2be9021e60903297e616327ce71b05811e98b056dffb20c17f7882ba570877a0f9d704893fd28706bc8aa3c8f3e27c598b40f3e11ddd6d0b83fe5066e2041dae4aa245841585e666ac165422adea67b55643e269dde9b71176fc8c3212f025c0aa08e7cb7de49314737ea7eaba538e0de55da389ba44f4dff7ccdb09113c958659a58bf056130f175122a7f3a98859371faa4ea8c720401df8c6ba43177f14b435740392368ac3ca1b8b5654158392582583e076877c3f728e4d7598bed09bf7672c6147b138b630130adba0e8ee883dc6669de3003552217a2d69d4912b22b052c5348deb7ed3f7ea4d9ea1b1f0c41667e26522fc8120afa56aec7473cb689f4acee91587910edc7d34f4824ed678c19338ec0b77ce1733e0a253a55e140e6c7720730a0148cad8b1b1e4bc94c04a7682200c5b4dea2184ca9d9edc3eb83b5b12bc3bbce2793c01561d677f4be96e63544847d18f788cdce64d2b9e9f302b6bfeee4e55a0730e01ba1cb384626cb7031fccc114e80f5345c1d45b8aaddf3ecafa1a498bd072496d881f2ecb40111dcab5d819b90997a4167f89ef0331b33408e1bfbb9aea33729434654dc4727ba0a3021965620bc49562c010b4489314bd43edc54016ae9706a470b16d63ba9928b32a453e2699d4fded3b79872cb58d5190437bb6fbd1ec03bbac287c218b7e2855ac5bf4dc70298e0aaa03bdfb50a4366eec3c078e80ded6522ededb188416f9dc79b690a36e82846a1de0d1f785bf06962414851e77dc4d0f7613e322042d699a0d48336911029c7569b241e53e4d5b567c132347df17afc1192755cab7e52947701f904234234b194cd6e3e42860be1085f71904c8d82423fe990ff04889f90d2dd18a3c953da5557d749e21f45b9b894a91f196688c2cfa03b89b3398c678f2376d230e64b13c63c0ae231152c1cc05a470028ab214b86553cda2a1c15a13a5a7af029494712758e13effd1bc4735b82ce83307c3e036aea6618d841b49d80cc3511eba746fece4bed881f27cff4255612067e5cfaafb7bc43b374ad2ab5cffea498e8b4c9f8379390041346654b58d180a321f8c8c023d68a190d27ec00d4a4bdbd53ea7678006e1d6315a0d83dac31646713b4711c7afc4ca4fee1dab9789ee3716cb3d30272b62898f36bda995b783c73c05da71b067d7777d6f027b614cdacf0a6bc2077390f20d0901207a2f34ae1b9c1bac6bdc5372fa7175c35c73e0970d91015323351272c1ea4bb0c91a4bcdd827629a45c58c56ecc13c4a3f382a5982e956804df2a2bb3397ea2896907c6f078100afa549c9b1f61533fb706622a1ec4f083c6f57c2a86d33807e2b231ac1198bd96e7513b1fa4019fd94c152ee1cddc6ab909c9311805decb2620fcaff3ca4d27d81863e782df0f94b41ca807d24349b888d4e7d629e0a847f7e89333f4c9abbc43b8e579775761e4ae12a65796a589ef7fcde72c32f8db7e45bbc8fff51e35e55e1d23425a7d2dbc9cdea459463342f3a7b5520bfb74c3c107bbab3cf083bae59183157ab5220e549e2ed327fece09ff11cb84341524bbe23f8d3f9bed78ab36df7ac800c08f72e14fff3a846f8ce194b38ccf0a115f0eeb6eaaf28593d8efb0887d75f60072d94aa4c862e5f0e87a8b63727eaaa0bd0f41a7ceae943ef127753a183fdfec8cba2db5a926ab5083b4515c97856fd356fc046fcee777078b168569ae3e0fa328be4cbeec05b3a8b17426e51ab6be27acb1cf8e0df1608dd7de7a5079b961d31fa9ba96b0067a92af07b836439ffde9104750448154bb070970af1a504f84455e97321436e2d07691ba04c517900d98cd2cb860b4f8c2fadf824aa0542776410af4e5860284c261cd63e909ee95921a1c7450de196ff0e2c17c8cf2ab7cd76657fb00423cc742df4946d62241c33b60207c155586d3e14432283bbb17dafc97bab11bde16ac55965ad41345a5e71a8818e9c4375bd970d239731e23401ca324ba83d36df9caf19a8c1a158319e15a7e5869fd0e3b83caf967c5f2f4f6a0397efa29352485d150be6096ad88f1c2dc2304241e7b8f2e08fd6885cf70d61fa8c85a7d6fb9f620ddc22274e2646f6195b69866e4c4097d94eea9ea5a7c7bd183321d50b479513a3954fa114ab4314f4e243bfdd680c0dd4d3221e457a5be085a21e091fdb11703171ececebf5dfe9c682d6a4df692016c4f666584391a01c112fffef8ceb04d62a54e65ce4425f2acb5451d9550940dff92495f0567070a0a386163a21b75ce06266ee458cbfb2681e055b4a393046a01a3e8933fd230a16ba74c9214820f0d49ce60d6d96f8dc0f746f5f8d2ebaef3c4dd0c83b5a2fbf9b7685afe61b9d8c40c7376f9f1ea3a3cc1d3ae183e033bad370187378002828ba0ec42f61414cf1a985c29254b2102fd093e7df9f6a9af071d6d758fc5aca90a74c1540657032fc0a07d9f0d9452dea74b2ec9f873e04615cff4b27ecb8ac4e2e745d594903eb21a5d2be2a4de5d40700ac99072ffc9ca414b1a3e2a41367145c33447f3edd7fad0b410f0fb99f744cafdcfce0ca0928316c553e60860f0cc428407b4edee58c3c8082b087921a4ca4f39d79d56a4f80f0293376f77a74f844aa3ba0b45a2c6a471ba4ebcff5b22d29da6e5be0cf9995bb08a432f8ddb53018a72a325a2f7ec9921ae0edcd3c7fb1524487237357c48acf0799473c3b61b425067019cdcdf46f6307570937da0d352741770406a49ef42db2e1d5c4a3935015f827bdee820a38f08cfcba283fbf1fb4f8ff7407665207259d8865cbf979d5e47663d89e94821dfa6ec9cf1346bf1611ca122c1981b717d5891681ff1a9f808a6330382b956308e4a0a74843c1b4bc9bb8b141372b63507f4ff745e3dd89647f1a799eb2693b8a5cf11eb686fb041b5abe4311ed77e10fab9040ffea050add664680d8809c63deabab7f188c8d0ee20ed46be91a9f4611ac61d52c0e2b2178be5e796b240243ceb76399ea3b48f0f40c3d3f0b27b606a6386637c21cdaa7281504faf7d16cff099da96a0fd3d2956b0b764ef5111f1ed26d46ab2e35fb6162222db65c2f6db197d45809e5a86f8f695f42275d06116ffcbe8f6ebcbf67440940e71b46c8d0089568958fd09b3ef63045269455cc0a37761ca3a957da4f2779e45a94576ad2da7c9e5e060ff714bd95c0f9a883276256ac221334ee2ff6fa56221869a32dadf81c60c0cf84def24638e136b082a96d1daa2c17dfa502a9d9225e3c321f8067de2bfba71e7322370d35bd349643f206115588f19611b72306a88eb2c6f36a544a3ee5aa5d462f8ddbc0b3f4923bdbacf6c94bb976a77b4e9581d6dcbe21f23367dd218feb635cb93595a70596431ba72c7d52508e194f52d7b33f002ea176ed8bb536e044287295cb5a1944acfd8da7f6423e056ef5ec74e8c3312a518212acdad399f65537ce28dc99376425c0b74274e2926b35b9974be33872f692c5a8ed7d81a79c193b8fc31cc61930748d958dd46c5f22ab116bb828fbaa474bc90dd875a231db4a3b14e95ad399dcf20c88a50406bbe740dcaf43a1d54351687df8e70339191b08e90503cf3d16a8796117c45f9c4ffc8b11a3f5677187369e41c2134c28c19fe416199b120f517476b162c7b13f49961c8aa74f714a4c3316dc6eebb33aef03b7e25441f2cc13d8c0e55c65724f3fd7453b43e584fdf8755fe5f452da5c96bb7096b20a2231bfc61f9b0d297f001d1ed3e114ecfcd6c0b83966f7f5acea94620b7c682c678d0943b3ec673d2817e6ff8692eb705d49d55da69d4948fdec515d04a443cb2cbca12b96cf4325a1bf500bc7eac246e9bd6ec48ed2ff5fe909a00c7698b4a83e2bc857b2c06163e27acd059085c99a04106e828a693ee47e61040a75e872833148cd69489ec12256a2d896d9473bd49959b63fd4389c90e3344ad24f9d9ff43bc454b977e47efa8a47d2b2ef41b9827b5edbcdb863a18ba7d92e1ce19dc3b74a9d4ff43b22bfe3d4f47eb3c7030da5e853cad68fd08604dbddced401fc2cceab209d854af6e30588a2800591124de89d4d25d237e39297eba447a94a82acdc87a2440e1f204df70db291cd6d6c6f8b7e9ae701bb4da5b465b34573497660915126489896cefc2574b84489a8d3d76f6ad6404ea5ed70176d9d04b6d21016fdae0ef554e6ffb455066aca5049c562ce4b9de3e25154019ee0a3f248b17753587a5c4e719da276585c2226e675cc8bdd1d82f0bb9a710b96fafb89a8bf8f435ecdccf9c3899ca6e72330e7ac3e899c641946a70be169cec75c492e36ca47d576605b2471fde7fd89c666279042bbaa9e6f2c730cade2d2a7cc614bd74a673e9dc489b2e26503ab532e32151364d7dcf32253f0a92f1aa11da8439e2739be92e3d474f7f5a3f7d446cd3465ef5ac4e115cd7d42514e8310700ff55a5a60b7324fc0f3efb9077d05600c05c7cc286f112585be64c5d3f13d1ee946123067fb6abe82905f50994c2f72dfd25d8ecc6f18878584916a18bf6c57bdc050105e05f6d667dcfcdcddaac8e69aada788ee028521f5dfd1ca9af8305bdb2d09dacea1113bc4a90b112d9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
