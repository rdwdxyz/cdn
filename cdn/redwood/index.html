<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26c8a7e0e89f3218c52b311a0aa91f7a3d41a2bc33c96369ebaf2c109d6020a8a4dd39a1307481b807d2ed8d2955d68d2d4067c89c6f6dd467e2ba6d1c0ed2ce4927cff519781f6a52c8c81e297dd11a9dce11772b6cded8c315a5d01af30bcc2ab58f4d5c6b961db70fbb48d6b6c88d905f8606c2a8932c2c3dd649a820dab679fc750d11fbd77e2418d9abb71e8ff5b6a356b16c275d2dc527760f1d7e98ec6c13db46d3e60076b2b21bee15ea2b06cf7818611e4fe4787add377f0b9bc755687bf7792ad380248f1fcb283363e44e486c5d889440390d0dc36ee5e14de620efa139851972dfbeb762f4accc2e3e2286c39175801b7db2b960f2a6549ad4252e1e9439468fe3fb8090bca7ef4b55171f2d26b913f0eaa666bc3bce5d8f5bc9b841c4b6d32bfbb4344a7b90ed06fb8e4c4ee7635434849f3dd1ab5a7bd079311aa8f09010ce8b15e109aa1350848668a0ad750474df130bb0dcbae69b89e0b22f822fdee60fc9d91dd74672fc17d3225a92ccd7d35745365cec4c1d239486a008411dccb8ff650dbf5955c4a1923d558bab8a2fa1d6aada6821fd8c8a72797a31efcb99cd5b089844ab3f135c9c167f1b82d1366728f415dc333d5d59619af4014fe46de73ff1abbeb957b001db5510f550acea932d042bdd57268b32ab5695ad74875b253e870198f513cb3ff8b4ea72d4eb09edb730777039be40089f90be31b3889b67337e04119bf7533a82ff97291d36262fcaabe9f258e2cb93a1a8c401e31c4dd8fff1b4f052d2e9802eae7df1f7f1eea32c476e71d94709fac1812c321a77aa83797be3fd8543dabaab7e02c950359c77fcebff5554775fe1d1a29e187974450b44e041f6633cf6bd32afe4e59951e9456e697338388a9bd07179d2f068f6624b1a78abe82e4293184b028e6fe3d3dbd5eb56f5e1bd61ea9671d31128ce32c0657e343e0ec44a756a8a023eec2899f9c72e9fa242eb7f100349910a747b9569e78d45854a58bf8ebab796b986529963e07c83c46775faff2213ca16fe0ad05b6a2db4eae4ced9d5b53cdefe5e90e5b19073495f0a9c6d3ebadd62dacfd0de01ef704529d98b92224e7640b08beab0a77f5b73b2903b7ca74241fe1d2a8e5255cc6a15f5a2969bb173fef6d6c274e140234da9d71aa259ea72e50e71a4c73b5c3111b698cdbefd555922c015af64ab9e3f5d8d715019d3f33e7745a66ae805f58b51abe16a9dea9828185a678361972d6fb6703681a58881c6797e11abdfd8f9ca1355924b9de54f943ad26255430bae4d18076ebe120ffbb3ebf1f911c1d141efe086dd6f29767bcdabddabfb2156b61e2855419887236773b55a8ab72bab920da58b9a2d674e21f4c5c4dc70f3b87614fce8276d47e0792b9cf22da52e8965e0adf3c3907c1974dc3dd1c621db50c31e3afa7e26ba937edc2b033f08f248fd06087892d3f906129f8a5a3439809beedd5a4e0bb23f4bebd1852f78817930af45dee09dd46536b96bbf50045889874662ac5404ac9c4d30475f67759b27a3cc4d70de640434026d1eeedd0052614a02502c19bb8b12f77cc03c43c938b3ba0d9ef9c716ee6bda30b050de086bf826e4c4f4f64e26a1978d67945d54f8a515c74447ba0a1da015aa4071ac05603a0337d246cc749ed387ae9e137068454acf776e3d7f9e6cdae2b94514eea21eefd9d10851b2fcb1c693ea13636496671fa999a0ff8f54a430e204f3a6d21b8cddd5e0a50896cba60f411aab5edf8b70630f640a42df07701a2e3b50cd419536bbfa0a9a94ae1f0c1d3e3e9650d360f86db066250b4a9e976edcb21b0e10bab83113ab29188879ac2468126f246c8a730f9db546825547f17cee12e8ee4a65bdeffac7f7f453347a39a50278f78b24e8d2418b5ede9b1eb8cd0615b8ac17b14282ab99fc1ccd67677f9ef56d119728c1222173943c0dd2bead27ac8af110183e51ff837379c68af084bb3ac5d1115522edde1e1b9cf4b052f1278c1f0d4a71106f2f2222c39986d9b79542b8303e19ace7fbd9c2f25ece0a5b7c466ac73496f64fdede475d4aad27513f41fdb37d6c41467fec16b0c3d54c0b4d567762f646d1b7b9cb8a56f2df2e3f8ac1072a0010a8f20389eb37b63518f00474d44335b5246c6b1d9e2e430f0a82b0cdcc5e66551eab620cea09a43bcb421800bf00d4c70d44c59a9e8937a23226f5c1c1a595706465a81a2724e3e1a791bac96f4632320e9af967420080beefafc61f2e134f8a72ec88bef46d6ac0278d8069ac4f7d1d9331e7f8263d1c3bd9e55b126f655e882076f96c66fc1ce117256da4afd8db9f3837fe8da9c11b8c4a669490089fe1649d60595edc9d35671a8d9d895899d7dc6f4b436fdd01bf6f191c361569d55771f53f888261f39186ce4b7de049c39fed230566f2029897edfba2fb0faa93e9c9d67f22be02bf02e802f556d56159d233c5538b5f408af8a542549bc2b7fe64009ec525ed2e4704446fa5b00202f88a4b74e24199cfdf1d0897b9f8e5470ce2eb0d117c2964d8077c7e22270ea41be9d4564c727d2fe03c849cfa9d389dca98e9aee509e0ef8933e46f9a02f589d27221e46b4dc81f80fe9cfbfc45953a449f553626cf9d508cd26d291a14bd3b4e57f239efa6532de2ac4f6c74b8a0683f665ccc8fd07e21b7a519eaeb4ff18d74427b692e53592de8534cbbc5791b5d05e35e2cb66085f11c480ff0f90da0214401d27eab2e570bf4d5e0ce357f3d912d8b7b73a5e782cb78d93da68c27ad9e6128978b642faab37adfbd2d4e284e0c3b7ff88c5ec1d37c9d942d208c9bcacb360eb419c8998636cbf34b49be36273a6445725a2c09c7126aa49e220df8ab2e90bc4ca95aa23508ade01749df63904413aac058a43c2c2bb948ec60b41153772054213a3bc3dd49bab9a2de6573d7065c83637763bfedf60d89ab6120dcec14861f8b0400fe9eff925ca72549d75974c232693bce4d13a0e82e2322a737a87e3d7f829ab7d44230c3c39daa129ed6e2fa1be4ae7c58d4547862c3889c5cb01eba0159463b86fc04b45b123100dddd8f4feb6f7c324c97be71b4351e062fc5340ce033cf7cf6855f0c77ae84d4135d75440f3fad5f4680d4192fddbf09a44bd83e17a318f8ca7b438b651f4effc2f0191f12159195b387c61c3781daae927caba16973ce93f01b3d2d263d5e685a5eb94ce919e425c210378171dc2b4d064c822b1e471e0a0788b4d4dc35da9d247a1eb6bb1234ed32ea2e5ff713db8e62417a1075f35108012feb087df86dcf3e747175f9b210869072e358e4c293075d5de532d1dc0a422c08d80f75071911119a0bf2204392ab3b74a05d24076ccd7eb5f62771aeef69d7b1cb762c5233a7851927ecb97570a4b2de639bfd1b833aaad0cd96567212e058e4e39b34daf6571389c2f5ba79d0d4c4d8774f954b225bbf984adea714a05639c268076e6a081e1294e87ea3d9750946fa6ca5577d1440f5ba785495ec501d516ceaac9715765e9f1be5be1be45a7c4f65bbc46a888c331a5d5a635c0d1b2659cbc792d5aeec06b01b6dfe9bc80e5d51a8a7950d8e27afe1196b19d42c6d239af68b92b6c7f3405083e61c86fdcdf0c501f5b48d144bab3ef76fad57edd862367d0bd551ed02b864db9cada6d1f44891d5ccedd2acc69ce2f4c6479c6f811446728c26fb88e72ab2af91e3254672ec5a75f1d92085c074ec645cab77d4122ff5a954bddb9ec6ae1041db99093348eba252689487e3113c751cb50098784aecf1164b4f25a986ddcb845be8a2c912f0cd728c46e677b171531d6a867bef1471d189548c2fac377bdfd1caff764401cffafe819630745e0d8ae67c97488750ed2408c0e66dcbd3efb29c053bef109ef69da9ae7875dd36843c6a90ea221a56841ffbe66214001a2e730cf5e3224a2aa05cbc571d4d92044ef0a8362db3d48455e0878d575d6d89e9da9b89ed9507955f84bb041cfd56324b4c1c0c7297f5916f9714bfdc1f054fe5a73fb7228bb1e4949f4ac4135aadc8be2f859642301a3cfc00394a3084508a3daa3869b320baba6c895e41875414d5a67645ea1dbfe4d3903c7ab03d8e92272a8f93abe6dc7bf0e2a06e3d9e67060fa99d528a11281bd6df7a52d4b5a9757c2aef7b8eb4a6a6919f7e1774164e51be87c9c96c825a95ccfcbebe278794df33cc00fcd93066d5e6be43b01a733a08d7728c8a6c8d096bcd751aa312afe2241f2fc3f05cfb953a60502d8a4d76cbdb988df659a49e02cefe4093e723e9e7507149a17fea5c1c69fa98ebd6973b1b0460955cc5551caf2ede3ebc3bff8e88d758918e948f180021ec92172a12bbb62d59e6b18da6ab2e7d673f3551939e7341b00491e9320867eb9e8c8a744389e8f5fb86c02f7a385a7445e59b80c7dee4a05d9e72221c5714f105cc93e14b283f8a4828fa1ff4dd045f2fe7e2ccb21d3f6313ef55f811cbebcba0e8693c50ea2a9de65952c993809db681d1751701db033d9ac4405f7d691c79ad485337577b6912db3c9b27c73436c3b6206c38f18f1f33aaf1f8ab7a7ddb4ac3876e5c4e69aff5ae4f474c69e6af1ab0123e5857c396e0f62aec82fd450892237feb9cb4b6205f886d0bf1bbf044ea69c58578bd5896ca8a443130bd45811c8c1bb148784af5547bf63020067de2308f3eb18d56e40c143ce617ae1d40204ee1ed6552fbd8ddc17f327a9a54e139daeac69a1df4166fb53862468bde968e9162891ec2e314f7cd4b9c6d59ac79f71441946d6025cd5bec52d06b01efddc51a8ef122f5796679d001f194e49a84dc533560d6d129453404893542df9816183564bd24c9e820bb24c4ba4abdbe62710163c3db74433f03870bb4909b2a5352df4efbd29fb171021b3dee6b74f9482704330dae34ce97d294dcbbcc92cd3d18ff017578af7fd8a1eb3576469b60a1831225049e94eeca7169d60482ff7ff00726db6737147692c0b4018fb0045eb794d1af6bfe81439f91ed6f3c042e49f50775985ad9f8a5b66f540ef71c299c663154a205dccc6a1054f17ed7490eec88a72ce7898a394911920e3d277733b84bce8229c3f8defc44d372c1ded56c822b24e53aaaf3831921492bd368d59acf4cc79e55e3174b7ad1298906afadfb9aab45e03e1cb5d7bf567939621a0b89e32da8c5ce5b665c1cc1ea70359cae440159c145602e907e6bab7ec70961abfd579924061a501cdd5acd8be49e3b46f826fb85599180ae6bc6f8f04a798a1606df8b57a6cda6c2d3fabee55d0decc2693838915732b88bebc3fc053889ba97c433d95cb7f00a59cae9d18fb73756c9e3017c5e9eeaaee48a91a27fb9c804258a4768f1bafe8419692c74a703d5dad2c10bc7507cc985caddb716d7d40318b7854b1aad748d8aa3d02d9d6a15ffdc1160f09e73009c0829ba7598529d65b3d87788c478cb31c0fb97caec845d4e0bffa4e3a885396dbc6abcb0f508ebd0dbc84732f6399269f6e8d8b4e71d8aa67573de142d6b8737b9960a8a8d434139f5872d67eef0966f9e1a323c89903ba1c9580096d2107a27d888d0134857c0660805d2523fdc3ca18f037dc3bdc43d4a8259301feee9045be9d12689a6a99d569dd20c2e197dd8bcc0e466407600f68d9d3f2ffa23b3e579e69b12d70be9f0bae61982ce9ddccdf36537f21ba9988e5dcb6f13d8988d1d86ce769ba16c3ea38a363b0322ad307b11e6a8e1eaabbbd8a1916e33deb1bd5a4c936867b2e9457e1b939ee585ae56ba6dbf9c6fbfb986ef58c1a0a54fde7239df953d42c50347fb0e921a64cf246b0edea41a1dc5e35795a3d6fb6271f17fec117a195f77e3f55a4f43a285e57308a251cdfc85e4cac59d3b1943eb3e4b2aaf6488b1b0aaf5d220b29373af4f0d542c074bfd2d2d6bf1e36e5c7b2a900f165835ae1190c7cfadacff821a8aecabc2930c4b1bde12a0eeeba45295825bec4112e88888b71e0bd7b60becd80d4e7fa65108760e2decd34777a908e0004836f3aafe49ebca80f93f0a9e74e9f4d9bb68b3753c8f4be960ab04e3bd40264779ffeeefa8b027fe48a01682e359d303035852c1d76a8b7dfd2d2f8496f766f9cca3177e98cc2a0794eb925b8fac886fd5cc01153b56a42c8fd5356241697e9839821c9ad4dcfbdae1e6d234b9f4ed120dfb8397fc4c917ca91a07ce7a1aaf1aeba76f51abaed15ef7296f465ac15cbb929a5b077bafb22611b0abe89b9f2c8d065bf41168927f2b580d5d8171e3d369f3d1799e51f8e498d6dd5550ff4f2a84c091491cbe6ac8ae22859135ccf5094907e752c789bc7b2dae5b6db01b2d7925cb16a234c4c5296d84af35bb3846c429613523d9c70e2ac93ef6a3c73989236f581acc361dcff72c5194c7d034796412cd40e84728d3eb854ed09cc3b3adcc558bfe8c8c2e852f07d204b121df410d9bb1f4b8eb2197acb40d40c9f20bfc3371a8e50f8b5ed24d917a77bc4d605c07ada30ffe5bf395b18410db8e4104a478a5bbca0f42598a1ef806faa30f7226ff8164ebd429e21f887cfefe6a503c9e049e8fab481f624f5a1c0112b2257d9bba350dfc515f74736e3e8785ba321f62f733c0f0de38bb3d5088b4e4b5dd192704b71a3a87ba64375e67488c7f678b5aa29c32a6da1185fb5031793abf093296d3ee62c4600adeff74a993c4b964261f922228d80902a485b69b5b0b6666ad6bc4d8955f1685c01bdbc456e14a6563135915a6862f36303a2ab206e048cfa05ab60bcea72282530f0b5fb13afd2d1730efeff95176c48a8d30689ca9f497bb7dfe2ea8fe601412cb1260e07fe5c3b38570f7bbb623ae119ce877abf5a3bcc8b7f48ba550a844cb466475b791609976d3a17ddd64b5635e862ab64cc550e0764cc085ea1b36549aaec88d7cbc28e81c3f6cdc5f5ad1d4f16553c8dbf8ae2b432ae61784204b343c2ff92f46fef07ba20fdedc7fdc1ac87facc0c62fb073078d9f20012fff9ddf4dd190aed5c341dd2a788ae2d4bdd25b32b2bf3eb8d3d0491bf9b59602fc73de8ec019d76b67f9c651eb1ada19888ddbf80102fce8b7babe97e384211ed6ddced19a7c22a7e8028c5c02dd7febb15d395c18454e2cc7141d63c3449f4fcdb289821631cdfc2517d9e8292ae5544faf922e2ea22cd9037f0d9ad68257359f1adf72f2b80c77f2830bd4b2fe3068e239269f3dd6902d05b50f4477d137cbbf4755fb90656633391371ac61e72350de15e1867c5b6ed3d5b67f9c2e3ad1c5068cfdc3ed7f5769bd5f9df4307b24e621704a7f84ff05bc8b31b922ecf4340e202ec2a7fd03d3652709b8af9c52cac08eb501c43d976610e54e5f15f73ea38d1e29c07f1642baa55c829862a321e6d1e5a19151f6d4c99988285b57d1888c0bb55436e86d1e2fa28947d3ca87d174094d3e0c88d24f0da76e237b47463f2ac9204ef57ed3e686117a1681d02a90f6d17a09488642690598c4ed444696aaa1f2484d1a7a1ea846ed25f017a9543c4bc88f6e666385ceb0b1c1e6e821f6b238e9627e5ab4c1433db97dfcea27987aa78e857ba1641f64181d1c0011b43eae9d19af8b150d9f6ef731ed691e4edcb9aa6dc99ff1a01936c329d4b472744ff314e18b6dc43bfe01cdd82b8181d4ce902a08358cb16cd98852c82640675b82b8cdd7a1e53c2112b1bc9198a05dedfd2e29b75b0d6802082777fe995cdfbcc7436eb3de85d4fc2dd0f39c74a08a60d7f1590470700fa559be9e78fb5c73ce08e7c4e05f6ca3f14732f8bd35bf827d30a0bd4aec25bc8831af6d40bb35855bfbd108a2a1f579233c6a62297550e3fec8559ed17e937089ded91188e11d4d26b4421f6acdb6b506717a2fe8069b1b04027e2fbf04122f5b357fe236398f6394acbb5f2b9f652cfbfc6bbf1743659477867500d789762c29b818b04bbdb453c465eb8620ee2ce47eef204dfcba0e5ae9746fc8980a3ab584ed2646b90a4e17beb0a32c3ed66792362998bc03f3e525f6cf653d0caf5630179f70257dbcf40f6b42aa4fd634bbc7fcb23afe11e4ce7b2482bfd1bc3e67ca7315d46770e5ec5bc6d27095f1d6821703393538127caf71479881825af78df9dbac37389afe81bf7896b3bca870ac4d169e3010c908a340605ba2a3de77d639dff77867186f6ca61699118e562c2d7d288690d35ad28f6ea4e3db8a184d67e138f63f82ba936faeae97ae904d1cea58eeb234f79422a6f46e219c0a7e65c5fa8677a8cbae08093da53b1964383afa53158ecced387a1410e6166d0cc2127d62258501257d1b5a2aebed01f77cb944eeb70de06f34718c5d4e3cfe98c374c22355df07aa1f49139324080b521999c6e311c932275e2b35166e592e81c333dee28b1cdffa2a2c41c983c5cbcbe25d035d1613409d8fb5031048dd049e73bb5fdb657934b392e7ff071259dde760d4170bf78a0dfce73a6b9075cb910193c40103d6e0d828b4b6dca393579b05e4e5721d0ae1fe8dc99adda0102b23ad47ebfc18a45678a8ef5f6e154537f16faedb01a1926f54659cae38954cf44a18045c12bf55f823ba2fb6423ef1c7db148bfb146df0e82433cb9ab86eebd034c8ecbf904765710a0e146c5ce213ab31f02f17d9985567fdd49ac468c7eae24b2e3a5cafc1df1e0598ce48e2c8cc3aa3b1abd1180a4bd21dfac10aadab833aa6b9dd970719e84512bf53192623c73773b848c3e2b15583eed99da19b6016bdbebff4438b5e94ef53d5740d4780133c0df788da4acc2dbe6fab5d010e7888788b6414439b05a869cbd4ea97084f675e23cb79856877af6fcfeb61e7653f3d0eb1a4d94f44ca115534c8ebda7a04bbfd0da511631cc1bf0fa58a5f66c102dd0bbfd863d207fadb3a95b0a684db79c2bc2bf1b7acda33acb9fd45f760ca06962da610dd95b5c9d45df07b31c79df858b8752315014dda2203bfa43b065a976c12e528d1fadb79dd8accebf6e6060bfafe17194054447564cc10d7e6a1a063344008de5095e502d07e1930906ec90b23e4e1df3bc7e101be946e08ac835029a379ed95c2eec544868d97f5bc9617f5ad30d12dffeef940d5d8bb44cf7462e7d4af079c5938f8a8ca49064158e3503f11dea1a46c83e4a3cac216a65056150abee52a1754819861ff6ed8f571ba79c162a1495fa4ef5605c5f69ac440c229ea1d8f9141a7dd09d8ac15e0a30f3148b898e57943ac5aa7bd4669f659a66f3045cbe780797cafe905cc431eb4f088d6b2e6583db2ab0293d1ba9c17426458066fa551570147a5edd0eff45fb98e9b40e53d8c40dc7814b6190f63d0c86ba62dd87df0879ebe76d02a48acae61d97767339c009f32f5fefd6e74b29ee1ca3b1a34eee8712293c1c66047774d4a0d364ead60931e1cd04af7d47002a6120705aaa2c906e8a838288c3f03737746c9d1a47d5fe02b67e7bb95810799cc03ca0b59f7865ce22694bc04a3f15e98a80bc0c5502ebcf8cc8bc75979c993011f01ef4ae690191157ee24b5ba77ec32402b1edacd9a8dbe00c9805ec26fad58c4c29519e610e8f87d5414bcdeaaa73a335f19387756d70b52e4ab536fdc3932251138daae748d75ff163a8306922f32182e010f0b38f05d297fe0c7586f2aaed7d96920917b5d5819f9868e6cc77dcadfbe3b9df37086068f460c325cd2f4a1c62297fbe47d5ef9fb706ea6dc3b632be8e1f964a2b16cf377349437864e4a188503ed7e1df393b614da6f1445d41d501a707b5037b1c7c544cd7d359326ce75e348c8d39343b83fcbe16b21d44810c9dcd0cb967c76e9d99db9f1d500266416fac576a5754359fb4c6ec8a157d44087cba91724b5699eb5f8869134ce5086549abaeb7a901a03110ccfa52c383d46815169a523a3c2460bff9da37bee26d0d362078cde84aab1ab8706937bd1fa93607cbec5c3f28233e5857cd71d542c19da26f2d793e6e4bd9aa625afb02bd684eb664bf27da0769d47b3bb63fa36fc423ebef369329e906f59e4931643764a3248e8ab4ed4cefc4ee804373a9a43b7589d632f417ce3c7dda887518792ee7de0c6ae3e5b8ca5fadde0fba06042b39d4d2e12ead2c7c78e2f891c5633576cabb2ee90330d6f0855abf12b959a15f3a07d7d5f733efe02cea89773ee6585d77bee2fd7ef593b55c0d95e442e85fc748fa57a5f33d3fd923acbe20bc003cb8cc88704ecfe36482b4fab20e54a8dbb64009e4b669d3f405342e9fdfa935ed6a8670a1958d9b35ff7097480a0d1fa97ea372afa70ae75cbd6a4eb61de7f80dda97d80ea8aa46ec2c60c2d18d92d2a57efb4157228fe1e649d5c845e388e47bde26860b15784f8371b0080395430b6285643c864e10f05b5eb4c2ff0989b579b6f3a323c66dba388c1c50503045f5333540a093f4dc254911958d8c831820cded59d01cbcd6b60f1651fde40289b2a17d53b1d0eb8f3dc6065e635665712ca93368c31cc69cc8605392b7d601cc0b753339abd6aa0bfed5da9e4b7c37104680f1e2d88d9c56b573c337a82bb63768ac9db6168abb7fd9f3ca6e623b09abc3f8bbfc6744b7422bd51cee550ffa5f3cb543738c216fed2215a4a01d740acc4173e125e0aeaaa19a2179ab77ec22d3edbcd85bd7181efcfc3a15c3db7fb1cefdd40354772165e2da6af6ca29ab542da32177c55c70885cc139e7837ed981813a435a76e2e51a871fa326c078637095edadf78572dae1674fe21f1dfc88865950e6678d463d03bb7e73a37315b614b11eff749339e48e487ad807cf33aa670f31e359d7c1aa0e31a61ce1840fb24deff6d7ce016364179d4c5eed3039950dbf5d1d8705a3663030596ca3ae72700183958802ed32af88894119bb27b338565a1679efdef33b908d6105fc731c1f9524f44f803fe92380405cf93680e88a6b4365010a40c3a524903d0f2c6d125509912a1dd996d4284679e69090ce5a9aa33f03e9a4ec8b43404fa5320906820756bd9f9713960693208ff5130f94421e64ebb33e9e1065174148706f340299db6434c5dde755662febc4e94ab91687b8956d8d527477e7f9a9184ff7eae36bfdaa539f875d93a8036aa5f6b8ff17874819f73dced7603f654eab16bc36ec3e748648a42e57f5b39203dbeedb39a4ddc30cf992916994b9a71b714ddfc9b2c1a9b939d8c9b15f2843c8007ca67080d87c1aa9e60c060415a03983a466b5d9b6789816f8457e15f0e2693bf0c80e47505f90349a457b8881a74cda43e6af3b7e842e137d5b1c3ecd3a4c74eeb1aa9c538f66cb15a6f5dad6d937566f6964b829154de1b3228659a9ef94230f3f17d4a62b3f2f0ed18d2851d4640e787b2dc150b53a22abb7140bd1759aea05d3f25dbebf63fb91f08414e4702ce81080d8f35a949873f3673dcf8c2da8eaa842ee0c9913d275df8c637464d84ec11dc3de06b7d49d76e02de60efa3a3d7eec92f24aa929e1c427ebc19bd238b1555166d3740da0388ab9970848b8783f5b051d2b523d99fca8b136cfd40230ff9ba6202d56d00d0532f08d9ad047b6bb668fe14a3b0754f5252cfafe9777e428cd34219463ffd6353827bd84486ce9cdb93e964b363713719b50cf3cc5024cebae921427e41fb8fd6c5ec0e72aa091cb3df4e601085d0794a2184d77909deb98f3a2b49b96fdff6f56c73e8326c92d6076fbe0cc5b331dd972cdd2f08f4f1f49615d52b4e498db80d2c5e45d139feb43b8f3a4e519ce40756cc64241767a7d90ec2f27823a128be585b040f7712ea410ccd90181f5bf56258c21f1a9c6f37d5cd714c92599e6b9038c257848b519299ae5f4733f50ea8473625caa045694cff3055b453e43e89f893a23810dce53a852dd645742533118d64473d8d193cb90b361ad942d67eab80a1eec14c254964af92edd20fbc3f247a08e50efd33829f1f75dc53b74e825fb4810c25b5969f28662520d21ba6bab74cf9143af9f1fa625664880c8c5aa029008db6779a8c10389af3b0120fa0fe83fe48f89b3282ae3b25b8b8149b9953007c1ecd46d687e74a85ac55468dbb49dd2be6ea347f6a5b5c35ebe3a5bc2e4119e995722bef3ac8349d7cac6f22bf2cbb83c368e319f10bf705285944e7598830c54d6ebf427ac859947bdffaab788b351c2df0646c7d853fae4e80e77d9bfdbd6eb5d812212c29d60b433ed0db535ab63288db1a965d08f2d452c8661d322b4f94ad41c8c848e32c3cc044de4db8a48f082d5eb220598937951243498c89e86e6ca95266bd445c2d8d5ea6c4d7fa8a76a9bdcf76052b235125f282fc2e8ffb69bc9fbe37b0f90b330ea93cc9578656f3f8665d17d33c15a258a193f71f5571e0da185563efe360a3b82b852bb7b4aec352a5e4b7dc2ba0214105ed4c103148dd08262bfa9167923465381ed5ba00ae275f02a85fa61ae08774293c875e51aaa2f26500c98a0f525f453bbe5ec8cb70f337add0b53de678d440414aa7fe42bbd7187f15780a1b3becbc2eaae57bf204e4a61c955ebbaa5973f066fad0997f7bd32233120e77250919cca3d3f01c356f7bce99ab9954a0fb7c3cb12521428c702a30df727e66bbd8797ca8ea108a952a5891fedd7aa68eba11227ac1a456067bcbd4a0f620304d26165abb42357a5802bf9ecb2f15aaf0cf48c14bcc6cfc0d4bcafe620f58931e3913d1bc05e251e87ed9ebde3b48c7bc68cae6e132796d913070825f5ea5e609b8279e9bb51c26d1c8b1c6fe4566a7f8c48293d4b73d36bff322ae58301b60a54ff8a3c6c2c70ac0c8330a67220b95f9859c11403e2b47658ff78ac75eaf7cfa66899172278406445dc63ccd68884d703fe54865ff89220cd898230256a7892f51f7b2191e7bbc77c96e3b04e5d17baf19ccb9038f8222c5bf67175a92ecf3297892d84cd0748520ed9ba9367bb56f1c13e717288967b0ea6f441876f6e9b119b051563e8f3291936a812cf6b7ba5a6a7c0177fa0bf3b93c47049be5bcf8c59e6513fad164583af7c83cdfd6cef0e8572bfb7305948acc93807f7b1cd9a5e253d9800a297212ffb60f2749d669a29bcb33b54e6604909c64b5aecbe4ae91586f0f020c6fc12a1658a1e20a198867bcffad918d089c06fa2e764aadd3b491a3f664698b53fd669c4588c09e1fcc67ce5f7cf88d36d0dbfb3d28399a18c4481c26aad9cc35a4bf7685bf0ca9d6667dde6e6ea76ead5ccc0b36fed431dc7edc313de1508ecb3e58858cb44b203c4f30de255538534ad05e8c2b8ee6435c7740e8cb186e959cda651a6d473c10b18d8bca116baebe5970ae788e8d3951943766de8684fe61b6e396955e385c27702e24eceaff9ddbb273a0deae99d5bd86d23a392d0e7d3f283cdb5bc263c3a024fc80a7d02b97dee23035b563ebfb45c3ac1da3eea271e8df10ef271b5ec72e36f2b372867bb5a44d0cfc11adc9ebfac25482c9506d0a4e66e27b268afbdac9eed1ed01fbc994712a4bd8d77609c580d5cc71c3f81a1342e1613be8d9790a1dc153b87ee327a4eff42cedbc6af5a897cfddb46e2e404670a7f0dc7065f409edbc774ac917ffc83a8d614c0ef4a87917dd9e00198f3d0b89f81f1a4669322edc73d1134d253dfca78f0a77dfe694c42eabc9586a57e205d4170ea09d90de507ad12a6b61242cfab4ce7811d3342ca6ef6110a50925dc005022e598cf02efa586a13b432a359de87f1ec7587f216e1950569190eebc54ec3da9b1c30a4150743fb0e93482fe249d948525ece666e4aa5fc50f4a8acec722d5cef949ba6d6d2ea993bce7885de452d9c88e89816aeeecc23ca8cbe2e06939b4e3c5bd8df983fbaeeb2a17371e6dfcfcaaad76433f2c7457b76efaa2092c4b3dcb1f0c6f45541ffa2fb652b32dc4bf86caef2799e8c8285dea64821b7bb029744c9fb7a3a06a643f57c7fe29c24b9d80371f974301271742d3bcf82795cfe9398ea7dc29e8efefab9fc98b2899127924b5c7e06be45b6a26d1df8189eec88603a7faa980980f94cdc15732a92f820814e823efa99d75d059bbf433d49f6279765e54a894276bcc2eed23a60913200af93cc2708671af9c39a471f5d2696f5fe12b52996728055c1dad0297827b5fc0a307210326b7742266bc16294ab59380354952b9639554649c98002232abb293dc25559a6ed8c27cfd0d5f3092d7d7f6a3d20b34bf3d268e1c071f7fbb1846fe00ccbe617622aa73570beea4c6451ad25a877b43ce7be518841dffc0053e48de26966a771c4e59be8f7650c140b822c97b6cd57ee7f54d9914e84b7e3e5bf8aef7267b487c7a1c4a123b4cb765b22e74d79976e06196486e007f8a5d16f381306cea427ad57261d354504ccabd2ec18abd3bdf85bea3204bae49b2ffaf28ce6f1c7151dde4fbce675a626e339daa689e0db015d395e388f779c612b498a71502532303d4331d8d7b2391055a32a88c096aee2c79fe95d23542f8769b1b52d70f770b0eb59f440c6189fc031e9b5d02b01a1761da9b5793fcd415024b3b61808d0a6d6aee48c779b84f1542f1bfbe591db006fe56a0ac92c7458aaf17ac57becc2566be10991bd8d1268eb894f60a514cd6002f825067ba830f8e4bb5093140840c888c161395d3f0b412a45db3907fc6afd9af504dc20b57f4928da183100637c8b51630f39fb3f4717ea110948c8e01111f27797fb5642390dc685122f3c6fa3aabc28e67cc40e3e722e70b180bb8987dd66efcded831a55218e005823a1c70e66b7b28f4b5eb69f04919c8820871542b7a8df4e302b7c386dfb2d7f8ef0b6741a8cf6ffaa7d097ed0cd0d42be746e1bc59dbb55ed4cd441ddbdcf23928f6636f147ea9a16c54f65e2cec511b286f087a70147a29e57a808c8331a350bb92569532a848c2e9abe2e2cbc27f571fe55a184143ae84f52d2cac25449faecda1ba6840794316b16d672cfc14dbbb006edc2ed6a0312145db6306849f7e58a91576e925c08bab10dd65cb90a44ea5f78bc444cb341930b146845cc200db8ebe42f6717026d644b52a0cd6d090fd069db98478dc08ea4a2b7d37038600eedef3994a5aaee2cbdff5ce1facd296cc54b335da2ce4977871c2e17363c8460ccb915d6577786de2da46408bbaf77b4a17aedfe0df0daa0644b1047eaae0303d0709bb9e352c328e9080c92b618b44d5974765e2e25c2f1cdde9c66994fb8f817b89b5538dcc7ae9e7013fe5b4a2604b640567dbb03d0eeab394cfd4f973bcda41f09b3ecdd34367b1d75c5e78b9fbb135b20a2b9194dbb13f513f960c0a366260d32c66f74f75b7437c96b22859deac92277a790f01070657e128ce711af07abcc71aca65165c6392753101a70213ae52f17615d9d9cfc6a6d0f6d151c7434ffb9b09a86aecc91fda14455c67ccb7abc0d4937949625b4abb41450fd211305a06d9ce160dd2d57a94a3f41a247eef76349c1e3fb96ed85b62ffea946e2ea19942550919b1b1a3f2139147edd5032ce3db1bb1d0fdec8227beb2840a924f36946435246a574af2d08be6618e133c095ae842c7b6abfcb6cf37b8795cd5aaee8a98e0c24ceb0de491743c11b7d52356511424f2c13eb3614f93a0bd7730abf78dbfb2cec6241a0d9d30f5021104a8207571849aab612cf79d6dd7d2c11c5239448a716b471d3e842d2a728701ea13f6a80afdb9e83cda0156363dc8cb98eb47705b5d2ff583a91dbf798e9d8bbcd223a55b091b7e08b7772f33f24a322fb4907d74637ae174c3e35b2a0a9c12a11f7dad99533a9286cb7f9af8f1fa9360b1bdd99cf3af95f7c5b89c324c113fe0d507fdad7de9d70e3ee560877fd8990bfad0961e6519fda033520a4ee2c09cbe75acba6730bf0542a583f14f2cf564f98c8337427ee51b0b48843636ae6286cc0956fc44e77ae3b51de6d08e2744fe935b8cace0df9f403b55eb7a168fcffe59cfe831de0a205f792afa3d6649679f23c94813a9b684603efc66db8838c50b7d147f4a80e8cb304d2dd2b05f8bb76882a16c0e354e2e03699199c7338ccaf7d6f938be1bed97d1f2ca18bc63925964aed397e9aa5d1cc62f67852cead53b518c78db15e5c35e3f75990517be6b40864a943dda9c02d7f175b2a49133f56ca2c1183dec5030c3163a14582454b9b80ff199a64a148ff0b24953d9409946cc8ad64f065b3417a2d35338b905edd669d37233f21ace21b6d6510b38fd0a6e80d6e6bb0264d0ba51129c2058775f2b466d7b9381a91322d1d23d65707c0084731194ff64ee6dba0452d135862d23259cb96885afcdeda8ddfd5b97f2be0455844ed98fc172c9411114647573f513b9d124ec6dbb3e6987d86a34b46653bd82a2ead2302494d8eec83b6a92faa2a8e6a3e3badcb8a8e4543ca44946f4bcc201e207f9be9819220a0f10f015e6d4542fc9803beaf04cf6e41bd16faf8b1f211bf76ee44eeada625cc4422ad454d9bf99bd3dd604c73def022326862494932405657c63dfc1ceeb8ef4506babd88e477ac5fada26d92ab956e53463fda12bcd5fc351faf3c7813836e876723e25c02f97b846bf14782d7a2e33d851e3ee435df1d36391b6d2a5bd79e817fcabb51108e32702773550b7945b1356930de734550e1bd27df49a47cfa3658eb0f48995e6c6e754b9b8e677f25300728e063ab6d80e24222fad92fcb79b1d414658587cd14bf8014281f0570fb6eb1a59546cdaec242293fd48193c45d1ff8290e9c6fc9c739fded31678cc9820f6d414ebe622b7f821dbc3d4f044fc19f41ef3ba29d90979cee750b2e5c989429b964e0e1e4b8d03735ce6781f3a082217aeb4ced37ad5a87516b53bdd53748737cfdadef1267dac28be62227b3c3eb0535d676fb623e77f82f0b7de772f4986ede94eb6aa0ffe91188c110ef21ba29f8b7f95f8859965c3daa8d374df5d0e5a75a7a00d95bfdf279e6765c0f6f35bfbd1477582482233d3a173520400c0432abd2adf135c8d45261796d6aa889a3a8762709050ae0674918ecb1b4be40a0cb2b6f0b63af7cffdd40a22dfaf0e3ffe06ab2c8a8c4ec372a80a80c55ea4d37943fd4e16f53adb891dc3d8a5e0a7d5593762496bee85a05337262487077b1d0320cfaa616d6be329af3f931026147f64ed581622ee6f8b65a25b6f66326e383609cbaa387c7507b6d3e2ecc8b03e4a341e2678125f609a5610faa51c8226888ae2e3ad23947c07364dd13a14c9963283ccdc5957e88260323b9982e6eae1863e7a6d18686e0b85e44139964462e9d30eca682f71804c36ec20ccf33c954b46a46730c0a899fe3cc4468bb4909ec564210ad6ab89dbe9f2e8395882afe9f0008b8b2de0aec3af3c9c2f258e7f64b210cfead38513b76fbd1745862816e8a4710496c64ed6d521b2950ec9868767f33fc39dd7695e73cc3c767dc460886ab733b05c85c91a4ee07d66628e21053611820fa7db6b6c764a70cef4e89e08166eea015a3e1cc76691eaf1cc37531167dc216eebdf9a4c43c07170661be29b8202283d19e89fef2b26f5d183be0c15a24614668a26eb82394cd056f055bdf8030f2c13fb11e9ec8fd8d1672df2eb46fc2738a0da248602444afdc229992711f2b55dec23e38ecbc540ccf8133c2e5ac8b21920524625e660829c3b6e5ad01d572fb32b2d76c03d33afaf0ef4593a00fd63646db5dd8a09add746f7d53cf4b387675a3884d20775af09d054059c0108ad7c5e22e5db2081d5c51e0681537771dd2a50df6dfb631189dfec5f7a71bf347315eb12dbaaf8a8e0594ecb7bbc70e3b88d683595dd1202de55b693565a0d629883b60be139c04a6747121243f4bac9f4cfcd30ebc3b2c23a73fda0a03d19c976bb1e007732fe93615ce8df6fa38930d92fc01df52bf8a516776dee2b079ce624409dafc255bacf62cd3097edd022e1cbb5a0230eb83ac0c7602428151d135744f640b71a7474d75d3ca25c23b05a72e6c62fd9ed360afadde93312b1ceb43aaa0600355e5a880c8b9b8f8475f23ba9b4eab6de30c7691b0ecf86d406b278300c5f8ef65b6539f87ac6e338052f34f938864601","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
