<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4d5a9d33f92b8ee1b8ca02b9823772228a8001ee18fa8786a8900c232e4fd09a1ce14b01c5600974cff7907ccf091967859b3193332633e726960e21891c27068d426518cc58da977303d2323417c44ba92fd509997e968e14a6ad24b1e261b2dc89bf7e8e2deb60f0afe9ad5ecac1763340ee38ed4036ee87d207d92cf4511a669223542b85cc6c21769523675426daecb3032f761de0e045c2759f170c993117789b944116d7e9bf8e5c89044bd094bd40e5314223c26a9903aa5d620802ca809bfdc18a9ee94735ca87382c6abb0df0244f30814723508df18e9c73c1569ad6f7ac4965910d493c611847096aa77d25158be4284189fd637787f5a3576b52922b7a3806f0fb7d5c723d2c9c5ff58efb40babd1db218ecb8c709b29b5ee208498aeb28915a78efd0e8bd00797fa8305a7df893adce5bb280e4b934b4420df342d7c1ad5deced3579365143c3c1391682ca65eda978d3abb7e967e6cc85adb4b25d8d0de3ae11ee672cbbbfb1907d91e5e3a69bd1a88a204f940008000c283a548a856283e83a2eb11a324271b7411c3dc90e2eb7366eb47d1609b2d27cc834af835e1e4a4e3b14e97feb63647165fb25b11eeedb7c3a11d247aea4f041d4fc6c84dd149839581a52d18c202f6bab118d0ffb238bc20b6aa8a1ead16a069cc8b74b04dfcf4476a685c8e5cd8ee330bb9c7ae61900477b9143d4e210200dfef48f3251c25307bcd7454fb1a00e99e81e4b12ec60d258d02cf31249915ca988a2571d6032af6a5f6a8d710c9411b20f7ddd98de340cc439a431bef8a2f0b85d6bd47f7011d13ca2243dc680ba16ec27019839007e59c51f40aac3f1e68890cc911c710382d772abbf1f9432c5b799a5539790de216d09de2b83a5b0b818fe61da6608c5b49dad070f26d2d6d58b6c6001e1e36297e5830ef6be8dd8ccdc31e979b9d2802d5e97b09092118c21eb8e25d312f86b74bfadeb7cb54dfa7ae7d60f9e32ae85ce4e95b6ad11127f05ef65e734c147ee1b88b8c4ba14631e3c3f5127964eecd87549f2b3f9f0841caae03f09ef2b84e69f69745c2504ce26d094f750450891310090c9a48eab3b22ecfc60311fa12d62487677697341bfe04c0d217a98463d58fc0f78b7f95169cb35d1b65b37bc00eed1c3e40048ba825ae0676a5ea093fbd9d2b68012ff07d8ff3ed057681479ebc97fb1f5f0e8c85c212e4bcb5918fb2fcab80a44c9964ce066664789fb0c40e5fa54a8db5cb27aca30ec9d802caf710346112f6de6f505e8f675e7fd5dcaa787bfa0f6c88993c7c8432298b3ee3f3fa9901ec7faf1c7a3119e362ece1a7994b7b80b4bb327e873c57b5ad2666d2f32f3e7beb6e288042b1a4dcd6e0c7aa37088a152910a9ccac8f5367ed203e258a4ff02bc43412ef672ec7c17c7504e67e01e3bf7524a4d9d3040c3ed323da00b5e287d7a489e1e56660cfaa508529d7cc78cee013148ad5b7cc549e50fb4f8be695ab15f058d519633a3a1f24fe54a0b5bde76247fce8d978ee76bbb1396835c41a89f8ca0cb43b287cfdce30df20a53ab67aa1cf97bf84f712e4bdc4ce299f401c922fab0ba1978060470abf043bc5460af3b8ad77c66ac03160c9a819d5baffd2c9a4716a1193a2fe26ee7503c81e63d05f9a0dfcc1daad423a9d5ac89c02ab4fa5405f499643a64f2d006f25264edcd58eea6b95d79213028bfbce2c570d85f2a7fb30afb54fffdab009565b51d404ce6df7d940688524cc04fdd28758b991ddddee18c19f53472be4580c1565beeade7590505d18ec070efe8f9436c144f1ec6f28e25d07c047345fd7b2fa56c97ad95bd04f4f1505508473ead8eec4469bb13b56692ca97005fe18ccf3f31a6e56b87b179c77dc18b7732cb750b5f041e9d21a17b062ba86499b58e70443e457b87d3c804a75b1bbcd3d8e380479a59c64ba83185fbe0ce4d185602415a3a785c533d5215c58e98a3c38ca34218f5b30d1604722915de92ade32cf76050e40202cee4ced32aa96a5dba9577a23703627fa82fc394da27e7b5fe3aad1ee0acf1811d5d201b317cca87424288c3a429ee72a8fd3ea2014a0772f613a2b63abf5e66a1aa71a44f16c413b46fc0cf2fc1d8034b601f367ec63429843c5557356d211ac56da7f42c1725160db55bda58299775f35328a9be03493922e6a7a15e9cec03abc5658ae8843de4463e2884db8b690dede5b656e45136e567361f962b7e1e24b760abdd46fa5244d02d821fed0835de493fa481403230be4801de552175013a9ae6e93f18f7d05125b298ff78d374da79dc12f472d5e6746139f666f00261ccb99071b76d0bc0274adbda2fe37d42cae1c173d8af3ff1f18558e8e64e7655b6435707c80364a3bd3a68f6c18b8f1a4cf3166ea230da288270c53b73cb901ec75a76277c0c0526bb64d998fec398f849f0b3ac4e083f79c8af9d0df38e5500fbbf6d831b94891398bf4a2286bbb5f9df80f994e19ead91f6e757b9197732ff6087b1500423d0a20497f3a965003c1e7ed54f24b842b3559b322c67778b43a6838dac12068b4c1763d340026cb0bf1d041e76ab6a6d2e47ac9d2aa9cd3531b32d3e765b49beb357b4f69c490d10e1e9c2f0ef5b1d4e7a325a18a02f5d49e18f8587e6fd6949a0902fe7f06f099924bd44a085e0a27f2c218344e27ecbd7dd97e8a31e2002305a861c5452cb1b45d36d0527a0f7b76fa49c1d34b96e3bed824941542e2482add6766fc14879a151d8c17eed595307cd52c6acea2d82f084f5f041d7bc709d59b0e8e15b7336b5192b49c650f9d66e2af8c5c82d5c80aff79f748b4903db3f4b94f1565be66eaef83a30ca94641e499a313a684442be1ca3fd30293f77a6d467e2aa9ae5f878ad0da43249ea97bc8f0085cd786e8be204e4f8daaad1d9b98f1f65c072e9042913b751ea51fb202937725b591427322554c13c5cd6da977e0724a3f0b29b152df8586cb34fed0b404604c2bcafb470eed8ea2b9ff8e45a5832a0deaff9eaebb3b6832962360f37603fb4e306f132c333fad218ad77a8807b1feb0e609a4eb3bed7a85d40d9362cf1ae4a3a547ca02ba576868479d4433374266c3db78db9cd688e57862c8aa2832dfbb2aa14e86cc6a3641b0a2f049802bc25b4423929b939c2c1163cc11a4a42091e66f80245124369f51a0dfa7ea3696a2b6b1a73b1ee499748b5c97c47173b14d8f30341bdf6a16bafbdf2ad64a656011e53f357c7726da59480d91226f64228a5510e07245da4625be83cbdf5e80de2799fcd36f75934073942d46068315bbf2e9f1cdb512b0be4051c5b945e2dfa8b431b63d8b5192716e918afac6acbdbcdffe8ddb36da0644662e05a9109c511117321960011fcddccc1b9c41aa321fb4ebb53025e3c6fe78fbf5089a19000cb6d0d3fd98758cb17d6d6d7f918b644bd5d3c189a0c24f51c6009d3a8ccf4f2d2855089640455740c2b784e80f59afc87361289ab0ce3c99dfaab8631383264aa051d4ab7f0d4298f18e6302af2b57d872146e717e2643b5a9ba35c7a01c395317bfd9e08726d02d29f06d48cb79c012900c7414dc6666374974afa76a50e1189b6348e65dc691aa29eef2b3042a91a5cb10bea4eb8227967400e8ba7fd95e8b0de5928f771b50d26df215f4b5fea2cc07e163ec89abc13bced18fa3fb6de18395300a950fc95e7c91f74a1a473674fe289a5a8232405b1d98a535efb3303c72c8742e90be425cb8281386763889a8d69e5b37d69b73ed3ee4caf42028232365cfb22872a261b7f4adb9b2d605192cb2841e2ea9577c4657bd17504e0a8ccdc5552dd3f643193d4cfe67556f3618818fb1fe56f613b7d6ed9627105d981dd87407b9ef2bcfb8c7e49985676ee7d51d537254f27732611e1d6dd2d1eb2b878e73d76917d24597b52511f09ec11b906c70ee6ee1ae6344dd50de752b8a99c5527dde64ac6928b6726faecf931af05ff8ef2a300937fb887efaeda077ed0b3a040b93a78b3952f1131dbb7753802c971107e777de099b73a28ccac205389b346949f0c2e67634d317f8d889e78670895d86d43da5da60e72947642b734b8a5f6c31cc19d1ee6e6aa7858713da00c282516876822efe6da0ffeabfc442909f10d44a87816a1f2a928ebf2142be01de0f616afa17243f20bf4281f40e93fbf749c45f3b4a2b336cc7d31e24f2efbfbedab229a6dce4d54b897217648f485cccd973d2a005dc25c1712c0211eed4cc5a29a0c410fb4edf75aa8c8d0f1cd857cdeb0ff14dc80336d50322b008c8f823dd3797f14b806de46d7ad0d3c241379fa396d73edf59b83dad14a7455ea62186cd9875a79899d932da47e3e6c3d9d41769abc0601fbbc2543368c027b6003f8e433f793c2c608737d2ca671a6679b94c714fe876269ee6bc835fc3468dcc8ff75ffcbe9a91ab54e38275d1d21c191eb53285a192d9d95253eda316a4ab214fdd481ca8fbe5f68b3c81f49d270d8e4c72851f33f30023683277b7f543b8ded12675ece8a6db6e0a3a938bc8db2452f524f6a57d4b17d299b693df91006e9bfb798e12b8f8c9f30555202ad42c6cd503ff9c6219621ab8b0239a6db9cb6ff5d3c47f16f803cf39388a8efd3165be4604aaa86d1b2f53dcacd333277c49444c920ee4be5281af0f085237e2c2416d110eb8f55fa664e24211416c37dcc17a9abcae92f2094666ad899c8ad413222fa2c2ec76dc5a0cc401090fb86b609dc100108959950a9333b3ddf6d150685d781d98b71fba8bf2c23bf29ec6719888c8489c77a8b902d2eb718fd01ebb2d890b6430e979015b27a0b07c09ce3f4d70382de412d5d1eb66fb53b0b0d459853305988f4907812dfbc087c8ce330452f8cd00b6dd95843c6f8788057619d93feca26f0f7183193fa355107b92137ac61d676a327139d13919fa9a56e5110a6cc79b6919392ac3e837e21ceaa76a60f06b85ec243383b8b9a8a957cf8effb8eb631e9b412a621ab29d5517df8b0b849d22febafd3e3115a25b22d40a2e850a8bdffb25fb3ae4586f100ddfa0cb61e6357a8f46f421a691ef7b0b26f45d8f536e8242dfb417d3dc9d40b13fcb40e2929ff30ce22bd62534d547da7a4c5b7de812642bcfd250877e2c0ee389b8643cff86a8028e291b08359ab05e5f398c0fbf5c993dbe33a7f991612ac414cedf8b709a0fa8e9896232ec688acaf2efd9e613244652aadf9a24c35df6c29d047acdd9b3c63e73a510200ca814e5909d736e90600b99d0d3429f4fbcf46ee99ecbb426192888e359839002a0ec0840ce0c7fe27f19299bc369ece21c6775f89f63fd8c035125021d2fcbc56bf17aa5d97c5ed835d7bcdc4162355af7d6383d98ce922ef2ebbab3664f132c610f24cbc9803785411056da90a2a49d09df288370d75c3aa7b328bf84bd2407a422ac9dbb2688c4f060944c4e33d0863dd1bb8861556f2b5beb8413879fad63d5ac77ba3a1d4a0de38e765240778600db8bfde25a243081f8bf15e816feb5084be5ccc794f1a905aeb1add2d3a10b4378b521bf19fd5766f8b3444eb007f68eea3536100b4e928b1abd6bf1a2fdc9dff62603927c571d866424b4a0f64c7d325308260d5865ea2a32b1235a95739e791547a1498a1d55294b825c3388b068cd4276e10cfa68d8041c2147c5a6f7efae4883876f9aa5a26d2eff639b5242300ac45535e619afb854af7f5c87401114de24154ef8ff63ca560634d7c0344b138e7b69d71f1e3097701ba08fec93d7d138da9a88fe65d5a1a2f0cb5d2e6d8477d93712803b2b21f0af2865438cffe79d0c94ab4d0b8d431464c827158e5369489fb184026aa3c91a7e7381f4af54e22b4063bc3257e9f289b2d087cb163c1bba851f6c3231a6076ac72c25c32745e05e8c6956082da18994f62940c5687776267e6a4cd62e252ac87d3c16ffbec2323c918b712381eff3d698280497c27fe42828544376ce5fec59ce952e3234bb9e601fa5ec8dde572c116ae216f9efc0ebf1c34e6b8e4ca6a7dba74c883931f436c2459b3bac221fe137ac0812566c729e61f56a2797f9263759be246941b8d97db49837e14960bf32506b26cffbb8ba03fb770a7ec4f26e1169b5c67cbdc785294e18ade7aeb8cb87697fd0804d78a04c920bee7f76ce82bca0e376d9e540e2a7f1cc6c0100049ec4bd91d45735cd3e98558f105dbddf529d4156e355c2e30e3fa0664e42187415fd9e1d4411275949dd27da8042b548d7d20c03546d5d50da4885aa26ce4bd0326c941333457068eb9d8f56a27a57796815adced106ff8064f9c347c97eabb5a5d40918ded51143905ab1b009a4b90d12bc005e9a1298a661ed8f1b9756538411e7428f0a5a8a6890c08105759a16042522d694d0dbe6011e90adeb2fd09ba15e5aea6b9b1c5d758ce26604035c803cb4df1b2b9189ad0908691f3e2a35650a7503629e74628a060414cd8136569875805e9de4005c5edba8ff9d0235da58b99a8828b4f4de9f120e2c38ad85d5dcd897c0c393ba5c6771283cdecac8e2e28391fa7a6e3dbd1e6a8bf704a72daee3ad126ba3a1395d651992081961ed00630592332984a6a0156741ca512a6a5c44526cca362993b9e6dadff48fae089176bf3778a94e6fe8039476b9f403e01df3728c0407e52378c2b461d5c17d0b9f81785598d915715dd6b428e114377a16105aeaeec48a70a1c167d56b92b5a0c990d05dbc9dc2da0a2025b94220200025570d5af7a9c099ad8eab72394ddfca798fb925b6350433f139fe59131ddbadc5680951ffc11aff70ac488453779165e6724bc2aa20e1e4d4fca4599199c54cb59e6cc8cfd845829eed4c3c58f6b0c0dfac55b473fcf6c970dadb9889db9d169c86665a763b28cd9f30e8e4e3505c4ca54925d9409f40e10a582a4b12f811d3cc999e9ca8c7a7820b9ae6fadd78776cede9d24fa95abbf580ecfff567c2a7d24934e249cd08dfdfa46843506a559952df538e150c3e6f2578d25cf4a6811424c34b87d0fc4217d3a077744ca70fd333a5f165b649010999f7e3176c681754c6736838a3dff37748a0ba60a745673ecdd1ade785e38591823f3238d835a1310a4251349793791f344e4b27ae1a609ec66f8930a7ec6c5abf42907e89f4c90d7a3d90f5a0898e61e039403e61674815acbdf7b031c0f2b499cd5141efbe037374c855c85455a35b7d5f6a3e90bf3e79dbdb72fb014512ddd595629323fcc5159ed7ec1020640ef518f5ac987cd74dd31ee01aec0579d3c855bb6a5a89b623555b1f84f1457f72d06b567817df30aab70c1a9227099d0e567ce14f844fce41762a8c699b19875d5950ebd73f7be6b44850814f327fd6da46ac5b67beee8fe3f44fc8f7462dd3c33e3a950f3480f59e7ac5bccae2f9d0e0a3598a46afecf90435c8c58720bc2842400aad3dbaae6cbe350c4ea1e9ceaf25cfdf3829ad20979593ed2662b1efefd52d0c18d4c70102c67a6a716e5824af002b75224ecd0899d5f4e8e630af51d9640495cb6f7b1bf14956c3015a885d4f8e54acb9f949461de0d456985f7bb1def954fa6efade86c01fd152b06d03fb6f6f956d1594ee8f8311dcf55d4048962a40a0f6b359fae83a3949d6d5b03b6cb864608d18acd1c006683c45d600969b43bad1423602632e356d60b42ee51fdc9702e7b038d6a74c3f8b733d44a4dbf1a227c74c17070ecd54b69e1b128db7e08ef1dc01d4c6e4f1141673c747c65a4a16dc8bf8028e9c4223ba7c4d54e55a1e932323fd28595b9e7c13fd0058d5ca50082b35e644f72bb604822ede65dcf98dde16cb4c745f805549f56f0144cfa895cc11547458c5b361aff36a52c6e36a6df103ce03eae076c34d981dc02a14a404bd92daceefcc892c3fcdc57549f53eb95a08b71374e33575bdbee31d2994052e007ebd10228f3691ede984fe8aeec8a16744e51f7f4733e7c47f14b1cb77ff9fbab26db2f83c93b87cbef0079350cf391954d2cbdf8fc6b09aa60d2216fae7c28fd48efe32af0a80b883c3366cc39e01d86000d74a51186003b69992d1c3651517cb54ecc066d0731b931f45c616e5563eb49fed29fb7ad971ea3438358a871f1378cf8b83ed8ab4c806b2fee8618569e26171bbcb56c28a168cf4a150c18ae628365e7db5992938255eb7b0fd94cad87bba494f6a9c1853a767b59edbbf8a318a88b3a84c578a0c802d14ebea8069678ef9ef33a4eea3df533f15410f06592d6d8e7f4d8cdfb2da1e245a78710616debebf678a52bfdd0e3614ef40ef816f93c4431d9582bced8eb50dc1d423974653d282c26d56bdf944dfa992128f569cebf255df7f8585a484c671fa97827b12374035f297801fe8a97d8049d23cc9585a467f6453fb72dd6550f977aea8a38d880dd049082aedadb7e0beb7f0de3d5de36bc16d625aba18865a8fbdcee20e3bbfd15847d76ac8bace82067d6c2d265a6f5c31cff4a9ee0d4725875556a568c82190855e9b48a9dec256ec100d538391aef99d4ac945934739c534b3757c8b155548242fe090eadeb798a1275165e39d9f58fd3649c39e5524fcbc5a15fd432081ca73e2e5247c6fa0fd3e0754d88423c18d8084ce0c0460bce7af5cdca67e9a035dc5f95c2f99eff70ef0847df161169b7a3e149472364144adec7d8d5245776281231892d989b50d12013f3c67daf52f765c9f33ab7b68c36fe6907faa322b78466135dd0ea1f4f89835b63a59125f57d889ead6b4ab18e1a1dbb941d026964e2ea692c41833eaf8f6fd2fd0eab0178d4ee7c3686ad9bf4403ef8b0e3ff4ed8cd6be550a9045a60030b3b499192c5f2f383b17e9f370e571ae5e3ace6a8c19b4ec7f9d822d9f0911a91bc60c96e8d90a31d480700c9faf5be0409a295886ebe84fea34746987425450eded6ac651f91d547693f203a0561c844847e9984be3f4c9d1d1100c770ead260adfc99edd2cc1309220363911987cebdd5f4a6dd5022b036c4f42854ef8e960a1ca1399fdafc2bd5d41f0692056f86cb8b4c580862f59b3bea863e07bb211f21a2106f97f7df2c2550cd3e966bf5e0d4c982116b7fefadb36c16e16e1250afcc9cab20d3d291455113f224e2bc7c27409277e5013ed2e45055c33fbb4c0e51a39525b462fb8b9b6eb6c36a4baa0f85de5e6235f2a6842a66defb7462204b1f44eff5ccb40d263bee6283f7180315aa9b545a31a65e42479ea17668e90d18dc797154f4eb59adbcb07eb8855503c058be2d4aea3a111b171c09c6cdea1a6e4cd6590ad118e4c1db25876aaae2d6d998eb5399b985d01594814c7dd9affa0fb937b7a6e16123419568e2c853d1f039dad91b5f0916972eae712e21533679a4462fa2d436d6cb20c388256cd6a8bfc65b1db1243a2de841bb9a194f4c5e17897ad42c8ce25697d637fca6e10e886e93b5ef27cccf57da3cc4e8cbde27e809ae048146498816f55045f5f469098c5c201f3d2cf8214917f21969663ab6f4c3b625a43261c326faa00fc74dc46a736836096d2f6338f96c39d10ca58ca702d377d043897644648197eff69cd9af2462771a2c88a029cec889f50fb3515acc7cc930bbfd6800f90a380ec3616eb3962560d234510cf5682a29d1f85f570538627c012a16c06fa58c9e4c9c4a4b79f480d10cd021b2124840d4dc7aacf756d8e095dcc61f6eb965675eafa2910e03b02cb573da1ca8fd244fe2a4038413d380244914d053cb5d66a1e0afc624009ffa15a3c79ee7b4da632d3c0f3a5336bc8cbf1e2cd4c9e2be79869cb33748bf3673f94de79de61e6dd93eda7b7ca6950ece79df0a130f7c325ba520ac3c38f80b7cf7fb4fec8d8d80822d9049fd3ad2db60bacb0913e25fbac92172df43d7e495dd0447cb0166185ef577fdbe8011b44765abed2004ba1692dcfb91a3a416b5fb0478dc5f1efa4370ceeaeae89ddfec21e5ec91fa2ddfb0149fe2c03ab2aceab0f11fe39398c8a4ebd0e30e966c7711183ecb7d4ef1f909670a510b25aa7fa3b0ce19fb3753a1d493e79de2797500a286468c2f47abc8c31e43dc54607494c21f46624ac81ecc5b8b28d0f9c2f9525ef3fc4db8420a64d38829ed7e14ad3415cdd0a4208c9abda2ede1fd7887e238de184af261558fd3f0177c0e114874128f73e0db52dd80295ecb4cebc7309c53c0f9c7e19e70c6ac47cbc8f1c7ca56d885dc045a8c6239957ebbed2a61aa2d51a39c57c44ea16016b6467269c63bbd78aec668df2dd68c2fe768eb13a5b435cb0dadd27fbe2a4a8e3f3bb3df427ae8c32ad0cfcec4fad3333dfcb36893b201338c6351f059540d1bad6705c1e041b363ac7c54767986323a146c371f83aa53f62ad1ebfca5263bffc754edc3d4c5fd36aa93375405d3d9f39aea1a19a8c0c66f722732162f1c533c411c55ef635023b2f965be165d15c170402e8213eb6c4ac2a4ffcc0b5ea33301b61966b8dd8c8989e0b836da9f775bcc3336e52d9a48f92a9eedd3898ee39cdd24da22cb5babc1a57f7ad4beb3bd5521c290d62a4cbb2d9eff8220ba13f91f2a91a0bb90c4ab4727fe92f98288a1e4a8f63c8a51ad3229680beae5a876032737b9f9b18df65cb7ebba7b7007b33f0c7e7ff8efe17844bca26b1ddee09691b2f3a6ef2cdacf0d4815aeb1f4f965d154a86efb30324e313b1723bc5e5071747e8963672cdddb0d7bf70234944697023c6e5e19e54e933f95962ae532aa458e57cf900cb6862a8049de2e6b8799a074bb1c10bb7fed176e018eba0b54188c7dc650b2007c48203519a132109e9e1cf434af3f4a8c593afbaea2c779203619e104db47b393dbb618cf0b195143b60a9ea89379986597b1659d0fed2160bb93c8c8b60871bb89243408eb0b19919aa8ba42c7968e02cae8b4a64dc4fff25f563fb353a32d957a1cfda1819d8baf3e2ceea94a9002d03036dfe451cb638b44ff19212d688d40de43ea7b289d460285e0d79af908ca7001c0bea055cc26c55bd04d422c3ca54160b2b25f42b8e94d03e7fbb835c7b6d91c8b17c7f5cb7eccd558fcf7571820fe2cadf4dd823f0a45b616ec5d5e520ddf1c728bcb9721773be01d41dc6af54d50f95ac915951f62602bc39461a972e6b6207efe48d07955a4709ccd9b2d3c8a38318a281d4f7ded41259b9cd9e82f4d3e614d5b22529dc99ce74d7c3ba1963d09760213908ac0b62d9fb8c2d595532240ed3225d19acea9d28f33ba54db42060ed1e9e280066521c8d7427076bb0d6ee6ec469a3c0b72a7774672def9e925375740666695350a80729601ec50399de9d8dbeb9da68ddcdfcc06b586dd48a1840e9fd177b8be2520d40ea6b42d6ff6fde7dc268223de4f634d97a9a74ee66a9d48f8530dadf657bb174de6f1c834a40cfaa0041f5bb20c649013a2ec8cbedb4c9b07024b104b5617e70947afc16772c24d0ba1bb4699bc895977352c4f3627c33b2ad26cf191ef1d07646fc592ac258b57a73f412da67f9843e160c20e593d68a2ee75afe9a76ac4d1089dd1b8317d7bcdebbdab574508a8006e78e318561992d3685f274c46449a0880792f892fb7f0565f6247c59166255189714e6785b2c4e3cc804d677fc5b68b08d2eca287b5b3f262712c51844e9afa4e9637cbdfca410931b40103bbc03f2c7dd99f23b13c86bb803a29e329bb5bdbeec08a83f0045a6a30540b6259f0d7b2f4951c5ef460e9a34fbe7629423b4db4186deaf13a46f8f2230dcd96f6b2f7c844a9cbd9d15190e208029612962bde31103b691b32f9c508dd0be718a3455046448861175b5b7ad071824f9c65480c6e6d6fc38a008d0c0e1302d2740951e367a8abf287e86ac83128a5b50e7b976f443653eea4ee08b03d428f70848b997935998d9a1f3ea18e30da044404dcf8b89e0b934a474712f1c3e97f05d1e749c286ef6b9698514f5434ca5752d75b1810217ae4cc11eb22f529dd09d0694479098ee08605a43f9d4efdb9aa998f5f4c3640c4b44fdb0093e45d118351577c8781a08392da6bec7289eee27d1e974de8b36fe480965f8167aba97e472790372272086bd2696476b2b1be4b7f8dc934ff3b4e90a98b254c898ff841149dd064bf01eb2789a41270e47b85cf96c17af2928dda4da083f19c1b8ccaef10fa4886cc5eab4e69f073bb68fb1e2f0ff3d975c25524948e0fa3ca8ac0650fa8b69b479aabc24cc39cbb1c66dbf0cd4c58647725697434c47207f9f3f907c332f8a506e12268a43b615b1bd200fabc9aa220e0fdc7eca8892035ab5f4178980b1e191eb174f6548e62d4388c44e22d54bd8d1d4ac46c69504dc5e528cc3f42d51080e95e212a0f2b213cc8704c7fb5f040943e7c4c33fc2d558a96ede2699833e1faeef1696c2efb5e274e3511061370753d281c1d4c813aa461d85474feb334c8c9bfcef0de6397e67b11db9ed474b73e9f12cb8d40414408eb3381b03f0853fd8258703a255f49b6cdc54d0e032b0923b15c302009b38dec14eedb67ebd3b7149aeb62c6bc4107a558a4a32092b71dd5ba3181ca16fb2174be58af0858f8e42c36058e91264ec5645d76c2895db8db3b7cc92d1d607492cf82565cd90b198a3d46941b3cbaf21f0ae01ece5270d107e37e60680c0bf99288154d1d4a4b0da15a817c88cd0f527690016ae8335ed81b05228fcefad073514937a604435ed2fef71051a48d41e86be4c750a9daf1b4ca4247e1fb6399a1be4c0c6d26cffc7dfa3bfde6765cd711a5a224dd17415b982ee133503ee05f8be225c06198d4963d5f8be610a40bae540117a1c39430d5ecf6defe082dee173631556871898dba4170bad1b33c58cf0f37f268bc39bf8bc21785051f77facb250afec75e02c9cb8d29fa9d8f8b4e26e53e4edca6470fc3ca71ea4c5108b43c75ae4209fccaa2e6696f485c76cd763fb95e3b0c573aea93b0cfc2f551323493de2f0e20ad44af05f16b12154c7aa3afaac6cc3d8da4b8da2c82c222a5f890f6b45f0f8c28df03a2a62cc0ebacdca931f7eb4da73dbfd2cffc71abaf90014b0ee78670efd3bf98c501889cb5380b458e63328ea54cb9c00378daf9d8b7c02b87017bfa51b9a8aa75cb78dacf46c14414bf9d60d415ee3e98f8919405d5bba016819f005ebe6076b0afd837ee72640cdfbe7f2b9782739f9ee4bf9ff7da6e085f66c24a1a20fce445fc2292aa85afe84c397e33e6f2dc554238b6ec7979bdf282660fd598c153f5369bbd1286aef5dd01d307812e369f1b24571e2a0a15a52d236cc46947aeddd863425990addd40a8e74cd5fb69acc61c2ebee1fb18f1b0a362f7ab0b739fd00ea4c053998b5f030dc0cba9dbffb099f90aa4e933d139ac2b11cfc51afe363bb07933770d0617ea0da22855d9431b937e98bd5ea5743f83e5ab0f20d17bea190c617afe99089a1190dadeb50e00ba95356cac3ddb9e5c0fbf4ee4b4148324f7b3fa6337194b92e403f8fb2869d6ee57a95786c022cb091d52dfbfc38d2a5a542f87c60423952d46c60038bb55c832cee433b2df4555883f90f6fb4900b0374c6a0b3c35ba9a48c35b8c2d9f1352ed3e3cfe9ffa7c456b54b21fd2d81bc29dc6a779a58831fa0575a2114ec6d6039fe5034a0fc36127adebb4cd64590af96f3cbe56b932aa20521951ce959e6e3e237d6b23959b515ef2cbf41cbde26420901ad38930f82a0e9721bcfd48a9bf218ba8e109b0cc9311e5c5a3d68bac477d5c394005f1cd68e8c719d295b966d2760b45a8a08e7397b097b05e1556b5ff178ed9594cd10b8662d5b303dea7d3a6cc2f10997ca647622c5a6498ddce96b20399ab5585586e580f96c4e4dcf7deffccfc1e778a0d778dde5d1e6e0a253433349a003e73969bfd27abe8b2e32a386e5b2ee6d25d285f54f90e8b874bdfae51c69a9625cfa9fe9f6f1a66400e4c6749e1ec11a5d7a0993140e3361f2b6e9395297df943cb1a758a4c2697067d5b89ec1b5399ca314df87fa3541fc2bef3921688c3f395882c09718130b153d79311b23d5a749981d6e60078b2cea5c33aa7d1798aa7be4befcfea5822875b6002ad3befae6620139dffc93667d0a7aa515ea3d7bda963a0002cb1c441dc87e8ae96b7b6c6a45a3927d2653967f4bf04f2c8fdd262e67e976f6991db0a23fe51370a57d0d6f591b089065115f0c956f2e3ce6bfce1bb1baf4bccd233beb2a4caaefe8b51e18be8865f0fa54af45de9293d30662791e1fbd7196a41271f805a13aa5c153bcbf00d6bb5b066e6c9d25111bd12b538408b00a3fdd3d6199c8c2903bc0cde2d15188c6c655d602c548a027802d04ef40cf7d94bb810fe0c38ef65d9a719835802ae86826620767ee40ef86ae76587e7a313cb42ed60472c8ff4d2aac422716fbe4771bf555bc6b148d6518e260a9bc85d2ab14f1f4818784fca899fe56c1a8cc595de63f5e32d467cd53af8e927785238217051dbd5a92d5c685f6d13c8c856e01019c320175308efa376ae45acc6cc917093773e7bcb5e7906e13394bee0d1d2c5380f3906aa8c8335716d113bafe19a9c3422ded3c9680e019d1570c15c194b83f87543c9147a6ae802953dc87b01d573a4e0e01c51dc8f686635041e9950cfbc72873e33463e0457f9439e8833e45df0f69d55202ce331b63ad4c35aa53b11f7fae9e61f65a43d37340ea1fb79318cda6fc56853a90347fbe16f3255da9969bf309458fb433317331b1fce9376225073778348d9bef231ec6e821ddaaff642da90cb53304c5e732038b8424f4b2f6bba03d53de8179b25a21433bab3f4eadae8bbde1747540025620ae89159f63987da2521685975572cdd5c972ba5c35ec57e710d7d6cdc39a47de9a25eca73fa38ebefecc59bfc1a0f3abd49998f4a20135cc6ae94d21ca1d4ef258dc5f48e0ba8472c969a8de0266df6b1264f1a53174b96cf27574e663cbccefb99aa283161ca729f7fdae7ff30890b2bdda5adbdae55dbe11b3df8b8c44287002f5c8f3f66fcbbd2a8d278dad3b71030a4f44c0a3e48b46d2f06970d2a6f9a0ff462e476ca054cb08c3c380d9b707ff37e709f707ca5895ca70f44fe0373222a3c873a42ef825e06d6e419c519cf08c7294afc1672b20a002da68089c9e294dc6a1f9fe5e6d4f2fb202948f9b1b8d51bde932240cbafd0ac9695569020f9faa9dc10ac395fe2a0fc311d4b9618e1701d31daee5c74261bc26dd996a33dd1ca217c48884131ede101538bb43ae9009842c5ffdcb38a8a758a4d11b8e870fd40d3eaba2d008194960119b5abf09875b9bf42e97d1b3204d11bc13c2d3120601b5c8bb11cf7012327c9ef4d4a14e42d4c1921b8cf8d63c3079e22a550ebb359f3e2eca21ee81ef44ba7b2bac46d9a70e370423ff557b01a9bc2838016767005433be9ed1d3cf67fcc74161e33a5508e980c67112656b2e04962cbf3362ee62a49d429fb4507b3e103836a68430fac6d8b0cc27692c93fb1dfc0ce2787846db640fe34cc4b08355b96ef11bfcfe6d28848fa10a698284faef9543c16b0eae1272ec4799f3e2d2489e98d3a4fb1b745b6a9a62660cf4e2f40389ddef935215260fefbf963f8310e77788b5d1505d7da414f8d5db89d1533819eb169dba3014dccf1bb129916274757422b601624189e118b7def27e72a134592abc957a0991e02927908df12e4755f60457f1a4d14514405c5e290c7e99782e13854c5a47da45ffb5835ba01e09a9e8607585afd6c126a5b3eb353804c866e8e4a58e07c9ae821c89ed8c2bd03e5adc906c9d3c6685718b4fd1a3dc7e13233da1e09a8ce5175d321b08b491fcb2ab5a52fc36c8d4dbe31c4e435a35c4eee98ca39ee7804f83e055f7bd81d6f26a635f226c41ce71e38c81a30b236429f97ec89ad874d91b15422add9bbabd0249faa4ce0f3bec82f8f4e3e286c454717cd19bf254660042ac61c1b0fd94a1067ded8d2ea8125675dde3454c7b178bfd853b0c79ad60af81be021a4938d0a4856ad224c952e459948bae68a52015ee189a034df1afdb47c99ff15d9666abe59d74a45fc95b2d370d62dcccced3a5f5185731c46f1971e08c0cb3afef3eed0c09567e073021e1711c31d3e7a9c081f770a447f51466c05f4fe02a07fd576e0ae1301c5d56ef85879ed688f86db0025cef754763eeea603db47ad6ea24fc4d6cee23a1b0ed6bc335dc434e12ac70e75b50f65fdd90e00e052f5d46f4b1133558b2cd84911628df400cf485b2d77e5cf661e6295bfeaf3a6763af9f73444185426a1716bb19244006a7cf1e491663b5e485ed54884d12cee0fc379c7e2e9ed4946a4e9948c3af5ea67704b6f20aa200015226b7922480f47aedfea8ae0e1062cc17739e0c4e373a45cf0490c2390a25c9dfe8e9180c91c257793da9227d285ff78609696ac8f8929ea255ecd2eac18bb7e2c668747aeff1705407051cb9bf0215d859d157bcf073fee2af6dc0617abc56eb7f3c36650d438baec70b3150acccc36d6529aaa96da5a57798c4862f1bae5bd5bd69dff69ec91587767039208a8b3ffe70e0690a3bd32035d6835f785a4baae39735588afb003af9d9b502092d961357cf793c283e0b393d87d6b95731f2abd3c041dd603dec5e7ad1439502c87bd2eb54fc20b116a4a78a15b62d45681f1ac36b89879493a11b82e62012d911302876222f39b13e8b5484ac64ba08736bfebd1c9c9db9eb6925c7a0fbfaa2aa56650bb574d208a91ae84fef635ea7a8d5dd42910fa528ab96a765c150f50788978cc915dbee118aece47222e5d72f2ff5f85128518a048ddda2e824f9d0a0de3c3e5f53b04594772b7933514ca3e8a28147f2a8eba5bf43a16fcc49d136487e5fdf98f593e645d67a3f2a9faad879ec316c1155dc6f51ab9f364ea74b093a5dff62ea66736d5cf21310f9eee7e75ed52a7d6a7acb305c86d93ea6cebb5a571ad5804d70e9abdf1a279679bbfb56a0f22352a5c44d49ee7f7de6ca9ea04892eb91da11e1b1d534565b3c935692dac409b7afacd3d966f39d4763a9a0615156b8703c60ad50c2160e41a9d61b1f97d993fabb8915b8d15e8d8dbfe483e58557ed035dda8e8bf6af9a70aad6e69435138d8daa0adeee94b94b7d546f69b7f4838ad1567a3e15b59b28a1b77aedb015da6e6e473aeabd058c3e5b6ca296b651d67349723f755d18faa56b41c106776d89fd45b3539795fa8bae54b07efadbb8ee506275b8f2e91018a5ea30dffcead7922b0d5ce921e9aba7aae5855bec31bc6a4a70caba30d0eae3d76991c9387a95ff6549aaec3b5d5cd9de7aabd7e5a2eeac600c2e9d384aaee6c0f44e21de0899bf337828a557bc0a5c36ef7d7ea2cd15c3bfefcc3c0d369e1910f1f984a78470363a6a9a75906b17fb43dbf77978f1ae8c9e854b736da24040853b0bfbac73d3e5f75a4825db7abd00e3c048ca21ce23c4543472e9ac24f8d11e47661fce9d3258febf9f2702b7c6f7f3b79ea11898881302c573be2aad3406acd3326b0b3ba2bcae0c55c918d3ccdc50271b127f820d4612a7e1c82c1945c46a91742300b2e05cf44cdfc43316ea07d0f76d0508bcbd70717f8518f35edb3dd5a7aa711be6f81224a57a306439120d0676baa201e642c50a3cf3aa7854aa19d72ebcc496f08383dba645c853cdbc104b4f265307494fca21fe0ab8873f15194347ecb6bd4ad61bd66afc99dff193f47b23afca767226f504d67c4258f5d710aa8ed559daac22357eece437d2c0a106508f8f5c74638ff3aa0a801b399f106cacc7330b852acd35018e1b675d4a0f676c95ad0c4d78a4e0160d7511c11d88662ada12b079e28c8710514384b00ad705599f730c96a0b5dc7b4cce9f7daba0f4fef805058b36c80a03b9af8f8449bfddcc8348c4f1fdfa6645b88ad7185f12d6ffccbd534500bb81c9e70af04f16f31c4f35f6fa2c0404ddfb008a4ea4313d65a1ac1b72436bf16c29d00753a912aa03d36aaee0ca9a4e3cbf98b43eb0dd5ed018ec6574f52cdfcd86b0e12d94e32f71aa5c273136bc9bdcbd37a0eb346173","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
