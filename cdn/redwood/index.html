<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7cdf132d7d371b7e446a85b0af9438d7fe15229b55edf91aeb3d6414306e091e8d2b5548c186f50515bf81a69d19006e123c0c2bee60b26ab58939acf9a9e4fce65a165ffc5ada7f389d387921741db7db56d5cad6fdb9c0c8a5861d673eb22d7414744e5e0040c9776f104edc82daf95f5fb7fd9d3b48419ed0a5fe7a2f9f1a7b14caa049c048a1d9a36015d460a663dfb1294cccf7274200ab0c4007906c5b520f811f356af700b66e3f045153e726c04afaa53be20e214d3efef4a00424139a66e492637f02550712922553b386e3516b9c18f7cb950e1ce10768023daafb4baac3c16a6db468494217170896a0c5df842b6205822ed767c10e328ccd8583a55c5ee3977c67ea7aa6cff7a6e2722f917c9e5afedf9cb0f4ba95bfbfaddedb146070467c676b0f65909670095e9d98b8da61fcdcedf11f8ce7482c009c375673a16f5fb657b18ccf09077c9142ad65119606cf82c74857fc21f36b1f3367781a8a87504ad01fa7c008c17ae463c1cf963707ae14b7e7226b7af3c6bff281fcdfa876a8f1a2b69ef7f52a26e534aa7f99e5777cb694eca367ea61f8196321f1b227f8c6f5b2d94917dc92a242f3e70aeda75bfeac742d14de7db6a3320a2ac9143d70f5593ae398ac479389f88ee2919d3109cebbe8836882aa4c266aff8ec1628123267c4f4400440821714128f207d6fdf169f38dff9345f306aff241caf361a5b66a8fa0cdec11628a3feddb3655bd44b21faa9a4f2364b55b5aa775a87e5755bb5d99299112b53c7a5f23b875af43afecddcb963bb017280c28bd70bd383b28cf7ceff582174e3fefcee48a6743d9c43afa94408826ec875e497e0cfb7c2aea2091edd3a052bfe54ea038070ae3cf815e25eccbcf7194407a6bee665f4a2442e1a346c7421951ea1cdc542c1935ee186e484f3583cc8dcef40858fb7bfd2394a8f4655257ff1ffc0925808127fc523c63bea0c5063ada5c458ce67d83b7f3a497f94f1cb558c8a3d29e5fbae31804da8a4c2ec5e0fa4b1916dbb7319b19818ccb2ffca39add5c7054a42eaa33f1ef329659575dfe5e02f768404274c73bd7d28282380811e712f30b25605b411444434d568332bd2ce0e448d6e86a2850111b0f9f95d68adc22f1cae9d2ba2c5c5d040c1e782cee099ab7457edfc5be364cf74ed91ed5c8f8fe9f2d4d516360c9dd4b390d12b8ccc71d8cb0d1da23b932026e74225c01885b01d2788083dfb33521fdb63256343ae8faf4e1ad643dd25365d3c1000693ea2a32a55618b928985fd9c9837bf8aac0658f15361c1fac61b175cc1193a5d2ecb12c4ab6549c5f688fc4ea174b40b662d267577f755563e53e39ee74622d251f4780e76167f429e22d8a321e4ecada840c6499f2b9c34ca8ed068ab523522dc3c7ee02d74bbd308ed251cf937d85f11aaf67283b4dcf610b95f30d8d9e091522e9c961007f894261b106aa1b8aae95b1fb88c6e1ebe4a32efdf06580754b82ae33fa0d86e622b4b266114e3fd5dcce5e016c270962cf8d43d0b0d07f901e9274520d51ba752266303fea38d6d66b73bba3e1871539a536d1c1f3a8b4282854347d4a4752e464045becb2fcdab07e116320054ea145ab740f2dbb7dd1ae4775ce0371e357760fd1d0eeb52e1fc53345b11224b626cc0b7d5e8d6d65f391ffc55ba0c8f530d388933c00c43f854c6a2d63c66a73f73bbd42a289840470c17355ba9a3d4528df685db425f27b0f967f9bde32d8cfd9980a4add7da473d8faa0bf989dd0cd1a35c5b263d1c2b7e1bb6f3f2d4f82cea6edc6f459d56ce9cc7816001b083400431edb338bbb4e67ee8fd7f094a7511a5b920a9f648debc43a841283f2586df9df9d6bdf986ed4ca335c0c25f4181129c2d40f38842a5cb202c9a6bada9f5223fb307dea3e8893df81c811bd90347b2a7479a631012aef8e1e41b013a013efc7ce4ac11ef831e07b730aadc21d5e9d2b5d570dfd67a3f928e5205fea21a63377528de36fbf22bb95512dd4c378b2dd3fde4bcaf1c2df7fcc6cb98602f456d6db7fc004edf420fbe42ab5c7a9e4fd27bcd5c81e087ffbb6122d89500ea2609cf352a24af92cc2c7ab1958940d993cd0112c42b46de99d20bb4ce4b25da220d3cf07d2e5836e687231d8ff3689d08720c2fa76b7928b6ca49a29e4e19222aeef909d92afbadbb34a761cb242249b6db249b862a36dd548b14926edcde8207384a68bd1c7595fae952220d547951849b5cef01fc8778256cde11d7b7101c5754b9c0563ee3dcb2b2a29bc709ba528c63bfdad4ba4598f88e403c21e1a645fc1259567416fb81404eb1ce0d30e6b8fec36af05fbdc1f9eaa959671beeb7097bafdcda83eac9fd88f39bf5933b56048e92382342881d5a82eb8f5ad6fb4f6a027669de05cfbd021a16f12d33cd7424d42fd40a36d953d54de89c7ad6016c50f6b3c1b5f86a82cebb427d1e2652d93d65fb25d54c47fcd0fc71f485d9b48f2700a911e6e89ade530b5c294dc91cd840ff26531eec3778fbc258c34121f4bc7d4ce71702a6d7ea4d38153f687346343c510acbcf057d5189495e9f0778ffa55dd477f19a745f0ba4fa837fd008865af18fac61a38ba93337f8f7168f8369582a5a454693bb63826a2905eed771863049471a5a5f1931366f86809fb3b39703b9338ecac74c6a76e03ca6c65851f37b493ff921983dd93b345daaef326d6af8b30c7da813a3291bc22d97ba8e218ed1fe80bc0a9e6c81724e25a3f4108c5a85fdc9636f63a180d05983284ffb053fe67f910d4107939c8f38e64458cf0b184854e6b04ddb0068b582b9d3d9f9d798fadbfa06618e3993999976af236f976fed5fbf7043200c442a2e5213ab64226b2ae7c088c9c0775e80003408f6fe6272bc99abd75a94926e00067d7a147cd1d3ff88afef7584e820c5ede5a65640ad2670e35bc49211e8450586328b3188eefea9e770cf492b4fcb7929f36f6aef0e5d731b770fc25eb85f199c46333cbfc83feadc152b3470203fed73f07d28afd10ad2d80e09002516c39ba84db453be7dd628703d80cc4057f3850343d26693d91d103620dc638a91d922d89b8c295777a788e14ad9c8065d559aacebdc11c1b97eb1e3ffc0b810238548d9545162bab64286238c626644f16045fd79fd8e87653f2dcccedd7866e4c21c06231a65a4e1717713f7842c9a15f3aa4f42b298f683aacd0133213c6ba19d6073fa53654703cf0b83ac8e5f68052c6ac854203a85d73a27cc080c8afb8a3add5e90e6ecdea2ea419e9484f1358c4dcc64b942cb5c75edad767697b5e5d7a2bb7a5b6497844e97e68c45b6dbd7e639df6339e3c38d04d4fe5ed7ae00879cb06d20623cb6d57a47788b7d8b303f802bd439db83b3fa849298cc4803b3b50154032d954d126a6154e40349a89ac346562dbbf917c7e0ffe27c4b4151a1440018bbaa186b3c4912e8b2326d29836dd7964a16bcd0b3673d27f0c92403dd12cd63a33c110f2ba8f761c297adad51f23c4776356c743288e9e78ab675767ebfbd86628f871b9a3d170d7cf8b7c5c97b1deebc48384d317c1d4079bb06ed11e3da1b841e6b4667937a8df11ec2e19ceea61941bfe349b0753098fc22e9d451eab701b2b8b20ab7d0c0641040ccf5831ad80a4ec0644c48251e5e58cbbf4f379fcbc6c15c9df5042efe27db598be52dcfb96e9984b2cdda8792927135bb311df41d2f50c2df1f1de849dea762d372081aae15fa88f1bbce10806c66e98d4a6f17edbd4e97dc62e5d3b453397b61d51e6142407e4ca67a387fb16fdcdbd3ca3abd5d28740c462ad634972f9e22fce6b2de01fc820e446d4d52e9daaa08595197f855935042b911620d579a704fe255d3574731f3a2b93887cc61961c4e06b55aed5d2fda56ea7932e87e509f84de2c8e5d13ed2bb69616b0d03c84d45bfb96f043c07c7e39a85749e13c946c5c37065c85f93bd02aa8812fcf35da295bcbfc95a67b910e10b723831cae0632afdf77a98b21bdcef9bde4d8ba6b70895549805bdb4cc624fde8e3578e9248b2749d6c64d0d7e138511c8d8ed41f7816b444341a32e764de7f948f743fb54c2451a4cb14bc385c19aecea1fea4f44f3ba454afc09a282cf7be66bc5780cfeffadf7502508c5f02c2f46f272dcd94cffcb00c80eb5c3e5ed2d08aaaa4208d3f21d684762d66d74407dfd52ae8a038c968df4cce038beaa6a0ece89ba7744103a780c686268575ad806b1d0a66b19a4dc8540b4d8f8526a98c51b7a5fd7c7e6927633bee64a5f0e48440fe8b66d8480aaf29ca8c5deec7e11f761eb3c96948563165404c04c19917e313a47ca6e957ecbc768f69b98ed1922d9b140214c61d1d01267f8692d4d1a00f2df69f451f9a63a32f8159a4d8c52f068aab04ac6a19b286d9ee779e535d82aa77c9eaf161dec13c85ebecb45adb69f4dc42d2dc566fc332232d2c475611f9c8753f9be25c6e57d9171080f24c04823bd2660bcdb52b4754451e1d5fc33da9bed84223b8d567bd51761f0a00a9cd824121ae362ea79930e39e8eedc679cca78ce77a6bdd7840eebbf7b78723e85d314538e86ed176c8c6e025c5110363a4a9ddd6c60acf70af551d98ecaff79bc56b08891d7bb027f049f4bea8d3d22e361a9697a2713b8393d230ec9e0a013fd96ae8617d04a39eb914ebcc563c46f98eb664ad8e2c406ff78536f1e9f2627b26c20da80e0ec2d8745f9ffa0838bf751246255a74635124a97b36374362ef5001aa2ac3137da98ddedd35d1fbf0330162c05e2f445cd3c3c918629ab5858e7789921c05786fdea71435bc3ceb7fd0c3f719ed5b704fd77c9fb717b17b0f5eab51c7c613a90657a6489db820ad9a836bc1dc08136618dd65463ff2a05c9de6998a1ff3447db41f4ee9504e13ce09667be9ef6e3a19a93e4778504da2a6da94ecbc0ee77b94c09f5ce29bf5374aa99882cff0a9847f902359ad9bd6578965572fa1e13f3d63141148525b0ae6043e7ad94e161a2dc8be6514cacc5eb46fc2bd0a050704a38505353dfe1a5ad922f6d9d9868d76c983500979bb92687bcf2a7bba2d2bd7d87fea9c923f8f8f72c9c33086d795e70d385e94c270510abd278a709c150352e0354a9f26815db54c28ef7ae6383d0e4e17910c18461188ede1320411d7106d7ebecaf872b49297cf1cf07a3d966a91f286f545a97539135869f327c4831a60e00627d8260fcb4ff970865b89893748e83d01c2cdf33bae0b724cfe3488df66c9113211745a7160d49ffcf7f04bfbb4ac66372e83eb43aae271e94f6cf2536cb6ac044e75b48b4a59532e947c08601be754b7a3adf4f0350d0a6aafae2fedb65a0bdda5fe6e9515326902a7b3de27488172c8730654d7c6223ce46bd323209632b8e04af6ed726b68b19efea7713ae8eca7274eca3ad4c4f213848555b0470685bf2f9bdb32dac462b5a45b8e9f36e8f765c385b04da36386c3e99b53d881f534b965595d841c5545ce24806b7b7dadfeb291c89ff5b1f27e4cade05421191aca6f4a375f9ff3928eb66b827d7d441b381d1e9f02f8e09944bec1cc1e0c487ff50a886f507d78dc91963277fd8610806fecabb88dc12dbc2be03cc351b3f8471fd078df4278cffcc9d0203204e6d29c1a914f83ea9291a8571d2f065f24fd601aa141adfd364a9e7c537a801afb6bcd4b0e9731fe7da26804a91c20c372a0172c1ec5a1b05515c434f2730c7d8bcaf42cff2930337146dd716ca959ecb50da1260e0a051e35ab4e8ec81feffed2181450c983362fb27a9bbc731d75f84fb58657d2790b8b398454a1d0712cc43ff0015bf20596e5327e4064ea393c2fde8f14ccb075d2082bb9b9f68d8b23178e76cab0f1c55a316ecb6527a10add114e0e3f82ae7c4c55719448af295eeaa91dfc2b1228fe0877a6274b301a42dd2cfeb1e172a63573c458a32518201f85f615782ee2bcfcd510d39e254f6efda75653b57a272bbf8462a34e8f0d0a2482f8323a7772443d3e77a2d5a2727d3a8cf97cad0ddac375d01f54674083763d07fa6edd72049035aa9218dea1dc4c68171301d75edcba84b23e00a44720a05e63d0ded6b9d9cf0aeb3de13d0740077051093bbb95a1e257652fcfee47b498779cc43520f40f4d5b3bda7365d35c35effcf966798d89f354729349f4e4d4d74fea5fa7ccc190e1e4d6c759ddba583b3bd0df39477ea173a9923957469e05bb1f7037858d945e8ee056ceddb1df9c2c80b0d7d8075c6acf0ebb3725573f76268dbd77a4dba0b972c05749016e7775d579acd5e3b2716e60b839610b1cf7843306333eed27a035563bfb4eacbea58b20ce3b5275fa9ea7428f1309cf3d12ce603c43b878637481e812d8c5e791c788dc455ebfcfecb824bc92ab5df946e2703e2ba64636f814961b77b9bd116f7e85e94451f5625e04b6006519c85857e4c26c015dea834151287911b1ccf42135609063dc2e5185ae7286a8a4b6ba48829511c1a670e73f1101bfe5d19360f1b8c0a6f4331ab0cb96ef48ca4754db97c9b2c11a3d5c0b37f62601499c65fffd82e1025e382af41dff37cb006639df051d83fce91e70cbc3cdc1d27211b766f4971185b499a8ce3019b3d082871ae904696141a667e5cfac3f59977d91dfe24c62f5345d7c186d35abfd1c7c5233f8db8385c9db1399f4406bf29ccaccac637077184c0009eab9a186d39aa92d11ac6cc725e333200452c151eced66a88be81089a0709237268e04d83dd2bb0fad87caf11674a81db17577ea2bfd849c0352a9cad065eee6b706a96fc482412f70c43e800e6d098cd09e16394ea3b3b89de2b40b6adc6486aad0e529e751ccf5019f74462006d99483a42d610385158bb184c3bc1ce443565d860d32c749fdcd4c78fa4cd4e0a1ec563d4cc1e71f7d2490a008b43745030c9c0cda7c1e3eecbf9edd50ff950d2866949d3c9185f314b3c4fb662e5ff6271ea048062ed8398a64deee988d6a392aa013318d29a049593b69fda20199b08899997cff3926c4d1c0830d82a00ecf236b6a1d16d5d7b38608af89317e8cbe78f2e7294b7f671b5bb938ccf66e4262294b1cdee86a6c60cd1a5cf49f5e5412e78ced8223c611efffaca4de61bc17307a7bad40902898c953987140fc08f3899f786877c39c05329c591a276aa5009c4bbf978f73b3d5ab335ac7a9f7b6032d6b25805a458b097fb30f4883680355afd82b90bb6fb2fa24304c8003f2ccf23af09bce16c97668e3a6bea37581113f1c649ca0c1c0b4f1035b2e74e743a1c9f8593b8037a49cc9c2b45909c1272e7dbe80ddc44eb4b3613b56792f0c2d3a6d969eea541a9140c8bac5c6f4aa536e9a0f803ef960962feabccd6c18b1d533369b1b32c46a3ba786c77ac829fe59c95661058ccaab4d1e8d2b1300be2f6f3fdc7fbc44f606f9e8c30e8c7c99c566e9ffb64c3f4a9c88e444c0531c2639df7c51c8abe6e31a89541b04499715f9d07ff5af42b27651c026263c2763fa4e01f9132f1d59fff82efc7029592168b8d41fc10a654051b9d3b4b1acdf99bb207717ba3778e4f98fd4e4f9b4fab879f9ffcd5aab95cfd47849103c5cbc68284d6e918f25873d8ea861532c8863d4d7fff1d5f8b9c0503264f5adb57ad7ad65a38f0dff192eef96fa854c2bd4ef442a93850195826663a632b33492219fe8ee99cd6c7029a70673184f5bdc54f7399cb1f7d5125f9cee6935c004b63ee13c33b1f249bccd0f3d5d157a8efb5db2fa5c38b222f603018fe46d8c55a1b980531e9b7dd747e01b300ea209d8eb150bd39d8360d46e25119d0bb77e3d21aed203d4c21fd95c357a5fae8d6639a328aa80c4867d89c5785bbe5bb54c02b1a3e33b7664ac5892931d9e2cb89f7dbe4467556179160f3671e0bb3e3b9f5906a1675028d21723f069b97ae62347669a85d3e2b490ee5dfe8e421d9fd979151ced3043b3825b622c7713b55e29019aea4463d6ed5efb5112731f688eb865989a3ad53de84d3d171dc3bcae741a057364c0e8038e00514656364d80af07d1be0492a58afe342b04d77a5629b43d5b56fd21565812fa75ae166552e6f858a3c66ad30ee90e34a344fedc0c668f2e9dfc7f53325d3a03d2404738e4fe8338049cc42594b456457ea2bb1342b37bfade20d71f79df1ae37e5eaf78047f268abbd93053408dbd6a2be53fd1b54a18b1a753c9e87fb6c8ae2b3844486cbf06b00eb70ac65ccb2b1ba5b2579647d534eecea7ab1331cb999db9fd6691dbf7b46e340b21a8b0e89922327c360d906c0e29892e731bac1102730a537727641de9e221a97f867d7f73215d6318989b2e03f90a20156150bae787594096242bd60fce64d36c7824a02442fc15af08ead65bd8175e9a485dc206473d3754ab892a0c1da4ced09523c55ebd5b27ad46a984002abff002e8305359fcd939a99621f9590421aed5be7adeba75713f0fdd6e4fffa432b172a84926caf4026aaf5176e70d67a1bb72f425aa55a1383c09769abcf42cdc421e0e04c1e18f3869143773d7ca466790631d3f1f0e3101ed29650de4f7f2c72c8ff66c61167e2f045ad3f71c5a76c1d6825fc1044081d4f7ac686753863ff72150dccf28f917a8eef22d58ab06673719ab768f184777bf05ba960d736ec44d3c1fdef336a8749a53203fcbd657e177df5bbe77c67d4ce1a73dea38e2acb23ab6120ee9c3476fae30a262b4b2e928541200f5e36d77829efcd2edd0334ca932f678047df1b792581657726cb3c187c95b93000fe18cccb40ca8a0a1e49e7fea1307c66f6b916968c4d148805b1203007f15cd6944554e80219a0af9ca8e5dca7e1ec6c6974c2103fa699100e4901beb17ec92d30c49b6903aa656e2080d7072bf97fea47251ac0bc3564ab74fed79434a6c3a652381d142207f138f9027232ffcad0cc5c367b45ed85a6e92c33872857da65da7f0769087d8f51229c3a21c9ddd0fba165a04815a7722fb8ecc769accd6b566da5c552719ee51191f5e478bbd23093247f243e5e3646bceb4a846dfacb8b7bde737c1bc3de0f8a27b3cbb2fa2f9e3da97b2087515b32c446049a1920034e06de436174c42b2e575df7e229dc88b08b7b1e5cb05c7799e2e80499f3fa4ccd084d27a82d010fa80243784257c747e34155f265326a5550b6f2269e488acb0d6b0d57923486638acc382656fb185c0010cac40c6b3a761b96773a46c8ea61aba6e5b14b714292b6e205d77ca40d4ddbc1dd41fa67bb8f92ec9bc527ec9f900ff759d117b1e64606994b7746ec34d977c3c02793840c1ba798b76cfc4fdafdc0bfc726a272e5878322ce9da5c5a7246ab9138b0e318b6dfc6eab757c13e5dd36a29bfc51e7e89ee5c63096d3392baec26aeceed236b42a53179134e017b41d1cd417dfce3b410824d10450e3cdfdb93bf8a7e646217539d049e8a0bab187522313c51b3e1b77a3ec9e078599c06f05a424c4cbb5878bbafdd2c59dc0deaa3108f2fb4dc99ab162bb543cfc05b53217bf62d365382a0715b6f6ab90fb83efdb67d27ee5e847fbff0472050d43f1e97b89d9874546f5a6e770dd5662bf20cd1e60c6ce914b752b5caf65ebc2a648e869ac7f2c8b4ca3edc3809f8aa319b1ad353547809a080867058f4c57071ea04e04b9d95d2f68d2454cf936afd0c4f2e732b1126b427957185d42546d1c8abb0dc4e61048447fe8b6d0c2444503291c5da284d2e56090e0c9bc895a5c0ff2cb23fe5ff338fc571f16029454fe0e8851beebc473be0b9557d4d6fa34898a970b37883d5fb1b6fd901f25d67a6cb823e1cfb663d00f1afb69e23bf6b2940d9571a85d821bbafec72d52a1b46207370559b6ea5521929fe6f08a2fbf9eae268465da1d77dbef611f3708b2eaf14f1a262a13468ff40c64e78e25b2f79f2078040c25504083216284288aede73901911d56cfcc0f93530f69a2f9325603b316bd5d054f64c074ab4939f0014fb5deda3b7b15631c06d4256e4df2dbce71d95176497925f4d65d29b1f6f6b29f569c5d80d7bc2120cc2e4e026740fca2f27b2d2162ecfdb8e730a9104990d3e216924a000d03d02c5c3242e4634d6f38560c7616197d61bc31d1eddcd5bfa3e07abbc3e122868068e7dd5fe2137bfad8fb954ad9c6345576a53549e46d2a1a2c0228c2df7c32ed5b281f99effa7874b6adc4a6ef6ea99918db3f05945402e0e5eb4cd5b252eed222b32374da216024e8bf60dfa55a1d73fc77e3f504221867e0974cbc2a163afc101cd8590f0d71fa4d04fe0746551eb584e192d3657c7d7bf589c2bdc8b4d0e0f95660592dfbfa4c9a3f718d138a2cd43653ac7d87f92170f0b4c57d95811e10e36b31f19a6475ecef82761d7ce65e01304bd0791ffacb263ca4d15660197aafb1fc627ea1f57748f7e225f28ad3d13e91aa59ccabfaeb04e32c03f5e1a6bb1def722a49b880216d87df8d6bb52a746f6185a509c5704cd8e2264c9572191880c65e393598ea864ff64d21819b550c21e5157c8e8fb2b3afb2483b5fcd441fe5bbf127256032d47a76cce77423c229c51f89ab377655878621f59ae9bdaff9d47f9e4f5e74f246dab37c178162c62b57b081038f5742eb6e38f8c0758f52ba2978ad92c6715c2d77c04087b3b8bbc122aee1870c9ad5a5d46c4fd333c64e417c674cf6f948c6c6c8d76f4ef24d71c54edd57961135b776dcadd85d4d928bc99b3a3580d76934de5ac5ee25427d17ad50da80ef11edfe055ca7f75919e71f15011a6ccb7508a9ab354bd8969b338f6afe4a9a585c3fbdd6dec2dca241128ccb364300ca19656da308429f2135bcd089132e7f503b97052544fdcc7473af27607e8948c77929b29016a88ade651e0efd0db0dcc838e3cd2f60f96c3ef61438d6f2fcc3efd2e7b6ea9272d1ed43e392633b0d11133b1872296d73c03d982e2d138f5623a226db3c9dd3b64e0c69252443339989b75a3ba72d3e97b5cceb260abf085d67db3d9232a1b77ac77829d9aeec1b8337b7027f2c9fab7abce9ff0e738313d7424f66745d2dc08440a80aeb9fbc933d86682683d50b587e47a88ec4084446b692d00e4dda6e75c80edebf5bc47660bb2b8fe696b012a05311c0683b94b5ea00283a9a0fc60b354e9e4662609420afbd902663e72937c1aca17bedb7eefb86db64c9e10bb232955ec377a3f5f0195b2ebf3d659f67f710b162c86f07a568ec619f39f26aea0340fbd49403749710a0c377fae44de751adc90c912e0aef561bc262830d23d45b06e8b72203fd79fffe9eb4b73561107f8291c3b354f188fc9bc3c991954f07275d4c225afc8a0d8b60fcdcc907bad14fe8faebd291766dabb50a21897714e8d9f6cea83c45607c0a0edfc34adfb98d956cc40365c32a226e0e573f2a413f1f76fae9f80deceddf55ebfba326456d367d389ba93d6c8548d2bcd84690c60d9e2413482ee84a55c962352726018658497e37496122d684f069ebd36ba9c20053d87baccfdfab4bc0c0be8cdddf166e2e8ef7bbce9b7bd7f6dbf89897c5cae052a192e07235a328a98bdd24051b01b9c13a35f963a69fe9445afd9914ba22a9c8376e001ec0e58ee43ee9856eb16d1b8a85d3e9b5880367fe8e58e8ebf3079bf697c0b3981e6ee77acad4566fdc4bb8a9415a8401377180a97973da2753532be9325df286ea7a3972d6e25b16ad90d0ed5874dfcafed58b3f147f3193ffa37d00289da96bd03693837a405a930f5ce787fc2a763952fc57fefaad5923cec2b43d9e4f0219b41648d523259a2d2c2e374cbb82b42d5eead7fabb8ebaa04336f6045985a996939de1eb9c2a6107f395a419bb2527dd96b9cbefacaeab55fa0c8482591642b9a936d209521741a7fe0af314de0a463a94175bd8b4434b96b21ce7ced625ab6cdd9338086aeeec1e4fc30fa9d9aa4a9f84e8d95f55fa1736b578abb6abfe15cf5633f23303db5aeae5c0e2a51bad41775dc4a5ea3bfe57376f14982be66942a49852d4932361f5c4ac21484bd4bff2be446e9d425f9d0647a4d9dc26458887b5c6948cc32af23a77f5cb31a2b23a0583cc94059148509df1149006d3b46ec4498bfdcfd42d7d04abc73181c411db500e2e627805c1fbdaef30cc9ecc67a7ef2234e8954a65c05d9845cff3749c7a7637304b8646683698151e89c0c70607455f26a38ec27a8863d243941d17689b778dd45de27240ea3fead63cb1c92e8345b91200bf64984b6c2670bf2b6d0f617c17d774f77920a2ec8026dea6cb22fd203ad2c211e9ad3b4157742bb465b5daefe39dc2da8431678c664315f6987266237c9221c09e5d7847a5f6744cc345e50c136753ca63deab01c40037a044265fa4536a173d1281fb22e02b962d6256fca2d25f87405a55bb64010fcfeaee169384238ee7a6825b96fe745f5e5ac818a5bc2557356130b5525f10e294f6633a0c2f56ce66e112cdca4ba7c84f5a0356c8a92c895d1318a7b2a46c7cc5f19e4b4edbf46c7a0773d9650b9d41218cf4b448001cb9d6ceac885d2e2c503ae6ec8c64a6b04546fe3f8ff5f010219548f2edd4d5607686bb134b55295c7c9d68ea1d0c161b8fe91f2ca5f78421640bfd8189ea728cd7fab358645685cc7b88ce6ef770ec5dd635a24f887ef78d0149ab1a1b9c8401d3dc82725525c604c8651c8b6272ea47399b38d328408c50c9c02cfc98631e8b29507bfbad3d1dd4e5ccbc041a19f44d060b3044b01f3756ce010af17af9954e38bcdfd4bd3bf103b5ff3c4c870781f79fe4bd33e0e28c004e7781dd3286d2c0aade5ced1619d24625173e7a32ec613702b10677a2aaa912c00a3bcb180c0064bca3ce6d7a164d3ada016747edb6c375b2239ffa2229e3610a1e191dd25e3ff061f0e16e6f961430d3f6b528d801f83b44a504ca22c80e31d33934dd28099907d2d23df56abc05b6f55cd5f5c4ad46d87958f6d1df7fdb0c511b86faab59840cb36a12a7ee11f90180450500394c362f8c5154c3876739ba18630c68b9167017fa5fa780cebb525f9a0ca560eec3fefab9edd1d2e4f03cc7474c168a58ae0ebcb07d27086962b5531e1d49ea60b194e77e5d78759220212e43d7faadcd1bb7f7f9ee01ef592ad9853b4c679ce1f876eea1310d12de734837b9cec2082031018e8ba7ac4e99098a08c031d2c9c6c0fc5761f6344c5e07972d16b942bfbfec8f04b994fda8685cff270210fc85501adcea45d941c8cfc2bb03a3935021c559be96e095e2d5c3ba5d06955deefb17f741e9df4cd1cd7c71b425f45ec0b6c0446c687b18d452abdbeaaf7e5e89c73f8d53821294a640100abf4634dd793345755bd82e3fa68b98b54313730c8b3c56318379562ff07cdb71470a5a1692c69cb3bf82e270fb7389853d5e479171dcda51de303a2189427545d5b4f74c7454ec4da92cb3fa29e30486689bee7c609c1b0c402138fc24370c4914726a410a94ee58caf6a7f32c0e847ed76b11e31ba4ac2bc498f9705ffd3301ca8415b63ed4344e1f50d9a001cd95392a7612aff107c70bd09c48b1d75e19ba0ee24472e885a011e0bbbeca0da7f6842fd4a12289c8d9eeccc6b56b49c568966db79cde353178e1a2d5016a2f00a656e20a23a78b7e8509c323aca9526a46c88223d7afd630df06d6e8a8927a896f806fb66f13500ab23671eb2716e41cd47c085af8afd55cf8c81c96b6ec52dc79eac5280868d4221240467f531cf8df5d4d970caf239aa8831f9c23bda5f3be4bdd972cbfef33fcf9b319374f06fe148f96b9a42db6c71951850b85d3663781900ca9590fc75d866ef35bcceb4163dbf840835f087a2b6ad6a960a5953a4f1085e9de5a0d7d43452e262d370a24f1db17958e49248006560eb3f0974ca35aeab7200095f6234988f9ec347a3764053dddb8604a2b9530441a00a4b27b730aaabaedbdc78aa598c3a1fd8d61ba887f8aaa7d16f8adc69c5260718a4b635601556098a64ccc24aee58a09b6f532f20f31cc0d535b227899e970a9e157c1aa2f685d9d9256237393f5efa049b441e699a54c0a1a548312e7dd1281adf4cc05777e1164918a57ef5c4cd15a13aaa69678af0c26318f12837d902c03d35632274c755a5ebecd943515f19321d8db3c0d9f63846a231880378c028e2f8e9f7ba599cc0da67f74bd09e6baf812a851cff01e61d93aded95438fac33f1b397cfd3262de784003072eed78807a3bb99c508709c2b49436b6db5cd21d10dfa6c513435ad54c6c8214387dcff06042032783eab91601b91264cd20bd8fbd894f2041b51b2fa88e7a83399bd622d27503205d3e2d95e537a2205be3aee64db1dfc3e34f256f0d87523f620d4e8e8a94cbb67f75eae30dc459f4d4c58ccf9bd9b7e0108fa17cd8313227c50f1a48bd18ba3314df3cd290e033209df198fd1608f508cc130a1d12044348d990a1f1863056036d5b8d624e3b8202317331ed0351cc2c1a26e602cf82257750dc8a5d74aff1009617ec1bc186d4dc777bd04831b8e394496bb01b137c338301fbd3576ccfd4f486646e78241622db14ee18663f10bcecdad75e28b7e548812f3b4f28358c4635befb96ed17c1ac44b5f8a72cb299093df97f5d20313d56cc7face855f4ac16e1d9b161b7509399f25777dcba1e1578285fc39ec371bdb4de9c5ef3430666266b87bbf7f7e734a5a1dcb7208a2c00402f7880b29442792b1af6e9742cbcd1a6607a99d8c3eeea3ec2c9ffe32c517d50cc42e0039243b50ef17dbccbad6afe9ae8dfb66262b9034e63588712128959c7b3380dd8fd1c9ed6f4757fbd4f8bb1c2a8a7d0182685bf1ff5e432b9ec72e5798f8258345b2a425ec66d22df8490fb83f1fd96f3735933296e7d37693ec0469d767c9d4791102c390c9db9a7f5744f29bc3aa2d86623a555874b27971acce8dbf36ef628da5fca18645b7e22efd1af817635bafc7e07f04b17a55d451ef57c68c0ccf9b03977260875c591d4b503c583b942f5ad6ff6568abfe9eb23e1522de1263e73ee6b8970cac0d9ce7d0a6315abd78e036697b05fd856eaa4ea83c40aed15dca712211a099283472f06460e8ddbbe954e3acea80e7647cfc2e3c9b695c2193f769442d87aa01d04e674986c47327c0af4f35684129d7fda671c4177af6123ef5f8ef4ef78abc3a09f41e3e80d3879422b9fb84b7366793506e4516d94107bb9f2be34e5d12ec3e9b25e29bfcc2d82ff8670cfc5974ccf7f484292e04984c794105022507e0ab0859641bcf388ed9a8171ed7e894a0c915b0b7c1e777094430ea8307306085d6dd02f52084c8e8d7de366b628d5a24bc6098783a712efd18fc9cf5d13b5ef2bb65f9527bfcfadbfad9292ad55664c1398c134a674bd9e0d100c2a1dca67c243e237aba9c95932b3dcfa72cbaf1542f5df15c6df1c4dc147eab8dd3309e3a063ed031342a4deae77d13124982790da315c774977b7c31ba85169e81bba416e03183887a8a733aab4a447f9fa052182e99c74ad3599ca98191b55422b814775b32d6d7580c7ecc559fd83908ba3769a91cc7d93893de155989b10f96983b2ca9c4f7b19ca722db61908675063ffcf2dbf05363680b2888929e44b7892f8436fda626a31913d1f85ecd4def24b7587ae807d5bec55cfb8c2de6df32312140476840aec257b05b876b9b45690332f277f88ba7078f9c5d50a7967c637834cc6b11a83869a9658dbcc50520a6c607b5f2b7e921bb931553b5e51562ab29ae36ed9c0e430f01b106d249fde0dcc4ca82d0bab55bebdb68c2e3f84372315180a8fe239de67f0dfd49b49ff34462ad8c9a90d295e5665fad69f8e3cd01b31d3cb624dc70ed5955d6294b355dd9ebae48171b33788106a0641ad850b764eb8494be783e08a5306ef1eb9473d693c0da1109ec80daa87abb4599948ddc4ab84a11cf7c0f477fabe41693e3fc483cb71d6c65c9c6d3aaf48fc33d2ea9aa0ba231e1b919f40eca3a3bd8771f84a24d6bdf2d882a84ec8d82b02ef567787beb0e4954cdf57e4738214b5818f26d7511d0de5b42237a19e7c47794a4b7348258adb48f612e1eb3f47ee7d1c8f4843477234951d53dd26b8317b337a7d431ab3185494cdd165b65564016dca7f7e932862e4958f7a71fe0d9437782982b1e4331d095ece3243217b9a08aede3769e28fd5774ce3f240a1354f8e034fc892ebe5685e123ecca501e292f10ec4b3664bf747002fc0312662f578645011a3df214a5dabc73d76b41bb61b2fbecba7dd0d2c3125b8ad9dba84810640c331219d97377fb2f0c039fc7e7dd17c63b502c3361abb73242113612ec97a27cc0dc59ebf5d3f863f54004e0d923bd0a2c412ffb0456066eef1d1514b8804ec5ca8d2343ac7cf00c382d9585700ce4a26ab5e57bba63685868c24a778121e20591b700a371ae1947a919e65935b0b9df914f1d6dd16fbc7eb9b2dd388c0e719c71ce86aa194cae22ee291b172ad90fae24a7b3c671f9d324e2770be011028171b2163e9e3af098139fd245ac819fdf3aebb54724878247c9d0aa7f9d8af0b8167a3cfd157be5349ab6b9a2116980ed91ec300b282af71855b1cda31b29f793cbcc098316a32c9e533948fc8d8038e8275b6dafd0e9bb783140c15a57b7fdab7e9cea2daa82b929f3273a8dd8acd712d177c2cf297887d36928b9cc45d0a743623d46dcdd712289f4b1e7873cbd5af5a0be16cd21a6cd2cf4f484388d8a6ce21b9e8ec6990b5e2e802ceb83bf95a190814ea79af7720f9a4a9ab117ff9e389461f241abb9864d6a9ecfd6b918a8aafed6b8a42fbb438ea53e821740602c308ca1bf850d3921e7a141fabd12a3eab659ddd750660e47e8a8b9fcb2a79b1170a355d5ee43a4dc8e32718e05fed856e165bf9e13a7ab515c28ffc900e314b382e41b406a7abc0d2cd5c11e892f3a33def2f55679ab49f110e2bc0a26ce6f240e32919024ce94f4cd884977027ed637b4368a5bdfed090647c1b99bb8d3587e2d85a242dedb694ba79e2dba3f195276ebe7377af2c43332d6c7523299706e2669ec7d1afce2883385fc09e808554e5e59ac2799db9694ba1c57c1c3508ca6609f12eff2b543e27660b085819d4f35d07d09f3118514ba6078a24c1a7ac1b84c14e7ed9eccd5fbc689fed7f05bf7a35b0660dd942440980dee7e21d30f4f3c8d80d51635d52dd1a4d449d1d344b37eddfcfb365306ecad2d6c2f9d314d0df4905b1c939461d8c66612cd493f08a4da74bf4d3081ed5a7747381f52b6598788671ee42fa8044196414608b2657d4f97b0626872fd600f59f39b0f5be978f5e5dbf507c00140bdb6d39fe1decd8d0b8a0ca853c3208274ca46421c750c38fef6d50f807a2fc37ae1c73909a1b0f567e69979214bc736d1ab9846c2c5e813ea684ed636b7c571fdfcdcf4a08b365d5c2e41c0b1c49f8bc84f7e72c46b4844be1f5d65ad60490eacbc14b72c3a168d54d430e6ad09f16774ea112f04ba7db55f8f24b6ab5bd63202e5d1977868ad8806980b1bf865f28c2552c677f861f9e39cef454baa00e2043ebd84721dd2476c99ec9c6a5a9e1c48873985e254e974c093f706dfe053ee6930aca89258678c13ebfe9c0facfabc5157f02a4e23479d0a9113ac6917ae0ba1cbe959f966381b56ff375794b1b373e4d1ff7a8d8eb193399fc500e7560d9999e06c4ecec89b157d9b17e5c7e1f4cc4bafab8ebabcd66e3efe392697aaa70661d1426f820bfea7e17039134dd8a607454c2919f78053e51b1fb275c6829e5b5a8fcb90a60e0872a1aee4786e9d3eeba15d3478cc7714374c72600080a6c72d60da3b0ef85985d222aae11a307574c9c067b17f70a78b76e4c6895e3212dda97bbc347c2c428717b43213c5051939511804feff26741b2287f481eccff4eb32a8059589a8f4a1aa4fcf14281f414908761e8d56d4c0fe51d59b13fa0822288aed430d8d517e95808e9ea4ae809ba4efb6959ba5a4c19aa6ccb0e9528642418dbf7323792de0c2774e8398bfb1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
