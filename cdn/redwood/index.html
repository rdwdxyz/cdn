<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba993709ac04f3fe649556ddeaebdc27b98e440428229c67df303314934bbdb3e7250551ca339c59540f02b174538030508ed974a9a6e7942d769d7defbd982ad3a18ddf007c91bb76232bdf98d064d70d456478d73f20dcc2ef5ae2b73b4fb78ddddf67872e8fa545058512fb0a2fe7a00e1f4f78319965e5bcc56adb445523f037f52de7720db40c5aa51fd2e5ef23947cb554e09ecbc2b0da9046cb3da476a529091fee57ab51ee447f4b336336aaaa85e954aa9cd1140fef5461fe127aec3db128e49bed41640f4a3be453575da3d565e6f3ff49c2bc0844e38b4686a1853e12b996f84a5601e254e13d09d460fd538f8d91ab62ea6640ea032f481e37604a31159e968ddd716aaa04d6fdcc74d93283c80f24e5a024e04e59a7fedf18d5d86ad027b713f5ecdc2a1a5d68c6d2e85a397d77a6e355e08d203b655b6dc4035818db689be0da85c59ac5e2777e53e20694ac04466ef8764d43ccf62f7e148d5afe537954c322910bad2e953195ad77a4fd20f857f0ff83b0ff7f93690e2ead28ec1ebb91b32313e27154101db9d3b7a7680c213ad56cc48aa5ed20fd4f1f36a610d9dc56c35caff38d02ed30fdf406c1d0aabd430d531348c93518831e8271b77d0ffdeda8882fc54b2d4c451a7e432982bdf2a28421565684c7659754f42c04a7595d6cf716077062cd5f99781b0ae28326da035f027e573e4082e3346a2c2b5cb355e40c7f004f3fef842dd3cb7abe004b6b240ee46ec923dba6160b57095e723f0c543e7e903d6a3617390e412ffdd9d9baffda3d68da93abeb361d0b091f01944af482719a71b674d7104ff2a1eb18fbc13f1fc1859f17b9c813f2f74abb607f93abb453432f20eb14c7aa497484b03eefa1c29bf0d8d7de84f2d41926acbc4bc2a72a45b57fb5bfac8ce2e4e2ab281233e11dfb5082757428cef9b291eb5a7709fd0fbe9d663510ad79391f013eb0519c1258360143f2376cb3728fb6389157ca030de4e0890976daf1927b4845bf3ccee96e29afc66cb94c82d90a05dfb72e7777e86aa8d43d4419b9c2e9b89fbaa57455777b5cf16b6efb6110d103bcdf9ddb2dcf45891da1f785883aa97fb167e3dff64bff1d0bdaf1c39b3e5ad0751362b25e047f56012db0b66ad1bfdf980ac91214ef61f8baffc664e70b8da496cedfffb4bc328adfd8ac5555b467a12a503069f562158ca9a30b83f12c19fc55b58126fdc845377f6f162267a8c13f48658e065e3130fcb81c550ca044fc31225c57dea8309d3170a291df896f05f4a59ff611bdd3eee8ca30e6e35d2cbb0c9e99ac9cd612d0ab4097e8b794e834d70f0afa9f35ced611e9cc4e2b8380d46c05eb05555f1063594c8262a5d60b3e300addc38a779cc1c26da1ba9175d8fe4b72801bc9512d0055d99973bf90a503736a7fed02e0c5f19fdd1611895ac6d7d54ef8191d5c2654c0de2c0b3a5ccac5911c46b556df976d6d1871644afaba206dd2b759508ffd6dda8a5a6cc145752ec6d672ab37efe47be8f606e62f439d50134350879b8e51fadb7120129ee558e586a8b6b430a7359c78e70af61e1a8b01b8be292ec8a23bc0c2e0fb562a042faacbefd64b571e7c3b07bfb7488e45a11f0cdf1aa4eb939456a2169e1ee23e80215b3ed6c4aa267255611431b670980331a494d0af04a4c660337e0a64fe137a5a51ce42a5312f92033a9949324972dbd0a5d34c3d58e491741b18bbaefbb6e86cea043ddab2ca3d4740fd8c752005eb81413bd49254371e846ab32aaee44b807cfd483c19a2569a27bbd799448d774287a11a0124be32a59acc42b49cf8acf8dff88db008f1adb7fb298fe092dfd059675cac468e31d93a304c28f4d211497a6529c25c9740fedc0a96efd540f480e448097d368b103650357931f805469b5b09fb6f888afbe8858c12e17d01d0383e4956913847f61d662a63163cedd7fb849747e6df35b1738383dfc988eb512a1a0c0e6192c052d902b0b7dca1e158602aba815af2459461db09f32e2adad29ec84ce0999303a229164c84d239edccc679b2eb296572c4258625bd0e417ce6a63afc68a5d849f47076ae9838a0a5627dcbea0fdfcbd87e787d12516226af450d7147f74b425861eaf74fea705725a5708f7c2c4081041a401ca82bcd5ffe498a1da4a352182ee368624c7b472110edc1cfa29b11f8df37b1202832d57b519108871cf7669a75d5cbe14f5adcca99d3b94aad3b6af8911608b2ea8f07a33edd1f6aedc17ca8c0450e5867595cb97cb8b93a2fca9568af0f4916aa5cdc61dff72b14d7ea679f65ca32348d357655340ee80228f42fffa31338c89a643df05c4974849aa06089450b68a5bb4b2f134faa7b995e2bb50904e04e44aa643aaee8e6dd9a9e782266147a61695c60518e76ab0419ba6cf6d317df937ecdcb067edd5d21dc93a75e0074d46f783b67828bff8147e47df2eb14cfb8c9c5f99903252ce20bcb9af02a6b18511ed01ccd2a82781b1d20ef0112d3d2141e77c58fc6f32f6bbdc807058a565a105287a1df971a77d1c400b73da69c1db62898b7d66b013b2319ca3ba4535b0e5dfd3920b11d97f32e2725925856d6b294904a1f6cbe59ec0bd35f5802e60ba356073c04f1b9c3a28d97a398a7822effbf9d6e69f44db108e77941dd060614df8e6965b775f7dc2c486037fbbbdcdf384331fa38e357ec407593de21f78e88f10fc1fa0e1e536b8d1f43ad44a51470ccf691a6cf80c7d8885aed6a8d7ec29b66b09bc6cf279976e2b46dc1aca1e0a82b93355318c5ee7a368d39c7eee00440256375d856284978fdb2aaea143bdb94d6c1aab678d09e051d59630ba6e617db16294eae75f9e06c9ec42f3c7d0b5ed2e1fcf96ce3918559f65673c49b20c52c9bc0374aaccb77904282cf2722d28f56832a6c1e8bbe6a72ac7a2474869e55954cf743e5d7d81f1548b0776fd8bdc12d64db5799d57f4d4b8368c7d4c25c3cd910090634ee7a698e51c1cda3ab05481976187367125dba01801de3719d52f0b02bbefa96adbe79fc9acf34bf773ae19e764a222d77ef3b09754d4b6f9788831ff6dd62a1abea5d2780a6e2ac0106975045933e4e3974d67bfbe3fc909e7a698efb1e1272c8087923eb5c8d587ad5518d68074a2788d6a51160ad80f6dff90fc6e57ee6a10084047c5944cc02b748c76af54e7749082598571d2400bd6c28d1d2a9bdf1fc2397c777dcae0b4925fe30166af7271927dc51d71c9a3fc9e38e16941a263342924ebe6e9aa965cfd6a1c860ad804a487a3605d0e84d3ab4e39cf830e03884b6e87cd4e01efd9827c68520fdc70742dea14a7dfed7193fc6243dfd9ff9d56f8054ffb9a80d32157c4041d3f1726a960ab87b4281ff0e9ae99b16f0776ad3b2f732e739656020078832268ae6100853b2347f531a7374d005b5e9ce95a72963f04d6d6e219c57c60639f196b6742df72a63d00b68ecf3e6a7d94420635203cb32a337128780d7cf54309e598e49632e1d7a503f9f901bbe7ceb6c7cd91e2a3b268885d8607ac00038baaf7acb5857c21500cb94f293b8f8dc3553dd7500bc1099f596184abac3966f23dce9c6b827eee8784e07881482d1326058da9f6c09c287056467799d096f47d038f8db0b13efcaf85b6dc7a079e5c1c97ec206968705acf4615b365e633057572a39217dc0c1da720f3e2cfcf315de48aa6556be1bd83491bef8c092890777559138b5df0108f93c96bc8c89f366902ca5204eb9ba52a8fa990713e7cb492d3325de0a39b6e3a3c2ec57170fd35543822e7e6f52cec4dd698d807dd1cd3f693aa89a46e006b70825a7243278f306b099471b2bb46a7d2a7cdd8f566bb690a0c9fe3fee8dbe123001d9af011fc5fcf3266e346a246bd43b32cad5ebc05fa9a361ae9db191ff9ff54342a449166addd43eaeaf5fccd3712314c87c7c4dd355ccf94a64146f9f37e820ea0ac0e001b7b66e8d0ced33319ef3cee2179c6966e730313e023ff2927b4443e1c3d6848bd4df8d83198ffcd9a1328517a8e976b4bf911bc7ad102670f9eff7947cfacd56d50ebd458119f6bb9d80a13e445f25d9cd0e46a97d338ae4a03e36d08a965401149bc0b78b89e2295ad520fe5784ac4a242ec563f29a5026f9c18f33cc6f531cc5a0bc5e93e96eeff70ecbbabcf3d85f971e288ab0376632ccd818820b04323b11d86dd92d1cb640bfd53e44fca03ff4311db91a88efbc67fe3a2c7d4d0bafefed7efc9c97bcd6b435e3436cf7422a432d21db6cae169a46d20ba2f1de52c997f18c3bc42a182070bff0be30c343d43b30bd225e6018c816a9d20974d94de8b54bd4ae001c7c5126650f5fa49d63cb23b3edbfb33bef214357eca4ac1a3a7c072577759a4a11dfff7e31d3cae76c0703347a58a41d53c39f8676c8390abfd54a495d55bc3349e52379d630745ee61b5ab8b1ba07d4e52a1f3b6682100d360aa3cef4640f8710428737f00525917f8b093e6fbf471006c6913d85771edcce845f7f3e8466b49723ec739f1c58409fc00078a6e68f25593fab6cd872bbfff72658a532a04068ef6fe73ece371db5ba14e0f83b238874b9ad02a907cbd0a617f981bb3f6b8f04de000aada7bb009d3fabcc27e6ab7c050cec07f140b5c9580d10fddce2c9b0ab684096713810129ce595cb478263dba0f96d7e51987747fc86cdf70a3a3f80f81d53fb54f5c091c05ea5e78f4fda31f586952dd2a6390bf172992cfe04207409326e45651e49e321a48bced6db8440bba60d700b2d2ae1baefeecbd14a3b36c42a9989077d51bba072ca8194cc71cb9a2564dc3299f87255ae1a557b17f4df17160d9843dad40f0944b2b8a740af5eacc672c18fe5f6e913556b0c8b285419eeac9b2de9b193a48892614951bf057dff56106cd50393a7737b99762129049b2d467ae91faa0dd2af87cec41a264ae9b70f5f8c3b4bbc71d625cab664c17028c71511cc031cfdb7a738f2fba61bf7edee01336cccdd5bec92f01aa4cb432b74201afe8ccc7b5fbfbb0a8b15ee62b372623b96268e9965b70f8d41f019672a34dc29bc4c659136b1251ddd94ec93addb43c3e1d8db5f99430218ba0bce365197cb1b80a10e35446bdd34b357e77fe49a0a399720fa098eed5720bce11a45c842f60e3841c39ad6c116fccd4917fd880c4fea04723c22812245460ce44870ea662a4597093844c8cb2b1719be116212e491c925ba97ac97b938c3c8a69713bebaa0a9568795cb73fd3e8f6d6dfa5d65769ad82147a757acf96de583f06cf871ce0f0b96f104abb6307e456c46c99912d5f2e31584a1f114b91d8d676641d10ccf507b4f9a18205681b72581dad007e6b8ac74a4d283efe27f086b4e7f3064345bec06afc4698d58a0a02f29dec32e09d272a1bb495fc2811b9af93c830510649f86a95f2b5c8dfdd870c0660f1d3f42e5c3a8a5f682dc032afe4dd68c790b2d4a66a6b2ff226d0db0c35a9d94e7047a493b8bc0ecf3a4968cf6b2b2adeaece7ecd426e4928501714d93c54ffe91dea4cba1da20a4a0a8214690406a2e1c15b40afbe7b116865e79f1453c44607e8066fd9b78afb1e4dad9d3f29db3c768438d1c1aa9d65505b18b16046e4cb8384bee6f851a82f67d76ce223fe35b3f629e3789ece3f27887ca5e92a120d30568a06f45f09d3e5426847661eda1e60a6b5ca47c8bd6765a75d68540b365b4f9093034d32e76ffc79e4589454cf362805679d17bae28cc37ac71eb741ff91d10b30418a33bcf711a3645962e769583cbe02da9e6f4bcc6d13e2f3b60e4552299f70578a371f4c821051fba54afbb10d150628d08c1af2a435d5437ced3f23304e31db2c366f5a45a3147609d85309a35650301906f6d41dfc5413fb1c5ff806f90ada4de3bf1072e75d889c76f2516b83e8ef57424852065dc53085c27aeb7b5eabef5befce6fe3a4365486f79608347650c877a9f8f8473841e37ec3152009c0aad1bf49afd40a99640787013d6932fce8613ac70f3b0f6c85ecfea124d8350580f546ccbe66a5b403f17d8c72306852008c577185d32800c33d3d067f475994c26a3435e4bafb24af579433da153ba0843ad71adfacecbdc4e629ddc4a15c553246e736180d6d7e67ebc758f57b1e9a101feff0400e26b0833d443a3eddd59a9483796ac303e5c54d8f39565a92b89bc8b82f984047030340ec4e77bbf12a095869895cfe29f503fc5884724578ef39b9fd942bae734a7cd46e1a4f01db67588a4262ea393df07dac4e4153c1655f109eab47a55d2de6cc3ec7414cd937ed393c211759515b2efc79f3547cd34db0e147d9cae5964e1697fe4a553f8ee128424a57853eb7c155aafb82adf4e624d608381aa25d2f51efca79929a71db38f2f60d1bdc0bf2c7a0625952571e6b61eac5a71c3390a720e1ecd12640e4c51eed3d4b83fc798899b2d75735cdc21386d776dce5471309a11a7b619114e5160a4deb805185e70f5c40fba1f6ada12cc2f4046289fb76d765e07c0e8e985b0b4ce3a9d6b14805c1ba4d71ccd2077f8a2c9f4bdc632254641021d1cbdd6e42e814c7f64d71009c0adbe26712676fcb94136a51ad9853fea3924347d75b4ddfb73982b4da062aeb189be4d84d940d8dc153e4ba5e7bcf26ea3ea5b5049ff069d9b89738069ed974cc3c29d0f44d65f37394bfb9b587acb1f19d78317eaa738e530b3cc13a5e7606d78c2074590761fdd4e49cb3145ac5d540fb33b73c96c3342cba6b8423cbe9e66613788646d8623b41b47a9802776920ad03e4dbb55e6484e9d6368944b505464c744809b384ddb292e7c3f7cd04ef50c9a44e02334a28c8b1e6a651c40bc36bc755421c7e163e411a844dd00185efaa0e612b408683b9968a1013a7ee65092757aab9af125cef5ea6a651e0a701b857f4b53289debad677f1dc734253959b4a1f06c40d4890a37c072d760a3a1dafceca655b0ee5a0437fdd1fce4f1ebabfd18d16ea5640afaffab86f9a3ded648f154d5d8dc5430243b9f31f714cb18bb64189e6fd5ed94ed850567ea810656fa1ccf93fb031ccbc4dda2023be25fdd18407e6f55aeb603afe4364f5a2270347690e2286cc669f5edc64c84b48b85b8511a96ab975a91543bd3558e7e2e61bd1a650b2d4d255ae18baca85d4fd9ff6cb05797e6efba24c8be6f9f3d71e7eb09143c179570715100681bc1612d301c58d861f6a2e2f1d535129f794f056a3b3f23bb4c2c22c0d12180c1e189c8d443c6758eede0f14ba73fd5031bb2d922892c3604e4ffddf74eaa58abba5bc55a1e7ac138906d2ed4a746960f8481b36e39579593ca6b7a2ea75d6c4d7be0c4eb30719b9165f572bd4e68c8f652618748001152d3c0e835a1e9f6ddaedda4dc29e2e028ffd89b859edd6b30830be1f5a5cd1db6023e4baf486f7e162ede0f141f9c82543202803c1883e53cdaa849bb292b042ed477efbf18c5dc9cbb11931e5c092bb71bb7e2f68a7c463b03c8456a35c7cff6705b3ae367cedd57fcb1a3a6bc1008014fbab2177b79528a99a615082104efdebc40ef370ad159bf9db67d5cdfc933585ed0ad1c281731786c6d1f7d8c15275ed13ecfea87a1159b226de1b1e04afccbf18da1b808ddc82c941d3d0ef800bbc91646d7f0ce806698590d2cf40d7aa6fdbd168af5a411ff22b79a4186381d5b19a4a3777b7e6218d4fa77c1027f13403f125dbc36293362e60ff9dc8f1a5571a8fd827044b6e7a577aebade6668d704bc74a2c7625e0836380faa8001fde809242226da73d5b7fd70add3cbb6854c775aac1bf1d5432d0ab017400ad6b07c272bc80c5348df7c0c2991e155c5404b88394d522dcde262de59cfb709587bcc10b2298287ab10877d9fff09f5ac1de21cce90a21d2b212d89920750e2717f34bf7a0e6ebbaece40894d2d7b1988a2bf9417baea77d98bbc32eee79437a1b4f275ce510cdb3cd86810d1d33f569acd80b7cd0643a4db3d6cda47d257a71a0d31df7d18dd76e2377eeb08e95fe373c036de26483285179923fcf11cc41f67dc06db701ad88750f7f6abc89a6e100204347a57f00c3222e36f43c8a89fdb74b01f7ef06b6a78e152b6ad746b27d4f9bc42b50be221c28d5ced625bc5ade4a339bc9f00e89666bc3f86dc08ca349351dc4d63ceed887e3b9f8bb0a997138408784fc9341df7758a792e7607273e979efdd009dea034a0cb58d21cf3fc149e7f35e0f5d405815bf7ee11058f3f58bf89e0c1496a5daae73a48b245637fc7d378c43ffbb3acd3e96e149b34c1dace980ecc914b2b3e88b83106a942c10d56f885f058fe8d8d15d4c767e9a520dbd56728ac8269dd965b5fe54332185253f1393009432280ef85d7281718b08bac0cf62c720caf3975627a8f5d14ec267988d800125b3197eb04d4b7c82e57729ed5a622b41febe4d1831db71c997cce9640dab58afa7b277a820afae7a1f611f3c1cb7781183999a3fdbc3dcf38d64cb1c12dbbbc1039a8ab26b48dd6fe20224a0da85963602b6e7dea1bcce7f5e28d7df80b538c5f645f5aface3a506996c58f299d2138c7be3a8899c1569f364a8d1f447b828cae179bc6254d9c8c9896235b88c3a441417cf64f9e4446d7f32a156e252a7f462073ba6b5805bcd34617b3895662543676d290a5be49942d1256f47e0de48284428d4b6a196ba191b6ea08e3f1a7fde5031ad7b12f7167af75dc1a5cc2ef593575f5bc515a8a3873d1c4416dabd3093f302cbe4171af2d584817859c07d16eb3fedd57354b601222a81cc0eaff4e92b50a0478a1c04d766355110b2ba37423f51a790dfd417758189ba28b7fa0284925d44df163883f9fbd6c14d97a5365427073430774cc30b822b975a5256903aea2db4a514b826c1ca64b9512e9a5c4a1270aa687f9e00ae33bb1886f47875591be4970d3af435a20ad43556000b95e0da03599a40207b4f4ba325c8c4e40caf53499eb4325b4c4eca08c417d3685e62f203d11e5379d4fd15a123a94428729f964a32970391fa0ce7d70178d034069e7174ac643344d1962088db18f7fa2db2430dc18add7bb90c7d89499cb5258b365c142499cc1e4cf7fbe86974785c73233e41219e2c93df5665511dd242f26ea9b17e556aec87236d21aa17ab4504ddff0543ee77968b584a90a3b15da1c686275983eda6dcddfa5ecabb2fa3f5dbd107668508ca04be1688ec9d2405c0d39bb838153905e353541ea687d65083e6907811977cf2b31aac3579d8704e2aaec665a3aa9e6ba6c58ac3df24a8d4e7a9f79974fc4548ee22b6736c09d09d655516e51ad0f5b5a70a31da84bc42d82dde9ff14894702ed6e0c4b12320c66d40142b8b6ddc959b640d93c4e5ed7af6c178727bdf9a6b0eedf0bfbb54888b434de58778ea202857fd76e2593554692f858cfbb4ab631af186a8affff6614afae85cacd97ad4251b9870ebddf61613c1becdf67523296c9cc26ee5e79918f1a0e8c5d6565b1972b1766e749cafea41b71292be4463f404ecd2fd1168c99b8ff6cd51351f0c908f2ec7b976d2d56af2bf51060cd274ae42f4eac471c1e0661640b82a1372b8c96a71a657255dd9d90ad7705106df97b732b40d9d0f3ccb5410d3d9599d6901c838b43fd940405634e15d0dd1ff194043b9a5d06c27d930e292374a880c7316dec491b4694084772b0555ff38a694ebe107adc816199a2e493b586a8d7845a26fd222a27759422202d678b5761db8641a45ce19f46b8d9a56c8b4ec58fc0e4b9bc4bcd0f14708b32420d9e7eec62312ae1e186eb8b4b137abce0c50e8f0cd198fe006541d519c957d184c04bf0a4a59263f2098c5de7d85605739cd3973903b374dad729d038e1ec85cdc1a5eea9da3ccdc52f6622a78e7e09bf13c48ea9ca30de632b8f51185f6d8daad8911e69dc148b19cd1467b301da829aec4f9acd0690f7375eef79957a9a57d63d76feecef16d3f7e03d0c737332eaec7821d217e877751916e21fab41a90dbdb0a29227c5b9c61df79512ea178e120a4b177d658fb974f2e105321dd19762acc56373066162b23217533c04e2d86bed966b9d2cde92f97819a40d9e804c076d212397fda6daf69de7d2cb324c1d06f63765115d3cc47f1a34621f8ec8787cba95e071d5b6b206db896d581734cd9f2c945d6253f5139d0412ff4e8511cececc7a356d4ef4c9e3aeb24ff2bdd07a2b9957e1faf03f079b4dd7260864cb316908377c2a42ad75479a62c9060be13a4617f2b88eae7f143f59d4a5f1fc1b201a5b7d8df210857d647a89205144a5885b95375cdd2963e2cd7cf2f47d9b4107f5d970f5d29ea492014a34c3b958a33d38f9b156e541bd99ab7bb1fa891340f6d487922b4ce1ec712fe02aefa3cdf5ce51dc099bdac6e2cf134224cf5cbb9eb7cad5d58d17e5fe1c3c5fbcdfc4ddbea04585d2c0d87caa6a1ce6b7ce8b64ef5500e68f71dfb9ba57489cc3e3a137d6b2d039e9f890a65cc11aae055d10874b76c7750abaee9f082e7560f323d706af595535407d025a14f67c41d6684d2eed6b983ee11b83788d96b6724ed64448cdd9a7a23827c4e4022f04a366c8f888b13440fd309f3aabbb19e988ece862a346db02340c8c79f68673758dec4463f1777db2e9257b47cdb69e1a2d5bfb1dd5710fc8ebbbd96e66de0a675f03c497e8be1420b4623fc907ba0f1643bbfbd224816b6e49bdc3fdd2d66e2d086104bfcbdf13868d7e9d6ee8aff5e0071c06d9ee1e63019d2b4f0572f62f5ee94919f46700d11139e3c5082a3add774ba83bdd30add3aee2525b930f9eb2e733313039de692a6196c78d8949730a129a79db41ccd06901cb226916f4517de9b229e551a5c4137f4a9789b46679a1a3337d49e73e0e1a6e3eeba35393b4e7964e9bf88b878c56480fca904e1f22ab6c8a233ce1e3760afeed5ec96aa34782727917fd41eb977aea3f87fc29729fdff864b8a2c1d4723f0fdf8076d7b206bcfef0c03232f9404734ddbdcf71f279a40d5a2b3fbd3641f704afbdda090ffff49e26e25a99bd4d2198c1716cb049bedb4c98b27dde6369f632db63287a776532796d7d56b7bac69b7e7f6c59bf682e34651b15a342ab40bf43a57d5a57e953ddcb081c7bc9248ef69cf5b04116c3bea1af1a5f9c5cc2f70ce62fc56894e314a544976fdc3d32ab41db252a81f69622e417b411a04441cb2f3e9e4d6f11e9c5d692f30fa833be2738519074ad343fe486da6c8f47cf7e9b97c59f9829fa05eaec0051c1483f5353d93d15f00239984ea808383329b059ca70910d1019c238d21a2ddc8b55b72f3f0a1da30c7e6f671600b132204d377de52cd94e188f93e3b49525f024c198d652c856bf00083ece81bf1fc61b00c4218386339ae110cf8f12c140a533beccbd015fe71299e7451b50c2787c2ce62a2a8df5cdbdfe13ef5986e82fe316f2de479bbfd259446ce90ef318310fafc13ab46eecbe0ba03e0d3d9e54c4410f038640b8acb5e1db5f1527fe2635cd68fb3ee84c6665b989fe147d2a569af488e3cc248b3a2953d15487b8d16995fb3fa5406078b63899d0e05a578a1bceccd14ec6dffcecc2e422bcd2c886d81263c5ff1c345c02748584c28589fb853e4c2918f1426f53deeec7b6a2caf9e55863a2bf54793293cdd39018b6e562345ed7a45b58eae24cc81392b38621c6bf0b9e3c84e4d0fc446b46408ed21b1c6a525eb80498e7aeed27a61892ea2d3542ed559c7a58227f05ad9fa0e4ef2b7a5bbda7a468a130cab83590af728ab9f4db8e765b26d7d513f35e3eeff5fb890939d7c24e2e7b0976948e7c5352e752a22720edc72d82b89b0b46c923a94695e96d9d3d0273c857d26a16d7d66e219333325f53aee8a25415adf906d402c9666ee5a430557866b20db0ffd1fb3d12b3237f17aeb161939791ca50e2e86c3858bf698406cb9c048ce929377068bad323fa11ba5c7a38c115ad955f84fcdab2b07aab36cab0374d3ffd28509397520da359fd1051a87ee3aab29cc22b7defeac93cb15eb218089c015b45c3ff135e2c6b769566201e239df3b53c8d5ba63b91b23a4bd2ccfb06866b42c21e54f32078da68882b683186314791818860bf4409f4d30b4623f7f79cc7274a8eb08147f6e799efc9041926ed49dec516f7b27afbe54e15cea89215e2512442e8ea83a5529a1739002fb2b0510745a71cb47234238a1e806480a180ebf146b7583687991bd8676a51cf195ec1cc550bdadbfcbec0479854fd0a004d0fca0d838d237ba2a66c6d6848829949a398498d7b28f1ea60cf8d25f4770fccd90add190ef06697069de9fb47230797c424212854815fbc3a0b8456889f645de704b9de6b68ed0957557f00ded26afca5e3b6b7962ae109ba7fab9e5ee052fa5d5027078b132dc0dd1285331cbe03ccabfc585cd1dac17fd3f617d7ee46cef0a44d93a14eb97bb3928d13e68ccaf45e3adb6c7495fc7e882d7b97fd6fe094bb1e066561895ff3156a9c6ad92cf59371f95ecb1fd99661dbfa4887cab0c2453e5f3505b9e58dea8950e19b8840313069e0b8ba92ff6528af22d52235c16a1270b170db61fe4349e65bea72d81230add65dc28bf9d10163eb8f5764568c49e9c58687d6d9f2bd38bef817a6df6d8b35317a8e498713b58697b04da991fe56b1d86ee7f81ee22440d0b44a8c1632308bec17f8f44f77c29c40d32382bec34f91fd43d0c8c287d41442a8f82e40ee286364f81f501f198b09335e878bc1d2410b19603815188fa38ba78d3aced550cebea70bbec98d741f34dd889930de9ed4b1812703a23cda76dca189f6095e177f3c5844868a0b3d3d0eedc9c16010014b953f7df380480c4b2bb67d7da995311c82b8c717d6f933eed347d7a779610082664c7f5665174ee548bcf539d0386156050bf17a102e6a300d48db223ec24c539ac91038d6a4f5e9fff74ad120e234407cb7163e556fc2f4b1ce79eb13ffa8b5ffcb7ac0aa582cf66db245998cf80f3783da027962a56f69b9c0e2d970f5fb80976b6f45edfbc9ecdb6bcd9f17742ac26e76d5e1977e8febf87eaad42949106bba293c98c69d8809f47ce52a8bca9f9ffbdadfe8380e2f421548a277ed09208e6f4f061178b8e2b7c253872ec971230b51e1b929e2cb7e79abad4f60022418d27be931a4e6ea9c9288278a56adfb18044703cafb41f3235d38e896156ddbbb38dd9d50af8dead2cc0c79ceb8d911f3a64dfe3a583d7c5a94ef23769cfddd01339eedc56925b084cb06767672ab35f55c8d122422d54aabc6a07b75335c9f3e085f7bde6acc494c7f479b9f6d3ae73d0bcb94f76d9090880b938320e9f2da86a95eaebf69fa16198e6c177a1414d8b4b74b4d05e68548dec9b1928fc1bc59392dfd0a20d236927f5e268e845b4d0d55514004d602f90c9769d8c1822a1f3a881c6bedd58a590ca7c26a635ca50536c969041563c9afd6253c3891167289283f0d92f7be387e7c5dcbe598cd6022bde6df1380c08c429948bfeb5f907ea00aed79453eac5f0acf63d97e3bec3055e59f77f0d1e4d51f58fd790f3f8a83d16a60a77323a49cdf2104f6a185b91be96d6a95249799aa4be69a0c1238ddd8b7d772a74f932ec3206d4a96dd03763226d8f4c73c24f60ec011d092d7eac6d8325bbb91c5ce86148c675b456b6f05b6b81c33c69845b38d9a3c3f04bf7a83e6dc3c95e430e83dd38b3be9c98492e5026549c4e3ae9bfd354333257bdd35f0b9977e177cc3d67f9564aa20fae7d87b73988c3001a43fe04123eb450cf1b461aaff9451c32a229b7584b979dedf6b8d59ed487133cb35443a2bb991f7709d88c614d1cbd8fcf1ea3344f556fbe186a7573efbb654198ee7b720ee6e618af70bacb9508c154971de8f483b13fd1fa3b0d30b04b74c5ad388df46d8fc28c4987b16d3dfb43f69755df52ab2ef97b9ac597bfeadf75b48d192a899dbb20341a6556e77d6f297c3a9307ca0930a601cf1c4d9c9ae43d1bcf3209f78e13bd16062deb1cbb097895a0be83c87eedc175662fd86e75ca98699409b5376686b5cd793f4deb3b17f8bfcfbc52e98eae221883f6d1d8cea95356a82db58b076e4ccdeee99af65554f026ac1a5fb693ad8b3d8dbd161ee8d6155071b0674f3359c178f5566e56386a9533f436f194aa924d223e4705d4412bb7a5372a78056e389c734bc35f4a8649a3baed8e522771a8c7adea392ebe88a81661ca4721903429c87fd3b1d9adff0d9c483b5b9f9482c2e57629dbe1fc7ee4c5e2bbfcf750ae35a5ec5a6faae9f8c5f8fd374c906ef3c2cd14346ef7bd5f81a4b03e386e3e63882e305d618a4ed137ae2076bfe7cfcdf2d27bd380ba49e5e27a1edb56476eff5e90eb81c1ca563f233ba6ecc2124aee431b5d4c051935eb8ec0e45dd61cb43d0fae54d80ee7606689bd843900c62d2e91d75b15b7fb939fd6250880e2639b17c13ccd8a19c984981416da75cf39594970b8d243af2eaaeaa9c137e322831e60695cda4ad3d1d8f6a9572986668760ce6fe7dd89f30ad455f2754ec238907128a9cce126fd809b252a963b12f582341895f8f13b9b0ebb9a5c8a042acb276f2ce2a86e95322b5d96c973f0433b05261e7f17eb70e7a6fe78f1c4691e1888a8dd7b78c833ef90f634d6d4dfcd2a441c764100d188866e4183936baaf1e3fc85ea0eaec812ec57d948ebbfc7aaba05b7c7eba993b5d0c2306e64f67519d23756febb38c587670fa11245b2f43aed75fce2af53ae45d16935e5d37c50868b01ca24bb5d9d00c4ccefce7e714990707ba9262368f2131a3955d0a35bc9e282f7e07023766af2a8413d3531b8496c56f42173a5d26ea20ac3f986c19db3d7e59a126428d2229482058e6fc78c775a146e605a72c217e8ffd54f359e3fe8b1bdf71c4b497565b9467c6c57e8875b69807546c9004e9f73c24a8a106a01c4b77f8651065a60ae9eac4a7b46c3636759eebb99e1b0fb9a8841c065d7c0a968610925e7007dfa96117f6f8ada13f0ab015019c51dee842fe0a746d89c33666bb675bf112f39b4c5b8b09fa22329c59ddeb99b0492b2fed4f9b9ee095fe929e1a15fdfc668266fcd5a868e7b681074afffebe3c51cfb18f83dfb8a66c5b5dd1f62de07ecb91fa4c111b43727fd6d15f99d643714505acd1d326b3864d8ff7b4ce9783f6c63ecd3f14f412db06fb7c053fb3056faac87ad31ade6eb32701b0654ffa2bf4292cbe814d56fa70f7d03c86397756ce2c74dbdce641fc674c651ba77761b0a792277da30d87522a1a92028e0134beec6aafc2e89b8e13fdd5913e96f901b98134c253cf69e4a17cef65759f6b46cd801a84d9bdc120f3df366249925700376b4c1b6d70a01e0d03dd53f6f36c52d3a08ab130d726228d8e8b2247100f8dc0eceaeb2538ddc562626422c4d0075c89b5ccc91c356ca8f55987478283222d6f4fd235af7beefbc71dcdf095e0f26a37c317ccf58ddec792f6ae546015d9e796e0b9a82a8e687a36670d9b9d14957aed9fabb313798ede4f198ce41a7e702758ffa5aea60f865c61b682d257eafe64de687023314c1976da567953a5f6087beef51ec46c56606540cafd54bd6f34071d866ce74e6f8d94a5c5e23db4f5051c8edc8b229cdc0c7552d387929276cd682e1db6c3343a1fd353e7d1efddf6c37670c4ad07cd530ed17a446b4cd14b2195b7a8dafb89348a208a19f2f4d586f3bf441477f5736bb1ddb2b3efea5f7cbe0f6fb127fa2ddee973dcbfbb59a305a0fc3b24a5f3b829296da02bec29406ec972c52075e3b74ee742487b8c1145c33cb7ab14f4759fe94e57792700caeede903a429bf72ecd026c7f16bf966c38815bfdbde9326a7eda90ae10dcdd3be7e5876e5f6588f3fa1ae4d6dd0080b99db3a59822acd0dea010b5efdd980d85ca3998aa079bdf64d4691c540cd431a10d77a2c469d3c56fe7388ee0df1cf562db4eb9d6e2d1e7c656a1a5028c018044fd9aff6b621da17972c7cbe49146746d06c6f0174c19c5af35abd89b2dab1f3910a7ecbf148a860edc371813a840098129d98b5d9188a8b9c044d17b4374fa6fc895489e593569220feac7de09bcabb81f7b4cdc1d4f58981dbb6e777bf138b09e6f8c62d8b3be345e591a1934a8206bf9a0c0120f3f15496f3d7d24db304862e4f79d91da82a3511689bd1a04d13d9ced5964b9b463db63bbaa343833ab42bce61400b3e04b819b342c481a911d500afa96ef5e771c3e46c7af7166108bbe14c5b9f772d2994f601913cd558e8e4554bbf0c8a8552ab04ca373d87a4be49959a02db6404e79f181c744dcc22969372095e6ccf16e361549546ca1c1c7ddf9b66df4164c1ed0263afc204ce919c284e4453dce8ecd60ec97e6ddb9c468b876f654802f22ae4106d5d5da59f618e8da9e86d53a0e9028078609ca5a9aa727eafd0e09fd02318612be8981999af6f9d467a8f01ac0355232d8e8308207ded16925b7e9ff15fcc5483ad7c3adbbf600d1df3785db78c7a78dac5e5ee070fcee111e27e418774e62321621b82b8d3e74dd8b1e1e473bd0df9302cc8941600ce4dd25b51c04f1ae47e9c7cddfbe54bba10f6a3ac383b3dc6cc8d75b40a3048180743bef1bb9ba778a40f53af703b521e3d76753d6fb949c129f8a22caa280f8b9593ec5d8ddeeb0e2b0694432f1f59ef488efddbec6834f52687bfed60b0b0dd4332bbe7d865a4eafc2ac434779069c23e7c222f1be6c161525745021581b249fb9820154e2e6e387c94cac875f660b627bcc77341a86f3079876a73a7bff68e59bbb3542617f21a815178afeca41ee2b25b68a40e79f97ab6661e5dd52dbf314686e8bf4e9e6c64b82fcc3acf07d3d780fa2f48a46d44515d7357ad43f49aa45262674401760e3232f0190c854dc9fe2bd91a8d6f0613387adb5367160b201c959db74944db8e352ae514c9044d800ca14b2fb1ee42d692cbc2fb46a970296d887ca1cb545f53604355a8f93a850dae2ac47728fbadade9b5f9ead4fdacd41b871f7c9b4751e871ae8cce2000ae25e530992e50e511268b21b7dca5c63af3fe2d01bb43d3f5fe52121162cd569b2b91a9c68964ee6c7f2928a5f2d86597c88fea1bb51ba33f5ad4ebdea23b6a0fe16657a9509d1dfc509bdfbae238fa1f8ae7a6841d51f7946d9a5960941a0b0d164ee4f4a65e7b04dee8717954a77fd0173a7beade57e798b5f711e597dabf8add4ca2a984498a1e0d29809d7452c0bfb439a9bbf22f4a3fdbc5db40cd6ce1f898479bf38b097a6ce6016c8a498bccbad9d64331c53d81d3bb1dcf6ea06fd0841131404f3be598388d3e9cafda85dadd7360de37ddf2f2089e5bce58e0b07f8ca39ab45c98a36f074c61e5b0f9c1df5e3e7687ad4d74e4c555d2339003b5705d2e259b2a51a04ba4357926555f9eeb7b609cfbeae8326dc3506b12f8011a0ff9f1f2e27edffedbeef36a697617df1147dbd26e0d32bb4efe027da95fa9aa708665d8b2f980c614b34d02a8ffe0de54b00885d409cf7b633c5d1e07f8ca6607d790c1186095289f10346c3657a9acd4f9f488640ba8a1c2f5420f137aac992de41efda39793ad61fee1e9642bd2372b1e0ac6f8edbabe59c83593b104b15c071b2aab47517338ff762fa340e58772db54f63c27f79620bec4395e0b534d16e3d6fec7cfeff2859e434ca0bce521c85df9e528a56bc98f9c2498fa7019b5b1dfb9b8c08b5bbb9b2639181233e0452870c638596d530623afd8c40cd55ec5a7421239765c0dfa3005f579d385b094309736a4f13abae759154bb45f2907e53a987d365f4c6e26496429f482ec6864352a0cb0b9774f52de86ed6c7ca740ca19c2646c1f153fe7999e7d723e8127804c9b1989821eaee9916e7f71ff9cdf0a26d0fa363f96d3cd0872cdfbebed77e34ac29845f4fdd76ac7ba7ce18024568c8ee7f63fe8388c2efe9a0c2fd71d6ee9b510da0a60d6951f3c7d3c73a81749a9adaad676f6d50527e1584aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
