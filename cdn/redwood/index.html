<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d8a78f33d5fa273d99655670795e0e20455c22d9293e8541028f17e1ce53be5fd09bfce10d2e3ec919888ec8d6a72e4bac129b615c293aa82fd9cf0644119640bcfc733ef1c5811cddfc86f0d3028c03f8061997937215b652f0a9cb2437db47bd6e950f7f4e52a29eea0a157178bc859e4b427d013da8f9f409b0dea0395b22942102c5d13c5d53a13f6965583a9ad8f73487234f4634846f7951503a6b963d7c25b88f1b6fe79896f69322a48566cd9bef57b1d642c82fec6fde706056c91ffb0a6180049b82143bd327ee667200c69cf82639853b96cf150e9fbf4f59c2cf406b96835476f10d3fc7945c2d7515e8e9a53045a2ac92a751e108a300ca55b9f4ca5752e3001cc3a057df3d1069b7ccfa22e49e8b87957bc8e22172c8a2fd99febfeb0ed249fdc695f3bc5d9cb0638f1d4d1bccb50e6e3ee2d0efe447a0d7dcee7265a568ec4465b34b0e7b90199a3e8bb85f27ba6152d639d475e052aed89cb3914b918401fb3918840d1a6936c33cf887846ec9653bcbc50aca2a3deaf3a1c27e4155d7a468bec03c21021be2ffe74a82c4c65397957947e48f176c521f653dd26d59bc6290be034db40f020bc43ea04ec37f6620be5bd48874ea422027ba4cd7f35ec56e7d967d236ca55e0ea38a13e8abb0b5219ad763b7386f79cbc934adefde9db33a39b0f16087cf8ed44ac218ffcb2c219e18ca7939820bca52bb0318302e7c18226cc4af3161e088c68f59d08ca65a87cc84e5622414240accb316a36cae70524703092c27de67bd4315d3dbc9ab9e05bb7b8fa7b4d99dd11d4ab3b0bc33435375be43aacaac0b7463fcdfdcbf818c8ea31b9686b42e2949861416da4a80f84d3a4afb5d9716933c0650fe025b82bb6d6f751598251109c1db96f97d9387b1096913e4638a0458f6ab87374d5d6ee06ee40b7f289feb61b7806713904c638b4949a4a58979a03d538269e03aa5691c585ad27ae1dbebb1edb422006a702671551ff65b87dd7bea8de08dd4203ee8bfc92a3f8290a207ca6750df9086fd62d8fdc4f5fe5d3692be7cd24e86ba33d4fe997cd1f49aa9faa81f5fb40f9aabd5be5b9f1ed2887a112eb06511b5cd9778078d15bebd2306a02e579ee623db7904044b7a19e82fff36f0c343ae431d985781728d6e324dfd6cb064981315ff63bdd00b67c6137d8513f5e231d8d4d2c2c6e926f5dda331ae283f1292a68a7a5c2e7bb31f8db36931f83ca299614ea9ab09f3a89bfcd6002eb9b58bac1bb63f835908a5b09624fe4ef71667def5da00f86540e4d4302e96915275304155636834d6d8dd0e18bf8c44a86aa7b48dc222df89f999c16fc619dd6eef2a647e41b6fbb6bf7ab8f2107187db31066251b0cf40bee74bba1c873cdf5436715029613289e2ec9c2199a2798a22acde242c57f9ef08112322c06f3565effe2abc29e845b0998fba1efdfcb248cd118830ee6c87b77826ef14e83dcbc2e4cdc578ec0829a042794152912f6026fef6b07a703f12d45e47f4db450e6d6b34c4d7ac756971b94c82e5e9f48ba942eaa448b093cc7ca4ed20c15b8ae11fa203fa4d286200b2da1269aafafcde44b9395bf080f7de79937a9e4831d41769ac6f85259d1cc653af4b97d951eb428325ea2d515b6851fe5c273a930ce3e60f2fe2f305e3aa808c68705c196e57103060915db51668b76a40be734e8d30ec5c58c29b9f0f451940e559c9ac18010cc114c64ce73789434984746062142a9baa02c42e80393fa93236b08e487898ab5d0264e0124925da1f8c5693d45fac2db1bf8748c8857ea36baaaeb0b4890e39130d4f8b38a73336fbaf248837565e7c616159f56fa01792703af129136d237879b366b28da97f228c3dfd3ae8c9cd7155f130fd13232a0f6a3773b75e34e78d92da6d794a669944c1d821a4e9ddb86d5aac8efacd4f20098ae43ecb2339b289c4e3c93e5538135468f88f086438f93fc23fb26c1b17a77c0e8c62c6e5ca0b67cfa23e49decec44111d6a71395efa3e048041dc3fbd1f76b4992425e824e47434de5d76c01b8ed449c3b0dc98bd5bc0e95d9f7ed667ff160bfc6a8e6fb810f98ebc254c9469cda0dc5d60d93cc4b311142d44b3c2ab34ca2ad8d72ae868465c47c78e0bd40cd5fd8f9337f8f2fe595b78b902681764189688fbdca0abb5718d39d6f48d702525a688edf943a2c4fef5d62cd9adf8388d88ec4fd7d8f5938524d641f64d075d769341fc01ff1433eec207e1ff1a0ed1c950a85fb7455b8744b4043465eb0f4b67f96b458aa94856df7d4a2ecca418f39f4f9c555effbd5caba8f5d37deaf48837cc262c2f0c69d7f426d4a5681c6ca617e6718d090a9b10ca0eeff425986e0f4c79e4e96c8ade7b239d529c51a2bf2819f6dc481369222ab64526f8ce73e2bbdd2c244756a7bc9b0b9c7099a0d45b5f2b2de14183e71c9aafce56447bde141d3e9e20af1cc789ad81227fff7bff8f8b89e08b65f0fcb2f6bb95ef7c2999f35d73735b26f563f5732361af0374b8ec9f5f82054edd4b2e6bd87e88f0d75b7d9fdfef043d5b2c151a68e3dbb06a781330609a923a16128ff8999196760949e94ca03820f450ec858e0c406063f81eb31e344c4bfaa88292ef992f83c4fe5e2a9d9c4cf6be9fa351e48cb92048e01f2ef6712f073483a5530bf42362758bca599f86e59a84e272d6048a875f12830f4c3ce5a6b7f7a7854ba21ecee7f116928352bfb030a848037dbd667e44209156c4f1a38aa04ad0951a7522dc4ec6a1c4094079db89983a924d2fde77f9f7fdf479a43c84248875bc6bb61238deedd75c22fe5003f0432f2b89b2431db99b61431c481c70c511c5fa84d95235768f40e7df4b0d63aa3010552b74dad510e6587c4bad646ce49071a45f457eb5ae2fc9d03e3b728dfa9f627a79a1629e91d75b97eeb73671bdb51152d1f3c1a3cc8f0879fc0001c0b570e192e023d2ef288b6e612e00397ddf5ad908d527a48eb0831e4c96ad158d68452afcf2554c1d674dcae5b09b8c0817b54d4c806d102f30fac97603bca2eb9e593c85e19abc8130bbbc21e6bda7bc1a9a796804effee6db7122aeeb6802f5117e8792c39cf1389c2f6d8673d2bd3ebb83a90c30f250c4f6be0798714e96d6cc35bda0d8e7794f4215711d445cb5ba956038841d695cbccba696494158eded40b18308a2a4267ad657ff60c23819fe05ac7218b4f846fd603658649e36adced08ad05944f91b64db3a00b2d6c1f3946f584ddf335f34e4d18f2188a328319bf72b77b72835a29f6df098499f06d3066ba6ef4fd38d2bf8b156b6b82f2840c9b117a294f0486e5a1d4b86141bbaf3a1376fc22073198b59921b29bdbc7daa7708bf6e35df06a3703e9b33352fcf5300097693905900ac98b5c8e3bc359c46429c7a4982bbd7599e2abdea06550579940f12b7824e1f2686c6619a692240afbd63248c13bb2ef297b8396e5928f70ff3b4bc501064b579d684faa3b76d1afe43874471097dac3a0bec15915512ae585119760796abd530f8c699a819976a6ee0b01142f00dfb4f5ad03799b8d696dd9649c594c12f8e9aef89fbed9e5d8ea137c81cc32a9720b3a836ada85f6dca62a74eb7142695634360a73e703d9eead5972e1592c9eaa96444c0b46bb7288a6e2413c914413b38e57dfbf4da67d2d2091c1d8ddcebe55255d2f200f9363a8ce05b29385738d3778a75a6c2d27aa6bd3fc28e74e2652c5d6ddaf228d8756ac79fb0d732cdb379d9236f61523d284543e4db79f372e7f2f78733be6de1d12638b85b678436a5d8a9e9ffc47fa5bf5719e15d21749a40d4793fcc01794ebf5f75cc033f6c7c08dc6810e82c7d593334f4f1c60df5269d269359a122cba6599a65bda905a354aebca580904a0e5dcf1d4c9b1d3c629cbcc901d52db933ab35e22ec8da181f89c565488d2c492cf84f068db11c7a23864f884bfbb576b3c97cbd1792a6472f8f9cc6b5a6d392ea5c84d39cf344acd0c40a380e0a088899d200734693bd392fb932746f15bb5c33d0789e14a0ad2f7cfba2d7b65c12621a1a7ede5c517edd926822ea80851408da7824ab7b9b09c449eb4412378b5925dcfde7e07ec7f8c38a7913fe3287c60532784f048b11a97d676943bb837e031b9aec3231909ef1270783096ddebab0171ce82f19d10640e6c2f5f13758bf8f78f4267a1279dee7cb845a09271d12147e84a98247c7b378fc254ee7c135959f601b16e585484a7d65c8b3382031f01e49b929f3a33dd4c9eb6b8c3f8c02a26c9b360cffb188d8bd9c63b17a6f54a0bae055febdd9279b77c6f368c9e40336799784cf0b6faa111956b7f42e92308a943c0237424a1c24f9217f9e2095bfa43bc58620140f9eb4ef4a718a24281d10c6121a18a6f480239371d3b40f1c6a11430d228a4ed4804c13ce0fa64c1e4e0a0f7c5a143d88df7cc3af9d323eb8fbb0ae0ecf477a72ac29a0ea34a4e63b5f899a5e42416960ec1ef049d055c32e7f59426ebe5704def350c86c8f1ba2f5f9b23bbfbefe9d87015127f6f81fdd7ba0558d4e07dab762b0df4a19dfc30686fea950df4b9d00f6aa71bcf520091802a8defb35aaeff5121fdbe1eb7a8c849c4547c63e728f3d5fe91cac9852369eb0bcc72dedfde8c8251354a21916444e1730e2b95e608da196f5bd6e64304f991d0b8ca3507586f5aa50cdc4f0476401f31a8e7a67959251f38fa7457c241e19b10b429e2e625671b5af2919d95ba7caeb8539793c6528caf92325b7cb6ecb43888270e8d7ba6fa84b0e8f5d0b45d811b06e3a212995017cf528683157ae015de68ed4db1aea299b098911b4b823218379fc65eaf7a03133069ccd59c601335ccb6c5fda461f53d6aaf74f7a3d39bf8a3c099b110654b359848c94f88f08f30efa6de5d46d117a280acd7097e0dbd83c7357369b8044ce6cf59eaa5a5f6091b4ee6423e3e065c3d50c6ce0736d9967afb5ebf88ea254717213814d5e105e21f5ac77cd82adab8beaa314d79eb0469661703d0d2a065f785e2d5b9d004ad82d9cbdd345d972f8b4057c540a08cf6deeb5385eeb368d5ef5c1d3a58469e8ad2f92583dde5347933f128bdc0905abc5bf916936cb8cdfeb3b22acb2b0c0cbe37eab7506a25b3106df3d9853cb8eb3e8e4cd25aa7cad110beae6d3a8b81c85e78cb0800a38c530b7e886f1f84386c844c0ad4cde0a354e69da0b24dcb4cb1350090351f05e1a00037e565e7b4272bbf35ea0c20d466ea9c58f5b943d02fc54be01edf414fe6a5c56d506fc7e4534967d0eee37a9c257cae5aa62dd3faed71f014d0490cbb86cc0c2466b406a1cb81aca7255cff123644d37fd44dc18c1bb4a9f622030cec04b5c3ab426e7e3bc002157b17a70ec8881eca53e553b4e63252b306194679a82fbf0e0dd98a8b4be0a95dd9890d963d449ce4524d9b7de24fa4a20a7d59cb3da8e8f397d841f0c3f9e56d6757bbb8be8cb46d29d6102dc1445b31cf7fafe2d1d38f2f4de6f25f37198a0687b2b26ff16966eeb9b93f374b7b8a2ad929a5308af4873fe1ad00558301a9cdffb72608f592d16df1c260f8a1c974c94446e466302ca17497b8457fd35d6bb231ce22e45163e0282821596a86547827f0674b3ea2d1baf03835eebfcd823e9b042b6d6d5e7fc8ca0c66513531d052aad2e0bb98c5dcd4681e48ba76beb9a3b9d3093ecfc56c473455840343e950659e495bc3f49199f9d4808ce20514961d3bbb0e04247ca9a1844de33d1d0df994f25686866010e6e6a29f04717b339a911f22f997c6c021820bd001bf3bc370ed998959d0a691b3c5216f2a21965c00b57c2deb3fde2976947a159ab6cb734d60d7e1f9b123d5358745526907725a58c39e7bad87071b49bd76bc6a608a7953ce72b3a3a9119abb95f35ba8938b83bdb7df14421b22f66664dbb0c3da0547de89435667e7f29e1282281a35b72b0cc36d3cf2272aaa9eab29faf0e5f38ddcd20bab96ee5cecc4d348eca6ee075a3698051dce20b5ae32a1e3800e578a0494a74193c82441b0ee1a4becc1c42cca918f3aae11a3533d10efd78dff74260dacb4ab691a141c8f40838e650ce2abb3ffec730f3d9fac0b1c7f2f270867aadbc2c1542a3b40ff9e277454e2ad12b6d9c9c3f139ec6ab2be64832f2151de2834053e5326a363893d2286ecced1ed0b327fad44a8c2ed981af5ca7663021ccdb11002f4f2515e44527fdf32920c83a052a471200db11f08c77027c3044316351d9d7a0a7883d1dec602d754df17a54eff258b5cdf123c7cb8153df60094421944dc20a114dd22f87b905cd494e0035eaf379064f5b9f5be367777bb1f57294b601043f3746eae946d8d30bbbf4d56f7f8c20cbb881237a9ec2e33f17b98c8fab394505c07f9ad83eff5d66121f2a5c219153f0c4d4df816cef6a1fe5d7c29f48fd75a3f5a2c8a5588030a85accadf9a0d8e0e057bba4939339001af2f0c39e6b8f064fdd9e3e8ba2d0bb83445cffebb70fcd1bc27c8e7b7fea4fe5f943c8547c7603c2c98c9090a7b874c71f64634a302d22a36dcb355dc2bc1116c99fc11dfcbacfb6ac51d50a1e57bd9c1827d0f9ac8ee5268513e7b2289b8e3bb010c88e28851cf884508cd2f71f276c6adb5d1169af53f032e9ce052ebeb9cb825773e1ab4e57e062351037c601defbd2608d9d119e89aea47ceeb64b99cd32731b292ac1bf980bf6b0605fb207fdc01eb1b2f0956a457f9b8b103a5c94977e2b538c30abc8d61bbe5ac8bb90e8cb8893661090153826efe674208af4141ad12c1e24fb89b8032532458b0f4d16c6c4ecf4d4e61104e276a950b0b3f8f2df406ab86a6d92c1b3223dc0a13dc9f3a0e3beb257995abb61d1354bd219f7eedf863719045bd3b0afa82378ce82a9de4a20b3a94a261a8196d19b20ea04f4efb3e72896aab57539dbabd8de1f6865a469cc6325906a8e49e396c662c99a20c1f9293d6f478c2368326dd8505305f187f6fbaaa72715fc87c9c7f0aaa7ecd94e04b0b64b83edf22259ae87dcf46ec6a5a04b7b0203977eeebbac60260aa30b096b12ab213d101f91f45d02f68d776a6208088d458d46a2ec8071e723ee67889c6dd8f83cfa077492c60f5ff005c9335eb3fe7df3253f2e4d36c22b3909c731620b8560b4511a5cf4bd4067832f8e78f35db6180b4de300b89859e90e448928a5594b9b64850fc2083dc9ad8b569d1bb4e29d465432d6b8be6ad81cc65c441a197e293a1f47120b060ce2efe09ca9eeb6fcc5f6c6061c1da212912ed975ee2db16386f055f3897c203e199db31c70d8a90cc09bc6ec3b6038a92fbc0feec59dd3fc7ba5efb0ca6d94b4ee683735d2b00ac3417279ca9e44375cb5dc8a76465f884d5220ecf35eee69fd9a7949c129f0c064711da9ab162db9c8bf4bf6611f373e2c56aea1e64201d35cd27662108c0ac3416cb6931a63cb6174ee4cfa12c2c09a11d350f7a153de887ff0ac371cb07bd8a2d0588b7709ccf2239d20ca5491fb976e0d81dd78924264bdb31028d7be26b8bae6bd77fcfd50905ded6c224cf948a2f0e49ec5ebd62fce35887b7829817170594662fc3d917ad7aff84d9f2f9fe7883e140f2a9313362ecf30cb61e58e584b218ced0e644caef3ffba1efcf3ef67caa7c84cbd384e6d5c7b1283676e4bd03f7b77b02f87aea9502ab20f5fc043237fc247613f35d01fcc245f2fdbbf65edeabc05f6e6a2beb9e58a5e9145671a6b5aa4a62d9048174524d03c260b50f1c8860e6d1d1092645288e29ccb1a7c1910541e1fd60072a9ec55ab256b3031b5ad94ed1a05d1a760f6a7d57c4aa338de26f755c0f3bebf2fa7fbe11a097e398925ae6c774b5bdf2709b3041c506edf8b457e2541ce6c9d186550e0b7bd772d310ccb4aa4bea4d2d3a5029b27d133a5971ad64410ebf72e0633ff9f255f085b739f15224ec992627ded59fca2fad3e4c7c20fd7ad23d84ceb6f9f2c49f345e6e39c3e160ae23bb20a3afb38bc04315fb75bf7d8c2a6895fa8794424a12e8ac410b6bda96173165f71adfd51e9fe7e55e9dc583171630f7b060f3192b91ff81055ccb947c655dc99d70c68fd9fa8b002d48746229d383201c6c2862c37cbe1eb71bf4f407e438d9cc5aa1121bdc32191efa4c2a350ba8c0b469d3c04e6bae6202596f20ce87a29c5c04049d8ec81063a4a4cfc3812700776eff7373d33c79b2e21c052072fa4f3ed3b28511ea5fbd4fa72d102fadb552cfac442a4c21d2cddabe6375aaba2e8bc23927a84e54bcedbd7f46ad8187d9f1f9f8ec7966a1ce180517e7881cf33771cc3e8750d809994081e86b3fb77f158a0c155138abcbe2b26b9bb559973dc2f09055d5dcbae48ccf5082b22d6b71cb63d677be630cc185ead8664abc64a79ce7134a75356c707f119a54b373111d5b96d3ce68552dcc5c14b7668b81c8383366b8a994fc8a9f1e38be398d55426e1a740919da552a01208b45eb0686b98541325a118569e44ffa2fe4869de7464a88bbfdf6ed7dc48a5ba4c52004444b255aadf295bebbc89d3a4e1dcb5f2804acf0a308de758efcf872f5f608f6d88847923d0053330cd837a2fdceae6e3bcfe66acfe5653fc7943520766cecb8165cb4a07ef9397a40405cdb5bc224075e6de99d4756b16a0e9f4209ce1f49a8b565f9da85daa6979fe55a7d1ba04e60596f8da90180d0a3a957f0e5c173030da2fc5305aa610c356148b6ab468b1f19cb1eb41d9c24b8f4a6c79393e0454837ac7b2707156af351ccfe1af27ed45c248a6a170591f542eab4b6b8f7740030b7d11b04a564b5b43ee468f8c08462a35b6940bb017d18060b2eb0d2c296379f9ac700a534ab96c5fe34666aa3e6d0da0ddd4c699f6cb0fd6bfbacdcc72cd217b030f0916c7f6a183568271a85c3162d4d31f5aa49cd82b5c3be813e10d9ca8525de7a8fc1ca4e439ba61ef02df5a5b2253fd6ba03d32b91394086c2b4e2ce4fb3413fa01b3147ded0f636e03cb02a82113b7b6719297c3eebd09f1390e96cef7db7141c45b23ee96344dd06de588ddc1399fed0041ced82615858b8d0e564c3df1d675fb09aea8de6bd06c3c23e777ac80d4961f10c1c811358963af857b209885724fb8f9de8262602907bab77b3e82bcbbc33bf4cae22f8fc4197b63ca943c1597797ff5b11376373c5aacdfa0dfdfc2bf0297f18e028f28acbbe2cada73b57ef61e97118854da2546e49bf73720cc30c0bb8a1335d00da8577fe582ecfef59672801082186a87a1bdfa00863ffc37f12c5c0a8858785b8393fb7e77fe1cc65b113e7dbf9300e2a7478eb46396e50de587fd2872f2cb9e5361686c8e22d747420172e0911bcbf5714cc4719d1efbceaa2b685d89ceded7f01111a00c7150e0c1726e6a5eb891af7b8084362e5fb11bd414130a216504d2531e032a0da1f15f46eca75e13fd367af8613079bb5793d5dae879ffd81598332931349f38612efb51275e3bec85323d35fe0805e90a49f57bfd10b138f2ab0360afba87dc838ac16b98e1c7750d783db4647cc98fd5c2b8c24086497287c06398937fa204405622e69eaad4f9f327c967b08e65eaa8b3e391b2d1381c046588b220a126c1b3d8a9a90305654c847e0eef4fd9e56a3334504a28aaf43d614af0e206559a2b832ba8abe1b34337d0b76e67db7e420e95a8183b360dc0a391323523970fb6be4c543f502067623d9c781d98887c2a484e4cb2b689f1988901325cb72559b5a5d2367ff16948ca0bcd7787cd40e7cb00bb2d9a838a308799792264243312cbaf9479b51b3a06e6147a25262ab526a1187e275f44f1fe37cb99b0ce61b96f75b1cf4b3711cd6939b6537d2f458e0d67c0da7790ded42a67eec447a7e834ef9b611c0ee0ac838b021578d75331b4e18314659d190509acca4de4d07874dfb91c3beee7206569d7aa006228558606cffca885d6a77dad0c8b18be5314a061499edb0f6459560c5611a45d575b4d711fb17000e45f3286790497eb4544d9e073f8a0155abe2febbdbcdeb287d15b4f162f4c6bd6b5025fdde0e9ea58c0018efb1085d5b5683afcae3a51cae22f3f7011f15da0f4722f28ebf0af54ca11afe68b99b07c43a826a4f102b6c213ff1bed35a31ec8383c1c81f7227f7c635935abc59280dd9ba73a04ba62bcb3bcbc9f368c87e41ef30ac57c5a5ae5dca128cd0e07837b61c481228050538779d434c7304070694a771f8adfbc15604c714606b7786b5f3b3795b03eef7f1511ed07d338813e84d5493daf9a2dd665c189f700090a15dabd505d1c76717356bfe6425ca7f282d39581833f7f8c79291a23e2d28749bd2440ca097be6f2b4e05d1f7d4aaab0bb97a7e7a6ae70a162bc8c930978ab8457d551d9a2dfd4a3c2e1a61988da276843330bf87cb6fbcc0919c68b1e7925e908f286513950888cb0e2ea060d98e1459344928c577b0718cd2006cb9aa76d09cbb6f8b1caed6b3d5e08038a82bf5d8109adac800419b9b255183b1ea8db1be08a4085a675372408444e71a16903632ff31358d14fb1a9fe2855f967213c8ba80a10cdae03af3f015a1fac22551953e0a545f43134a2862590d2fab8e715ce0ce0408543734010c2ab7a84ee40f61be73fe599ce89f06f4db311520373358683a713d63075bfc39d9793e3f0de2be16536f4363dc38b9582b1618c58efbde097f2f8878e3f9d2643d7d1ddb734e753f41e8a5b74d027639085858fa8d1acc5de3665c2816f9fef0c612b78b7bbe8a26cd8ce13af913f90d6cd2425d2892746f9ca8981dd353f1dff087fc9f126bcaaadf595077bb5e1e33ea05c783e0c95a8f02a92e0e74f782b8646380e87d9e6f573c5b4a23c7acb70eef0578afbc5b8e3be3579f8235d52186cd8bf35e5f64d092248cbd073a605848e4ec29b8b5d2e2e6fc29bc8ff7c78f9783f8056c8493133b77f7bed4278413c512607834d0f6b5eb6357dbb33fb922f325ece2b7cee24276b9440530c076121dd101221094ec45c54a35dc0ce22b46d9bf983d39ee225fbae876407509bad59d9389ba336eadfb8c66da5edf5673e94e43ffbadb509d607d345e6cace13e2991b596efbe73370552ee8efaa1c7e02f12130e76f48fdfeb35b20a16860645e4bb38af2202b037c2ff74ef690efb793c70256da30145a983dcfe65284cc4ae0cc201e824ebd4b3295fc2b9ad1ea26c2c1d5aaa8879784f95ec737812c9d3c6206b5496602f48ece1000d869f1e06f9a4c1a1d5b1b363fc6d784d938e7676a7a9048dcf111608e4cace8924deb0b3a535405c5d73eb355f982da0608678c0f9bfb17ea2b882aa8eddad68cb9f25986e52b3746fbdba00e43b66ba31a63613be29892553e9c8d27997b5f4df7a3795a1ab7d64fd0257c9b456b58ed65785a70c31ce7df8fe139c1603d5adcbf07dbc5cb88081302404851efba87766bbec2871f228d5a3c034df91869d618f51ea67304b97703b81e5622843a43826d85aeb0c07062265879cc8a04ac3f50bc963a66c882e81f991be3d191884751295a732fa9aa07c8a4c1ad08843818ece4c0ff4330fa8582004be4470ad2e0b288f873650377891d63f2114117a17c4612413cc3e6bfc45d8c861af38f0779f934f376b988d91cee5bdcc6c061cec3eb8fda8417f33bdec4d4fc84d25751fdb08b3a0b0078ffe484ae8ac2e5039efa2d3f5659f3c7b13267eb3bae9f81ed95c5cb6ff9513014af81b07abd34bb4d19738043e6ae759a7ed11536dec63534ab172ad6c90134597790bb522744767008e21fc36a4f38a725a8819f08a81d3d12809948a1d5c3b92ed38bc47baeddbb9165007737290a9be6dfdf5f0f029517f8c52072c937307947e51dc190e8fbf4326ca7df38ea888c5fe49e4a32afe10116e3bd0d6e7d2df1b3902ee83b39cfce7f40b02f2355f186b33ba099b6e3a0ac989d9e10f19673750ac8d882451b83f854fb0ffe398e7338f19106d3cef7e8707320bc7eeec01d551c147129932773effb343f4193108efa5407c398341c035397550cbf6288601fea88600f37d34cf9bed3aaae4768a8011b24278d3f0ed1f747d089c1a88a4302405d6ce3e2522f7065af2bfd8513b30baf106b745683b8415ede040496acf8c5990a282d790a5cb0655a0000e5057af19e02efcfd08f86f992abc02494d3cfdfd5a4c6a2a6842547c9470fb398dd559433b7d5ff7d496b3d34accdc86b1047e7a504fa96fd30d30369018f1deeb4dcb7e6b40b9576878e73342ef0e0891f7ade221113c88c80a53300fd12972661454e05ec5f9f989c3a6e3a4c9cba3ff60dbc81aea3fd5d687508039e317cc8eb8336986e18b50ab636db07f1ebffa8d1122a8bec6c4d57bc7a6902e0ee8a18903086eb367bd56e385b6c60e101dd571a565bd0b1a370ba3189f7fcba947f79977b12807d81f4923e94b9391980dcc29709f07fa8a56658219aab3ccb93e7a9ce246bdfb67f615182dd436330c6db652d808cf0f91dc80932d285639bdf36f609f7308dde6917391bdc4fa5345c673e827fa9f957bc95135ca6e751311b18cbac90b121ec4460e3f41757357139c463f60e6f13db42f864be448621aef8878792f22f61bcc1038cd8855c3d38372b7cc9754bc51c641b48873d512ccc0eb488fa9ddb010d27fa32c0b1fab211fa1eb699e390624868eae2d14c88f135bf0d794135ff1ab010a214b65f5b35a97d7444716aa673ab835d149b7b6d808b63df2412b7e9de316ff6967ce2c8e33c139e9450439cc361a200785b0d18ee7089c02ae82db9290be1aaf5187e23ab33ccbc82fd20cded84a94281b5a6e8eefb7280f9ac5827c1f9cccf1032d7d0a57b5d759b7e86dfca62a79fdd69fc9bc177701b8bacd2879fe79d682656aa391b7d0651207061b43537824eaa13ee4fc23b758c5f82adea0c2dbbcb32d70aff0694088cf9aebd91ca485fea464389654e5e8bb96ece046ce677030177e8c5965dd3d51f66f75a474e583df525b4906bab38671242ed4c2ddb0bd63cc70b6d84a66856a8872f107c37b2e81c8e70f7b040eba85d4d4f07b93973c081a6fd0408c716c6390a49e9b9df3e66011fd7015425a1ae219162bdc7b7c550eeabd3158c3632ae0a2bc94070aa19b199f18376676f2b2779233867da3bf7c770d55059cd42f3d9ca6337ed8f977869eb41b523806ac89d4b3c3a2746be90db613a2034d8cc1e28a26180f59bc476d2abe4c1ec5c84d7942ca2657bf2b196e7c77346a5bcc94d2ccbf00ee97bf3d6579cff83be2a1d810bdf1edf8eee86668fea3ba076c537f78aaed9a4a06d4418e86440721bac677240f931262cb41e11255ca15c52d4cb47a78d68e2320ee8a7283513ab45e698bfaff03aa3da0ae728f33f37393fcac0be133d88394ffacbdb5df132a6c88df5c788a59fcad0246e7531d34df4b19c9ef89be49ebeb92a4c99af2d70f40461881aa44580c884e814cc9434e84ccde4106e79414dcb321706413ca8170cf4374d0a4bd83259dbde85f855c0773d59dc352c5ad900bc1abb24202894da9fd1c98c0297e1d5c27924b39273c18e81c4951f2da7b2937b76434450dd875e3e77e7ca7331927c47520b11e454750c64a2dcabcb6287a9149c5858d63393d6fedf68286c338f868fcda482445877f5fd417d34d75eec19a086319a506b239ff6820cfa7eed84b142e6968487501a85c5c3ecb9b304fd57ef75a339dd30a671e8f42833fc05165d7916d2b7781742840fb246a71996aaebd7f0709c87d34b28abddd67b9285a231e4ada1aabf4678201d020d197256b62a8763f80ddfa2356d2040e2be46927aa78ceaaf44f82b5b57c3a3319e8e67540b63b855cf100ecfa6f45e108bcb3b8099946502a56c5fe23527deb1da3f3296c5c506f180e4e9086b9009365d44878263a51cc6c3d80e7f90dba6870b19d252e3fa3296ccd952df2cb5750fb27c15db585607cf9111998ca2f618585645f8f5b24bf4ee455cecfc7f8228b820f4efe77878ef3572b368ba67d2a114401651ea6422c756f895879b5675431a8914758c05610f07bc7cf3b1081c1bcb53e14e8c50487a001c7954c1418bd75d0e72d7e6b9e51ca01a8fae06e000411bb3bcd077a00968a1fdbe4b5f514388fce3fa3cf8d845a24203e8f592ba8b88f67d1c5dd784dfa87f78be6d163bf3f593fb4ce28d0297a3a7869d25ebbdd389903b44b734e9f2a97b4b875a2107c8d373b73325a6939b3064a3d9a55d156217e79a8f1c124e196fd7c96a39c1cf066c13a6d8774747505641b180d08d60d190bc35e3c6f0661a4232a6c3c6218b27d65b6ae0785eeaacf94235ccdaa652d61e8d9b17cb456d8f9d85fbf8b6ecb261e6dae76e0658d657f8b76150a585dd7e95a7d1b3afa3931a238affc2e68a06d533e6ff495aa52c1e3e7768667906740550d746e2cff67263b56149104a97f10c490a09056b8d7b057f59e5f56a9fcbac164c784d257e22a61efeaee556556a5f542ec7891899f3f1c00612e686028bc44528d7e92ad4dcc4f0c3b20cefa72db5f4f7b56f1570a915910d5a460a46ad8c34a72744c229e04defc58c5e0bcd7148e2a81b4147cc56321ec436116f05442951728ded30b86f4eb97cfd8fbb9315ff1a54c1741186b476d94f5f25218d6db5578a92d06e371ffb8d75c33638332e029aec61485b9fbdbae151009ac9cdc0497abbf4e7d7228388c87892c1c24238899e093a7d6d54b35bd5c53c6a50a96321336bd485700b0ade8fc0f52538b0afc5393dab33acf06f02a7cd0b3e031feb48d06cb01a758cdb226b2af185428fc490667fe77c620f56e9ef0da07dece8ac8694b12a632ffa2e8ad994d2d923fa7330c96574d51f14ca7da00b2a15172e359d76fa49771cd1f79b893c26d034c4b4ab862ed13c0ba90e80a1ed0c361a279243e8e370140ec4ace1f500f85796c4246ba6a089247231ff40853037dacc95999f0bb4e65f05cfac68bdeb724e31bc435b039ad8495432383684ed5fdfd0d6af6811188a736957857a102129372c79969ed19d8736a0ab5effac00c52165d92b12099c07af66cd590639c7114a76403e4d8d3f17261","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
