<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecdf57fa6b4e53d7dea700fd3a1c763d0640dee10e9cbb31c97d96529dfa587877a40e34398cbe922a9d2d727aa559301877b04eac74f19bd2425500a38afde4c16ac045d594683ab07c43fc8086f5f72d2134cfb24164dcc759e4c898c7dceddeb17387350da5c3f9ceb34278366e21569664030582719963a6e56846f1a3d6bc1874d80e837b5afcfc0b0db1275f6114b7b4c8e9a04ead2596e265a0cc645aa319995a04450e623d20f67f6bfc4fa43c1dc70ffc9c6e9bbef6494e5c60e499122e1cbc2bdb972f3e4de8ecdc7daf5ef9db1ba8ea3d5e39f9ba5808130dd91ca89feb483893fe161363dcc7d354b4425bc54efb8bbc834f93902aefa8eaebea160e57fbde5feffde17fd1e8334c2208f0f448b48e54c49ca08353fdb82231264ae4b0d8dd4172396c27fdc9d2dc15225ed191ea10743040503a61625beb7bba3bb22c717c7fc5fd59d45ccdcca25666cea04727d2eacf963215235edd67e186e065939aaa45bc12b1e061a0aea5d79ff270a3a165cad94375188581dd221a9cbeed61f1c84ee6751db58cd7ac093c75da2209a4c12db3e423bd5afffb545ab9f863b7cb7d94dea392cc0485c0f6cac125f4488bbda344c9584fe49f9c482e5fed5fd147ec53726e06b0ab48b0456ac83895479cc1116feb7b48cd617f9802bb2a17ac0186d199c84439d8db38286ebe9e2c5c561f9c0d38673b7af3b3d298ccbf5e71c09ee826d0d36700d4fe51a777545b5cc224bbaf516f1bf02fc8615f85618f45e26d9faa13f1181c018e7bf44bd0178554c89729fb0228556f17ac4db4781827dbc022ba2615df616c4f2c0c53a50a932fb6bfd68010e91bb9d30695ca41db66303b1c530c7452cc01969704f4d38c429722e2b6ef345a659a2fdafcff1ad6685ba5bc6d0ba3128430be58639504c9a1045ec4516a3985315cf5cea53b55bfb17aa254446ce7cc673466fa655bfbf201d6420f4604ba23f9fec3898b46c3d6aabd74ee2112baec87d6c15dda9a7b852dd320cb048850ba80cf188431ad4683923fee14fc54f3757bcba9a51db44e44729785cd3702dea1d1b4e12d0887bd5fce73af08facd920220c3045dfb413ea1cd66e5b805193d1ff5a0786d16110608d282fbefcdabd230468e6a8eded616df79e5ed6503e935618b577aa0d6ce7c042af0cbcf192cbea107057754995c866e0d1e8b0899d032b2f4a31ebafd61073ebc42a3d9f860a356a5a4e770f23a4ab4b57e4398153f40eb4fe56d7352acb20d3d1bb25520ec6adc338140e064f2222eda9039ec24279ceaf1a8b75869d07f0b061aac834dd3e59a9a0768d1996e021fdefd9fee0c5e6137180970ca816ab16294e80fe2d66a880f2eb5d8843982ea3e10018534344be4f3c753123b8082ef1d62ad0956fa414a09fdc1005f209847021effe6c2799261e9f5b275c362e8f22ce2b5eb8b96e59e827425f52a53c7f4f3574353c3a9ff5f2e1da6f410a30ac1c8527346a7436e45b62c70ec8c4e5738263427cc50a4e0d564e53e9e61e934d78481c07745552d333d7574707a0ca4dd98e10365a20b7daa488329df0125852010c1567d4f371433e53a80a2d468c51c274844542a90738401ee75cff70bf912bedd8fbea34ce1e2c3c7076944bd7e160a689a2078d2dad18943809537602ef4459b79915ac07a39f4308f329591014b1b172496962c0010a71eb015e95860af081b0923a5d246fbfa3818c4eeace4fe1eb5bb1e91c52c7e5914a4bab284c42b2d65441914412f63bb174128597a418892c8553798538f9a6708dcdbdc1ead0e9fe87cee8a0d9bf7e483e2d0d2e7fed6e44717aab052b4e2c6ee10394cc11c53f3203387cffc1da81b1b4a86c51e8f9241ce972cf725d82d6dadeb82119bf0ec35ff5598040a294363c9acbc90a3803bff675cac4fdac99b086835afc35e351c09d6f5286fdf9c84aad119e6e9307bef7e6a1917b5a45a9ed56c897fc114e791830adea629bee45d5e4e4b57a52ad61dd371ac1d9076ac80d805e476b3a8fdd976ecc05b7dd13c5c4e81adf0b21a3fd0183a581e28ed4f78ff5cfff5c7ed2d461ab0c194a9de16372e4f9d5af5d8e0c0753f49537cdf9d1113281828169a037bc42694bb6ac08ce1d102fac26c2c5c5e5f9a3182a8259e698dde34779095d06f1ed8f96db4e2531eeedb2659a5fab726c06676ee7ec72b24331e3fa02ad1846409805ce48f21c39ea901a7cd045d111fa82497e9be5068f17970456eab9e15c4884aff6e6cb7e1962b22f80512ce30f1e782a74e3d8163392c276b99d169204409b005912d9ff4d6dbd51d4075cabac0971248e83f55475b730362173d1cf895daa235a5207e8369e8c075d609ffc46265e6443bf50aa2c566ace72ab96d76b5a7328438a5d04f1e7b91b8c01f057a00bfde2caccd383ce66931c67e644c509b432639bb7cdf76a762a86dc8fe5fb2cfb6e56f36df2f2c493a49593f9f82137a3ae395d486620bf3110c15356ab2451914a4bbddfeee2665476b20f943f9637623f71521c4509ebd80d4a265ae29e123f0cbcc932b35e7a54b96357191a463fcc6dac03da3a672363574ff3aedc73f03e07fe8cca2e61ae37a52f3d960a0541ab3727b59f05ad43d68188f13e5d70ebf2f6978eb4f92305fbfc32cba8256aeeff2dd984d71097f91cd2ca8bcd0ec4e5d0db4e905c316786091a7ddd25fe970c8cf3cf295d083ba8090d94377bb5425dbcce07027977a06cd30211e40819be4258f72ba5d6614989eb6daef52dc6bec930a01a1dc0f00e7e57751e53cfaaa5b973e5d8271bca62b5a9363cfaf354b2fe87cdc829d02e390a1c6e2c83b1da017f0a3d0444532a8cea8dc0d95cff37b2a4fb5d04ad5f364368ee670f52d401d6a4fd33be4da2085e7d919d123f34e1a441132bcbc57cfeaa1d4f80e26f6c53b41ef7e551c0b0d9bb98948f5e2b4ecc7084ae1cccce61fc47b007a0dcfd4235a2db55f9856f96771cc981fdf2e209c60e299eac1ee1766868fc0199e43ed62d47f338a74baa3d6e21aafa157d5bc3bd38d59b6817d65a47067b62a10af7150aaa4df724e897b1d58dafaf95d16e85bb0c84478b23c1d6ec6e149098525353a6590cb081622d368cb9ef4842aeb2e4a2479184eb6e60b5dbc6aad156923b98fbf6c8b4ef868b0f80515f6469a79550ccc34aefc0bd04e393a943b7bc58d15510f7a64ffdc3cf8e6a4be13aa5f4fc07cbe343214c1aab8fe2b6f7697a05d4ccc121248fd7987215915091f21a20f6c51ae924d8eb6e67ce03f55ce0ed437103fa9d0301806365807bd368d42d39f0a9554cca25fb8d4a047c653d3e813dc0e79a3c42ce7a13e9036850eb58ea1335511d585e815d39d0bb50424de7eb35fdf32662426db43d04d895d2ba0aaf2483b3247799d8971f85c1286b3cdcec94195ed0c4b8b8c70f111ed6125019afca8b75a4f7353fa82586a8a8511d4f24f756aec26d20941e9286ce05325ca51814ad1edf518f113218e01e8756c8bfb40d440dfe137ade177ea607f957bb54850806fe021219954e452fda84da129bfd1c60f803b86c906091bc3d93e5fef9d537c7c987b0e09ffaf72c45fc0de8309bb6e57dda70ef3fe19b1e44ace6795201c3db8a47946e377fd68b20bceef835ee6404c594074948c8e96931634be4abd6082f09b5c7552401e1257a3af9d2367c8a3f112a4eb527702ea10f14a7028b9ee9a9cbbc7cf806a91027a0f0eb59fa9408f41b55ccb0361d3d0edbb76035cca0fe8c3ef4796aa356ce6426e83dc28fc6ade042650ed88e455034cfc0f900d880886e0d7453caed98a32b5f36dc9757c517f69892d3ca87a20ac07d76edecc8a70c4d9c0167bf8eec30e465c8ce4931b2e2fcfc86f56aab6a27d75e1040641781be1e5d3cf7d9248abab60758c80bfbf4502cf2c946f068645cc104b6f437630a541e7e68d106a374025c09ea6b2eb49cf270066c53e8ff47cb7f773439eda737dd5ba568602f5629ec5ef79f59cb75260ecf1bbfe6990eee1365996cb7206c1647509ff1fb01539d62f957bf9a606c0d53c0e766983cc4e45a8d905b26840a66be2dc9edb61effd41327e0a69b00ddddd86e9069b03b24e85dbeb85383f8502318cb519f2429fb3f4b300ee8cd1fe3521cd302bd8fc5c6203d72a3c8c5a794c95ecbc1e760223ff21c997bf040ad1ef2356284d237dc679af8c6567e08af5e31682bba9c599b6a4a53c875b04cf81de3465702e3963cf06ca38cbc670346422afd15f4b3d4065c27d3a044063cc0b1a9b3190f3675d8f0e500a624fbb7cb917288b5656337b74306ee8d990141aee64a1c5418d1badce0dbd6caa916086773cd36297bfec272a983aafa0ac0750c48c8bd7f6a18705d0e75c7c031859e02683c8b8366d83e5a89af603af3962373776af2e3e74300693156e478b19e2ff9dc4a6dd4b5a5f23c435f21327927befdfb3dc7454c87c4e139067c1eb796e0e1ef6a9af5c261cc90ddcc645b70f9ad07a5984303684cab9e6de17d35d40cd4314ca056fdc0fe53249fa84d0116cd277122cc4ded2aa22504d225e47e0197f14d14d81c1812bfc5f58977d5f10ed0aafb129e62cc05aca53edbb8cd268ca835166810e03ba9b74e0d6f30b7810f720b87a1c4fdfc3a70711270351d4d318e672dcd49bf071bd82531740983a00c76a7b1e2ce927f652c7b4820f9fcb0fbb7e581478c62de7c03b8b599abd35c1201514d6edb4adf1b04aeb8ef70f2ddc5d20848126cc3d99070906582c989817fd327a25f437b2175b62f7eadb6c9ac930fd8ab259bb3f52cc3a04cb2883090c565fc55aec749faab1352484b68f4d89d4a8ae4844ec1224ea084d0b0ccd5500c2357c64736711673d5c34f74c1be47af346450b587f7ae1124e294c1b1de63f138c7c47b7c37bc45962035e1539b5054d8ec77e04a4d9916749be93d140473eeca571097b7d7473580fabbef31d81ae5f69ad56cd56c80f3d52ae639e7e6f7c19ed04530b1877b9e0120971e1cb0304f3362c8f100073386806ee8f8b803d04847ff25138a1324fb4e5d61053ab928e789a973574c060dfeb25dfb653a50f3bd2ee751728a389441e314924b3caad31dcbdc71f3a35ec9e3d2ffa040d75247a781c2877b9ea7700a284ce511b6fda23b460164cb96d7bfb3ab3115fa676a19d408486521c591fb45428a43d6d014b04ca7a9d01c0498306a1d54a4a62ab5a4f23c085e6c940dc294320075e78c8927cad110370fd0f9a6b8d12541f41f00d634b29bda3ad8cdaac7d45ded7a0cbaaf7324ff0b82f289bd7da9bff5819a5d43a612527bcba318df06eca6e19db67b3f7c868452615ac55fb195e43034b7db64377be53950a00b650b45a19250fee3ff515b862db6d88272deb9090e6d1364721742c5a6887228851af6f3aa7a3630aeaa782cda90f14fb4c319923c07fafeb8a6fec1f7c3ead41ce2bf9d72cec526e80c21aca31c63a571a4d85b4e23c8bf07a057cad528a322226ca08fe6c55423b576e9defa8452d33e0d07a562e325842bbc593cf08116a472d22e84eca1ff8141620762360d4cd8a0afb7c7911136aacfc3a87497d2fa11898062af66b04bdf728620d10182a0faf9addbb0caf6cb9c23149de5be375bc206b5b8b974857150ae8f605897357e00b16c5f3a6d45454e9acedafe4071b7eae2f01744b163486cbeae0ca9a320c7d64baaeb7feac20580a38b153a93d36c5f7b1518f030d7304775f76ce96bc8d6ee0d27e8b0f3e00589ab13cfea1d7f3926f7bdb7f8d709f549e6027e7486d6ab35d704d2473b74b2d7d9ae69076f3e12919b1d5746b49398912053a871fe9f1d69727d51bc829eee393f592a34a4b9cb99ce4fca13ef989952bfb633c5d6165f03554a807ec41a259b2d0d84005916dbbf1923fa2effb795b0f4723bcb8f288e5bcdb11ec6dba511158bbbeeb1806f86d472fa7acfbf88fa5cb0d33d802fe2fdab30ed08f40020e8912b598196e087baa297d61c5c4afd276ee8d6e355b071c433d55c67034ca703a68be91818c6ad4d06e78e89ae4d601f8a669cb6bd39dbee7ba45943046c97387f1d611c3b5094332fb7ed154fad7c0dd1cfe96a2901cd52e72c094c1372c4d5d1fc8877f474ce33175132b5ec56bf7e520cb28c83dd3085066e35d0b3d9705e3eb41e28d1076428e6f31cd8995f6193593f1a452e8d585daba308df53771f5d36fe1fbf1756097eb46e8288b3bdd10e72966f89694738c179288673f869cfaf1f103311c7851de6640080f69e204614b8760b3e0fd135d89b871e71f6c8356653ec38bd2b4bbccffc87195e53a42c16250de666c241fd3572ea1f5d577d85aa61dc59ea0fc27e48bb6a9b20c887e0cf1c7ebc9851fb1d06f9c17caa0ce5ebab3007378e4fbf653515589b950a9b7aa72af92475029a0401eaaf9cac88e366de75b41fe9529b0f9d5ae0fcdf7d5c4a289dd28892c26b0b3c92b44233cd0854a8c069d2c6bf2adaa4d4da105d8ed7e27a60dda63369c58d5da470a27ffd4aff3fe89578ba3d864e95ce3ae8e12c41204c4b96b01d26986cbed032414445f8b03c6e6910f6f7c4c02f47fce16aba5b73598a475819aa35fa07c07e28981763c7fc3f95a6ee2802f840322c1f6053ed4a69c3b3d888c3e1973f2212de68a3aabb198b173a0c29efaa7f72328e837ba11f769b6b8f734a3f9b990cf9496a6288c1b6923931045d41a182d3a4e7b7ab324b8313c8714bd163a89c30d3150d96e6b8fd427da869b30c2dc971609a22195649b4d65241a2356bcdf51e2015beb0a5ebb6c3723863fff39d79e0bfefefe4859b1845336197018cb8accac48e9581dd5ad25f5cded09448f53c6ebca6a0f057def7bf28496c782f34cfb14b731466d0fed266e61e4776b4b368d5fface12bbd03fa6be441065bc8cee8184ea8e11cdeef3a275b530e1cef928a940e6d452fc8aa7080ba480bd6045f808e4d7b6d78d87109dc3ce7b181eb4996b6c7032ec204dbfb7f9ee8bd90f347799ea9f958e3fe8ed0a245729be3237b351b08e5f8333c039f4921380f411746d5e158c9e5586c7bef5ac6aca09eb97ccde8d446b1e1e74d0efdeca8f8f76a6cc100244c68489cc3537ab6c8c3676f02e944ace2a436d6728f203cfc992a5dc55861624fca07c283cc87b2dc78d218602541bcecbfe6976ec22f3324343b23410f9bb502f4c5095a08a0bfb6f04f3ae9422d14a9af85b79ed959f6c9125af412b6f5c799920e227fa2d3940186e67137f9bab686d13e0790afe5cede471de6919c7b4a677659c3d11c4a77bb3398c1e2713b0ff26ad7487a98074bf42647a2094f2cba0e237459a339ba4b53dee68cabd17d0aab70936d767f9aae8e184b462b9e2bd9f595cd76d7cc0ef3f3534b3cdc71fb3ce6162f006941fa33b291fcf59bd49cd6d30d4b7762f7a39102a7041b1bf74ed50b1a17740ebd1263c9396bd15b5bbbf8f91ea351663c83aa6dfbf53f12ca0ba3ad2c702cf767d1e0586d4d46ee58bb71a8af689e0fa6248a7e1d9e0c85d5a1ff1cd5b56c187f7bc405d8ee2a3b08e78072121be4fa6fc05f426261eb57ad8dc207e56cd4bbe18ed26ee7e930d8ee1afb813c2ff9b4a4c534f9ef62e46620e79761807ac8ef3cfac9d4f568db02c9b2813d713b56f56767227a97a2c2697f33188aeef0b5f6700be404546eeb520f34017d676f0780f12d80189a58b1264d9483d958e6930706dcc69bc193df6366aa177133046595d590eebe77ae0a6b98c1386a40aee0e1e7038737eba691cc510b2a0bd8e24c43c5a5cfa2e90a193db6e70f3a308cc59a0857cc593cdd29c08292734e0677b834c9c86b7372bafc453acca794cd1961606531672d3a4a8844e326d664c1e7708e7815269be730a1034eadb0e841c9bab7eb764c7533936b1cb3eae8c0c3c6886dc2c22893ccb181edfbbddc1ad4f29fa29735ac49c26759906c6204c4e5ed8f9a70621f69df01dfd9247dd6ce9b4b0842bfb568fa2e4d0d2faa619e346c51bd532ad3ecfbf47f123756fc12354e643106df345ad35ccbe6f23477bdc7c58619c71a76c8768dcadd56d4a379476528b35955aaa59f60122d33282951005f6ef4dc4a12026650e6b041c58edac2d62fe79b13374d51703394ae791104159cb48958adfcd8a3c9ad0399dd2ec441cc30167370883e6926372b48ae3fca0393a1fcd10e90c88e0563be5415b43d44226e32343c6b2d7921a5db0ff76aef8ab7677bf7b5a58e4715c65fb3fd0b1c4f1b26aeb27769aa2e8e61a5a27750999aaf885f07978ad39881ebb8245b36fbc5020497a38f234a40b62955f7ae55968dc18c01d89b3bfea652510f76646d0a40b3c3fe1f9dad77a2ce1a1fc0b8f79c84c3bdd015cf0b33b4d2ee3335822ab7a16e575752ddd5be9990ddf87ba4b579d817ba189dfa401c9a6885c788b9dc32ae53d003ab900789a3235962fef847eab1f8ec1b577c2b8a5323b6dd62aa6a36094fc9467048d969e69656f1d12d5d5c8dfbb9bab93847064c1750689c4cb91efddd398b77218249bc2e4170c5a2f01a7274db0170ca295ebe462fa837d3cafc68280cadf85ff9e81a7b2c82011479c618b379b33db38cf517d6eef7c301e6b294bdf568d64478eb5a559ef2f6eba7c80a6c5fed43d0278f2e8d668028e28fdb45d50ebcd8815c41ba2137b013657461b6c687018118a77638404fcbb14236a8942fd9cdebe0bfd6271008e87dd7aa7147106b315dcc04220d1bb47d1482735e92623e95eefa757dd9517fd52ee87eb91fb8ef08ab4eaacc67ceece1e32aa361cf66775420b7ea5e1b71b7fa096bdc742658fab9a6f77002076d90fefdd75de4a3a22f5dc297e016ff1cbf8a50fc1cea02038a35b644c4f2197e9953d25c7c330b4abd361de7c2f589cf7dd1fdb38b7dadd7364a036b3cd68b40ece65e6fc1b39ba11b3a083c5886e794344cd10cc5ba0c4b20e2257fbc4c14e46631d3f51e407df5e49f93e78c38c8471c2353c8a528d4701825fec4ef6257a2584797ff76444fee7a039b6ff6aee197492f49f93b5ec53cb3de31634d3305a56bf06de49dd325bb806118d8341cf0dff130245d7623336e65734bc04e2a40cfc9640bf93d8147f9e7dab8ae15554707731fe1ebf7602868baa6e2bc5db33269043bdf1820f1159f97c8278eb76b45aa756ff8989c9cc316e6ab36c970bb8c0494d3a05c772a609546472e5f7260567ea40805eef39dbc2a01f9bd3f3e12965e159f1837cb9d3a582b3f67ecb1e1213d2466c9c198388574dbd15f0cfee17b7647c277f38e8fcb2a4eccfdcb3ec97eb583369cd05314acd4ad2e1a49b2163502162fcaa02033079f73a4aa6a7239a99966d02d2c54bb417ea1810e71d64063f704a6037510c1e0cd6548d4298632eee688e956b6835dec918a02bf3dea7ee5bf915fdf2ced38c9dc9b253d9a925ba86ee25639aea437252bc1284ebd2cf1a12a4fb7908c6cbef132496a776055ad2b04827a00cd935fc079f8b48a792ac4b5d46f9ac1c4547c9519441a95436c106eef82104be4ad708e1c494652803c4685b5efe738035554148e71407edadfe5f28034a1264a6db10c1b9b5fa52d82b0d002f346ab4e132f66de8b980aa10f90095a021b5fb2d5c02b210a73712a8c526ba64a2a599bcad3bd7b28beacd6a5596f1c27f13b09104cdcf1b3618dbd6d5f295b4cf41fbfd88c97b9f1b60b66248284879f79d0ac9aea828cebc781ca9c75d4640885693d7000c9ae1b5bc3fa8671a0b32364e58c6b8a94811e6863178076e3d76e909cd71c4c9893ce9175b31abf27ce2158120def0c1b3c2708beab4a72b3fcdbdf56d9fe5d2e5e8b4d1e46c4451fe8fa4d34349ad261f4f4ee1b8bb4279f9454d6d7d61c9c5dab09cc1aed12c8fb40d2a8396f4914fca3248e200aa6b127e8a9d4d26a5b1cade83f3ce51172c3f78e62b83444899cef00865833835ab88f518f8e15a777306f89bb3914dc706d6ef222bb1a4aeefaf74de0f8d09d352205a6b0e30bdce184f8aef4f9e140ee5eab72eea95794cc5a9de3f69b6fd9d1822dd8796684920415aafeb8ea331e91a9bde27d1417f63e236e9e2916e90fd237e459db8d29bdafd515568510247b21d74b2ecdcaeb18f6025497687f8ac38ae8f43a0944ed52cc7b1096f74ecaf031f34f45fdbe11450730cc958a1368eb3d00a1dcac0afd64597f199580dd57cb5c5dfc0a1618c03d34e3504f99ec63ceae31f8e3979d71e53838ae94f073437012f76cc409a1516247ea09f2fdff21e1020734e632c1eabaaf7fb17163367572b3efc0322288c64e0b796b713a6798caddf3fccce383c370f112b92bb96ff5260410179534a9f6cf3b38e8edf61b09de7da7c0cc9e9ade46523f65466d82cc71f72088765867c504c840d99574cda1920b667358724021f8b75d4971bb4f1825e463715b867b992a90b31bce05b5a536da0d43dd069c91cc10ad0e4ec1fc90275b29934cc8fa52af653d933fd14aa16c50c9a3df1ff989e1289dc38da52e8021bbfff6659c73008044fb50473eb1e4817b78ce923aaf84462fb1841bda85f590aaed8aa809a43c8117e470643fcbda30e1b76c0e8a1844cea1676eae1dd86988c9b3620f050fde5336946bd531d3fb886a88de251f8abe0c1c8dfee8bb92fb0c45d2fa4fab88cd700a547aa3e39709a5cf08b0d64d3e47f7367268202a133bdb6147b1ce85a7fb68d88fcd83d8213ef154089a93ecee32553e2486bdac097f549385588794b9dfa491b280a1de1e390437668742c74e7c39e53ca13642acb28f352875cfb0e5143b169cc19944453c768582238ddce0d339be3d73b67bd6cd2f99bc857779e53ca2b93c8b18046f87e72a397c5e7087d54099cc628d048e8ee8e8aa71747b7f5c236429edc2f842e611873a8a95ac555c47abac4f1fffaac401d931a48b5857a6a9f2074713323a5eaf0240727de0d51b6e526cd0d9fd589fb0c1e349c498db907f368fd0dd0f46a87ec51c86b0c9223b76cbecbcb19e17b5eb3bf5c7da5d37e79f53829ef202ec1cc58b2687deb3ad0b1f612f5592525a80db07e3f4d2fb0b737cf9be488c485843fb6064022eb214d4cdb37e749bd3f8568b42b615e36133cd1af8b7f22922bd73ae4bf14b8dfcfdf5d1b35836d6e2a820a54b6493e01da1925c98030cc86e0e2d3fc5c6f3266dfb6f6053206fa90b1bad887890a3f2421e37619cf8c8f9b764521a781cc1d6836df019284b8e9b8f5f7485b93bfea520c22092090dc835467ae2ef55fc8619ee8122a07788d125a46237aa3f5569ebe62e8a7db4e31bd56ca5e2409268057c0be2b3474eb8fe841e587ff33b8d9c97fd010b8008b7751188a1b701ad3525bf0f360dccca9e8f7b8ab81e55eaf33ed8d74be47a294c3b434b7eb2299d77861be4ca9ed841b9fe232fa6487efe7397d2ea410a94df1f38fe8a026cf2f72891b811161cdb87ce3d7e0fe4a9c6d4da28dfd4f22cfc1c749fc075f2fff5786b2c2d3016ee77df0213eb78e7e3e3bd7a9bc4c0051fce62d571bf73f39f038e70cd60dcae9caf1e950aeeb492ea4fb99805f5aa2461cd99d2bc3a44afbe52502d96ca7edffbb3c64fc440a90dfb3d196d61c3b03bdd8a41f6835ab9ae9d60802eff3d8560b9104dfca717fa4a1933a2e07c005928d4cd76776c217e56ce0431f3cbf80ac1499f3cc7bce8867f0403f430bb0a5605250388787b24c1c4a15a41c270acfdf87982d3ccac6049b71bdaf73cffd3f42bb9a707afd6f4ae91bf0ce7bdf0926fde3cbfbcecbae6b896b7a7290e4a47f74f257639e94468a2ebf30bf56809dc410c960735ba7c5841224365068f3a2fbfacb93ac520f00e0497d24398cf294dd4cde637b85e64cbe0c3d3a391d950c88302afe77c68bab99a085268cbb754c2b6b5d17c12f8dabbcc861b5092f277868debe3c0f920120608d07afdfc9de2184d88845103d852071fe5e5c8335b5d94c8e284d24549d98be0c55d0ae43f6de4a6c485892722ddb2732574083adf48ac02121c42d435e95f09bb3d465ce109c84039be1bd9898e6491d0cc8f406fe93786d2672b5ab1e28cc31e8dd9d1828470e81198cdcc8671a9864c30db67723e02b9e123db1d0914f402c694b4c5052945e0d1021947e62469db2117e5c1a548263c0fb0757309ef823bca595f3ee08251b7d940df43ea9547ababbb3ec8136f2731c88750ba6b7e0a7477c6611dd7173040434f5854c4bb3635cb014f2d3c386c16939cc01ed63d615618a09e84e50f573d5fae9f66c1fa9860be68892d730003af1bc50b9205320bfb8f5021b3f10db37aae3ed70a31badb406ab183bd1bab89a99b211da691ebb2f08bb4f80e51a52b5711b61ba8a346872b41b13179f8c67e910006491e1eb67d75b8d44bd0e47425c7496228418b41b3f618fe66f341630d452bde732c0edc773f39b0efbe3c30032f15015b05ad9f211d29895458913bb06dc98cfb6a655822eef508908a464ce9be1dcdafaf71241a0f95fc575f3780da0ebd50560d601d628b0bf4ebcaa025de6f3dd66c2fa444b9bedfc2a5b158e75766df474da3398e6bf0cd3d31545880ed7ef31373cdade36ae510355fd3608970ef8797b0d207b68f319ee3b1b8dddd7be57c8c577313ec41f4ec1d9ee724c9ea1c6582317de9ae7c94d9c99fd748450c2ee081db1570f6adf31c24c31a425643a15534eb14e522bdbae084506bf68a7f9798388c33e92c0c8265e0b77235cfa5cfb7f32a512f51377ccbe8d5731a18e3c1d74ef4aa2b72f03c8164564e330e1a33f729f602f0e6a86b94e49425be5e97687ffce42598dd8afe53ae72fa238a75f0f892bc1377fdfc27fae4bc7b014f3a6049287f88258d020ae46e216d74386b1f6a30a319ad49984b3b9da7f6ff3908e839e0c0486e45f30c4be0221d33b8b18e449ed7af5f55a9a6755a4642723ce795cab9859af324939896298bd7d7ee78685a7a4eec73d4653f7f6bc63cfda520bcda9ea5e5ad7f94517c7da11e356506ccc744aa712454e8c467e99a3e28c0b7b6a8d6a1a7d8f40f21724d6ab2119cb5c5e38e3ee31679f7e3ad2a1423f4e52ff5dc68aa654ac730c8349b8d4a6e0c0e2129ba1c45fbb1edc816282098e1520df2bd01fd30f6077c6ddec0db2eee9ad434df633a0f0e0308ab42a6b4a2b71c70243f6cd4cd8bda7904f9fb026c49d408675242d39ab16ec9fd952ae36b22f87c507c16767ab36e65e85c156e076ad38dbbd11974b24475866fde7cbc50faf79393d1fde934c58cddfbf966578117d9fe10a85168036ec4e77c5d9227219dba1cf0c6b6629d60afa94f1cd5e9a39dd78e43662403660a7658ea482f0742af3100730a5a012fe926a14260e067f32035d17c2c059e331bdba04483840adb4974207d9af476c0f57ca9b7b58bad3b6d07326db7b6ff9a072208e65a7cc1af4bba63503d053c798f0f3e2aacadc574c08cbe323e6b8153687c447cfcc3e80339bef784c268be004fa0939d3ec047f97e3a7e65514e9a1248b29ef77a18d36f0728b5d1b7df2df79be36ca1f2589387f32c13bfdd56154de9ec91c6d6c047133c833f57cb3dad4c3c226ea7feb0f66ac450a25523fac67a75006e9f04a5b3123ad177fabf2f055cb670c9efbd25cdf2d262b9f1ed15ca24d4319b396b5b542409c7ec9a256357e0180b53143e21b519345f54182a37576556c993912877bdd4207418469643dd1eef61f1f110b77b2ba29942eca6e8fc0721e2b93116e2d5182ea89a4daea18bfadf443f40201dbdb3b5f4cc798a5a9c881fad5d9ee67a2c7a20ba9d3f2a369d80af0cf5b9d5bd7e8f70249d7ba2a191c76ea018175dd516b87e3f90951f243440dcf4ca554b6ee386eafd513efdc01b2a4b92b351cc1e10f9a939f61f7d71716345ac0d4c2f908a41e2c31f798f2e46093a538fb84108fbbbb667c83e74b1b0aae384bd58e4a9e2992b46319290c2b77abf9529670e71718523d22e26447fa8a1b87dd06ad1c82ee830ae4d0d4ac82b1babc74ff03e691d27e19b4783620182d9fa39e2846fbe91d14aab89e7be52767afe1d25ac06bfce763f2516c1452bef0ab55767c0e5e4dd4148aae36e33e01fe5d9b4b6a95e81287393dc310a4f81f49ef719fc2c42d81424aff237581c193dd42af86a7f910dd7ea4bfeeef7a534910af811da0356d843d72040000301306ad3a82f079f1efacbee35519416e3c47c9de311f898e7a6795cb4c0a565fcba797f2293f353bb638f7a2c434246b840bde9b85d3b9d5b171310d7690f1c5d567627c95b91b9323adcbff37a8cac5298e375c4e015b85bf11c64d5caa8b890d91095845e2483c14889bcdb8ea682f8cfdf723e32cd737ba99114d2c648b9947e7b82b6982fb7bee6f5c595c9890b18d2110d155c687acc5bbf77c4c4a47bc0c83a6b6d46a7c200e9cccf807bc6079297dc8b8df2cac42219824d3f28e9cc603e75fef9010c76e7e6b73f7d34b2d79cf5e8f1dfc2399bfbf557d767c305fae24de649e35e70dd4d0c370421fa903b8d8bede4df7276d4cab1e2da7faeebf5649fe14365714cc855dd065ad6bdd36e7b77d3b6a06225681082a668926a1dabc77aaacac8f3ac383453114de75e15ce8904a4741ba43814e416e0b8eab751481bfbc7017f4dc33ecae1e78510f6c7df03d09afa61b8c15506c80cfd311708954065725fe7ec67d2e42cd547414020f9f8dfe12708604ece5ca3736736c708b74fe42bb00a32ed1af74961cba5bb7ea14866e4d761ad7689e9ad529e5d6b4acb819291a8e15e06ef8c0c072502db3ec4f7f1d243943718d4af5b87bda0ab138e5dea6c544956b5aa0220e453f215834e50f55e3e22c0a9d0f58a8df36ba5d45d198d6c0d15c3938e451b4dd6a0238a5b3e4197666140847112437a02d9f3b9b3cb24e99c258d984c69de502c671d7a60c1f2e471c1dfff3edf7c2d15c85ea76290c23a7b98d114ee5a217e22ffa4851f0fa5ae4161cc04bf2b6e731e85ea7b38718ac3bb4bd27679fb9dce87957216240385a872c7bebaf8fcc66544f0db6db96c1db6b4b54d6c6f4fe517444af585d737c4fada2330fb38c9ca7a93c4397528f35597dff06553920a6b242b3e5a37947302f913df1ba95de154d31dbbcba20d49f2e4acc5bf1b435e3c5a3aff5f9e4e03f2b7c4a771d796546991b51e7d4ed941c04a5419ee219326be00b7612413826efcdaccc8822038a278859e7cd6abd01f4cf247c762820d4bf2aff18955ad73d4c0c37eed30d84b06f337122c6cc48d51af6dc0dfa7afd16a1610bc481eb897477f86ac0d93b1c24cbd1804060194361ca475ebff9f7dd355894c0fb7a520dd62acac86f1d5ff2cdbb5b52b086a8cdc103fada3abdaf6481e190b0ae07bb8cab656d26bf0f142e956af2b57ad1106702482d289e86e8ecf9f4473977023b414cf40149250e2fbb54f461745fc1b698cab2fd402cdec0bf49efedff7ace05fc78f2b932867bf4f4ac4faba4c22d129026244eb04d880d6f01250a40f74567b8c91db3aeb3f9008cfb0933bb7b7ffa52fb17c19313c43d71a0831da28c637d4aefa2a19f213a8722e64b1997006682bcd74020ae369a6690ba4ce2a0a35787aac6bab684e68829ed3544f87c87ec04d71b86adf485c641b7e1b162237b60038bf66f58b44c88f56a97ce2ec5d44b00c6b6973fb2a7d53c99f8e000851eb7b6386fa34b5179ce8d789f29dfb5fff79efbd6041c8bbb932fdb2411942dc03a6abc046fbd4e8b954bb8bf2470024b8c5f18888a9b2a73b51836132a121ace153efe47ea212802ab3f177ca07783ca683508455a66dac2fd354a016e0904d7572424590b72edb35864d3454aefc90fc8c3d6061214f63c29cdbf671a90fc8d3f0293fadc515603a569bbadafd543e300d8dcb554f29cf495362b3980662c10f73ec8b81fcc9929d1e6df48161cd7bc528f4c38b07b55e6c533524bb02cf7798055c3721419075fc256df84e535384dcd5a1415d84ab63af482e51856ad8bf12759adb521cf2b75ef9f8fa0c756259f2418029baa6c65eda6d464d9780d8b76e536af8094cf201d58ff5be3a0e84a7644d8fdcf79e80c483d1f2ff68014d0971d1521f8978f8ae7cf3215777418722ade3576db8273cc6897e4b97a5c847ce8e28f7f13a4dc927ee27f363d00e191b389ccc32d6934348c97243b14fe1cc31d71083f77c161af1a2b3325a3b0a3e63baff6105fce569758817b0c01130c61a7077124ff607e10997fa56f26498cce57e0fb8795d642b4e774d1dbfd47807e2b93d4ad6fc17d58942302260e4a021db813998c913722d01c59f9ab6d1d12e650346aa9302f9eab169d5ee634da914e42a6ccfd9c6ed57fe7972795fcb6de49f3606386749bf6d4efeed39b7f7da907b3d86813d7d8d991e5f5e5e0635c1639201c813bf4c7b91591bb968186fd39d2597d10104b9170d0f22cf435f7f21f1ca486f8e2c100893422f47da507f1e2a0a483f6cac315d97e6e1df35a4bc6809c9a7ff7981c25e80431b4aa3d88754658b682f7257fed94501b1ba961e8f4ceb8f802065ace2d3c4e3b1c66cd4220f2bc42c87f33b9a950a2a62f04e612e770c8bbfd2e1d053471c968249d9b28dc240de3c7761eb724c1e01adcc3ca8d7568202e57264988be350078b6eb34153b2cb12ee184107c2cff0bed5c2c2306ae48668365b2704037f5cbff0a70ee90caa902709540271921bcd9a11c2df498efac9ae13ac8646329068d0dede9fc67e68c3b4cfcee61c0cdc129467e97744945396148f488eb0ddcaac5135f96783d2326f59c1958259e63930888979f1bd8d28a57cb31f935e21bfc675b9644c73f90936e12d9af9817c8ed7b70c70cb763883332a0d05a963ef05716429e1ed5106c3eaf5951f41196935315cc381602f7c8dfe7cfa7d4f30af37b1ef9b0b1b631b5f281768229f6b4615793c847ad2b8c7128777eb2b16d8011b17160abe1575a3286cb1547f067f465175c6c5d37dd094be275aae43b06169c48910443f5945fc687197021521728f713bc1248cedbc44be5814a9cc459443e93d7c037d0046cff75801a99d9ae80c1731ffcac6074d84ce7754f071043d90515aa13fc00e5b3fb297367f7b4348060ac4cfc6addf90b8f1b1b562491c8ae78afa3afc64d1a1ac285219d0d11511dca7482de514a6df891ec93ebbb9ca1a12eefac3ce8c22d6c34ecad58d875469207eb44eda3dfc9c06f7bbc392f5cd753ae07f5249d8d5e8f61470bce7b03a45bef0b4c4f7b0123b6c5d345d59ebef3d7dbb192320afdba0da556365fcb9c6d9aceab79cdd5dac43a6f5d7e69b9a5f9cfe46aad3399dede5f559ca33f95e876416c1dc2f1bc3d443091fdb6ee16f145237ccdfe3ab17fe297fa7d12f7eaaed2b33dd6e1bc271786f0dee29e27a941a8d6e474fdefca68642c540620f1b618d46a29a71ab3545e40c0774602e96e787241d15c024dd1e29d7fede2092d6b0d75f9ab554cd22f43ce620fe2a278b7f09028c962a7e48558bc98b18a759c3c086179a08c460ea20606c71443735b670a83975ab85e2640ee66328c4fcaeaa8bd257f2a64ad12c43141ebac1d71edd8db7dc5227f55ce9b6959fa5ff18563ab558d1d5424b70f50f1b5ed2287c7adc1b0267cad4ae3827ca4e946a9e0a5d4324c0e087c60dcb6cb2e267c96da1215bb52e3f85e74283e4905867886aff315d6e539c1ac53a176ae8eb62ee8424a9fb86db005e0a220456e595d4dea9110f813aa20e5a7a3991166f5b30e6caad0c2f4bb45daf385c26214d1babdcdb8a5efe65e8af14c67c24571e999061e52725dd10beb1e0c7b9be48d19de21ac08171ab1d2ab531542c0548417593ac6bab1031641c2a329dbb80466afa3c5dc5fc3ead107cc9290ce23874d0d38283121b17ed0d162d4bdfabf506210af7b0122c56e1b838f86282a45c282bd67c0d5c10c65cf8b4734f91c2d574fd95a55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
