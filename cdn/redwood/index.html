<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26c73f4c0a805f8a384a97bc4bde5af58d11e24f4a084e78717042d515256fabc91e6dd71566a2a32f511d43465ee11209ea371f0fa6b441977c8e345a8cae4ca605e0cca8224d78492b31a91c2f0dcc4a9ca1930dfbd3a0d3e0278282abd3c0a96bd42ad701481880ec587d5d260cf9d53bd37b9ab56a43c0bef621f36962040ba5b91f9b24926be398c286d3d072d7f4f18733452249c2f865942a5d685b66929b089dd0c1791c713cef8721d6a7ed6f0028292a06f0e3bcf3ecd8631e0b33a4827a209aad7167c330f49b4c15d45d3871e1369dcb6ff80d25f07d0cc5d7d8eef67899858b265f64ec760bc0cc3c5c07ba17f0fadc5ea60dbeddd91c51fafd8f5cadd339d07ff0a5b943a5aa3ff7fea0e271cee241548101c65625e9a9b60216d8a23b82c90538d8194a693c8442a45ee6d9c3249346486874088ec6e1e80ba74abf20b022fa20a96fd0715f6a154a3c2b8c57cffbae93f5000cd1118b4f3d4f0e5672f071ce02ca7b22e00ac3ab701d2c1e866b89f6f4d3b477034899a6397d905d61fcd9977bf8b62b91a45b0c7e5818a2c7c60af3dda1f6e78c8b25cb0797e4eb1a99ce1b8cb77f2c9a0f15a6c10958680bf520d887ab4723d0aa88d71385220466131b31c905bb0c2c23a241b697b2ccf486ea1c3ac1338bac8cdbc8f8c594c033965cb83a98308f26283ab698ddae91bbfec5fd9025994b4baad585bc455ff52008271fa251f4b054714652351816b8f17c28ddea4a51163a013ce56f6e5393ffd950e20d74492167998185b0fc2430ac7c3d3044b589747cb3d392d362609ea65847476fad801e31bf03fee008af7314e93d4f2eab241df9a8d3b1212f643d94d404e2bc92ae97ccb8404f2388d04c7c2c7a9a6271fed86dfad0862b16bfeaa1f4550b73f7b78290497419f77646ccfbd0e1a2e0437eebf53fd42590abf2bdd94f4c67f308bb7fa5b55a06291ac31034112584fd614a09dd82d3b7ae59ee9c51c15ef9fec382ffd4a31a05284f6c14948f0c9daa0c57f1175a449dba382972d57426efd804e4ab3aa3d36a03bd931a316e475186c69372f8f32850d6a27c73bd6096920c19cf9db5afbfaa48f17f6f221de2cd610091f98a0af9db74b354cca62a3205c585599b3b5f2fb1ed17c0ddcb07113b47aba8b11930ae803d80ed3930d70b873a0f752b5200c5d91ba136a8d717789ab74b3283679482e6e8c658f1f1422a87aa983c77d8f8c27054f75c76013232dc862405253e5bc6328e0e5e41b288b2e8d772b777217cda4a684debfdfc0e542327573d54720d45ff4bce8256f578d0331adc7a6812e46ed280eeeaf6b41bb5e379218ddc66faf13130a0c7e8f0dbb0dc9e5d6413606d75d4801f45d7eb9cd9e61b03ca0dac4fca42703620501a19414b88ad71d0213f26bc2a5146df4a26f4a0a3ee1bb06ae8bd2dea97f034be42395224fedbbf2cf7f7ae2e7419e2428a2557cae9e0e49c69e033bfe3575e8f939a78c84ab6d5462e7ecf185f37b4d99bc67f1de8147bd7345c89223e68aed3e1db72735a01734ab78b3a760d1dcf048e887f9a70dba87bc7afc1fd40e1c7a6b791d39bb0fab6eb839ee0855c7af4b825aa673602dab37326c6ec9b42d6b2491f545079b34eefb427f36ff1309b5c591ddfd5391216336f5a1516fbafbdb0ac62130b40ef832de1d4c5309c5f013865691579acafa6f9b9a6eb1748ea08fcf179f0c66a9e845c94422118f95411c79ece48b58e93e0f249805e62bfbf6845a487e60b43c0d5d68d95f53aa65bdfa8fa2da373de9fd781b27e08c08e8ff844acefaa9fee6ab229be3505452c62715f38ed76e3a3eafc12fea40a60807bfa2114d64c5935dac9a3f4b70d330793a276cab1e7d1134d80d0478742bbd4443c6fa2711a88a8a3c0179581e9d0006c8ac57be754922579b2c70bd319bc1343fbabe0237814637fe6bda5991d19713c62fcf0f772775322ef879cb9cead0bab2013f30b998e0f39c44a9c1d4682272f9b52ce091cf0e39aaba8d57b592b7558388b5a2990f038e692f69c5abd6ac64eeb22f89276876bfa6f85a0b79c550f31435931c042ae66f286dc008a1e95e8d5773ac1f1ca86e5c972845f4b86e6ed1d7da15a300c70780b0638169144a2eeb641acf25458c465ff11263fea1c634eac0098514e8c0c26033cf5ab42481b0debc15654ff9191a1e5445638b0dd55fad572efe7d54e55738b0a9b4e752688892aff86b7b2448be020c3354f52de23cc0350bf61976da33796b95294f03b0f05eab984b58b2209393b362ed20fd373374b5fc2232d721257210e7688313fb5df6b81a1dbf561e8f482841b395aee2017d51be1f4be6cfa4cf413db36aef2565d8a5a038b75c77c61694b32bbf65adc09166aa121371fe202e8e5bd44058c143a16fe9283c3ec13bc320ff66d121efcd2f0d75d161ab2eea3b0581524092abcc432941580e293b495c76e05525492cd94e8f41fbc8245b37208394a1422ff1059e849290a81cf0549a165134eb38ff20f382d1509817200fb3426be9eec579f86abf16ed5818b81ddbe3da6b2a9fbaa57465ba2499c504523f89ff1306e892ccf21c2a33c35dbaa65d8bbdc9a4a509c68bdc409192c572fe40d47d55b229e3ca8a6dda4d5156abb1ff0ef9f3201559247e5905545d72924264abdbffd149915d4f722ff69561bffca0faa1ecc60b863bc98657006271d9079e09893e1bdb66f44548eecacf6acd84258a84eb152efb275859649fe7b8cbb8ce1cfc511a8a187d80a1d8a0cfd79d1311b5c1f819dfe4534b6020b225d4d9eb84163c18faa9f701429d27cb974804d3a401f73e085e323f7e7f71ec45c13700ea31d8a6792cafa648e476a75e926a2ee7988da45ff06d4118f367b5503492c6e6c169bc51f44a32ff6458ae8808505413d3277ec0f4f18e6e25deb8edb936a6bec47b76c058e7d3cb40aff430328db3d82c99b933cdbdea02527c2f7f85a24565970617050ea78037b945338f822141456099d6d203e62743db93e731ae560db910f37b4cf5eddc1b93ac6bc1b22bd2c44114770403d4eaea931a72d95e00c68c9b28e2bad8a67bf6ec07d87da30fe63ebb08afad0392436686eb4a6fc7f36f593184ecc3807a4f2671e039efb8496e4d475af8ef042bb7cf046945ddd599d36ee1eb5a9c8df6bd34fce0969b149b766cc92e50e864fc7bbd1b71f5426a15b9a917441965f73ba23a43491c28968686e4dbb35691010dce5cff69180f9a9d4a86b3355f034420b546dec1a0c025f4e4c8a19b0187e5430ca6efcab79178110d2ec092d4699a542be6d82bba37e6501d8589cddb905a4cf345e14dde17708adf151bce065f748add5e971fd665ceec43453e81c69a130a1580f06ca1ce7b1e5a773464ffee6248b0907d90b930809f2876987363fc04fe74b84e2003c02f9ca88f6545f76f3d0cffb0a75dcef8b246cddd6ea080d74e4427635e4497725404ad5e1925e5293f07e48e0bec8132db6389e5ce2640d260e42e90b76335cebe50450d26893ca3d96ea46723fe2cc622f9b5af8884b70697c86ebe316e3a8cfccb0dbce70865f6f1995b6163eff20af948a1f406a4b5c0b66533020bd792957a189d59d90893bce5077fce11e260748ea43fdaa87a54370516509bf45db49b0ca0cea5c66ddc5b3d39b627357e56f1039d1b5b7e23ad52ee6cd94b718ac4d8b0540d2c1a5f60384f97bd8f431bfc189ea6069faccd50f8c03b3920ce58461c56dcf36808131d232e7c4097b7456cc253868d44465fff0c2b62568a74af8c914e3deb510690f67729c91c9da587c6256d5705ceecbe0efd7216cc041a0e8a5b49cc57389d33783816e762b44bf1ddb3f9c3e28ae1b18d858f0f542018d9533f9107d5d2f0c46bd2fa4428b36a1393365ca54a7760b56ccdbdc337438276ebc7329e06204d5acd3738a4727131b4a40a98bb7e3459c114042a7843d9d356ad1ef2f0811c294edeb6722a42782ce0be229a1513d7c2096b9a78ffbd19e491579dbea25db19f09936d2d998589da6ad8f09001d2417d3367f9f1133ccdae544c97e891517e48ef03d0ea7db67690a61da20d079a48028b6f6413f75ed9329eb12789f60da8af78379526500604d53969f9afaa2ab2437bcf82d54eda82c5156ecb3167034abc631becb0f8cce049ad6257cd22689a9cef15d943f6f7eba185f6b62b48539169f49c865ebbae25c711738800c5ea05c95e86ba30e806e509077779e9bde23c91d46bc882a65bd83dd03b6f8abf73da695f3235e6d509783bb98b9a51cadcce4b704e38b9ad0075147ec7b46e7d6d0619e1fea9d8ee5d318847f9ffa6e163be857097955465ea326b376351f15f1354f5f2b512936297e0915488e82d9cf1bc5fb0c20696b002ab1769af9c5b7690335e1899937cf8c9695ced620787ad77860af8f51d233298b87652e552aa2ad7924e790668ba8f569cfa016579899276abd3793bcac1791d6d5dbca5efde96ec4aa917853527afc38b85aa6c09dfcea218b70259445c66b1103eac49dcbfe6a738b82a3d7fc65690412a1c99bb99f00f7067dcdbe742c1cbf5e3c2f8ac196e18f1307649f0572a747b843d5094dba51cb7a8394a4efeb8e06e20febe30642d92b444e8b4025059d4010618a97a6baaa837054c2dc18dbf4090f3bf3697daeb919b602af6ef0aaebba40f3f3b16bc85d75fa421c742890f756d8cc1d3bf55d29d8c2de04ac19ac9803579cee8e6a697c772e7e17221a156cd7a620dca9642a978a382d7aa95da0c6d33008a37383309ed275469e1f88e98b931099b3a3b51ac223fa0d45ed8d84f180fc3b6baa34e28bb549649ee605891d02e40b1799e299f11a0cd81bd4cdfb7fc4adac6a65a825b60050dbc504044678b748c3366b36b536ea582e332c16a7ddcad4060d9d7d557d72023155d80f6fe84bc7ed9db4d2bd345190c0dec234f5dd1d836e719dcd35e4c93875f8429ea90e46a7c0c734dc30f22a1a1572eb2d8de394d4e9a232870dd921b9bffc266df47c40cfb80e768bca14cea5fc4904d4b148ec82bba0d665bbc69090f7a71a8b5fc3f5f9a462bf7e9a641ce356344338beb0435c934f49caaf6fdb5bb3083d15a6dd04b405db7b38ea1e83a65ba96cd55a9a2cc1a7799847c92e9f71b5ed82cdf1d6ea408f4e7380b41d4dc7f9cab1e6ab2e0ed2432f5e91f95065179ddf1a8b0026907570bc26552adc0a0bff71af6e852ba1ce54b0e5052878ea6345786da033f3c6faea85e793cb440ae0b083209bf661e98694136075c3100a716fec4725dc8ccd3ad51cf21164cad0763524cf0a52995ae557c0dc130a05723bc33df18e8736def5ab60cbdb27e284599ba0de4d2a997055e55a66d68865ae87feaa4d29fced0d97816876208dc3c6ef2781f543f36e08203ce3b719648ef5f010b9751daeeee0d6d5da6cf63d8a8bc957593df286c998860b8c3b36baf40653c4ffd574fbd38154d602b9127c40371b35cf13ecb489bb86af67773a07fe15e5d15f130c253aec0a2ec73036173c283a83f127fc9e2b79af00bdb2e5b01aca05586ed7486701e93b0825eae0ad26ccbe5ddd59bde82508e51790afb8708b98b9183672a11f69e474717d595d44e2df1aaf99e6380b6ae01a3f6c62c1312ee0d122531a088dfa422ad9c33a51cc4986c053d9cd45af7e7c2c69fc4a19a00485f66ffa6023bed8b7f6a0e37f8a76a97f453b7c1ab6ac7bcfa90280ffafe711bf445920698e82672ae4c2646059667d29c3f91457a6687df3d613f5755c809bea111aafda20ef1df381612d9c2792b5f73e281dde454f34a22de97b05383c2b12291397929bebec8b0cd343fa48ce941dbd4632c47cf7b3f3ba08cf48fd580f4977142b6bf82d91c227c137acc4bbc220a0c9eaebc3842661497dce7c2fd1697a4a03b7216558e1118cf409efe8452adc20c313b634254f810e42199c282c82ba531571159f3c27c9ed9fb58030cb03083cf4cf19d32e8d32f9d8d0e4b5945d3bb8b738ac3e06eb1527d7c53a0f2d045c9e61e7512c1b98e1e76196733b069d8886028cea57db75fc4d665ecc84d23a28e5e0f056f3c7a6777582a6403af2bbf5db38448ae42852db83ecd463efff4bbfbf75f0707f0dbb372936084643c2460b7636c749bcc22d19af64e1717f76853bd44beab95b32213d53bb7e8faf6d3472beb5fc24447f1f9dce9a00ff98ac7e65a7cecf3aa0609df2cc6f9bd0612192cee10cb376b1795ae92fb60d680858d2923e1fe3320b4bc720d5563685ed6059da35cf3f390cdc71aff6a14994346ca3f02efa13f85dadf6df2d3aff3704f37f0a09af46016483847c0d182179054ec5c513e11bdd1b72cd9522b1ebc80a13dc8bbeccbe4043d1655e5ad8d2dbd0f1e01ba7e941261592417cb8a999487f0d20cb0ebce3989b2e735702b138a0683d22e945a16b878451c9250c06bd2e9c0cd20e24a757c9d09a86fa0d7baf1745ffd6225f8dc7d6a6a6707ea13e02666c53050c5c91eb927ead881ae640d280139518db065682b2e52569e968d1972bcffceaad2159c0abaed15ad5cafa64bbbb3a4e1584acfe6c09cdf8a41d6bc041977a7074854812a26a991861a2bee195a1304a0f4081e77044f91b76a9948e3903484b56474bbde89188c974d0358aed8065430cbb77803b0eb632f7debe5feb97e6f8c9abc1ab6bcc8c06262e0ac1758ebf0ed5dd9884557d02e9c303d5466b70b32a33eae5ac4749fb66c3c429f2473ef61e5008a592b1eb58f99c210f9dd45ea0d96f387c8658dbe0bbc4175ded879afb35741f48201c3fc336074323c8898697a0724bffff203d7e8c8724ef2b975015e83905a69e62192230269178f9d811405014a24d4876fbd44a099aecb922eb8daeaa885f7e81d96d95ce43d7bd2407a1731c50fd10ecd4296b1a4c48c868437115d83b79308e5fde9adf3484549c7efdbde2a47963b51d32e9a8a3e5e186670d8160b1e26715a264469c3bb130a46b252801dfa9beb2122feaf22f9d5555995e631b059e22ef1936d7316132ca43bad1cfb5c69db0c3a222ff244132a500685eef2cab0d0501de33ec40ef06c9aea7df2813aeedca1efd887d94250a61c60abe93eed7f02582dab7e17ef9d14137306e7eb5e7eb4ffb75c27a451e17226c3969bc1d107abc240feeb6f42c617149ff5e1e5064ec29f6f61a291583a6867897bfad65432456e446370974c18fe0ec0f63c1e9d8d2db1d9bba5ba54cd804c1d74a0bef137a93e3eebd93880c3cac8db8a8a1e81ab2b8f12a309189705db84d31aae9d54deb45feb7110b2b17bef10ccd443c078565455dcd8893fd5a53c56ea4bab145191ffdce11ce008ef6e280dbc8b9797e0aaa9eef4baee03e74abd25a5583f5f4c222c82a6614feba77214c58b18c8afa64ac607e33bcf927439ed7aaf79a0b95c40bfbf9d8db6e611d039f8c0c9598631337d4e654c05e37a26f577cfba0c6bbbf3cac8b8d6ee99e09acc4e34ae219a4b3bbcd43e89bde401c101e8faa761ec397cc849e62274d8cef49ca466533dda1f46e7fbd94404a00322caecbe5d48a681e3baa5c76c2fab4a485bcfb30a655811c3c7eed89f23092109bd8601d529f4879b5e309502578989bc7a1b062b2deeaf77407d31ec07f13f25c7b75adc808b0e2a1f31b8eb5f03ffa6de047ad1f8f80ad026346bcf801cc767abec9920faa29c8eb300ba5a33d96b7c73246973ad458e923cd616b4bd9abc7ba39b2069e75aaf7123c9c79201f89e3bdeabadb66fcc6e1b5457c3f7b93a02a857f327efe397696f7a69ab945206a9fa4ef6ab384306d0d32530f9da5ee64e3cc08e5b984842672ad075e56e33f5901fcd84ceb0947e51a2ec8f827f49b4309a7db15c76cfb0f1106ab4e7d7de524ce2ae450408dcb6a1a9e55fb2c8fc33d8b90e976df43eadd9ae65439badd4cb525155a2c0e1ad55389cf687f96a970f1e3c56a3c7b466ac013b464eb11abeddc134c4e9d4e0b10f0439a14a9be5f5ffb9a70894d7aa595262c1bac7aa849066dc7be57aa09b0a32f79c822df2e0b977772333f7fb9c26e3ef49fde2a997e549e6f078673474269ddc49c8f169c52d4dbc94154db7becdec71d942d3e55c567d497f8901375eb49058d33c07c16a67cb3a47a1aee57db5ee8cbb15e21b4ee578600fe58799e2a23cfd8b17c45959491de9db947f7acf705b41689cb3658face938f05575de5944e26fbb97e8a4243dbf22b3112330e119c3dd1ddcc9b6c35dd419d073568f5ca3de1a9706716cd3814fa0ab88b6bd16fa1adea2b7f29ee6dddac89186544c5ad9e12572d93dfb54d5473673bd042d12fd7e3e34805685e4256488f2effe4246a36d3df611871be2e1b9dc98dbfeca8e8598547dd58db71232781af6d94b2c26d8df44084c9090c98090c6fb92e45fc2915cf4442b65fbcf21ea910705caaa3143f71e3d355825ad5e91becfe68b8eb8387d3ddbaed51b54b91be06b16f63f8d27dcbe6ddde38f9727a10b7336ed3aa3992cd68fdce7357178dee71b6e30fbc179aacf2ca4a981993eeedf16d487bf062f25623ca0a170790ccef8d77c11d384f93408bda3337e95065dabe0a698e70aee71d8b40c0453e177081fdf494d362ce0c0858e752b6a897922ae308a2a60a28f977952dd608cf21db9e8b4eb047c0172a2768f16c45946681ad0473f6c20d29805905e34280d6bf32cab1d9e4c2a2e2eca7123fb922d23c05833207e69822d81b040aaea832e3333d6e68e0f45dc71d201a58c1aec75fb6e6d7399fb33ae034fba714c9ba7380ec2a713d27e8b9fa2b30c1a50aa1c0a021e6f02ffafcdc9d4f1ce452268232cefe30157845c68a13dd3fcd066436e9bb5839f1b50050a06c1edb3fe8bbd54282b31f0a690d648523037841ae0a3e5da136e5eea78938cff6d72b3608b6e34b45cdf24c9cce1e3fb914eaf179bb58c841c47535a817d7a235ea99c2fbbf5da87a1ff5b04d368241851bc951002b41865d82425ca9893e9aeaac90dd232a0f5dfc00cb2b4449a3ea785cd696f71a7d170a8a776a2333413fdda0a7a4f02646da4e5b673273adbcc864f466e58b7d3f7c2fdbea21a11ef2bfdf4a624617b16d9898e7f8fe7d6ec3c700bcfd58fd2d1cb48e7efdae82677d2f3f6b98448d6ec1138c0ccfeeaaca041b67ebe16212b6c0c3a0b15a6591669a287828b01ce833872c5b4a73cbcefdfde9f33d9918fc1b108cec88db1ccbf566a314dec480a1f88c783fe0da353232fb6cbfa8178e3ce19881794f9fa081cd965911f7900ed662ea6a31b41b9556bc7ebd587e48ba364ea9eb9dcbcc4b539265fa29d27baf5540dfdf7cfca267c5827ca84263f30e1f40b52eadc9b553cfdb1bf0b3fd59f3caf4bfbb59a85f9c5f79211a848ff291b5259907b8b2a68bfd5a3982800e49523a3ef4cda45a12fd4bef6f22e190338742c01a7c26ee3e8efb427bf2784ff4b5e3d4acc5b21c2a956d7e95229d39569641af673f1c22486decf6f9babfa7fe07e95c8817a3bd27b60a9d3fc260f728a9edb37d4f5215674a1b97dc4ff8807ca053765c050b61d7fde766c991549cb9c3c8c62f8bc8ff89187701b4dd0d64e78483afc8e2538f1ace4a21900ed3cad28048320a917697d3efd29f7333d5b8f11e115ecee417b7609840f41610a96ade56e19d32acb92d6b3341b109f965b2c28c599684fb6048f475c3c741430804b458abbd557db90ee0d3ba7965ba46efc061009781551c25d6c567de60a4463559ee471551eab0d6f286bb3f3faa63eb85c92e74c5d304e1dba391d4bd54f9033c2cdeea3ed608c7934eaa61d2b49a17cdf4b8be8aa5e1c2ebf0c745ae9e3041b40eacfe7b31ce6fea15358e16b61b3e810e98f7b8cc61e6d8e9ece599c2799f8cf4726ee3f5c16cc5fa8cbf96b7af934604549ba1a3ca8ca47189df0d1490b7f57886e5dcc7d669ca21d5dc40d026d5c7eb54be150a809ee0898516e3e639aa716340c256e57e9cdc3aa67bd8a2bbd8fb7734f0e9d75df920dcbb7568def3eb35a6a0e603f51f038202471d44c8c2d20e36489924a6ac2a14ef2db1007d790b5b64336717437e0655f59f22bba103d5dcc97450b1081a7e525ccace826894ac54d627236796f3ab319bf7b28c641304a8956c8dcdcf7d6e7a178fd17337af205c2b4a91c0a456c1ce826b01681f8084f0a25e8f6429f8fa0efa9b94c96166ba72c4e99d4e809b726dbc31300083eba1b2b11f9b84bc3465fd0522b604bc17c8425bdcedffdbd04b6b761101b1dcfb5e6f669c0f1146e119aad58f32948767fe6cb8e32efd61728888a124a1aa9d256b0e2614710375cba61168b63861bf0195c6bec26eaac4aad80056eb657926a0850f4097076977b6934586d4e965f679db99621a22a98b22bbf881261abd977d586b2d6d83b7da979d94b079c2a33a80fa731344b9e4946812c78408d75d9011835e714dbbc96833ea15038c134baf18793235e50629e448aa7e84f6a0295f2cf83e098f7ab714fe7023fe3d9b0c09d0866a87a738d7ce265d349c017783733ee17fd9a181ad6afbfb9ef618d365d5256012a1da28c3f6b6457a43e226cec552bce89329b520a09495093563cb9ba9bfc85525f8ee17ec96234709eb30da76c25578b4e4c9f1f60ba3fa1c04f2973a6cb0d418a4aa9bd6bed14b16671cff49d201499f771fedbb664463c0cd4ee4b714d5984ec54c637e09d12556c90d2f135f816e86f92e6135f86c2e3a61d2d662f39dc23cff4fb307bc673fef3145c4d178bf31ea64eb412812792f0d633ebd68e550f8a41217c5af9f15ed03fd98a54f314ffcbb9553be70fbc8b6286df8e7e979672e5bf4c878feb4b9d744ed4337b01d6a0f290ecaa4b527bf5e0d70acd79f3f4c2f05b22efbfee5ed21d3ba5e874e9e4422ae86dc8ca3d0f55db3f8f4ee28808d5858d9ba6fb3f165094c0535437ac98c32758590e94911df3eb4495497559341d7740d0ab742d1388e366b650053793017124080dd07d2eb5c964b421cbf5791b8a4f10199b3355235259e189dab0beefb5c5c57ecf0bb6f5e3efe481d1c53a1d604b5c3f7f3685a560f808e45ad0c10dca811039ac309bbcbd38867e51eb41ecea48b8bed2fafb0d8a5d65174de7242e3ce9834c90603754e04b023297a90513e770893154494003cf41dab56bd9fa696475ca7835f818cb10a1d470cdeb89b71af07d23f99a6022a430bb116ea8e2c5f7e89f2b5a40754c945f315678874b420973017712bf4658e15ac052a4cb9dcd41c80597e33ed1f387a701dd478ee9ebea3cedfd408e618e5eddfffdeb8517c8434a6964a02b06189b2a0bec362b1c188735304fde7de499712263ebd6724fb41f8875e4454c4b3443d7ace1a32676da2e9a6143fac3173a14f48b5fd1182c9f831b3c594019b97f23a51aa2289ccba6c60379620280e1107ba2297a1254117e2097aa3cb7a6352848d5e2e1c64ef20f9bfa0f50187643a7389e1439c2c735f16ec10e97f4676e74bb9174408e7acb0cd3a42bdd37dd894d3715527171101bba702355ead8f66184765056c4655dd46715020ba9e7f09c8109dc2d51edb039e67ec6fc381cac296f92d8f383a63429e8129c0f8f907dc28cb81b71452528b864ecfcb20bac43914a57c1a286676b8b43bb6b562cdc097fe246a08a7ad0bd8918c200fd5d832159a4b2ed2b070f318cdffd6e2567f86e9892868005a4498539214839ce3a2fb1cab1206dbe1d676a4072e0b1e4822a7fe26121560feccf359862d7d13d25c58d1b0b265c54e61f1888f26087619da3bc8a4d1d5b1e78981a3e9060f43b29e7670d4dfe25460dae4a464cb9d8019bfc7a8e09e1edc70cb01286cf8159fd281584e2918e8eeeb834914a86ff29f8b6e08a070951b21f84973a5d5b85a8c1d4373a4249236085de32f8c435060981556bf018e3225d05f3f9e0bb70cde6c0c412e74b2d4eca066c3de69cc2a758a63f367be943fa8808728e25b203cb66f64d4eac7b3f2835dd90133c4b48b39b47c2c2051e3e5638a65c3f6ed4f1cacf4d751ffeea0d96d86a370e763092e21b55a89bcaad9dcaaffca953d20d46e7ef365c2cf6c1310d2ee73e266c284c91233eb1d0d39dd3501ffdfe470f70344d289dab8eb2a38833653ff53d47a5fdccd34fb4a8a46d23edf4b6b7852318b23e35910fd8dd1dc1a379d9bc049c3917bc712238d6f204749c73ebc93e9985f97752cbb8b72dc29d96d2661e64e630972344451df7ae9158630f44c159326b8590d7f0d7df12a2b1098d6f87cb01d84422baa43622399cc22c87cc6f4636928653f81d2e1ac085738a0e5df7ad34471a77e69db08cbd03f7eb29b1a4e3989bbb9ed18b61dba5596dda0909573c6f34de9761c1c4d6ac9b755c910bfe8cc63923af0f2dac6b2c48050522adc4a5b97d0519d1e1bf0a5381a1316df983857cf7e5e366ef81c028062bc20dac3a2f96cbf3feeffca202be057d9fd4fde3038cd27e767c2c1178bcb3704127b5841272ec873c0a9b08d72caebba23378bef12b59fa79f87384625d9f9bcc39eb85cfc3d477b01c575f2ece7a69fe6d4fc84f91fe51f1da65934495515994cab26e1f84580bbae0a8ddd5e39936c4c0451baee9cef11fd46a8a9f835cd8906c80c1768de3b67f0acca4810ef1ed342685c20560b05824f10df89cc6202d37c793f55d0c23e5355383c052b86b79fe1ff265ce49be117d68defab0b83072a93637cdcdb23362dd376e1a624ffa62b10fd2e16aad67976315a61dce17fd3262708f3f09b9af1091a330447558aac391fd8e165a39825fe2f5e3e9f8a313c8a168a1acfeb75f913e1540021f3da05ada904ce284d7ad83c6bcbbcce551d5a6746c8ad6c2551e8017f4cc315080bfff3df8f3ce2959023e4f7710e8fb2126748e512a99d4cd784b3b9f3f386cde0b2c95522458e4e3178b54761c8f0e1fae330a8fd60ca224cfd543e3fccb1e029139c492be01369fb4251234ae1ce7b150712138a954e11cbbb71271ecf94391e0a53dcfe52acd218fcc0f975f1a427c526b5d71eb1a4f00a51474409af7420fea4113c507ac70d927223902bb9c9949f201b6edf704d745624aabce609f35f86fb943610ed63aa35414c78f9d8e5c1a8bd20458daacd87057989e5d74fa0dd5b96baa8ee2e6107534116267696b22703b5d9d85bc9cb23ca7f32a5b9b5e0b6caf1612f35d617f5d9f09dac7062de1135fd410e3ac930d506428fec8f6313822dae63141d5a15bdb3a3bf9be71d884f56c4298c65de82c034d65332af226df54919f734a0ea6b6bd86d1ae902ee9fbd89863975f3bedb036377d247735ffa1207a4ed6c77a607814f0c78c9eb0dd0bbbc6635b6cb82116ea0f77fadc94c10e52c6c5a7cef23ab1a3f896dac6c7276301beb07b1adc59a3f035d7240595b1b3a432e5f8a5f8a8ff7c8633dfe4e896b292ee68dfcada0b466c018a058006ba57f1a6efeb3a6d1b4763779f39d15ca1a972b83cf460511e35998dfacc70a0f73e6b11dc26c90493c59ca6b79d30bcbb586c5dfe8b226710135082f9cb059d462175ad90f5e5aa8547b1ada32261e68b34e2b512704a05dbc65e7674d26c6091b764a9ccd10922539cc8fea972b917b4a1960ab30b77afb0ba17f3cc03c6413a61353b046934c043f0980c2b113e6de4dc988360f0541ee2f9cadc6397e2fcf0eb537e9a898fbf2aaab787d9971cbed31e07f3fcde614b2ee065dffc0c6df08d23a020920193bdd821a6240e684e589568b7a6ce4be510d49f72249f13c53df0bcf5bc15e564101b04d7b8c2fb284918148ed0c74b28fba943a2c6d601502b3545ad45bdbd726d946519107012118dbd7969f23d00c04d32c55cfb39ca69cca635fe838de67f3a7e2a98838fb7ca332b8abed22c9ac9dfc3ada9fb01da2734224003862d6489905c04b26fe86975474c07d81ef11920679858895eae5ea0bf0d25c2fd9e1c13ad7cf7055f2ceebd4a24b7e76268becd7a240b16dc5bbe1e984a47c261b2ce6b0485ab1a75ea8136fe5659f05c4774aad168b7c5508338ac6c8512be08049d12ceb9a74cad989d15d2f657f5664ee24afa5919a22aa829e1acff3ab55d38f08f8fbd0537564dc3ada9aeded0ceb8a0406ca69be3e3ae3a2c0aaff5c8257a1b089d763057b8481a986d7f0d66e383b5c90174e408fd9384b3a8edf40386213d9b0198e23a00246851c3a58e9252640545602fc2ac8cb602c8cc17afd0ee595c0e5904345858642d2285e30911bfa0ae5106192c92a14a4a47bd42236075170cced2975ec51e2aa95644e096f7e3258f5565d02d4818f17d2ab6298b8c3acd5026caee837c4a3b0058ab263274da59f1c897acc1e96a50f40daefec47302f8978204587262fba51621ae4d779fb6f2b3bf518ed1846679d8755c324518cf7885281e2cf576dc9ec046af9b3e5341aeba4d807d80fc9d56b064c14119a548b9f71ec22e85bd624d1d1f215d658a2c7ee0dbec063ec2f5ab4509867f7c5a291cfd80ecea210d7b7d6845cf683a7436e28741f808ba0f16548efc2709fbb5ca36b819f2b019e94a15c82f7b70df161b4911a3c936a8e94e66d4b3d09267cbed094622db7f7f9a46717c45811740a6446609de9d4af38af355d4a7a1fd56380fd0c6171077907c6212cd16f7d8c571a340eaa8c8622465c06cb04f0cc5e5ceeea67c2807559ea17a61d7c3a4a17f262ae31d7af17a0c8748f73da5bfa26501bdc01a9c9afaef97bee6d51649466c6a7e7fd51b6b81361ff4e3606033bb746ac5570d52db33808672591dd0f02d381c01ee1bacd753f7fb80006778a6970f506e757049a285b71d9256c3e25745c088fd18b4fcb15e6adac8f596d025f969781c7ca5e211135023db91f8af18c39b9b0ebba979f05632eb966c5f37a6389c297eaef85ac04f26165363ffcdc1996ef4ec6767b26dc01c08b8a98b0f900f792b1cc5b32f44573a2a2e9817f710c42170d2275dbc71df23a51d3727309059e9560b0bcd1740e57cb8e7543109af2677b8ebfcca1114bcdfa4ff67b1ef79845bef4077195e62da2712bdeb1af689b0be35f45d593c16f92f2f70888841b713fd78b59be62d3f4825014f52911229e44bfef5a7acab6c2b1f670ab4cf48060ef2953028fed216bfe81250ebdab373e1943d909439449112542463997a7e5cfc8a023287d3e9b1a02af3c81cba6111b1593715b5f40ada4d9f64445718def5b960f5338b16b77d58a82770f94c5a28eaba95ca0e5fe9c474d1cc65f3ff9755c37ce0ebf929b704c729ee983b959f94e1cc1e8d9b3b2bb6b9fa8c7f2ed6aadd3af30c81865ac882fb90fa463a6548e97f2e1a2ec52ba634d200d4206e86ba230ed9bbfb24146a42b178b76ed9cf6cd0f8ed6b088ea7eb37dc1f9cd03150aaa54d5d17389e0597b0c363de10716615e7f33c066b694bb0c7d981c76d74d8ce9968cbcb81bc7bd6e95588bcacd8b2fdd5ee49e8f1502e8d6d6415de998db3862beceabdfa69712ff306f981f4f9c8e1f0522344afd255b4caf6b87564f1af7a44e8fe1bfcd70495aaaea9b39e6ab0aa179ffff5c03646a168684dba5a4a8038c591d5f0c5441a35c7ce78086476e0d4eddf9aeceb945e78319d8402ee3b9ebcefcecab5acd0fab650e484a620caf501d65a8eb4156f9e74ac0326d8037bb544c8053e155e516a0047c5051e4a27475368c60181968b31c7f4a2e3b98b90acad733ce36214cbebb5c5077c6d4216770320e77de4f4d746d0f8ad37b8d628568e1ac490244cd8c54ed64ccf1410ee35cfb875f20ab9551d3258bfe7ccd7d5c73b344be7847850673b45f2738ed7869547c6199effe97b2308fdcc89f112bb804cea380621d472998473fb26d41c0e39959b71d0ea53f0ffdb8116444b407c906d3cd9a108edc37b02315f0e9f81f4192c0f1fa7da8f8fdc2034cd3571ac3b367624c96df202e8d6dbda971a0ed64fc5c7669623489e9abdb68f4cf8df935f694bf05efd612be67cf669cee83ed1af1e07d7b9f2527b74b3b067b5e84d9d3a0cc81068d15bd779ba83a94a11a085d2479f4df85b9e1f29157b0c41936d73cdb9da28d9e446328e4c3a48da01bbb671fe7eb12f38a009991cdbdc6aef281ea91751578fcdbc5633953a2cbb06f7d6bdba62db87c106346176b1fbcf8e74eda0b173e251492b90ae615a0eaf3e83d248cbd0633f37213674fd6ac2d2f790b25b3eee447219b006d1154aecc79652d44b15afacb928d66b582469a0951166fc8acbd5605599ba1529ec9262ecc2792f7b753c8dbf583d99006a38ff0c32dd0c4363d535d5d7050789595832a58f5a6845a2a488a2036040807552a88c058641281d0b6a475604aad722b84c8a623ab62fb1404e32dfcb6bca6f725541bd350db825b7428a749da9104352b97183cb98be30e309857478e2b87a4e7d0c3435e034e4915028638218a5852a714069c0ca78776bb771c507c1572994fed44d9aed03138c182b1598aee2cbd1314f98ff72a5faf9e0ca3c2014c6256b3d7a59a01950a3ea4ba0b690092d78fa12803874678540084cd10a5d6876806ec03c2a7427768307c2ba8bcd26ab38518c2bf4428f49707d7a22191db0022bca514cce0f8127f1e64bd6533edb2e1d31374313c8d5825862ca81e183e808d4b0cc6a1b7306cf1d30faba37c3fd1fa1fb6a3a6c54e4cad17510c427332fa6ea340f67bd5b2afc144984212a2b964316a69446f7d7928a3aa579f1857c6107ee56019758bbb54fc4ac3a5cd1babac93be9d6ebdea96a73896f4bd14f1d43283a2878e95eb0c03448fc238e3886b9fdd4bc0b4aed3223c72d33c44a5ba2f9cbf4fcd54ee055c7e3475bdb2f1ac40bf6cdcf93148a6cc8bbed6abb47e69363cb22639d71927e887c60b65fffa79d45723923eb4892726556c13c0b42738e2a0632dbaff7ed1a256ece2832c282727b11b7488985fecc7dcc6c1dd234dde472c257be1bc5a795822ffd2df0263328152b87544533f19e40ee73a3f2e86903cc7ff71a0405b04ad3e5e15272726b56e85eb6df942d3fe3627514c785e86f61e35c6b4e5905193dcc3bf24094af76bf9ca5c743eb1874968daec655388edcd53bb2ecc0ec05b91aea4b6c849cc2348014a7dcbb5b251a48d81b3c059aae78ce2535aba9309b4fae1452217f2c64aec60705baaec82df19f5c8d5f046df5857b6a3f8dea160ceb957cc71bb8d7347f8d678521f38b064ef6119f41f762bcb4893856bc558326cf3cf78e80992ae041bcafc2ceb04427186069812a5f855dba80581fccdbea9d9621f493f1827dbb52f20e7bbd8560f43ebedd08279c5063462d86590086709a6939718dfe3bd5d76e8118bcf4a225f849696ac95a2de3cd127aca668777a52b1dbc084376ce8be58f34154bc6484288c4800225acaddb305abc12c6fddf120cabe92c52884bfecf08093b1850d0dc5011ce3b8d22520269e1a91dc548603aefb0db179007c7d1681e119cef24d5009e42644eb367362c903815ede9d0c7d73467225499b97b8a1f86f69d64164a34869e6876861cabd1430ff4908561fd4ccc6084cf475f83bfb82983d86dc8b95b3d9b0c631ddd027644a732dd43e28ef464f265c07a4831fddbfc50a65d9dd0a7dd64d62ed0f402226537075224c8e8b0f5165d8d460022be78f308e3f310253e53397648288d0d37defd7efe883e73d0476a644d111a852e381ee9195edb61877327437c52cf6918deb8ef8d99669a8087bd36058e35c1a8fcceb33fc787fa15600669c92695c0e8b8bcd14d5db716d9187818ec4d6f899540aa4ce0c167359f4ea9c0ba529ea2fc9f19e9ac10d55c4555073ebd8d1a90d2b68279ad855688ae811a1e2c6e9f71460d51c9b9db3d4654ee47efaa1a4070dbb6020ddc1ab1cda5124e2a89bf8ec04f7789454eb28a7b6202be8ba2de3c0c34d67e60d8d89cf8fcb4af3886807fe6351511a5252a5e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
