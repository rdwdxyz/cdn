<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b59aeb36b2988530ba88908b17c5a498717e7617e9ca1c5c966b986708d87f770e5e4d0e68d678d519b47df9c8cd8078462877fee7261817fd7317f9bbe8667ebe75c44303cf8b671f32fa23db8f78baecbe39f46f6f59028a186203ef46a9b84ffb40c30476b5f4c04619906ebbe9579e3e83e27373fbfcf7dc6788f4221c9062b87c0592f8a6231fef1649770ccaffb4a1525df7ad6d2be5e3c4785f42c6a6d2e81269330df351328d7678084a6d48bfce46af87e7b39e6618bd3476bc98c5e679fd349c30e41897843f1816257a80790d71b81786dee1c8ed9fe402ef95cc6a08775002ab5ed4e5472c9a3ab0a51d452f64b4f3e3482c5ad41d02b715822b3620b843e5c8e1a370d26f5a4771ee2f9d3dbdb1c61fa3822ff5c912ecfcc46a3ec9397a618b46a9cc15fd88af0e912c231c38afa43f90942723ebc4a36e251e37da9cc7af88102d1789a818f44dc1e5303d10f0b67659f76157f71b90304a6092fc8267e22c2b198b4c779636cddde25089b5cdc6f61f106d6fe97981c91dd6c80205667fa9a7616e223f0ca93c9a8ffb3f82b6a54dd7c2356246682013ce444faae0ee618e88c72e58539b743c477381008126e12c7868bb979347aac02aabe53554730e537d4241d80a407345ec05ee6764091dbba5e567ea169eff69d80f57f693e4ebd18932a842f02d4c1eb120a7d195d9929fa8b7b1ddaa78b71c50f875ff499f2be4da148df7ce1e271652840f454cbdfff4e71e405a02edc835dfe683553c7189f4a042cdd4624cb738c443111a4848b9c084f6a72f4017cee15817d0f6080bdd9a025eeeccfbdd4231c355b2c1fc9420b0e277ef2913bafd35f492a0aec8cd6ea436807908cfdb791730d407911455d6af5f661fda66972c474c69677f2e01f2cabdcb9cdc4e0826658b2def994715ba59747448aec77ef324cc76da1b4e52a9ef6690d425d457fbf1941533d184174432fc73cd6fffcff2a24cd11d773fdcfe6280d3846ee931be2ef23c8e6214d773e8712fd2827327042cce720f2886a7fe81e7eb644af7334639bb6f7b25b304039297d33f81fa5e78fae4bd212bed8495ed88bde6162521a477bcca2f4b7101127f475d3e742e23c851280de635ce07c69ebb16e2e072d5a42984877e13a8ec71f22b789a05910a57b2841e0c1bd608c5f37c5318a6084a195172b44555617ad658e44b5bf1d065149a8e735230dda77d07c5812fe149effe0b9140572bd5992ec46da35343bdb1df21fae32dfb5d93ea2a975b4b408a77e5ecfbb009cf9b3f50cef36591cd113f9af4a674ca2a03767e9e01e0a032f8093d8f39e71c3727d90da5db3ec921b7e5e8e199c7e21e4c1375b32eb21b601c5d5dacad67ceb807228836c26cfc8efcd955ff76b4d69723aa659951820c03078df908b9711eb56c790026f23517fac68803079d1806d90c17dfca672f1fcebe8797a9760dc288f48b03145539906e8b919dbe449412fd9ea32f54c9dc1e3a42906805c865fbe07e09530f9f5120e2bd7d94b73b0f1fd3c405da413e26f85f30eddf4916b9ead98b992b518dcd766125dc9f24cab86fd29c8daf75b6de67adc76dd4c4e81a6d6b0664511f727e5d1848a0272f65960007904fdf0a02a4b289314429d6c465446fe686cc3e9c0e69de26465eb3a41244f37bc274634b9e6b035f4d592e67e65c7f9087252abd5869b850e9974180516d8885a94a097a901d756e7b02df13c7d5fa871a44a054dc16cc2abd1909a5305002db40f257076cad18392f7da32baa82fae7c89d3ee78737ac5ff30648bbfb5829ca821ea1bfd5efebbb2c3f17465e5dbced630c05d2b4e2f73a87d6a43e72735ee9527f240855b4355c3aa6049137d459bd83e84a0c6b22849e26075e6b9463169a3c2bed15d7b4c5d9892d22ccb1ebb863cd720ade195fabc546186bc269596a016f106624a711e4f588bae1273668d109083d096204856333d96457049adbc81044d0604db2166894ef9eb819187645df725ff403b23c2274c87505ac9ed25c7603dd0aab788cd5bf17561ffe3b1a8574bb287ff09a5c33fd72c3fe8c5b03df9461a8f2367685424aa27b159b63bd1004006d2a73f6bad984f25f37aa6662465f397dbc4efaddc5a25ca0cb6f8db941408f9a02cba50bf880a41a3d737ce53699f7f92318d058542254fd463a3477d884dca9063b962b8a33342ac602a89d8de09ab828264489741f76c8871e6d5cf7fafd055af193d981b3fc1f63d1acac8dcd63ca91ecb58e6568829e5135125a164ab4d448b1f341654dd796cf533cd41632a28515fbbf33cba60882a1308bea0fec65bce25de9ba143fdf51f71501543681ea9ea4072e22cb427195b1adec3a146119e393e121a32263cc2d4ffb0574c3c9766b40060e4d14eea2294a2beeb2bbfcfdd9e6a651c89137abf1df7133b1dc05547cf8c987ae47e88031ea961d4684797f7da53d9f6c0e5ba540c01ca7bf6b95c77a6a3051781aa73246c8f7bb4207353a9072b466a490f5e526ecaa262c6446b874432a69a5961598ecdf47bb68fde6e4af260ba68d5c540e030d7d4924d8610e030ea9e9be7367bbb4f4e616dba81170fa55b25539d16ca3043b7787f596f341afeea4165c5985ee407c616beb0dc22837d7512041610c140beb1fdfe3a31fb0a6a428101e451d08ef3f25c04b092dd7ed1c0ee0da03b33ecf9b3799a0d72cdd9abbccfa04a310d211e361af9fcbe101f772f7d13178517c25e3f79950ad0b1fa8c91d1eb5ec716f0cad681ef919fa45c325310aa0f1ca08398dfb313e1587d5ab960528510fb70f1f4f3228ce0ef3463d52a554f1a018e647150ef1d2f8f158812fd59dc31087dd970c1000d0632a42780b5585c9270068f9cc79af51093acac4beb8e2cc70a69f5e834d78049f0c28090cf86a95320f2a48f87b66ac437b8373d4b76fe55d2a1c4a29c2634ebe8ce48272a36812c6f24fda8d9aa3a7e140ed8578319c7d1b0b5a1cf422e71ded71d36f89187b5b740dc87bfce29c0d0f969d5e45e8c0b96eb023aacba7d6bd3ec7e7229f71af51763e4c2e2966d79ac885a934b3b31e358430d4675e08e9ecb53e54970a89f61dfdacc9db7237c2d29c0351ba00579b441c8f2af08275e387bd2f656de30eae9594acf86e783de91ca1caddb4fdbfdabef3010e13f948df500018fa7382d81ac02abcbe2dc2434039a936342b65223a62e0baccc6ffc27c171befcc2fffef798fe2650a2a9fcd0847e765f5004e2d473fa4a2b5b2474673ceb0b9e139c2f39b57b88b4ed2d4fa415e30246c08384111245f2bab6eaa1c2a768f9f3a3fce8482ec1a2e969761ced69296763dfd65e74b08e183bb94808471bcd0091878913d32e532ed68b56a8b347e119116de212388b8462fe6cc0c68b8d37a1edd3ec047691d856f6aa0e92983ff029020520fa185f156ade103920822031a5dcddf824b94ea0792ef1d823af4d7e9ddec7f433c1575e7e78fcc4e8838e86257431e0244556372163efe82937429ffbd5ec2d24b6127a092b9d05c862643d49efaf0a307713daaf2ca49af54ae5de280ec43d464912dd0ca6b3f9e88323ffaa1bfb11328efbf3999e5926d609fd27fa1fc5edb59f9384d605d12d9db90eebf62e5609e0399f9afe2756212be3ae7aa08519d4e778f608cd5ebae960b1bd3bd9a36d605a1541d345ac4ae2e27bb43e5d64fe8255b78aa245ce2dad2eddca16dbaea54055c9369936bc191dfcd1cb0a7a381f36e2cd95e5ac2ff83a9f2b9a8ecf0c1d43312986d52c3ecb58c48ffe3dcc1d397da41d9503d927bd1be8e112894a71f7675dd7d7266198adc77644dbc037d0bf411b69e518a7f5d7961ce012e799826825a5b702b310f369b532319d0ecdd4dd36a2f1072f728b72ce14b9c214cf80d959c4c88ce071265f4349d0299ef13c97c0f52dbd07114cb895cad71582a922d23a1eb8e6c47ff009f94bf6aec885252d5ab5e92027f76f62f5a50ee6874b159b7c3ceacfce7398669c1281ed38259dbf34393d1206c8a280f7673154e109af62e25522e985eb680bd0185540697cd1a37f2cb652e09c8871c02885f434e9f995157a262449e5180cd794e660f835b9c160bd39ed1e4fac2723b95bc6fd0c7be5944f8d2c393850621de0fee8f0cb9c859a58280244642b30e1cb9c0993cbe04e4829597fa3d93464143a4bfa6a1e61d3908d7f83518d6e1a241251c1beb0108d4affe7f6640707fc80b58156f7cb006a6a91d3fb6c033a34beaa3b0034e7b7f4992ec3ec967c9528daaafa82f6965befed394454b162179f42a4c3d17d646e089929eef6d0667a7f94166904e2e251069232b9348c026a2ec216de2a1ee6829219f3750a2828076b05d2df2062454197cc2cdf93630b72a30b111e52fc8612c3b2f6ae1d1ff2f1524590d12d96bb1444d667b66568d078a15044dee8bb5319787c91eddba0654f1e03283237c92874baeb5c86f5d7e08233025eb98384bc6935ca2b4906f4b56e2b82f511010cb5da03850b654b441a0847f9257138c3413f6207a3f1f2720d4e48d61c278aa948576103f4d57c53b7d2545a42ae5b335c07675a7d1cfca314b201602df6396d7358753397cf942c9dabe759685b62d0e82274bb3dc9325b09041a152616387c57474266161e44cc007a77880285d236bffd1ba00f3a840ceedae8797b2dd1601e2b0b13e149b66213405a53c52d715034763502322571664159bdd428896c4e1847fe64f4b0d6d91587277dcc121d35bfe168cb0404f5379d41dc9d7e6148cc5aeb750d8bbdf08df0f472f8b39e996bb203314d2cb948241a37c94e101a36be418435b3736c14924267196e5cf145c0eada3aed2dba6bf03680b241fd3e830916b1cdcd9b984bc47e3356aa11c4b761de4c20c92bd8d72c9644d42449d5e8bcc0d35f25f0cbbb16cdbf2e13b6c174755f7181049b369b224d2940cefab6298b9e918d1636f65b3880fdc484efa4e43b375d9ee62b0b6286996f602bca7f3ffd3631c3adedc84b9dc2bc8f2fd7f090972ab3a23773148f79474c83c981efd7980828867b5f9e8c19ca0e4312095310c1464903544c011e12a5725ed69b9c18df8a2690f5533fec7d836c0e3a102fdc59517bc1fe2c49a9b2bdc63edfb90fed45dcc6124b69e67e64a3d1e8ee414f7c5f1aa596df5155eb2d9a10d721956eb3cf5c4e4880e43c4a362ab3d62b4554abbbe9431e642e0c4ae89a8c02131b7dcbcdd460caac7ec3f92d6439f6dc922284e6bc85c23883903eda7936d8ec6eb1953c6ec3a016b6d34560ef7ff7f44f08ebe27c776cc54e5eec20fe2ecb70b89a5fa09d009a11752b5006d40f0555f859ea30d4386f17d542f4453eed0f5c0633ef452ae0c1ca88667c5f66df27a1f071aafb95561b635f2d9c47625a2690d80cfe9863088cca66a9624ec66de75fbc43f0738fd0b6ecda027986e947e53078a79ab9874890ca4971bc7c2b41fb6e7771ffa43b6fbd29e500c93dbeebc2dbb0cb51865534fd8737e6e28f52de73c3ecb4894b70275727fa5d5be17cb7be3a2eb508f40bb114242f462c4547c90976992bd3ac0b5a678ca43fb890ae1925bfe2cf1a4d0a8a1dde4496abda11849a0bffccaaed44e886a2448413a8a0ef69ebccc2092096ba598b2d0ca76bae0c26fe8e9d58df16fef87c73f091e4eaa64853804af12190a7143166279d610f5ed20b5a9dd5b64d3aac0c5e216bcdaf1b98aa4c5a82e593f5b928ab77eb11a205d91b11d58a0b381317cf6811ef907753f68f889b3cc187438ec1c9d53c7a0195654372ad1053150944f8339cb42fc2ec06822037ae6f525e04c541aa6ee92518ef7d47051c3da32b110fdda2f40ebfbe8d175df54da1df85740f474523039852a6bf727f1b40fffa1af42ec292aff8362f0e26fd7e6f8783bb96215db4e75056ec933d0d9aeac86baf302562dfda5ecdd92217cef25a54ab796039e2c11b4209a67175c34c45a49223abb7d8f72509956b1042847380c41765b87fcef6e341d18030c66d17c027244604500d043d8ba810d30e106de134cecb3596df3a02fab8e36b573d99f1ac375d222e6cb89a0c15f2cd422d60bdc131f56b88538d0cc4849a2132ce397e12ca98435cadacec0d5743d73ff33dedb3bce61cdc39435e88dd4b7847a394a48631a572a15a44beb9d141104fee3e535227f95c70cb39731bf899bd571a9e057973cacf56fafb9aa768b7ce66e4ab982ede0837d298b0d5dde73a953f9b44c71aa1c9034edc41568f6f5f085141eecdb3ae309bda36b1effe1664c6958a2d27cc1831e8167881085c6199168d3266d7654e7a4e5bd2782655cacff506ffca90f69460308e053b3c7ee70cce9f87f4d41c279fbc5720628caa5a03d103bf1468e1c65d14575ba84485cd493ad47c5fbac35b5c478ae10726e4ed57fa7dc93d770ce0c89a08a2d3db1ed2bc36979df61b6f30f3f9f4e2ff2afc2ec3573bc33ae8f1ac31fe9f64907346c39b64f66719d397bd540b443299c1cfd2252b33568a7a8fe984ad140dd23c3930fac877750f248fa992608c44c87481dbf63fa9ca604cc14c08f3ae62df670561dd3a7d494f4e5d2965a8c9a021ab29cdf1dcc23b5c18728d41e9366c971cf062ea599c31ad7f6bd02026ce09dba8ede19c7182bc21acd5671b2a2d7af8c63cb67cd017b08565256e521339f307fb199ff69742c44e8846c34790e4693bed50ee7c99295289c7a53bb6caa33c0cc3374c8e527d956d68bff77a03f57af1763f8f56997b19565696749dd46bb2ca506bcc6186fd08ed62bf8689b145bc5bec5ebad2059a19fbda3d9214e87f64723fc5a1eab23f3c5ead8aaf04906cf86ad68db039482dca6145b114576695c149e3d7bef4ec27e613864d2e111616f2bd6e7190bfaac9a0445bb5feaef2bd044f22da35ac4a14dce6870d0e9802cf32b8170a1de9d3f8cac64bfaa2f3f1b8ada1b6bf66acf43b93477a95422a6d1b0276d36cb0bf24144d27b7641e3b0293c568b621f04bb3f4e0ebfb03a93fb3bcf9d61c27c4f5576f88fff93644805731d6bbaccb91e7e07f348b3c7bbbcfb562685c848ba6fe012849cbb72b6152a2ed322beef381e7f705085bcbe83c8c41629f3296bb452ca6143d06ff99bde94b3c52c7b4be0674cd7ac4bbce75465e2d4cf9fe9852f67367128896dd08246b337e71912d955b87dc69d3b6a67b997958f5d52e432b69283d1cfa6a2984ae656a33dc69537f1bbfe9ee01912f2c8757e012e502bab3c02973046ea2faf72180129517261c3d9b1a264cc59c05e0d4ce01c47af815680c97df18b8f1145a9f419c3b4b042e500d1896a808e5a49a1701e0f6e2bbd9ad2fa105efcb0840a97c14593fb979d01fe280601431ef4b0beaf2d58aad543c4de21dae8abf35cd0fdaadbfe2952cb0b905ca82f190a6edce415bd5ba90b778b8d0a8718c35490ddbbdb6a9eef15d1bdcd25d5223e8ea30ba7404d1d6899cb9879bd28a9fb821f3d81bc7abdd55da58bff6089cdbb47bb12a985c99185e7036b6b47060ecb59a92d0b742244d376a4bda4c0be6d439f5a1f10ec879ae62634440c6c4b17ed9a76e5222d5537d05397ea563f5e589d5260d7cae7ba29375598f14fb44b552e638bfb8c1a31ea0413d0ee085a2d1b5712142b1ae0b1586100e0f3170b261e2a3926ac367b0965382a095c0e348c6e50f31a7dd1452c763fb11f13a15203acc1e13fb444316b5ca9a22c39a8416221ac8ef05ed24598f7c2aa01762c8b07ac77516a0949daa6027ea3ca33b23a20e0b201f40829f5939b74adf79f061b21751d26ce9584f6399f95167df34a7b229048a447cdeee0fb04ad78ffcae323e520a59748f61e911163ae35795beca7a1b2883db01acaa3fb842757c7f219e04a9b92134c434d98e804157a225e3c3ef14eda86d9cd0246bc87827a5597c55057532f65a6cbc94923dfcf286ac28576c54f10a9c41d427e1825243126a0aefcea58c27a7a844f0be1fa3018f76cfec77886c063ec91f366c76f030ea766d1c4da3feb031410246191a7549ccbc5282301b4ac3cb6696aaaec08a6b2d77196359daf4260972489af2ae75a16d522c7b8beaa7db52b095f6475784e062f020d837fa3c1458c8a35da3e25db27a70d50afe40aced0d29be2964d8294e30c12569f106215de208cb5abb21f6cf9c1e5df685243b75b853e17798e64d14929d3c867a375ab77b820fbfb5ebab6bc09b7af7edd0787a022850ae60de51f40d5980897c466706b610e94e7f3e4deaa7ffae0ceec89f9f7bd1b937641d32191367b6df4c7fe89b1863cf52652c0c2e779b9ea01abc9d27e2a8380e1d71817482b7b694d81203854d36d7f081945329c88ea3e141e901b768aaa7e59aec538829493d9ee5000be5ea61a6ab86551a6b9e097b7e58bfb7725c3e147b0ad0e5af316418ce5579b8cc5cd546503d3615b3786d37a547e4366a8233e19edfcfc3f150acd54a75374b7161209a3808f0217ebd07b686333ea8cceadcf4d686470dbbb69583163a969792d7d15ee29ce516d66e0a7b804b49fcb375915552c501c6fdaec3348b863912bd6c6eb0c96052bb2f3b02d9963c37ee0c4c3fa4f15df6c09b2e58b1e601324d918c8356ff5a84445d59d5547779201a230f910a8f9efbda94ff606737db8537c3cb8967c9c6e73b86e5ccd48f71dff9ada886c020a4e34cb447068f6ebb8c7435e3f01da4d4673f2530d14e5b5bc695035245ba14afc8c49c7378753c3e140366f322b482bf7c54621c37291623f034e949b42e9096c4abcd7d70ad6dd36f45ddd1c3445decc038eb33511545727b061d7a0b72986152a21f05614ec2de19a64c68b8737e29da4cabcebf4055a088231d0097a25eb9f7417dfca5ee28e8971cd6024be45468829c5102a4c1d757c73bb0eb07ce3e033985a0b0e8e76540e92af759079ce059feb48e3c920ecca27996cf1a7f4183103c4251a6cfe0423abcf7777a60d89f802ac5defb4fa17fcd2ea227cef182ce0d6de7f5c301e4f8e703b2d5a190c53d6a7bafe9e5c6d97ff06440b6d5f365dcae434a284e90dea7c48fdeaeec50611dde70338706a2a00525a62b5894e100b1bdcdf580b9ed91da75a9fcf87db2d032e1f838c9fd4c0b4bad717ee8cdf142219a503fa8436b4f67ac50d9aca498cbe1e64660bdb23c07e4fb175747e5c34c788b29b992bd5a16ba4fd98b11c85a67cea039e8243444bdfa03769a0d9fb3d0ca9d37b099179b405bb77430477f82d05fc48c29ef584ba97861847e0cac16050a0883ba61779ebaccd8a43a344aefb2f03c65663841b437e6398d460edde83132821854869171a75290cdd522536910158561c4481aef4710c881509a5c545797c6f996e8af22e4a40eb3db7cfb9b35ba687bfe1f9f51a5510b8f0bd67c978ac4fac9e298c96460e7351862f4712a18b17ab7cdfa705214f02a544d1fa1162e8e4d23f91896d9cd0ee5925e07b9ed12cde9a34ae447b3929ec2ffed0bfb5fe897a1b4534549362ebecf7bc7167eb3b954effdef46e5ff4b90e42b80b0014adfe5ac8406db7593f4b611dd6c30c3329178387372cb90ea02a7677cc9c69148bcdddad4376d9ba9c2568499ab1f6633f01601c0144003d846cd5aef1555a9f971b844b39f5c7a5b8c261d9f7edf51076dd510df10cc8acc719f2f0743a7918eb8d9974f57ec7848007362dbd1275c17596cfd70591a3ef717c8dcc1cac6db2d8ac6f2e3761f756ac2e3fec56d6487edfa9d2869848448d97f7e0c4a395757c90568a25a51029b583e3e465f5bb31c2984fc65ee9993c044eb7605ad37ef3cf5ac691ba133f45ecef7df1b14b0a95d10753f74ed1c530c9cd976784487ae93e32f4abee7d6bcf15f59ba16b9890e0a0b96f7d610f7da633e2d14c4288911cb9f1ae44f0da784bfec04655f0b74e2644cfd5c4c73ea2d1c19c277b32dea6df47684d787bbb72b23e08b7f6d79112a5358bb6724febceb26324eb2edad66c143ef109a53a3e368d5418ae4e2a0b6c4d9faa5aa061754120a89558fbe3fea27dbd72bcb61b0a7897fffd909989ef4f61534c35f5aff4a9405b1728840846b0909bc66564fc8df41b2966bd719f9354bac296169629f4f1909a9fd31899d34d15d940616720264d23c32e3abe0fc58bbc33610e20ace8596796161ae144be310035a69d1692ca1d1463ce1195124ead994470c3b02597718df12aba639cdaa922a8cc987c6622f49c6f1b9c036cb283d37624ed3c21c41e4dd969953f51b3e158a5565bd1c5f9c811e4a26e196f022f2a02c5131074e0299ec0f9407af1d156ddbe572fb755a38f8ba1ccb9df7c261a7cc5acb35f79f8fb37aace43e5da6933c39e9060e0871115ce7079c14731ac66400d5e1e2cbfaf5b2e97af3b52fd73914b96bed19206a49afb1b6fd8c0d8387b9f0487b3c45704ed8ed42eb7a7d528fefb1385f341dfb845b36b9d6ee50e77d26e97821e1b17af882f7e10b0c36ccbae00bcd375a00117636ed71fb06be4ce3cde9f9dcd75aef0234aee1b3dbc11c91008476eeefe30623ee02f0f085429838b9086468eb7a737f5faa3befefdf016d960bdc3d7e201f0d2fa77a22c6284bda02669a791a03e6e8f947de2d0a794c434111e48875b2d68f5855d06e1dd7626cc80de7512bcff7432e5e5f16f80af817be21faa611e9fec369fc5a2d2410c45cd09228019f1eab202321775908bbf0705e1ff8e809bd7859eedee765740180ada3e21222a03a27276e07957fc162d5a7ab6b0cd7892a776e410282f942ce7029b481d6fece022936bd73bbd1131e1ec70fc9c3425147d1f0280748d516037071e25f3c0fc1b608c74888c3d9d5c3800085074320f1809f56c1f88512f31f40ae5d35cddbdce4f9192eb9f5c8a61ebaed6b87ebf6ed1b54ce61a38c3919b2aaf11d4b46557c3254bd802da5b3bddfae1956b751234ebd483de27cd6b55078d46c19fc6528fe37af5419f85c35a3343034448f31a2d40114228aae012d1d9fb4a5d16010ef8559447cff8cda32ed3bb8277fdf54fe362e4e3151352675aa6b9b208b12ffae5b4bcaa104b32cb1acb224fa8cea7029e6e21b7b34c4fc8a1a5c76267a5d97546c4186e11efa222557899adaf0dcb24b848f79601d6084a67fd14bec57589f38097ed6547500a69bfda23f1c2e7aab740126b82c2a29f3dc361cc0873b6e5139679be153fef35172ed863098c4cd0a094e763eb41497e5e068db48d093951c4be3d0bf3aaea061aac19e891cf36f3fa40d9859c4b02b5674ad8fc9f9fc7b72c3ae4a82d984b2666d87bd29f51f7aba6d095a72761b12313901c12472feb40e10d12b6134eaf8353dddfe07dba801d4a928ba1ebf1b84abb3e4232297e2e2c0fa102751d7e915f80389b94b53c111820597b918daea3fd7b9e1bc7ad757781342b8b462c2342c0e78585b75ec17cb998d5428283463b7f6e56f8cce781ebda1b9412d723de11d952a1a936d6933761c1433ca083429ef8f0a55e1b7d9b587562fb354473bb255cc40a64f050a2b1e2b675ae2a0af5481d2db27c88989e7a58f98989e206ace7b019d772ee12ac23040e2befb3ada2e8ddb39cb992252be4cc4912695502d7c2855b8d46a16c7a58c21f24e37cd65766db8d3c19ccad8b1c060dd58c1ea6d65b8c66c1b92a5db18128d1a701e961cee17151efa8612d39b15bc7c38dfb4190d3134b706ce20a4fa3197e55960287fccc8142cf5c6fd2fd49e647ac961f665c2da1be381f9e65f6fdcfb8967553bc38ad2ac17b09a2648ffffef1f7677c68ab143ce3ff81bf8bbdb6907c4c66ec1c08be3a638c3d473b7e2a9068d0564ca0d35b0f1b4e3cee414f8541b40161e813ce743e6114e1678f4e74439e7b0640b7ddd50a851a6d08eba95b807994e3fb3de62d039c03226930e1f9a815e445fbdb19b61205097f4841e3da07b647be230c682f16588f58d73ee7f467ee8b20b5c3d86d7c708f4325e37a2735f46ad271a2eac54240afe6350e7586f918bfe449df880960d2d84a1871df8c4589b23b8518df78d631d4f4ec56258492e6932edd479acf676f800ac45d36b1915775be27720097a1fe5c21265149347dfcb9ae7870cb6b9dee5221811f66ba9df5f6cda564f8a0243991ab35aba7f2da50dd33bd2cc763b1673b7a509ecb79d206f49ad7a6b6bc8d5c8008cace2f6ae501b7b0d5712a8a6ecb5943b3c3c6e9c3c1634bca187c044acb81194105cde545589450346b36dc253e16509e7b71513385fc2e79c90a005e4729938822128b11cdb39441942d73567b4b731c25365bc1f1ad064ce5bb13eaf1bdb06263c5783823de79c5c50c8decb3696bce016abad6241d5c6f7706eb400159777ae815d4a3e30021fbea3075eb1b49dee89df1ebf80ee97d970ad51c44bd02dc83769e7c02c561cd09eedfcec7a67188614693c1ccc52064d29a74bb8211f12f82e4f665d59d80804518d81d6563601697d9e6e0a49c2d238b232883f983fbaa67262609faeb9e0418e59bc55eec2bda7be24f8f3fee234011f3cae4d1fb71cf7f7ec51a1941b1bea947d43ceb224e36f3d7aa6ac7891d424cbc89a7df03baf5b7e268bec52da9017497ab45ca7f82d57dfe26d168a0d3fb53955b98e691f30b76a2464d7714f5b008d57ac8dad8d3de38aa2e9d02a7e00cecd913845400caef8ac02546cf6807db531b8194b819256ee269997ef81f3612ab5bc3e350c1ea80587d42ea00a3bee91574580aac67ca781501946100a8b96c222e972c9d5ca6d88f7b85d56867d4743b61b51c0bbf6b3015d7e8d1193ae3367f8a4baeb8ed0d5d961fc558b47c9ecd8b59860019090062e4b6eacd19b08ad51b54cf2b912974decd7a3bafa0bfc1186ccf576bf55012e785eff8e0d0409e2a700492b009eea4a9242dd1068b772452f0ae914b8dd703550e0c1ae5b6686ec5f115f9912cbd2341cc1d0f7e1fde1d9941943a7ee4dc15f3f051efe6a404a43927c05d41af288586cf15e41fdbd660f0b4c7843f6eef3afe01146a1abfc487b5d84e2d1a9726c48f399e6f67807fc123aa7e71baf2fc20ff73d49d602f0891f0402990ae8a04ffe260e0f955b893a456cd401d27f0cb74ba8e42113bc20fee48f50a3d74ab5dbe9d7b4601610706085a68ec0f0851cf54ede2d14e0f6c638a7a2f6d8b37a84a2edb75bc40adc1b71a294eec9d17ed80eec6b7bb4008bb1ec976873859adc56cc8c9f0df1a3833d8dc5774b6a242be50dd6d51e632aaa731a48af319cc5353bf7557712e711078119910be511970fe2d3d6ab2bca1c005bb4cd371b1008aadcf5521e277db28a80e7fceaefdbcad5e75a921d74948ac30f703cda2776bf269e8a4e44285277e2a8c40f7d8f07a9ab2532e0a711ee614be8ca3804b7f7d2169ed9db4c59248bcaa2431fb04e36e8678eb2a2862b65c6c990df9b616593a5712bd9b616ee1d83a7aee6f3ba400e496b002f931c8eac698db28d343581ab5f8a4d3481b2af22133cadc0095602e26f6d3748377024ffa93d76a51864fd30c7910d0b0f8e03cb8699b1e118ed9566440e0c6e1e141d4ba7a8d5f8e2af2e8e11c15c28b1e6017d58e0eab443e213c97b888a1c1ed91705b503f05c7414c19c9658eab27d06831cde8ba22bd5634d6b94b8f8c659b637ecb16a28971db844dfa4b496c649c64a02a701860bacf02af4275f0ebf193f63ef1b1e8e8497f394cf4aee68e43ae938baace485df7f771764d8fd8fbdebf3d0c8b91f6208cb8fcf437976dad5ca8a6e565adb2e927b4169e7f6064582a4c8976bdb655a2e73d54dc87eb9f78a21dcf5b03965a967a0adbd4990cc4086eda1464eef87dd8098d32f160f2fa94258fda4ba970e8f9c304225b3ac1938c0bcb6cbd9c39f6a83c31882ca89ed87beb94a3f54bcd0f0ea9ff5cd7988824dc41235161e4531580caecda615b9733640c579a69b468346a72e626cfd84815cd8284d6a749de33aa9d6553a675bfa51e9ffc9be194aa4df8dfbee98afce64e5c105dcc5572542d5b8e23b0d11ed169b7a53e4d04d04ff04469d0f0ffacd2e9a96289e3ed3fa85c3da465339d42e9097aceaac262d84bb9fb630306b19dfca73906b2c96f32d12f2bbfff0bd37653f719410508a019a6bc222c84fe20118b30d4ef279ecdcf7905f523ae5f16fb2a7d20589ff2b374f4c3a5ba38d663751737e15f043cd92d25dcc4813c538797c13ef63e24c64284e59c1365f322cc6969745a5f0897265586fe24a9aefc9af352f5164e58c8d05b4d771500dd4bcda11532740c1e01f6eca388e2773c672ceb811b67ef388a82ec583056116034991b67ec016f2aa3ac496d44f516846b94eb0a2dda23e8f2a84ffa4bd92f3fb9c42382dbeaa85b7ec752630a911a3ed256e3ab19a3cc80e9c16016f60777689a31da405751847c55ed4c1cfe61ed8d374f78f884ba2456b4e9ceac64101ad46903f608648b5b6fc1d2e93dfc15b9f9b78819189ba5173b21965732b98b0b8daa8005b1936d0c9205e9a9d35e9fb45418e648f89d39b04975f5db37fc0e314b9136031782da2f054563539178855fc9a05832b95dcb418bd4d9ed533d8f4d3f12bbb982a4b7cc50e2235b5669c4abd403c4d181a129bfb28eb6ba262ffceea1c67aea1c8d79956e8b862f5645f7f375acd104f5f584aa254a68d0a906744e6bfe964378ca56d14eff20dbdef48ba97eb0cd4d7618ce11da1bafbf2f5ef2bad10a173642df5445e8a1c48c78905dc2c9e2128e28fa6de181eb7aae54301633d1bf7753daede65887ebe9566d37ad9b5c40ecb9d8333b6af008b3c226ad91b7edd7251c66955c0c01d6aa74ac290e1c611d69cb68f10c5c5f9308d281e9b485681dda88e5b4c3869eb7ce64afabaa0bdfda8049bc2206f06e47f07a95c9e5095d9f8f4167db49846fa07f2b0706fa96b78abe8e0f1856ab864a90e4f159f08d9e77f66d57a055a70d72c6bad527e163999bf8e5a8c6717ad99393e2fd599e3e862507423849fc9427c3969629386b950bae7505df51bbc595ca5865f6cae4f5de81b3c8592dd33ffc543e9ad485890508ba96ab0568d9059df7d9e9592a08a9fb1db66f0746d44efa2c3beff4e281bade6044b558ee5ef96ab416bcf65de4e97fe06eb543e32e50e5adba1c5721c68ed542e5eb45d68546cfccf561c4b2009bcae7578e7b23b7990037342a01cdc9b6152c95c1eef852497ecbf47992d0a11f6639d2d1e03793d174a10cf81c1c598d176a5a259d2f1870a3b93ceaa8321db9845d55693f9d6992d9bfd685a3410087cf0ecc499d7fc116fe1099eee19c328578b6225669d7db74bcf3607b2d74aecd0e3f8af790344afbad3429089c51b2ef0782952eecc069f9a1945238eb294452678f88cdabfc21a350f21037501e52c2e5ed1b747dd4f827f149eacb72764d952cc233715d2f06e05edd6041a956a02b9d27813784a9faf1e28aad254783572a7791e1831044e410752578aba68b51cdf6398445138a47bfa473ab43865022361128c2167f30d289a57d6a45759bdbf063d7144775569e6d17f4507a3b129ff37450a4058ebb24d79c97249bb6d92e35f1ed60ab5c2a677ac390eb59bd61900e2a0259955a3e08695f58c9c3af9ae4ee6b4df5d3f27e26993a51cef949b51cf2b4c511d8618f29a6fddb2224d1fcda992ec81cfb043f75f734f51ed0bf7e9357695b5402417af4c333007ea82358ea3ba06752d418daf9780fc53f479f49e8a4c428b084c6f319a2e6a3308f5e34e204e4d3d27cf0777a1a34e2d2cee5fd8d58e4864bb89dac8eb0530164bcacab153259c39d9b9b621a81127cf88c60d11bebd7e6175a07750b735e9ea12b9329ada2087d80c04834c2f77ae967d94b65f2381e1706ead0b166f05c120915f614ec0b18fcd95a23cf2922c5f9cefc53ae457dff884aa6e9aa5e16579d9158efb3e8712b25a2fbcb278744584b9f76757c4bb5823d734626a0179f78769f2a0ee5d69ff07338cbafe502754e508ef9fac4021b2b83780ba78e5bf15fe9bdad023256c53961ede009881edd789a26311dd4597f10726c21a2987cf3a37534242a3e0cf01d70e48a60c9d018e8baa485c34864904b315755b611691c7989e8a8f42a82fe34d3ee70c45d8ee5d4f781c8125a006a52e4223c4d26d48b84ead2e9d33567dbd1aa7d80aa616194c14710a31fa9eb346be6e28491ede7df441e4b7e95ed079c371677019ae95320ac922c63225ee1a3f4dae23d6fdf0e3c6a65124c7e5c9addd26a5f222e282a5e56da5ca2ed479205603cae73fef92b4ed57dd7822c4dd51f9d749174990283176509a2d622f3eae64776c61fc16e94d3ead81dec9452b69fef39511ac8511525b05d2000f93cd2ed59abc27468515269b2fef93bca2bc1e82e9250382ef5ebcbc3e1f31cdf1af6915928f263d79b217ece3737315b93163f9c06ff8da45000cd4c460c60ee01e787c7574eee036ffd0e1c0a7100ece53bda524a2edcd8555554a75cf12e293a2202f7699d99d7e57175db6fdb8776b953457034ea509b09bca76e87616836d1ebaea80c7a882b2fe34f443ce86705dc7c945a6036b430e70c3fd54e5f630ab7bf07d4b28a4a99a7ded95a512f451aa280c27ad8e54e03413dc71d6b821e2714fe90493829a27df1487a4acc8de62e07503f145ac819be379615e524d8c8842b83359de50ff11608d200e3f1e157d3a57349846f452af6dff4d5c9103a7a0c4752cf2f4605279914a75cc232f17c527c615f4b869f93f88fdb54d824d42757473bc5f7ed1970ca3d672583e78b52a52b07ed8a70d4cc20f771c4165defd941d6143b954ee6fd095e19b44b26823f76a0867fd0bedfae314e725aa93c741bc85dc8cd3cb324384949588aea5b9d034799269ec40d93aa58ff79e653e7d0b3f7e6082039d6d7079407e1c1e08461c23aee4604e3f177e60b3d78e7386c1a25ac9f70ab991d734a5fe5ec5f74eb80994be7cb583779ebce18859cbfb311dc3b95af1083f1ee12fc76f67ef79ca825ea6f664b9e850a98b2ff8af46c2de4bd68898565d4e063a6ccdefd949349fa2840f0dfc890fddf7058a35234f2863645afe9477310cd87e70f5f424af3bff906682596d66a5c04b7b3af23db18c7145c100298451371b16b61dad61c6c373ee66a6c9c428a0f969b41e6c45a3c2dd20a69ae88656d51c061684df03e8595b84043c96eff242b74e748ae76a34b48e6a732a3db587079daae2b74712fd8dbfe6ce12f9eac8d929ce5a99627134d0f121b991f6d01917e1dd497fdb94545e5b7e3de01795bc7a8f3008c32b2c386d612623a15abb70a9878510976a077d563da4f95bed63a5f33c636ebf4a4cccf6bbdf8ca385dd3b673073f1de54b72ef9ee83e1384a8df456742ca5c2a3574119a6290fde44bfb67f8e63e5a071445533a4946e139cd5812388afb06bcee788f6dca8ece999c20617b5d6678afd565e0755a024cbf00143c9eea3441262850d424914af9493903a92c638bbb09be9627da66bc8a8bd866bb01e4f7575d52371eced025808f02b7d1fe76d8957ffc6253bdfdb731290b05e3b19fa2862f3662b48ae91f4037a9ff6c634ad7b89a8ae006182bd3e47b3f14380da017cd3072a96e9c84e42f08dff22e75a48263490714d74bf389b254f11341eadb6795bad361f497438f84ec19a2a490cfac5dddd33779a8a7b8637f56c59200f09739832a905d4e258fbfcf7feb5f33d4bc2efc71af4f70d08af9f8aba8231da4ad1336929792b1c59f97a7381a9b9b6d705840d2af39b227a2ba3e0f4094acbd0a70893408a9501afa930351b30667915cb27e5b4adca6df870a929e63590f7d662ab1af2e8e687e73ae51e5791aca999af33b634a6720224fbbde8864ba7347a89487829dd34f53bc53ac793d6d0838ef21244ad65b8160c957081ffaf07f798799c244d5b8116d8b9e070d492693e29f0e623eab5341404eebcf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
