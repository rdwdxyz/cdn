<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a909421811ca6b316dd232591577886f1ac4e708af8c16301a49b35f9ad43cad9da9671bf447d3d966a57ec8968c92f32548029b4bb9fc978a003049baf83e2bcd598ab1488526d107a04641d974e2792c0e8943729b31879751633937d079b71f9cf1a32b7bc68e517bd9b194a393b91225cb2697180d7802c041398cbd8944cf5d3f5817bec1acb448eb831976575b43591c738f761252bd280d2496a96f9c81980bf766df83740566f70c2155090a76087f482801c5c02c32751b52dc00863ecddf02d33e87465a0d67e811e14a7add9757a69564af3e3642042b0911a2e9b512b8eed2c11ac202840da086dd2c5a36facdb8b8eaba47b404bcee6fea7575fbf08b93d1dc967f8dabc3c2d3a294eca144be1bc3e5237524d7ef3225462c1d2aa7748285002db5ea532a6ab6f9cd9559967d696b6961e5fcfd28fab2cde27fc4c0916270aa9da86f374158a5e66894b642ddd791c382aa9ef910334dd4059ad6e247d5d45087b285e83e820e8eadff476dc47d3ac1993f006a9df4000ac7fbbf3cfdf45456ae4237967964d14f227856bec2a20dfd815c657ab8af7540243aa4e02260aca43d838f7837540620732bdab62b3d3477ae0afdcfb8b97adf69581f5e37be6d27948201bb5092fc4ae7c7ea90a79a4f9e1433d63a694a7d2d917d96b896b2478d9b0712f32382dfaba0503e239906474e8a15e27192377b1c8f60fe78a3d164b2fff0d5c1f5fe41bb3b3e740fe771ac20c11f0fbca781820c72faa2ad93a9a4b919341559e31271982f7c791bf203be416e9fc90bdae7aebb24dfdeef636702e7e78f818b6c20f7a281d418587709141bf696ef23681b2098a2bab125a4eac92fac5276e2f349359a6d82f1dfc1a77369c2093413e4084d920f27ab001f1d2d3fec7707a62cfc2bbba855ddadbe0b57ea137c061f5de14c95e1fbc67712bfcef4a9e531729bd140a5e76fe5676261d62e63b6b50c37335b4719eb3ad1b13b9a74fbbb3983e14c07b41c6a5ba6e042904b862cba5d75ee86407201b10a52f094291d673ae27b712c8bba49fd8c23d935c46818ce3387d8cf7e434b079b3a1eb31ce57f834c4c9a8c2cb9f007e665c986b7f81090f3f6c7bc28383163293e9cf425b51931b0541b5c3ee88cbedcc3325881eb77599cabe12d0b55aa55598a25d688ba8cbef8f63f51e2645e3bf59c94c2a8ef331173b4709ab8b026a6ab0cd46d854ba97582cb458b2cd09b0f8d904674bc9c525a120a54e1aff9a2aea1f6df5867f58c4f1df058d0807050eebc926a95558604f88ca0488ff47a7bb66239889a6baab8fd81ea1080822eb3904505b9dfd3bd245219d139c2a6d448439ea8c16807f99f619209b6bd3878cc555e524195e206ea6ee0d8e1e22e81f799b9920d1efdd574782021ab4759337af7fa3172dff62e224bb5aadb3d647b7777775f233f934843db7e049b9d743534a465bc45be3d7e468866ebd8b815c81e9aa4dbd9ff899679b769a133d0eb707240430837f754ab36565c534888fb278908b9433cf48206931fb9fc9920506d5e048eebece15210022663f312c8dc8535d76cbf134d3ccf19826c84a922a3992d9cfce07fb444cbbfb55e288cbbb652a50fada8019efd6f1f692e6f9809c058e8c1886c0f657ea268587064e20b7bc389a3fc261668ebb5d59df4f216a71cbef73bea29ae557c7a454098eadf2c8e51bcbd9cff237855bafb5e205d25c5ca01763536d3864fdaf125875667c952c1dd6f0c939eaf43ae2caa3f86ff10fe39d7bab2032ff93a538a062e1bf4940acdd75204a314a5f0761b57ef26ad99792f8d1417c3c0689638f645dde1aa904deae16a83b34bb347a93be9b8edf9f68b110dbc8742d057e9cfe0bee9f4a69c7482465b8d61a802c90a7ef020b96f53b900ca70bdbf5d6418f9c2683488ac1fce8654a81501bf820db1538cc13445cb1b95b60ae749a770d315d6eda968170823aa7754250e82e1cdde471ef4dd877852e95fee088e3abc2e065b7a1defc4a4e71add3d3607dd5b4f748a9330ee57ee8b5b7e195892f8b7afb0057237dd85599a3936a8ef1f929209c7f05a0550791ded07861af6592a5474a9124ffea92ffb903a6ab00a45746ba068befebdb21d5e8608c7f69c3c31ab12ede7baff7b81cf490fe82ab7bc1b0256331aab61d5a689a6001c7286cb703fd7a15f9e753ac721745dd8a207b20e9cd8e51784aa7d1b4cf17a09ea550c8deaa60504b8c285f5228e29fc17677d5f28501a62862e6455a8e2cf5cf249278fc10e9274a5db54cfd5b4c5b5730aacd3b19f4deaec67c5e88c819f2aed36e006526a6c0c23f9dbb8f3b9d285dc41a2d32ae85d0586df0d575985891c8e7f88a5a7e67b6569619237f360b1de5bc03ee1d2ff48d8319501f88ecf66815838005f5ffb657856a72c795e9d1a7922e44377115ed701d14988571f430876a57e50ec26a909fb27542afa83232399518a8616fc82f193e3b6dd474f7d3e49776dc4cd7f0d54b6e28358d43b743264e7bb9b27e0c68ef1f7c7d08aa64f2eb8b75a8d5fa046371e2a5c4c72b02555d1a0cc0d49c0bbd6619fcaae30e949c60a6ea013ed6868007502c7d11a16f0aa421f279ce291a511e6f362b0e4de3a080146bda3fba650135f03b04ecd745435f62117c4ba10f3eab526964f48715fa3445b2e324c83e373c00c7001e146b0fe3ab46d4da6dacb9422766a46cba9a82b07387b4bc954fc738df529c676594b7e5073430ff6fc0658abc3697c98e0cc6708e9fdfa2a36a1e2a493aff5837c08ddbc3b412b6706773e27127a781045d1693a627d3fa1086a2798f3b0fe69d83b06305939e3c7e6eed9f4e157366556a033c13e50ddcb5e1ad948083b563c4c14537989c2b084d393bd85aa1eb3236cdc9d5f9a8f595110885ca48532fd8d8a2a87e8ca0ba793f8d25736f87bdaf5e15a8f0f573d75aaaa3fc46963e8c24d06ad8a5926291486d7bfdb7ae4a8949e0d8a17073549aa121bbf52ea8aa54b1b47b0038080727fc2b208a1362a9c84e93e485510f2b2d6429c1ce583c65d5a83822a110dbddf465012b59bc40c6664b6af742b4cb922855a03022bd59c680c25e2acae261112fb3842b0ea6b6b8343c95c425635219d0d615441e68a2c99b0ab26f3ab9efa2c14012fcdfdd81f6f94c39a2a3757d1701964957e0b30c756d5404cf9b2dd4088dc23b9b78d53898f743d16be206c181472ba43c490f1dbcfa1c774cb3952e271ad1ffb718a3d511328ede11cb0665aa8067cd13ae595bde284ba2d1e5f8dab1577b9b760845d84bc8417a761fb27735b9780538a73d03c239520762e0f11e09a9cc73b22d073b24f960a83c6db0292901b1a4907427d9d37b769e8f656cffff863ef02b5592d386925808e31e833e3f769d7a4c4eb99896114dc8b53c96a7e16a4ca4b5a5224cf850e9dae0f09499f6a05d8a640dad7e0333e4cda25ee314080a4f4a317575deca3025e98d85eaa4846c1db2d855080bc0183159fda3885c3d5e99bcee393c4f99ca4d9acbfaf519d3761c0b664936a405b6e95cd736b1102a2bc70659808d145ab6bfc769b7b743848df9fb9e334921b8c1d989e50140a8581714f4b6aff5182a7f62cd0d9b3b9aa83effac33726008c1ec7a4807eff5e722583eb595a8fa552927a49c3fec446f9eaed716879de0393fba14158ce719778a586558e5368ed9b174a6b64b79be6e48aec9e817ac3a9047163d2d69fa6dde8429b7491d863ed6d53e18fb6e810a69fad7e39e6a52ddccb3353ec3a5090ca2fdb9e4cf30ceffd8056be19fcbb9552492392bc65a0c0bda753e8d15eb27c542dc4d3cd892006b3f9e69db5762d1af8c694511cb571162be4da23251c184a1da08b2a1605ca4303f1827f70e077f080cbcf825a0cd26d3a046e09990781da47bc6d2e79432d19f6a5fc5b44365481f2919cf8e1cd5c4b6a28cd1bf841c2ab74abb0786d8d1bbeb0fc694ee1c2995f50b4336b649676fc0eca9104ac97075b6e958548d2e55c0ae1dde2d056e8c226576c3acf1f72312be2fdeca9575c78a41a49c25ea1973594c81ee49cb180814e3904016d43a58fea49549b0c83fcf23eb90196e74508b43050a4c59fef94f21ffec57fdf0dabafa7e7d5fffcd5d20f32ebb71334f0c3e7488df0535b35b70881207a55cb16159ede55c9574c768dc9446759f675d19dc40f650dba00bdcd7161341685b859e40843b0ee2a0f8e1a40f491ca1b185a496cd85c36528cde1443f26453c2b67466275e4b5786e5b35df0acb335081b36c46e240861e652f971775cf6d3afebd5270233eb0d5b250cbeb7cc77f2e6b024b2e26d98731578d93b2e701d8ef9a176d33e94c974cf0a0ae79ad5ada4166d51ae35683baa3ddd5aee08e37bc52fdaf530a4f39fdd1f97d6289949aa7e957538d965f37cc95ededd580dc7963a162ddd8c1eda61c1f58143592d51013ae52066d313db4eb10f086d01fc0244f9510373b9a9ab10956a05783a54eefeb2dd3d7caef73107ae9b9ee35408930b7bcddf2c930f553021991bc37adcaf66dacbb7ae465c96f34245275ee0f74861b289a1b0c93e312cf2ba6f88ccc169bb641f461f8d66745a1568853dcabe7b787c6395b8a9479d19916d74bb4df9aac7c7724dc8d437a4907e922a7d5fe183078d0705d8b459c1b264e4d8f66a30d36a441a66fbd9e4b090d3cf848279447a4f22e1c5d197646452699d2ed3f5e58b88705daa4ece287b36156b19ef4adb5c09d96d563a75542cb00eeb1caad4a3eb75b5136e54aae81777963ee3cdffc8b24bebdb9d07bcb0574d3c4cff436b72b6f46689b633930c069fe0a75a1912db791f4286cb12ab6fa07878b95713aa0329f0ad403d2fef1fc1eb079fde8b2a59a0ccd715627f9cacbf73086ae5528bfdfff1bf9765714008e310909a861b49ddb0ef5c27b4d276181655eb482375bdaaaaafa07aa19a5799a4469c25c87490619d7963cd2771a5157a0cb251cdac6faff498b1c2d4c16c00daf33755a8eb47bd3716b5847d692023f2c7a676e8235c11d9cea7f080ec2560ff7f03b42359ea39245cd0ca8ad043fc6dc17971eca556eab75baaa01158d9166e22735f8d74fda9058ae763e54c19d054da1b2f3ee04464b9a00e73109083ea3bdbc8a08bbfee782fdd01201dbff24da83e134fbb19e980fdd04d2a627f05ccd8551387e7ad6cd4693a700b0c190681c06ba80cc1211e43c1fa225a14bbf187801a9362a5f4bfc37027bb31d3a53262d5045d44a8ef5b4d1507867eb00622cfdb5367b71469c583ba21a12a95bb86e071d1764454bb64674897e51b53f4d0370d08f92dbb2345058be3cd2deaf83961b512cf2cbff3522e6db8b03105cabfbeadf348fd4e3f8947a867b97ed76265dfe1a5582b6de37d2e548f62b410f8afe9fe6967b9997c6b31d83d7e135790d607cdcbc97c896af4e1ce3324ef6bbc2a22f636556f295739d758276c7a5d493b7bab7bb28c36068e32bcd1fa6742dcaf67ce8382681ad6930409b5e265dd7279d052e261659a5a2ec174de1637cae1f3a5ce7f00adf7303169a38c391824bcaa55273ae8b0c3ac0d33c929404aea94521422b35f5239089f929b510188f7df0030617132b91f23bdffe28f8ff7f7be9fad3a083ca168a1281c276db7ecaaae64f79cfc193df7a6ae8951dcbc118dc74cdbf0d39568060e4227e9168113f1c229f89d50a734a5a5f9bba4d336ca27df21ddb1b6422e793d62262d5893f3c4adff4962a9af08b1d798bb5bf6ef85a334c253a467dcd2b492f8a242ae33270fe63acb77ba954a0e17849c0a06a1478702b4ea84a229a6f16de26c488936ee3ada97e7cac808229322f368b77ee2d8244530d1ecc3f10e9335e90008310c1121aa3f1b616e762d9b204859cd4355d410e95c9e82b6a717697e173c9478359bd5ae5e91925a4e2a7b826f802a8e5bd6dc5623953f6a46116c3f189a3b3ed94f7a4bb0a0b235dea84a83fb96cabcdf7abbd82dd441b894d8cbc19ad078b3e777b4dc4ab8087da1c0d6a8fd1d5328d00f13703e7b8d093eadadff5eea9cde90517c423d2546b29d9f26810f19615d2192640b34936ba199f355990f1a377e6f7875e8d5e82081f680213a03c3aa19a1b7a5b3c70549cf6894603c6d1c6fc749f8e21950973884519530255b634ba2d57fc16fd1309cc04bfd9ab321d0ea495371afd178fef86a905a0bade5efbb2e4fa3b0587f6d6ddee9e6208f0996296876bc65ed11e8e860895217b6214dff68abb69fd5cd1a22f791e58b11803dc275df530fb38f885f2e643077bc758c56199997956aeabaeddd7eeef2c1a852503d070e6528aae5b84758de94c288854a7620d6cf3004862a2be63eca61b7581f39415cd0da2b88268970dee86a427b524070ea463054284b770590d078dc6524f6e3af9f73fb896a3c021c3aaf07ecbcdeeac21f956aafbf03a75c5f3e0ef36a0cf03f741e389ba14c9a125fb96ef191077a8a905c43049152d58fa852da85606c57903171a169106841b398174a933a76d725097d52d3c1b77f054fe6b9e82f9ee877b96245ba3d84ed19a8d74a042ebaf12d4f0275397f06e4ab23cf1144a81b0cd4d4f2ab2a66b1db2f405bebac8cf4919b5e44a20d033e923b4fa4870c23cb233c86d4bc709bc16f48c15cb29ab8f451d39f2d3a1cfa7e28afea339f61c8d35c12aaf505f83a50dd1c73c6a84f2b329501644526bb803a89c431c9f75519410e69a0d9f9e21f3fb71c9ac99a58aeea88c5e15d2e910d573f84855c9c3a7f37241bc3b2084754cff0e0fa6f48b474cc7634868d510efbd3f088bba3bfb1f75ffbc276ae595e99ae7f7d827801f50913b7a1631d80d4e14e195e3722768a16e8b8438e02713c8cb15ff8fe75fbfaae840dc62a8316de371f4d26395abb540bd33dbf4e625107adbdaf8a95a1e7dfe3c7a2a7fecdb71936316c6df1dfdec0286be1da725f38f0ca2e4d0a9d2e4d0dbf9827942ad687f78cd31e5af3b1516bb2ef71110d7ec2ec68b5ec9e59a2bceea2335e20c98c2ca75dd665d22b6ac279a9d75f9a26601c87678480c8ccfc0866cb76dd91627e91d30856844e442cebea12006ece8da47b012f7f75e38853b5e8b956439ab000afc880d4146bb9099515c0160836e5803735af9bc4a7772b3564a0056bf85cbb8ce2c418a467d21cfa77f82faee233e15d4c16a3aac9ae1ce747f66622bcf52f5a7e9ad62c6d626b6ffe5fda90cc0b72c613c4472736bc38e73b521ba189dcf288ee69f5cf105eca26fd4c2f828397315af3604f43190e68a61d02fb4d7c816f6fbf42ec25a5b72fd4cf9930a49a6988df77f7e205c4b285d83f37650067be443d10c7fcbb091193ffb53b107c5222ce1cb8c627305f657d18ee76dcc4c3a3352f23e9c850c4b40eb82ce55e271077105337839b8a4048e26495aca22a928ed12f2b3b511c946b2bea6f8cca1751d2bece615c9fd41db7d8a68f52333c1f930f7a0f4b900d9f82dde45c72f637f2c21838e6f44276587415c017daa2996533a0a146b6f128967adc0be19ce452765950383fdb0fd9d8733b12ce617bf5fbaee35df3b212ef20b51926d2839707f56bbdbe760e4771b3e841b6a772a2cf07ed0be65876eb82131894b920faaa6156e410195a9ba799ee18bddfe327a5b590257d182083a3fb2c14c1f8bada63c3b0afcd63ec3b6022d1952e9baea1d107dc6ddba4a4961e31ef0317e3b450d163a975887d434fed501d97b711d927f93bb9bcfcba7570df72ef50279c7de5174f399187df9d492ccd122bec4c4e8a6ad249adcb7a9f5762cb413c9f11728f9f0617bb0902aa5d7f327fc18bc62f040977c29f59aaf72d17f74a75d3d36af4e836cbdefe570cf417530f1334e47a9ad5b1e79402913c7805993b7300d66360a024f2ae49814522f1e44fbf946b4cbcc7d580161b55319dcb363aa74c6a6cac7947bdbed1fc6068cfd434223e8f73f1d9b3d15e192a539467489057a630febbdfe201d289a7d43629466de868acaad3b1b44866e80c3df2a0bfbecea038aa3c3ae842ad8bf05382a3020c5352ba9a047b004e51d07d650850321213fc8138d1575f59391f527f971560925747ebce3e92a52d178693d50dfcd0afafec89d53b5f51c7ea48076ad67bceb88e9b9bec0e04edf90dbb0fb4f5ca8c47eb67a0e5e6332aae810355d452c07f12ad86de7e90e96b9ef049f128fdfc660a7e6b73f98daf0bab9e60d56f7366f889de5977db99f5dc94b9f8d678543273d91a9e017eb84ae9ae8c6d4d7324fd13614cce41b90ea16b0038f0cd7f3195373507a5c3fabd1d243f82ba1fc3c31523884933dce485e703008c0ccf3ff90f87d2c054ee1d702b3d815757ece32e1abba2af0d1556084a9001a3730aa3db5a9a4ed638b6d7305f7abff5681a4cd5d886a8332ea4aed0cc264a6c18cbd3dcdb55c20d0228f428b5cd5e742fa6df25ae0479ac22a2f39481c7dc5cbf6b5922a96ff3396e0f1d8c7dbd7f4f7f2ad9defb6c5745118f9d75ad9eb2317c886bc5882348c9a161322b878ef97ab972441ba3236da058172cdfe2088b5ba1700058d54c7ce27af3706835c5f7f9e91745a94ab8c56323724697cf53c9620d9cc8c14ae8ce154f242176f748cb7e3f3d7bdb8be43d79907e31f2be348514c86843abcf5519954898090a53b59e728588393ec0ab7c584ee54619e57bba7de796b4b4aa5ea3e8c5295adf3928e67c2bd8a4989ba3946459f25894f28f898ac5bce872ed1270dc7264aaf03e820b8e5ca35dee6ffa304006ecdca4ab1743e00eb424e735df114062a487aa7b3f46df0b1657915e82d791906d530ccb5ee5c6db1419afb6a615c8fdf0fd103362cd127ae62885ab0246a5e8c927726e185358b2d62e00b92acbce116a9b0c0bb66e902cfe7a46b838d587083fee60564c308b4abd758f66fe151191f9360edab33c2583419cba027b63a6f1c5ccf315439a61f04492de3f4cafa542764a710d61c5c9e00a239f3ea0572c283bc198faf26001f5578e766aec2b57206998f1107fcce3c759d9385d4a17aed0c0882ac47903c532f29f13fb6e67f7611c1d77b3a4676c9547db3e250be43534c74694952df7dfc5905a2219852b89f6bd606c9c5ea8e9e93ca25a729b01d2305ea0a5b3ae95c2f0c4293805df43884acff40201a016429c6edaf715c320b114b1a3e9f146548aec01b662ab68d07d69b6fbb66ff9951d9880d774d0111c45e66ee5b34b2ae851cfbac5bde20b9bf44b827bb110810b753ca5f256b6ec02e3c022043cf8b03b89833a6ccc0158fd02ed06cd1fa820ad7046bcb7eb078353c9033c6d865b37e68ad5af057e922d91a3ed279573e604f1af79ac0fbff65d29d64a1f87f39dd86a6dad1c9ddf822aa481b97a92667deaa44dba88d92c7263dab8d70bb63b77f532e7781ddf0d3d026a2c17a67ab79d7884a78ae88b77864d42cc42d185e95967ee017d09cb0a0c3858d4527909d4452839ca969d30d4b0bba7161e04fd5b7e441b9c00e847c4984db2a28000b9cf8e6c79ab1fdc88a28512a027103dfbafce9c5d45d5b8cbb0db4b74970d6e8432c09a8e80548d7a1866b9ba92a7a61a815e7012bb61b9fc1734881bfa50bd7c91a2898efcbb68ee4ce6d23fd605aa52e11a16d81025b4dd4dea1993a4f2a80f05cc9322a56c2ec3e56ccbea48da6a2985983227e9648e61cde9fa175783d182b97d02ff52675541e59a939d93dcb50d4cc50e9dfcc4e2ae9b7fe0ac06655e6e70d6986bc21dd96dbd351c75e77b346a446b59f59cc0120ec465e8cdc2c3dc03595d5efa991969dc6ea80577ba2b7f3520803ab89ec6c5583a478f5ff3011b729e9cf6cb66e2cf89a0867c732f8dfada57bb1ae9075bf9b4aa0c94881becdd5d89af11fb10857115e0558cde7218bc36c952354a8557437af77ae6093abda1d69c88f9741409c3eadc14bb7da2231a3ef8a81ef2363bb85659a00e5b53437ee75e804cab848ea4d666b0209ce74dc7b8aad85e3bdac4ede2985372662a01fdda095f0dd42b52c2255baf44cb89e6ae22408e6964a3d2eca3fcdaf3e5253944dc8f73b037f668730e07315206a048536aeaa768536b8f6daf4e843eab3cbca906d3e5a4fc13fb9e5f8096ce49dcfb7e30e7f65fba6f450bde3d77bc19c18e8038b19e1c7af66335ff709a35af5b8f142671639e5cefb3ac670646a8fc0e50b0aba4dc02aa08174f91a730c0bfc41f235641c901771a4737667330efec13172878bc43fd44d1482b2b2b56029ab3fd19375142e7134d9e2c0698e57e03b1dbcdf85439322ba8cea856d6d5728625a7a24819b8b458c58c7df9fef5a57e178aed6a8a7fafd6a4311caa1e841a14388fbbdb8b969ee59a8a7db69ad95eecceca0283dc1f818921c8231da962ef09d03ef53a7ee0db7b9d76c7a176658fec9c3d7b05dade378bdbfad2eb1f551e795029ba32a4cdd2206e903dfd7b149d62a89608dd05bcc400a75ef9318ab2c460d9f5c36fe9db05a666094fbc14316a44d0aea406465bb43694725d79e81b4d3c6b68bbb3c0ccb3f0cc222f6940f094aeb96d5920b1ad42eb0552e1e3f068f10ecf45363f6b9d50aef8bcb3b6aada4e30788cd3dc552e79905cd683914238e3b29de41900d2de321b201fc743287993423b7b6d822c3a30ed48c1651563d0b036f529fbb8571c15f29f16fb8900500289b4b952f9aaf288fe6b22c30138491e667c43a360da979ee26e96310aa61c55389b54ccff8b9227959d866fba0f8cfbb69cae80a1d82a2d30bb960aedc78b5d15e64e4d7b0b841e81cbcb1215e451fca039d7a8baec5b2fc38a54abaafdcbae7b2928e3c38fc29036ad3b0f720a29403592e95258cebce5052eddab256977806852493954a314cce53670260c9470dfb76a3b6785f69d13a1b75134c5b58a005699e46368c386bead20a8fa9a6f367304e4236224179d14711d9cf18a28bcdde649accfe0dfbec1aae4ccab07f74d56d8b20a9ae02eb65d7d482b3e05f82e4fdc6167374ac149825d28b6f3498cbe8518ace44e0c8d2b6b955bdd2f2e9dd168b81a139e4379897f770ab242fc91c260ddcb7103d439c920a4245b6c1af27798c00f73cc2ed7d909e18a95a1af08435d3f9354549db5b8f4dfed5b1db0e08094fe3493a4ee426c0fd9905f488c5f373f3e7180024558be9631d3d8ca2804917375ce4fa438f77298755ca6508a135e31b317156cd7d039fb9f1e9403d3bc5884d38cc5cb5af50d87cc6462ecc9541541c97bd809e09afee4313c95548b7dfa0c963bc482e3337cac4a45e37590dfc737c656612827bae97052459c97fbeb57fb38f55dda0cdce7af6da9a630d042a1beaeefa8d58b7c239c9203d06741c2ea56457b3f47333848421bad2e65c9b274ef65db2b419f377fb50523fd0754fc5f54dee6f6ebf066c3831db2404eed7e7c146a67698d726950c03b5f5759cfa2c7d7e1cf32a484627b4eb4d9b5aa3dccff519ec34b541cd1ecf6c999b378d2f925299333136d720a53e8db14f0a645cdab693caedacff836b56af388d9e7c788971454be518241f272bbc136c88de7424c82903264c13dccfae83f21a3ded117e80ab2f6ba0f243231369e93282ae381270e69a9e691486589aab5a84a11e9f007366bdc955662a20134a4978373e103abb5349b5729cf559ab6ae2ccf3c89d0209632dfec477f6b587a4e4e2b966d499bf8206fde67a170a574ac35828afdbdf6fd3c86eb430551e988d9117a8a47e553752c442b3660ce043980c2b73fa5f1c54676c472cb266f0d1189619c7b241cdb24f795d157ba332ae2cfedee562f01150b032118ff41053e114cfd74d19c8d5eeabf78c20416395f71359fd2618e373f5d878d3a2b43e3852fb671df719006713af6c707124af77cf5f5d403fca435f24e2aed2b5573a1597b16548d5b5964ea343b19bc670979f4a014effd905693c42827406f9a9a0a9744d716c50d5512cff2afe7e0eddddbd929904ff036feaa5ccc363a6a34726f5e8062aca3b5d672aa7612854f87f6483de784f0e5ddd4ced9543029424553772aad1b6db70b7d0c88ab215081a7cb2109b023c5c39511b5bb4d7be3aaa5f66d9427fd6de7b6a5cd5182e009c44683bc78aacb1d85870caf50fbdde0a1798179db8dc0570c94b3b95443e8a1682410847a006f0429128b089515bedf1d48684945333e9bbc71cd45e94cf23d99bd0198efa2451276e6ea64d17f34f40d96266433f5c501927d123350b02483b52be4b16cb5a9f912f68f4b62e06fdc90b474239fbf00949280d4a2ad4f4fb3e8107a3a796326e31aac17976768c35832b43655ff0bb4b3a3c35e39ee2759f15623f504489e4eab51759e5d8aa226373d4ad79fa2657644d51d67d5c53e51e5f7627f8801a2f5fa3c69d2de53a4440ca8d9f5de64a8e35ebc62cc6c2c477181e0da52186ee29397e96a8ecc12998fc328a75311576a11bd11888abfcc3751e5229b76df724f5f99374fa6084f9b868ec387f34dbff5529310e71b2d5a07d7ccbeaa9e910ad6fb8f186cc56a2edd3d1f24a7d090cc170efbbe4461c607ba2c3b8352583dc6640e081649e3b2c3e8042d43e5135be3d3f810dc8cc7524c3f3c698eea26ce4442a5413fef19349e2d3a0d9ff68dc253e6938d4fa381f5829f76dbcc3deb20255c07c1ea9c059a09d3d2a05632e86138c2623081c551629dcb5cb133204ebccd0fbd32c7d2bea122930f3ce1449d1fddd1cc5900904174350c0ddef8e66812f50e249b737a0e3c822f367d319aaa50594f997475a5b5b5cfdb687b52ccffb4d8ba9c82fb78f29dda63bc6f4f78a91c2316b8f597f2a95801fb4843273c2d5c418016f3187f2b05657e12aaa6391af6e21b5aa161fd94358fa63bd4c02316674141712f450af7e3b5d03c34818a381f1d86e49e1e3f9a21c0c6dc6b2fd63bfef507c4027c07280fa9bd600a64bbf954969252595dd8f4bd9c487e17261ab2d45f113d353dbbac4776fa8bfe79ebb6ae665f21957559a8d072ce461d53077fee164aaff349bb283a978cde390dc6c19b524f1d649adc782804547f2aedbe9b05a17287c6ec0f489179200a8311072e421171c0736d44ab16ee8d546e310a20c75a8d85facee0717e7807f789db3d33df61eaebca90c2fbea3ae775fbd9ff79f744ab92defb90b5346c18a07b270db54e18f1dc0d8bbb8a9bdbea8697b2b8f4fe76c94589ffe808be59992a59086c2847930b7028b606a4adebf9acc8437d67e32f443b62aba48e3bb641a963b6e390426a9857fdbd1b0051692e4975986cfba276f1f4d5f730a5c807a7915cac7d8e4ec673a767383c67eb70e08d9a8aafb2ccc0db585d3957d580af409506621756f8b5190925ed91b7163e88dc735bc5e91c2351c049d988b3ebd963e41849ce8f0867d703fec84a291a84c4ff69f45f071a68dec98edac317478f0acf10a69362e21719ecb66815ac761278e6fbaf3224430171c9cb9fbc934b659cc4e6e4fd43b8513d5c6b17432c6e2b4fb1c25f7e1f6c067b98a6850b582a49f2ecb4681704ff1fd126981ad8f477cd4da6b8532e05163f959192347985fab4d75f55e9445bd960efc7adb0c8b160650bf2ac0398b5412ef450fddcbc3736d6cf43d7df4e35ecad4f4b18c913511350a0aec8f093d36c69e6600ec22681af8bfe2bcf0ede1b5aea013ca4f46afc73e862165f2fa64261ea0e2a523ca52c74d6a4ed6eb6d77d009c3e7b661d3219ee30b8d53aba5941e353b24a826424d66f6973c55aa1326a7b85c4f74d7729e77c6b6703606ea974977c7536ee63279a659228943807cf1b2e258bdfe04da81aa0abdfda3270a567701e073b2efed2d2bc04bb8cf32f164df08ef80988a92f21efba6f7161bd5b640f88f260f796e6521c81f655702358ad301cbd7e7b6b6809b1c805c88ddb8d4269532114d3d766cff0cbf8fb98ece04cedd8a3328dc76c9856e5d9a4d967860d1f0ef56d533f4466428c22c7d39ca4332dcec152ea41b1aeeb538ab0253b9ef09d1b49db7c462d9c1dbc563e0fb1dfbdd6b60ffba6aad3e067be80aef428a9a0e93b6558b5bb6917604d1f84a52cabe50eeb3a60615d197888ec971af97cfe7f6691803fbd1b60058d84625f77b97b91de97e2db64fa9426fe6eb5f73c3b60a1092a44f44a99905d8eb981f81422ba65408f96b473372d5530ddfedc20c51d08a8c23be372bbffe52b24398fef726a7868e6b3b259c809bb32863fc6f1611aed8e6ad258693db742cf8d350dfed86a6a0ff39388e7245480f01387a886104b15d88a584e78d10fafd897193392b819cc2855148c19fffe7166b7718cfa83c4ae3736d2eae8a90342c2c8395ce35edd449fd3cf116809d14a8f4074b400a1c443f79a1c5e5039f2b04a39804842f199174d9d760184bd4abe12fdcdcb579b802d1bb7b6f5515fb275996e4454656bea468a2dbf74cb8ec08c018a0bb069a6bca355a93a2e312d522a9050e9e34e6073ade9d700d138cd134f3a03b01bc1eb66811234b4523c40ab4bd68f6ad1e972464fc29df9ad3a1d5d0bbd880ef4adbc56fa591b1e3c34d12487b2e871688001e6a7115b3e10e34e72851e1456c2fe8a1c103a5aa04bc351d0a7caef36f5e7ed221652d6ca49c5ae3a244107873ccdbb09ef85cdf0158910d8957af314ae189142edec2382bc302770ea3bd2e51d280c12eeca91961709606360af0a8b67cc723978f05b38a1a59bb541adee06bdd5f78e9ccab7154fa8766832ef49a8c182d967b57e65ded73befae1384f3946f7f003e560d08fb9ff3977c2ee9262a135fcfed205d8ca9f51439189d5a74709c7a16fb78ff6161482599d640f1b8536e9711c1aa78336e8d7fef03a42ad90b3034f994d5e96e954159e7c133f3e71efefd45b9058a3159d098e4a71368137cf82cbe42fcb5d68ba42050309c424bebc62c81932e28e5562782b9a904427d1daeb920563117e51af031a099ecd33122492cb89e55d2f31aa0dcb757d9c11e4459b278890eb395cc71cb4d1dacff0cc2037a771d485d9f4cfd288f431c3c26057af841a310eff82564349c0fb6a6cb26f2bfbee175d71ef4902d711679faed80015f4aa9dd6bf0124a06e5f5f2a8a2c5adaeb4e1cf8bed1cba91ec2fe1b317a5a3c7920360a2e399e1d7121b95177f08aa430c8e9efaf708d5bac1dc88d4b9e7b85ca71a6f4f023333c7d6733335c3bceed29db07fcaf9b475040d1f8c45a9ec09ae19ae91549a026c6f584ad4b91f541714904152c18a465b02922efe4b4640be870aea42fa714153d719d12ac943d9248b027c7c700b6fa1ddbc9f302463f9bcb1ef54d3cd86a6bc1ee01cc8498e250ab25f0823fc0fc702a79c48d11628f81863736b0940f202d7c841336a266b612b708285c86153ac23e92a76ab160e27f14c3ff5ebada7de127292dafa2f7170969d9a2898a93ac1ddf62de1cc6d2142539ce582c83d2eb2a691c5cc808c5e827cef56ed2920671f25438c7f2654aa23be46ed043f386df32646b7b06a8faa3f298d2b63d7776e665a2defa72ab33e3dd90ed91a2b6e2a18a885c367663bc4b176b98e00a4f15aa9aafb2d1d5b327705292adebdbdef385d378d49a2bc2478cb26548185ffdbe81fd56ff468f7059feb76f11591d70a61e34facb9751ac562d49766185885b817c36f93b47b215480b4e4b912c70503f1b3f96b0ab46608ab112a71bdaa83dbf412238fd9455d09afe4944e61ccf615888ba018a86177ea28eccbd069e5f7b0c076ab65aac9b875efb7ef3c460df96e6cedce7983ad44a5b87d35ab6b9704fdfffbe64013fd536312db36562aee8877c7d96a97b8e0faabb1028c282e488b997c60ce0b9a5825cd0dcab7923b7e9aee57c8cb3a71dbd1efdc3354076bf2ce6abbc5b4eab8c0e7d31fe1138b25cfd92347d89be6e9ee65d789a5186394b8c2de1b7952c428cd26570974dee580286cf8b3d5fd3012212be75800251516468bf12576b189e444a317627d9fcd5f9de369715b4bfa94a14909a333b89dae6c5cae78a91868f31b2ce97979b7808502a55b35463ea2b308319185687893b24770df2ea660f00583157eed7106396a83201b57629a9eca8d477e2bb0e2d8c9a537536465b3e58c431c7bbee69b54457ba8977a599916cdd5ee722bfbcadaf193b03b877621b42c8d99b814f122ab8434a20855959ebf4900c7158f4c7916d9807968573e46d5cc324f3c31596587e49523597e2fe636aa522a9bee9204b8e6552ff301a9c4f1601ccc4d65c888d8313dc33dcba8a8da277fa729b7b000d57d3a29eea8426784ec66d8e5ba623139eebb2b3bd9df9320b13a605fc24bd6fda8a0ed3584446623f9881c9154108e8bcbda08c4d20be650cfe812a9d1bb7974ac650f62b01b622fdd6f28e5ecd8284467b3707094b6c38122c9b8b34b9a7f92fb4bd53e4fff105b6290f6d6da9c76aeb19dec09cbb390a2a5be39426cb7a66c946876a88cbf2b6087ab7f20322a87c86cbb476da31f027aeb674666dc5019229bb4c2a423d274b00a501c5b067f2e9bf41a36b890f210f944b96b15077937a0d252f6ae7e4424631051e3dc0b3991feddd61fbafce43ca279731a2a656261f301a9203158aac3821dd0a97b29031b905439364370a694f4539dca125a6f762e05efb9867cf25d8caa83ed2d405fc986409eea0cbcf6dec648e8247c7c6c663c3568d1a8077ea558bf7e77e5b5a7c334e64abea8f77b6cf2504aaeb0e538413397877cbcc51dd4b40e9fd00f1d9c8a370e813b5a767566d26eb9f18fa8dff649f6ce339be76aadebb267809bb885ef63c08d48d9cd795e5c4b750b78a8e30032b83ca2c4f7142509ae1d6b353f89c5b67ab1553bd3d96ec54c6cc50fca0316698e8fcdae4aa7733cef573531f95ad0333c6cb27e90becbb569aa57626afd4ef9db109266b2e975a67aa2eb1e95e8983a8449ced61acd7dbbf42effc72e12b69931eccbb3c907d066f64c1d825a4ea147f8ce9568cb805c1f968f57371fc724faa0a492b70b923cfaf5326392e713609b757f97b31d06a76d566fa9f41828a071d39f9e9db6b7c17ea4675343ec92e597ae0bb777b05f3693bc10183b629bd7e3f2d0cd1c0e4532fcae9f21b8f7db6e5653f440e272faa22665300ef5f5c89dca328901e7b80862db00814de6aa742c020f77d0d67f51401e402cb8696d76dd6a91222fca8654ceb4198040c440458f067a0ac233875e3a48e890322012c805c2312c20d952700c116e60232885e83b26ecf736dcf9b523eabb50e5e4827cbdee7bc47757a2559e8adeb4a86e863cb6d42c07b344aca37d6050215ffbb85bbfdd866779b311c1431a2a9606b53fa16840e659af1a6671fda2c4c7cf9c5090b104e1a3453cadc7dacd5d3d9850d266ab083b84cec817d422b224b27943825910a029916417725ee0a24a655f398ca3ebbb1fd18a11b95c76d99b9acdf6236cbe6396f4ec35a41e0041a678f7ac745e949ee552f45caae716a2eb83a407dcd933096e67c65746040d625b2108b3dae602f8ee8096d02c9f719b70120fe7899b40952c7205c07ccd3e39e4ba9685167c05f8a4a89b676995616aa4c4d97d28c5ab41347ac6b36f08d746f06f1039baf01521832802662ae36f6fd2c1503da3707f80ef39f36cdf5c0838f8b131cde615bba63cd90226a32ef81063993446ea7e7cef99b19ad83c8ea19c9e98a98cf1747c1cf37f7e8a106d1de07995845a8af8e6529b4b22f372f6b07ca38a1ebf9ada55dfb33c49064ca2022bf67680507386e6e402a66336012cc462cdcd31342d82f958b0a274d7d6d2bfa76e675babc31caa49ebd0794c3ff5a11f841a4936cfac20bc02121535e0c5183d357a859f28eaf8265e83869b22cbc60c3293d2255442e2fb892277c1cab4fb98bd207a6fd1b741612e4c917270419052e557e46ef4e02a018d5a9c387029","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
