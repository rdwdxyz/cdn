<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dfe26e4b329fc58eef43b55be912873bea668ea12fc3d7dac98c28aa2b082e83e1f27cf17746484d63e4a62d03a3e2d66f848670e6c890e594d38b63ebde05e6726f9992f65c0430d4a1cc0a6f7b3a09e655a06578037f71a935848d84941f3fb64bff76dd52159ff659dceb9c4aebaa45648b76748f110c801b9e2e3cd47295bde643d191f8b04f72bf0ba7ded8dd984f985fbdd7dc688930cbbdef8ed72d12f025b76d80c0f078331334eb27329ca967053fa6c131c88c43a438a6e7ad91b0bd322a02be52fcfa3a730a16176395e6223995d4d4b16395e853223de4c493319ffb5856153661f2f4b3d64ef04fefb66b20e7a5bcf137af3b2f374a4cefed696dab2add67c22568b46adc3cd40ca146a4e1375a655d7098bb85200b3008a8a5103946ea85bfb18a1b057bc6d4ef24eef400125e2b55f633779fd45873d499b4f15d3118fc9eeb49edcc855b35ef8b8ecc4f222d4523ff3ecccb1fcc2fe4a22980f1a8d4d12c2d5c5184e11e49a6dda8fbee3d51df7fef1cbd283a1f78377c991c7d935717597df8157ec2934d50ce657a69e5278b456016f5f69a6034cfed3ae0188adccddfdce9847efbaa5725b7ea175c67d22f26c48b731818e66d34b48caf6721eb343f3851ccffff8ab93b5e04fc84dac8cd6e7bf14b2b8d9c03626f67c7c625f7f7da48330be2e0ddd80d0f17add82283023a1846cb5968fb5c4121d2400c106868462705ab8aada0cbc7c8fd4174049dfd0d341bc89d117bc067fc057ed37f13403e4e9e0ab37e8a18a611e5f8d48731e81ed2c0baa0cf92c5ee70ff66645cb72bfa0849d0a5692007c6d5afe062b97766be194977a64cd938e5c187071124530dffb0e690dcddad392599f809993195b7b7ffdc793cc5fa87ab87498ceaa362b880aba7f44965f1e7a382daf8c8c6704f46f30133be10f366340ad3a3a34291e34681bf31f1da7bc4a86412199e23a223b52608a790a2efc7c1ab022f002f9869a2ebce823b3cafa2e8a5342446afb1de8d580d6884fcbd99699df5bbef43f86fad1b28c868242d3ef4cc29ae1d7e33cff09839fb3083c99011d359beb4e6230d847a20826478faf460504dabbf0a2e1b0cd7deda806d52354ba4d7737eadc0529c79225cf0db02e48c3d740329c56e5a31535d3c437c29c5a0bbf3813ce1284ca27426587c118dbdcf4b65d56f37453e32d337472626bfa2b9712df7e395e6d58207c25a7bb28fc1f06d02d82404267a5096695d344dd54d8d484aebd1108373261ec36a40053e832e1abb2002bc3e29e410d78868f858688055a491a61bcfcb77cb1f36f4ec69f485a1fabbaec40c039ddbb741e3f616d7f9816c501c865f5ce0cf59f2613bf80d85acd8698d791719181e7dd6485c5c63dbbba0e8484522ebb3786b763cccfe41d9fb4c3671c2c73b4858e84f55f60ce4821515fd232845f99bb6b0cdf8bfa39c0fca4872bc0edc89b88a1f2f7a08fbafe33fc7afd8f673a7556d75e385a3e35683f91ad65bdff15b03a47157baeec7541c54be2c56b00977d7df85c79f5b4b650359523f6c05171057ddbe52216cb816e49b0e36e4e7b1b979c30a9b22176f184283385c31d5034a03abf76de950f7085ef3557dd06d2178fab293817ef5596a4f41783e8c92fe95b7f94dd451faa60994e4143a8261ceb19e839b4f6803d3171ad87ed9a7239d9ec86a5c677e9bed4435602eb492658efaa02540d75739e92904493a95c9449786ab29bb985a4e1607ac4efdc4d896bad06c04e23ddd6c2f97ef2f74021ff56d502f6079a6ca6eea1508644beec848f111ab04d737a02deeaba8d6edf713dc0d165751fa6ba37465aa8c0d47dd02f38c93707a7af1a9567afb88e59580f92dc4850b619fa2bc9e24afd26a26317cff2f049f4b01da4632be3648a49bccccdd5a8217d6fe0f53646128724cd38f4f742baab498bcb50468ed38c2e3af9c9564b52e70b05613ffbdbe0fd1ab379cdff8cc5c6c4bd5e10e68e5db477c2209c7e45a7d35a2660185e4aa9c5ca97c7149ce5f27e847fb7f22cea3f9ea2567ed412ef99236de04881f58858392b29d4ce7ef85c09e7d4cdc9e317fed818d08141e87bbc1fcedc4c16ccc2c88e9d4ad243aff1dc6cb0d323dd47d79f258edbf9ba37439244d1298a786ff53f9afa6af6b25c3a322b14edad0fceaebb9d52a0540e4a0148a95c702a9869ef9e4fbe9bbd4c3c3c5cfafd65a50e742994322eb1cd4258ff27da3154c140ab35d11fef0432c3534a71e86b0249f39b8856caf731e173eb93570f030958200a02f7d08817458f3d37906f1164309c8d22017aac9d01ff82a013defc6ddf6698ecdc9f3195c703ac1e59b0672ffe369ab6bab1f1837f5e9241e7466e590f14ab10a1b056f3e2f95565330ea69bbfedb1ad48f26f7bcf66f3dbcd34d4a96bc0e5dd55ca7a1d450b5532dcf6aaa04992ad3bea506ebe4f5041f57c171c0a9eeec8488f1b51e2bf1bc1a0c5321bb69c165addb2f1b587716b082e39f48856ea575d8e31884aeaabadb4183c99f17fe8d4f47edd29b1e5537262bf5121f5f8174d602a7a0a51986897c8802e3fff3dbeb0fabecfcb673bb8559ba93a3f3fc92998356ac9f49470b47539476e428b07397c131408d28f03262a5ab6dbf7bae2e4cfede9c229b58aca5931089567c098d2c972510217630f1abe8de9b5fefd79db12544b26443f0ecc91dbe249a7b1cb8e14c08ecd2c3f8288f6c1a48238a8acee8349dc48ef38191ced86e25ddf1eade267de34be4b42a04fbdebe128384f2996dfd532df85dae29595637a66f446ba1cd685fef773ff0d67da774a4a008327697114165cc4c28e7f8fa06a44c423e321a0581182d469dd4c6544c53e21796a5e128f7eac2808eb4826093863d1bff97b88c485ecaff41f59d9e12ceae5294adaec1491ab7ba8403f47272250092fe2ddde59a21ae2b8f3431318c4d62651c8fb913673592839a44c80c2358311e2270e3e771657a319a7f2adcf730ae568c6e09967468be42f9124cf2c3bff121edcf9563bbd8bf6c96bf32f4d7552c758b28d0304498a745c31d6168a18e7a29529a189e479c2c6f9bb2971a83300c22c64ee598d78a38a56460a1fbe6c81ef5294fa570003541a82bb4b8f75ff1a74caeb32121c1390e73e0d52ee4e9c4e202dac806436f1af18d9ed260dce13ce3d818c65ad2315585efaf1d50194f723de95dcd5cb28f357681a0778aaa67c33706775c9ab60e047528e2d884de64160d24c678c755946abc29ea896c3eaf04370515e840420018ca0cd0035b35a04f98e96b433df047196e685e93fd317205917324e1df2f5342cd780b6c9b801cf5f6e1ba9350dcb9626b8e6f572f95d0bb980228bd94803d9cf685c6ed4555c246d1de5e722bae5179855cbc3e8ff03b633cdfe22201a25447ae7222aa00973c8ad4bb9e09ff9933dd5d4558805bcc967ab2965a33573ba999701c9f50337c03239f54b5598e283b0e2d778f5a5dbb9fca3668fd8e4d727d99a38b9895e2109e23f3771175d7c4aae3af3fcb4503ecec7b7be09a59f00c6685a573108b56364294083bf8d0f124d357eca6203328a6a9c6a8ebc3fdf985ce02bb9e5ec602400f769c230986fbe264048055e0283ffbc068fea366c6e5f7b95b7e343a18be782de8e5ab4ff08de2d90782f27557bdb0d850dda95b1dce5a610c1314a37e5b1cdcac28f9c4a814ef7d7c576fcb1ccd7bea1a7516aa13f1d26c9175ef4c964e32cb85fec9a8fc1a4b7c6bdc40685e73320eb38ad46f4994f1df05fac4347f82e3187e86e7f427cae79e4af2fe3b88901f9950851e0517401cb4697639ea76f50eb03b1ea4b52f07f3527e518ae95191fb4318a8f578195d20dab917139b5c393fb1f1c9b9f393817a74fb72bf29c5c1e9dd89ac349564b2425b012a1a3f3dbcc055ed696ba0d1ccdf577a0869efc42635748598da3e37ee5259ff886cf084105bf73d69bcf1cb4177b8b8e5d22b29ea4944a2b21d70768caef040a0c8c1bc64446c96a86b25e785c7fba5c1c303a5ab4cf19ac9d37debd0629be7b04889e266abac03aa5ee689a5d545d802bf543f3de3fa6d39c6d26cfe57be6f5814f36f34a84f8a0bf2676a877e05988b136bf116352f0af2b4d737963f324ec0ce33fa2e0f80132e2fd26a649ab00e376a6c631428e8c0b401a761d55a7811a6475c0e5a38b261310f22c5996cd06eecc651ba3aa66ab446c7842b0c933dba83f7b0a087f5e385dac496ff00b046b74f9645dca96ef8dd29ae1f7e156cab579a4e05cfcaa0d939d964800c2a4100e224e822343617e5a5d22fe5962701b1d88aed56cf2346ae5fea371f553c2a7eaf4520176d8024a697a5b2ff8bf9aec291675d14f3954b60ff942fc703764405c62d822e94489d880c1a4e5a9dceb25fab60baab5c6f0aba25b4135ca8725549be2b30c233b26edf1600d855f8a2e0f19e98535d9c6f9cf8c9cdd1d1c6e6142080deb648f40d0bead8f39c18d5dfaac5724f0e01e9250e5d4f39540ef827579580cce1dff2ac78edfd65127f1b5adc967dc2ddb783b0b545660875123fdda5bcb1a816bf1ea05b7f4f2119355b2afa4d9a5c355cfda833254e9b120a0e4e37091bdf688e7328b5ea400fefcc43e2d0663fc88da93a5857aeacd82525dc621de4fe0130513c3f072857d373294c11d55d6b017a9bbba307919c99f5e646d8349af85cb351f9f38a6a68a2839264a9dc1691618a0678ef7ce67e36c4097035e1270bdf16dd61387647d7baf9827e620844c5754dbb9c9e70c5c667179ebac809fd8e82198f62aa41a894b01a5cfc057cccd4ee953aacdfe1646cf6fd5120fad492f722a665dc335f84155d362b3f191e31bd4390b3ed154891e4bb8b58063ed8465ec9965ac54860bd035a0d4877c75bbbf118cc01a1acfc4fc617359147ccc537b9fc6cf2d5c006e9c64b161100128d210f1d2808d20bb5aa39a78ced4229f2f53f748a52f72bdeebe1459adf918024ae03a3aea18ec636431df831f76f529b05404e702453b20254f75956e42e8bc626e8b2bf1d1cb4af262890ebe78c6ba42e1283cfe21a33c9f9444354ae1829a995bacbb28ef8ef1f3c617a807b3ee7fabc17b76cc8478ac1bdd49fd2962dadb8d1cabd513ed7f9fd7e538ac38f9eaadd3df615a6252196b0a9c9b5df5bf95bbf73a5ac75964e2f601cb7e6e1a1f34fc337a83f09b034de41ac061ea1abb28fdd94597958d65b547d2480c9c403f20e51f899e6c5cd4880c4d7a2dc0322a4e2275912b647630b58f3219605a384faf8c4133198db46f9a3b9d1f421cf17bea2cde4bf48831da60e09c8302b9f7fff4cb34b01f85ab2a94d64f402eaadbbfdd0c34a5af389f600c72ad8727023651aaef0562289c92123237d9dd944eed5b1513c473a0718439530c318758c0caa74315a70f622a02564b3848556d67cb6faf3583eb868930664904ec8f42069c660220142fd771eb4410a9f2e1c4c2af85774fe12cbea59fbe8921caa13ce59c0164e748fcaae18b01e5ad0156863a28558818c99197d3720abdd285b7779daa30ac80a3925c8aee6427ef1e2a721ad6194fe234dad8a53a45be506a27f4c548b77d399b311ec7ad1273afe84f4994853488d1e65cd55d2bcde3e54b3ed9e7a2d16bc4c580a97b8a75d994bc603f6fda2578f9a7bda5cb0404afcc65585c5ad1f661f44508eafc438e48bcccbb0b67d32ad29ed03e2e51f3604d7a45b2a03dcdc372713277959102022cf5076940331e81e80c78517815e62bd8fce102cd81f99a93f9fff98e3e8acb087fd9b2663b8bfb8469d7bf908c25910b6ccc5bc0bb543663b9ecdee5219ae4f63e1b373bcf40cef6c9bbfafd348a315a7de73d93f94cb441e2158ef1388edd3074f8d85811340442411619890ff7beca504d3f3ab45170d7109f1e56919fc5bd0161ce182f5a6f3a46362edd4d6387721cb6ce8baf4d7605f2d6a6435718093585b4736644ce253fdf0c897ac5b2b411019f329040e9d74dacc203df5756980694d280f21bcd41bb27ac0c964b8b95a908f69363953a901a9445a8c1aadbf69cdfbb672f00816edfb93156381e9e6db79b92316c85dd97b903d068553356a2a55421ed7ffb739818abfcfe09644ebd46c6dabb4a90633a606c2088e6e7108ad1fe597417d1c90a39532827694a76052375a0bb09570b3962fa437f2ab707b9cadcdffcdb316211cac676a842c856a9fd30b20158408422b25607c99e23ac865b05d366dd2ebdf48116d97c66a55c741d30ca7db26f9b8fe2b38b180d390743d872ed822806ea9962e56c117b862b763f1264ba614927c6edef7c68c7dc4102545d11b102ff29b894321183872397b8affa5747b3a152c0d169c9549b94b0d956fef751c1ede6548e263d95c832cc14161d76efa29be588a32598a0666ff4ac96b2709dc9f6987b2c39159ea7a04fb20df74fb0c72f58980ce34b35cc43903a741cf89b77ea700cef039edcceb3bf149669f7ba9cf0ecb385ee8d3090f94ef68ac3c4a883a8bc4e624125952bbb32e389313cfc175e69a53631f7757f5c1766aa2d390fd3aca2f26986ae95e0b3e6023c246ba829f096431a615eb67c70e96ab556518d95278e2827e080b78317778b3b643c5eeb6c98a628ed67c7c4d75edbef4fbb379b6e3cc530191e36091290b72f305188969eb4fa49725cfbc154670a5bc3b4a898bf2095a44bc3a61bbf9f938252d9ee8d82ad68caa4d6c8ac9ab473a6b71896b6c59aa67bbe6d2fc3c9439ef601b357d4ed0ffbcf8b487bd9fc12d98f2d246763d0b787e590a8319b09f3f642cf31974e5f7da93888ca05b04ce1161545e33e2a8c86e90d03d1d2a8daab2950ca5c9144bdec1db990e0e17117e2875d6b8e98b4474f990a71ce5ca7bec485694941c288238982049f9dabf791f1672a7cb3d6120771bb2b029e8300863b4226d5282079842e22c0ffa2658897a803cce4c44c1184816e68fcae75e1ef892f48b204dd3e5634776e9c76cacd929a171fe9b08aa7587e280527bbc1177d6ebaf02614dfab6fd6ffba0bd157f37d339351c3a61ebda03739c87c10288357c1bee9ba718d1bf93d8b080a5b81de592ae994f5d45f3c14cb61730daff797e52dc2af0935b1099dbb78d815d6cc482f53af38c086e2d648925dbb4fb531e377429403e7671cf32bdd71f4d4b8279206795b4c185b7d92bb7176918e98abb1a87a951cbee053a3febb96e1eb6acd24494b7f12ec0dcd9ba786b23739130ed593de826178c64eb3f54d6971d55f794451a32b8e11655476ad005137125f3b4c3fd2fdb13956bdaa22e1e8726d778661311adec15d2a5aac22cb6460bf5ae941aff24a050735d34ac007136a3f75a4dcb00f3e0b354f72701746eec129401fcadcd6d7745968714d82125d4d871afb5cbe39e2ab50793bb167ae7ab5e2541b3f8fa3585b908d05f5ec93eefb6dabc78c27dbe91ea583b9ca214c847ea3bc1122aca08ff2c3b9cc265af5a95b0688537c73fc952c37b8ec56dceddb7aa593b3204af79f3b84398e6ac829f377ef037e9a4b65aa9a02c8ccba9c43ec5c9ce4f6d261ee2ae336484c56debad797cdf5bc5c6a2fac9fff7b06443ea9f9d520d13fbb64437522cbe034f8cbd97534f968e9cb6d2f6f0534737343927e4ee557b25db1260db226b3d6e1d08b2a142c3d303d9ce24a8a7601c8c4553f55e8a3462ed7875c10d7445c1cc7a5ccb19f733f4d26e433a1638cb3d73d0bab20e96587c0e0bfab171d25227e62325fb8124496a8f62fa41a9eadb8dd128912535019eba105fd9ec13b0da5b36ad2fac3ce9471f374d29e12db30e8f8c77da72e95fb9402908d59db6e04822863b83f7038fa216d1a60e374b3f450ae7052cec0a5069426876ce6f8c89359347467fbdb3f97a47a90fa2af982c402152d1660609170befea08bce9a069535fb21a7db1945d780020f55cebc61602bacc752f3c11fe005bfd15a702cf088b37ad3fc0a8256e12b55cc464baadbb92f67c445d65e2289197661e9888d81dcf323b15a6b56e8a24f2bda459bd529e1f8d564faa678318dbd8737a83fd23f946af98115296a1efc8304a1b93af78f72176d5ca75c5a65d64fcfb6499db9a8fbd614f983c23c74ec06ddfc853eec7286dc7ea90d84ef987a51634a255c8333f03d61fd38bffa57965bb346d0f8fa412fc83885ff92489af76701c018791c2aa52feb329f40d5b30fe75713b6d67122b37b647e4bee656d323f63fc991a960675923003b05878dc7e2dc7c570f9a33f20fdd771fbdcd24ec487379168150e9d4cc8a3eb0b0a6a58ed4ffd3108e60109063730c382d361adc454799d47b8cec5fe1602eceee31a5da058d0ef0826e1490eaf40b29dde512ffcb132007c8baa38cbe25ad40a0ca8434817418eff59fe8fdefd91564450de8cec652360e320a4f155a822d72e2f0bc26e08636158c4c5bf4b16adabc4a452c82fa24f2a3b8f79bf75cfb50b29bcf7386e5d04d77dbf22f51c77eed42ba63203c28f2fc94e75a9f303298197da2eb0236cc0239d088afc48bee166d6c6fa14a65503657bbc0fa18c98ae016bd046a9353788b729e4526c196dd2e7785753e3e349d0cb295cb93f7f12e85e214cd9df47321b0b5fcbce985573867e113b0c2810ee1bedf2e29d56fa31a177eaf2d533c3f29544bd5b88698138881e8f53b10262e0ed961104529498c4db8d2806c1ce7ba6f0148d8f67e08e90621ca4a6ea4847013422883799568251ca31ab99a5eb2addd40302ce7add0c15b1a86247a8062ca33c2d608c9fa6e6bd68937a99672be72ddd89fa2e6560184f929f7c1ceae60ac09a2fd16590e2d321e43e21072dee762631534290f8851d085759dee545e75caf8f612393d918ebb2fa2f47b2de00c289e471fff5cc2cb5a06c872439a691c4b82f19c0dbb0d78bfd0a4313a8d805969dfed20488049698f7b1dca9741798f28c3f8f2e3d9fe68447fe73308ece912c6f3ad4cd75196c95cd3aa37502a654952fd4f43d3be9d2446c946a93be6f8972b1c6ca1b77e37f7f925251f7292aecd7d1ec5ea2549ccb91f896575dd07f330b1a84268a7876bf230e9833913fdc0ad197c988fd1e7a4eb17a95bd4982aabf7908ae3258e33e623b1a3eb5b20fb477fca6c8ee1099273a7944e4b8aa8169669178dede20eccda5737ffc272974b34f6797ac8ba322cc146e102dae3d9183359c1227c578d4f44f9366957a95f78cafc4cf153d3eab0b4bbcb3e0b648e2462775bf587bcc52f2cef8cbbc6752688208f6f19e74ce52effdfd653ed05ae01d0f4ecd2c99684177ac6c75f323bc9022d4a40c97cc7ceb0385870abd51c28d7a3f991c7141e14a2da3058bac313b7b328afd7d4c555fa8db628d1d1ecbd0584b04cc39bd6ce325a55c5be204124dfc23f4b0e5715a5eb08c181ed787b06406398fe575fc45c99f1dce0cc9407609841552a8d04f0b01527927b9bc8645cc6623bd59d73bf739df739a9fe82303ffc4cf99dc746fde4e132232b1e3323939509f0dfd4c968a67e247331982ee0101adf5981db09cb3e224fe8870f6cb3e7ebeb3717eccfce3fd546744a5ebcc23088aeec525e2266da9369d73f52e5d3334dddf6489e58509384416721ec2b4da178c1ba126b6f706bc50c3e9d5d5e5ffd8c33fe310ee74f094ab2c3bd87573c0f32909bfa24298313b93655f2346e4eae55f6c8ebd169a99b7473df644460a721c66fb0990932422e63858abb5b39e9c50a8fba6e676ad89b4682cff73d5fef203e4dd861d00d648375c91ebfed2bf0e9c340ffff55f026c3b42ccb35205632be73396a3a45baa3902f806a41c8f6a7b618b0800b429635ba6ee8bc4622568457f6e583d2906c009865bd479e236e7bbfb2379ebf50ad489ff6e6bc5f2334dfeeec7b11a74709caef71fffacdafbb4938c88d67273314ecec032105eade5e6e491b132d0d8ab65a29e9a42b396dcecb70b184393a746acd2a414aa7c8624a1aea465395fb61421701624d4c7c0709de447be8a7403c2610a0e0a3bdc057d0855a4ed2d57b86175d22425833480e12db8d0700529eec320cc93b2c2c77686205947d5b507e768d94374b478176cb200abeec78f0b8fcc0542fe19c050cf661c7df4e5ce6e8b30190106ec992aef98774f049d36fa56312720bb270efa33f2c76b4b1d0d8fed88dee662d81cbadeea760f7789a5dc20e444312ed2b45784da149c03edd6c06b0ae04f731ac2fd9391fd029863b7330f83f965b870888a5ea2480765f54d56a7771dc4892fa72ef57dc803a0b4630b633f65304dbbc639122f88c380f9037ebb45985b23921e15c87e05956ac2d6809979bad567e6ef30dd7526e86011c08ec5aa4569b32d6682a606a997f6225a411d36f3b402217c73bf28a88a83d43b8af2267e3d9081599d844972c394ccb2add6fb98af92bc7d015457c54ac919a343895439112215c9aaaadb6947ba8a2437f18cef1ec8ff373681a22bf9648252737fe32b1eb5e1314b8f6daccf87cd23f7941c2cbe758c2001c3de2859a629840e3a82f5f53308dae21130a0a6241fbd5ebfa40f08d95336154d52bc6da82574ceab2ca2f70a6b4e8cfd1e4a2cb06577d4b88207e9f6a8a7b8f71bce5ac62ae2213f365fe132f13fb22289cadaec511a667a209525fec84a9b0a6ff2718582d37ce7e58d30dec3f03559f95bf42425abdf6e0a0bcba7927d4fdb9653844e06495b88769301029cff8d83e0ddaf3130fac8a9435a162aeb25d294305360648bab047f0e73fc2df5ddf2580816473bac6bf258d511347b8ce4b73d7a2e63bda7f5dd3248a834a5107b336f84464fabef8b6c272fec3757156c8a36cd87aa6027f1c1ea524c007f5390c74bf2d32fb665f1328ea5f04217da3159090af1f1b34fdd6caeddf3467cced10c97365aa16394c2d2f359bb018103cce60f7c29e00de98990432a14ca0062555f51438e2ea122f9dfbd627b818ef8eb40b846801aae1c4d1c8944ffa6cac05263ae1fb1eb56427b0b97e834e0e54f164f62dd4ffbb0a03eb244751a8077745ba1645d35c82674f411acdb04401f8d3ede55c1190339158b569ea880c9a5ccde0616cff9b0aefcda01a0d15a63b18e5a4c006b85f951c3da0469fc1f0234bf351fe49950d2d52adefbc3a1e81b88aeca723701241610389ebf05d2542376fe52c42ed89e5fc8fb6b5d449accfacbbf83c9e2bd1e505aa0303d65b9506aca285846d259c4398ea0efceaa9838310633edded822dc0b521bb654cd78199ca9b096cefd1b88a24f07c857019a468b5c608408d858d41d28f832e96703459eca17f85630fc08ab80222dda3e280aadcb8aca2f866bad8a273a028c639a6b4a3790bc74d900b2dc4a29f41468896e44ebcf2e10863c892043f14b6ad323002501274ef3ee4f54ef7b88b91581bf4fb3bb8da02483846ef4ece546e26cb7e0192b88ad03fc882ba04d55cf56aa0285ca9c1a3cc1799cde03171ee33f7476a0251afcce0826df2e381b2fa672f8d099eb267fe54fe8d1eea1d2505732a6012c3f6bac551d5e0ad49bd1578b08e2f4ccb0d96c3a5c83288e07b1cc9d34e4efda505c549f8d4aca0ad6c3afdea2cbbfccd262548d96d23b145ab59d4acaa95ccce3091a2395ac7d41ea6f8b808fcaba5e05e84f7b3d7db3d3478338d0f3e5b5718775ddb0cde8da0d951d5e8d502c967abcf74faf1b2d13be9e46b5babf58c11cd3f104a373cc86d267b0a28a91552622b4fa167a0c709c625dd86afcaa2a9d258143bca793d99f97dd2a2a1fbe72ca984aada03b43bf54b09a6e7eb6375e55f5ddb8f8f6db8ab2b106873df1a6b4fa4138f5e8fc4487e85bf71678153348dcc88ce7ccb88b719063fd960151298b6e20432d012b93786c2d68639c10384745156eea5207a9affb2bf423d75b0ba8d766da6842e7b072fd2a54031c1272d22f3da4bbefa77a9e0014f9727b354901c6902f90e321d7d2929d237956d76549d4ef677156620c26ceee60f12b4ac03ed9bca77efdccd74287217ab3c3a052ad65abe56c98e00ee91d439fdd76125e6c129bf29bc5625ecb5a8ece6da6034a08aa8591356b0a1a219440608cce17c146343c6d872f37a1d6f9e1c8c346401c92a78a1e7275adfa7e0ca5c6e0a0a847f1e000aaf2406d79161b0d17b40eb745c58ddca7bbb01a8e4f6fbfc2690eb75dd0df933010cd13ec29a822ab6e26e5592a0e01a77dacc4a013b9f68c09b7714c9b08a162e5b4b48cb056945f14fa53825f2e51f1a1c5d9a636a69692deb9762e536d8d80f2bf765d2e3f310f3e6ccd75bbe77d1973732c78d7d93b61e7b312a9440054f5a456e0705fbd268cb7be4e32eff7c88a75e0091c307d795d56f7eb84bcd394a4910e01127656ec0dcaf4dfde4cedc8b74a922fa3e226ec8a4e26080c9a81c99b48aab42b30af1c72100e1a389b4a2ccd5b9dc2601b53f82d2e30424926d3bb14fc23f7a8d1892b1b12d0533efb49b4530401aeea4f35e66794d91ec807baa72f3766815b15c3d91fe4510921be302cfe87c5145c32d954f80e8470a80d7b66fdd0ed95d9394ed2a381a5f135237379e59872dfb8b599d925bb39f7edd5e4a25e384ad01f65e07e76b272e069ea789f63f326e9592d52bc504ccbaf26b9646ee72e96940708e174a61c101e6baa8513dbf4cc7293af54816c8e6b50604b17b24b3dcb1326050122de67966cacf09c0517dad7740a3db6051638975606299efe6836fdd7b07215340601c76801197482fc0eb737829860cb8dddb755e221d351e788fd2a9b1b7c9c0ca60e18675690174bed8c87ee66e8bcd8e3c9e63d50805786ad807629be975d9b5012f2796a57e8bdd16b8f35f3ee4f267091c44feef9d69ab68c30f6cb294e9e4cc9e704e62c2e5126f99f4cfe9230f9d1287496c8b1b6972a02568647f9e30033a2f45b85ee06e594029863fa281fc74428d6494d67102aa63e53d7f86cdacec763dfa79332ddce0c78b0d7af785a36dd851abee2c7bb936490a13746abbc8e81f00cc70031bc81b1d649fec70d7b320e545a4b265d7f071c32133ffaec65c956783dcc397cb541b193e45e63b03482a08d5a4e4246b442d6126ccb6422e8542a3f6cb9cef1488f0ebc63a25e54f8dcece210f92192c268bf566af9a3117a50a2dd2125e99753cb5feec5516473da7c3471c4a55344bae593d5ce7ff3aee8007a786da1b4db70d16272a9c64774031a8622f0b5089f9e91b8647f626c70a6a9c688f6ada9020e66ae319ef476f3f9a6df4a223af95b0cc2f91abf03009fbc7f1c2479f419a91c0bdaba8bd2e297727070d407527b571ea1ae656d923d2404498b2fccd14bad98d0de7a7b09e1e354947ec20cf50c1cf2002c56788bbd2ca619d3a93112c43d964efbcdc30e795058471f5a21cb5e69d3eab192201d6fad4fa5e3d816f2ac88b743f1b73fb3f91dd4d7d6c55939d422cb8fa1f7aa9f59441450bbf76f71a0ccf8369e01bf185d5a7dc50f77172c4863a34be49e0ed478a0ef01584ab4ba6a4ee2af57377c6595b3c2c5478957681d64c1d1a0bed557582916af66c4314248f3b5dc2063727c4f3e41efa3d6a368a44f826490ae7699ff0075a4bf95c685fd1dffa59feb44afada414d35c8908bfb090ff81f30e86b98d048f3c6b5da8e9f618bde8080a24b433e482edd19997c7f24ade93994d592b45c40fdb36fccce00a0e9bdd2f376b84bdc0b9665ab26d134a6396525fdad2d7244be4811b3ccabbbe120c4167aa31437c04a5cf5996493ecc4ec6b1fc1cbe451c67b9216c89e74e78c9795bd70d076e6858d5a35a2de22bf73f480091c551375d040690c1b7d21db01da96a3c1ca9788dd95c25bfdce43fb1ad428d1c2fc3dd7dfbc0c1b12ae40c13db737510d4230a29e29546b37675fb0d39d65ea3face479ba0283eb1cc2c13f74d486cf5eef3c0bacfd2994ce92874b44fa296a7d690376f8c7b5fcaf7578c752f226b81fd788f4d45e15c6ad9be0ee1fa95b26e35c40febc28596fefab6d6c4e37e8767b5159d279a64ace8377850a1b4c0be3ee9c3ecbdebe52984d14fdef06c3d30da39430208284627e1b661bda1291afba49c1cb98b5132d5a5968336ceb5e7150cc5c01847db584675bfe3d5de01895ea630dd76354aafdeafc0c2fd5f32cb96f3c105bec86787541c0c694ab9412f724fd6fba17c582e6ce1d05c3f67dd5810dee0c118b2b258cf9154f404e782a960b453b6c71caaf59d2fa2e6bcd3a493504a14161bed81c0400453f38168c9d826c2b619727011341964a9b432f688fffdc39f01517f26f0ea9c1af9656363b948c91a42534cd4f9a80ffe3c47e483d4fc92b19c2beb580070b56b0b9b4429e59a4a55bc070e7dc3a28618a7eec8aedff377c25b722bd33218e8acec2c53a222649a86f437a7e6b7acb434a10b8369e226b8f3b2cf80e1048dfc3cc9abb0aeaaef061dccfa40d5a1a7edafdf056c22ec85902691fad7f55dd1d3c4be66634f938051096916f9e45a31b015a7b5a2b856a35c0855a08c487d00be98600ed2c624ebfed486ba88ce95d9e1ee5909ae8049bafb0018680b2c7f36d0572098812dcb7f4f1e92d3a6d33ebee85f59fd015888d00adf66234a0aef89cbfe7c7f88f6a714537f0d4a900dd36c8d6cd440d4e53473c097980e6fbbe99d6f675e0cccd5108e3d89f985202ba859e31bb3b96ab0b075bf62411d5f23a18869a4957714da0026c911a1ec4d68764eac80177c369ed73f3b7dcae2455a80668c719e6845b977f122aa8d6489259269a53420e15a11c0338845041da9daa8ac7ce025a54cbd1e2e8f609f0842db4557f358c83d8a2572d39c0470775a3e21d3f79dcfbae6389789c1558aa85f36a7e6eeee147269f6bae0b7ee551eac08ad3ffb8d0072544516f87289baae400e445211f615cf084dd939a025683a9dc6490518df4562d8cef7c400277094df186b2a32214d778d530cc4dbec0216e58d86596b446ea95015f211c4c7aba5644d7be5ee480b45316cbc6e84af36cdf96ea39b291af24b0b75924bdddbad0c560a738ec03c40176d4adcda602ab89b5a63035660c99a070251b9100aa70f3bc8bcc55d7a8f9d65b4e781418ccabdd62499ac5984273c3bd7dc1e158865effb49d6888dd785e2cd157178d766434d2e1f39f753c4f6b42fc1976dac508f287c740d70444e5e70140dbfa581d461fbaf75307549d78691b7b84ccb75967e90fe833c6ea440cfa1476f259165b4a94cf342cecf75840ffd76a1752f1c46850d446b45e94c32d521ebeadf10d17036854d9fa612625f38fdf322093e9a2f5de486323295fba638fa9f99b4315f7f9065e76fa2507e56673b559bcca54abc3e3718a8c40ac336dca86af74fc062da47b9db7d8357e255bf2341205f7e4da0b61a1a90a39ddbfe8de3b2bec46cf36e2b80d6e1415ccf91f6ef4140aa188f24b95887aa953b60a8849580acd39747a36e790437dbd6d6eb9057a9ebc8041dedfee4464081183cd08b739c282524924dfd231392514cb433b544555da88fbac4b4dbaecad33edf04ac96171ebc4de1a82e83b236a140eee6ba7c406f03d61ed2f6221a4fffe5f0f6473b0f3558a72d4a050507334fb498b6311f685569c137abd2cea5c0a11033a4c423f74f316ad549d423b6efe82de388fc7b08bd7bf10b7fabb6dd6e4f212b962afed0a99a97e30c611da07a9112ae8c18dcbbd6b967bb3b2378c86e9e1e48825efdbbe591157515f091bc86eaf004a713e4de0b9a8090453c97f819048ed25cba53e406d771b05f880998d9515639754c1ea6230983e6a705f137c80eca22f87bb6ee534fea3b7d9b1d5981b64fbaed71de35439b66e836936f89d46ddc2c4828e2d499321b2eb2205c86afc4b91f221edef202992b67ff476a24f9ae8f016fe9a992705aba70c1d4b2d27cd45a7f4e38714086e88543c85af1c1cd4e0c1538064f67ee1466a8644be659d7b96e1398ea5f3cd987943b425993da1b703aa990cde6b3463afcab0d57d6848732d9a9306f52ba3133b80f27de3364d8b5dcbdcc859e7efc821eb0e2f8d512e2b1269b89d4582e852f8aa1d751c0f15dfc58bdb03f0d2ba72544e7a66ce13f31fe70852bde94e7741da7afb4ad8df77ffdfd29617ca77711ad82ee33cd4944ec82735d7e5089d209c3caac8896cee81e066376cec6cd9781d570436132b8a68edda722f67679ac907d482df027920516d5bfbc675867570a13ff55746f2ae55a3b4531f1a3abce169bde24ebcd08c772f2b2c6410e202b77a3fbc9c89c2f542704f53f9a65ed6ba2e981a0a74a9ae56f63d8d8fe15874264893ba07340261ee1c94c171d29c8810b6c05e3ae8b562d6d55278d85c19e3cbca93d8fbc3bacfdaea61fc02f11f889af0f685773d4ea0d089463bf37b1b263adb0c5d6cfb096a4db9f73de6e6a793fead3d563d028cdebd20acdab31acb8a463486015c726ed36a76973bc687a24e34d2738747b909dfb73fafab90dad9c6933cdeba13286f63f191dc20911cf4a4d36ae16b038c026f38b7f5429af0200e8cdb7008eb2c2365685d740003df23770b15912db6e95259c452cee8be57f58bb64e96e50050aa29dd2c15063ce42cba1c6a4a1026d1fc6dbf846380411c7074ebafb40c657e190c15d6773c06b03ae519dc4207740e6f95a062c66190660a86fc160aa4b78969d8b04398e82786c04b8c512f2aac4701f4e9e278b204d05efa17b4bcdabe9b09805cdbffcb9d3797879b3edfb9eab335e39a875913810b4303fe7e2cab84cb5ce16b24afd5a69e4e4b858c0ef92c42e253c73142ca275f70692f0951f212f5ed9343db043eee8c761ced1f41b9025ef979bdfe63a7bdcf453e6faf2b5d823727ccd8d88b97941a90ea13674492d1336efe1d0a4b8ef7e714f92a6d84a76c666830992ec8794d5022ffbbc419646372f523a72654623602162b3a9c14fb311257df0ca208a59a47ba976fb7ec1b365d9a5d9d0236f248a56a40840dfc5e89759dc0806e6db737efad08f5f3f08d54228fdcbb47bbf5e1fe9c1149427bc03c311e2114aeac8cd3cd824e73bf2aecebdeaeba2ba054e7cbffe04862a154da35f6a617fbce6de1df86dcf57a32bb211145205a03bb603b2cd6a1652cb42638b85f7d4d9d6693f2c7757028ba1e43779dc69869c2358a83ba0a3d284fc087190ed029b9e22d0c875152591c5bcc46725730a83ac1ee076d5bef61cae522ac43502a24977d2754ab9515ca876fdab37e5e4b7c04ff9a2a6e92f74bd91c3da74a8c8fd3b6179b62c5d8e30768ed89a2d14675d6412408b0173df476f6b607293c1109414b69d9cb3384e6bce9ec6b1e7198c0da711547ce155ceaa15ce67bb51dfbec69edb3a15efbaaadba1a82f2c620ebcf98aff17724f52f09d6a27bc6168f5290d082cd2ffd2d6d2fac1f8bb4e241a8fbb715ba52890cc730623f81b7abb591d0bcab52837d1553b0075da7349d38d508b11789285e9739f556ea89a007eecec20967c79928aad149fa65e7409897fc4b37440bc44036ae5c71815accc61d78b36f0c1008245e0c5161a82905684a58b40dd2f6ab4afefa0387eca143af218fdd1a999c757982a6de8a98734952ad5427e6c8a1d30049373c147144d79a17d5b31b6caec4ee4bda37a0d1e744a03bb02a5bc41cc0b4f29a0123432b5d341373d402656ac965762a62dff11084ff9003b7d6b553e3552071dfc8cef8890b447a9254c3a0d8db7ce7ed558730c55b96a4bbc62e3e084d6702174ddca1cf27f7969ad697945dede8f6d0c04c03dd2371283e3062d40e5bdfa2f621fbb2e7b735fc9e731de32e10109c98766b0050a5927964305f55e34dbc8640c4e62c376821e900b054a0ee58eada4f46111210d2b19df741237cf51a8ac89b654939cc6a26ad138342cd9c5417f83560e2c74656fef53d54d6eeec5eb390a4ef1ab583219ddf0bcb8428e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
