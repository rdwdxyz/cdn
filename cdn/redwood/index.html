<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a5db5ddb8f9d821fa8abd3121934f8d14c750c4ebc37ecd65ee0013df46029018fdfd70facadf5b137e4626824b20285b5d33973b079ac81a589208a5fa677d9477552a83b6a6e69038407aca9bc4b721c730477c507671d2d53da0da2b1e6ee11ac7c9c05c228bd0ff6ad72fba262688fb722d490665c1911e50415de83e33580d3afd849ab30ed3ba25d52732f63fbee86cbd4db82438134a6f9eeaeaa8d616df0e3d87f44518f42042be6ae21750ffecf724e6494b3d7ae558c996d158e24de3467f23ba492ff93c58c8bd2501d8b201c1bb5ba8088cb395c306b0534fff29a39113d96ce293119d1943ce2f5867cc175fc7598ed0078a862338a91c86b8930855e8d34a398cec9a78fee59b5354a3f6ff38c6e09b2853297d115908ec04e1012702e1f3f785d2bb541cd441df2e3afae31f7c7f6d107b34e733ef6223ea885da5989a77ff744121dcd6883e4bffd6e8acc20779e39d3fea3c45c98f5c84dba8757068bef2d49787e818ca10d033d259620cf3f5bcf6394648cb2a7aca2b8fece469e442a98a9534002ee77e67ec54a683da33b7c2288e5ae70e063081491abfc2da35cf3a1347246856887b8415df6cfabb9e8635b04e6712a3e6a25d69122139afd853b1140509a2ee2f7bfcab75d10ce5f07ef42f1b959825cb35081a77b274b790b195915fba1141749fd02eb15eb1719025700eefdbf38f7b5d8e2e89a2e7ef28760d941e1650afa6b4a5a8e28e1854744074c3c0963008746dcc2a59da590dcc8b141adf1ca1396607dea56c429bb5f6cc2196c39a70a1ffa347a1b54901b4ef89ec738c3ec79867433280aef87665e6fa40f0ee2379c69a6943a0cb5f1d440b375038611dafd0292f2270d9afb692cfa9b7c3443a82f7331b3b302f2716d7e9df316d6b862729efd43b164f28004d001d6c0485e28880a660d0ffd4960aa2a0d6f6e1a20ca9cfc9311b4fb609beba1ea957eb3801ff0b3d070df8164e203259c207cc374071cccf8d841b425f5e997fdf663707614496a9637735a3858c7816f03f732e65008d216828f23254dc870c01ef1ac3eb55664819a64e7e8bcf6172301d5b001b6181e1ec2301df5d9961736109803c522ee603a2bc68358f9944e50c57f9773cceda0367438044fb26291eaef54188e2f6dd0de938fbaf2a63402df222952ac8657971a5a901c5f19fef32ccbc6f697b19abe0c53ab3b766dec43ea7bdcd10482aaf8efaabc1a19d56a583837c4abcdc365690c05f34ee39e4da38f1b32f1f8d71f674a9b450b1aeddd1b5af8d2d721a81aa1c64baac73412b53f7b88a36a120b15d6403fc150810f4ff245414483a8b3bbce95f9906526fee501e5db89f09a366be5d2e0d6d48cbaae8d064f4c20644df085053ffe46be1dc656ac96bcd0af723ac620e3686231e96736aecbcdaf656718d9bafb113168c8dc198d45428a2280390ebacda494edd73436cd0ac8b1752ec8aaf1714c2b41910520c573b72e75a3ef8b8b07d9058681e83fb556813afabf68154a06ae5de7485bce10bcea8b7cc77b02564ae0a7287da8ee352412f18c44d76dba26d876f5e2e601488044de8cfd1f070b714f39a5c66338b930c140a43142795c2ca69e4af5d70745848033c104596947a77dfe34aa648fbd62d5ea9730a3439e520394eb1556ba8956b8980ef5764e890f923d13d54a741aaba43e196e099db62e7cef89d99d593c87a42c67df55f9a72c1062c4256a1c0d3b7f7a0425b8f393747e3f8481bf7c3b61504fc0876a0babee121c99fd3910019597cfce5167e17e4f876728e0aa59e1fc9ff9f749168be57cc1e6970ffe63934de60d9e916dae19027dbfbc5b66b137cf4f53c93efff965b24e05a34237f708b09a3780d6e79af7e1cb1c46936f991034b2528a63618a23308bca10d99b01af3b6c0b61e47866344e1c056f411cde0adc30005934e0679452d52325a54e9d25d206351d06b9d50c1a1bb11a68594e04fc91e7d3cb263aaf3fbc72312476990138b8f988cc915a31deb35afa67d5082bb62a61e91981fbd57f1cd53eaae9df9aa5ae4c59c1d566a48c843f7d0636981f884763258c2e9229b7b2f98484087b48a2917ec245b4c45d6754a869ddc18a3fa11d46d34db73e3c5578e2d05d2061fef9fd48b6402bcbd9e9ea4a2dea4d45bc05ee5990a08e2653633c1580bb4d9aadb7ab2cb5cfdeef074a2367160e63823b6fbe6d46731e5149fe0d05d0c2d0ad67941970166ad4ca4ab028cd98015016badd6d2244d9b1e1a72b7148248f3bce6397d2fa858129420c73cdc528e8679ce8e80aa8a3e4c5bad76d0b2f59ebdfdb1f258fd94b8cd3b6e464354c72ea023f15553235afbee456da9419e97ec1f13c781ce6632f31538130deeab712c350fb1861cae12a9f7c4f8c5f9e0c867d7217167de4d269053b54f3b5fcd440a494b3ff41d3c2d1f44ac4d8385c6b2f7feea876d5feab5a376a227c23f7aff793171067fc8bff95531c4ac1cf7a6f0fd82781bf0c9218a6d2e9d362e3ba2a9cdb39e74796d939bc8c2b41a292961fc36d115a401d342528b6f54274e3d6be5593d13653fd3d1a613d809cc0c2a66ef113b37250939db29fbdae19d7180733c3f97ba5966c0ef7a7fb625328e3d1bbffec3b884bf7659fb7ebda98096d5ab25c0724896808c7403aa94070c7e3cfe678e323bd8998c89214c39c98145f2663c519c4255bc33c70c4cd94e6bf77a46da89d71fefcf68fdc2e7a4e93da2afd5521fcfaea2d915743296836b569c650160cb9f11af8437443fd39da21abf6847cf2b545468f3e7c2f8882a2a4584cbc5b4d2a02a8e57eec6cc4889b98ccfc06e13314aa365b23e7c2cdae8b282a4318066ce264e78dee032b7106a49c94fe5de1ad90f79e0fe708bd6fd8b6ac3b63854a601c813806b9f65d3bf2c5ed27a01d43abda36eb8f8d1cc55877b5845f390520c9449dd07252da7db6a98eb5b1d8dab891d06899f547b6c1b2e4af60901678ed37e1520fde69a3f41cc5535d8b2d3b612f408b93cbd72ba5dd651e685cffbc3ebe14270c4fd7fdb9a2dd373f76c0605d83e0de9dc887f8315468087a7bb9004dc74c2062419bda12f6fc31f29548c37f5c1123c45de986559a78e5f2f6ca02a23a2d456386a9c78a774c2fb286dad5b100f4a1528cb1554fdd029b7d7465a78d3f00cab00ec237465f06981e982f8fbc5816dfb0fc70beb34fa77eb15534b04e0bd92ae7f7626fe9bc921fd2c59476bebf3f51179132c3230a971adb29698a763f7054baa9a86c94a229b3e71f86cdb2eedbb5b6b1daa94775e199850ca8f3c3a5afd11c1fa7a7e06889dbb63fe50a5f6cdd2bef73cee8aa886ab90d443c840481897ca451efa230b056cfbb7f9d92d0acc39c300d1d855ba9fe34af197799f8040135c0f8e56f26fc048894c7663d7fd85e2acf23f6f0806c54adaf4d3bfd630dafe6a8038e80379b78e5a13fd0e6b20e97557e08e40ead97ef5a467e01dd4404910e119db423234aee6a0ebe20942ea9eba2dbc5918f8203b761f84ee68864456f845e1a324c813d5fc684a25ba3ed38add4399929a4978475bf9bb0da693ccf9648beb99d0148791b5d04d27372394466c2396a6ddda41299ebf1bf75142ee12057dccd6165b93da47e744829841579db52b256298ea3f09c7c427ae5a7f2c2d7a0b29b068200d76a8ebf07f4077c8c86906c0864af8f3269873afc5e3b34ce51e6634d7e9c786e0ec7eeca492ca18913e25a2e46589c36664ae22a642a111a544299f9eb524afcedcadf88b3a9cfdbc9eacbc7c1e19cd21f8d2c1b074082f243a013b4c14fa38ae4201aa9d6947487cadb5065728dd55261f2d4fbd09a0d6af17824d534ff1396c84ea4e2659bfab79a7fc43aa69a0c98b53fbc0f1ef62d618902ca691514e7f608c9de79a8df61864796608a01c754cd79b1c481f1db7f65d5c6d241edaba6f34bd9059413849015ba29162d392290662909ecb74adca99b70862909edea22148816de7353129a25ecefa4716c6dcaf3cc3534e31c4daa2d3414444170da93886aa640cb34c576fdfc2ad0171ff5f42f6eb5df46941bf1f79962d81cddc83d6a74fed923897aea825e052317aeb231ccf9c6d7b69b2495744e85c661cc386e8cd8000a3cf446987dfcb6b9293a4e82d0eeb5ee0b2f52a25dfe4359158e9f0c59f3a79a264d20a0b540f70a589d15c4715355207dcc34c37aeefa5b255ccb17e1f892fd0ba7344224e36eff8db2181707258ad844e1e325c081fd22ec61ce663225dcd83480f3a794929189ee00ddea90d7104630b20ca75a47f3ca701579c81f6dfb73eb3d5355c1d8b2684486d27536bde3e0919dcfcc83aecef658515f814d43bc8dcaefa21b554f75a5b11fae45a8eccd8d4484a60565c081f837f1201dfb9ce6fb3decd9b117242c711ac9e1bcf752b183763877abf39d50dd9e19ccef5224ab78b05b4eb54edf5bc1217f53701cb2da006e00746161535f9c1aeb3bea71f5d53317d33fe9b9a3215d5ec01217adc5c2d750ccd1d088ace816735273dcdb53850efe76606cf5625fbc24b347ac1ea13982a37adc3e78852ef06ae78cedc98c34ebd616eb8dcb720a97c5e554f1d5ebd69ae34369d794c49b44c81bc25c2a43b6b375bf60492b6a7f8799b5d28dbac2957b1d9fc210bc4d6133a20ea6503128c542f5f12aac1d22c143ac85b56b2787391ccad2ec75fa8f5eecd59d043a11f1951c3b7705b791f4ac7fc42776d6ec7cb7e61fd40a48e96e02c016bfb06ef3e07e90a1909f147863ac0b06ed71adfd7f01d7b05a8d3d1b631e47c179ff5850432eaf32217915cd182d66b9fa85d8108c72b111056da3c72780ff9e363222821e62e06c461774936f7c359380624f6b50460bc6bf8aad1ebe92362c6f897504fced4c087edc47cbbc39f40bbd5192287c4d627900f761056ccafbe31e1f19aec607540115863f603a234992818a120bf2c63222ec608c1c97554aed0e7e14aae078e0aea55b168278de37cdaac3b93115ac72025035b1bdb4b41a3c7d4abba6b082cc738544a4f5f644030f46c14c1387a18a5268d8784edfc96c82878fe36922503b5f8c1d4204c98ac118bddc560ee1d73fa3e4131bbd57006f14eb1461a604ebb0d3300b30e13da0bf21301bf3b584ebecbe1930ad49962d179bb59e9e969095f0f3c4368dad7167e54610e2b5eb0dcbed6fafe89f6ae8ce3154687c8214d7d980bae8fc090fbd4478cefa4573cf829782b9e2da534182cd2de171e7e270a682dd47932235c86707c71bcf6189481cbb12f26a0941cfb4c877a8c9823b74d31fdf3adab1ad506f632a272b1e74d8ae95fb94205a74140cb40ea3eb9d3c08a0ca297d9234ccc1e6b1706e1943ba4771d82f3487c8633926698e6670be4eecea303aa5a8681fb40967e04f1acd9de6929518e2871f82fce8a148d1b107fb03b06ac8b24c93c3ba91294b0cf7245e34a79a1c6181f7997ab65fb7577869b96f7e5118808880a9fd8264e5511cf60c5441968e2b06c9019afa27746c2f00c325501476f4a877fdb651eff3f51e4906629c0b2fb276c25e521241eb358f17dd50c2258e01ed9f85e413b9410a72fea742cd81366137f1b593541a4d013a14d59b2a9c29a4b6c6ff764d082d734534b6218f754fdff90bed23c5958c64568ba3ddb2596f7c33db0d324d15a9660e039573254db5cd9cfbf500053890e3d0a848ba654aefd65d9735bb516af7effda8084931f2c1e0b04d7372f1e6aed9a3254987f95987ad90f20156fb20719c8efe698a5e28446122a3eb7fba81e90eca301b5198aeac7ef1225933d50d8a8714d76250898ac46d90bae5b72ae32aecd432d39bda2ff31023470e33a79c3c2970ea6240fa62178c3331b6ca5678bf83c9a2d44a8f45f80c36866e4ff00449f01c33f8cc3e9449d809fc64c37cabeb9167afc691f1917f91eff3f0f72954de98499e19b6448b38bcf2ce908d6ec40c385b10f9a7e6428a0bef0ef1205cbe41fe239b38afe35292e4d8b6ba4f20dc0f0110f079210ff0de8a1c17b3f35abdbb93837d8f713c6a2b53f748401fa61af58618ab9d9c3128627109893ca7c564cf116fafe104b7d28cdc63bd56ef6aab4e538d146343ceb270de5edd73e6706ee256f9fe0783ff729e3c6ff15f8a2ccafa35b1ee1dc297fe51b4ef2ecaee22e66b9bf83cfbddd5dbe871ddba7d30e75b25f21208fc2f8accad063ed9112c5a97b80f2b631bba8c9abaadf956c621f4c410b17aaf14e3f44a7ba58db73cd18ea8b8e01f1947c977e1c8eac69f60d05fbca9a8fe399bfe7d422fede77b3ee4dd3974dd229e53eda9846d70ab94294b35a8881f5634e8b31c5de97c832722996277a7f038fc527fbc467472466e1c2136509342025deef6e342f5075def62c1cfd5f386f7de4a5295163618be43e5311d2033bb8e868ff9424a3eae5482713e6815c94e9b1420f43de83340b0589855de41b30c133d4486cce2ef13cc7bdc0e2f51e25fefc64df527e9f4339b9335ec1be903fb497b3518184e117a61abcfb04fb2d20d7f07f6a2f4781386f7ddfd363b00330b1e5fbb9852d05165949cf7bddf5f2540c10d0f882c4ad2be9c98110940c43b9af11d267ae8732a24e4ac7d976a2fc688451553febf685ffa3c5e591ad250a9086e0a441a95012b77354311baf11aa0b16f65023f219ab5be209f9642bcb4daf73b7cd1cd61e3be289d8cbe7f53dadd7c5ef3d200471d56b5a29c440ffb3da051a38e56e143a7fb7c03ca8abd45e574be5c4bfce40b2b8e1d083c5374ea5c35ba0103df7db940bd6b9e293e4e005abd848eb0d5e9c527dac95afa9f45973afac64431e206e586ba216bea781eb5f48690f783463ef594a7fa019365afedf23792799f734d40f940df7f18d1512edca4d6b55becd98ff4d186600cbc36f7155eb6bfd7f1093353908778b2fb4cc58271cda2d1b306100e7bfe544de56d4357dde2361d3a4ef247e4830fe67af6b0030624669f04c20316176611917ff74f102930328a9bb9e1864d10b7c93acd1706d399fad4bfbcff5fc7677c82050bae63f315afb107d38203ace6ac49011b07832840f7c7c0f3b0653160e3d842f8444708457e005ebc35bdaeead38d9e0517a7c10473627001a29ac987081b12aba7506e23940e3a5ff93774244c9a4da8fb8fd1a0f217b0dbd2b8480c22da1a52cb4fa04632cca0375d6404a3bf650d9fa5b91dc19c7369582cbad7807eb1dcd0a829159066feeec93942a807e76fd640336b26c6f2608ac1df440124f30383e253ef7a9c90a32a31e7ee0d18fae565fa220a2d072b4627b2304670fab6cd7aedb572e4669fe9015102e06279c01ed06bd14bd0b1436be2dbf1f0b342ba3577c7a35508dc339487d743c0da01b377f51e5f02a28cfd04b045b960df34a574b4b9bd8fc134125db644667c8f9f4b32eb74b8c03534432d107f55264e5f5cba6baf020f744feeaa2fc95c5e5634b527de9031936e160fd9997a91ceb116a9e3e99ed5015f6d388319e6973898c9097599d75c689b9004315ae01d83a91eb9d8b1431ef6060c1925e06048eebd3be4a9a55478fb46f077b1face667e5b44e5acd491c87e57bef1c41e0ae021552732fc04f2f0ede1ae75489e992dcb10642aaad8ad0666373425434992f32df8fac8581915d8ccf0b206d1528502e7897aefece4292ebc9fae63d496081e8d71532ecbd047fecfd5b275c003a5bf12187419f0e91f20090ddc64b1642d77cdd6a3711c55dcdbd85d84306d774c7f37d521f0caaae7b7a0b3e3e5e8f1a9c497f1bdafb73c7f359c867ab08ec4ba96e73ed1d77d8c3df53c6d48b829e5240c2da7a79ca4a80aa757604b8147300aa2aa316520c8fe12aadf27738937b4f6b17ab975dc113f863010b506a9e828033dde334a979116f4de8d31f2c44e0339c62c5b644eb4a65ecfeea9d4d79905f338daf7dd169080f1fd72cdb03fb9b75ca372311fa6d083ddfac4d33a021875f0aa24e858707cf5d6d3b887b74db5118bfb0929ffdd6d48256204517759b8330eb110b155007fa04dce89003d5490ae37d0ef47edd2f6e319074a27106f80109713e4f705854302b75d1050293e854276f88d20e77365afee9a537550fc9126277102ffb6309097b63af155c61b864be21e77214b5e6d7a42e475482fc9f08569b7bd2721e7fa98bd3163cff3316cf5ddf810640091e3f1ec570734e3368de3beedea5b7b05c84eafe168256d9baaa29ed0f265469534e4322f27c66e85587482e2f5b9e38ccc154c03ecf839d103e66f8273d6fcfca04b6e3793072980707726d01cea794e0de4eb37e93b78326edf80aa30140c747f270fe1d26faef32095b2f035387c3feae110b954eecd5823651f801f0cbd510d505acb68e4011310f06de1cb6c4e6700a8b8bd3a405c4f13534b6e32a62c4391d0be63f7e1cee4f866ac43c5a67f8975705008919cd4a1c1359d88e375a81e0eeb0f6b49607e9f05bf39f2730c3ef2283f374cb9e5e3e0cc74e616f237b8a0976030d30fdcd7543babeb26381cd35cebff67af893c16b01c7a6bf2d4439b9545313409250b966ee8fdcf37377a10a04a40b5fd815c89ca268739524ad8f9e541a629d7980e3da65962ccaaeed7ba572ceb49c22f6514d5f7add577f6f481e6e4ce9164d27535daf9e6414e8499b11f9cb04fd61b77ed88f1773cc14ec0c2587c1e7bdb3e265119624498c918a448c862e377228a1c8d3029fc096a9ccc13fc4d58683bddc1cc898460ef7e854d8993d9ff3b0fb4a074584a76b7048946a90208ac73302cf7f3f4c7e69f0e5296c8234176605cef59248503475df64737cc24a8a3195720227e70e8494614500acd101d6b22aebb918ecc60345ff93aafdee1c7322561dbc96ae9de889f7d3e660e3e3ab2351720f818143997eeee423b3479742876b7ba5f959c3829975afdddb4c34e296d4fdf97f00ede40b535ba3f80e3b6b3f22b8b97693ad24170e18c28972f91090a2d2d8ee666bcd2e9d9bb8010526ac6b991f02a08aa52359d66db646e05ca7694366549ac51430285f0c7452fc92daf735692892f7030e1940307c895f3136347892f2c6276a840eaccd02415ecdd667aa88b9187d99ed8b07655d7ecc55dc776e9f007439161efe72b800ad633b411aaced69f6510f65012f06aef330dda4819ffd666770c661af0b2af72f74061f9e5190a7c31c249301d7bdc0b979ef865c76f5bf78b3552e881acc26b0b70d176646406251485ef421de2948a7277cef16bc92db90cad9063aa2e386a16053d4a134515c9d5f419f08e1c50404bc4c77b2d068dab7d6dfaa764d862af3bafea47f6b78288cf58c60ae754941d80fdfd369f7b92424d021f6eb675ddcfc2fbabce2f9b20c4172539deb706aa09a2f2b562c232d74b73c440d96869fc0c76b029f58f540c10ebad7781213993f61832403318690bc73d79b2bc7da79e03b355ba3ff3eeb9c43047ee905cd5029fc0665032ce23bd8043f9a07eec510935b8bebbcc69cfdd3524dd57f48997dcdc7467c5812ab066695291bb4cc22f104f28a9e1ea594f8d52e8e2442cb9619cbd0020b13e3ffd4037242864d8dda10c6589bd57fa573c5f1109bca596e22669fd7148818b469a8912f7a7450bc0df9cca7aa2f949aaba3e9ac8b9d654bf2267a1911b486a20c97bb3ce5bdc77ac1a6b3e59cc5a4076bc8f06e503a93b42c51f888509687c89466ba95919d07e77b3fad93cdf7d32ed1a6f5e67a384342cdad4cbc3438a87fc2a8dcbb577d5d18aef8b1e62d49a4b1a68af40a45e6f3cea618571170bf836040cf2df14a98604d55dda4e8b9057470d16d5699f600b1120e9c66204c48b85682bc1871d46a894e464d56bbe2e85554636da36e0a5ab3a6ea1f6a6f5a1e174761f8bbb96daca2eb460b4a63ef6fac8c8e57a484e64991e5501438e620101d5b446da89d678ad677883f4207162f87dfe55d999b372e15af8774ce9dca5975308690c2794216b142635b97e29f665592d752c7effadd6779c5f72ba11b54da29b72059deae08efb96c71f2d554ff42d2bb6e0f39eadae279f38fd0fd808f413ec07b154384ce647d033535f00eb371bfeaa550580d554d5070ce2a471c684e5a9d8a2a286f2748397d23cd0a60d80c89e502b090daa350f83d716a86125dbe0ca24e80fd43b2cace59d420b6f2c8cb8b70976e791c8dc54c6a512d330271954efb9533ce48eb98beb50a6215c47dd7676fbdfb67a9101ddf71c4de16802834bd694eb946633acdb41bc7f1e94d9eb5450b154f91c6671e8804fa5632a9acf697c5b56111cb69ebbc3ee9bb41a60faae9544ada44c33446b9221cc14f8e6c1ab88f7caf191f0fd10950cc7170d652e3c0bb33e72be487c9c28cc4e7e919853883290a53a6772c70ac7ec60f8b2ff1ea5168fe0c6de0488f5dcdff78ee42f52342864bbe520a71235ee76e14584a5a32698e3f76d37d1404b3375db0b75544ca14169585be53444ac70d062925b21f1e7c9d0a8f14a4a83f0839dceb6cafaad37cfffebf9d2201307dc84a8ecafa37a8f51c18afff6c9936239ab83e41c15a41f60083ebe7132f9f1b4686072074d26a203fb9465636c9f08356c26cdf6b3c81e998621d32d0ae09a384afa51ea6ad61a4ee712525ca7059cde7d27371c51d0eb89e626b1ef1f8cc3045206fbcb8a1059c575173baeca526f4cbb3ce47fad4d83ba4f53a5fb94bf24151e349eaa735c2ea78a5a72407c127efd8b7a768618bb4b6b83ece3f11468dd36ad10d5452822846f1f00fcc3b81fd067ae7781aed7b480f5efe1670b67772cdf99275891222f219f4ada3db73c71564545be3360bed566bdcd758a0ba01f276a515be543abac871594d167f547952cfd4899aa61de6c22de85b93c37793bae461d1e484614a58dee8ba3777de3151e4c9012accc5879679e310e82a7e42f4860e0bc915fa7475ea89b9baa05b14ee9491ec0a597ced410c4b86508e5fed27503b09a640c659e5c2c3d0809a0cffff57ae1f25f55ef6f9cbfc8060161444bdc0c215030541f5da7c4f36e3559604a93b6695603e0d1edbb305aeb9a24496cae49ac4b97ada455ef14fa48272ba40245e5f2bd21fe731d3bb25f1cb1dcdca8ca59fb12cfb687fd888d74e670192e771f1f07f911c7b671f504c8d0363dc0676d98a5cb4fcb1ba4376bdfea0c59504243f5ec4896432d2c6d5688e766f212cd796f75a1ef0bc751c54527b0730330c1a1f4813781236bbb3cd9c3f9840d2c1a5beef6d98343d01e97b6de820e9b113137a67f42b2fd84ea62801c7cc996370c613f93fe095933bc135770c6397c6ebc1bacdca2940edbe16624e1411f40d2533f486b7be141ce3071c790756add15165f0eba6ece15d3de0e73bb176906ace509066385c156480341073aa039622308ceae5e68ab6e67a58839e036e177dba873b2a21d7f6061f3780d8e16a91dc5f246519c89721806d46794af6eb27b94a53324388f81ccd2ae8ab67743ad917098c1c6e0103ca54e5ec5ff02dfba2cc3285b513f8400dbb37bdd4b72fe68be565150be92d87de33fa0116ffbc4554a0541d765b40bb3cda864d82230611b7463f8f0d20f083eae1855eff2bd0320d91e1a69c5c4bc39a01ad95be38dfe94e675ee056a87b1ee3ab10b2c427ca7d9dd78e4dc2e206658e5137f2db4e9de262f5c76f72a7e39318dde42fb43358044ddd04ff3bf79ae94fd98d8ce714f3970a7bf40deeb08cb2af14f0077c45b89fa12f701deb666638f1b0cd5e3c2b1925922d70f0b250860d93097aeb546661400de9dcedff727c3edb619988b38fd9343f15be73ae41773f6290bb668f4bb6e2b57581a16c62ba35fe08e15373180649b1ac5a38a41570cb8506d81cb3df0b535ac06c03a636c6869262c2ef51231d9417a5964ad0454d3c2aa557a1b0bf99238654194f543648654bc53a3e77589849d118ce394bb3688d376b6e7ef82e0db9650736d15b7ca86226ed6af06fa9004bdec01a1e87a607e9fe3c9529397bb646fba2ef0da8894a4075fb2744564f9420d76c86275f5d03f87d02afc3f4c350785a737bb0d75ffd2c0251117157ece582a94dbff1a4acdb82af095b6acef681aede933700b9f136ce7b011463c38df1eb96311c996fa5948cc13567bbee9f83226bf884711dc110a9193a16d0c9c10c5acbb61d3bfcb1e6a0efbae2c66e821d333dfef245ad6cce8c71bf3d4917f52ebd17ceb1e7cb7870fab77a530c17c683cc1b031e3ffd433510b2403380fd5b64e930b1fcea4e8c73dda84639dda73306f588ed7bf68c1b41a5c8b00e907a68fd29431d671b87d2ed44a6fdb014460bf238f40061243a61240489d93e7c00a06bf51f64bac27908b70fb43d3dc86e2f5a97ec268c5f0d03ca7b50f042135c1eacb865c0b13ba5ecdf663331eaf8255a1a89b945df2e8becff73eb6a3f835056109ae977b7112409fbf850a90810be32bad48e0475fbca882d6479fdccdc17410a056361d3c3b151010f023ab1e905b50316b203aeff5d46dd6ba1007f06b5668f6e694357b208d65fd375a341d9cad15cf9fd5456405649a0518a32676eb8f2d1a2d71189c0da6b3ca25a04e352deb6967fcbeab3a023743cefb8841a0dfbacb017107286b01a5255f5e5f50764229274e341cdf3d0387063590fc4da52af18dafe752cd97ccdb4dd34d508fd357c615fecb13128089cbf1e83a8d7e913beb46ce69aac6328784bc62c138083e9277066548011c7e269dc8b1110554b5498344f3967551c944759037e83db6294cc436ed1da8482fe64050d95d9f7ba87092cd44927e9a28b62ee612502824381542d32ea1eeb9c481a42dfb48762ff6117818c060040b141e6a7c97df3c34626affbe4811ebb7b4f53e2e884eae78a83dd9986e3ed69270ccd3fe7938938a1f2e4c030530dd9c1cf5adbc3c01c09d5317d8dcb8daf10025e66747c70071ec65b5ce1c0cf6c0987f6e950fdc21ede5d046ecaf545912c07bd0910c2dfbf642083f871ba5bc13a8c919572ebb26bb5e46abb5b2925fed565cc23945746515c184e1a3e14d61b43c6244df8606fa1390bc9a95f6e43ccc5491c3bb4fb9af65ed7b97a02347e1b4a09d93b8d9ba60c1355bab23add1065db7df293b8f50529e90a779b82b6519f14a298e74af226b8d20a1e3311c8607ca5041fd6b7fe840469b06bc7dbb0bf6cfe27ff04146582fa0e3500ef3ed3afcf926ee6e534d3a59025bbfb4f1178a6ecc264086312c3b646fa36008ae9ce015f19a9c5fec9fe689f92998e3e18dd730a291b1888fb45ca3ca3acafbf2ee2bf91f00d3a84b91831e0ec9fa0d413006ea253a5e115f7625152c82afe7638c9ee70917332e3b47941ab1dcaf1b367eba1277de132b0abaa3ead864de0f39fbaef863242e29d9d10fa5cf9045967d0fb47b83e9516b44b5bab1b9cc6de095c42ada84360c742ab8d1aec329b360e17527dee8eb283f37b24ea9eda2db44b2071d3c91576621d0aa4dc28b26f79ab5776947b71cf47c5217ec268133c78ddc8bb71cbd0855fd4a1beb695b9854ffaec2ddf2528d4718d6081f126599e6fa88c80b20d938b01b9ec6594864c17aeab52ddc8a0bc26e2c5211ac3c8417d0b957c220ddfc6acb548d0e7fb88411f1d1527ca34df5e26b573f2040daf0f5063564041208caff655fec969d8100ee4544f18f3a155093520f8b5233579661e4447c23c65f2e597127a8fe5a701cefd2273bbb66c31b2c22e8b7924b6a4b129b6b52d37619590fbc1e05fc2978a65eb25eaad331bb65216f4f5fc6bc400ff1596d7e3856ba523d9802d7fc66a9dd97da5f69bcf2b05adeb6d75ccf43cb21cbcc390e577f2a6429fe0c80de36d339ca3bc39f784445ce3b688aecfb1f0c485038ca64692bd65e2a6a758276110ccbc0d8c7690f77825e163ab37ad05e06b486123e83572266404ca75d8b6c6c54d3b293c8b3b8383d8196e78765f9b2c0f6f6712d323a8e87ae3701e5b7b8c49deecaac268b422bbd41df8d8865ee3018480c240218ec4e4bddbd8e8702aaea775d50d47560c2d762facf6aa23eeec9bdadecda83a49f67b7ace45512a5a216b7691b50cac46ec35981609c3d4d8046882230ab78d0c004e6781e7fcc8d24cbfc316d8d8bff348ec4f934ca6b14c232b3e621753831646bb8f34208b2ac39df8f9f4cfd91df7d596954a19e286a55e89d4074d79fffc93af55280a20a7e53b2493504b456c6ac6787872e3be4a4ef9d199a69774f0681172431af8c40751d0d4536de904990b74936fe2f4c834bd144f53cd6c94d393baf3937b177dae99bd8701243f4cf0c5f5b9770eef070ada97f5b8c93442edb37ca6d0ffc450368f7a0cb2b6b0a5219021e114bd4551b0b15dffdfaef3843c3484b3274bdca4d6ad3d82f872310d6a53e0776469b304c8935ef3c4f1e659d873edbbb675c29c0bb7a334f5c4c77b2667a842068e9284defeca36528368afc441bb2e0476e4c361dfc79775ba85596a95adca03c791a2060a61e9ba8d00549e89033147aa0a26d9a3a974cb29b33bfbf98287b97b6a4ea4e9dd4286b57f8d7fd4bfa51f0e220243cbb76bffeb63f49b69a6fd1cf4e45296ac88bea3b76cebfd7ce110b324a281d43d4779bb2e5fd198083d619dedd7286bdaeb6b9fdd697f9cdeb49d2df7af8443139388fb3ff98090fce10add38bd27b0378bb291db0035619333cf3f26db415d13ac3b279eb0cbfc56980a8a70ed25a906dd847c7bb1053a6f6e930ba859375dc27d0769dc07b66d1b418f4b0fa9ffaa2786404b45159193066d06ef6f6624c87eebd5f73d06fd551d1fb83a1a0cbaf967691c530c085d5fa8d821ac5715a0bb13cff37e2f0ce1d0692e95bc87fd7e7ff8e4da70db50a965d1d2d57aa2fc33d1a5c433f3a4d4654f24785c3ff0ce14cc1eaa01d213234bc9e818dd3c6a9c3af54c43028956d18b182194b4e93afac66212530b35d4699431f89b57cefe695607279f7ffd0d9ae07b4b7e581cdaccaf3c6273e02b592443b634c50995be89da4b3822d6407101ceb1e8aac2ed9cd2199c43d8322011283a85a644bf101d25f655c26bacb1330a81cd6d851a75d9bbe05f1180c87213367bad28cb7e0e8b172806153e8160263e391abe41144a735edaf8be1fdba35dc4b52d6c14e7d92467df68209472cc8acf5229421f1ee4f50bbf60107724a9747832b89439633d1da13607831d08864ec26b78005bcaa531878db2b15160b36d18091b881620dfa4ba16a97cc153d13191073b5170672ba1b6dc9c59322724779d805ba61c4c9a7a358bd18caf547725ab4240f6820d9f3c63b544f0df985ee19e1933b8355ea5c68305e0cc1fb187c950e37bc5f249025f6ec5a950153a619abf49e2d3c91b75c0b5c12f430feacbddcc592ea240f7510873d5d0ab0d74d5c14b06d03d02986a0360dce984b792dd053646d004b8b4e7d1c84fd45fa39f08f4c4036a64c0d4a1ab5019fb9ac072832475677639db3de08c5726be3323d47c4850c34889184cbc551c65768516024d09aece195a58ae3c8cdc496371bddafbc74c3f3fdc5fb6c2eec82b7e0106b55f64fccc62fbb66eca7e623c1c6b672d78a3893a83c574119362d24e887c02471eaadf132000d7dc1bf3e782406b7b0734265d9f3f980a4d0d7ea28686fffef4f361ea3eb8743a28554c710795a4cfa90a624e838299961f781e3e78fa576f4b026a6116933a2e7de2099285253769f1ead2d404dc72546f12295dc69bada328f738b29e38a21dc18787f8a95f49413b2497f609d92d333e8f50c815abd058cae949eb55748c1fa07d4e3eb62b0182c65e1cb3d2ce84a19693bddf247074183dbb2ff80a502aa06897d21bba499956b0e4dc2bc439f4736ce775cd87baa2acc4ad9e47f8b349bbce135671cce0d9f4aea3c5cf69e93f27ab6f6816a13f8cabb3fdc2453abc1e9e6965e52832ab3d646d67cbc608581f3b0524277465b6e4154c0f65dc546818791ab057e9f530f99398b0f3a109cd394ec3a77e2b969c8a29755eede65881c77fbaa367871652cc4f26cd86e9a0f6d953738ea1ca1d0d681cbc3c221b9e21f6bca0dec29d884de0025208b64e78075d3e5b42c24c283b3f473f17dde34524a28d429d0ddd2a545d2cbdd71e3c1f71da0323973a623ab8e5519b09637b7a73da07a8606f48c4e502d3fc246b1facd16b4230d2f3c2ec6fe9801cc27d9904bb6e41b8adb740fcb6d6521357e04c9af3ea70f977c35223b733740472edcde78df93f2774157cea6eb9b00f1a5d2368bbcf701b4ef4f71536bd0ed56440466e3187390232350ac13d31fb4989a74e8f8088d1b30c6fd53ae9ec2a6560263dc465b069deeae4394f0d5e8aa3d23e7222955e39b00ad63cc7b8ce5a7b435dd3ae238b5b5babc82af9fa761806dc35d4b2f864629a749ffbc42b4fe8ad748c1099b4fbe1e632a65dbd54060ebfab6c68d24e57338c9a1812ae3e53886c101d2cbb2c4959a9e73c0c45411a73c3e33d76204582165734d07174ed78c5f37256939a8a70ef86eef75cb892b4c231cd74b1664bf0a5917aaf04c04e5f10fde9ff17df21694870a1d260b664d5421078a6a52cf96f35fe3ac4be9c0f87cd841c282dd9fc4022a156f41b41012112b4d5f28f79249dda4eab6ac2361cf30395b7d38f6f4fc94ff5cdc9f4b6da216684639c4fe9ea1e955e4cb3fdc21915c419eb274830246cc9d2ff85fd40d325bca8c39fd2399fdc7f09b0fc6414ac31fc47948a143821968b93fa31dce5d31a168466f5023ba1038352a526a03e607f7cfd73f8b52febe28fc6ddac0105ab2c064af4ed7166f1f372ee61b27763d2cd8ac6aa59168e54c03e32e4cca5f154034836a73367d08a570a1a1a36d580c92fbf973d1043ab8a7b8d30c8b8ce9e830862ba4bc51a0f7d3e44d823abaea9c741b97fa26a74d99abe2ac8bd0b2f62417574e6fa7a6c070b7dc13ab0f1c900637e4f7c13c6bd883d384ce2c1442dfda22857b9c47b1a4eea52d7111606ff85d87a4ee734ac1d7e42f34f6c66c001fc81124683debc2eb57d935a156d11c38f7e1728b2cde36c841b5610b7e6c55732f987884b8861c469b0339df22c212b70058575784fb05cd28815bdd732cc33bff2673249cafa1b3540f645be4da8b1adea25050cd377f991d57d64959744f2e462a3fa8597740c8ddc273c3a88f91ce6cc1bafdb905095667ccb409055970b94ba267b785faebab14c9857f1635af4cc5fb533e5fe1d2a3b6fe361dcf69109740e0ee5bc4054a2f8e1a3318f0e070c964b9874dfd4a78f8b69fb6fb369399f02d2f7f14b1a8a41d94d3fe8ca27e43c23de75c0c885b2148441ba672d1edd47bc5cd830fc4889b7d8d88f4abfebd27f10c869bccc9cfa1306d6ff68146c395dd02f03bada4bea4fa1155e40526afabab079e414662b8bfe9878debe3ee62b365cf5594deb4c993fe75ff3423b298f0cd3d640d162c076eb7310ac199beea33f212623275944e2595e340dcd0da1a9bd994403c87731810b8c6ab99494cbe4a5036eafcca163ca7c297f693a92115420c7c9971bbb261dc27973de414133d11e3c1bcce48d1ac1857e90ca7c4d9264e13b8a4a487b63d33551fd081fe4720d79454b6eeba5b521d59323b86f39c3ea39c0fcda669c98ebda4dfafcacb27c639e77011b1ff325e806eb436e9389e9ad33c945b69582aa3d64cb5fe1d95e5f61f5c320d8f486a50afff5e6e4d046a8e6111af1e714d23a6a535c26d5386d8f916053a1b10b9488ff4e7ddb7d913453c8f1f6d1bfa7dea3456c8ec0b70d4454d7c0a24c0d4bec097fc861e159ff86b8fda3c53566fd9516f6faf5b1a70323523ef4e15c7ee7b20289ca53656def61d2ad2461b3b0f34d47babe8f1420ba07ffe4ec55db13d5178cf43057b37ef846553103ce9daaf05217d054b5ac449a1afc1c2f8abe4a4bd231ba76b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
