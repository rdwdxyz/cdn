<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3b3e5dacfb1c26608536f55af991a8b407b2cb15169057c884b093d5d65b9a28c00204affdff5520f5350f3a2ebfa76b71c183b7adc528c0058a0d6300eda7a0109763240e6eba0499fd71881c7419dc1722b22669925761e26e817f55d0d3b4e4ab103805bdffb78253bb0bd4bdd8a90e8a6a9efd928f778983e0f52bd63bba8629084c054138aed45d1df98427fa27f724f7db481d076de9a1364962210ebf515c473224c6160c33836a6ae7572f2d1b82c7ef0849fbb7babf853922a1672d90c0715dd6180552571874a0be2e05e279967406c2623274400900875fde166533355eaa9444d45157705e6214e98b2a57594e6f85d103dc495b920154322561c69df0c20d70335ca8125abff40b22d3d7fc4ae7705be1116a49c03d0ee4418dcc2cfa178dbbbfa792eb9b8ab3f68a47549f2224cbcaa6079d506be48939fda0bfe3ba29ffcd3637b5aa7b486c3a85876e24a9bf057209aad34f073224a97fd0d19ba970f29ccccfd4f1d2aeaebc21aafae23cb600e3207ff5236b2706f477a66723792f2b9a4f58d9caf838f47a5bceb69d9ad2b41c9a4043cce26b18a2e8b864b7d25ec6e0786b4189edd4cf4ce4abb6028c1d0bafa6ef84d72f8b673c70bdf05c007af1a2bdf758c52ca5dee5aaaa635cd624fcbd7eb5d62676f091051979693a7b95926ae03219b53b7272aa56904aeefe77cb1a6be6a447348adaad483537d351569ff89a445f9e1de4c939b102308bdbd2fe59ef50eecf10cd3cfa3c8422dcdbcc2338779c08ef7cfa05fef70bc19542324707de235ad29940f3d8adbb02888d686d28d1c7c609a5966b73517ea45e1d7021e286ad22aed87f1365aeeed8046d775d68c57915018dd5374bbd347aad6630bf155ab6b30fda9d1b4260b9d0549ad87ba8cada006cc9e8f1b80a8175e9043470f1e957a11134321cc0d4abd1ca12b735e8aeb10145dc47cbc62160803982fbcb202e6ef479c9c4679745dc2c0ab27a2855eb94eb2ef9d580ca0f69511518075a9fcceedf412b58b0c33402811d525c5c042b5d496dd1f08aa66fc83da38ef17e78a17ff7f5bff0ad1f4218e4bc5bc7d465692d7703c4fcfd769874d78bcb76b4a7a0a79fb456047f8fbb6cc4b80f115445c92eb15de5fcac0cf9b2c0d36e37f584aed180480f8372ecbf829b2228e7603a29835433641edda78fdebdb233bc05074fd022ab449dc76b5680b16012e2739cbc4931d771e9d01c02e8e89429ef78e44b0af028f12ad5c59b48888a271f156f04f8c2c781bda92a9157af707408ee1e3e09853f1ca36022980079c3feeee60c6d5390192c8e11d70472c8c1337b4a11a8d85a9c469d8cb56f3701c19670e0b7d0fa8a85e716d2d5ceb60582d0a2e272d1a4326a75a67b3797bc359da4c6d768949195e018e2303929ca1425caa9919284a1d20770ad2dfb00c55dead2466d6507735e28001bb1514d16dbddf6fe7e48b34bbadb2db2908dea212c04e876ff9c48f2e0e402af1de351824c359df28821d918c43ca65dc75be12ef2f3926f5e445633a6ea073414b3bf193ad40d49b117dbb8853a4e2a7e51f730821e7bd4cc4504e7bef4b0eb32e9d1203385d3f2f313ee420789e6987817f2f11c9828fbaf431786aaa902005289c9c0cc589dd0d348a1e2fb0e51868967bc3416e63e896471c3b2081f628688b04d8e047a31408c9f7b86eadbf5edcfcdebe66ffb0405561837f4ef34b2a1d3c328106667b8c4dda8419e6ec973c3568194dead6913a9af85a66bc2718a0d756e582913dde63f01fb7ef33b7c13a97ce5e7b53cd2cdd33759fe1b7d7a27571693dd9982d1b86498482f6edc97c93f94b29e67aa1ec6e158fa2b188b2859bffb0c394e02b87620b29fbb320b4b4478262b8498d366ef1268f8fc6b7d7214c733ae8daf1e5a4ce7b50447135239fe6f7afc7a37a33193832bc363a415bcfb35b311d3d5de8426a0c84933c3daa5893640c0d3c49d8a9ec04b0e1e9badad0093fe36b833791ca331ba7858927a680f8b09953ad2fbb729fb958eafd53edb676f46f0318f01769863d1aaac0a02755b2500479b44c0ae63e5fb5b010df9594a7b0cb24934515ea288d095eeaa36e7d2e5c7cfe9d3e253189b14997653193fe23e2ddbc6c70155c55ac35ed015d18a3d23ed84f4d006522fd81ee1c6111130865cbaf45b0f56c702ff5cf1431d51eeb07e0f08ee410a51434b58e87e25fa562dbcff786e967d5dfa29a12997a3cd0627670dbdb38d4be14c9e4c05f9e6f9c4ea9b87a1af089c5d362044e31ff2c34c2b3265d9bd8590f6767d433cdaa86a77c2724dcb9416c678b086452d6eeb332e75fdd543750f2b4e9000f0deb9266b3ea54e8279f8478d4bda120525d10b621e86e9017c3e0daf0f812f4b79068ac5ec1212ff1e2e600419b09b9a0ba88e190697ae33c6bc6f370db1ca4b7e57612c0640027cdb1beea8befaab65032993c69afb422a6c880ffd572b9b9e27c27f3a33cea5505a1858d5a53c72e9238235f59d83f34964949023f9491c3de8c13450b36b8ac93eb36223f8fef7ab75bbdc82bf21b26a5f57d41fcef1d7fef48d3e83a159c56ea0872520ed791735a238c99964ebd5df11044c778248b2160f5898a087c97ece65be74cb42aa63c9943326117787956b2a47bfeb5fa5af8fef5060136d2c9b28bbce33b2f4fe514dc18309a4ae42add5fad076a6e2d415813744e69b7b302b3b851a8a2a13eeab2d8395983de021b9e8408b197172030c1c79fbf6572dddb0f9240f79fe3565c4d1e953c1152c3e3d1df4933e01405b54745b7513131f24a1cdf78e68b042eecb61d0bebb28447f289a6b18034df3d783efea9b2810c8439eebc3735486ad8d68408b8da472ea7812e85d5af9d77b70e428d51611962c38f878674c97250cf765060c0201b348f0169adc28d7c628cef801438be6268a8011857281e39d7de5cb063808e98dd786e1df055cdf03f1f99a83a1782c7ecffc66744d481b5991f44f0c6adbce0ee220d40df9e0ad1b42f83ea622b5707ee329d623212c020b065bd4d02b8a4ea02ee02a64030fc0adf93854be5e8495f738ca2a2a9aeedfc11040551e075f1d525116f6148819e7f7aef627901194033fc3e03e6f4d6524d426364a8fa39d3e8aa163a951ddc337746f5314e4be1931cb68bebd7b0b499a87fa8d80135c511ca8a0a585090ef1c5964cde088f5e9f4b21191d19f49e52d46ae8c4ea8cc5cf40565a4d90f3c24685683932d046096fb82500d5a25f009a2d4090ff9d9c685569bff546310ec3c72c14d0bdf429452c69b0e3acadb872c7076720bdec7d519ecb35fd858c498a9cb8532d9ad0b1939b3bdaf45f659ff7e908483b595b23bb7749040eafd8ab3e224afe70e45720636ea357e82dc83e420e12b7cf6ce6829d0e4b2842cb89dc4a9fa7790b16581dd67f60bc2053aaaa9a55b9b428493e618a3241d819f05fd56c7096a8e3df01fb13bf853b7cdb2bbedf64ce035acb6294cf5e0d9a73d5f70e60f0aff4f96c14217a94cdae36a0e190f631f6607d96dcee7b150e02dc58cd3d2f202eb396af64654901175b6f2eef6f1aa11c4b54088a110e4ed089f3bc1876ef28c4add208a43674e80eebf92d5675f83a050b1c628c73e42e825fb0fe206ba5bc288b761dcb8f25db6153d3b3d3e7ea29d49e95f7daf7ead632857c6df7978dd3d6ae65e758783b15eb85277e32e1ce0ca5d6eba4999a9e013790bc3c81af220b802ecc7b64d818224a09b205d1bcac158c69d9e598e6d5f1b58a7fc41f8e7aa8e22744e12eb45febb7acb9794fa3db893e1f1ea579315b63f29be7d2e23fb74eacf6749e136334bd8f517b418ff39d38186629064b0ac2cff28c4a7ae2eac1ad41fdd422ca84e1c4b5228d64748c52dc71cfb1427cc58f0bf2ba28e1a3eb0c55fd909a326edbdeb92cfd6b807d0a6330cb311c31d37170663ec8051033efe10a9f094f6641209df3ec777d4bb0894c82a038943508eb2a9c8158a0e2b8355cd8e055f08e36fcbf472c6fe8b4767cb3ebaf9a5217ea0dc3e64d157213c0ff32bb2c743aa5c55553447a63a40b230ff1b905f02dbc11cb4038d5ecd7b3bdd89457b398dab8073a155e74fe9c28866afede3ecab4e178b3a162523623359dd3e08d8ac08bdf5fc224e243f38a3e066c344de0140f19385a9f9541f19ea1f9b1a45439a125c7b460fde408fde2de3f4d521ea0f47cbf7a340251874790eb9ba8306d120498adc699b9cedbd311a03cf594dbe8b0973645eb2e6b3f37d08529ee620c3dcea63a1145ff6292bb9707a649fff73d7fce6fefc78c53928f1a152a132f1c37deecf3e4ea3a30e66961fb6c023458a6db5ff9808d6de4f28c1bd48ee53a476e32f3e97491ebd7bfa75a9d74cb8901f33f95b8e64ad54187fedd6cafa6583d0a075e891804ff0c3f54cdd09988ca1ff1720ec7f77eb631d7167bc04aef572d43d5d47283e7d6fba84610127b5872505a4eee23632381b5bfc53114b9d6acc81c046b61242bec1acec4162bbf00ed9fd92e053a620cfe7c76eb81911aa2b4e5130ea20ff53a9b489ac2384774f7b8575abc165dc16d25173c12e2a3e7c40291213916c4b64eb017cebc81fce668d8f5f919a87ea2207f015e4da1f932e95ea94e1ce80e23ea60f329516eb2271bef990cb0fc68095fd7c912ed49b2e00e409cc23d8b8c5d77dac5cfd802766ceb7a0ec645e587dccc9ab5890c439e615aa60017f1a4e32137422e8e4d3bf8bd07a9048fedf4ab4b605ef3fe34bd89465fb6c87f13be77edc559ad6e9903857c713e8d1b8fe74ed3164d4c94af9500cbe098b887dda66d72173ca384a99cc628318493429496b8ef529fd8955890c4655ef1feb2dcf377e808d20103e4e149f056338537f281290e670d0413c57e7d13cdb2c1aec9ba62e003b7e69e596a890d576465daf8918c6410930d81b3ac5b8a0336702588489b8d826f377c6be57729cccb845a2dd7381ace901d8384780c74bbab8e369b60db5d407d73d005abab9c54c35bc0cd0499c55158b964d0bf734946405c5d9ab4a0befc0df311fd1912d6124f59476fc8fb63ea876c41978581a648046a2adbf6fcdd6e767a648a68901a7ecefd43b26a92e9810356e6acec248ac5104e55f98eb1429ace0869b4febde33174eee8d16e0219d838613b60331efe41cab4a91c2514a22487638e3324bb8ec33987230059f35c4a072f5c3ec9385da3a25302de23efa70c01f11688c0c60ef30a7b0a21f1ad32ea461b6e9791a16828ef0bdf87c568930d157de04a06fc41aa3a738ed13bbc64c326a061d948110bb1a0edb680582dc41a0650ae07ce08ed1a8d562a9f1e6168b235992672779f3d968bfd5fb98898cc5c45370e8c0752f4b79fe69a7fcd089322c226d9783fe458a64866172fe72608e56d0b2b6d01d7703c3845e0566fcb3721b6d53f4e2835776171bc89992e4cf2f03eaac49660794dd31571142c8e4cf0b9a4af559250daab1cb0bae5acd1d5d4d4bea724c5d9dde4ec6880b9db650c9ab67871b0ae6bfce17fac9c8326f94e9ccb59a511038623486db53ec4d7fc4a3c8c412a376b426c75bb65901ff614e0f1711611eac9054cfc3080370eafcfc5b56b208379ae055bc25dec1c66192b069ae6157c25d3310be772f3769b8a85508b4667c26cbe73bd1da0b0a5f2dc50f30393ac71468597ccb7aa1661ed40098f56ec92866e8c98c6ef4684694ea91d35ea73ba694809abae9e0420c42d0b9295682fe8fc26e0a672bb376f8771525cf6f3ac3dce42c81bb641778a282dd558b65b5a4f50b13e5f2d9225f732ca9f8f40d73e63025c8aa954617a0614f36ee344a9e42b695f6547ecae49237f4c0ce3caa59a3da38be83631e271de4f5a04b5e671856ae3257375c833afa415b5a5422595e7bec81b4280b847a05a8bc925b5e49ec7c9bd607a51b29ebb199bf7adcddfb3feeb926cdcb935037b71c30d590d462a991a38bbe866f831d7e17909306914ee1a6eb9cbc57cf13363d013084d588ed8cb692682e3fdfa9decb35c4346d88d059f182deb766a85361f7a79d68bfb20f052ad5bb067c711dec1abac65fd531d71609857e45df909ce8a97596a0b03b191a1d7c1088ad9ce35f9b9832c60a8094d2ffbdf73ecf97df7e4ffdf60894fbeca122e0ddf3545884963851920a4a8104abc14013a6d06da1cfb909bbeb82a87424231757991cc061e0b482e58b870f47b2020eb4d6bd1a5169ec2555e5a7a6bdffcf677fa588a2ef8c4bc8f3c37e75f9a70d11ae2752887381106d4a14f82ebab271fd98de76dd150e68217ea7e1a67cd489ad712af18015fd25b04809bb7b7f3bec1d551c001324fe0c8a37f460120ae84753851d3314164c1fd0651966747d5216a6fcc33b76ab1c077068f593ca0a7987c3be6bb32aa29401d32421bff9e19994da46012689c367f222808be4e27435f4403891ae162a6166a0a9afde4a7032d13ca16e598c5361cb59558b8b9e2edf344b17148e349b3fc191670b67a80a0a04b876ba2853dadcd5273bdca34b188c811763c04bd3ff5186b09363908e77af1f5acb67680ccc95deee1d088df498e5f62e0eef4f09e35bf2df8661509d5b3ff3718cc3e53d5b0b3706a197f8ed7eb0431aba91ecf31f16ec09b07921ed74fb8ba7260302252e955e266eae718b094d7120806059b9332be1e10596f449016443eaeadc10ab27c3f08109eda0b80a402873d06bce22605a17f44a3fad9ff23f30a24af36d0fdb1fa63d9c8d9da26ef756981a112b06cb3a1e29ec16e714c2163158a65f84cd8e1a22a951740123a7b35001e037d3a4cc0ee35e3cba385e4776bfcf8ef6e9c921ddd37ae3426a718b8184cb6274ff0edd67984620a4967d129657da7d2a7ce107be5f4f9f473de21d68f8fa21ac12c62453bdbf4e8340e197fed64f79b675ca126b3fe874d747103dff25328a3b19372552ad9dfc306d14cd725e4da849c472b7b8c3b42e1acb67196d85811452c53389c07fad55cc3a5230516f6e55baac495b9e8c882004b6d44a44b599a4da373f1123699640f116ccc0f26e7efb3a8f9187e433f9f5ca48bdbcaed54e5dc93c2b59608a4d4ed33ed2203f9e6e4963fb58382c046d777f261e28b0c1d5a656507f8bc8e2bdc1ea860d5403858acfcb10a20df5e2e923a54bf4416310845809c92037c070cc1fcc23ad2a589d5e1678303b28e45fbc1de51343a3356757e5362d47823b5c9f1efa3ea2372f75f7d3a73ec615fae013dafd670ca2c47aa8652ee47563fe822160646e73a14054e8c623c8a5b33d7437fab14642e1fafa3ff26ce11bae85200bb021d2d7fc25cd1c819096fa1dbc2b968ddacbac72bd76a7e8dfa2962ec2df5d43457b92e1fd07b723da43c3e0006d9e9f679e6be23651698f450a7f11f5b7366201f99924af6aacde74a93de8260bad86ef982642bc13111092ad7798f8cb93318b87a356ee39768b0696cb5b3f4d7b395ef40038980032302ae3c7b36b0d265d764d81df1d52f2e238eb13ae52e603ff3c9e82cd17fbc227141a2f6a8914107a8d519e68e6f9c04951fbcbb735ed642c1a497132438359f4c0cefa97032a5fc3e8621befeaa98026f2007bb333ccc870fc53f474c47ba1b8d6171ee9e484ed3d64f4eac1886c8afce27a0c4a8fcd2a32f1662bc06d4f3fb03c57c1c4d0af45b1270ecb15a14398f077138deec0e733d760ac1e53f91e175172673d1c40ba59b02a77ef1b880995d0adea6b4eff847e63aa26368c8827522145a5433d825525e4b40a2894107179a34c733817905b98d497cdb788cfea4863530b034d497b3eb7b4bee5a9b10799e65d6aa439c0e52f178bd27ace38e8d401afc3f7ea1ea701b018f60c5910c610cd8a33ac4e278caab7fdea58df42a5ac19f8ea8c59806d0782fdfccbe4d5468bfdaa78941718980ff84f1444fcebf3f11f936bf752854c0f6956b86292464241947d8b169b64b3c68d3575af0a92b1d04705a53c31b9570cf62bd1bfa71d917fe13b3512c881022b9dc5cc3308d62fc7e2f4ed32a1f73bdb7e14c0f0ec31f61081de57ac1a0c99d2551a6b7c40bad51750c38af1a5b9ae793b50dfe00b3f41b60bfe7b5e2f3a6bbf135135af5a1280431e9996d9fb6062d90b8b58121902c16b63e5b47d1f4def636790f10a0595a02a722ed8c78393020d660f14ffe94a316fea2b544913510232017cc79da89dab30afefa3aef76823fcb8a50915a8be08f88ea338fe963d806c2039f0b7632781e027a63aea60c23236812ab57492faab4df9f57c5f36c642ea32fc8bbef2ca6cd7a8a32aa1cd8533e10d717ed390b6374d6a6114392724d672e672d56e3ee4784cb27404a62ec52a9978107de1f41e2dccbc8599308a527bfc7c48803d949b264a8ec9d8a3e2ff1e4dd4642218b3c721ee15426cb769424ffad8116f6b8196790397f70dc07c9e81a4caab4be306c2efca6c4ffe3c1cb12fc64025fbd1747313adc143429605993f5b876506d87474c4d5a8380133df3b20c827a9a71036d85afd9f71a0015864b96eded9fb90216f73f138536dfed297f0887224f39c72c05d1cac1bcc65db268042e38eb507c2299fb0f4f63b9aed7ecee20d8bb96b120fc2f9eda8728d3dc9975fdd9d79906d99b0d607610a20b8bb4b3a6a0577349c752256e5e905c49025dd8e735cfbc3dfecf7d8165f9a762dd64b92e8addb0b6b8a048bde5b8cde5ef64560ed57840acd9346a8b8738db3e9bd4ffd2b95f81645891624d31e9907421681633686304e50e6e882a825133ce7a58b701325090d5832e09840865d88504ed241c59ed07c36f5dfb7488a15cab8a92d142bd71723e1822f19a84fcf0894fed5c1ec7cefd88c0fc263fb4629421a154c1a44e6e4138bc95c76226bdf2bce06c2da57357c6aba7616da762e59798e9a29bc6f06c36113caa778fcc6385fe6c7ee6589fce4d8e527577dab8b5de71cc0b733ff5bbc064f7ccfa2b30f8ca5bfa962042bc871519b018149f13404ad46f24b5b54f9e19af7787cfd3b945b95025c2d0ff421a56ad99ec205afd6c438cd0d6c6768b460a9e06ffe57b2c1f26c2d78b0c4678efd8ef4c29ef3cea475daa4803a62636a58090622e1f329a1e1a834472b616c2c8608be6fb36ead4a9058d0f9b1a09f243c60f5353b38afc0b9cbc12be8381cc6d4d0f6a76f30bd30cd9866e5f2070106563683d8c7e946991acfeac58258917562696d74a1455e788a556360fe7900d281c65d67d92590cf9e67ccada92b9fe702afe5d269e5ce9c5301116fa7b6bc85249881e1f11d3d1add15532f670f795ffb0e3d36eaa940c96cd27158ffc1a31463090d76999660b0aa38ce856fe2b6bfa23e6bf1961b1c055d9497369cf5ee5a3ac5c10d26c8e25b0e43ff5aadd397c24deab83357f5b45e26043d74b2c6427e03178dcee657d7ece8d6efb2769a93e324062f3772b9215b79fa3f88211a6a531e778046b70db82c0d0d0ba9e43a6fedd201bdbc2709246a1c2e31a22a344a917341e702cddc0e0866702faacdb8b1e236097609b7de57b6b58da564804204c80d3867cc436e85f5de6c16da3e2b14b26e25af3a61a70c6e386894a6c35c8faab0f9ea72547cf047663e101de43ab6c8d8297ee230ea44ad3fc32d13b1298308674996981a7e645b4649c1d9f1d7224182c4a1c81158619766eb78c2e2670807aedaba9227b02204e06fb40c28bc4883e8bcd1e715f3c8c9f038f0d79eb4d8bc11641bf10c565c3e3b537d9ced9cdc7e54c6aa7a3eaf272ab625d3a3ad6ad847910bec263680f59bbb578a8f6cb1747753ecb2ef28a77d3a359c90defabf90ae7d1c5624db38a08e18a165fff2f02ee5dc99cac41495f0ea20d3fd75824ebb47fe0edbe3a6e0a2395e8ed666943f22c7a248a1524bb364f1af5a91d44e44ea437513632f67af5e6edcb5f54a5ce4fa711743731dc5605efa0f9056403797b6fb74b59a83bff9e64cb2503e003b018f29614e2144505af44f693f6c232965b2cd8c79c95bc872d53b7a7e391434e816cf17b6f5f06722f8e9663613ca8c33b793605904a7809bf684165b86d6875f71a68c58e801eeb87851d431e99552317b95e9bd4698797b45cc693db49cbcc710ff939ee4da7606bca03ef9efb5ee3330d44f9b4c4784dbabc328653b79c57b12736f4bd0f776b1735f7dfa01b4fbb0af22ad62ac9125e25fb403646b86f2eadc156d7232bc592450f5d5d260bd36d7cf4b3170db189b995b166683b5e6eebda62bc1ef7eee196d8f444b530ae8ee3cb499f9c968f481279f389fef25c527400f0af37604d09ef43172ed7160849fad93632076c936df9ba8d0ac4b40b062730ae6a5c05c82d9cade6d3f2af53fb262fd935394c65164ab06fa3f62840f4a81784d7b37e08ab255ad7f311467ab8b699ef466475ca292cb872881333a8d141a37e6382b2807634a8bc4279cb61936e989e695add796abf23d7d9632c1ff18e49036613156070d6fc2e98f5602f9e038790f3eaa9225e06ddbfcb56e4e53390de2e532123328b295cea1ec66fe9a0519f9c429ffe0ab931a03b4c549d2abbb6100cdc66622569af51f4e62cdc63c770e2e8f78488c5f164d30a8c49426337eb98f8988979b5243a42888250cfc8c245a3dd6e9c8c3249376cb9f0c8f7b71d7f25e7a1f5c72011c17e2c3cbfd0322ce3fdb70fa9aa616d924c7b249c9e529cbac1fd5d881b032bc486a20e1910924ab72a3b84d1974c39e3dc81d4dec843cd0f404bef61b1c10e3d947b2d49fe235ebafb017ea46cbde70de8679c2ebf6ed2a9b60904122729037aa0c4545a5c14fcfdd829ffd4d0485ea1dbff4bd6ecaf81c5113824c5c9ae8e1ae6698dc3ddcfd79987be9dc60b924a44db78810775628ecc3d2a3a4a887ca4e69af2519f8cbc81599a4942708a16373c4986bfb0c7e792a4199fa0cd0c119fadacc1282628df3c7cddfab298ae1703856e7b00a42cce11ed47f84275cce5cf656a2157cd785b7333ae07007f5cade4aa30cc80a48a5144064a0bab8fd1dae0050ab8672f1ab5248b4e11549fc6b800211a8d319e12039627f0d76ba68a16e250c6afe24d60eb6f7d52c061ce469a0432a45bcc0b7ef2dcc31240a5751c42f9f4605ef5964b90c611ccb234706b4cfd90a1cb7ae0b22566a1dca93130c100a1d8464815dd75c955ab649350d3520a4234ede4a8e7397ef69a70a908c6031a9e8d7b9783a2237456ea33f4ed913ad19b374cbca0626927804ccbefa65ed1ed0daf5be9bafb3d98cd452b811d5378cdebf6bc2bce72e3e7a0803389c30a1dc9347de2dee9743e33d99ab34c59cb3806981525d30d6fea233dbcba78cf0a9f97d1529bccceb2e45d5fe64fc2f2c463c24920df98cc27adae694589a267dcd0a6572f68b3956622e33dd94278a4a228723270584dba6d0bde610ed011c79de7cc7052441721ac3d08d1a5ed556af087a96efd92c15cbac7f98ca92918ab97c543a2493cbe1c670d4fd9e6226013c13b52f2e42f232a1a606d9775d09d4ca7b561ad73a4c95c44fa0cb455518288749bc81da48b3900cc06c3983c60eea8c9da1ad7d0e99822eaf478646462e6d0d308f717434c8449594213d4339c15fb666202373ce42136700240a6afd0c14e82455dcf7c6717cd3fc6220864f3f9f75b43abb6fb3cb0b531d35106ec03186fbef3a0efa9b54160cb210f5a35d1293d03f91f069a109f701056b18525aaca6a46b4098bbdea5756cfbe7ecaa6a013766a76a91bdd642d84383f9f259209a1aa11e8aec57b2a38c25bbba161f2f50c3c46842b6f5fabfe9b5dde44064c0539004576c4650ca01d5d59f6ff5e4bc22e272d9c65c81ba5d21bb78d26d24c624ae92364d24970ecb6e523b978f3740d91ea884e2edbe912b57ec4da2dae09cb1025f2680b604cb18e0d5a002e95ae5901f809c4b83f8f7b47066dced50a9eb0cea9b502ed1ddfaa7cf8f526d38c64a06d7ed7ffa337b1c2741447158712492e4b90d74ecb864d7f5940cd2d32712c1d9cb52ec9ebb819fad393376e8533edae594f25bc689bb0194ff8423d169bf0af96d1c7f065a0b4d2fb94eecf4040e88983bc813fdda6fa11b04e5c26afd6b9555f89232aea67d1d40f643a00538dedefa70d92ab8add0228c64917952fa28e22211863ffc577160d32703362892463198f1411a5461053dbe28979ff225ca8e89897df96ead4b76b9e636fcf94749a8b0b1ad5a970c961af3fb3e82a045b6874141652f4f43dd08db184b2055cadff03c108a6eb5de609dc280919af13e705a5c1b20fa6c2c8981a715441d47a18e70f05e253e31da9df7ad5dbce268efe9645d1d0b54aebde0d1c745c990b35a837be5c61f3522778a9ce99d91a9efef1c7b30026e22d22d89127722fe0b1f5bfa2d9543d2146a7f4ab0646901a0a3f7e7f43f331bc0eae1f2cc71bb6855fca59fbac976fc826e4200f471394a1dfa728cfcda966aa0f87d7c73e211dfad0e4a7ec8aea662a3e68e9112612397e1da7ad06eaf00b28ba38fc8756bf069a59938358a4087a10cb45fbe5e2b4373c2ea3971addfb25c696c5e9898095bd2ae87b9f2282aaeef25b7093387aecd6295442c18358cf19a643665a95ad013a7a775bf41abe5cb5d238949226a836df1e4eb5f73460ef12957e4892b25ddbcc945d9c347bb7ddecd213f8756f7df250b96782df69e60df828ccfb79c7f1625b34aa08b5d041032e9e0013148d1a883323d2c22fa7a330b38c8abb0f7aec466edd4cfcc06a82d0a5f4c51d078709104a7e1188cad27d2d1583c38b1982b8c909262077a115371e8a2e68540025dc6916609a3ee1c80e1299fbdd9263dbcaead474fa29c5ac660dcf744a549fd295b22e213763c9083f5629b467a8b1cce278bdd80d85755324a93c13ee064f6db150222b8e57ce2f40db3c974f53c68719e7c81c137586ced6437d11cdcfe7cf679c738a2e2b8f6872f86a6fcf53dcea9e26ff3a1953780548180a199fab551580a8225e78e9bdb544c1c526bd990776f8343ea8ae3dc9d979dbca440cea8e9ccfeb6d3705c267b9ec1e38863a3f11b14130575cdd28633c97f53dccdd1f729b8ac970dda2e7678d31ec85a7b4b265b2eae0afb354ee15c644cd47cc2c0c1ac29c4dcc0927e1b35161274d884f3ffe096316c7986573e744b6eb86f6869a60bb7e96c8502ffa67db829b49aa6be3419ba3e4689573ec93e1a6e26ad27e7dfe976b1b40a01f7e50de9129e81958883b74d4a08dd8c441d23eee8339ea0af4959be7b4a7a3439dccde4fa463341005767a68009d42892075c90e80304f1aaadc7623702cbe1d20b02811a2cc2d55f1e885e059fd3689804cf6d5c21896e33e0c45fc986401fc64a9a3daa7aebc508ee74d2fa6616d54d651efb76df147ae61ab4e13865565b05acb63ce893c11e453b264416e9a2a1f708759cbbdd596cb70035f0d96b3d9604f77919382c744c8cc2d049d56eaa86cbd7f149e4be2722fbb7151be512a8b9ac72da80354cdec0ef01a42339593e655706a57e2168ca4cfabaebcb8ad5eedfd28f8744298ea067348037ab6d6f94dbef9d3cb41946b397f2703f8ce4bc8fe477f5e34deac7b52616bb21bbbcf946c759ed75869d7c7daae8c3645fc4dd2107cd160dbb474521b03d1f682082d62cbadf4f9b3b501504b0b4bc183a76931660aeff629e19c06e27e2dc9f658806e8bb729d61e635173cfdc0bb674aa9928fc6584171e69d09ce0f465008ea2ebc596f4e65af2e54e14f76e82b9fa4fa111c7d87df21d0b7a5fccf47a04c688278b60603dd1927df465c87a930771a8b7d60f2f5bab28eb7be1537c25225110570a6e25311342e37e0e3edba7b8664a4d00102317731bb136af084fd15c57a82e7ea926c3ef6b338431bd998ec8ae1d19bfd237abd8b456f1db1188f673a8ecec9387d1d9e77425447c10cd768363dd8a2602f17bce304546907b9c0d771680c13338780c9bb6e2a6d477e05782b4a3ebfb862f7abe8b9c379845a717b74800edff9f31013c8eeefc511ea645fe1bc1d9500f48bb908755c2da03bef53762d6889107399cec392ae1be9f44e9d14ca8ee6bee12cf1cc8ac04978ee07f5e12e6d76b9d6799e0e014f7a6a678e950d6843ba1b732ffae2f09979f5692fdce702d211b89275c23734fd2d0fa7d077d802fe14b0babc29a68c02f7dfc1944dbd144f0a11d3d3d3bd9ccda12c980e3e0086e3851b86a8a4da28d90ed2350020e8cd3b74c40a08a31da6aa6bd7d9df728bafcbe88d9156d51d142dec8b62977e9cff17c9485a6a95f4dea92dd716d1c197f49c3c60347f5a307e89b632589d07aad65f87f58e7cc4e0e95cfb2f4fe72cddea87d4ebd475a045a2d6c0cf9a84cb77e7f0c351de152210753a145d56ddb9f18034e824c6ccd77dc11f521851a66c77b002ca81a16b93288503b6c3f998a67730f11df3ac8466711ace48f7167d963be21961070d4f27c27ce2fd7436a523105947095a2a73d9bed14d3408e39edf41243a9dd917c21621fa49ce7ec282e637e1fc191177b6a47ebea67ea95bff1553013e459d70cbe5148d6827735d190c9d725b9f12f2ba399e77424b1a4f5f4351f6cd04cc2a365a5626a7d16ee02b4b5fcbe39404cb4dcc7912357cc81d027971fe5020ab86fe3158d58b8909d141f1f9dbaf8fdb297370bc95b25f81647042a2063761644ad8803f6a2356b8e93e056e05b67bc20ae7f0545c2496f57fac45ec0aca9a65718f9773cef282aef0fa04f6d8232a6d7b19f1d4b3db77da4d3591dfdc3a65898e3e7d752900f6d103b210fd762be37ccbce4ce7bd7eae3e1ee378e3bd5e3571c4f97407d21f5e2b6a16499b4e584b53cc383c3459f4ab060139da0d3556955da2d624a405cffd5025fc4dd3fa75a992a43cb9cfac22de83c22175e2f124cea343f7cd8de70806b4b05e890166d9d2ef0cdab9d7ce58fd976c1668f6cddca83b0629ec3725f3b3860acb2de7178588ef4ab46a1e7c7574a5b0b97fa95c953f1e8e89e9d49275f4f281e77cb360b148d6527d13e6a5125083c59e85779753a49ef2f414651a077de25289d2f6815e3352b5afdb64f867df1da106e92a7f5116cac0a8952397f4c083601280706f334572588ae4edea1b6c75da6e6c8482fbcf3e238ec27e08240f55d0d066c297e8c8c652e21b4fca6c8149ebcc846493b8c2b1bf3841d4057e1087d08421e312f16f8a67c1cee9249b0072d9b826f16a4893427fef716866d5ba838e3e00984137a1554a51581dbca0f81ccb22388a33512d88c9fe32ba428e74532fb11802a554af43bdf638e2ba0b12328a84ee0a330c1621d8cbd2b65793294d9eb863c0b16d88fceb1cf5b08676fd73440542641478a09e21effcaa79e1d620a51645cd799b10f60f6ea72d3dba69cc2b0e124fe09274d1b58feffd6fdf671928f294cb401bb0f7ea7ee77c01389b71f4540a55b49af5f79874edcf2d7a5975cf5e92f50cfbe289dd188c3a233e9b457cff444e5a7339f61bd2b62832fbff99f60f38ff1c262a5c6a542af8f9d5a5ab7587db5c35781e8bb9ca350121ad08e51290693a0f59b4cea6fba115a76474e4ec563c5d706993d08d0cdc644f6bfc3925e468c41d5bfdc28efb1e90caaca683ee57c2414a77e1c2ffc63281008d31bb3500e417bb241783c32c34f4d5a9bc03c34c743843d2c95ded5f13a48fecdc7cf73c1ad68861013e547f79cc793ac7757bec7327a64b22fca7aea94b7a209fc902f2322a7a6f9e3ed02739155191c6105033a257db7d834ec04321909e5343b96c1608d711071d48d3f0b3b7ac1ffacad9340acb176e494dc851f592769fdfaa6b6d0b2664d70daa536f359414cc99aaa84735b7f3f9320a4881e85a84c2b5fa0e8d018386d89b00784339fa82bbb571c7c99db7a48281826b2ab31169f707087fadceaf3c68fa8540ffc7d6922f7a6ac6200382217016103172693ac143ab7d123a160ac73d1c3af3ec86e3a4ba010b60b90a5553169e634219aaf1b86a5a82f11dcdac1b1d0daf047c163ff739440551f9805aa7f24a8f26589407c7fad6aa01760eb0aff855040a2d4053462359fa253aa8734d66de840471d6e79b9d87b7fb890343d89135239793a2124e52be7b7918cbf909e65de7e7996f3c3e34f0c2749a29aacfd434fbb89f141fd18da41ea8e81f3e7c1cd0f126a945f70cfbf3dd3650c776bd3fa5f3b6e02ada41fa268b2a0ae3534eaed2d0f4b0a8ca0ca69bfc77b2536449397fdd076c726e78cfc701bbdeda90b68bd18cb735341a59ce908d31a50918bd6a6d8dd4a000e3f71271a6c9c40ad37676f7dc37b6a8d22a55c90f54d6251237382b4e5ae3c9f7296a14f5009cc966526e5402bedc831022515b48fbcae984baefd505d66ff35d8baae1fee02bcec1ef368d4fde369cd4038a824f1fb950e4b0392a01c33bc3f956000a5967c260e96c55bade40afec8c290e426b4bcbf49b6699eae612008e5474d797545898c00337ae3cffbbe542c7f9d3755f1a46e78501fc55083d10230cf017e2a12c13f26a7b9a2cf6d5cf25cec121c627e830abffc51deba5bd6bbae3c4b69e6851cbf34bf1257e9a31c685f1cfa9b796e75e7edc532a064f462ac4677d2d4932b8f1d5b9d4ee6bcda8369283a37749545dd4fda87aaad538f14879aca49d021f13d46a299dc1d89bb1a54cfbf09cbd3d9d1454054532ca07ac7e2971467c3987cdbb186d993cc4764cbb76dc9be7bcaf80fb39247c58f70875b5b7cedcdafa6a286b0fb23b0d299c4900acfcc8725b10838766f9511155becb63d3280fdb288da628a6a7dd380f1803bd7c5285c6e7bf5ea06d8ff17a2b4aa7617043e8e6fde2a31426b95ee7dd3e9406bba2b0a0333760ff33ed7a92aacb0dcfa4546135df754b30e455d7f3ac8636e3fa701175d6e2adb71d2896e47cf31679add6d37d404ecc519fcc08e3aa2dfd5fbf7f200f59a58d250e00e9a2dae7ca64db9b5b76534b23be5692bcd8a4bf508d59694d3ee2d3a59f43c6c69803a1f5aae0505780b7ce56e3f17ed6185f0b881a143e46f8e28e3281e4635fc02bfa4e5cf72b7f4e86969edab371d05d96b2ccfda82ccbe0df844d7177750d4f127354c332c2da827afec920d8c5107fa6be833bb7f3486eabb99fe0cc9c53ac60bc79008ef1e59aa3546ab3add210769fa84b8eb73fbc55354861a4a2f6d4a8b09ff2748ac7c809b5378b83be984a7c20f71f585d62b890e0ddea856608329a68db55a714a636498f34988900f981d294716c44263ff1f410ec242ef4675b2a6e911166e3629f3ea0d75495e2ac2f3dfd1f44a74f1884e70e375e68d5008e0a45ab97daf410e59e463717c21ce98ae572f6359296cda42f8dab4105eb37e6b2fc91814c471fd3e9d515b63faa736b70844905a92c93e4daf04a9af0311d276b2ff451db336b528c3ab4558f686f9ddefbe7f535d3c93009873f835bbc640eaf709193628c8bce6e11be582f04cb974e1d14b527244ada1b7655492bb7965a875a97a6ab286fc874c9b1bdd90dd42c2362038a37f9fa389dc20af291e9e78abc73cca46e681fbb5e50e21a3f9a76d108583cb328a95ec1cc52fff79cb16e12eb2448104f6648a4ba5616048e31492bf9b36add2e7814e2394b814e3bc86113ab9d1fbd78700535d67631d80c41be1235dca6ba126eea8e396e7bd5fb689c1eeea2a27daa554f142ae9f6522bd6e425e703f57ae3509af0f04103b9329006ec8a5b0127f506a93a3028e3766b73ab8af52c92f1a7493b35dad5e0a3982d0d4fd090b80aed3ce1599b6e988ec60707c0f85f49207df7ad40b6bafffe19e7f2d08b3046e4711cbbca354f158fd743308ab9e40ece65da025c65439e965cc3a35751d2702b86a1ddf481441f057d0b724b319fba513cbe413e974d6b9a525e0d81fc5cb2953774f82a71899a60c546677f2ce4e45374cbced987","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
