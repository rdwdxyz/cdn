<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1639b829bde7907e80d334b0d95bdf4736a4d809283dc1626e94a4dcda48872685a504e91e265f87856daf5a543d3a2c4f5ab523e8e72429535e4b587f229c17db8c8e23f7115456586f9faf528c68a37f26e294b2792f82fc9e0846573958c05df19afddab162e61e18da21069fce27f724017fec8dbfa2b3abfd0037ca9fcd6dde82b2fedadc84aba259458c412ea1c0b765a0a1c770eb333b245b1417d37fd7120c79864644458d9fde8501712e47c46094d4524cfc09b59378a5577818a5a6ff063eb5f84f1e85bcddea8c276bc302910fc5a1d6826121559dac560bb2dadcfa5e39baa36479a80fcab75824fcab55a474151ebb8b7c8f2becef19192aa956d92d6c6a2f4b567b9d4cbc219d0723f74c54ddd23095f56a84a776a548ec3947dfd7ebfd1f754bb53a5fc989683a250cbe36d64c13b57f7c3fbbeb6e20b4597d79d577f8c9defa043ce25a8a1e3567bcd391507a2104feb9561e1dc4d26bb189a6cc6237c0502ee48a645ee726c97ad6e344e8e100c9c045343bd771e77b8e833349bbd5353f2207d46f5092a81bef22ad5e0cbe1c1ba4f995b7636c3aaf9bbb147157ba06b50d7ec052c74ed2790b6aebe0e1a42eada2bd722d3709229565ba948d8e2a5c34f45f8f4da5279ad4d2679e17730cb297e7e3a84c55e1f46ee90716923e28d77d9001068b738be54ec2da3d886b8de689817773509d290c6e0bda07fb9ad8a19f8514f2abdc9a86d939e52b29850e1a43eed6b7d51984cc460a51a10f0d32eace470e5a186fe887aeeb2bb91dc1a323c4cfdfa1754f3d99fb13061b9e5912020aa65d769e060354c602eeff7901c8411e17cdbcc2e2a9168525360f9e45cfe3ff82c43c8f332e854f546a70ac7f81e7e6f849e1747aed5da42df677122df592b43fea08d802eb1e1a6eb458b841933afc965121927d56f135dd265b3babcde57451b41f08fc617a037c3a133cdfb7a9fef1a11f02e30e9eab0b09c2ee4da246458ee82bb2e6c28fd7616d4611358fe4ba977cb3b401fdf3e3970b9a2c762cd056c6c3d53172610ae5058e489f211e5e6480d9704bfe379cc34aea7443e7b1f4e9b673a0e38ed78f552a2fb13af3d6c209bbdf15ff537a9bd628f4d542efe710ea549998736c67f13566a704b9f13f10325a4543fb820b2364d77f420d78dcac84cb404c275444879eed953739750ed7863570427968739366e324087948ee1bd5d36f9a327f391e7a748fa7fe0a5ec9ba3377c49d3a861c0468f0e3da20f4161fe49b1e3830d0bb3454b9cf67ef28c24249fd61a1d29df61e10a8f087dee1fb913b582280120e94e21dbdbc5609d5791eb4b165f9fb339fbead2a1bb08b93dd818be38d52505b5bb1c472a06356d003d759402903f1772b5224fae0c046351c8b138c1f70354c3d8d23acffef79379955f2752085c45b7ac66e2c0a938e9caf513f4d8f98fc257ae3800d25e8e48426349d46ed0119261184020a3a5544f10c9a5aa49123f97f8710af448d48fc55ba134f2ac992242c2459000470ac6fb126bfaada908833fdba78dbfdf094b4aebcdb25547e289b9553ebafad46844d88938f6c18d5b36c49779422e3d8559a11f5a59fb03ec9b87b2d24e4f9fa4aaeb2f85577cc0ff8a37c6f7dda380f855c60220c85e4b5f915c66c31c04665d1be6902767845dcc6ff5571f77c395e4e1c7eb21e2b3b4391e8bd7c0e41e77e0be68cfc18b6207612ed11c38aee61944f2fa7ac2b2e749a1d7bdbb86f09db99ca6c0e1f42470211b47d5fa1a1e2d87fce755d724bd34e0939990aee8e13086ec3e84fa402f5d546c26c5a4dfb5d5078b49aaf1670b912ba6219747a4ee2016ff3abcc52ea3ebf332803342e812a4e8398cefa2b6465a3f14ae2436374dc39bef2b6fab16c3b19fe8c8b9774dad981e634cd389e56a399cfb0e6b66ef7e9f2cd27bb255b1cfcd25c56bfb3f5244228b11809d5a5b5960e931c15fa14be9899bccccec774d1d6a838969c97ee6be494e7bd7aa9f8fb5584b3c3456371e6e42633f19bbbd1e9cba757ca05c28fe32897c5237cfbe1fab10644f3f2197aecce7c92046841e1db300e093763f3a408b26b77cb1dd1883aaab8b971bf3493659efa4c09dec810c2f8b78a22598ab27f9f6a51f5274ee2faf85976ad5ec50211ec5505a864b1edd445f9a7b3264d41f85d60d79d72a380e723a84cf906f6a193cd8bd4821fe961d0fd4f8f988fc9ad8e18e2e1b5eeb981fac2168e3698a54c3e52fe38d34cf74662cc7c11605a7769018d9cb18055c4ae292d7fde53fc484005995040e914431f2ea20cec57cdd392f569d313e11910a64fd997c025ff31c8ab904bbd3613e024ea003a428f587ea9536fb43b39f3c98da35566ad42aac082e1b7b0c7b63efe754b08b87bae1d8c332d15b2d2212a96618117a593e6c3e3ae97940d45e7f6215f5fc4de903f452f953964708bb1b3f2bde06514f0f68f620e3d1ea73138502c28bb921dbd906f69805179381e532c2f0fde8e2718408bfc28648d89d36123e9d3da524a438d43097b21fe470f4be50717bf9b3b777ffd249f728c36fa4daf471e10e96299da43e8527e360bf77f7b36141abf87390f6282d565bda7eee03842fcf5bd7b3c2067d579ff72623ddb7b6324ec4a2169ffa1050093ba2075638022313bf8baf02a0af6ff83010f7abd5bb17c00f8a37b6e21417e0e3047e3e8aa0a27cea3b8c40265bcd55d4d028bd55057af02d9d7c2220e258c84284c0a3f4544d99e8b22259c481c5b17986c24cd5d5968556939881dc8dacad3ca12d966d1496f9fb4f637d675afdc7465f5ce6a0ce61250b63c59ab846ff7ea029ca5fd2f095e61222b0c304060783efd4db12bc042cb21f69e19b485dd3bc14cf7f531b3ec9195c7e6ed1fb4d3181e9ae5bf7e0a536ef1ab0fabb0e287461ad1e0210a8ad7bacb42ad9b507ba6345d596cd6a54de1e2ef123bb92f92be260c398ae8ed34a2173246cc372a0f14bd097718ec6243fb9073cfc688e1b2b319db8f222c75812ddb4106275aab799b30c730a4e65b3f814c58f93f8b62f935a5cd2918d9015a57b9d2a1eb0d34d2d0fdfcb01e48b1474b6bad36c3b3c5c7df923736e18b445bac9d9e880b04b98065fb06331d2ae37d576e98c9a086ebc44d9cc27ebaedc71424c80d023353ae422896b16213cfb4aecf077d524b58d257f23b9531006d4923ca80ac735b3cc15b80dca1205e4793b93468d6cb6dc52f0de301d3645cbd89476a3e4225793cb13c30f46877a58823b3d57ff8bc0c9d7dd9f9de3f862d5200a2659659cd4c2728ab8f735bc543e2e7014e30133467e36815a7ea1dd87bc33fae69fd09811791d873c2d843997112ec4cfe27df75c6e14e83d79e9761916d0f83c340301bbb22faf303940a0171f6c1a0b225b75060dc231c05edce7e800a2f854c768256bed385389a66a2e9c7427edd12366d6ada45b9ea4dbe5ec96aa6a4634fa64b5fd79317a34dea1db3667fb8d8d77333ff20a69fcd73f131d53654be5eb1afd058b83d9bd242435204e9c33b22ad03f7af3d4deaa4181fab67665a11c9965a6a5b34106370eac5843931c5ba22f5224e6d77f19245fd462fe30ff94512f0a5a8a188b16766b20c645083aab9d414f3a32c3bb061bdd9e86648c3f19da8aba8b32326475b770131e31c37e32b814a250a9992f55f68fcc07a87ae18bd44a8f4ce64d47a65309039361c0fee9020b1b98dab9e93c21f4d689f5e25efa938f9870ece3a12b2f1a7bb033dba8975cbf201612591f0002d489288a1fb476e658a6e3d34ec6e265f842bf5891d0a4c9a219e4a69972b06a8632638fa1b7f5f591aaa7093d09aaa65f059f94603643209a4a41eadca6317fbf4614fcf6eb635bd0ed790a0b0a14224b7745d8d00187b4680451e5d8bbf243c2b1a979a2ca8d8381d98b1cd03735f02a810e3578a3b5957886e3d69f9fbf8472dadaf76a91a567a8e07003a30da5da4bb509e4d6f3a51dec3e8b300c28632e3e8e221d83dfdd5007ba436fc2f16f43f07d8ef59fb05efe9b2e1b47a0ae0508d3a3b89882a1945ed8bdc7ef2057e96b32bea5821398ebee28914e394508a29c9c9045ae20acb14513bc96222ec2b7e317bf76ff756c626c89cb2ce9d736f17e04bae350c7c3e6336b4f03343cd8e1b92e95b565aea07bbbeb215e56f38330341101a396d5ad90ed7c942fd2299c9a4628c0a22666a8a23c0f6e5845864ae45df748458bc337c08f1a0d73b8f94744999ca44590da6630f3132de346912b6b2ad09c05a0e0be770a70be238359a0df44ba3140edd9c0ea1de1ed9fa047ecb56c556db3e645fb0dcc043dd9a62f5d59f1bef087afb8514149a8f1198bbe0ce005f95d7e933829455f9534bdfce6823a363a1f0af68ef9beba4b89fec8f86df8e0ca011230f597acd75c5bbadf816ef9a347809f71b4fa3b1a37a940805af0bf5ef17332e92c5dacfd56f0d5b9a525c5582eb4733f30345136f577ea1178f73b31c70a19f04441fd096b18274b8f76e807f4a7c9d11ac652548aedf08747d7d03e8b78246e98ac0768c41bbc6f11e8149751990bb616e09719aa5fd3e1450e67a11ef841c0443931a1f29267610fe30a2b4cc97fb6b6ae1a8a72e9f29835ee03600b5fde153d4b90b8dcc9bd1176f3ca5608c4bb41c74b91213bc5a0f5ae87af69eef832d1c21370491961c72acc83f8b7a33de433d0af3210305976f0bceda2a053a474afdede07df4fa6348035688637c64bbb0a13225da5a7aa0cfba7c80b8b52c4841506f59d571005f88092ad134f9a57b132eec57966c15d878333f22eb096efab5a2d3ebc03dc8ffb10616ae340c56aec0242fc11acb272ce0ccf7429dc53a4a7d9d47ba84d896f2a1eb1e0fceeba7da0c4c82c731503251105ffaf99d91724afeeb40954ca97f8c3472620e5439943bd06100425e0e3b21bcbba9eaaf7347e612b6206e0830987d447850c0cc382c4a512d2c3b72d7ca49e5b0634db0026f66f7e174073504750d994f45e024187dab994c4df8d986700971eb8c348bb7fffbdb61ad195c073e4f3b0f18051c8ce88b76b4f5663d56c8535df65670c939d7644e482a45c5a674810796df6d6ced9b673f3a8e8ce833b879923ce28362386dbfb2c7cb670b4967cad464bdd0fdeecdca7492b51ad5b39ce39d8d7b372e0e3873c21fa477e4821351ec9d80d16977ddec5c91cb1ede2e841cfd31fdea34df3b0e83c10281c5e38e9e2dad634740c4c42c514624030b20bb9bea47c22a62933f84871c9b38bddeb6665a8e4e4630e372956f59086eb006d570babef76fb85c4dcbee6a496d242b41cbcb611b23366ad9bb5f13ccf6346dee8e08c2a4f5e4aa7badeeb917edbce4efbdf3d2ca559d06f0c4977e8ff38ca10eb64864161d6f191c6b24e83226d41facdf964fb1affc7e0a03c860c0a9912ef565145249dc6c35a29d9817ad033782dc25218d1298758f5e3b37703ba8ca0a71d1e9bba35a030793e6ab71e0305ff644571a06d86d8298e2bf1193ed4f05a51e4138e152b789e59e0a4890394510d5c427fba22df9beaf711477a77d1f616620d138706d93191b41e3090d1f6785b32d195019b72e6fb5202fa5782cb692da7115e4dc240691ca090cafe70b1c1d335fc2a485329df584d6ff729691fbd5eaba2de25db477c57917daf6366bbf54b00b4e1c5c6a44d242a4e4c252f275c1f01bee0c4ac431e8b7a4c12f3d8985ffd840de99bb7da712e4dc277d21d95d346aeaf2ce9b284e7148c236c3593c6eb317f6842014474e51d14d667b1c5f90ab729e3c97738f8bdbf1c5faeb33b472ce3034e11560ddf78dd42a293b3a45771abec553df6364baff4b8ecf4876fdd3d0c4e217a7fb87c58410282bba568f3acdeaa1aa920d9068fb203f54b38845af771d8f7a4906b03feb58b2f204dcebca806ad927f04dd9e098fb704ad8b038cd94c9d96ce81c2a35d99f9d924c632e1328bf202ef3a7b391dd198e08beb0109c9c7aa43b8514febe73869d14a401a23fc42fbdb64b142d816f31028589ec4b44c3eba31a3d4b89eb5752524187ffa2d7416f2c0244231c1d85af872cc534f366e5c28b333bf31a1a008c05e18505d9c71454023c63318b9d5ff74b097923851c971e4288df73a07979a18d9f362c5c97b4baf54968c10786f90305eef45b7da31cedcb1ca6a2c6e83282468f3feec6de068711fbacbf3adb241a87ffa50dd3d3233a1781df3b0629950efb0d690213a72688d2cf1882cb8035d021606a5aef49cb5c785769161b1c9e5fe48c9d943ba7103aeb5e505b85600cfbe5d889ddaccbfb160268016f5a5e9275ab3ac019c6350fcd2fb1e790494a1b800dee7d45882dd46cd04772e95a8a7e8267ea49d2eb1eec078a1bcd2ffcd1f4c0f0639d58fd52d32bf59ff72bea6889064105f27995c9ad9c15452406c5254468ecca4554c193e6b16d8d184d08d3351306db0bf5b45a751bb555eb8cc8d7dac982efaefebfc9efdc9825d3889f808444cb815771a2399012b39b0aef3087a73bdc74b365779dd9c22ecf5fee895675029ae8ce5aecc3d844b4a37a425b591cf2bd31fb62b8b63cf5c5da91d3e77663824f99aabafc2f42eefa8cdf7bb0063e8121e1101847ca9667ec21c7b3acb603275564fdb64822dd9248d2bb82cd8355958800c19f49459e5cb2c60ffbbb98ebeab0729db5f62a11a0eca53763df65841394ed7ec32225084b4fc3df32ab434d604732af43bec02b3b3860f421b293eb3e339e529d5286c3d8989fe2f583cdea8531330bf6d7d18a18eaa27184d56bd706b9b77cede85a9a7fd790a06cfcfda3d151f0fb028dce06533e2a3c1d219f88a7dc6f9b693e827e2789e1463d54d7587b7cba074397cfda672e9e75e08a3ac6054623768ac746c0bf09f57b63a9cb446a25913923557548305fde05e3a9940e0d85f640660299acb2e31f2e72ea1586c955803d6c069b3ba940edbcd648c085c740f284a0a1d0fcd5eaa6f001313e2a07b70ea5d2d7f9cb05b4a1f105587a0060490325fed39007f16cc9fce5e0149774fa701e1c31a9cca60ec40fa40ab72b208915d0ef13dbdb0c0b0b97283bdc99d7a68b43b8a5cd861c6d8487ef7499c1c5d3d2437fbae137d23658155fed2938f02f124b987f3a0d39872d1665fc692815be0428be49716d49e45474b42d05deb236559fd9fb51b7baa09f0237cdd300f2f859246f6ba0163e706382da12fdadafd723806818a6ca7634da91090ddb5fa9426411f67dcf82e58f98d475a36f4a2aed00c051fa70fc09445fe06aaa285aa7366f20193294fe5dc0db2ce856988a6fdc6ad692b31ae35f72d7263d7785d80a72ed85b01d17adca85cfbd9ba032d1d95286e2a0f19e3a7795c724c3b401f9e92d5d830e94780ce6d880d14da6d137c54ef759ef9bc6fdb8381de9425bbfa97b900ab0f4d4b229a78545869da9de1f3d63f27eb75fa48eeef4a61c68e9351dbcb8b2c74c04144c125ce3ecad4fc00a7d243ad65db5c709e8a8cd8b8bcbdb6216365ace0dad3bf7380da9793649cbc1eeca90f151816bb782826f932bfddec0ed68337e1b60dba75fd2addd9403b163c4cb8f59676137dc70999e1401e23fc517cbf00e61f0de49150c7540875062bdc5e1f043b8ea87f5e4b9a824c39c80d5e7054910769dc25b236a7e7b632db2fd238e161438d025058dcc4a55f71268ac4a2ce78339dd25e03111103812e9765dff5a2c3bcf5e6d3b75b14db5af5c414e9f75829852df5b0e6aefdb785aa32b00bda1c57ce4018739e4f237ded5f95d59188e8529702a34cdf36c1dbc218fd9e632db9c583ef3b36fc4ac5c713138a995ac928fd64bb605e734d6e46b72746ef84772d749bc9fc3fc22261d54c6dc3abef7d9fca7ce72ec9f1e1426251a17b7acea36b190d59ea4e2e6142cd25857f8a0e46523789353cd7ec355995556e22de012f3da809399b5ce78181f5a2076ac8938efa24916a956a3ba321e5924b39d4f64ea709b8cf67835032a2e1d9ed79ca4ebc1f669da52e3fa9faba121b736fd07cb6664981481615700c4abfcb3887974df789e5cb68ebf48f7541b75dfabd5aa9ca35c61116517a40317f770271a9b160e044ba92aab25414a54cfc98bac2434312731fa2c7095b3798f558b18dbed70539e46b53c8936f02d2f325eb4cf9248123f2c569c54e880278bae420f906d0a202ba9ae494245a293fd4f5330f62a8e62019fbaff8b3e1d465a1970eb79e1ea8c313bcb7cd4f7b5abc327f69da9ec87ea005595ef9c69e29ecbf069bb43dce8ac67b79e13f30136cb028229ef3503ef7f7bbf3f96c66fa3a263ebe7a0f665a2914ba0d999322d1b8355750f25b73a9bb9e2b68ae29a5af7e61dcd654fe5abb2e22a4e0dbe7a58cbc6eb891250c5de9bd49a5879f84e2966b03bef3381804744bf159215091ef5e04098e75ca4c7fc96d2d8c0035c48fd1a3b487ec6ba3273422c242098484c3947920ac88165ef30a654ff4220f8cc781e0e91a563d2e3328f62b4a84271fa8d7a59ed8c5878e2043dce1fea34c5e867625c478b9eae5def030be6399c061b93e238b4e229762adc3725ae587c6573da7ea6ecccd14c7ed8a0e3d8ca19a363b6eb4044b091363b2f558aca3ead08aad76ebdc39ae4e27cffcb36dde253eee47fa8a941c2009f1b1c782265eee2153872d7d8a1c3da11a6af2d462e2b1449e89d32c6c99485a38d442d8ed48d991334eb45c6f355b2e830d3cc186f0916d3336cb1c298877baf82cdac94ce7fcd480e74632b1d576d9e382041c671df2a12f9c5c1cf6c07416c9fcf359e2e80b1cebbbc00d3e2bbd621d928021d87a9637e22c04e5b41b652a04e93f9bfe952675b40f21e22a3c660f06b72a4132a7122b6b2fbbeb5cea1b6003dd970019addf0ba8c9ae873452bd42bf8b0ec7ea35ce00885060617e81928cb561d2d03f540fe6180ac739c99603d054378ea2d400cb6c24c9a7085156b76059b4ccf48e9f0c34a74278672e80df91988ea87fd780891d4e50edffda581193734af709532d95cff1cb5bec5931cd9c11a5b0297dc2e6b9a7590a495c46c0c356463ce97c67393f5bdd1aef7116623c8b2d483ec678992a8bb55dba1d05509d6378e31e37283ffd6f19c24efb40a5292e58ab235d371076006ea28ab2d7957cb5d69bcaa37f3ef4c10c5d6cfd0daac2201d5eb2403eaafac607e15a609e2f1d3ec181cd25c616ef2d40ea7599e4e63c9cae2f6bb75b01e74cf0a26c981ed42180581554bfd7a11e7e7dd5a415a41cd398f15700013686554df57aec8d8c23cb6d943a612c4c38a7c12417e5b7129e15d962e1e589f07dc650ef4b6f7a2c056d8fe922b9c3026724fbf8bcfb28d646c4b76dc95d00ee587a8f54abfe0000128a0ab346dd37f93c072bfa3313b2d5a614b838f16673f755e784897c428481f4f45a0fa1f993b54fe1874727d575d54508cf3156950c7fc5ae5676a42fb9f083bcd96eab4ff539df9c8a5f48f52a1acf51e14403a468c0906aa3afd50d6a6eb1b250c07cd49e1d5c5fb6652ac3de78f2360ef3de5e58cc6847c215e631d89142466919d3363f0a12d0d87ee28b1a6f8f8b23b110ebeed801d1efb7d53d5448aaab74e97bc138b16ba35510af6d919a2916adbd56fc2c59e8b5a44f3063a67081848209b9d1b5597dbf2ec0a00ab127f62b41d096a4801157bf68e63647f848bbab1d179f9131f73a8d9498573929612d4747f215f14ce7b4d1769916666c8cf9f291319799379c6c7e0c0f23947eee5cf2d655e7308382cec54d651d63660fecce06fda0cd5454f0ec9f5eab2b3eaa0dbaf5055c83e867e6cc290648167c2d3c201ed6d99023e66cdbfa4e2edaf406929cc85c65b5c0f1d55a6d60f21e1b13fe6a664db5a536cd7ad4470cbd23f569bdf0338fafdfacab7574033eb64cf1eac6bcdfc6ef03ebd952757743e9279c6656dc41e84a3aa7c107b624a5460aa55757f75cacf58e70f8cd641d79c6e48cbb320b80a52e38c31c2e44cee7fe65d6b768ca342e518a420bfdb8e31765492d105642fba35ff04ca10948216e5270e78c062056e28c8a06136c2b48b7344d2291c058d49cfc7c48de9bceebcdf9fece4ee993f6c126446a5873408195376708ba61a63157aed2557e2ca3b7b07ff82653410b292b8cb1993da11be4e75f827382b000d59a36fdb5136728c6e0980169aa5d1e3d19e4bb404d28e2ca9c0edf82d4606de1007edc0fed4de485165aefc5f6e27fe4d20480de3c72ea7072ead599e07320998613a73e2367a7a4ca001147c290bc3c291e0aa3bdb76c1f578c2447d6b63c12154ab3fc4499f983ca5b7115cf02414d5d016a2208c38ffecd1b61c10d968e08b4e74b9633530ea726f26bcb84a9ffb751e354bfdfa7368b62c6fc35e8fba97635b0bbd9b609f14f27c72dfe2736f76da964368df82ea54bb913d21f99abe12a623e294d10ba9c90acc06b783af8514b5c70fe3d6c016058d1c0b05449669afb999984f28a481ecade92686a0608c5abd6a9981fc571f092fb83e10a4143ffe12059800c5a7486ad4662a8230c3e99fae16a98a48bc1b42bf228835dafeae45033a7bd44ad383e8b8280bba94c72e2ac8deea67387be56fec918a58912d64a9ea4581bce8dc0629a607d366856e53ffaf8502135c9c0d8aed27cba65b1b25471aadb6ccac767ed8b70aa4d2e2366e42f55b8cad1a0489ae12c674418512b7c8e631df6cf850d08dc1845a436dab613a99338052249877de88b9ee790d7eec4086952d1b17a71287a7e33dfae8c70223ff04aba86396f11da7b341e7700d34f86ee5ae8c1aee61cf5a0c78537ce73fa5c323c6d71dc64d05b73e1ba84c6e3fd1100add723aec6e973b2ca69b811410f5d2f8c0b3d5813518d05f6b51d76746aef5a0d5b81796af71f56f7fc3d07731db78e7cc8b55e365cb9346d93044a5809042fb4a063d58d51c591ac6d487b9bdb87f7ed04656ecb61134a3ff2097db17f83a3764942da49284e799953871087487835e84e977a088a278e4556281707aab529ecc6ad78137ecd516e37a3465d1696952a8381646c2cb9f2fb2b09c61460a7359bc5697a122874a1a12b666e37b8307690b5ffe31c213d4c9a7e0650e2aa2bec2d6f4114031934ffe970daeb151f6a637447b3cfe3b76ab59b379bd7b30a2e28a95dbe3a63ace22106056616bd22afa0262f020dc0e48c782225c62c38c23affcc52dd11375ea0de35ec4d0f80e6010fd14b5f40a8eb47e3db57aa7d3c1c218dcc7df934517b494c5c7a320c99b2f52531b8e91283e783621769a408d431797689dfb5bfa799430b047ccf7c2f374187d4e391e5b5d3e5d7807097ce5936a7e895aaad7ab7a1d833929695f6ed3d17e8aa20b9ebfe36f78944d76b3e6478ecce0d79663e11d6b88a56091c34483a14a18ebd8060175c57545f3c4820eb318baf838a691e3ae446165e9a6cfdddad350d0941c9175f16c5e3a222c8fd23acdb68d2938b6cdc5d10186af529163ff4839723e0394cf1a76eb5bd70ad1fc415b82c5563b4f2adef4264255784a084cd09ade0e9e4287d86c876a115b249b8429dc0282826cc4b0e40c2974de11622c47767b9d20bec8ceb0105e484345d60bf84736ae3e94db5e18316bc980adfb340d4af6deb60f742c3c99f77e8fe13afc323b34f2596a2c3af3e3a64ee7a143cb827108c8f200622971aa5a2d857ad434fd4083cd9c29356fcfb88887cece07ceeaa60536b8714ba95468100d952cf3e824ed289599e216ee3fd47e733327e875acc8176eab1c0f79a8ed16dd97d27d8024be2f0c22911e5e23f754f133a16b9614c706b049a6e54089f622d3bed50f296ebc85c2537e6957034aed2b23a245966e5dbc84a585a82ffec94de07db43355784e1757e8a461d498e15e1eed5e98354df8b5801080e61beb0f1e46ecc5ce5f931b5a43a2cff441c07131b8e141bfa874ae1bbd7038568c1debdcc0138e7759f09727920a66c5750517b7b56095d04fcf6957f56c0a9fb37704e35133c94b68e54fd58624b0521b4bc480a9647b1c7294a60144db16ce7d97c775846bd526665834db8590fcb91e1b730662c4eeb3c295d5a11c2cb1bdfb1fa4c1fda86622ab8659b2a19cafa04dc84616d8da7e01e046e5a559d8016766747cc11cf08431a73f35837520e37823b41d9db3610928dc8537250d9a7738f2c33fb59fe323d17d6285749437b4cc8638624c00b52008bf00b9c681c9334f63180e7ddcad65e52b1eacc07497fa048018faccab1796182f32b9af646dfcb4f5b5b19d458303b9081a7ead3f2f58025dfa309910271593af85dee8695c3096872fa4800240d928cc645868d759a962c405d75d7c1a463bd197334480e9ebc5a7fdbf342b1006a05ac3507a22b34e60b93883ac5758c2a952547fde4386a18bdc2afa411e40bc2496e8a4a8bdad6c54fa1a597fc2b57153fd9cc366d91f81e41efc269eb8e5ed7a19903157834ca558e733cd0eef7aa6a155fb3874a39bf3a9b081a6b0f40352d1ed52fc3467152462320f710e78fcbc2d32cb94111a81519272e0c0c307c4e7b31ed627df5ad221394f0f6c8e8c00d4aa60490e2ee17ebcb39367351720f73d480ae9a0b9c264849dde33c836c1e644292cd9198a17a4d1df60728023187f88366044e45fad5e1f006f654a6f0620ea3e0e63157b44f15d18f137f3f8c79feb44d7795bda23a28d9f6192869c4c27e3e477de2dffa5e82ab7696ae7dabd51ff0de6a82b3181c970230419dba440ac677828af85c661d318b534b3b39d24c81b6c72ce79fe0e25bd9c0a61992faa118d4ce252a08520c1f47c54dd590416868c17a36f8d042585099a120f2ccbb2602b6cd4cd86b88b4746d3ab7d21c1d064a7f86b6ef03b9a1c09934bbbf5172132fbf3764dd3d65859c73b5e202cdbe6d2409dc267c31e1d4e705fe416e59f8d666b80baa5f67e2a14ce2c75fe5dcb12f16e9a5a7578e8b870b43f1fa3f5a7538ed91d2aff09bf2ba345db8f63a829ee087d86484081ddf6005f4bbab38d51e277be4fa9ba312df41ddc16f0e208690b7804b590a82bd8fdfd10127e162b7e8e94625691aaf0ab4b2e33ca5483a30ca6c462eabb5d88eab2b11e167f30139e60d2ca105c49593c7d7611cab1616d099d8f6c6b9cd317176c02b903940a74ea199505f23ce00d792728de76b3d7b4e0f8d433b86c28ea10faf1f68e6a8dabb656202522039b2b3f401ca379fd010f205eec766ede86bd0195193d40148a2e555ad8c25e52d845dace5f531f25ef97440e5b8b964b489ce70a35e522163f91bbc0dfd9ddf981b5f6a3d351c68acacc56fa99f5587da38f8f40904f1589661b10ac7ce8537508f855055c14e3179c9393e4dfe9aabf7271fe9b127f94a0e21e99822a6c142f44949de21aad87959c7b56eb421bf5c679674ea7b1b5110ba33e8d88a491a0832e5bf6b1c59e66c1ab13c3592d4287055d73b48043ccf8ee27ac67155d47414cdd371b691867c70b98c4d17f8e808a4371628619bb8f31cf3a8ff0bd8e14192193b44247fd690e3e6288a65e999cfb94d7c00baf2db8333b2dc7362558840d27cf9a2c07ee5cb5775754e9c7d537efa8cff5a5efeddcb5ec1c755ae2de6062b19a3522e866a865d66b6d702d5c465337cfe0b200586737a321086b51199be25fda663480ae2c1296119adcdbc2140c7a1be1e06ea6ccc753d9b71476de95324d3ac0f0fbe3254f263b4a304708377c44374db38183eaff24460f908b15d8b07bbe36a571536aae661ab41c1173d2053da10993cb8f4695f9c8d0c8f4b4e4d2583b3142aba583d22a70949ad8b04a60d74ecdc22bd33db4f4d63b72ad0978a04c6ff82b12b67a3aac51f778067d5d9d2ea70abdfeceae3e5c0aec27d8a21aa03924ab41d87d1a6bfa324999487aa44e925c924af3ccc6e70da84c0b17ba3642803cf0020ed8bcb7e0fc91257d14aebdd51c69d3b6487a8bda0f2e97dd93fce9da84dcb860c64441ac8524c48d33d9770536c26b98bf35397842828582218e6c5251f541d3c8db3c7ff6e4e4edbdb03ba58b23c09d4bb8f68e4cc475bc21f2603c70c3e90f88476c687a50d207de7d212a0f9e54ceae4cfb994fdf1e3040212645ca3e715b408c2fb07efca36ef21e58e6d12cbd3b40b53a4ac5bc7c8a27324d4c46e3c2b12cea024aa9ac34c43611fe80ac0bb142f339eca5c5035437cbb3e2efc09d2a924948333b65b129680528a1d4a51e7449013201e42d2e5e3e128256034ae56783656bde662792a5c64f6e40c73142689e5554cc60f748dee20703845175b9c603250958691b34d5436457b75a03728f4adf3e227a85377346a26a4eccb25a040271c87e841415ed6f6107356763af766046b8f054fef5d143fef506aa001415f067d7a223505fff5e76c53ef51c4590d6f7701d3aa48a0e80a0102eebcf272fd81378375c2203daa377adc8609f4eba1e80436547513ec3847e9a2e456461261e1e4347c85fefaee243e4d3779cd63432c3ffa5880e5b0a30f9058ee9bf760f789a84790ad0be7f22cf343218750d0a0b892342a37e49d174c6599390f383bad60456122f5cfddf1dd244787857a0a69bb8b692400e38035d3aad73033051db30d486adeafcbaff1e9612827bcd43e83ebd63a9d3a378ef18df3add07a9c29e66351bac6a4a647af73cbe564803402d30929eed4a254e252e0ceb440a5968a198e0f70cde93c69c072ca0d8051e1fb6f8646c6d8ba37d84eb7dc967dbfb6b28fdffe6a0c39f22cbbc0771bb889479e50191bf75a4a245d93eab262d3c9c2d214146d1456bd9fb3903632953d5a2f624f478acadc31c9b8e7bc56b11f26ea0b3fcf9b20dd94ccdfa4351a0f74845b9eb0f3930a0c5fb6ef79f0b046a82df8182ed0d04b1ad1e8af36560e681438ed04f5ead4a87c2c6ea68a12078c635f8f0296d57eb10c840b450cbec2e90c85dcce9ef069c5044b0576c51e542528ffe8c6d8f6e03414538ea3c5452d691c21c80087b8a654eeb64e64946eed4852fd4785bcf68e6701f814fdda3c0f4c0dc9c8b38469e8db73fe8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
