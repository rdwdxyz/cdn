<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4189bef9192e4c0b390d53f51fd7fee470f354813dce2cec2afc4368fc4ca6498f1ae4db0f9e71e80a1b6d04d9292e10419d72bd6d8f15f3e88aa6e6bcc65acff2b9c98fddf83b16736f71ecabefcf5f5252950b2fa22b23355cc4d9e8be3be6bd77a5933ac8175704dbffa68f12f8738bd72ced9f23f5e761675e7f991507ae71ed7c9a67e9368327208a8e1c7d780e1763300306c5b238c95e78e39cd6b10a896cec5853f2601c442a86ff67d4e4eff76670caea4ea7f234d77e6eef08050c953b44b3f2b0894adb1088ba4baa7a1b5ff1c1427d3ee1023e311099a9d5f4462b0763010960c3a8d94cf0c9349849de93f87bc782d4b03dd62ca0fa7ca2b1b813972b739ccdd135692ac7a9ff8da3623eb6b01bc4545c5e55375af8e0bebcae8694bab394c4c88e487b5525614323b44d0b3a3908be0f2ff7b51c96ab11fa8324ed2b6b6a5bd5a7318b42f020d45894d5167ccdc3c768116b5110928b9a76ed1399a6286c8d1fb2ecfb299e9ebbba8e12de52434ad1c713004486efcd0afc9890dceea447091f13d675941c54f086d32ce135fcb338ca79dde236d817f82a8b4657b280c6a23bc58c44e86f87a9b6a6a9289fe459bf7f8447ee4f7bcf650fc88fbcc1b17823b98888fdb0aa985735b40161d030776f449798756e645ae5ba4c1d8357b356d1a52bfc02a3b7b6a0e58d4a73f609f3ddb3cbb28ed4796a39e96119598ddaf67563d5c0deb75441f8961311b884812214633cd47ca8a951594362282d378752a376a473477b278c7731408c9b950586f8413d88ea32c7d60aa7169c066cd292881c51bec36fd1279ca04d83da3662e41eed069f464ea16e57715733dfee1606d32e04ddf7420cb7265feb8f63c4d613d818e0b0fa208a4c40f76b7b025caa62d966d70ac331bd3811291a7d42d589abf54801c1238ec6f7a1814c35096029d36521d6f91b39eeeac9d574697485c27d0be90e0789bf2b09e654a0355b60da9c0b7de79991b126f26cb60b7f90507f89f7f3f02b9d92ccf6c08769a06b766f798dc1300f186b2761070ea3f8fc6268b9854da0a510935ddc678da6f4a703ff3f3bf2e30a3a85f69dc6c06722a2b4d8ff512c8154e5c9ca4c103c68f3fa0dfdf0dacdc45e6e20a503ea10bd491a5a7269819080195e9ef69bbea1a3f56a2d5a31fa58e04bf8d02ec56b19c3ec36a77bd5fa47d5552d1aaf7e883a734de0902a9c1b83f63f0448b320750e1b77b35ec05369fc99674b43577c4df2579b2e3c9f8979a37010896cf4ccc66598f101dd35b4480d5cc646be1c4dc6c3596732b362349345a2b5b69c47792849530e54fe69dd1b536e61bae6e6545892b747941fb86cde4c7a1f99e34ccb655c0ff0f9b9eb75bb1d8b4d257b9c28cc406224d3834aa32b1994faca9aae303355b1d8a39fb3ee1f4ccd92fbf81b9cb2b1d2d919496006103ace5bd1ee7bb89cd68a0dca10616367030c80c4c4756a5660ca51f18f23a78f2fcef6dd7f5a4ac37fe9f7132276c0fde2b9a7c22e0b791a1a85063c0cf2fdcdd932ed068ed094cadcd6c955109ee3e4af37267df8f91c05f5c05fdfcccab7240513afdc77f9168d464129be1aea21bdd88f92cd4866445c476b99e685dd925d2f88b2745bb74638b7e8c30d010f68b1c275dffe282f9385a7243210f08b94a2648c6e1d73967e8ffc86405c6e853109e2546aab1b789a6e685c7c9746f9492f06bec728e4d0ce71fb7786155681f49868d54a4b28d0f38090098e1b11b189054b679ccdd902b7fe0dff609de7af138cbcfb996fd2f1c439ba7aa1402f7ff257c9ebeade357da0fe5e07477731e20b4cdb5d47d29702d14cca6ad62f1f73a6d2d5967512d945b256644db7db142a1abaa7960adbedd2e76ca268b19556d29e098d731e6fe6c04a39537dd7ed7595337929baed00f701a1eeaf7094db454b7ebad42e41b8dd68d6669608ab33d92eb6a674b17717e3735923e9c6eec8fcc92342eaedd3cfcc78cc7a71cd463ef08c67c309d528f94102eee5a67701310cb47634d705d2015bacb1bda215fb46969314519a11efca9b9167fa1474f39fca95e59b75488ac98e3ef3eb726684ef947eeb20b2926acb17b82431b15ecfc458404d76a81a6948d833fc1995b1e0698d6b9f4c2eca3fdf9671a2107147e4de79f8a604d031cc4cad1031dbf0ebcbdec8ff1e79bd5dfcb431c1de4a830f2d01dde333f99505facf87a926ed3d632cb1938d664a5ab839c1d13274836e4661ac0b2b5fea3507203db08d3379073305af6bf7b72100ccc26b511015cb8662a38224fde1a02f70539c232a7ec1162e2343f088d4f4ad72ca4c507081f4f07dd75d48fb44c870f154d769879f6522ad0b8fdd8e00396e81c415f76d623fcb20a676764d6decf8dfe3dd61187d3a3dd9aba9fde8db86c7725fcb5669adb3df4fceb5cf22ab8ce0e26270b7767ca1605ca5098550b1593939d402f157ee305a554127ac4bdf81ff3dd76b233af9a4fa12260173c2fa5750ab591b5ae8ca3f25d803caa33599ac479a82cab5fde5e47962f63a0fd73960205d8f6455295b2c64b95c700319e12f30b6ebde4c43642666d2457afd455b000cbe7931f5e9e3b7a4814c8519f0775acd0c5a2869537afa853b2857bc7e19ffcf3c39f6dc38008b2797345d750821dc87cd0b60466d22e1195160c0be40fe0629f6ff131d8d60a43c21a78378be9fd435f9c51010ce314fe62a353100c95e325c307d77422333ff8adf2d11bd4b32bd09c29c0b7daec661b42aeb5c82f0057936f1e786c4c1f0ecf16cc35d4f89f1985f13ce8b0f2917267dbfda00c1e8f46aee7936899dc8db595b616d66b08ce28aae549510156dc20d14139d0c22ee7386461eac98f2da55bfbfba5ffcc894ac273f557b006a591dcd186bfe91338cc8069bb73890db06d022a940416ee63e145764cd876e7affb8c5a961ce46515636386990e6a97c39f93656fc26530632564c305e2dc857ecfa8fdb83bb998b746c3bc78a46c3d2a3de194e313fcacb3c6716bdc11ba83501836f8f4d2cca1d7657261da79c505a20fa94cf7a10fdc566d5be9e35b77f75a3fb4e91eb4bc51471465a0ef0568bd5c17f49383c24506613bd22b7e508b6fcda21df2caf80ee4e5af5225c9397e0503f726a97336ce481da6e22234d7db8338e42a2719142c1f4e15a35a8d25727e50c266b520495b0cd9f40c26ab1ef45fbcfdba5f53d46dc7ffcca6cb7a4b07c73aabe279f9f35bbf1a3aea2e9f2d9acc1782cde40fb7ff52b9e39d771a8c60b689800ecc722d7030c9b88c0a9adc5f3ba547875adec1307aa5ae3865dc4606db67540fa487914f12d7fdaf78ee5ff4fd800b81bdb1fdac09f8b4f22757b4d30e273b7347ec608cbc7c40c9c12d3aceca5b25c8c03faa95fd9c4da0f1731c3e647dfe7cab752d3e4755f8617e292aabb388e808b9e2a4eeef39b29e771e691cc8788b58bcf9358528a5e9f81c602aeaa0b6c586acbccfb33fbcd371948f02711aa2428ef6ef8c659fbbaae70509a2777b1f0947b43e1634c42a5f8f6f10930f6e38fb46d348b783f0e7d67de4277d4ac106d30123d3465b6112d083da2aa0e71e580b1b2fcb56da360ef512f4f09af22dd821081eeff054a6b2fd9ce2391abb7cf570769ea098c1dcd591f98544dbf10bbb30bce195e195f9ce4588619f0437e38f6ae8f47b55c6b7cee861ce7f811ea257dea9241dae740a063a8c1319e20d34bb8a5451a759dd5f7d6a1719fe61233e462efa8f2b0ce97813cfce7c794b3b0e6535da64d60d0db298b1c87824f0e8cd9db7d6b0aade1fb8a8c5b3f7d569b732fa0f1fb6e313382031a076a9654a567658144d79de12ae51be31756ff83a0cfb0e97ef18a65492ae131d6349751ee912500a41c4f8ac29e5ebfd3747f8185d86840595d8af4c5a16d4d78bb529bf9a4cf0126c75c57a6aaedcd89c13fdf3647d97dbfa8bb0e8fdc3631f6cd01de124ff91610f202f8a2dd6bfc74adaa5069a63b144b9a9105979e2371fa97704bbd7f60726d6f850bbc4b856e67179e4a6424a5f9728493a1992480ac4ba9f4ab06dd6d19a81220d1f064fd964b90c3ded5f9cc80aeca6ecd8da53f3e54bae8d946d2b215cb609b2f92475cb87d31f689952c3439c1a0c57fa9bc2dcd4da1e893a0b495aaffa358b208156d198c1925aa10910e9aaad935f853840aaf8d62676acda3d1504b0a19500e0fced7df620d298bc1e105c1c6f704c00e2d678a00f38a9c8beb0f8093fee15b997e49569147825ca53d99ada9acb98bcb0f4475f2978890041680c6a96ec96c5e5f00ace217681bb0f913bfadbb6c063b66f5c0fcac11ff4ad1495c10c565a65a99085089432fdb541621560dd7f5abbd50777929ad274936f8f1ecee1cb3a306fd70beca0d24d755c7ef21e73cd61c5d7aa8d9e365bbc70580e77b65b0d8678ba1e7647ba5e46e7b54a823adcb5157d838c76469e7b3171341afe94444d6bfd2bcf4e4577f91e563bc2b89a0224245dbb44418bbb194b93b993b2fb4ba066fe0b417bf0ad617778f8be934ace8937876a64fe34448876402f9dab073d4cd5da0be68da231303316bf5769e35b1819ad5d15959a151aec89c5d995adaeaeb958a6c99f2c54d9c84c90341dc0b9277889f43a8349c11bc8ed0e3ee02078f69875365a39a607d35311c7c54b4c7a08cc70f8febb3d83d7cea974d7f1592e0e97ad3250ed77480e40bbdf312f551d0e38b5f3ad1fa1eefc9a1f19c8aff7e6e771183cd5ffe7c03239817c4e0a34ed87076c6ba75c1955abf5149a415517ab350b5259b810fc85a4f561b712b61772171e6c11785617110cb8c7507f80190b580a42d4b6504fce0032ac7196a35a92736d0296a369ca3842731732467f230a6545bce543bef59c299010a24746a989d2196d601e1848e3d82952ef5a5b108a0178e5d3db8828dd19e5de82048d4d631eecf4903c6970bbe0f4aa26860333322169e347f14ee41237c0bf8e115f74dcb7b525818dcf612b9ed084debd91509e634c68a5bf9695b0ea6441faa1eb87594229a774370f9bce9507cd1d28b1b6ba0cc8c34849bf5f623e13aa18dc58f9d26ed8628add8b5e5d1986047ea5737e562fe888d3d1bb19f718204e4c352f50460aaf09b69b253246e31a234aa0ad42d5f87fc3795ffa1f55a41360c8c28fe33cb09e224dc9d1af9979df3ddcaf9b937c431933d7643b09c8c059490f739837bf0a6d80d590896eafe79bb373da5279592bbb4eb01fc37f8b8d303b69ea7adc1f639c39d1c667eae27168c54ede36c986001f6705cd91fb0745e04cc5ae08226ffb01522fef5a217cbe746b0f18a90fab9325e5a2e886b1f2016f41902707870b2ddd7d7eb821107bee419f2af3af13cb21199117fe0c3163b083e2690b40645f5410e05ff8bf5514cf60ccd5ce67ba5fa82b4d02cef6801424de9fbe593917ea0677518d87420546b90a82ae38dda8a2cf4547176ae72134d94a72dcca80d0de555f525e8e03a61db9b23c36fb4c91a955219165448b004c429ced92afc3048746feb3cfeb56d2a8f0c476a138e2764f93e3e247ccb416927ec908012da7dcceda6b16d69fbc6569cfb217084c2832e4d5f0972366eaee79b886073c53a25012736703b5323d2991f55cb4d8c86bde509d3537c8429b5221fc8b03488a52587db51c93fe1451d2baf75e4391e9b54ae98c8f2409a5b3c4d42973640d3cdafb3cad2cda4e3695d61fc7d65101c1ae0600f8adbe5abc04b060aa1857baeae4a50b0a956360dcb99fc1922498bb329a8a4fd22b110f80a8b578e621ad2103316e84c7efa4f46975eef18f6ae4210c447a4d91e5c5d0b75c80d96593c89594523bee63d104a0cc9d331cc6d0eb4f16d015d27f4720976dd6244d3bda31df8e259bbbd9ce8971c3d3db1df367189f36763c556e1217ef2889ad56fde4855605de8e3899cf90c2a4a0b649696a0248ac1eb0a6af5313654d2a2e814526985ab5d6a250e3c2b32303ffaf064e6a119e19637cac55342e8046cf52f07eedcef9206be996b8b8839824f630378ec0ca6939cfc1aac1324f9f5393d36d0c2e7952fdad919a9ab4d709a3ecc952737891382bafd411214bab488b00afbe16f819c6cf90c9395bba3bbf5ce7907082e6190253545cb756fba39b193b38616a8efaced15af5ad94495781e38acfb89b1b73e60448826c049a490bf598a7447032b75d8d4d1ad7dcdd18947557aafcb8ba22675aa8146857c62296089756855fdd1ecc1e1ebcbe108c46982a8e749b04b798828e4c8449449bb77b1f6ad53f57eb591a12dfeb86d544b2462e259fa7fa949bfeefa2e7d75843629b1beb3201c93dfeaa06d9d60d2b80e1e307750af5f3dcf716a7d840a477e2e32d907222ad52fa2cdf6d98d7c065afc5f9f0ca9fbf0f8eecc0118822798be20029c8c4cd44d42aef8cca6bf02a9643d05c5b8d9e49f1184c5906ee378d83b6932d3b0776e73faca96508489671181c77c180439334a62e67eb131c8758535044ed3517aeee32477950a1dba036ec5151243a81e5fc942205fdecffc0c3b9b929f4de36c4325a18b56301db2f444148220b0add6a2b6bfae67534f3bd999eafbe9465a57015d5ddcc458d74eba51bf867f7dd3c95088cb9053e57813fc6499faa7739dc45c5b33bf1274590113939987ef475fae00c3034cffd1b8a0d904e1d67da1eae532533b98a44a3e079addfd9c86c437bbf9ed3713445d45ce51c96c41cdff1d93bed50ebd448035e07762aa165057d51eb078927adfaac226d1b6da14295fa733144126561448403c1cfc553bf88033427205d3d5a949f9bc859ca9dfff047f5504eff8c01cfefb143ddcfde03981b713f9523ea8d1f367add369bc00b74d3245c363baaa5f77d563f673fb694673d48329906fcafd870ec029ca4a924c71a4d863dd9a0fe3c0b9a1e25ef1c0252c587d2def6c43fd6731070f4578bfd45605a0b863bccd93a7a4c3b6e6097bcce5a26716e4bb7041cdbe265cf0b2aa8a210a53a2cb5ef3cfe9d146e277f30e1d3246beac1301d1eb7f4b2a1c1c8a86c33f5544d70c4ee7410473a4ed7e67909bf3ece1f51d210e0ed6101392e9e5ae7d181e3a82f61500103c5a3701cabed73957d1b75ea142d721026e54f88bf7bc4e1110f80fd21e614db7443ba70988071b2e0a69aa4b3007fc3829e54223ce335a6a6eb46e7cb33374c4df89c8604b0f5af83f0de440fc5c397bb77d76dc1153cc10e0a42265b2dab2102d72d7f2292708455b3468817450f6156184d6289db9e75e1ed7e949fa6df0e9185a9b995b0e0ec78cc1745e5724fb6797453294053e97151b1cc070a3f90987118e7b258b55b0f1244c68c52496303d37301244d2a8853fbbf9840953338f71adbb50a8c16e2ce7a5d23cad0c72e088b3ba9043829ce3d3d84398f9d223f21a70817fc0c1f090f89e6aaaa1f0cf036192aa49c53431a85cf9186f615261b3676609614a159a6de7f4a23adb7e64b74f8f9b9f83873b0dcbd70dc5d9efaf323affbbc64ab668bf6beaefb3cb5580c8f39498829b9a26b767505bedf36c7cc9965e623aba41d36cf42d3df25733c64b0e9968b275447705b0d70b96898a09d1b09ca1cf0ab12e32c46375999017bf54ee472d4cc7df7e6dbc3eb33470bafd77813f22146f67f85430b05fd14650a3fded3437d3308caf7ccf765096bde9f43eeb199187f8c3a5f7468c694c2ab65b1077f2ef901d4554fff5b831bfccb180b68cf8cdc89d62d7cc094a7a242688215adbcaebcd72ecaa0fb349d6d443be10d2406e9fd3cdeccc04213e3a6e8381d9fcb7838273eb450b48ee777730d560e84f769de21e77327ebdd1b1353fecd8ebf4678eb2d5d5b663eaf77a8eb0658ba1888ffc6460b9e8c4f804c3fc134a815b5dd360ed74b8208bceadda00ed452fa60184ad321099d770d72f7f6d675e21180f015f5a63025474c7273bf06914d51e8af948efe9b9f399efbdc683a6d9b1d6f8915b0d29ef7e49918c3d9075a80c5e407f6f1e6534ac70d7114f00c964695c5829b3adecbe4da63859c9d39b1b8ccb2097fd734675419bedcb886a968629c42244754a26ca322b6f23b163ef39c60b2e1f20046cef6c83150a0ec8c6cfed31e363613b949b0d7705cb5d0e1ccccdc19dee1cd0cfaf575a4b0921dbae19664e6df9a4c6ef005882e313fc1cd8e192bddc85945da5d1c7553016c8c7938c2b03e4a3fff155bc9f09dcdf82f093539eda3af63de15f35557402232b2da1dcce1abc0281dd2e9e73f0ca4a99d967efdab36c3beb6ba7d39ad1a54ff02d6999558a775dc8cfef90d60f7d21be1476786b3279ff41e6c563b632c65d92c1d7ec194eabedc9c961881f4ffb2e72846f395871fbde672f05166e2beb8ffdd80d20cf298050c90b9bb7064036a954134c26454c2593add8d5fe944de8031244dc32f30b2d7ceab55663021f7cd9d1f1b42befb398be0fcd76b0c7882fdda20b7c2f4ccc93b062aa5d03389c82c7e04ad0dfa9509857c10aa1d3573a2b6ecf5a9855915674b8cecbf53750072aaa728fd3cbfcf1e686d4a67823a343571bb2587edae7ec1adfcae8a691ac4ea0b67aac64cf361d556df346678793731647ac713214546b86b1869280acc4cf69c1c3d4edd4d7d04bfb154010854debc49c4632904c8cb8e1ce7c8d6db81dda179daca700f557bc27b737f5a501556e82085476400d57041452aa3c475455fc046d37a2a9fa0b69b9db25da778da8e5cc38fe4f3992319a20208d4539f2938e2e134e2aef9f3713063160976029c996d6a728046fa5ecdaa4753145ba1952575cb5709ee6125c38fc9082c52c6c6b802bbc46e0b5af8e26e2c15803ce8cfd91a6ee0274957b46447af6e84253f9f3418418205e5db6293251d4389a0b41873fb690164148483eca54460d4b94a2f03375b046b1368a6ce92dfef403a55c3ff9b3d7fa29d9f9934a2d1c78dee01298082be6db18c280e456aa063bc4d32449fddea01de55b3943eb6e4167a1e9670978958529aad861d64160de0eb6851297dad595e7121163f76055b8c1b6129ff7ba8eaa459571ed42e589f366d9a3fa6680a7676c2d34b8b1014990c8e2b1912703fd02549cbe17d1bfd13ee2dfe9e7367fdcc3ca8d4ab327c7e48f504bf59ea43af3858664009128ba447733d840e2c4fe6d991bb7f0f6a018461633e535af1685a68d16b94617573d9d1b197579c3ce2a4de66c5e498aaa1741db778e17e0889c119137ee167a2fae6d75fff23ff28c790bae1672079b060df13d2cfdefce30072def81d58d187b8fa2b68d0d09391790fe1ec12972bbec2d163a68a403cb8c600d6257dabc046730ac38d11e8d494c20900f468f11f4c1d948d8e387ce2eceb4717f1bac0330f0a3179f47ad4206441f766d04fef3b04880879aa71b5fedb28bf0e323e3278fdea34eb62559a4652d472451883bf1303a77dd3cb53b61e59ab8f3a46cd8f4f792901751b9eda5361158900ded78b515950c36fe8a7c1c4079f3766ac71ed721bcdcc13c9f227c032ff2fba9fb6f286aae887c69964e922ebfab4dd8dfe32e3e32b175570ec10ba4b1bf9516b089e332df8f1125ba87bea1fd65e8ab4ffe31fa08b9a64531c66948e23bbaca808e6f8d3597856f28b14ed2a324e0847ff94fbb19b4408b48432d5148ea3c04c00b973092b81085aef87ab6c6cb69044006ee32382b1e212c1e0b195b9147528e3a725bad5cfb27c06a447219288fc26b73635638a02941b6d50e4d40d1e6158c0747f7a44c0ba7dc6fd2a84cf3c8231db994ab1e7efd0cf2492d426f1d455aaf95ce5490a936a9839af640b4b934aaf2ba4fd41c0c6c37fb53c19ecdbf8bf653365e3ff59d130a29f49d51edf2ae0a6f99c0861df859b533c2048995687e3237db5ceb8064052dda5fd787e488624e4c635366ee9086e2572577d6ecb681ba797c074c5682f04302dc30844a17523a2461da8f6fc79ee4336d5528d14d571dcb5eeec4663a6cbfcca9046a41cf20d20b4ec6e27bfd6949a2df62d3e66ed47bbb7201fd74d96bf19f0ada15f4690cd5e6d570a579df52a3d242b2a16bd6ba72e73137c653e65fff4c862f7553e12020eacfa64fabeb5b5b1d353db7aac0d1af089a6e2ca22198662c105f6be1c40e399d90ba44390b3b2140e0d9fbcd91f8012511ae4bfa122777c21d8b5645e156de034c693db5b6e86b7604e580220a2808e7a93dd70bf9eb899c5a9987e14cf189a8518e4afcbbf2682c6abc4faecf245301ce77ee91648ef858b6b611ed8baa6df0f9258e2e15f7c20318114fad85e611c557a761d7ef193de72dcbad58f68a11ecf1deeadf55d0f43cc5e8432fca69a857b4d806b8365f5abfc416649293798b39d218fc5cc6e11e825bcd1204eb8c825f498a17069f2fdfb1ba58195de643866d2c81127166ac4d5d9a28607df800e2ef1ccb25d0c01292c0a9239f320b2b6dac1073f5cf330beef5d54caad3b618556a08349668e4e03f5622e420b0d91cb21631196a922348ecb78d3fb7dfdf7fd8c5d76c0fcc3999ccd71123ae195db70d5af354cf0e99420741c97238a1e1567e419a8a07df77ba4287af6e83ba9ea7831d14893a055501c31d681bdb0bb49c4494b2aa1cdc2cea5309dc381ff535c3eb9fac7aba692978f3aaf4f127664f73bc88ba9b74d9b4da69dd3a1ff2907c17e1df616998cc98d0db8be0ef11cd9184832e053d7ec411d8c272de6478ef91359114fd53d317c77d21c869656379e945f5e3fcbcc97c147e7fe1b35fb4711d286277cd352a19334edf2723a74e4eb0307c5ab10dcf2eed750d44cc7ad65f9f9bd5f72483519b6503443c89249f77de8cebbd7e425fca17cb656ae640b2032821ce3203c197512c6015c90ab1e010ac0ed767340cb23547084252e6e4ee145a1170a35d91cdabe553d5493203ab1a64153a508098979d6042b1206eeb833df8a9e05da32a84f40c0341d4b2e76d478e410f9f397cb280fa380f88e7291f1f192119ca2c67ad6fc2c4a4c5f9273b7158f59a684544c0f2a783100a96781e5df020a447cad9d46cfc787ff1834a54c064cd3ca7bb5b451977bed6f01854cc3baa32a4c54529e762dacf07d0ca492a70378593f1fe388fa2e4f09cfcbeeb20065688bdb357a8af9e9bb2bdfdb25eb8de6add791094452b3f573473d7a9fdbc768a4e0a9c233d4d0f4907052ed7209d382b28b47f58c4ed74d0bde9a6dcab02a135ba05918916c00b5220c4092d0152b8a8a18a3be6f8d15b13aa42d8776612be3e9b79b8b92aa4c6908e06ecec64ab385e13af375dea182e2afb5b47d8512c97d3b7493c6ab989fc408cd020bad30e1387eee22325fa90d5e6d31b4928157f6290652dd5e670f191794391ef1fb510a917b2dfad01c7ae429c0b845dc2b3687fa08880a9fb2bd019e95944ba0b65709f79e0bb926e4d7015c52af3af0c474dee98af663f0179baa1798b83482b1f272a014c40365f9534fcae259b7ca95a0f7affd9995f288d7e858875aef5fd370d268c766db9357e6bdea40bad65dc19fee60a5341f27ce4e05bbd342c256537365999d31fb8d5fc9bc30ff63f51e95c4ae8358c959d7fb65fd66246f154f6a27af10c01f8212bc48f1a2382b7773ea0af16bb197b6caa0f63970d1970c3df2ef443f02f0893145063b9c55c477f27e495dee0ab05dfb90bda6929fad9cce58d29ab4392856e83288cff058bd2a8ee877c23d5b43a1b6792c9417be075805100db65d4355d9382b498345cd57ce3bc6d2bdae8bb49d42be765e79ce525176dbb851487e10c0f98fccaa03e204fcd517b9996a9e5cbe1f363234ea74bc4082dc9e9b3a31db062091236540c1a971e731d730cdd0d0b02583ea74ba93110b90541b36cbe3e8ab326dedcb24ab67b01574163a51da85d8eb49ccd0ea42f6e5eb6c1809c6ca3c47161d4580160ae7e93e872dd709731deb74c1b35b9bc9c329aa747b1fdb35af6ca2275020030491a3c60cdc84eb9530a7ea2e06896633290db73fc50bd07db4af9887d7a7ac57c6fd052869638bc478deefad47abdbb8dedd205caec44609a637d8c1786a8ec9faf48698e871e5b2c642f3794eb158e351eed0cf7d7ccf65177cf3d36ceaf5bed37aeac58e07bc6b1a8a727eccd7a6e0377e58bf425f81daeb38f5035cec025b40eacd0fe8d241d4b6c1dedc2d23cde51c1e9b942a1e29aa6333cec27cec9eee957b018bd458043bd5259199660b78e2d8e8e9e014f1959e74f1b290cb8e31d84859b746e39bbc124bf3a0906d4339f13bad2088bf3aea2149891077da8d36278ad3d94ea70536015a233c45a970cd2748d84c8fc165b9eece2fa0e95f8dc84fa5b3d1b934cac29baf5f7637b40223037b41324857658f55ac30344770b0a0a33e59275c449a72f8b90784fff92097090acd5be478359adeb37147e4915790086e57aa3511ec0e33e9ca8db7cd9f23caa39d51d25d0dd5274afaa0b8fab4e9ab4edeea976327abc3e4905c0dc8ffebe58ff286975a80f767436ab3a3f8ea3e3c06d953a2527085c49e5faeb9d594332bad7cd73762e6d905145fc15ac38a01d78858f9e03e6e65ca29bb58251168b0580f13d6529ea03e9e3b2721492da1d3b4423eb5e67afddd88eafbd79d01c7115ff681211932e4c6eba0b439278065a403660956f9632d3c151af803fd31122f373790ca4f096b2ecf713ba0b0583908b60a4a93eaba8be1fb149220a7b0d68181b86e09b71be733b59ae263ee8209ce8edecc85208dd60d13cbc1856733a0580c6d83777cbf98513cdf96080105dbcea12150cf4263d9241abfcb499ae1fd109910114022425efa3d51f1887390f73da3caf45c80ab57df299198aaeeb087efd6c0eee390b307905aac62caf5885917edc7c6c2242893c2e44e0923184380c8e1df6ef1a2623dee19863dc21a77d438ceb4f5c25f1ad6d36bb75b94db9d6909cb77aecb5ced7f8fe84d15e6948146cd587c1cff1c13bdbfceb7979afe444f4463d77be5037f62daad7db69f6550477b0190764d17f85dec9156a2691b4cc1cb28bdb837858c377fc6f741d48912bf3188dea7d23f200ad31f006a91e0f711b0ed9a2b6b711a03d3066ba06cb47cae69af9fe4fdfcf0a1c727db2085f19bd43c8baf7ccfbe96ee731d21fb7084c659ff42c4b3d1b043d4b59f002d5fc02b23adc8c0042095fee252f4411794f6ff0f36abb13888ac5d1421ae66de988b5a91b7a71cb7d2772427e44fc450a46d8eb62ceda4399f9938bc7bae39dfa277d2f885cffbb24b0217478338daaccbffa3cb3b8b32e29e5f154d96f2a7ed3866c85c37c72a284042bad9f456435c0f3fed934a968e8f43b388aa83d71412fd3a1fcfebfc17fa2e3f7e27619db3945aecec190235118366195fc63d6ef2e4b484497a7f231d4c10c299f3346f44977edca8228fa64ea6dc54e7004970e8eb591e7d75ac18668c444e9cc41a08406cb98f4bd759749daeadc91e9248dcd4f843fdd40355dc8b4a5bf7fbedc7ff40bc03d059574f8e221d008e57937072ebadafb2b211c9727ac58b8232cacdbd3accdc148456305f6f745ed5b1bfd4f7f7cc07f36092c56758ea09dbe712b502500e0c510e714a0194ba2e89fe25a40f37ec89cd1545ba40435cf85b6e494e885309099de4dd823284be5b66a28363c2e4d3e80370108a76a995796248b6336e8cb5375f57db387ea7568bec87b8b08aecb5abad3e252e039eb4ac621cb7e57c319cd4fae3fc428853d6600a5f331590eca8adf279ed0f7dae277d412ebe0b0536a2544e5267a63ac7ab7f6246a042608622c6f49e78f560bb4020823c3005527e568056414388f9924cffcde194d73cb5c18495daec1b3f71cced601c23b0f9dce66f4c39ad58f572534375bd6bac6bde702028c7bd1b1aca6e07e1547e99d7764cb49415f2c478e03d5e6a40890ebfbe31cd5f3116285b1aa47f5a1d46d2cb3b4d18754138b4d30962d5723b082340e099d7253b37e6a03f90df75e4ec68fe5dd6d3f51b535ff45f3719599d3163dbf9c32561394f7d56aac02a434af924a45f0f24bfa49b4da1e04cc6317ed5212f49ab04c9a6dcf8466042347ff78bd2db5519b3240a573cd8320fc56f3ecef188e090455149f37b68c1f6be16233ff492b9a66e8eec2eec7e6b5a8f03ea821f5a99496a0093dff4c85e51b19dd9981eb415a7499381b9511b35b7175da888416346779011364da6316ed454a336ebd08d8dc2834e162f4ba53ed90fb6815e916960f18df8359df9c30b155402b87030b6abcf6f6aee250efa12f5c28bab3b7d6047dd2e3c2131e388c6c6d9423d1f486fe497ff879fc6877918705cec47fb18a8898c69632b2af31b7077be6e722962393a16254b5cbabcc40c17d6c30afb52ffc6aa0654186f904763ecd248aaee791b071ad096b297033bea9b9f8881e5abd831f061e23cd9a3844c4b4bc319744ca7b1f3102e485426576ce22982a928a7b0038e876290781f2a1643244ceda110af28a3aebff91fd4271381335ebcc176ffe7470613459167188f33e752d5c3b68fef938c96a8c011154a9ca304a42c903444541a9e83480ecaa83018e96e0a73680c409263c15aa64193c690d00007e6dbe084ef40f7e4e7108249ada42648a146d76d6206851e0dad1efa774d2c9989b68c7b2aa0d6e5fe7991c268cf8b3ad7d79294ea278cd52e22f97723025da5ea1164f944cb2883a63a1330d4a601375f7590726e265fd07de5fb8a05149d56c3fdca6be50f725230aeaf73afe03a5157a233fda00a8c5a6b359ca296774996b6967fe39bad5ecd5986ffca6d6dd0f1afe3facbbcb396194feff25704672752bbe396952e6eed211d29bef24c0ffed7ba5413925b6d91453134ccd721f18a205117c0973e8ceae3772a17f154e39a29e7cbcee24ab4212d1f6cbb0daab8abcf852de00d202fb7ce844f5dd708aa0276d9f83f53b544e9fb8c6767c14d010255896040e8a50cc287162c245d7f4c8e2e581cea6a4a32fa8bbbb0be5051d2126f24045a0d21933777a3b9264e9be60fa309bf54617f0b2500d409314db9647cf7ad4116a6e8c3136119fa1a0d45445baf27c6d405710e839bc06d91e7b2b725b280d29ade8e53330483a6d8b5768470b3f282f5d6a644f9001da462e3b1fa05d7b580b4195b5d7368f87eadedfa1e55bae69c6ee4f0bea4f6a96056e1e51e0171aa3075b1e8a3582c5ab3613807666fca03221669f6e65e445e486ec5f9afa36a7c4bd9b1487427d8d9cc1ae6695e11731fc63633fa844dcd3f43f6a1249eac4f1957b8fb11bfa7011df1c371d864653e9ca00d81b044ae9a5efc0419bf5c728cc7d82f0ef09491cf39be74ff6728cda24d20ccf2e833208cb50ffc552832e9d1b209cd557a24fd19951b826b0c013e8c199843f6ae4145ddb1a863e545ce218b458b05fb06cb1c881359673828068f8073b66c9b0816027f81ff896c2b03be79909652bb71283e2bbcf90dedc5cdd39145cee0de0c5f0594cebe28db4c626d0a358980d6c94bafbc2cf2e34a2df86b7eb2cf0906d49b45cb20531767ba7112a05d0142eb7fd0f7ed053ef43b855437d18de1c7aa5619c28b7eae5ff9147324e6829bd9b6f1aa31fcc7a8fc781b77f78285cdcb00627ba927bfd3193c9979bc2bd7ede0db37180cf330adffa00b49eb0024eb1adf490397ca18e9e0befaa0730790c185808c5354b0ad30a625880708c142ac1b70d0503f4b4a263a5b7fd9c452b0c5dcb281a44d781a0a8e4a47c0eefd1f3e669f843e338b3898da72891ad85b356e766c0c9ea70004eed141498e8c78370e3a513d21cda475040f27d5a4386b26259fafcf58566fbdad1506e49b3b20d0e1d53e7ab04882bf6d04845af8c2ba5b7328df05ebdcb9905bc458ea6e935e00075998092bc1d8c221da387bd9736ee4e5426a62e525b77e91adb2722f3c7fbb2f84f9ac719292f0a00e92a71deb5aafa7fb84eacf5a1df4ebb7d67ec934edcd4268ec70785c6b8d59b844eeab45ae94186ea16372d11f28658a58d01aafdd0ec04e07c0cedbde86c436d6b1539409d4add0627972a120707679451b08d7dad3149fb27455895db3e2e22e960321958b146831e095f7ea147fdc1d7d5392fe7ccdf4bc911eac9057a7acdd0828d08cc17c74938282c4d7fcacbdf7034afeb341ef8dee0aa0633c828bc77d928dcce31efd21a6a99a25c8e0f14d4b3acef9ce7cf047323e492b203b5e155f65e7cf0e2a5fc819b0a92dbb675c47568d69bae66867af6dca3eef79aa637db0c847f47aae3fba25240d6e6cca8c76ece892dec3e460d0007d0e18195fbd62fc35252905cb919d1e4a25615e368c02858ded136335a028b2776ba724204b889e1a731ce8b9ead0ebfd3c2430f0c76e24d189186acc4306085c59509119ece859d9f85386bfb0a24df3ca0be2b2b363d0f4d37c603758b22496a500ab8750b9e68c5070706724847c58eeb649015c7aeefff926b3a9253e4e2420015ba4480f595634d4031f232891509bf462999c36fa101b4fd41f7cd4f8d9dd705dbdcdd65234cd3ea51c7568dd826e3d51da90e6c37bd5289375298d91f7ac3e0d1658cd1126428e3c40ab63e1a4943a4a2c86a3eb77f98b076f7d2ae3e9b6d2b1f69b1ff27af8361a5d3874760911be9d7b072180fb4328c708dccdc680912bf5d46726fff8356080d184dac930355e0952f5e77f2344fe651a494a28eed952830d763db04f3ed1c73bda84c0ca43b65af818022b38101a490222b8e2d1e27d1e89b26d0575d3b543170e598e22eaf160bbfb379996b29473f5c1a5b9b285caf6d0208a3c27c1bedf2f65adddf816e659a5a23f7791c5ff47cca38b5bddab95204439977e391544ee0c0f0f7035541f81e717276754cd3de5cfebdd210ec929c0064b0fe6c7da455d71eaf57de9e68667178e849142d2c9208be9e3b7ccfc63943a1f84ac4f18ac413421f052cf145fa0bf82a22871866a939998dd3e5a384d96c31f16ca5df5fcaee28c075338174c21f122eeee445cb055aa148dec203d5312e6197b39380eaa508a11fc7d0976ee8096f21bfd12e8d8afbaa9220e4d2dbe9b7db9e159b27975f5819b66ea5ae80723ed64af8f2204e48702480cf92ddf13da37cbb5347aefcb9362f15c9f54c8c7935d54947d77d4b9cb5fb593e956f52d89ef0c1044c60fbe533852b6ab3880874c668b07569511220b44ca2a819590655f0aeda9c83091aaec4e1fcbeb195034a20a38f4d51b4f632c36c6b33351175d270e3baa42d03e9accb12292e5d2c1a8f9f22a1a68c7cae2ae7f6a0740890bc5dc0c7951ea6c64635672ae8e976d5fff2dc99e5c42e4d7712084804f0f893557b347ae2dacb57e65f2860be836d06002a8a342780977621208a481b40a418ead7ac772c088ccdda65ede29623a82a07f28f65ea144e660f5afc0040f25a5ed7093f99d68f83c859267ef8196755268ea0ee790d9cecc4ffdb6c6f7b5e9f0a41eff13cbec0ef1073c2f2f1ca80ff5b7bd1c0bda20d41cd569c1a6b7b568a5fc6f3ed3345776216014412ad091635430eaca0eea9bc0badbec7be1dac02e79c8a2ee0cdc1369bf44a8a7ad5ce23e661155c7ec345e9fc527fb6c102983509e89da5804617733ad5e17e95be93c57e240925d9b686bd45573d78f11ca84fc3e44778046f842c0a9987d667f136941fd68f6d8c0239d55dcebad96545f42b8f0af03accfea461e7acc08752c23d316f58a61de3cf2ec22a86f6f97637d750d06a48278bfeeba51824a3d6284c4561bacde1c61f00d1cbe316fcb91ccabed0ed6d1c9bbf6427fcfa3bb5eb264573b3bd714de61f71848447c39b3f00afd64e0941536e2719fb108329a6f91391e09e93d6ef76221a30e8d1f2901d9490dc6a06e7aa5c8371625c8ec598df156deaa9b4570ee0e0250e88d6595c84dc3d1fbc3fd0925e453f7da8ec55f9874f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
