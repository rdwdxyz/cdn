<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e047c909706c97d775105234d4a6b746819642863759bcae0d2875a63195466b8e14db1ed6c9e4ffae2d13cce1a515d7e3ed332a55492eaf716254b3b9799ecae0ec6c58aa43c229f4680cd6aaf45d5e68bab5a83c16fb7391e6707aff91efd5e92b4b71826b3be43b722290af6bbfb423587ea0f6cd9fcbc9b2136913f5750ea39f15140799e35d54c5d90898d246b1e1310506eff79a9bb35dbdeec9c22c72c262732654547b7e65d8a0993a6d808d193ef17443319c26a31661877e73fb3fbfecaa549ef8de30a2a6e46f981f8c1504bdd51132b5b2ad127f2d0ab5e15a34cbacded1829e398166d627c53f0831caef4a982ca7f33a5bda071769e8ab42cf3bb99705f52f474d740c58a1d1654ba59c7943ffd7840ccb5da40cd4f8f6755bb58fc8b520d58acea875f0aeaf4b599aba800e193dfaddc37e7ac3f06806a285de9e30f912be691ffcf11fec989cc4a1c126eb7bb9eb6fa9195471e129d2920ae284e4c509dba8389c03e2de7667a2ed0547868e4205405694172b3bfe7b8fe5e6ea57625afbbb38a4923e25f6da37d785b82cd2271ecd72268d1be4e72d665483e2849fe7dc2ef2eb09cbf8d8fb591ee56b7163273e826bb77d7f79d5a28acfe183a33bddb8330592c4dcd9d3abea3dd0faedd0f33bf684173da6f4d654eddbd878823435d3abba85803e5744adcae7155c258159730c6e87c41a6a8371bab71a7ad23c7ce7b8f431ab22ab61bb7357f8c1c372627db968e1d1be8598f33241ee3dc4c26839f52374c2695d1a3abbfdbbb2d7caccc9fe26f28df0e4a58a315228a0da020337142ea09e525b6487f5941582fa6fdb299efcd969b91b26cf5deb5a6bf2edaf2fc589c4a3de89fca19308a37644e627e71c783cdede3b33ade5d91092aca44d0f52438254e3f8cfda3a65499d26bf2b518e221880c7b1edb87ff52ae394a5404cb52ec460ea0d820e563025a06de045f976be3f77b802d591b29f5eac3ab0153ce3341dcaa7cce301a4dcece4b9773f2cfc9e8824d3c86eb245734b4c4602dadfa33c86f5e203639df62cf978aaf5b20c4171b6b6a86bea50d1a527704f1fb42841b4d2e732928de220e0dfd825cd9da1c9604cae891372cb0b3a33d1e43fcc2fd288f2fd1d1a0764d3fee5680119e5d67677e6485150fa7c0e1e31d39f1c3aaa9cd5b60b31d2b447eddf9b9cff0becfff524bf1a1f8afa3b5d506cb2453f85352555c2cdd56eff36ac0049f841788bf73a0a08ccc0d66a9d89c80a3569bb5bd9f60c5fd0604e8203f736e567b7754657519801cc8b077b6a7b39c20e8ce0ce8c886be10c06180c7e9aa39004ec464e5b5b56ada1ce852d23ec238d8ff25be548ab3f5e15eb6fb03e09f92c9e4210b4b42c6b9c53aea329439b734e41d8c3d3452eff43cb1aea68749c5ad7990fa3accc486f44e546dbf762a7157ffba0cbc43bd3475a3b6c291e0deb41806c6a98237d571881ed65baf1b6622208aa95f6fdee2542aca0ca0542f16555c9fb7258ec752b4b73781bcd17f94ae457cd89ce8b99289563ae4ea3601519a32b1002e7e76ac65cece415d320f44e53be91ad023c55062302ab71e357bfd0dc5f3dd31d82bf613a3bcf2414b415769aa8afd4eafb3e8ffc170b545b6f84f16d3b429931f9b044738736fbb67e3e5d747a3a8870e5c8f1a64f9418ab9411274e9a3be5cd1aab4b245993d1a996399f38735adb6826feea344ca6a6f7956986615f137235199c6ec7c439c1a4b9ac123e9d0047b83a73034dd0ff81b98f2a98676a5f56a418fa0dd5b18c7ac3677ff2fbc1da4e78eafd210c57f41b2611f8a56b75540a7faf9e563572db645cfebbb13991836be625d6f339c1ed40d91a361821c85585f058e2190e49c5f04729a7c9cf8a1e3ba83077e8349394eb11b3c0a42addc7d172e4e7071327b73b12da898a335f180f970b738e932d92599fe7cb3566ee1597c5f635993214610e41dcc9a74817c5e2d2663fb0c20e767663969a8bb889cc9fb1aee1eec6633f444deedbc2748a7b2c9bde7d6cb5d0a3c1a303353f70b141f188d3ff55307e02f7e966f67d82d5a5ae253b71ea8547a3fc4ddcf4dc6a6e0de069f3507fc31ba4227110fa9649c6d7b6fb8b033ea0a3d45b65b6257a09f9bb2a384fac2094936fac0936d386342a0fd034118d5af1453664629e8948b4e2a43c7456b603ab750463aa4280d667ecc0312658462e20d934958d2c59828928d3cacd0a22383164b75448d68a8f06991b4ffb56003601381c969608eb3d661cb8b6f0f17fb1f23d7ef9ac34da9703f10e697611e107526db3945e5dcfac70bc144b025682ed9485bbaa6cc3253ac47d1cf70610652edbdb4047f9f1d7e0e39d560298cfcb87839654cd6db0b4b82e6b16a108f893c1fbe6fbd923a27a64e1cd58913f6bb881025ef52ac1c5577c1c1914b7c0383941dbc4457a518c0db5ade8c96be7f2e4d86f5c319071f7565f551f870671ea3ecc6aa9bff055adeebbe707886b4c86bb510258eabd09d436322b5877b7448c4dfd10bfe2ac063cb3f6083a1a4c9ed74563c5bb53044cd33d4aca9d5015a9f7906844e1b2d41be601f7716b4cfa6a057089a2879e7593c49494c113e9e5b824560309c560a8efd0c7630d20a80e8817e9979f5da9b414f5645f55be4db45377c6a6c0121f9f6f0eb1b289fbadf2f41124c2b8c6c9c8908be6f9e4c34d8bfb36c471e2ed08a616b8e922e3b21958ae52a19da7c8e064316479b6fd00e89f55b1ae6873d7e1324b5a873ab12465077c2f794d45120ba6772b391d1b96e43e539ee27967eb86c1705258e1c4e29c9a410e3927dbda7fd3b6c71b04a1fdf606228ab4f98971d278d2a507dc038ac2d1eeeeff0312bab04e78280683528bf71e67c1c72696021e96ed4b7bda75ed130a64b8745b4faaa45113758a7d05799142cb9579136692f47a422ba98c214b482787bfaaac8ac357d4a6a2f8025c7ed9f95efac028448d48d32ffcc543bcd918c3eb88ec5db887a867e3128c750d61163c44433f46e5c01a4d91d426dc144d4e0e7d951336816abf001f4d2c897381f38765ce347d2a7034458edab9834412f57f0f5df6f67d935907914339e6fae23ef2222cc0eafb12cde71801a17592048e53146a3d1aa3d8bbe341240fa12136d1c88cba0b84a9a24fce4e27460632fa4cbb14e06aae8c5dff169f1d0c576277258e2917494a2d73647b7a703fbdabeb8b4d4feccce3cbefa11acc62e8cd155771874747ca9e19fee1cbb1482ac4b89697e70c1fce0407165e0ef824b15b37e689d9ad97ecc7b5e0c1b1f55fa2f52aeff9a7e9f324b1e4d1fe4ccfedebef65137f5242de13f0a76f3ebb1243e2091362487a2a36da5d72612529fd273ba3e543c927c2f75a25171ee277e907553a7a75a02de50c30dd8a4ae3854c9d0fa670832de512b7572517bc48a589b65c819247998f847eb2dde0e144813b3a8a6dcdf6ba4fcd5ef07ee29e78aa4767313368fc9b8538a6a6b143f96684cc6e4d29e2953c1aadd7d3c29e465f1b57d3552062bb493843f6a4bec13b8c63a84186fc843efa7b1c251507ce8481b704c867112f1881e22df0105652526bf68949ba3222d8f84bb09c1572bd89f95f46a082fc30eba4f8d530a28e923144a84896dffbd6394e6ab1066200a3f52be323d8d5ac2e9dc8db1372959cbb7fc19882438dc25602f09ced8e75e73932615fa5f2a8aa476f4deafeb6f31635574aed139908dd24bf64f9fb5b05cf997f835269cf597d434d8ccfe750461bf014a1f8e096ccee628c889a21bb1562d52d59892e6b4682fe865087c6f936f215abcefd6319249aa148a31352cfdc6569b98d8e84303ec3592b43c7c2f0377f87795c09838fe23a50a15238914e20cf9b7a13e35e4a0dcd2ddcafe84e26b82b5d2d47458cdcab63e1113e2f5ef71dfc297cafb07c45cb7cd3261ae97d2ee02dd5c6b3f02a03692ae45d53419807b0e34ec9b4a9ece7fe30fe5f99ec7abe367b7e01ee67d52f8971cb57d9518e51c16d5f8ae9ece7201a203b14a2b7663b7fcaf94706bbf47ccf85e89c0f3c84f3cac35b2771225f626fe61ad63b2301fad1c333bfed407f6e8a70d2948b008ec5389b86fb5fc9202a6f378b814e922721ecbe9aab116f4bec2e599a31d54158755f65e8711f74f3d986bd22a81cc1a35abf227bba97ddd540cd004cd4918b18d354872c6e8679f9a1e2e09e98bb405f1840bcb9a1f4f51ab1a41cc88e26d11daafc62b30946c7b89ada23a1a05426f4240ac5c27b3a68b2c7404c54bef029214396c6bd0e72ff4436205ec25b88e7140aae71d591dc34640d0af6b313b3749e8c3da32cff1e722a041fa59afec94e530e341b2e254a4362a5a72120fdd5f4b958fdaca1f989955c8290fd7bb50625f2545b5c5407886a8dc773e1ecd1000c462d4851dacf10043a00c1caae58adc557570ed7e15866fcd3acd2a71ea04475cfe5fc3acc953b0a075fcddffa3e03c719fe186560bd60bfd24b571a93b8577545d489d9264dca4c3fe9ebe54e5c74610e66eb66e226ee8e331b5407d77300b73a47131ed37b21d7daaa4fa7241c149e85f6c973bf7ee3cebf69367b2a75c521411307e8ac37336aba535192d5c83027c5aa559feaa51991fec58e26b5afcbef79252719741de3c417ad487c275340ceeb5b621b26bf6b5ea8714a782aaac500c7ebe33709de51c2e38ecb17909252d12b7fc067f47ffdeaa386e539cb82e0a60415cd8a411fddda46a012bbe2b03ab6eaa8865bbb6788359dd0acba359035ae448fe807c51afc24fd479586531ca9b0957fb5599d70f46f3d7f29cf720b470cb4e10b52232eb8a48a39c3e0dc0987b50782ec6927533c6db2686712b5ba9e891a0d63a1724c558b5f91e1c171203b766e70abaa303a35964f792cb4ec7934541e483cc968a5dd3ac35b7233b3d047288303ff1733c6296a601a02943aa65a11ce5cf01d956cd32e1e092337f76173060eb47de3cdff31f38cce09ce6e4f3d57f6e8776e7298d60fe4beedbf458b4e89e36178f6a0ce6378109518332be3192f0d572954944ebe9f0710705259a5c635d7cac658558c88ab2e81f1313d662038a5cc26822b1f05d783d3be3eb68959dd392c3b32b5272607caec7838232d05715597405b6bac519ff45652ce59dcc60e314cd64fd5ecb7cdb4588f1f25814682cf82164c6f812c2573427f0e21f117b62cf1781655a5375f34f529c48d117b16aacdf0319a7c75b4eaf413e280bf5fb87291e7f3ec75ac37527906f673e6acc31a4aeb7df27161d7df5a16d6b37e879eaa40fc2d9f9cccaf39b7884df03996738accb7b87df51550803c38a94057faeed8aee1c9975d82559e821ddeb045a9d9c4bb87f40ab35dc4e7146247f621002ac71d719a7267a48bc53dc21c8669128691a2fdb5887c7a9b032f8a9eb564999a608433af1b9175084fd1bf3a30a6a0960695866bf58316e47c6cc07989442b397fd46bd62f0508722076d3a5129a6a609133e3ede8b3d7b7d761538db0092f9065ea9c4e274f023153e4d10739041c94e7c0fec4a2e7d5540302bc61a8afa24ac5949f9828c9bb1727a32668b629f2d4b8729620d1dd0a0ef017b4bd4e8a13a00124d7595f9e277570266aaea0d1ccdfb259a6baccde050b08f1bb7e7f924b94bbe8a09ca4fb6fa8cbd54d2b5b8ccac37c97d96c39c19acff219bbb57ed9b80dcc00bd597591d5c0e216fb9c8dc6161e4b930422766313fbeeecee6b4c611866eb611fa04b2b8900f8b9b4132148ef16b315e7e47fe1220485025cb15835858e031158184e6b44a71ad5d9fa1cf8e7eba5214e1b3fcf13b5ee3c3bebb4bf2fe0ef227fa00759e0deb0ba4e593377b48640581273258efff05913a6c604b9b544c5aca77b85fe1bddb93179a4e047f3c8a5a6cc3653f882f38fbef68f4aff9dc7912c5934944af34223dcd028443b04f519861b3e926e848b1f11e3a9c2e518198b936649784b20819a75f5316a785d5f69d112b332a251b873c55b0a1e485de825e4125be9b0faf2d77d49b36de5e0a646dcdb28f373b41ef13e6843d460a3c7dc6ab90ce34e2aeea3c3ac580ecc43f8a3aad281504d413fca8b82afd4a0fbd666f9eeaf561278102efc1188bdbd9de7625b7fec19f125d6ea9c182b9249af9b9e5ecb04815236a72cb05edda9396dc4d627b82288807ec79795f9727bc58b6e86ac6ce22e6bae924da23ee9c6278ece49b9c2670472b82fb050e0bdef2bab18360d8b6cf141e32c9365ac81af9bf3b693fed779a3545ec7e90021418aced304c297b602814564321aa68492a8c956c70aa8230555fb97cfeaf04c0ab8cfe39da67ae0d2f566557ae839483f710401241e2fbe917522a272bf2597007b390996d63b88a789047985b8cbaff3d19bbf3d15dd3e8ab0f0d80d458065f0c3c2c79415caba3429b45221c73e17164d01de2299a9edf5df3dbf3e2081a4dd3deb6955bc9093c5aeab52e9ea6fa0d961de8de11729548ea2a454567986294c6dd9b3f07ae5ed8cda55d2ba88a4eac7e60a17edb6186b79644e70136d4a3731209a8e002bbc67bd86a4f47fd8b34bd5dcd65c1e1535e5de619dc1dff1dda65a0b35945b53b7b4b876b1970afbf2e4c4f93043bd7b3c212e4326640b42bc924eeeadd8228b9a90f771c829e51794393eb8a4901b6f27bade61f3c54b59a4cdb33561739f188ea6b770e04d11e89906357f82ef06f7de076cc405e9c734a663d7ef2af145dfb7c7db550267afc8d5139862675ddaaa527ba551bb408183c73d901ca40cf17c1bdde48ecd8f1726e824ab303f1316c310660542243367d0d1c69be91505f464ab786a1b23b1bf6963df4cbc75b1551b95076ea77bac7bee57822e41ed39f32d2728be0b654521f5faf50a0b2ca5e4d7bb0807dbf17f78aa97ac8ce01b693edbbd6da6cc1d72e2d74586cc519571b268d6d0ac1c46b236af500b5f9fb3cbe171718da1089ebf5bb6deb6b777916701feea133450f78094b1f5e704751a37db42a91cda3e4dcc6209924aa600b3f5e7661acee9d3a4b3773499861606be2d7d08a8151fae0ca17d175ca42532e13d40213e81e93d6c6e870b7474ada494fcc4ce55b20115a3172ad372503a3e9c4abc63ed01447bfea74cec4196f860ba7cfe2f20092a78f77d57829160b2e6a7f688f7bf62c8d9d5f4d09c3a1854db1a0ffab28fdf08fe31455f40ad15f8c24cbdbc93bc9d80f498deb090fcadea36117af29f9f83db11fc2d2849f37bb91bcd2f6ab72c616b169d2f1d366c92beddfea8b9a93c33bc2e1e61ff85bfacfe470940e30d7261473053b8a10e6d0f0d99c94ebc3aa5710c55a4a7c00fb19c92862a9bcf37ac87ae1168f3d60490183925782680f21076323b37dda75e91a77b5ee156c579b54d654808e0d6682651f304382507de858293588d5c01fdcfaa33ed599d49bb6f58b5f0e38f4a0d301aa457738482ea3cb10f28b47d9f56558705e6a62ae7e905d036304234d9fba9f764e4564164cd48644483ef24f8e8acb525e9ca7f48e2701820fe3f81265d2d954123c1bdf4238067a5262f89f55ab7c8cd6e164cefff60f8cd0811b0f989bf78bd030494a68bfcd07c8245a67d66e17aab5e5e95299086beb07a88407849526c6adf325e5ff7c1ea410297564f4c219738b26f3dca8b72547ed7661a471d886bf0d19ce0d262f6364db95161eba1fdf8d3206528ca285e5b5f37a6018b009c2c5e8fd808cb268896fb38c586b052e123646e88cbe60f9ebadb3d82e77e15c5e3cbd8fc2f67a0e86ededd97e01507f817c22f1f269770b1896c197c1dc207bba71a8013342f175b124b19542729297006d2b9ecb1f3d7bfb5a547a337097c80a5bbeea01d90a45f4d677127a3759b0d994b1ea551d4e58841bd7fed03b927233e2209bfdfe351eabe61a7f33e7c4642298a29e1e783dfdb0ad7628994713ca21707070232c0aec779d4d08c395f5471f0e441103afb34c2cebdfe4b6e3eb57344fe25423b0ac00c38ba9126f2cddc1604634dac22e37dcc3ec8029225cc83f5b09a19c039fb2e3b4b5fe925dd93bae7c7a9845dec4dc6d6a943b73a1f155fa040eba3e9696b055cb0c161fd8aa9ca126d144020f48114025a65ec4726754d2416a0329f61788413ab0542c085bdc7272f3be9f7095e9153b42c51f8718e7a05b94cc8a73d5fc1a9f0e7b8b01dd0760150934adb12dea3ae707b49c4ac134c05009ae6f87351be771ffed1878fe877d1fbe412166e49b72b235b3ef375b83584efb3bbd002b2040d5813d788185902f260ac090684d21d6fda8245acf40750985c3381eac049cddc95025bd70e80a97f212527a9f9d0ab9b3d44fd23f997484ea0d0fbd785079c50736c041a553d4e9bf3bde54017b869922091d1a468add9c6f750229d9b12c5912de8d1bbdeb0816442b1f8b2e3768c58b159d7434b75b3c9ff41660e9f63aeee61a06cc98f28ffd21c3b04bfe9e8d861c00c8fb2d004dc4a06fa687f1587d7741a8be46562245fafd3a7bc88ce1ac0f6b313947e6288ba2a6b27ac1612382c2be71d72806925945e22c91142d2aed7d8fc61ff8d7074e9c8e3e511babeac9eaa1daf87711ad09bcf77f12f2e2adb88e227a29448bf7bf6e0ab3d93c9a900c54f93c9ac3fdcd0da642f41740f37fc8d4ecb9c71920f9554e0023a9d5b44bec4e9c82243fb7a3b7c07689c67b7d8fb4bd90071afbd433d8e32913f4ae4dc50fcd30d58601c30c1b9d3c5225e65c68a69147ac0fc9b6236f145c4e769deaef531b0ea5b4a8f3713dddc3c70bf1e426ab7de576dda6fb9cb1601cf80c57bf4023ab98da3ea3045b09cbb30c53aa3a77797f4b4a05846e6a78ad30dbe0ed10b4d3a75e323ed0100a23307bf049e166e56ee9bf637d7ca50ed553029066719c745ee22a061e740171f1d3d20096c4878a2152de5dff9026af9b3b63b2087672dd726d77343c1aa4b4a493c971efc42556a65b2925f34947b27ece7eb416ac4def2efbd991639f51739f36c0b1fe2d6fd752fb4410f5d54b60726f0c24e872a2db8c4e5e336aaff57ced7995f10d93d92f58ae70584e32ab29703e346c4766590489b002929cdc1460ea6694e87955ce033a99acc84a12326030fb573af39d79a58d1eb5a288b28215e0bca55b1bf4f7b74f06604e371085df9d562585a902eb2b31c5f67729c5449964eecb97311a35ed5d98022e51ba1a82affc8f75656b797bb77d246a6da7c0f1bb0fe6ba6fe2cdee2a3c4475175eb33daab7b5a8976f423fbd14a4f893398fca1c05e98f947dab0dbdb7c5e97cb449756cc2b51eb79eecf44474d31712db8ba4631f28b0d9ad936e886601afbb7c8c922f09bc20fe4ae08b6f933330f9682d0f8cc9bfaf14de507d02498ee4d0a40f9c9db8f18674ac98e0e1298e16c5095c07b898f11faf42006cfa00c0395d83967bd21feee5029e246d6de0b7a2d54cbcd50df46e281f2564fb95565051c0a929a883d39c35f7b236ce0af2250bc5a9125e634d0766b8e9546a0daa0ec24bc243c60982e33d093b68b4a00a681739320b0db22f6944016a9f4263cd654b09edadd0834306934aa74124e5a43467503ca53c60838409c8a7e63df6a1f46900a677cdeffc8a4fa23706f03d887ce95e925157d311bf5f696bf16aee8692c06817113d4de9d57e2b2d9e441395b50e6c651938ae17416fd7a17492dbbf3cc96e49b9b8ff0b80be2fd39522164f871c41689b856e4a70ad697709ef64998cda7b7f2ca084b6d840541292c751b020c76737aee4f24a7d5a797a10b3dd95c56381f6b027a3abe8897c61b6861f4ea2a5f12b4715c2096780ad6058161c7d9d4f20ea01ec21041297eb6f111c7a2964399b9c42aba79c949cbe8926310ec2c75af914dfadff1359aff6eaf583fa73b393e56eb37dc47be8c2d1aa0ae66d7d6d6cdbdca8d2bc0afc4ce1710ecafb806e8a67baca4a9744c6e084c46b45eecc1773fc3aee59b12fbddd590a80e17ab9880bfb82f7aa771cf2b275b0c70e9663685ee2dc5bf6d635ddbf66a8d01d970f5c3a6459ae6c919669d0f6b5e525d2e9e41a03f8460ad5e97effefdcc76fb12528ea2fcfc38623fa83c72d1dc5bf77b19d94260f3ebe7308b5340fa0a7297e7689ff57aaf0135d9cbc50f9d46541f41eb6c1bd5f3ff418b8b17c33c4d2ade154d4b09f16e7cb384e91361353729f163e5c8bef04b8188789a2028f7732754fd10f74050aae186a539ce5129325f0f529d6dfe801091b15f7bf3e7613e8ef414f41c02401cd62def3cdfa0ea7fda5e72a52d5f190dcd70ece7aea96216f4428f6905a3b940433f5f06d6958bcaf49bdf9234163ccf27eb11699b0477fb934f39f3503dc7099fd15deebe38545244ae47c8225129829acfb459c51ecdc24c44617a2e0842e26df52818cb30025381dc734d169636f1fe6cd489f31ea8a7251189647e640ac861b04f1e4fb5545e4af5c8eb6383bc5dba27aac072977a1e000ed369640f3abb7b2b2ebd7b85c3c61fae46d245e9a03275c2992967df6e12ba5b3e1d5fb011aa16872f7f93a8855eb2e52e29d33a3eabf2cc48b87b89b0ad73f32d5717b3a57c0d5fd44170ddb517932bace601a0adee530a97cb6608c6b7c4ebd34ca0eb1227d6b08f1a379bf636e7e99d42d8829d6bf76957a1cc485f01b8b58315590fa67f46221b6eb443e4de2af9e2a0f48203794ccdd25b0515bf1a4c9a38691c5fae2d5434e0e28f8ffe66c187b1f4cd05326e2a8abdb93b185025a19e2d090e2958e1eca4003a27a6adfd5b581deb3a5543934e78bfea18d621717a71038d5518aaafd4f66fe90b9fddd3a1127da1e676b66ab30e83261a41d27c49b0f4f4ed436430b4b7c3a2495e12b93b54a2ede4becc591a1f85b4a7eb6452e9bcef36e82e72ff49de2ff2ca06d2e991919e7d24580cb09b709ceeea7a90c93bf7b6f3ae59b349ede73eb9479f68b73bda83ea00da9620326dee3c2ea1b9c34012f06fbeda90be1bf4bbfd45635b9cd5cb7751d947b05cfd40df7319c7bfc8aeaab4c18927305a366f46eda8028916b1e208551c992cf960bbd3ed6703f69f4e3c9afc31f61ae271bfd7abf5f080d2e15d576fef22d2f54e1b738a1563447b7b9c515be893bd650790bf9d36ade4bbe348187daf7914f34e3633984a07f93663982b8c71c2786a311e4d7d7a5d2f14dfc0f8f652eda2516ae64fc25949c675884c6d6e6ececbd8353ad32685f8e5fad67ff9f3450efd178575be18a1569af22ec360eea424625911e819f11e186f90eb99ffabeeb9f576b2c1f282dfa928bea7ad8e8bc3fcf3dd740eebe5fa94bd5bc921e36eb9702e1cc39f3cea0b4307f86e766f9357462362b9d5b996ee2637c6d067e22bcdad7ace1852b179b60f76ba63d04ace90a9ecc496b7ab04ded677c1e38f56e3e6a34b7c3f227b0e6856091f237c5fcacc860ae43c90b723a423efb3fc248e4a0e1e23a130a4a11606f0c99b30f61c29655a2ad2166e02d4739cb810e2757a0c4b75824042db20032bb3ea36e1173c68269bb79b8c5bc9357b158e2ac65e639ba0e3a92c5b65364bf13bf77700e0b3ba2ecd7e285451f4b130951005e108f3d69c573ecaedbb91bb00ca36fc25cb3f94fa035e77929536eff1c248e75ca4493951dda257d934d897ed9c075219710b5b344d47976de56421b7487b5454583da5c6567052ed630e06b3d0cc4662c17fe0a1ce31ef988acfc0249a37f2685c7ad06314567dbe1308386a435608180189e0faec3054d76df7ab9d5fb97c469b210684f16ecb120942385b51dde2bb1f52ee00ac32536e59467a90e6970aa65127ebefb743fb01ae0c5dbfc22a172021d07ca3d74ef604288552bf98114e0efc1db418000edc34c75df8318f393e74c4e22510427df6e25c7bb7df185f31946878394dac630ddb1886cbe22b05358048c755afa572784a00b85efbe91287774e31426950d38274ddb0674d40e11624e7444d69e1ceac19371363537f77cd37ddafd9431adbf2849b6ea3d268b5737eb223e9046fe686a88414955fb0a3b3b0799e3a12a6d75fb7db40fc016ea14b9d803157f012a493d7e07b28ea5f2b624507ad72b61d1ee3c3199b491d7eb39dcc023214a33989a1b57b7d717b90a8b50d13b5a24e124f7612cb6a2a89a7e4270cad2a216e1f545cbea88876d3e574f9319fe916ec28880f360a257898dc28ee8eeca1cfc28e6028b80e8529ac9a3140066b5486f5c8e7dbcced2fe6bd0c2855562600fd80e136436690e29ffd62caf2c4167da9bdc81678e11c74fcb287e6f9f1f482eeb8e55472a76fbb36f470887a75d6f81e50b3a80a24cf56149db1577e87ff507c855f3d8a394f3e2cd766a1316a028bde9b58dd09e9522d448f40df748e9e8fc23650cdd401f094b8052d37f1660c5e8d34253fb67e569ef2319830d35e29fb467df90e2f53c3634de83dce9386c807df294547a64283cbd68d7c5e53ab4aa66192fbb1aec23714867a318f731836ab217951ddfc31b5bfed01df5a0aed088cea62160d6db52584908918328e480fdc849faab8d761c70a1644945672d78c189d89c1df742afe61898bde8b9eeec86817e374549a97130f4f55a92af22a7251d1d1391e101a089d21d332c9b04d715467d21aa9f22dc852534b1437d7346fb820bcffa07c4588cff9f6a6977796588dd41e09afcdf4b8e81f29d38f911e375cf6ff3abec28824fe5ef9b583a44c97a00f0af1adb06fd57a18d84fc0c66c71437bd42fbeef7e9161ee66f6068e358747f7a5bf31a74d094b06a69397016544525a21216e793e31b0634318a630fa2a84d5c13e192f0e19716e5a7c52ac761e62744884b86f7b8e252d0d6f0338bb4bcaf5d90f2b0a58e94c701433ae44989aa0dc35a60eb6e33a34402f22142cf30f23f4acf0a5c0a97488827c0607f793fc3d8d5bde921e941253a75eb4656df80088dfbe56290fd6e20b60de7c8acebe52e0210821463976519801c323f0fc9e7f115ea55a058b1a6ffa2d22db896a80b504c69157183bcda087f805695ea74868359ac0bfc68f2603af47986ab4051932200b0ff4e97b43a74593ff34abe6c0a6d1019b446d00b5d563ad4ce74c01e6a087ffa8c884ac3d3226c4a4163a56b395deec384676c6fdaf48ad77e44de55cc0dd7c2760acbfa80aa87d98b426d4d5c11f61c517967549b9cc4d338beeae4955754e34b66a4ce060fb7a6f84c9be1cc3502758c97381e944210650c256dea35c203230f86f96fc733f034b471fd75e9ecbad5be5396f9fe38e3c8abf5fa2b4f67deb78f468648500d8879879b03036faf04199a598888c9d666a14aed449c3b7e8182406a23f16cc5b21bd1b08c834751ccf81804e127f48636c44ebb319fe8f65cadb4a70db39c421cf4890cc545223504baaaea76649d4bfaae79368d6aa24def1a7acf1534ce152dbd6bbfd7ef230abf7c3c5c18f15e8040fcdaf91a2b5dc05dbdd64ef06e1f12020dc98567ecb8fd91231062e81a2d5599d6aecc29689b1a427f5b0f15d35ede9c9190ffae8a5adbd1d917ca0a2992d0d666cb3e88c19fa647e1e5665d579aed10b081343f50a742cdde0d8eb582a4f2d9fe649891b3c3465c08ed771aad7e64da91cd854e46afea0dc67f4208af0e7507bc7f9fc7a489cfb2f0e6cdd8e4d2a82e2e9e6b1356c0cbbdac681b08e75a68fdc24027284083c1d0f5933a3ee02e30070bb8ce2a89724312715876ea7a43a1c89b480d4482cbea76e85df6a46f88f976f19ea54b82bc1dcb993329736dc1bccca8e469879427fdd53df80b32dd64eb73f536643c48b18f33c210e4fbde6a3e588d3c072579aeb94fbdd5fafc0d9473e7839e89222ce6dac19afe96324b24a1203a7b0484126533d8622727dbda5b4a6078ee7e7ae844392940e7f383608d123a8367f93623c36f6b538a23b46f6cf425d21d9f3d09c041f374006411c3185ddc08ea5b711c62b458fd931af037c219bd8286ddd146a2f0e02f3a9b0f5ea8a7a903f3f067cf19d5f4770845c9f316c13012a266c93dab40935941bc52785dd5ffdd6a0cdee23530b529ecf3649a917b8675225c324124047730b40065f38eed153c78bd4c90395d05d64de6d9ddb9d33920aeef48a1287fe53845e4e04dd5195203e47d96658d485379ec5dd03ec32b8bba1745e3ce66da6c44c761037f05620e5b3082601552874412ec899ec7246b8f4fd7143f32ed086dd4414ebd64c56ca6d7974c36276a086db943d1d14e6c2bcda910ef6b641b9bf5a2298525ec12e296bf855bd42b510e8ea75cfef71ce970da80422a18533e1789bc031182df62f3ea7fd3d5c34a35b97975660ae5ba119b90c0279548ea92e344ee4bd194ef058ea0fd8e4d01126f7071fe43d5a35409702b4b404e2392751b776b0efb4ada485bfb34f8b50aacd8c3873fe71567adff65b43744e11e3393d625d6830c422ac52053b4e9aff07db762fb53ec37a2c75639c62a206186fd46e4cb3fbb74c1d96a3be20da7d54359ae65d82706a16a83bfec6520678a0a90835d86189c0ce09a0ff03409a06655b656644a027119c6ae0c7ba19262baaf3185e8ecb0eeef43c9eb549d833b5a9a411ab249a99c32f972a98c7209723e2f00ac80e4d7203a1c73e92c8bc6bff2e2c33974b04bc0f33f76c2f9b9cd08329085957196d695a527fae5364274698caa483457c3dd99003af5b6e870be25141609cddb94992fe43be07d98192e552c34fdf6f5aa1b2e13eecb966ea0c1a91242d2693df47aab196ac77f4e744d32bf646f069fe619cc449634ee68a0f42387316c297065069fff5b67f29fddd780cf93fee22997cd6807ddd0420c3aad118551bd2b0ff444aca6b4e97e897cc4ba792e2d645c1519a2a37de495abb8164dbd7f7d223aed073f6e34ac8259861666cc7540767d82585c0c0297a93d78ecaa1986524dac811e6c04c9eda8b2104ec5545aa3e860a4c32544856c80f575c04ff80643ea94d2d973146547666674d867ec3531b0221f6cee08fda4b3253a7a1ae5e2e6904a85a50c2470d2eefa7e66397093872ad39a2d630f5d3832a0fda2a37f49ac7e1fb954942ef7117e6daf76a7bd2f97a1221452d2bb959a668b370f6ad144a1bb7a1f32af0fc71669d016c634520b6157a500dff3808ccfb764bd1e3890460921f0f4bcc11d7135c38c773d37995b3d5c2c6c64ecddeed69c49aed3f13b1e524ecc79c7d4b9a85461e640717b74a1eaefdee6140cc6a978461eeed45a3ab065cc4dfcd8afdb846d2666419283297765d6df802d9fa32378abb62c85b8bd6e1ce4e24b91a1ca804f095c961ac2a5353f2537ea1bcc451757a772ed46e29c078bc548ad502f0cb997179b3075d76946b81c7f5358618eae95e781d5421854ba203a37702b0733310bef98a719ea88e8ae41516809ed70c8789d456f1980d541ac8cd05580bc083bcde90da38052a2f7667a2d8e239f2bf8a69c3202332a3d7a1eb247d90b612cccfbac38b3b68d146cd5a674751a54d314d48043aef74d048e63432e037a693c4d544943aa959c2e2b43b1a623d93d3578a90339d373f8bc3014e0ebd3ae8179509991fa960c642d3d1fad42cb4c8977f2c869d644f8166cf14ab89225cc5f8e3ed78796836fb0708be4302fe9068813ae5ac5cfcb30dbc6fefc7d836d042c7bd4d0b2d07e9cf71837adc9029edbd8bc0351dcbb5853a219fdb6693d5ea71f5fe889a5aa0ebb6b0f804205a4748a1c7faf7ba2f0e6f22b57e7d61983364c6019639f1a2692f98244349ae203149adfc505f37b345f9045001cb1c7477956cbdb1b35d900e8be6d4b5edbc69b0eae07a8d09b8e3e4ee2204aa1b82644dba03d8166aab170122ade4f759940c9b978706be67b827c90d6363a6acb8c4e543ed0063735d0cc2ebe05280b0159a2da067ef88c29ef4e2ecfddfa6e6dccb7d886ac5e7cc4f9d33605c213f065eb7028ff051205f5e865308b59f531cbbac313d69ede47ca71f7705a8b5bc7a2dd4dc5a11598de425d7cb1a1462d189ba6deb84bc5a5dc84125b13dbdfd68de99661150efd93e163eb644ab7394d2554e3bfe9247d8326844d9be8ed574f4b4888905f2ab4e75bfe0c5a104af1cbed13075e04e11d64f1c841150dde1978f468978d9cd5d46ca0367dc60c2f5f3daa315a06036c885335e91c08feb49906dcc326212281558f42e6f102c636ae6acf1ca5aa254d6efc47fd7714789c1195bba482ec63119addd9ea8722038b3c44eb5b2bc36c4beec695a87f8f9b7eff62d46732520426728e3e713f5ac605e955131c16267333f0fc03c3014a02d22b0d2fa0d1e1de5266c5e563ca058b16686bcd7e0a2cad6da398f4e2f7f48785c3e854e80df8b0b3909a4ba8eadaff069e098a285ea7f8fbda0d895439d29240ca1b58b40c1bd084ec4a30ff22335431530ef098cf8b7c4a569e555acf44c1fefcf0c36b37cc7590b6ffd18a2b3439a5c2aa893d22647ff810246935337794174e901e8051f7644b884c2aca0c484f146f935583dc198990299cadd29ee9b06cd1c11209467bd1d6b8e5fe31b5ea4104a33b2eed7860b202b60b17f8da624cf24672d2ce4a3635355dc85fc8aa095fb27ec4c1f9635a8e4cabd130f1c4e7b1e7a1d603276f8482214b2b8ad76b316c17a632de2151221df3c2e9de0b6df3b70e119ef82b81445bb93414371ae772c3005af94990317c83cd05dea64e91cfe91c19fbcdbf5cb190b8043a5de3a6af5163ef913db02010304a54e78705d2745f11fa3357b15ded46e49c09bb129cf214231868a21988a7e2c7bc476aba7fc66fae9fe4fba0561aa4577ba80ac0327b2a5ac43b256e296a223cfec39071e7b5bf7ab2d65e857e30ea8bfa21eea401a0878fcf8adab7beee2c18b6761786718e274b4689d706b5dc31040457642b75a5fccf91c3f0a29e235b9402f4256166295ee11204c3a30d0b215e8f959c529ab1968d2377b0b635d54274770e375053b4df97bbaf5434baf8f634b77a12689ec55c31578317e5674f6dbf6f899a933ffffa26acf139f91c367a5590d23411a1f2c5d9d99a7075680ab7ae4c09e11817bf789ceb6ddd0a818069bee51af7b84ba286a43a5a105ec2991292e064feca258de6796fd8c3679b883f55776b131df9b9532e1d4cfa8f163740adf469db1e4c5094b4ca69a9ccdc04152cb7cdcebe681d0d3e8fb4915d9a5455f2efa2ee9994571eb3f8c94af2ad42939ca405de1be36fe3af279dfe22aaa6f12252889a59555111d408c45716fc1b5dbd075fe5e90e97afdb069d35caf510378d5b5c836b9243ec55be792c1658a79185b1b71686ce9bd4cb7acfaa8348b4376ceec64348c29b21867dc3d37d4bc8b7078b4a4ad04a2c62583b2ba380345add51138614ffb6a82a3ea117e34854d89f377a626f6b3d4e9b2c6c2bd03d782b14582f42fccb8ba0554d0ddac2b5e59f0c4dbbb15731922a2df1c9fe026c60dc7d2822e8bb03a72de1e2f0d46cb60a23b8bb6941bbcc0a3471b101e8c1f891dac088d75d4e95ab52edd8a4a4cc2c4ce25446fe7ab04471f2cd6ef30397c050de0eb68d47a4edee5e11f4eebf6c983e63cf89e93c664cfe035ee6e71ad257965567750d4ccc8f6acb2edc40dc932121f83bb65f3fa4dd9b94e58ccd91b60f2dc092dc019d54dc98e2f723df7b4e6b72bf26ffecbf17e9da8bc0943637114efaf858577f8bcba1dc3b5ed5547837fda09c487044d92bacbb3a3b90d44747bdbebb3733306f0c806798c5578cc230e14d9978e4f5cfbabfa1e61f2b82a20b16d995ce7d435de2b5205e883cebf6286ddf824859105c2691cabc1fcc82f063b151fb3851ce1fe3ceaaae49e60d0c2b6f9820e8a911fcde1c14016111427520379c7c61a6453509a758e070accbc387ad1d49d10550b56dddd0a374d4e99c437b31d8739e0c9a5625ae833ef36bdf045301ab09faaaca536188d807f3e7517","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
