<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7f088bab05e2095ecdb4ff72fb7af1c5b68d77718a7a82c5592272f22f17c701114f73912a3eef16b6e81d6ba086de49f1c526d64cf2923c20c6cb571111680f988e9d50841125eaf41bff4f4162c0301a5bd3cc27e8dad5627614ca87475f991361d9f2431776532cf00e8a1efa6e07dd2be7520d198b399140ce87bd51b9661d39163ea40541260957aff1d817a203026509b09a80a2adfd352c01cf4514096c852c13870526cbf27b830739d3134db84eb6616b33a955fdf9733ffa46df468315fa52656ec4b775449a224f9fbd29121923442e936a9213e4fc8318d0c062b3f003cda1d760f9ab27e3aa94890172eb6821b98b10cd40e32660ea8bd033c20ef31a632d7968800f230d50f964ceffc84ad2444f8b52b378160ed8fc71627b6d53fe613734e8fd1e0dcb1a0243132a81b28a7a1a9e97cb9b959cbd47d538daa557c1da79faef6fae79940a448c87f3d463093709cb2a864e5c0066250dab2120106791bd8b8f1c02d450dbf5960c266365e8d5b7f4bed8f0c6150d0f35556acb3854497250571171677686999c9d1fca158a24de5946d54f1baa911e3b6a5db7a319f471ac25a1244d6592160aaeb94aca25cca759ff5655b8c521331c174ac9e1e1630f8fcca6d4020438ab7dd9a42aa92d60c07a4501bf4e14912782c564012bd0c45ae86bc3a9b6c49075121da8eb263101f45bbe15d75aa483c2487bc009a44709497d70b9d601521778d7bdcc2e4e5f17aa8ccb890cbaf327a249601c94389258bdb589fec4a2d606af8a4a6342fd900567cc8b9a2a7dac296954c78d04027ce0e5f097897961517b3ac8539ae47e8d9f11836f9df7fb0c11973d21f68c18d4efdcf33580027ffb84a2e6b0fa015db2f3a62ef1603bc8f5faa3b4b9ea7c9ada730f094954fe2c53a951bdf1b3ddf48be25570239e6f88e4c5cc379c15b55c5d17c71e4638e090ed71a6a1a7419696ba637d5f198babb516091b518cc83f24fb74b4044f4bdaa65be6b8d6f1fdca9dc6a96978b486ed320a5cbae9e5585ca6726ad9be1bc079e356c70bfaf19441608e98b5e414a224df475607b0ffbbfc4d8059c912f97b961ebffe2eb4a4d33ddb554799583519a1c90635d1130e0404550979098894570903f6ffe2f7737924dc4bd49d9108e09ad2f8facb4a34b1d2bd69f832dbf421e9906a47775137b47531c3fd7bf5c66474e4f1e193f2b05f8fbd9cd574774443ce1ad309a2575a283fa4a75ad6e7da64729b8f0278862f837cb69a4abff8525d1f6fb842f5b5ddce67024bdd884bf6d5d2e4163e68b450fdfeb452f3388c00ee977d660bee3fba8089ad4b1fb6d89e4143efddba68be7f299e09b4f7af9c4dcd217f3f411d2db52a53fadb3af26036afe3dc759419bacaa341dd0d8b9a7c39d4306b5c6a2d1c21fe4c8072fd2ae53c965d0337298381cfccf2ddf60cb1a85a22d21ceb1eee7dfdc61185df38a703bec65ee936b01ff8de9b727372b1502e01dcb4044657902e3db5711c6e83b4ac8bb7a5a4ebb4044199121b2c70b683fbb04cab9547069b23569a46b07beef89117e623d1632e6a87ce02dab8aa9f9a02be6eaef56f3c4758afa0db760e4a5727d9bbafb051da82b36682b98f1b3bbd19c64173a444c445fda5dd3de949842140cfa528ee4dbb79d6fa76c6819dd0a0d49fde5363758c49e7b2b20dd1e1879c5252b3c13f47a6ce90184ab7c530782c451583c940ea0fab2cf14de0ab1bc53a89b3e0f15b76b45d3d479912b864c16df1d53236aa8f391a9651137b2fc56721370ae8c83b6250e23117970b19bb88d968b1fc2b571a63da79333dbb0721690316159f16d5a8681412c20e2a94b3e37765c0c23312ebb2ac3530eb2fb6a3d23faa4948a4db8f8764f9250bf22e6e3e3285659fda409a1ac570caeff9571f17880183a29adac48f2daea195ad32eed27f054700e1c4f2f36c4fb6d614dfedc9b2ae043252ae3a77937ad55d23dd5c1a449bc497627931c65a28dd3c57b39d9091a52a171708f460b62a252525d9a9808c2c01b54ec5b1a45c5021e35c87581408d2e4210c5f4c0618e25596464558b932dba3b4d3594327202889ccbb162f14419f243b11499ac578d802e81542f284e969303bd57136044f8e5514f43f78138dd975cb71a58aa3f7e32fba37bd07e0d42a8339f215684a978a508047dadc7d73b972725fef64401928dcf6bfba58311e016f8253da5a5be9eac31c27715f73dcb3a28df3fc9327cf2f9851fc0cf0fb71af4691245431ef2ac30a083387eb8d4600c5f5e9af5c0a0268666a29c0b7f6739e344645698664bdd574ff809957acde9c7e27f86947e9156851e7e2c192b66909669cfa5f24a2ff1d894577e6976ff45b40807013910f3168e8f3de385c4052f9402d7521e9fef7cdf6395c9da014d8e041ba14f2c5e1add84deff4575e7e67529d3365a11fa755de57eaf27abc6b1f334f3092d543731ea1d23d73cbf756864abb48fdccff97a265e83158c8e0b4efc02a2d76ce7d4e4a90ef9aa35b4916be2670407a2bc1ed35bdf3af376584ba902f441e9abd89a4ce0fdaef2ef044a881965e009d15b12f386c3288ae87e2b090c1f08281b0aa649f3351baf382bd3d256638bdc10f9b4771b1e2bd7f1ca439f14176509347b678b1e451bb455d6b2b8e37e5b225418b729aedf975b43c9b1d73b7c67966053405d416ef6c66f66e4af2580a1218e1185e8f59dcc500474587b6fbe7be2077dd29ce82e79118ea9b6ec17946e649cb2ed6cfdb0ad25f9dc3ecc62c48b38c5545edc12f00ac67592f1de034bc0d03e6ccda7ae415b95897b6f8e8a9e24375b0f99e66bed9f37b89fd5cb73c6f4e05826db0493d7e4a950dcffd49f16d03b380ce627944b4f630b26f010992d54b9db8c9cae5d25d66ef88e7ecc310c1b5043c0f4f2877e60d4dadf406a6b6c72523bca4aeafe6107de3122b8acfe4998a39cdcc8e265c47d2ec211583ee9dfa282bb7a4883d40d806dd4ea1527512c2129b6f90d89646b495bfd157eab86519a03cebb70de85d5802ab7062df13329c8657164a9be1d9a3754fb24e1bb160d3c1aae3f73fc38f4b5b6342f48b88ac15922ddfff6fd0c9fa71195a1e1394224248f5cc9c55bb4107f7e06781dde6326792d39a543536f60218dc62dd240bc341d0b8a7d6762e7d04246085185f5e8ef38b3db2499936aa04ef1797bfce86cf1debed36cde91b65fa8afccb9750839c6ce378ef7429682eefa3ba7611d35991219ad1b9c34765d71ad5e5b1d71b15a1323255bd86c454bcca9ce41a90a359dc2b41d1af7c86c6d34aae427a103efba18e8d38ee5ea773d5febc646cbb3ccca69e00f88c722911b919d6d22fb37e1125f1c2a898fef1243d744854e7f8610efbe2d7850c13d64c8dc6f0b4588eb98f33b17ed5466f169c710cddc68c22fa911657671bf6c97c84046c22a6e164271608b68c68e8303ae216a8cadad27ab3bb230cbb7117b7dd694127ac5ab9bc2e4f46f232196557036d57125fb936f34bdea79ae2c8012bb567395c8b960a09d23ef0166a38f8290e4bc94651e7852d5b388be6f54249ac5d9828176a5bc73c6fe653b04fa5d7b63eeefee76fddb8e2a685617d326c21f586383e599dcbdd52d384f89f5a335af7e75c42bc2b3f0dd290b976064a35546a4b829af8d09134a8c4d97a0107adef87a9be140eb4bd344fa43d5dc6f605e786999c0965151274fae9432931f6521bc6b60006c33167c834400acd2556b6113a2e41c3739ff4187ed41e55fd98e11e0758a11b5f75f4e16620df4d687f79663ab53a05b75138026dd0a77debf2258d2c966ca3a705598759179ba45d9860a88de436cf99942372908e1fc19eccaecdffa275eab244e574c4131ad9df86e1e1d4b72ef507a1066ac33d6ad1e302f337b6d881c43e9c494c5b4c2935bff46c2fa378cb1b2b3658e553adf738e6d0215c00e7dd2c1ab1369dcb41c072dc3612f55e2b1b602cf73d329725e194b00e7db35a78f3d684d9fb19400ce1fdc927501376f0e3e8078163d52653f29f22c22bca22c58c99b1323d9a2f7909d253422374162571987072e5ae30fd818882e990b60d8c36a401e03bf2aef6a35561acc9dd2a1f68824a769f377fcf8dcf699a2702f9a38cb2539d1e461c442ffe04b78e036c19d57b05a2fb77ef99950221d57e350b32fbfeb926ac894eb2d036fb1264059d1a3389bcbfacd9b5d79c2f5b9c2b1942ac88a1331e1b3b324e38442f29e9350421a4c4aa9650a0f480b211951f409ce081c88ddeb434fa1cafee2c18a0af49097c5bdc0e79739821942dbbfeb97ae69eb4f32c4988658d2fe8d67f1fbc0473243355c2d620d6e689e43615e48e8aa790b2b7f05f7c588369a2f816da290370c66d5e81c5db5dfa9b18cbe641f357661c92c6549ef9216798f2864c68a2990545ca86faf3e846f63e99b313c373c925b18371f2ccbdf1faeb1439589ab86502a213a7637518ea62c1ba9b80bebb265c03f9537d1362a1a6e5d861488693c89635ad6201a2c8dcf1335f58d7f5921bf59e166567375d8c0e520773ace58f01494b01698fdba1cf178f80fbfef4fb27206b2a9469a847ae1e1e7c7dd28e1c5abd774da34f7749a12a4a732247807acc0380e72fb49c62006a429013fe5b7f3b0cc3709ce3f3c5fdc52214e70f3290c0a983d75709f295ae67d5018c55f507d8ba4cf562356fea3d9c3096a2492c09fbf38b6cf59e3178ea0f57a186b71f708f355e7c03606c124bf61e953802c99a0128fce96975e57da30d2b11c06215d8ac1be7c951722f754cf9bf0db3052608675590686fc9968aae4917417c3613e9a9f5706966ed21f0a06ffaed7790675b53ddff842b69fc9fc4fd3bbf201ba5efd70c7fd2112f5ca57db6395446293ac127456fcd432960025a42536161de20c89be23406306cd945933471fc9d821d932ecbbe4f9ff65e63011f5a01f374a0101842b384a8b103396183b59ae7d7e96cef1c9a01152d6a21ca79b1e0be3db2a49d3401e5ae46f9ac242f2cbbdaf0d02d80c5e8d6d3b92632f96737cac3ee9b8e2e8a610b07a05ad0c0faa5040b55a3a531cb1f8ab6bb679fff0f049a4b74bd500838f643fa0dc004b7be18458348431c05bade92f86ae40276c2cb9c647dd76eb89d11525d424b00a15e4d78e9eef0eb440d5720c1670dfc7926309ab2749b4135f42b07a460596830bbb2fcfeb4afcfb57c7c6e08e78973f20e83a9d9c15b00d926ad1dadaeffffceb0ab202eb6893e05cd1fe3304d23e26dd2a1ce94e634a398aad39213d680ae68a9d959c7db9a09bd40db59cc48fca30b4170634b3334422449d60544b6a95f4de5deb83e5170cc6cff2b14021cf5483988267ce553f7c4b4428d2805235f9ef59336d28d1572d735c2d0216d94b74b32fe7c7220bb033f1182e56250bdd96409a2c6b1f05ea5a9057d920890a88cc44cf195e20a1a86b06ff460102513fddef28917d3597d1c9ce117ed624aa62179756706f47dbdf9f4d7f9ed2062abc3f4c29264d019695ed2baac0b28258af00a209f47c1aaf38635b0e1dd1a86518d4142f4117316bcdc58150aabd6b8e7ae00e8a0c290d1ee71217ef43d26e4eedb24e669ea2d1a3638b529cfe12d8e0f4cd2da97ca321977669a70c0042eff8d7593434c43943ac181722e5be5269e4e6963bc49ca4b62bb02af655d7ee5e52601aa726598138563a5723f64b15805db6b4bf458da00b4227d700a2cb931d3381a0ab1fa67dd530acb383d58ce512269cfe8cc9eb33e63a3a68e0aa722ef8065064cf2679746cecf605c3b394fc222980c94501646dd72c62dc2fb1b74500938524f7977eb1376a07479e0331e21176b30a811d56d75657c871d6b301d91f385fac09b958f6f9c1d1c353cdca664731c43e51a34669f377f04421651ba971e3eead041a7c7f789c3c285779bd026f1131c83e810b86b7d11e1ec8e2bc3f024e608a6e6d8d95896bf807015e56f1db08961f6e67f73c69c1da1a157125201f2f7aface49ccde73737308f7acdb5c81ec18c87b13b9d4a60c5398ea447e13895883be2a8987508c38767a57d29426282a3b9531ff4ca809d62a53892fbaeb431f5ffd7ce6de317092feab7ab6e84d06ac1b5150b178c193cc167fffbdd97ce6d5b888057fd2172ca83fe1c0a824c07505b3feca9b384217209778952827da608f40f4aea5927238a9311411e24c84becb7d8633710fdbd55e2bff97153efafdfab61f87c366b25d684529430e0b8f1575b1fbe27f3fa84156eaecc5932003f35d03493392828bf54222b12dde693c65d8df3e1140ce3df1092e74b83c6a56f719037c0223f11bfa06c2df1b514276ee70a283d738f14066c5c9721110d08c723c3dbdf4320e231a354c712b6a676660c824287994b32f0abe544b18cb58bcbc151855c3acbae0bfe13b17cc33f2aabbc82e829f8c7fbb4083a8fa90afc42a391ad1b3f9c1390b3eda0ab33c904261f9ab6b18ca6180278d52e3379a83942807b5ccede64daade834d8e238122ef111719cbf04b36f231c58db7fac0a57ebd5edc707ed21627f6a95ddc430c0843a525abd2543db7b125b2af27755cbaca564bd4a8789b7d8ec2bde204bd70edc2f8b138dc040a890db5b96428c145bbd0e3582a690350eba33c92a0e8fbae6c33491ffe78d4f3c75fcdb9eac076541a514d0955fbafcca28f481678096dc48f8d4de4c2dc18e41a77d378d081d4ff4ca4bd2797878bcb25c66c01b24b1940f73ab3f543f1db2303027f41fb5bb58e8f2b61884a2d033c58b0e1c664da49ae84163e05c53cb6922cfb1c7717df9e4890e8fbaf8a7de7b8658b8d3c85e5055a2db6d35b8f433488b6e81d5afd75985390727112e144367a30748a82cebcc029dde3e5d981cbf2769db5385c34b713907020a55058bdb38bb8096154177c45b6390335d120566e3199bbc140d4bea73aca2f970fb513ad58086cd98c2d90b943a84e90c361a9dd26dfd97fa9c9c7312afe99f56e4c17b73f5e8248e87f4396c5640cbae645d0788724c9e535f4a7826ff82dd26c0fdfb87eae5e5cb11d645bbf9d070278d4a0415795ca5dfae65318d61eba84b32dc51af36c064d8d7a9953e80bd7eb4ed266d4b81ef003be0485f624e269f83089b94e8e0523d08c4066ad318ad425cdd80dcd8e6412ca83aa7b85b4d00c4ac7af2ecbacdc07a29b4e5e4a54ade4bb3ee895337752230287adefbe9ebb454f8f3a9219a0a0df4dc708f695e9c2db340eede40d26145b427a821b9563a045da8824818fd2383c67244197c53578c7dcd5220e5489c0e441b77aa6e96b949ccf8f69e51436973cade3139bed216d23556844dfc22f0908c5d7733ffa85685f7ae614818128ffe789b36a30908f769ed50dded40a43426b33fb010d29b208b3121b1873856ca8a9840e51ca3eeed11569b39c877203759a572d8aafecef3ea0a5b8c8a4914353ee0d074a2475651358a484d7b86885afe5541b28351c2ae55e16d12a586bdea50a807d6871e15e206fd3827a3580fad623628509f7f42304ebef96a837ed83f4c7f5b7201884193099a382a117dcf56c4efff43b151fe9298e74c8bb9a1a7dae72c5ebbfa8405224962396fce5915606b30fb860d91aa87e0a212cc348b02176c95943f1315d4e3bdae370557bd6a7c8a349228bd719ad25197ce3226696f795893b4d94cc4b83c19dfce4004e1f8b8ec84190f91109a831d38c1a14d19e73379ed23d540f87195fe2d29812dda34ab156796a0298760bfd7742820c03f0c8ec128186890a302e1884f54ed2cf16822d89aed537560e831e0f5d84651a2ec92ac14e4dde2d33bbfbbd56324cd89f5225dc3cf3d7b72a1773bcc6f7cc6ddf3e85b86af12bf1e52aa3beda0f663cc7bed01b72629cbe1b476fd2db2f73c8934fa93d07fbfaa33712de444e05177e650774374d6bfc10782ad348cf5168f569d6d9d4c7dbd6865668dd6dec8da66a283a5d07c7e69c936bd6e132c2a88c7fe300a5b491398d697d66f094011dacd7ab653c67c75116d45f420e140d3e912b395da169034b52a210d06b34e9ae6dba0eed12adb586250263967e848b78b11c1e4ab340087580da124afa251e6b679fae073b6b0b90d86237cad67332d77c5c97f2772be840cbbd4d2a82a2f3819499fea1ca548741b1aa01d077f8ea13f20e41eaf59a1d1af0f720031ffbce2738558bdae88e6612a5b4c33f4c1f2b9170db6c0b7a948a43ce0f04415836319254a33714e14ded195d354abea3e72322673126c2d74170a8b848b21cf7a66a0c2bd427d57ea22fbfad3f7e7d63d17fa695864f95571ab452c4ee85fed568a1c73c1d92b23f7a2ea19d95525dab10bb7c7d49c6c879ade4e1dd755afe2fe7b6d6480323d0b911a459c946cceee57b67d793b11f96cba10290bfbd6127382bbd39812baf5e9a95c35d175ab5d873b662ec54a0cdf77b7f902dd232a48d6b05a2247679144d78e727464fdc040513fb1d13bdd07bd1327b290f2c93de33eb7bacfb1454b8cb7ed0ffd22383c72bd03a55ab10d015bd48bde6b96ceb17d808ee4d532b559159833a9377280154e11429a961157a9ff32b7be2124680d6b7fffd031a1225d53394c82f641960e259e49871a832e70678eabcdc945d97e198a4d60fdf23b45cdad7d460d8b7dad1f7e946bebbb84482ce011ca813f4535d9af51e7db2f521240fe00fff13420c17e10a5972fcb0fa1587064d88b36170cc8cf5003f93d267dc959fed242ac40209c178e0b9729c397b82bb90bdb500fdc330f1ac4a387691bdac2336ae2d4b8c6ef1a1d11717a5bfd47d0a0ff4888b7cad4822ac4ee30648e913d35b772fa6362453b51891d7f43be32e88b71e70465e764e1cdae4dcaebe61aa86c66fb7a6b4c1e3ae850b4f46c748d01b21c9cf431c78ae89612aabdcc43834ae32f609197c59ac232852293361d34179fb585cc160b9aa2e6592a9b56d3d3f407f235e829c0665eccdf754a2380a5c2856c75ffd1669617ef1aee4a31c8139e51e933235b9ecfc3a065285e12686cd912b21a7e2177b0b5c821d3b7668fb0fd3e67bcda35896a8d4656744ea4ffa3a81106396eea00318f68ea58fb2379aee73e565167dd86ba27136848104fafddcfe3e8b4c42ee7fd8e17e5c3e72d9df7b55d42d8ece38335aa2cea8a23cc08f69032f0fc57f6a3e8edc53c070160de177c4737111927c6b067ca06425c4618901d900b65959452812eb3d772ddca4aeaa5624e19c5958f59b2723346c14c08f60ba35bfc4b5ec74b1239ed2adddbd49cf1280eca84ef205ce80575198b7a90b113c61c84a9e592b9e0a32bdc0136b2167351c2b5277f6501187dbb6bd95ac911104f8311246020fac2b425a138eb0848191d798f14c7f9c283b6bbf260cee6a4e094f6d14ab81c86a0b13b7a1af93d11e1eb7d04a2ddf1a67021a749245d3aa32b27856f9879f867ad71eeeba7af8975c07e20478169040df5f56004257a78a3a92b6cc5a5c6a4e3cff7b20b12090ad358ee60f6d83e16718c026648e7c9e4e80393b3331b27daebb80164c9908279f308ed5d3aaa49a26a58194fdd639d9b23d6af2c931d906a9396769ab0da1b61156fb9db83e606fe43825929c3a1df833b678bccbcb62cf2dccc6752d0c43178a5fa7903817bf48acc3bff768ef476fa55abb18a278ea4bab1b390ffdeac9fb5eba99eb8406b11d306d27df275546f37612d5136f05cf2713c67eafd1e15faf523d0853c370809d4b5810a4a538d559e448c46952e9716c5a20a150656f34bdb928f4ff2b768231cf8cfeb1186d011ba5a9af40b1d6416c737c00a57c3995813608beacd99cdc3cd5ad22fc059dc17745bbb18f8c3427bef0086bc9d18f99b167c576d61e5c0277a371cb3f53ac1c2cc24deba9f60cafd60aa2c150dce68f464436f5e0be873ed2a268767056aefdb91e636eba27d471f6894f2145419b1ef1791159fc42969870a93480f6cb253b0d24f36eee06327a15421c595f2a3d63b899868e1ff35d9dc1e2608be499c233093c72d7a83bd07c87d0b4ff9762ea5dc1d7e0793c46118c4b527bb898d690ed83adb288de001d4998c307fbd5e11a251742af2d5bc9b37c92f75bd547e954984dc37e95de905cb653cfc00c0d75761ab8beb6be95f2e7bbfaf28dfbc1786445acd305d9f5748049e22f16d29dbaa1b9b4f4df9dfc6481efe1f3c051182e75082cd2d1f82e3483a2b9f37342a91526dbbee42fec4df74173c8dd4b16ced77c1dcdf699bbd030b6be563888d365d02dca29c0b7209dff58582d7a225d7afa4c1183063c6c18d9d2396b4876822795ae36e141ad7b2878d6af59e7c778367eb0d0e75d50b92b4f6e4da41a412c52b81326062c1e96ddeca4181e918aa071e21cdc865846fcdda3f5968663ab10d07ec6f1ed1cf4a4057bf44e67603c35a882cb917ff8939a8775ab495b72538fa8428e5eefa8a7e82803bce634b3688b60d7775368ba4b8756cc6842433fca0074c8684b6304eb184bbcb8c82e532d2e320e0d041b4bf9b5807a876154aa55b80fdd2efe2edf0fb93f234ab716b42f65e6365c0c925460a854b3a4ef779bd4ecd1da92b1e1a9740ab5faf202289f9a8663646d9534731976ec91b961a8c4f903003a328e63877776886355e73769d9347aa42f9b89a6fe54d927b98264c07bdbec3e340ef4874bcc0dc60b85b7939674dc493d0fa6b64443225778056d811d7a5042fe7fe579c14483a1c25acfb69dde15d23d16f2d09450e1388a5f2f27068713def393849d61725b4f38dfbada89b4fb6ccedee51756dd748460aa26a7d3b16c62a92b6912875c67b5ee67ed755a288d77c3aa02c713cb673a2573e35dfde76a2a371ed3553f7f90d39f9ae57378146bdec355c9af35d99b0077d973549211bf9681ff03ad5fb352f23dd4d435b07afbb6edd320b7afa195ec376fea2386617fd7386e1ba34847712f73ed07b8a3e3e93858900408644020072dc6d7d327ddbf38cdef9e8019e2d960b9500d6a3de69edbc42d49843db8207cacd9bba7563d79584acbbb0b63b47014ea47eb84709724456cb894ea84d987c1e968de0197d66cf3b48ef607180c96d503f07e6715c2095fa688590517d34dc9a01207e278ded31d7ff9bd51a6ac7c653eb8689ee2051e08080a83c07ef028bbdbfd43108f67b8cf103b1fea7a0f73d135dd5c619e27a328dcd414f73cc85a0bbe3f16858d1e7ee70efb7968eb61ab818a9ab4e30fc219cc845ac3914a36ab84852a7a5f99ebcb45d897007c248544960c8dcf65754979e189fc32d149b30cd1f9122a5aeb2212fca8391baea8bc8e53129d63559ca5a2ff82551747f0b8d8705d70a08b90ff6eeaedea464bcad1edbf433e6329cf512d0b3d5266996e6049bf65210c07c7ded8647c67ee02568966bba62187f9ada4edc1f7c87a5b99925cfee8b086a2e91eb4af2cad01e35e25af6ceb7d7cfe6ee6dad7ad74bc4d4331b0653c01323e04aca2d146906d20313041f9196b4d7aa60fc2a02aa38571a3e31ff0af35ddf2b9be32d4982497c46256b513afb20aab8817a476e20f63d8cc51c318b9071b4c13abdc536e6a5891aad2fe3ac811c8f1e55c1d81226909fd718026f84f75958d7d40d286ceb7b613e157d9318d6bc18530c01b1f84edac4aab55f5ef2b5cd1794ed57a7524530df0f404b4364a0a224c7f4226af1a10e99494128e3866d729ebd34b25e8eaefd0a2fdbc5617ed7023a268704cc07efd90a31bdb6c58aa9fa0416fd684e04e014d6e646dde6fc9df71d02e43277ca94ba57f4bf54648578b92f8d60f8f4ed67684457022f9f784a943eb78cfe6f1ae6f4512b3417756400a5a6314b22d464b9d6c57a72c84cd15dfe282099ce5da4ba85f063e2d053d0f7ea8a15a302f8a90edf75388cb7d02846f5ce063f398e97a3872543029bd89cddb68981f20bda6e8076ef15d82fd87c519c8dfa5974508885364795b05def8b7297e0bcc169775968740b0d9dcf84c0843493c8abcc4c56db3cf8f36dc30d2e1b5f2562b4e072de38461b7e855ec0183007efc6a9ac068b46a443b751b9535cc71d35d1f0171f7010527a5a282234b05def0aed306168c22b20e7b98e0132c678cde9a5f5b191c48304edcd74e3580d6ec6f5b4fb6e97ac9ebcae9350c85cb0e21b9d1ecbe735a10a9fd115e83017752a7e1a90c81d6704a398e22c8d7e61fff9fd9dcb5f8872cbf4f3e71f071b61fe8b33c48a818690e686f7dab7ab988f82f46ad2dd5c5bc960467022f62bda86d98d46a70f2c8424fdd95b78d5a93c9be7159a75ee428f77d1388aefff4899ad32f4dcda10e9149a05f9096ff2e41348e017b98c446493fa2885f24d1f0cf846b516a9a7cb4c962413d2884091b0fc6aa5b452b77462ae7afc5fe2e444de5965f1eee6bfa61a3894938e17d5cb67b31956b7e2f476c09a8050999c0270586f51973944f4b5b41b555e0102c49919339c4ddf55798c86c07d7a0afce4b9a3f82bd902d8fdc0ac69337637b87b6cf85397a9aca42b7ab2bf3f7da07cbffc33d7300ad3e036c91f85196ffca2dae287c1476fed1ba5e473e5f8cae7c4e06e393ec47218e7f320aa3c1a60a3e9d8ba6177716a986008a2821def0f393b99695148a309b8adb376744a2964096799983f0a09a0e7cdfe2bd3e4e30c301a72c91698a5eb6cc3191816bfb3ab1b1225d6da81b175a4723086e6c9ce8ccb3290696cc809291e5b9bfce6c2cfffc0e39a3f1a5a009d6c344ec01489c0c6990fd31544eb0362a6b893ddeb65761a2d71d8aed4d9427163e12743ac8e9a637d7177b735b1ae15a43a01837c0a1a1839a84222829c7168f0c6ea29afe4cc13f2ab30544b8d5a582e5139baccac9bdc8b49f642ce1593f5c4b9d428ec0140a1013a107255d824ba912700c6ac8c6b2c5d1d478fd491d14568c70330e4ea6a6211297081452b1d9263473d61b3bc1f2adf6de7a65b16e2ed58dd4203c538c1ba2e9e3309745dc67e175f30625d2fb9419f6a6c1b057c725afdf51cb3afcf20ed7cfdf0cb8352ae826303455326040aa01717c1dd4b6aba76593ddc2aef0ff9b24c3633f4230d14e341b1cc4ea6dd15129386e2a887b7749079431e5eadb435e6082fe2af067fc41bd74cff8ccf7508dd5f2d180713b78a8c25450f8352bcc970e4d5cbe1e08bd11e7bf7acf7dac36e8d4c8f0d2d843e84cbef7f09c84a318543a83ea9f33fc1c78690cbe8c798dda96b8e3e6e12935627371018586e41c7ebdf2dba4f86ac6f2bef4b12043f676f6f38db384436a7864156a69bb080984a28316e463d0ce65eeea72a153231773052875c62b90a24675a139755b80d74f758e1541c2acb8e7125fb2c1c8a2ab7cedab20c0506e329563f9d67e87e190df40ef676a729a18fde6abb98e22888c402e0e33487b08b1e009c829573956624965b3a76a4efda31656fe17f22caff492a04cd14e2d130c8cdac0a4b14921b4b6b2a629e011bfb09dbba34b1422fc7367ea5688fd8bfaba8aeaa3a8f080c74567db12849078ddd1e0669f9557c37e3cc52dc4650037f3f68ae98c5b06bde880da53a23e4b1b1404b9ce38fa924b3d0ccb450d219943e6e3ff79d9a3f59efe883dcd1856a4485e870ef5f9ee96aea78a86d28b6a88ac385f8048fd7d373916df4d9bad0533d419dd2a01d29f20151d2fe3ebe3d39fe87fd7be7ee3fe987eca501333ba503a28499babb82e650ab896af355d8470872bbaf687a0e4d3a85be6015ec8cae66c280aecb6a5f0ab219332c7dd69004b81f2012b652a77194d6bb0e14104081f62d160cea6cf2d1425e7c4f9a60c1d472800fe54d17c892be9e30046958013593e405ce370a8cce96cca381899198ddbd5bff297dba87ba7c056f9c8aa45434fd5166cb2c065ab82d015a72d93d939cc55078b6d535d41624b06a6dc7c668096297f4ce83f5fd61afa12ae63207c3840d91b078bcbd3450286ae01f674e54fb642f178537441b432cc666f0333d8339ea4dca1a2bcf2f78ed393ca01c821ba0caf1b6aca5da667b700e58c2311a2cad3f189a5aa68260958373398fd4e54a47bdb8f7f0c8415170221cdce4d63474ebd19cc09c9d2dc31ea15588b95adff1958784b9b21eebcaefddd06fcf0c151474ceffdb074ae3db1c9f463008934e508fc4b92f0724167feb6513c9955a335a04f37083d80424ed0920797add4e0a47f6f743ecf07399b180d6b9ea1e5b3199183bdf12cfa0d0105a61199947beddcb68b9ee5ca95da1b1fe27c4514dd0186bfd3858030269e03b72bb59064a1d59482c3af612c908192e78cc59817e28def8bad38e6bc5460090118ddc0842f017ead076c98fb9b8e07a51e7b09b7e0f58a1b710a26863f302d898d2ed8252221466acac1fe84492bcd73ada88f4e193f5244d50b2ed80c79c98caaf326bec28f915bb0d2c48a6a40cd158c58702c4e18889f7759a7ab6f9039f0724e3e44d8d817b6c991b2eceb98c61f5c8e375ccbe0343a35a39cdd78022ccab3bb0c39687c8f73f158be16b44d027124cb913ce4d5883e10851d293f5b6980192f3e6279f81dd98d3430a00a33b043b56935c24ec87e96e6009f8d8f0fad9e9d6a88b850060aff420cdda8624045b261004f603abd044bd90e48a159bc82a465c7eb6182aca0437927be4fca1c09697a966397f5e8ff8bed925efb65e872b9b0c11ed3cc9af6fcc8bfcc5fa21dd1427620683e46b15733da43db5f7debeb0ece1206230eaf9ecea94a67cb1bfdc4e14a3d1cde4d6f55b67be83581b9ed26211f2996384747aa28b4af16ab332dc7a55b3d722a41c87a4ab0d262ebeeacd514101deffc61c6c491dd8567d33a1b98bcb7aa54eba561785025b27030e8565a5228eab83e41815befae29eabe26c92ca6832801584563956b88361392d370d00a709e68d332895faca21d234318080c9639ea37fe7d7881871ae2c7e8393c35cf4c4c4fb81a584aec47109046cdfd533021205aec09d4d3088032a8228f38abd3685268a34a9e74555b8e092fae8fe448bb18853483d0f8d220a6846792b0341ec38e1b72933fe14c34d8cd0ab46248baa4a00fe8bd04656c3b0ea90ed16c489c01e785f44a95a697097a9ac09027a5242fa72c6e99f0423e28f613e39b51987a7763eb631304cd08dd72e7b9bd692b2151483b2f7e4a04d4766cd476b7f6413c59a26199a24304f7e68645b3f6fefde99a84e8771cf4e66fc49c47b25432619e073bedccd987928c385487ad31c95e4be3bb347000ace94c41fef745f5b0c8025547bb894b10b9465f594ccff8d5d66952df3d4105379b92f62c6ac0661b94842ac0cd6fcaa06818611cc5c3cf1667808beb304033b0c18609807d54dcf88664cf687c27d95fa47efbc58b9ce31eba46503412e2a6ec8f6a9ee8f837db43c9baa4cb1980ff9f15e65f13612cdb8b29ba97f6f0defd538807096e0fdcfba4ec207a6701f70de2c8938f4b8bef5cb855c68e187d6b14aeeae43817e2dbc7b8407567fac4903d26759fa5074b833369902f7aa45b8a40ae6e03b5c2fffd6c92db7e7c94e0c7fa17442ea443208e9a615ed6f97df0b3a1ff782388b7390457512429c3d915b5cf3885a036f05306e7f5befbfbcc62d212e611f4188bd2ea181fd07f8b30d47c5a946208ee68c14ccba79eff6f837003586c616e702bb0b3921169e130240fe5c9f7a5c89ce5dc21efb34f622bbc44c73dd2e93a9219e1e5c49b66757a63229ceb351a7961bc0c6f82d4583ea40593931049380b275eca7d0ef69c67172ec0d038e0329f09960b8b0f1bf8a09f61f737ae97ff70fc5ef897662c51c1aeeacb5babd7237c5d24745c2f9126036ec7abeecefed2c2d89ca40238bb4446d1262572512354b233274d2621945340917de39c953f46850281a0c1d4cd557977554a74086194aa4e39a791918faa82c41253597d56a84b96cef1314603e9f06b5f3b8c711b86a9d7e81971faf1cd29b876993902af9f71a47e15b211d62ae6523277a14aa809c33fe6b6dcd2cd980f549d84f94ae24d193d717c37e05096c1f546616dbfd81f107d2746042e6c2252fa41a46940b1a1460a0aa162ba0db369f320d5f9b9fbed0b188cc348f8fab275fd925ee75bbbee9491989ee3db18506e8b3f878ebc511af3a1c9573a409732cae5b705a1d4aa2be232d0349462bc062704a38b2447d02ade4551d56e9a8ed9d3da65caea189a1467ac2d29901e2247a863a9d0252f9236ca40124edb640e6c9887801296ca881f0954ee599e7cfe1b7c11beb87b8270e35471cc95a57741388e6e175f2238681284c2fa931b869de94c61903ba87bf6b226147bf60184ef04c9768d9099e52d50826a710c2f463838c328c5272fc299125e31adb4c72f01245c52d0ec75b6b40bd94c4aeaf5d8f800d97e8ef46b6cd6175883bfd447a7729e62c3271fe9f5c38168c4c580bd7b04c204fce5ffa205ce2e8e71193d550418f7b99312883e0c9c08701f0708b29de8e98e5db3e37f97830eeccd9c3309e87c51d7abd5d1713d7ba4f8a6a1d3269a221814d76456c30e859f116d9ec429433afb2c7c127b695b28ede496bb61b49d3bc3ce148d071fec5dddf3ec94ff2861135a428b34a8fcdb81e74613f7bd01cedd8be7799f40f86e84186a330ccc791e312cf12c465ae6553c9d0581100ca0c76e1efd749688b3bcf963f9395293f8f86f5566b579999d8734b4d5018ed39977e8f4208cd99062e415f458de618d5545f89df8d18a67d737d66954218dff400f2d88a100f48bfea84a6bff4bf417a9f7e0f468fd7a18f0881a02b0e99290e97ca4f90385920c30310602e3310930c80d0f97fccfc2b08e212e0cb511b01e1b357c51cb9760d440b742bb9f55f8e3b87418e5c9dee2a097706b02a16424ac7090aa258d16d37d5ad585a1a4a12f79679bf1b5d978163472f5ef25f6d3aed34aacb88b3005381ce0b836a718ff66cd1aa509fda2bc2a2fea8d97bd76f0b98832cdae323579ef4a2e1ed0edf8500210c08d882f575e179516b3845fa141ec3cda214ea34ece80fe728c4623b37048f1eb9d1c26defc7f08e8af787bf21fc2ff65ef74393d7bc6392996d713e09d303104f9448c900493c8b6bbfd1586379152c487e644da1d9951f8906e7632a3c8343c2c73878c8d775f51ccee713857579d3a73519cce5c86d335ce88773c0e8a62f8e6ca465c8c83ab5addfd77755a0d31beddb8c0fd9fb526323707586bcb5664462c3abda51e2ed80f699849c592df3280a7ac7e9f8e7e7421e52e66c8ae1fa239fbdde97cb34cdf0fffc94f3e86a57f58f136e54a944984f43e90a9adae57811548a68dd7c1a8406cfbe29920224449967f4d204369b1d9989d9a4a13da804abb64aa6754a9677a2efe3110623f4f458ce375232deca462456739ec1bb870d84f59cd65a113f8388fdc489b5fe2b37da1f1ab407e6a6e29a9e1a13bbfc77d8df01c406fc860cddbcb6167d72ec95cd45aca17312a10b784b5a608b9e7e0b1d7c99f4e05ff19e64a50bea7f6b8eeaa15e479a62e54a882da62752c2a849bbe72b92f30fe5bc88635e42b36d205826c631b0da923c1c3b75d161a3d33c896a2b58360460c377e48aad3e05f6a07f6182c9dbca2bc17efcddbbb23fc7acad8011f494aaf24c2435568d9197934382668f38c446e4ebc003b7cadc43a3051949d82a4be084fcdbebd40af0e2318a8c2db079a369b0eb7940ffa8148557abc7177680fa9c686cf1140a94a83156f443cb0f1fccc2da42f3ab966a661d03c6614ff85829794989f80979767d9fff27296a0dda395a8abe84dc5d7fd9ed873656e757afa3374e4604296f0e0f85c4bb3d65564713b4028e96092375826cd4a61ab6205982ff798bb8ce193f601033ab254e4ef26401baff71e966baf4123b36e19bc4bffce980f44ce5e4410cdbef81b694911b7a62b799868d29b1d0975dc18a839bf54","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
