<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9770e420497794d781078a5253c652d6b5bf1714f6662c829d300d3f408476d71fc3a4b9e7c222b1b3438d113d8b72fe141d99b79fbef0bb2c46c41950f2d795fc9e9e87d162a07ad6f09c0d548b435bce6d24c72c462c89c01cf523df5f7ad9b1a4711af8fd1505f375601e9a21a15d0858a1d42528a31615b7f5ccb0d4bcae8d0a8d8561d5a44d0ba18ca5fb69ff0ff99e813c899fb7bfdadeb1e688f0f390bca98a1013c776160b479b067bb1afa33dbb0d52ac0b768157155500b2a09a0fd371d75c5a0627ae2aeda5442b49aa50290f20ba10c52187b50ab0efd116e1b35005ad04a5df12a9b5c3e2baea7286941c5f9c981ee1ca48761468c636942b4f39c6906132a74450488dec9296723d9f2e03fd59d6b5d6f3c7f1823e08ad5f64ae1935d7275fadbb5c6560c5b4795378f2ce58d1955a13e69bdd94e2c978628b0cc5d516980c3402ef88e4791247d604c6b71cf55e5cd47156340a072fc07a6485ee0d7047bdf46eb8e38c60d95b8fe6d9c14509b045ac899543b27958a71828554dfe0b48db2f310e9535e7af3900d007d2279d9584b9ce1101ba68a0e4dcb441fbd3be576a39dd012cf7f4917d9af084d77e350a5a7b6df787030b8982cf126f7c9bfd811467fc90b298ded628d57e48bfff799ec1b9b3b0a853b867f345edb44524c9e289974228abb4f3d4b30c68a6ec77a13a235150cee7403a61369918d7c8b1bf2148e89b8aa9166eba9c673ba88188d6681317b0198e07e78f33fd535d90a0743d2646eb81f879f0a901df3bf436a7d71d9e49bf3cd9707622c0e2064ef75413a93631effe32cfe4f7c086a79f67658ad0e553b52fde51225115c51ff3e73e158c2747b5f8420649bcd2832a991527565f38111af34e306918412e733a91f58525817e0add833c8c44cc2df896b32f950243effc32be2442afb6bc80a28199ad8f98c516b38b7c8d1297ee7c5a64e09b9c2d586e91c68951c774ce7510ec28e1eb53651d83fd084907dae4f22ca50b1d100071b1f0d07a125411ff65dd9ee5fb20b9df7213c0d259698a516c985bcf3f6b6245ce1ba9c79f5b39ba52b19229963bacc5e982b8a4f4e222b5ffe83609662de9180f7d9bbd0929446b2c27b9af671c3e1bccec2412ba42c148d2dcf879bd485ac2632d2c2d0b9fec3198dfa04a5fa5803d4f0189fd1392803c2b447642cdb6e9998a7176d0eb8d73e446de21861e4930fc33c85b9b9e394c976c3eed48a9fc2c8f9df069dd247564a62e01d41d0d355fdefc540154f4284c42594f2111008f21c675008b59b5863dece0d866b8b33c8d4b74e2185233723fa5aa222ba2981d317e028734f33b31436a8ae128fbb3b95f975115ffa57951ab9fc604ce52147f78b2758975d3d57ddd8154cf77ad0a5299b0d69737950333b1708c9fe365cf5625d237cbfbbd8b116e2c48a60e4e11a81138a3f397c3fa5893940a88c2f7b8ca1b0f04d33917e695f073cfcbc520e81a8ec57344c958c82da6ea973af344ace794e5e267ba359f70e231d333bc027bb82d018443b393b9385ded08c025bb5302b7cc2ad6c7b704433f34046bda428eb09e84fa0841cc400596c7b08e55d2f655f66f33bf757f5a5967895f802326e8b47c249233003cd7a3e6442d0e8961086718d98edb4fa220d7f02c1f16b392ad644bb9936d9383d10486ad3f8697567a4f53bc3500403fc47ea43f6883438d9436e77d90c86698af1fab73f71f3d24c3a404fec07d456e1198b444114761b5e460945b5e171c25cf55b14dac2f33e6d40aa435ccff97613b7ff22cb0b5e7de016d4cf79ea13b5fd8d034c383b5a38389d915d50722c0d91bf596603cc6f70d0c24dd9fb583544397745363680f3f8b0c930afb07b952c6d826fe0c17afac3a3b3f847a22290708d17c784d0a27a23de87d9a56bb1800c1a5d1761e8c9e1ffcaeec389397ec7fc7cfa553792a4d866de9ce79835673ee1e2f7f4316965aa8dda57e589ddc88b40d7435d5ddd7217013e339996bcfeb50f23648594b335c45594303c244c86f808b14d659221b3ced79c23af211e23586d4cd1ca8ca28b34cf4b3070cda71cfa4f631c679ae6670644b61d6f6f8219a1547e8d6b8acd3d360dec08a3fc42133084edc60391272efe825f5ef81d107b9ffd80ee2d3118e629345700f34bdd315bf147d1e74db02e66989e35c54d140df0b7ef008757ead8069970fb4fd7b7b0e80c882c649f5033e4b200d484974193373b2061ad4a7e359f6a59cc424bcc5957201c56ceb5a1b43236ba4a1752828c9f89b14af59b51d9cf00b6488beb1624264bd84e6c9b0db5398ae0319a5dce3fe37e11d3f35f717d929f9401be7b71d0b5fd7453b540454f384aaa8fad469b49dfda233f3e6553d0b3f8a5aa9b621d14385b7aaf85269df78a5f287189e5a7001ae87e782332e79dee168953e4b2b5081b1f80ecee7f9aee562cadaeee536aa2d753f2058324484ff4b27cca5196bf2d8c464bb34de6c9f3a6a32e060082b21cbb7d3f9b93a25d833275af322b5d3dc85f00cc091cd3e3dddb765dde4cc8b70df337d483469d198d46018367d79e77f909f8b6883222973c98ad4e555e3a4e8801f1e51cfcd77abd29d4ac93a89591234d08810c804b2a33f3dc9ce257fe9d0110ce7dd41a2b753cc717912ad5c221004259a5699043cbe9632d45d6ff77ca637fc5a924a79ac6104ceeee3ffee3baac0bea33d49d40c4df1714db60ebb85107b5c778cb93ecd9a36ca5916b6e49b5e67cb65b2550fe28a86295a703ee1d56cc300d0ea30f376422a17b33d82528c625221d6f572931f5807ea4818ff3e92307929ca41c58b9d805545bd84bbc4bb3b0a1f410df771c03cc47f22081b53706b6183e57e5b36137512f811a90608f2f7411a028cda5540d3c223106753ef8503a0a0031b7bbe7ee575670cb3fdf56a226a8b7d047bea8fb8f50838a1bd3a97d36a7fb9de03f459768279a3ebf72ad1c83991d341ea0007a1c8770658f6687f167c6652c0f3c03f19a3adb52f3b857afb8fef5fb471c7fe99b1b9ac6dc2851b47953f1e921bd2514d906a8fcf297792948060306e4a7661d08497e9157b232f41bd9fa4fa6459922ec23959c3707247eb4a7ff2c5e83038933ed44065a37a484786ce522299d325aa394fdc92a15cdc93ec9fe97a4c1fb95df7a0b5f9f976bddf6966cd25fc18ab0a3ddd68ded2da27303e80873f0d04e419acebe87a1abd980e0321c2fb00d0612888e65bacd86e1cc686470408b6f9a8a2f9043cd73ec5d57d6d5c0561aabeffbd8ee5757578558deaf3d73ba7e390f4bb3ca1c31520dd83596bb4c891a4323b3df5f5881e4befbc8d39927b6889696d432aa3aaed2a92c4d32dc1002164e41eeaded0135c7878ce6e122934766d69292b2a89bcfbe943caa352d8c91b764e76bbbbba6711cdf092197841489a6b3e22018d735a4f8227b01efd8d7f009cd0bf1e12187406b50b06e881cdcd529345fd0110e033890599ff9f332ef736a44c1daf6d201a4a5860c0bcd24f242134dc3525de3181f8f8f3feeb1199d40a77142074efd439cc19526aaba01f60d760d40b329287ffda11702caa29d718895a448481d3741f1e6c7c614070ecb6e42af56da5a2c782398e0f4e0de372911adc45ae4d96a802ff069c310bf3a2a17ef7588f7ff857ffe366c6a67e110902366270c2d7d8afa5f9841df65d91e48f087c5bb61303f9400f409966f4a87cc824146043d76bc8cb05cf2014b3d64fcce9229a64e5c0f132dbc5a0274c5648c22c01f80a06548906759cb4ba201ded13c080fedf930cac684a5eaa6bf9f5db964932c2c2d7f77c7e5695e0b69df645c343907cadab18589dece3bb6276d71d997c4aa81a15f944c44eee034835508d2153bb4c9de30a0e5db363a55c4a05af90bbd3731775219833ecf9c28aedd40a15a9d6631bdd8e645e85d809f3701bf60c0c3c005d5f5f3c0f4d427e0c6acdbee11a5cfc8f9a9546983d3c9b801123b4838e6984e758296f0162e4b0b22bd0c3cd426d537fcbf9c826bb761fa67122373126ac7ef0a8fcc35032d8aa40fc5e25619d860bf0a354a4e7e6994eb9790a723131c8b08acc11e364e60f0eef078e9c32bcdf17979080bacc3a8d85ca087348e20276694bb065f59a14dbef7dbf60f426f64ea377dd40caee1432c2ba1d1675e52122bd3ca2f94f9cbba3ce9707a4a0366592224122acbf7a7aa340deb3fb01316e3d9d3ffd281823eba4499fae4b0fcbf6c7ec3856dff136781af5e66e0e9b8420fdb8b4d0caa00f4c4c62ec4761f111b0ba8bd12ccb09a72f2ef8a88bbb4dd80c71c8f623f44ba43f00b131cf24c73de15e29b0f5aec5de81711351684f28481bb756cb38df19995c7925944f927e7f63324f8fd8bcc36419bd72aee7a9413956b38a03eb5acdf31ef87129c1faa86c55ad78a5ac5c6ff2643b4c4d4745d709bb2ec2b0532cf9d49f6509e1e0098d9fe772ce95e6f8c733b91233524e855c87b6bda817e2a8c2b93d58fba940208cad30770e5463ff681c3e2c730c3d80ee799f7c8ef76a903dbe08688e9e0bb7db8ad151744a6b6ff4d44fbfac2538f3ff1b6338e99453a05839fce9952ac9399db0d0b1cd2730f04f6bbadf33be02f12acfbe3caebcfd38dd6ff24c24f21978bfa27c8aaa88a9640280729687349d5cd851af934fefee10f81b9af193e454c1aa2ed1d07574689d25fa528f763409e22b2ba498508215e8cdd839745168c1e7da55463945dfe4eb13d2a81b9e91c37fe9a258f60ac27d0c3296dd5235ef00611943047cf90a71ae93b928aefeccb970aed07bdb5bcaef3ab6d698da9c3c26bcf906cb6a95e21d07c42b31c216eb8803942c948c0c65db355325fa6ed35bdddb0aa4477ea2ed76c71c4401a33dc7d8176ff3372b7c348910d7356cad0eb356214e1bf26fc0300343675810ea996589535f91d55624403da8e42016c713523f2a05a69fee06e657ff83388fabce724d3a43bbe588a2ef33bc966db3b9c1eb4ffea08172c624575a2ff9c1bc562c8d59d1cbba0c408e30b703b8d606bdf78cf67193425855f673e364e9db7fdb481d6767104bb8268454c85a99cdd4a82af01642cc7608ebc57e99dcbee995afaad1476e5c4c338b5f0e760a1f7a248b370d2715b390434707b3e9388510905c821194342bf2e4c04de51e643a6a3902b7ec6324b5b0758b29f2af7c2d3860f944b8c36c914c10a57c0f76a26dc0c960ac5b6fff0403ab97a44420ba9ec53dde6eb55bead2ac3cf4041d87178aae45a46e24022feff5d5382cbfcae3b4586c6330d1b1b8b82d6965cab69870f57d24d2c213841d0b78d7933d46d0a8a2c42d9a7d6a1e7a906fc0166f144e00398c86fdf2f2e1b8cdf67f6d985a570367792fdf22808d10755a0b04276d422b0bf0082744c0914cc638903365d76078bc5d4196bf4e75e6de409239ad1f741f5d9676665fa91ae2d05b57f7d8ebc784139253a3b02924c001c3eff6fb84e2decdbb4909407d31b8c58d37a74cae6f9cda6ae24eaa036b18cfacf4fd7a5697435fdf5b26a694415ad0b22460b3338bf6e44287ca4faecb3701e2323daece6bc3c3719bd6a10b46df03a399b5adba797de49275854afbe7725e4d15ac45cec336e55f735cffffe8dae0e4dfa667a2ba829a4521fabd9e9bd58a557fc5d03beb32256c09a56159fe1a0174a5726c2c2f274fc031ae4d98fbaae2a6bd1b959e4e64ee90d2bd9d924a51de0e7ee7826759b64c370bf9c73ed59e0a5657b192b11fa9536f3b383a2d26aced55f085c6035a816627508fdbd15c845cb1c9074acb3b6731dd7d8d8ecdfaf6b6cc989b6d23654bcf44bcfe46bff86703e8cc037f17d46c427e6562bbe0c69ca2ba26d1d100223dc6454b529ee2a33d9366766dfe588fe8900fc1bbc5fa1f54b3810a0ea12dfad5eed6441dcc02f9adf52e7773ba77777d3a5e1d4466e9330b56f096667ebb8697864a6a2754d09bd4e7ecf99a69d73fef8e4388b24c3b5c27d64654ad5a0a3a2d98fca9e6bd56d17d36855177f9b900c65576861f4d574bb1432e59d1d6463e1ca0b1e96b8c6eaede3b02b21db0d620f9bdf76c15821bb76b2b1edaf6ab7545dd3336ef9150555680d926be50b044810533ee499e4a32b2d427c7098fb6f821a44f3b521984f42b1cfd6eddf48fa75d877c20d4eee3c7ab7959b57611e748571e62fa0ae5af8e7b1ce47328ceabdbbf19c394ae768490d143dec1f9c3168bf2a8d7be3d503c4e584f2e5b58ed19ece571b897ef6d526d267b6f11ba332d4b9647fbe923850029da7894f1df6175796acb133e6076c253278684dbd0e23129fc2c9b129edd165ccc4e9478c7c82870c801795342dbbb5f38840c599b5d04d5d3430d517ceebb14d8b9c550bd7b21947558c76a420f6fb2e6f9c9669f90333d365d6af0ba39579bbcb75488561176184dceb4c9f751dd9e43b2d72f6fc63a82e9c99675defe594b77e9c4ca8fdb0095fc3fdf36592ddd11f736ce19b2054f698536891ba851c57a276e54626c7302ee3ff36771edc578123218cc3c19e1bfaa40a5ed1993711c429bb7cac25fefa84ffd67330a73eb0a706c66c2345b5a4c17c47de6d10a43c3cd16b94e6858a2546ed2d5dc04565443d7a08c787a2d893440b45d8fda94aa5e9416812b17ff10d80cf245564e10477f869ddd86bb43c2b9b0ca421a34207ccbfa1cbb39990c00f5dd15fd9c15b5062bc2038898244a468675c8c850b5753f79c97592aacbfa233654190d0d2f66e7bdc5b5a14d723342184ba98170e9c3197bc485d8b31daeec84d0d6639046e414da096c8d3969d71f5d39923b956096a64afc5108ac39c6753bfe039b7b4d3deb119ce3a0a75fba23900313d59081abdb80cf44467dc4dff9e78d9029dbf1bb866520210ea0f269c724591ea3ed85c31edf58d6c66a043230ba8a344048095a98240a354b7ef51225f91d7ce6dfb3212a2b882334eaaa7f37f15649b59e0c1e6b89a13359706c74287fbb7589e08b874ed242255e19f39eb095cb56cf2c40239f47cef1a322e369128a928403e6f3d27a6a4aacd93fa1d269849ce0cccad878d83f35f97a515f12e637971060293109e225f3ac6e828890c55fbac690e10a82dad909803604f430700852cb5fbcac25419158e09962956aedcd3b72d235db602e0d150863486a42de105ff90e7423edfc94344924a9d652d779270fbb16ec296f14a025601c72a082aea83fcb5017a0e04953598938e40d689f941070e88544c5c520f20514c17efaf9a3ba69b625ab0dcf7f3a36ceb8196368f918d5bab405cf58e9995b2641bbd636a0d2d6083e8cdbc5de49c038a6789ec691712b1545a6ca384b5772e406c7fd9c570e1497fbb847f474de377e667ca95f7c218beb1d0e92ffed0475086689110a7de9edfa411379ad4ced1cbe6a872c0641497fa54571b9a9de6a1c92611fd0932b54e6f855d46ef0d7f66fef2ea879be3583538a10b71346b0ac48e23bded60c5a2588f0afae296a4c4bdf424765b1dcd6acf04f49a5c7b9444c32284636e77994094d1cc0667514519e264c5d954c41370d833ad996dff31d6ad6119f264906c588e07c119d1385bdbc17c7563553549159939f8d11f9edaebf5e7b21fddfeca14d4135da322123898e2fa9c738fa0cfe9c8f4404721f01d770cf30713546f8b8ae6723d5e922abf419d6ffc7719b8712959a0a1cab27db0438235d5d7a68fb99099038818bff6a5c1acf7611c01afbf332b9fdcb986ffc24780b66ae1dac63f8a18e303266e001339d262226f66ad4d4de813cb84278afe4ae792228cacf0a5520f32c30ef42db87cde7ea578757b9262e2b991d588d24005d977afc69f5eb12f23ecdcda9d360fe9d828157b37ee21ade7afaf4cbfff7c9681806defa0353446d6e51aa09669a3ff4aa9546c0e81eb1dbb1ba78d8a0485fcd4aade622536234defa6765f9d3d564db6daa5c623b0aae0ca632ec64e6fed6faa049cc943136187d72b9f1880bc90146cf7fb3ea273224dd16bfd65980b78a85ae13327541e887056d776ef11587ec316ba5047e8a12927d9d914bb9e65b1f602332ebe5d9fe11046ae4e9d0a4ac4956a1461de88eb389611c4030346d35ef4d59d40d0ad70bcfb9fa10da25517b3592c4833fbccf90a52af047c5d70ce42666eb1d62e54e5f205c11878f37d20b0f5e47bdb2d136bc8927870742e743031838f28c944796a0d061df491de37a3e663d91ded17e3c8e61247308c61a5e46615545196b9e476fd1cab65832000ee51667cf9c5b314f0a6c2e6e11a6ce2e248fe0fe69d04dce4d24c3db84b6f92f8bb257be128cfebb9e2586c21b4ae25e674777d751f62bfc0a7388c9865e1716adf7f35108d306e08a130346db2ca40b1566f374a13abdc6ac6794f50fb220cc7bc799d7b57a68705a5f4f491aac4a1c4c532ecb2e503e839d54b0db936e8dbcc639f8322df795556c60601ca9b485a89cbe7d07883191a32bd1ffc177e699af656dce11db0533639f5a651a0d8ea4659d67714a1f361040515813f84066ac319274e393b802c7610eee7c4f1c8ff9e3c905d6b8b79f191fa10f7091a7c5b56aae47208e9d146f7428c5309efa64f70f59978bad5e3d88551be84a9aadfcc3a96a4704661a88e7156a76680727fcdca6e862cfa45eb06c4ee0d963d018da1dcdf2252418df4ecf3f3c5e19161ee2d1d2ba658b20f92027d11b8cc7479712e52aff2f46d91936c81c7b99c13cad770122c77db72ede062a08f04ef6950c01edd063338b93c91679f000256670a991ea3a8d4b19bcf0d3fbb6eec37af745ec1f73159b7626514de7328ed981b492d296e9a69eb8f79b20ceaf1fb151e3fba0287261fc8256b680bb3dfc3cfdf685a7af89696ec7d69ecccdbc35b82a821dbd6ec604d4375fb8491379ced368cbd1d7a75b7789c1876ee7c6c9be52df1a6cd60e38f1dc74df0eb369d2b54d8c2da5717a88b1904bd19ba88c85d676ea16109d1ca6cb709cd9f879ef5c6481345089e1b373a230a6cbf4641e14d34ece1d42aa024f7a532d36016dfe4657edd908577a54bfab5d2597c56b294bcdb3c11b63eb808b2999f58eb0f67499cd082964ebdbfe3ae995f399373beeaa422ad711fb7f91fd8b2eb21dfb02847c999d5de1f76e790db9217fd2c643faed3b21dfb895dcf56929646a2b6d7b832b95207113619b1e6fcd2da5621cd7bd71860cadd37d4a74ead7afcd67260c59773f461beffccfcc3d31ab9baac84a78f7a140305c5eda21d56b171a39a052397da5efde7e3eb366692556f15729949502860a18b1586682e0714ed9a4152a7fe655c50a5feb4424b6b2e44888fce39487fc31d8b765a2ce84091d855287845451e3be06db1a20a2e6b5097a6a8105cf8772262af6b146539824a148f5da7791b0684edd4686565e92aeb8eceeda5b7a2bbb33d147262a113dc637542eb808a49ef3983ef6f0e640a096168b0b0ce9c66828d4795aafc755daee0215436ea99aee8538a88cce54e23cfcb05c09e0edb3cd7b210d39ea1acf8227ed2595057b06b95729fb2ea698ddf3d721a4847c474fdeff6bd83bacd6baf3abaf07578b2c5ee6cd6fa992260e35336707b3b5167136f5e9e79ca5321c94068bb1fc5806baea8f15def0f336a1d3f0d2cedbb0eb6de02cf18af628ac20636ae7d5b6d78465a13837029b9010bb8b8eedff8792317446454e4c388b1409d7e5c45ac89f27d38b763cd344e76c3b1b3f495a417de6bae92c4e7d26142a3e25ffe51e532c74bdff9c7f8ef718930b7b85c0687eac0bd5e2a5aaf1db5aef48018f39be68c93a7cae7da75dd6e7264c48b1d865076b2f8c53af0bbded6bddaa655a211235b55c0ebb8af5a76b5d79088780b9dcf01083d74bdb0f9beb07a4d346416cdf8702dd860fac10d037c415938457b3040edb33999b4d30a1ff48e364e6c9a3c517fe1702943557577f4d837bd76109e465687e375c72d2aaa85f094cbe9442deec0dd0766c81043579024c2acfb4cf0aa50c455cb5785987e362647196a4d8d5f314d70d32329e661ae99ef70143aef2c31756aabbf8797dd15a77d8747289fd756b2f87d3a954d2bfd722eba967da56863b3c2015f669d6075a2bf321fc31fbaffe1ae7d59b2cdf79ca70bc18c678c9a1b0371df31bf42fb7047757d05a9b53c722ff4fa530766f310ffbe2084b86c71ea7250d02aa0ef08197568ef96001ed2fb25f5032952a40cd671dccc1e8f21c1ad5fc74bc40668af5ea5cb7ec21d1b914e70828caac7637e8e35d7cfb88849a3b7cbb5d3d2b6a916a0113a0774258e5f50c9afb5f039ebc4a7b6703765785a0f6fb0e5e1acad1762a30ccc12f46d5e398260cae28e0fc6d8b2107c0634a9388fd448fd1560c347b3f2504821dd3a5e5bbd8dd5d4481a3785e067767119325468d6ce96454fc5014e81695885f49e3eb235c1fae1be7d1e839c9f1c0b521d57c1e606cc1b537090bcb40b937c64e49b25aea39e8d196ebf8553b4d8482cdec574b530623f25ee00ae095e24ced461e85ff1b1454d9420eb3388769c50caee561f4bd793f979aff5a60f11bdd69c7fe1a0af92c1ac69467e2bfc1bb99f5e56cf3d16c97a3116624e9095b35cb2f1507868c3b771b319289af78f738807d240a6c5c8880af1dd75ff18e0f3b59fe0d87149e1b3af23ed76e0dca4feb8f3ea9d2adcee25396135f0cb621329748ecc898d37f0cb7610956d09f0bcc9d780ebb5578ba61eb38c1639a560f38d88c45e1f9a9e466eb9fc982a5ca7eab2c84488347db8d546a7263e0922432b5775c1912c8ef2bc43fd88e39a2aef257a88e9354969f9283d262136852aba4c7c238e09ebff27b70750aa864cfa57066486b2e10bb7917c641533100b1d7622b7d4d66e75f5dfbf12e9c99476f73b3a241549eabae4173e85deb123a1e6a0062a6613e7bed248f4d98a27d44a661f4f2ff6ec7e27e4278b03ff9aa9efdbce3e4d5765b39daadf2602aa03ea1901ac7443e943a75cb1d2b4acbc1076c8c3047dca77a35e6e154bde23c55b7237ca5b93439b4f47fcce4d8436c26fb3d238491a5863bf73a05ca6343573f9b3d55bdcefb95ee64d223f27e9601a06ae875de6d95461b3f1b944d23ef89672aa86d42285352aa77529742242d098b841c23617e1d3059e858c235be212a3218947322151b29b19d2df6c7c1ce157297974c5124310e274947d03cebaef7caeb9068b7640ed1364121adf752dd8d0e5160c4cba894e59a22adee8ff570c8a4fe862eb09e54ff578fc85ff89ac93d1eb5b3eaf3f04b9564ce421737526d076afc5f9e86381cfd2dd4da68dc0a6bb0aff614d7b8123e038fb8351d61a510b3c6feeb4564084917bd7c1c11cac6ed16374b4071a8197a9c6e51d4dedddfa60881caf701e6b609bce288670f005906542512f828e9d54ef71863e5488da4b9dd97dd90b7677fc264bc3d06d6f39e59d1561d38343f1e675b3d91d3a8e4e9892a7abd930de6c5719e46ca370d74b6c88a8075117e7f33ccba332c38b54574c560727680e004326f847d117af2a05b99ea79cc4c5ec40f09d5d2b8c277e7f22414b823fddb18777fd3aa320b9dc8e36f5a88f363984032daa47a1ebdc31cc7ebbc4897064bbecc32935f02dadb9c419a79aa4b7183a7a0df51f0e8f4b4de2c2322a120f74d62cfb3b41f1bb26355bbe6f1814e576b989fb777bc5afb839b5fb436fa675e34a19f6e1edb1d3e07a85d427a99bf4d0b4a4041aba8a3388318201e2f8560690888a42831f554eca7bb449ba5d1b8c416f7f3ef571895c95c10e3a9d8258f3db7dfa8ae1596bd5e7d73ad679fb31e8f1664bc159dca7eae76e59a2a8bf8d7ad2b998d64fc85d35d8bf309ab9194c3e15ae4f0973e17ce96c74fcea397af994112c88f6b3cfcede9853160def04f042f757bb583567e692f5315de019838d2829fd2f67ccde488641800f8015020abfc6cfd8075c679c8024b537a289c0452a42744bdafc25e9bfcaf31c058a9ff20f3823c6de19007b54799d2efb39c157314e26a3e27a369695331af0604c9f5aadda15daf1cea658048d70fcd53eb15568145ee69d135bdea374c29e29332625fbf60920966f2dd8f22666d0a271a7a0380f8c4e1a2baaa7de7ff0dbe6e335703659aa5ba37970efb9388c4db2b279682287f841048f5661d94ebf2001e013a552f2fbc2254d571f4f2b132a55890e238e21414639beaa760f3df08751e710e05bf92e5aa75d554c6d48ca23fe66f9a8018ecca765e6ce11bd80e863721c8d2f062ea734264c1f8b2907b443a9dfba294ba734ac23b7706b1b4c1956f68ae833592e365de6d4f7647ee448afa5aba51f2b4cb66ec9de544071ee20a49e27930c004f2a29eee622c4d493e04785dcb05b82d4dd763f36520b8cc223dc76af5175db6713f3bc4387aa1efa4e92d05db174d229cb7896a7ecb3ae08f240e9277b44ef728800b2d85ebbb324d3686b8bc481838fb8ed2138dd7f10b1e78cf9a48c21f3b17408ce23763f5bcb3b040423d618b707a62fa9dba6597047d32e8571a5a90310fa0b250e7a183c196622d8a68703496b208add40dae49b634fe59a1a12ef435236355d3201bbf62014a3f75fea8e83a03a90c1357a4d8a90bdfd24ad3fe39d77e26a2ef2518f396b86352c02cf37cdd5bc97aed7fe04ec6c8106dd9ac38102b3cdd6b9c1406248efc28f72604d3e89280d19081359ca5a2852ed71d7652512ff581c50c28a54e9db31d0df182e3a2136b3dea564f30044babf8f12280939bb381d285fce8f2af0e7ebe46423e9dd1530ebec1c34121a30decae49679b5c436821033f6fd3a7d346199efe8957f45bcae6677bfa47530604f6e2cce4c3d89338b2a5e2093d343d0972cb1e6ca3be17f00b3f2baed4315c08973c4807093642a68d31a6a80440e4fd9609c7e72537bdf8b3f4305fa395a60b5a4e3a866c90bc2320f704c5bd47dca9c5a3b3be6b661f177df22526ce6112942c46a6fe75546512db206d63a1308e3a206e42747e7da60ce3e091524a950b67ab65123bd5efd615710f2185947f8a6622a35f8d525d5f8fa5ad60555f71713ca4a57c79780fb1c1f1df001c1123eb0c5d57a282de848dae02cc33264845ebaf49237d5e53f57023dbd3a0f1186ccca0f684956b849e034b3743d39a5f74b65f71aeeb598a182c62063a26bc316bc74d2610c26895addfbfddf66b40fbe245ce1d92c9aafd2d1a11c702b79a9985a6f5764c9898722f5da90df4cd666f9b4b003dfa55d16f6666805c29f43cb480d138f426fbcc3b072314a1e0bea5e2e12c31aba9e1845f0b871cd416e7b2a701424245e440dfb53f4ea4a87b3bb700786d530d2cd21df10fb899e73ccc3620b3fe38dec4eec2f25acb212a84ea35cb72d9377b9a5a3f9508c0acb3f1f6edd6cd5db8dddc94501679119b1d54a2412f37d6d24131ae724eb4b75f03ec5d7d5b192f3ec55e1fc1ee0362c32140ffda635af6560763a54418c1dbcc8fc47a3dcab8044bdb46b84a82c050a9b2a4ef4f233a4a0d544e0cb547617772ff95d8dfc14f946c874c5b7fc4bdeca71458cef720d024da976e9040f0cf9a98e94456d27c36244b668c6f2420e4aab7fdb423096318f1ddfdb6d2360763ef40f8e67112a1eb008c6a31407503a4a473d050509b3c890e44c57f3cf1a696c0b5c4e1fbad253ae062bf722907ccb65c2b5fcd07193b8d1d38c471e3d410bc79bb8c7ac924902ad0d52cd1d5e012e16f60e42eeab1e1cc38a4235125b5cae62965025aa4917c3a51260490c67c3227ae2381709774c1939a6749857064262a409f752fd3c9bf078533cfda805de0fd72e24a4ab6de8b0e1c6fb06976418e7bcbf2e89b9a88381e19096a29afb6854b8e1f18ec83e8cc29f32dc9963fea49c7ebaa887eadca01f2d84dc0c631241991c9ebb3d55a6718670af8bdf7771ccb7693ee4379f1d63f66e6b697ea62c5a6ccb1bd7037ba89769cbf3a0ded7d79f1d4299cd5c38529c6fea0dba4efab6b9f89d2e6fd51723cb14daf929b74411e6d4e1bcaa841a924028ba9414250ea85dbd7f42574d21f27643e9b487a8c0a544b2b6857b05556079146418b58ea41df7e117ea9baeeffd617b318578b5e0c44c8d3a5adcae82f11ae6cd54fa533f71eb5683999ff1983c4d671c08d2716f14364b27cf23ba4dcefadae1c581d6df6e062d0be67ffd0aaaf77557df9a27b18247e895ca99494bc574c6dcb4ec55150dccc457a819b50dae1ad2a467c45303ac3e05667cf43d655e02a8ad35c49dc2e74556822de4b21d4c52531c38742f6c2c8c56c672382c4a7d430a6780ca3e0f48c1052f149270be7d2555cd5af675d5279cd2de3d3ea39a1d4c06f2a32686a38a12f04418a1c5dd9105d2f3dff8c6ccc00ddee6ecd7b755cf541a4af5f1970d0372e4bd7941452fab7152c3f970a682bcb35113ad381c7b49abff28fc433131a50c6bea8cbd2ede3020286689ee0ca65dc5f6098b6e9d66fa9f875f587ef83afbcbb12c26c8907f8a2ef7acb5984d9d989c1c5e03173ef0273ff0206db6c1c8e35515f261af40076e009a7015a9abac64e028dea5ffce8162b8986079f11afda5f9e894034614057e82ef04fcaada3083becd39d4caf45402fa4bb3283f2243ab158d3a002e8a3a10813d37509a8913de7734838e36b73e8286e9d927986507366c6502723dffb0c2a25bfe8456fbe146258ff83c58fb15504ab7f2ed7d4798cc56d0ba15971f63c2a50b6cebdd4f9c374009d74d04c266f5e0a374067f19546302c0af314b5417a0637c338410db9d1bd5bab5fd0decf31b8224556e746c52a287f1461afb9319f78e00a9f6077c29af71f655d82f9935b1cf3fff99f2c7dca0698eaa53cae6b8cf40ad66553d6c8246bd23d8380cdba6cfac13d3209bc6f0e1d7391fb93ad3d0eeb095a38b98d9cc00164cc1ec8f0503f6b30fc145f6c054341a154372378717b6b6dcc33636b13837d58dd92d5c14016daf4c4e438324d15d82384766795db6ef68dae2290f652c50859df608eb75fc1e814e9a8ec7842ca4e356e032dbff994","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
