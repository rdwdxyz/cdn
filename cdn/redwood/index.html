<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7743bdffaa2e25e6df7bcfc335080d16af05066f0e2d37d03d523767eee31da6f4de926e4c333cbcee26b08572a50b53e1361ce25aa852f5f55cc1cc440cdc4ab76e73cfd5fd4d7ff2013b5df3cb78f2b0fb5ea2524d2f482f562a9a897c2fe2b6a99048086d20ff3675fb460f1528f9a11c8067f0f74b8fd31e826697a29cc93b67a1470fdc1acac2222ad152a2fad09ac1ff1b944fdc2dc2414ba90817b54707c13a655ccc281561bf671fcd4d609a8378dc979de53330e2fd56c64acb0b649cc8def01fa9d6f2cbc27c110d093db872b8bd6727d624271270eb5be02374d14221b2f58c114921eb9eb860e9d50eb1e7916e40e288e282688a6794e97ce342ed1592ade00fcd8da8d64ec51dcbb8ba402e162e0e76e956027e3b3d366e6177acd62bad91f4e30e1b3ef770182371980f0b614f3e068fdfecb884e56feff4b0a21c0381f9ced6b166943ce18323bbe1f425c1d70db49870a4299a80b1e87bcad005946b4aea3ab9cc2719a76452c5bc42caec891d1fc9c8737fbb7d1188535d38d68debbcfc4e4d606b7172e767e7a8b903b1ce2b16569ad32a3e2f4b45a8592d87ed65ee4d5f18ed1e76772715440dfcc6fade7db1970eb0e49d8380201ef22921784102beca9f38b5afad101945c0108c3a620127aad3dd488965fc05682fbcc9b8670fa668b08d17ae09f1c763195f6268f15fd90598ddabac91d87669d43fccb37adc880079cf971d30e9fd7c8d2dc7641942cf8cfd50db06bacb79ceeb7436ab3c42c96c8c5a694c6991504de4a17bc39e110eeff65a76ad31f056f463419623365e63da2751a589b288e1de0f2d135c42c033416b771a605de7219b1a39e30d3722da3ca93e749154f205a1c6aea10725ccf856ce76b8779dbd4556f917b7eaeea92bd5d2b147619b63129304b56b01463351c8595da65bb6ef8c3f8ecda61b7cc7261645c4c3e62c080e35cceaba94471930c6e14e17ef2201378ae825b1785b2ad55fb0bc667f4ac03955c19b0469a4d9918882af2e67075daaabe8542f4d53619d7bf73cbe0ce93961d29f37469326d47ad2d0c267d466a96150f1909c876eae4b721af46ddedcf68e0c346893258dec242d1821d45aa0d4b0ab70789fa744bedeb8283794a04334216e0428706d0fb42f2ca15128a767b303fd3d9011b1481af0c5089eb9bb701ea73226a30b0064fbc68464765fdfaaad1ffdc21b74f880a11f7d1f2ef5010b9f09dc08a8b931ca8b833b2bd259d234a6107aba489a8370c827272048b00014e57a1f12ece4ac7b728ae16e4c6bb41649bc9890c9f059c1da6086b001e95d5279e7d42e4e3211ff535febc78261f5a50084083cae42b303c81d679da1de0c49d33680a129f04759c6cc675ac342ce0e83dc986e3e5a2558a16da7afdc1f8c5f5ea85e80f26eaf67100c82defeaff181c353a4b56e48207e1081d954e225ade3235b7b34b69cf0073128e816056ffb670973232757934b6acb31b6f59c8c3d526a44d69e53457e22cc6bdc2fc6c4f7f112a4647642465d5f48e772c3d3ea5ed36d71a92f1ab4d9daedd9edc794db1118649e65e4ded7d50923b105d19542f693fb5445526bca5708301a52cd10a8927cdc10317aa80364ea2c4a71172903c18fef6a923f863f630600916fd1e3932b87304e9f845a6891f504908ca8d36ff2124b9cbc5807a30e44a20c5614eb076d5ffd9464829c5a0d717ccf45c283edef3dea28a2a592dd9b360f5b70e957523879a384c96cbbd0e73c41c999551dd5f07985dbcf754b29764f1d8eeddf74a2088635d24505a63c9d58ac00d0529ea8a6ac137ec35005b171263e67420b6510f1af169afb3d2d3a1da4d939578e87770deb5ff145b08e99109f139cd8aecffc429d4b7596823d50372c96cc2e041e5a9f9d92af6574761fd347fca085f090a65f73bb25b8c752b79aadc0b5cf00efad2758502ec6eced80690b4f2b260dbdc775730e009909078182fad146f9a43ac5e27409b0b0cdcda76a103f920c67d43cd813993ea5aaa83ab9c26a5689c37ef0022425688ac9b73ab7b939b581231ac290a57090e2ed56fba5f67337b540f87c1455d39c975edcdff4b3f70a088a1eca5bbc36f846f8fa8b9878dd29c690bda190028eab31e9e7302af060a3d09b58d7a07b0e6f0cf086761886180d9d7e04470f5d0218e6546dbe777e148240e2ddc1b89ce501048183dc15ddba0bf34a77568147c3d79ca00d1b7b18bc4f912e549140554054afe698982f16f1edf34e25bda3a9768ee2c0bef80df7b00b05c6045d9db0464f536af93a9bc3cd63eb8ae9f807f75f0f53fc221d2fd5c01c647e95ae6285c7abf654d8c0398b38ffba26b28fea47dc70fee62cff6c50f24065b3f47b615f3e2cf859c012c3fe4307cd617849dd77d3ddf611d317c908432f50a2d75b421fffe69aa8677e109f88c255d0170107a8c0b5b50ef268af7dd1dcdaf445b6d710e6ce7cd7d47904ab5a0c5c56f32e31de8fb15be2c0c827fd57b11c6b237a9079cb26d2d176d6f44be497f937cc9d30e8514f1811684cdc40475ebd9e7cb1aca7fe37093e10d797fb326346fa46c702e2e6a750b5868ca5b8e4b35941933f0baacd87fbf79db970d9f248d2c780d56f7c7ace4588bb376ea580a98154eb0ff665d477e84da2fc2008e9bb2a702466e826601a2fff054ba0bd0f48f3db43687fbc9a1540c98a779890d020943b068f48273f274945aae943025852202f20f1a9cb76fe0f45144ae7ee9d428f05ee4c9f1d2ce4450d96784827100d8e9f878b1cd1fdb0f4eb6868f46f3b1092380d10fc887f5c24aa672f855eef38a5906bacdc5ee557f28885353b22be53830222ed6682304937381b1aff877e5beabd56972b12ab1d84efc97183aedb6371edf430dec625cc3f21081569522fb19ffacfc9724153a669b0bb44f178259be82fdc8b19b7060c33932b6619e975d401d3121dc7a1a393aab55f8cd6f3fdd8ca430664761c75753eb31efb8b8cc9f4436af9d02cfad89f1f63a2fdeb30773e344a623a5d292ee11bf10a9ab07166a19ba52469a5bb379c31bfd114b625ddd967e96479eee905591b6e92fa7bfe1bf269b1bbf5846fb2c553bdd71c91ee61c99cde8044ba5951358425bab662708621365c5b44edec441686116f68986860585c0d5b8a520f79f200079f4d4d188e875768698597c721bef94264251d54dda5bb62a33290694eabbeb2b9b2bf000d7518534717de91ef64401651b589887f5d168f889c814b9115e63109f53d5262331b200b53d2cc260c08a37a394a42e11da3d8075e547d512a5c4daaf2c0cc1c9e92034c7b536c42733f203ad803e98863d15b6a4be69a656875daf86a5ee0fd74bda63971ca31adca2e04880e9bd336273d6f7b3f3042a6e729d782200e471c5f82251383dfc1d169ceb869880847171d9c9aff88ffa12b307163824076c965a8f797dd2c81b555d2758050254e65c86c82467e867d5a81f87b58de5ae72f28dc2910109fbd1f28219768c408192d14e97f5de7bf8b15e9d548960930f3353984ec12bc691ca4955f3ee876ec9863c5fc0b8def85e97fa75a5b5129c9ff652f2cf9bde72a7aef54a2801d38db97c31ccd9a900a11c74e4a22b46bacb3e02c64751f4c672c533c58336b82b0e5ca18870ada83ecfd6b473417274adf3c2b876cfe87b4d70fd0566fa08df232883272252714f8181ab4aa11246e7eeb42bbae71978004ee4349bd0cb2fd8f6d9c133e486a36105a4057957508d33def9a76efebbbb11b8d0c2faa549630bc0ff7f1a581fa8788823a860019965924587e497998e6718cfa381b9d921b08fe7f89ee39cde51d67fa002e9a2a9d93b3891753655fbed2ff6702e17a50602c246e7856c0386225f634e178b0168d28e9301fcd64b3a385e49d8d6ea497e8d1b72bfe2a2132d30ae15dd71ab9bb8b08627e1949b136a5a0d1ee08d8d48f24e93750f967cd45422b8fe7a7acef75bd55f9762d8ea6c7d1a443645b7947863a0c76057ada65686709053a8732d3aeafdf6d57df2bed903486d6506e7b2c1def44e311a298ec88a116002b79c72673d5cc2953c42a8ed17da8e564b99e1850a2a02a3deb952edd3625a58540abe86b6cf34298a69f0fcf3cb0eca139f27fb12d8a103252a822219b5545632a3a2353cb988f6b4debc2ffa4e8386b6c664c4dc31819892d6bd1a181016813d4605f3231a46524b17b455f7b5d165efa074f88ecc315e3ede819e3fb8e7942c7095d75a93e0f1776c75d969bc9aa9a30cb2c5b582e55d237fce2c397a686778e6bc6c8ee6f70ec811507e2d3c9b4297c04121362477e56af930a634677112c1539470de37a8fd16ba9c589ea13c1da853f8b210332f56faae89cd22e8ee2233a2e740c1ea68a79eb8f9e140a6e067d5e6304ee71b65d66313b47fc64de10b478d878d18c31c9664640e02dada2e4135a391143b92808f316aea98de6418cffd8c2e4ccd4a038ebc5d4e785ea3ba64b3b09539c96e694894ed04bfb637787abc73b600fb1fe2310662cf21524cf9288cdd689e60ea0b533b3027adc86be4d321eab03e87bd8532fae54533fdb63dd3019a51df26b36abf686072d87f6574082a5b1eeb376193e246ee426934898d722e63345d06468e91e7fa458aa3bd3c3d8588325afc196e98aa5361a1fb9509e50ba8374e98ef24f67c5eefbc33613902aeb30af5e9bdb4fb43ce76afe8a0cb3fc83ce7cb63c08fdb52a78e87a02c97ab430c8fcbb0dca3b26c94507d0fd20979da0e96bfafbbc46613b16efed2bcaf7d7c8af72b784eb113bdbdc91e7ce1ba247cedb23e6af43da1ea1883412eed15713cbe65eb8476e1b0781c44f5a498bf3b2163f7ddfc3dceda540b0e7f8d2b8ed7f2e07b72eff5cf1c92433220466faabc1ec752ad98aac55932301c940779a10383aba94cd02a53aee3b897ee1e836a99c7d6afe26d815044697a63aba8ef312946a087a2d4f945aed1ca656192c192c60326fe69015603db7cb37b00cb017aaf00bcc7e1545f94e449f8d7a6a518c7296f7615d88ce6c2e083da088bf4601111ef1bf1d365f31e7aae8a0fd10084e213a63d1e4fe7024a9365a37d15f5877a7dd23358444544877181091669d83af90a4ed6e57a4c559b3664edb7c724bb35f8c88680755ca1bf8ff1ccab767b60f49672d2fc99df70d5e00cfb8eadfd40162f977bc4b3396b401a3cfed2840ca14211cbfeb6b6d93906400b913216e34ba97aa9a7b9201218baf155f468d2b15b90ac43d9150ab851fdb8071b2c5aeefd23a0228966e8579e622acdc3793901bc3c3b12d7454c0f9ceb9dbfd3c63a00b858e7e796fd7009bcbfcf2569e960898baac4b03d17866ef45b4834973e66eb138fb1d5cff436b1abc32b258ec6236c86b4cedfcebf9833ae1741dc5be111ceef14dcdaa39e3c03da0654cf95be946a8c0aa33899f31f16b4de7c89561a2b23454dde3ebddf011674b224f3ab1d8a5a735333df96fdb7dd40c2502194a8a6a8c9c24ae88000ec37f1a247cb0d77c67510b0cde7d2e6c3c6c04990373464287f0b8148f4fd831861126afd375000a974d05f777c871a4aad3bccc14a8d2f0f27f3d003a0aa2799cddcfddc406ac47adc5ca78d8af46d6cc6f7d8fc42ce1319247dbd6a5e812b8665b78318126c505db1a70860ee7e2cd1921ee46ac1023736d68abce52e25eb3d0b6b040e64477e0475040e549adc8cce6ae177cd6eab0aae71334a252f2d706d0e51a06bdaf080ddcf6e683a95dfc576f068f1d7b2545f7123dd77fb38db6d77da7fa55a0a0058f63f486147d1a866242bd8243fcafede2d8e904b6babe47677a3d4379ba83f7ce711f05e932b9afebf1534d0313ed6d0475825ba8864a49578fd2e17036180b5673c4c2f72f7c5b2c540a265161d38cd559104c314c1e8ac2ea5d5d3159172729d8156af879594a318c578fa76d27cfc788897c692647df3825fd77c3de992ae1d6250935c46032d3a8d9a4c4bccb252e3386d8ecf04c3bc3d4228c749ea84a1f1cd50d7c554b290ab200b7aaf2bbd921c1e5ec871975b13ef2aea1837ad3fb1563bef11af6807bd0ef14d1c07c2ab29aefa33c7e75976d23220fe6be3b668bd1cc82fa5c01e473779bb880519ddbfe53c2486c5c5625893221bbc471524aef9e807e804883d9bc24fac6b8df95ed8457cda8bc252a29100405010c10d5cbb1b40d3f485ba2342b06725fc165252db9633e573fd6287d764108f04dc4d7cbbfdff88f33168b9da0c18235cb9b90f6f3f320390051521229988e788261dceffe46fd46a0c7b74ef502a018eba120fbfdcffb84fe0207a48ec8b7db579dcb6ebdd804a3abfda328b6b44047778824bde966ea495b04668dbdf72ad01c5053c5e41336542897e1b83b5ebe6f409e439027cac476ec7e6af94d2f9651e0febf90a8c200b60f2475fa9fc49160d616a6acfe03d74c509b0b04995f8a9ad3aae9ec85978c63a93dbf9ff356bde3e386ed342cb1e0f055f6a2228a5173c7789d88caa95a4e0e54ae44e910780db5d8d7d22807a6f7b7c27e2360cf04a82ddbc251edacc3c3a893f1ac68f26c2eac31f6c595ff200fb0645270b34a2c1a400d75f8206c861168fcec99f2d30d16687ba51c3b70c4ed0a3d43e0d0ef53a700e48a956e53d7b686450021e30db7ecaffc97390afbc17f4e453121adeb2019b08a8a49489468df8e5112aa92a66f55ac10fd198ce299825376e2b1ac503ddb1c4187f809d5826bffa24c707af4ca9a0f27184d9d33b21bfe37db1538acca7b132efd31156d20d6d2e3ed4723086b156c1fb93dd3c3036f700abae373fdd8fa30da8f9e6be5f82c1b9377343a313c32046aba7ace732daf0d8f9592928fbecfede32e821d9855dc819eceb98312aa65915bb6a89f0c2752103f7146c3222f6936eb62e0ad3681d2e0b9e50ba8445951427c1ddf6a2eefa38ef139f1a9bc92932741727d3fbd7687ad431a7f04715b5dc292c394e197484d9dcd28e98bf7c65d6e9f177616054a34bf0f76a645e301573297852fdc5134edd7c60477c6dabb88d3d7be2fe614bd92cb7603d02839a942ef327dd30db3f047243210e93d1045dc3c50d6fa93345d6623494e0100fb7baff2f5bca1d5df99e20e06342275df5031ce51b49cdcfa2981d75753aaa094c12fa6af9fcb5a852789339a22a6802c240ed8fd5164d5d5d99b1abf25776d6eb8935aef692226e5977d09c7e5c45d2567c8d864009ddfd915d357a3a57b374b28967d22dc842682e56747e262b3a60c20556bfa5347bc1a5198f0e2415f68641b14fc6c2675d3ffeb84f3aa7544e7c846faa568ac2d69d9a964b28944a1401a5081601879e9a377fe2f7fe103e012829c15bc61a1a82a3dc1134207dc287788d875b33757ad9f8307f810fb688485653f2823313a74e03b752e50c399ffdb6075affff189e346637cf5bcb3cc4334067ff5cbd464868d8760b155d762844c61aa249b95d8bfb9e33d729768bc1ce655453c8169fb09c1248b53484a0dbde066ed76b39c1bf8f3b526e0861c282403c9a4a819a23452321df06de76300d1eaee71e3799c2ec2aca811dd13ad9612706814fa5ebf60c875feb5f71a6c2b7a6f88f2e14b85d3526fc60dc445dc00d6626cda96977fa9126536202bc033e70df05d069986632899f1c97ec0437f5a308f970da35614e3f128a20965b16178b50a5691ef3a6d5c984d6bd8b6fdfe6050ec9c9721138bbafc598971910f0ebc86226a1ba8f86f7670287d0eeb6d1815b5c502f38a69e51ae9be3f44a80568a0ef8abf73221f7c611564d21140a285f3396fd97fc2eb5e9c6ffd1e631b38eaacbfd624f79d6c4779074854708687ff1482fc685260c8993d5e135a739c59885b080f1a3df4e559f80f7e2cb2f0ba28e8a0f96aefceb389b8c75a59bc02fe05cfbe061b2c713997446dd21a90067e6b369a114fda8931d8e29229baf9beb8761189ab390eea31afa776934902f4e1ee7d8c901cd2d5722fadd0c1e4248fa810a98a963b73cba4d10342acd17486f8dd2d4252c0c3c1c8ab275b7e3e96431dbc777f81bba8208ffdd87ec62d2c39084ba98ab528e5489a4ee5b7f4df6dbaac999d1d2cd0c0c3500b3a7cd03b94403fdc624f2aaf716c45b5712931bbb34746670c8c46ad1fa0011de9f4a83d4b4a815c970c0c8e115d6cb3f02f0432e536f12235c8c4092ec655ca84e2316f3d0fb9dd4318ad1b30ec3132c858a3d2947523c56fdaa5a6a9122607ddc626064742611aa8525df1d2b421c63da9bae7d1f8bc42344fd0dd9e8d695ec7e9aa4c15ad15ab27f5ac0d128268a9ef8cda17a9b0df3751f3162958e21da00e60292ad54a3241f552588498d56bf7b9abdba32502de5c63f261cd66d3cf893a31d83b4d79c2bbbcba34bd3844c593841fddbbe536a9257bdb1766765de4ea46f8b71f0f0096719dbabf02ff5464fb9bd496b7345a4760ae74e3de01b8fe64478ffcf6fec722a03dd485c2dbee0c326f65e7b7ab3f6e375fd641070f38dcdbd8cddce0a0779b878efdcbc2c9438f0fabd123c3836adbaa4301c2395f1257cc0758833ceaf6b04876bfcdeb2103761df664aec0bb3a0e879d456b3a6d9851b6281bd070fe7ebdeb0f4afd7ca1459e676ffd4ce4681505b527e93e49ec2b4f8b3e5d81af209c55a95590cc1853543b53c8890ec3520605da3374d44c0dc3292acf47531003bd4257007789ad4d517bfcd054d996f2b8b7c307eca006c61cba0e48962913cf80cd09cef84d98dab5612f2334e8a8c9ff38868ec909acd61d56da3927ee24f2b441eabbba19d063b24394fd4a65bb7bb4546933de88621cf4a09386015c66d7a1c610b82b7809655937d00b4b1ff48c16ef8939865c76a869cd7176a7c42f595e767cfc5a2d3cce0f83f595c052e75390e97f030a7dbc088fdb17dc42d98a6cfdb59fd6d85973e4ac31f37f594cc70772eb6c5147faf966a73833b9e6ad0d2ed15f39960f45db0d8d49c1280a535434841e4fbd73c17a2a9fbc5e797c84ac35ec703c8a2f273a11638731c7628718ac6d0f03ad923df8a55d36a521dab22bb53c2f62a776ffeecd17b9da7e6e4b2e62f98c39cf02734cce1cea6681c89096f4aff56bf9bdfc887006fa8286cf798951ced57c7929d4da14c997203a2bf138fbdcae8659ea0e7ed4f2f9292e644e464a9555bd8804fe6641b14e15d6742aad10b052350c76f6686122729e71bb598ecd28a5c9b3da559c3691fa065ec679e37e548f05200d95ded0c06d259300fad38e60e6cacf98b7a2fd02c9fa58c253c593226c574484424602a4bf9e3b3cbb09facabcfa0d91031ee9b6a106efe50e014f22936c1cd2879d0b269627436a4cf88238e0d869dab824c09ca9ac088a604bf5b40b51d7d8e0041fec8ee3c29ede10f57d2bdbc1ab08d91cf2c1b93ce21cd83e05933186b1284e69fa05a5c362d403d3605fc0adaed769ff4926dbb0804a7ded55ec09bf7de741dadae57b79925fee137f5b64cd66357b8b280751ef644d9f53e0e7edc88789adfec126c7e8796e41deaa0ccb81b2fa74600466cc147e92dbbb05b1335122905af1a201f42360a5ee6f90577e369060a93c56911c5edcffc4cae99563aee025287cfdfd80cd9ff54bcc22a28c5f8215456ab42137b8d12d24917dc089fd9b39f7c6a9478bde5f695917db60fa9097d254627eb167d247a8115dffb53e14c92e1341f11b85cdee608a5efa91e4cc1abf16fa04aa7415d1dbe439c72329bcb6c83bc06d9352fdb1976ece2f9061212eb1ac2a8441aa65cb485bda497be1b5190eb0002f257642b99a3ebc9024bd71ab61eacadad48df985ed4674b864a15b632ace7b9082cd0dd781a670958ff61cf5f8d19bd4f863e680cee38622549699081971562c18d6f61c390acd8e482b199b56233b25196ef09735c4cef2958076720d49467f99cca96f4b9b7618a7271e7f47e1dab9b486e6595eca61f5880ec5d47f9ce72ec488df60c95dd865e81fe0c51652d41222c2cfc9536581a01a366c3fb8108fc7f1a303056371ad1507fb57a2a7f7b05236e6b2368dbd1fa5d8f5c5336295c2bf3003b0df3ce8c3d69ef4f7a500bd2802b38c83eea91e794dc8ece15bda45d038db9bd9aeb17fd9ac773ae2a54ef8178d9b27da73fbfc24e22b79cdd01ee1b2d0b327ab081179dc05695831d99b7882479cd04322ef6be5bddfd8200bb50cf7b245c04769464f9f1691be8372dd89276041943b1cb46866403f8b75701aefc454f44fc7d1f0042d54de472f4020ea67f4e2fb656cc3bc9659e4da5462376183f61e6745d72452e5aa637debd7816b715db11b3c1b20d957aab1f7ce3c9999d88591e3cbf38d122785fa0a0c5390804db029a476a9828aee9c0c20a41f15b60cec487ec3cac2010872abf1f7f231eacf4a8f25a348677823e9264e49b5a8df56fdf504a7f414e758db6040c18729b49f0b28b8e1ef41a9b332f616a5700a947eed62a06edf820ff884431c2f1bf0e756d245f06e457c84e28b26654757fa68cdc16bca339b2ea4afdbfbbd18b25361d53625c4056be1b9aed354bbca706d3ffb4444186a42b6129670dbb82805abc42dcd7ad787aee012807ea059c832ec91fa75839c286a5c26619ebc2f9452410f8b1f34fd27ae370e9cfc110e471f8dc77a3e5be19ad24d5bd0d804f65a0ad0ff9b7fe13b4087236b340a2d53192060247f6887ca32202b5eb936d9e8ae9ba18087b9b98ec99fc741875695b87e3fb52e6f81f505e72604da419bf1c238952306813c1688af1e6dd92587259c5b7924bfeec6d870a46909eaeea4bdd6bff001d3d095ca989840835591e028eba3a6dc53160c9007595c14eae508c55f87894ff11a09f32895835950fa04927875eb5d7013e3920b5ae8320208aacbb1aeaa66d567e9f02a437993037048d2cf140bbb353a47020925b3b408841ab6d2f8cf0ceb392b1c26858d22f2e8595a0f515f62fd8fff9d380a19b3dcec3056be688ee79e55d7d612770965a990dcf6985f77857f25453f0a5b56ea6fe1bb1826596fca2a59f113fe1bb8034a095ec2d9d43924658baade67ff47e94e5fb8d9d7fd42480bd079b6d0ccb380ee224c1799b15ce08230b8fe363d55ce7abac697f4f71327b1e03aa5203ee56f3b97aa7fa3177131f68682fbbcbe82c25feea3b14c42abcc370322348741d43003362b460afbb46afbbeedf937abf1d28e49f89dcf0ac472ca26fff48c71638c19bc595fc5eeadc20a50ccf43c7a8b4f963c78ed2c3d130c75c2022d6726a5e3c03908bb99b01776c95dac3b180f0deaa0481a3ee1f2c50fad19f2a237c8d749210f1a1e586e1d5778bd0f218f693276f42337cc99440f6e3eb807e7294ab6fd3bd3d2fd6abe3b5cda97d2e7629d98c9528ac1fcd90be10d4c7d40474f499808e3f34760ab00e2b68b54c00cec404bbb432420a23cc82eb1fcb4cb4c0f09488adf4be6e06fe2c328c8564ee5ec8ece1eb46e7c2170d258ad27e323bb520a3f66e87cc8f10e0e53d2d201f1ac9a6483dda49384895557a9c8c343da8c4c0f4f5304b93a2558be0b6e7bc0f274d72e3f39e05eba4a1f06586f4fd04c9cfdf912769b6f0b6db4ef65764466cae1f47a101a66d52906697ca7c77b4682bbafeda46873edd5727121bca820b7d4d86ed035f385054933b4e27d419a3dcc361e284264598e6fd2d0bd6f9ced65fa11eb4baa114aa0a5dd9bbc3a83a581d743f99e0b1c23ef0662a5fceba1eabd5e974646fd7f3adb162c7f7b1f60a00e8d29ffc04605127cc3c2a3d4ab43f11dc4f796acc61b99f820c9abada2730cffb49d0128ab1d4674e5aa826c93c73284a6a13ee513e629e68bf8d55d96032bca902b487cc5b1df3b90604350c21365465e1a652771c21e0cb9793d36a37c31a820a8990f64b6b657d9525b36de325f4db1e015ac9c9bc0470c327a08cc0b0741fb3371fdc749201bc48dd28fe9ea3b8b69eacd068fb76e862a9bde5683575f9d5adb34db9157974ba54703085972652bc34e98372c720c075d889a695d6e1605835b047399be685522864c2d90c744e791b3555ad77e5052e5e519675130e13900b9d522a9a3f0f19039c37041e4c8e0c740910e27afb9a71b5e10eef80d3d2c88b76f821e543eef963dee6e92da9c49f7f94f3a6464f2130cb5253bde0671a2288f5604744e3428a5e7e7e49b28d4c400db97bafda3b02eae4f2e90e8ef0eb67e4f9742652bbd31960c132c8d0b84a9b284fb201467b0cb2e7e16fec9fc45c486a107839fa649f95449a0ab23a68f98e27f4931086ef50a50ecb1a3ceaedf2918f3790ca6bff06e34a60b596cb720469b3cb5e505d0787f7f32a10119139a927d92da224ef73c41ffc2f2cd2aa2fdcf945ad802b28f7e66e14558f1ea1deed30eeff1b66aee0ff5d4d17f6dc07f7dd77ac4e3a041bc2eb9427c390d6493bc3b06d2ed280c02a57024bcc9ff2b4c2b12e3a932b63427ef56912db1e17a714eac27fd6441d5d359a2ed1fded844e708c2ff7654fb9432849ac666cfe22fb6662e327b98ccea197e139f5a5101fb68b25cad5c78a8c476a2596f90e41c63e5fef9ae64169001e4b033f6d64c2db8d0296274afed635c3650fff94e642143e0dfadd46b01b46e2e1748b235eb18e87cee02f174afbaf027194435f832d5f0aece838c18e9475af76a852eff4c8c2a8d394066a1eb13f3d252296ac977801aa7d4586281fd7f17acb65222e800350ac3e8f65d725464c9df3055552b04ad0012cc2d73202e0f67ece13521e01f5d8058fea52dce586eee5e8c5e62bfddd2760410d11fac2d474158d8f88948b1cb960cb649321e8a7632abfd1dee60f86c84bc661d4a5ab036db58f654ace9775a70f65a258b155ee667a765180250248b16cc2d68e433476dd22ff57df07d90b9a68cd4857b6d1013d8872c4736a64132c980aa4c853dd93e9ee2909264364d0dc408e906e1ca6b3484b54b55a8bf7ebcb41ac3ee4be03576b1cb95909d7c050401df7fda531b516cb474b2f4e943d927669068d857b78f73c87c3ce4df54cdb43c6a37359ab26236889ab1cd8382a9802f58c416b1e163948deac12a2f730add9a06fd5c8ae397709703dbccaa5a30b0cef5f63ecb5a36b8b89491c390186a39dd581978883c551b7ba945a439deab18cbfc6b6995dac2984d21f42acb716ca3892af7f5c4d4324e974c38557087941354c37a9fbd977b041a212c4be62f85fab83e589115c6964311a148ea6cd61cefacd812e57e8f483d6071ada3898eefa191d3fc289b713e3548c0377c9e1fe0cbee8bc1c92bead79a91d6b821045f8a77ffaac115793bf11180655e3247e5a1947b761a5c9aac929bd4631c950a5fee0dd9376718dcf9415cccc7831f60ab8ed861df16d708de1b03ea5bfc6901fe9603d0652012984401434428726929a9b9ba4bcc8a2fd93887b474a3df29b8914b504e8f4626a69ac9b74612c5888fbab511ff1eebc49350db0ab90df25367abf9a4aa7b5aceaa5c731b029d800cce2ae2d6aeb7c9ace4e0145e02fc465f8a1caa63c0b266af79e519fe6f14b700516d3b73af161f9d6eb271bbf6fd55ec85fd12b8968f8c5909570ca26ffb8d99c1a2baa85b03eca74a1c336ced3f3a4c5ba0347958e2835c1052b0c186672928290d1e07c0210f1ec721f8534cc356b2d3eec8670dd1a173c1dbec6203ffc13d6cc05430fdd9d8eabb760b716bfe41cf21291090ae3463273d0fba8c35977786478761be7e50d7713b1d4954323a7ade0b4693e4b7888ea82016adc696413d0620a1b0e5c6018df2b8c55429b000795119d5b556d915b90b462d2c3e14b24a8861dbb0177bc5ab105ce6580f3782515f34770ea6f7463258db83b76901f0a7ea778c128b35e4483fc2ab032c94ba7ebddb2af9c19b3587724b922b42c5620a2440de7f69cdbb17518f2dfb1b1c44752ce499b273f7b3b046944f7c056fbf28d6203e1f11de22cc787db368ae42fcd851bb36fdbc1e32344be96d0984b031490e581dc4239a314821b02e3d3b97d3f6404d28a37f580d725787de639e3acc1a31caa3c27af008fd99fd92076f9c6a5b3de42c983ec3074c776a146266ea9d9a2b655d44134f473c919c5f7e148917720d14e0294530e2d1c515f765522c5cfd14d1454a1b35e466f9ff72b90756568600ebec34afb44e5068a524260891daf5f8b5ab35a198ac99e38f6a7107d1f6f36ae1a3cb43ab08f024ccc16fa62c205849078971e45410566d492ac676d5a598ba8dd0730b2b0db4b238611c7d09e3a84bed44f75db1ba5fd73f47474bdc6a2379890d3de83ce6e41b6a09d10ce836ad549795be435f6c03b6664c9b95c059b91533c053cb9680c361679e7b5196d8360ba0e77bfe98ee2c91ff754c6cd9d1519a02b2df3502e8a88fece93d7432ed2893b8e36e23bdff70cf655096fe176f19125bfada7fcfe2c4ae0f97996c9630c2f02314c2fdd512fc71624e334a0f838c6c603b8a6a5b9c798379daf3e9749cc849663b0a173f6a921c7e48472b9fde9da4d1e20373d3968a88b5c8b523ca66ed2eaf5048a0a5a1b749f33f91826eba7f824e730b43c4fcfcfa0f5f065d56cb40aea4cda1ca3f5d713c308260116c44d9e2af9da45e2d7388e0e5dd6463b1d34a85f40b9a8fdacd39f478ab5934474189e1aa7485fa0059e1095c9276f1714c355c1d0e00d9f25be08652bc4578f313e6586bbd5052003f1889c945fa8bd0535bec7fa2a9bcf2a1fcba8397c6e577bd31f0a9719dd8797ed8ba616873f434405280ffe96c85df27beb617d5fcce60643256d548bc9b29f468a6885f672bed9525ec1667b1b2210f0aaaf80f36b1955fbda8060c0d17da6a72b928016149b002eea2144abbca47316cb42a68c110269fb6914f02b8159ef7855b2bd9e8e566266cf77062a21cfe1db79a2bc8dae8cecc5b522757cb3b48812ca9267fb1666d0030758d9a0c873b5119ba1f2fb3d26870967acb3da6d7cc0fe9dae84e7e73828d1a242e099322d19f063c0f5d54754b6dc8a6b8484c4598a0f40f9695ce87d96574da68b0eb7cdf2e49095c3b88a4ae0a25caa190d99bebba73dff9a24690e28fca870078d372c94c3cfa384768783483e7c018d6ba739637dab2a0250ddd9d74ee151709eb65e81d0c7d743f5f03528e90c2a733ee63c9549a7fc8c0c205eacf12aea5ec6f75f29af78a7016dddd47046355346eb167eefec33ae464ad1024fbee0c3a77d5b528883c058c1230f4aef7f703d6fba57fd9adbfbd7df021f9dbc81a416d9b421c4652db63ff1f8232931baea3206d59f05cbe54d0944dd5e5e48742a7c44f224c8a15edd2150ed653680f90faa562eba19757cfa7bfd9759f659d5603b5485ab18b9bd6c42bdbd00b792efbb28ed1b74cc3e59fca30efcb9a794768d4cbda318e546529240f2b2baf93fbce611f416d9aa84f5369ec06bdd3079af9f56265f69930202b8aae91fc3dcf6c46582cedaba04f267e21df684646f5209b17db21ba7524eb1de2492b7a52064640a6264767e13db7cc89a5e13841854e4100b4a25cd6b08069ecd6f63095fc0c093093b4b2e6ed9348e453c6af4a1ad17ee97215273835a9ac6f24434185c9a80b79663a65701df476f2ae31f7b9c00f6c5b894589e85198260fdbeaaf3cf104fbcc6d3944e64346bd8c4bcd74798728a154899c5e5058d917fac1a25f4941eaafda282a6248d6c87d884398e721418b3612af71d02cabc4ca0a50e62be3d0b3e02861fa027eca26abf23d641a6badc14bccbf7d8e77f68bb7f59e5bccc1e1c457012559e83223fc5020ee24cd1da64f7abfed3985b4e2240ab05d1f63bc9e8dc0b7826f29251835a58f8baaf194c6259e16eaf2d931d983c22c7e925a35aab3f933403ebeaf5ddf1f156e76805c2a6a70768e6ec2768ff7832dbb6ea279947e155ea0ebedc2eb41bc4c065091c03da8247698090d34cdde3a2217e22c0891ab7e3a6488e7e67e0a858852ca60204326acd52bb1234353fed80ce80383b9dcc33855eb761507c6055231f4f375e1c0b49dc6c2f11d4d5a9ef1fb153ec91676920ffc3ff63d91868075252f710aefd1958a3418b776f1bc9090e7647ff57aced3fd99fb36b5df7c62c61a2112d8ad14d7b4ad79989a8a8dd2390c0c37ba58ea5ec803a20b302bf6fa16ce1338b9cb60a8328ba3a345ed2047d0472b3c6440c0ac555d8982e4d71e6e79bad4bf7021f503efccb9c1fad8b4f408950cbe0a088244c8328c1a4f3940c436caf2cd75f54c72c4e372a2e2faa70d8e9a860ee686b515fccc972b6fd574004ce8f8f54e34225152a7632bf8ab74b64a378a4dcc9629ed4252f500c2c4b2d08b67e5a003a6e36e61872372384a44596bbf86b411c5ce7ea910bc297d48da32078cd8570587380964e11bb119e7c4bcb55c0ea63c85fd260ffe4229ad7088154a17a7810e8c92c99fb5357941c722f316f30bc32bd79ff7aba91df72699627d2e4098c0cadd50ce00aac1d2a4324240ad53c7761f160984a3c009685eb6750a323f86889726fa5095d6faedb2246fd331f410eafae5e13b145fc3ac72a7605b1446b4e519b0da115c69453e1ef662d950b2a68deab27e6801990b85cba0ae6d799988b83711497f47645d3d7c3194ce606ea32eb8b4d20a1a3595b4005395a97c2b52f708a0c4818143ae340b445d0e5e1e62012a1711b22a92d9aa2bbb40f8b046402cb20c95ab60edcacb3f4ca10440f9c71d337eebcab1411125f57f06b9bb740c65466a09d374274df90ba345c5ff6132ebdd641b2a1b2c217c59c64af6f245ff9423f26e4388963ef2af6d26825d1e0822ec07f0eb315a462617592b237d174117797f9a069965c92a2d51dc93f6fb75af881aec4d556cf992eeefd0643cfa7f53c9ccc1f5a76db012407851e8b8cf97d6012c7b6f0274a15bfffa33393dccc81975f0d36acdd88664298e47ed529bee6dc7796bf3c9fa4f246587654ac34c9f3a4b707bfc078e184e2d22372dd7aa8113c455f550123cc5a8563ac70016d63efa502f054a23618887da13aea74ba3fc7b35c73b3548ce05af9e60428a3f3e4f8dc073f8155446fc630de575509699aed566498c2528ad084bfe31f7fe2c4979b730a2bb617deedbfec3ab1ab5dca54ca4d1ba85f48c484df8c2abdb53c20fa918b3315f0cde79f76e5ecaa08d9b9c4dfd0032548c39477986e8ff8f2192ade111db26108b224bfdfd8d8da230afdcc21ddf8f02d02c2dd1f898e1bd7db817856a90d152598b63093350bf085a2fd8b5df51fd336c201010d9a2b89c9b8b8da5590c4dc0af9ce5417d800adfec78138ab846d7eaf87bbc1c3ddf9dc94c27ebdfd2042488e62c1be38aa0aa5edbb5d5c12cfbe042a5ace87318d100a018157d9d4641312f741443410798135a926a9a46966846df302e2f5ad59ffeb141c2aa6879ba91bba86c4e75dcd8d7a1b2bc6a4f416fba7d6ad0a7f78e2cca762f1c6c0bf664a401514b0a7d66177e9fc82f50d0376bc8120ae6efd4b76f26583797530a64993ffce04179535865ea4f8d4f87c81a24d9bc254e9e12425bd7526de3f3507985e75a2bf6dde86528b1b2a6444b67ac772cdc2d319fc868064c2771d449c815bfa5e1628669f4ff07ed845cab0a38c56500a70169188e9a4b329d34c105d09c6a2218a14f01027fd53b7a0f79812a78bb59fc8e3d4ab35c1d64b0e249286bad6784b46a0fc5949df0db47b9038c3363e345e5a584adb0f6edf0e318a6a76ddd823bd3089883ade6222a87da0a6d924714dd74161d5b5e57fb1476730a21738b7ee68d307d715fa9b0a5523984769f57c627fb7c1de8e0ab7df817ca2c2a3bbce76d00979fcccd629aa4d063efe9f658ccbf3db4a8798f9d76cbcec35c2e23e4f5039ada24a59085e9ea6e607c70407b11660df6b2c809fb9b40495bc8f176af6b9888013425269e38aeb90794b5229d5d11","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
