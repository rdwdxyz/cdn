<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4005accb89c536e172b9b209046fa85f4e852340b1f4650ee30b585f486eca7a56fdf1d5e84e405cba984e1318217e881701b6c938140bd70cc2df313518e426eb41f8b133714c6ed9b5373a8214ecbf03b5e84d03f33ebcd19a7e7e83d0488d92b61809b8a954395cb864f00afe77a2e78e3b6fa5ed388c18e4f61f039db56674aeb21613042e021d65bef094d0a9fcdb25b9cafd2782fb69c0c065439bb17bf3233a0ec2ff9cb7edb63f7a779215760d6b333f3a7fd08b0c2b2fac03da7219f9613f4886dbd8807a352e662fcf93adb72c18c16f823a928a7c2cc8a254c7eb7c28442e853136ca3831c1fe176897c2e9c61ef878539dd1a2a810d956cf655a3aaa08b3698993402d7f937fb4c0e495a3c39bcb0a1c2dd7abaaac5451fcdd3d8a7038e8059b28814b69a53a36c0d76e1bbf49408d345c9fb7934b572c405697efd90fa836004fbc0c4e725b1fe6369098e4ee372071f05a4b941e02c453fad6e893a415e112c47adb439116a2aadafdc26ab1ab53df5c4a997649098426ab23d4b1ee23769ced838c5a4fbbd122c76f2da5f63e0bbfef808a3ef17b5599934228b18218ebc699124795ac683310835827d047c42ee9fffa6ef72dedf08af6c60f4e6fd6676e138d75a8d3a4786399f70fda67bd3500bf8b4a103aa3d8685429bf6549bda5f055aea3018c9a8e72547b335383b20db7676c1fcda87433fb320fab7002beb81821ff89a2ef58bc8097c1e5c645963cee8cce5438aa3d9a042b22eb21c0eb41cf673249a56d1708b7b3a1acb27f1956a0f8958f2d3866c0b7c8ee9ad945080c566be93612c0af7537a5638db01b0f62cd38aa66b9dca9c6d3da1bf54181ad119a32006806247e7a9997295b4b1ab60cebc7decb882f85fcef97ddedf4ecbc214435e52c184315a139cc6df28f590af5bb46dc3aecf867042898860affcd6d892c1d9d5375c4f5c1d03344bfac5b526cacbdee89e114cbce4968b5f3363cc7474d30c4302c26f3ba302e5e857fd2031840d4c9c9910d8cc1b645933fe547e0611d57e5ac923e4223c7ebb2277cae999667b4e42b341d8a0c838f4480cb5f141a7441db84793202bfc6ff027f051693e2202c7f32d93d2350f34ef8f8758f1a18d03534d7f04a1db2f2f6010bdc25d39463d322bd71b733aa5e529be055a37820f64bab404f9edefe7a05ace9dac619dc52d90bb4550278beea89db63da9c338b8938a54ffddb2ea5ddceb9faa8730f196dfe2291e31817666dc2531ff1a53c265a2a87ab064f728be19c1134af0d3dfefd94f21567914960d59b717bf1dfa81446cbc28f05e51ff29357c3df404df66eccc9eeaed9d49a37d8922c96d3ddb0a1bcbc506122b2729589665b8ac4756b6ab1e146cecb1de87ef32c97bbdea6f5062eaf180b87abba973eff5bdd205a10398aa3904a3d6007bbf02da45c63ffd76350a9583a4c51e1c59a0aab44b3215d5a5662e804233c70455d48deb93fd6aca82f6d486092ca88bb9b93b6f0815003fcd6616a678d96628e3140ee63edfe987bb1f1dd752cab802196d7073108a48f181c3ac72f735ed9f780ef10e39d13321b8c7498d63212d15bd2639c59131bce263cd8e7872f06f667336739bc4087b4d1742fbf3632c1057e43c8d2ca39b79dcb4d1029891f6b83ea47e46f0e52b6f186497b53bae1983e3028fed8b8a0a6b698030425711725135b634f1f0309c693b98dce826224c8d372ccd6bc19610842769359a534844d219686bb9b5bfc234d4973d1e24572b5024e4f9bb01039587c9399c93c6a2d856b37ea6665422041a1c42698f38c59afa2331054253e1700834d31bed0a9dd7c64840d9cb39f1033917eb701459b7020e7ced4f010550ddbebcd9cdee67bfc6bb04b9ffc0f2292a317195069c1849cc34161d16d547b24ca7aa837eca0b760ca32b9ebaf81ca04c853f23ece52a6f9835da68656a6a91312c60357270e269e133bb4fcc66bf16c44e098af9cfbba643f05161327ca5afa31356b8105374f60731e62f74f3eed92ac00b2197ef5bcfb4b11a29619442092204388419738e460e5e556f7b9cd0fc14f19b932e5da212ac03ad9ca8d86560e34b4932200105f50586b7a86d9fbba0ff28d89e7c0e9a4cb1438749fa16543a159212fee27367033ebd8f8f94cfe0b7924f61635934fbb24175a7cacc0888c4a3a861af64ee447c4ae172d409f0a6812e44620a44aef80db1023d9ec887f2b4eab3641f2df7259ba4eb627ada1dba4663e6ce56cbd95899953fc0ab01ba6a006b8cdc5cf7e3e636702f0edd606e0bf61ab1a451e5aadb7b1b2b9d3d38df81546f93ea0a3df2abd444d153c748f091d057931290ff983be75aaa094d737e8c69297e1fa3bb1ec4de149bb7477f2584305620d0c2804ec025785e955e788125c33cf6a00d61a37a1f606daa6e2acbb66d6c60047d0f05af67c65ee72d24a3f03c10bf445652d85b10c02932112b8afc4ed32b5d222f8bdf59f2635c5868b4b5c3022c2e3294a25af6dc2f56a8e60471a18ca4ff61c0ef516d73ad4865ef13f259bd63bb4cce8c6d8dcd40747ab635d94dafa870e10ce6ee68ab444cbfb222cb3ea0e234e2f030f1fc7ce0428356d6c74f431fd323f36e25d6c3d574bec2ce342aae7af3e800f506d420f2a92a328f93e1ce678cdf9be7b8708bc96ba1650ea42eb10e5ef8bdb1980cdfd531e20d1327deeed34f87653394d45a70ccb4cdb3a56d93a830b8ee2a9550d4154c76db58ff20c5a77d99f5ff534e0e0602f62bb08d33b41f7ea2dc95a2fb84319c303d44299e0a73c04d5961e924527b1499362bb35dff4c7ce73c432b466f4bab197d42c87d0e50974fc45bd3deb2288fbec37cee129f70c1312d5f6a9d5a8f1d0afe4852f27400fc9614045b30f29dd84bd80aea792c1343e48dea06ebc373cf77d6e837070a85e22cde6123508c7ab124e402cfde331148e22003c189e698935cf5c7500a629db85926a7d099ba5888252ded3e332ed2530c9c15e0b62a985688d0f7a8c238a5877613827d6a74739c368f052907b17720a361206f4362d313b3b80dd1fca686d765aed73232b8839bc4d3fdd4da40b5133e00d3da9ba4ca883368f17e71fce51860c1c25e4e510e8e5b088cee7828930e6325664db5ed48b53a16c96d11a4d09b0662f626bda8c88df06ce2be2269ddda5017d65b450c451f202e1530c8f22f17f80737a8722ad3895708baa87266fbe52e23fef021d49034206266936cb94023c8143b8983426998d59062bb777b5762ff3ce47ea0b99b38a45f334b9f94a095c67713db97ffe0866d0fbd4ed3ced6d5988b3805e9a9dc16d39e54275fb718c178eb2728de5558070901f108aec3bcca71745bbedd9e51eb9ec64033e8c0c996839b38010f88f17d4fcdc4712593a989680754ba75ac64ee07dc6d80956fa42daa5faffd3e910f1d3c741cb01578d43152358bbba791a6c81907f19fb3b130ce4d7bb2a96c9a25bd3400da192990560d8b432bff2487b6e126fe5aa0952e44dd554c0dc0eda1df10392f9a41494efe3c39fa9558c1f24fdb30a434eef746e361ca2d464a5f88983545b96fa109aeed2658e68fa5e7cd2eeebdc80e5e896dde5d3dd83c15c3ed4f95da0d534152a302c695cf81c2898feb4427e609db5e2a1b24ebf9c58d24c220967aee1401273a79d7141739f979f5aa09cea12ec8031a9c1c41d1307cb0812c366e931ae7e226dba54662e67c1232ade0c342148cdf8d0c00f5a1180964547a7ebab504fd2c7d36454e3f7ccee876657c270f07f834e29a1ae6b369f3a931d75c86288474ed96737f9d16d1674c02127016de20f08600aca269009d88b239ecae34e032a22cfa8f6bc08446fc61e3c0c750aad313ca6de0e1787dc5b0f41e9379a0556d4b1b08fc2ef4e8e570cfbc018ea0d21be84e26f2a1c9daa3f9d3e183690401f4d74b803d1b367c49e84a3a2f96989b230dcd185883d9cb25e6b36ef4a5237e9a1960a1e999648f34eb1ae25b06527b30ed2dfb4178b23d7edc74fc48ca75ff19bc13e9225bf5594a93e87baf1df2ffdb73d4dc099b2176a84b661b28124c3cffe133ccca6fbec99ce464f749ec2b34719bd271da781f22c2d642344c52b47dde09171571e7a74de5b6ba4d977c88a4596b1fd2e5e6f3289052c7bd46dfde5f71ecccb1b4a75f21dd4bead5e8ed27d4ec16f8d484a258e632732ee04d9b7b5df960136caad1b902d76c12b8e4751c205a541ee3d994727c7a990653354e27bb37af209dbc67c5302b0a7a79034c935f17a699480d08e9c73434b716ae37a76eaddbe89cfb8bb5fb722727266cfb184ee579c6bc760d227a6e507fbde192b76f6303961d57a01b94e9a28ba6cd4d1962ce54e2655292a310cf34e6f9af8743ab703a5a85f94ea2d068e369a568b16cbeb69efc560e423738d5c233e5dc1c2772218b9cb32a022b9f034f63243927f4f1685e623a03c009bb60f4e21dab3cd7967cf1369ed0e73e0480dd8cc431cb9b4bcd2315e03c3d5fac15adf7b5d06739a683838add922e4579234945932084bb6aad1a93dfa3fdb373767884c3eeacbd8133af043bee95086067ebc49c7b7a0921f77b39d4375429f1b7d3b9c536f9c40d3e1b78b39ecf521ebac1d848c15b276c1c536d8d65f162c2acdc00c8cc94ccccd08fc92ea86d43a5dafe94df88d22e80a4da6d0be2ceecea6802de2a77dc1186069ba7013eecc0aee70314b8c5c2d23f5df4d2e023807d524bcaa2251a15a65d2faf0c14746457c50b47afbce99dca7ebf516fc330c66a9a92902aea027d0872aba37ef8c2bb393f97b94965ae04496b8e710db52776da04fbe1f575385f52b610c92ac3463f1172f54f9546d764809e9bd522580f277829ebd3ecd9f5cecd5a9475ddd541fb60a32ce536268195689c07aea0db23f4e4d8bff902a63b7f2d85b4c749a7598263768811d7f3603cf8897d777d6b71364a49ce5c989ef3ab38ac7111e975ffef730bc9cad2e95d491c8dddc9bd41bc90e044b4cc64fc2c2205d79f99c13f4a9805a08cac538c54e3130ad4f8328ba9e458439118f44200a76e38fb252a7ead66bc73e6bd30099d1140c03eb82c62bacb3ffccb8589de392c907fead531a687f5c64fecb5ff1d5e6cdbebebf526dd5ade0d294468d59edd7a9b759052ecc7a12bab30500c419c7e712cb2ed6ceba23d5e5d9ce7d1fbaa1e5cbbdb1deff9774c8b331578ef662f5946a8a2e9181cc59277113caf90eb50ca21098f433dd87396407562549d2073aadc69da20512c6726608f5e8a7a6b42e4a49b0418c6717c0448b6746c247ce5d68485970c0ded5756b2c7cefd3707a2b432a7dc391407e6c61fe8bdd80fc439538cf3f94bdf5ae6092224c76a3c1ebdc04a94fcd197d472793f4e9768e407c809510b6b5f3e75fd1cb52ff8d4826664bf4661468c8ff61ab36e5d19d8a00c9625669f13825a807fef240f5935b1de1fc3b22ab9df873105fa3380358e0f774de32e9a14ae5b03ccaf5f6e712b93ab1ec9f5eb3a6a638be49abc9eababb86c27926e21d1e8f30a5122051713f242737e85a5d0cf7916a9269ec52ecc7a43a6816829560953fa362abc32682744181cad2bcfcecf76590b6cc34075f312fe3c0877be0b03c6d7fe57aecb93f516f4fea8cf7f695e0e0f688f9d56df288ef64cad22b7ecf9942fad87803ac5a523ad85944ae3fe38ee8d7eadf8b510e78046718f021d58b2aa0950a131655a58a0f4c76d946d6f0aa97caf8b9b7c07aa45274fcef9f8ac5ec84423cb1cd3a144a0db03bffaac6d2a17b7b96e7da4d4581a5ef018b337335bbede20e5ebc60db5f895deb441af3e54d495e767aea995fca28ec938027de4465c7ce62a62dc18836dba44f9fe2edb46a783fe2ea2e580b459a04edfec2637808792482f58e3ebe1d33a3f0323c5a98bcf49ab300abb13576c87a69ffe8bdc5ff1cbc66a2091f8843625704f45dd70a3b09aab43c06f7e09755a60f3df15a0d07364d6ae8b84e9db8204a67f4d232f8b23d01586195a8ef750bb7b61a401c6d104e776b8d05c45adc0a87a101aa5a21b4d6c21cc81d657df47494848fd4d851de035541621934ec70597232579f0ebbbf8ffc2e569d61d2d5ec9b75cd05e1839c78ec122c8541ed273e887ac805ecd5378bbe1fb19e1cb0ad38b3a499aa46c2ffc34ee821fa81e1858f04527f617eeb99c970ee3d31571b1dded31d5ca2882c67951c0e5dc98a3814bdc6e5368f4df6370a1750597575474ea149b6f2fe0a2837ab7305bd751bf18873e89f4366b3227422c60eb23e89ca9862a25bbbba045168746b56a2d7d7a7e69b2f1bafa5d87839707f4c5935396e87932bf80cc69ff43425ba9048a57dade02bf2c369d022a3cb9dbe9b4d4ee16c70b67f2924ab6ed5f013e10be3e92090c15ddf92c22b2aa757c6b4aeb9c675e42ae88e617174310a46b86e4c8c9c9304f04a04db7976c915bbdcd3f65d185db653f47af9fe4b6603e71599710662f06558ad345d82271be35b088f6dcb86f55d08b7695b35b2adcceeeefff3f4e174a899a3e50d5e0183e910ac42f719fa5556351566526771470eed59ac54c2f6c8616dd245d6bb9c9f2c0e8333f7eb82655b8f80757d88040c002291ee60dd049a2abf86c61fb3331bf45994687ecaa72cc176506bf08a42c58c70a085559f608f440f202acdb8b753cad082cabd995bb8cb6999fe747502e1560995cba58acfd80f713d25f3271af75f99b76ba8543809eb4923d8cd38f9926cff6bf127e8b7f6aeef2aa69714c035d5c7d82eb5e935006df32e0789cb76ee88da77eb3934b5cd2d24a673c37064eecd08eebe2a7e10be00202cd5a39d26d992de7f9a6f42e3326edc2fc56186602fa851de3c88128754957852e29bfbeac9c26d540cfc307bfd0743a65f94dfb36ac127b430b1ca92560803cc4b0f0e09f5d9ea4f677b28c6eb87a9fda57ee43420f38e4a89bb966c657c0eefcda714bbac45a9d10a7f416523edb5546415687ab25d8e7f9f975603af58440169ca78a627d61f51a9d365f33c8b71ccc7c5ed6e7e3fc17bafe6a489a7986cbfc5f2f6ca4dc230df1c562bf2dc7ebd6bb0da81f4c0883164662f02848d3c815c1733a977bee786202370e37f76e69d2e45698098e234495dcbc1a7aa0bd1668b57227744f098f9597b9b4a573e71b4b078a2fa4b04b664a7d144bdea729652faa186b133464a244fdda57612d0d795718f7ddb855a1ff33f2903cf3c80a5447aa6803427f61534788c02aabde435d3ec10128d474359ab50b34eef9d838d1511cca49e4ae61580cd030be48844571f8f826365ba075f246466f0e816110e44ca45c3661685c9445654a1977affc3eacef194c16808d4ab4011830319e02e3e4a84dd7b4fd44eeefead9fd668c0c540cca59918571696b1cd19d5bcba8593942bf529f707bd9f9d11fb58263f61d32d17b61adf3e9e769c6adcb2490fef501ba7854bb07d8f2812fdada89cc6dcd3703b5c1c16a4223152122eac5bdcabd13fa15393f59f6fec2c7b622042ca7c66b4d775f58699e6231151db4ff8c13310a341938066fcbdb6b9d20669200b075fee4c3b69529d0df0bda320143e21508fc3ef1044284aaa425e0e24511fc245cee23f2ed7e6ecbb8f141b251b4f7b468358b0de93cea25206acbf5faad141737cb1037b2c9d62fb640a4f402c91dfe1af527546cf44acc43cd1eee7f833aebeff8ff3d4d85ba6c03e58f60a52ecb4638b1d41b971a411a6173815ccb26f03e524da1d8ddb5cc9e9137efc09ae204e264c5731927e044e4643e505dad7aef9a46c85ce16b099d5b02b7d7373e141e433610dae557134ddce310dba4e6c86700f1a64f782df2db9ab4052e2acc62a018150f4db193a953887dbbdd45702d5dcbab3327e8401b2ae14606eb612e7dc5680c59496983d8a03eab062f305caba0862b8cf6e218f242caeef454546dea1bbd6c256cab4aab0186694a7219abd8881d2ecb2a08515873fca7a084b09be9f352977ed006882f204fd2e5f5541423d9931291b8e9511381878ad04c073525b41d2da36b3fb38de328e3419c4b2136d0946bacd8fe7c6801500d2d15cbfbca62036c7dc69c256af04df6531c7d4bba0b3849990a8085f470a5352f7c0d06ec1d12d15732f5d7977e523b6d1dabc10b7eded5e364ce3521bee67e4c2a6d09b3e355397cf1723b4bd89524df88dd8e1714148fa808a1589f8cd551a75b670246371e50c54eb95285a4dddab27202c09a52eb2bb14a2434cf1d784de7b357494edf78c7d4530108547ae7cc53d5d27ae993a74f48c2b63e6002dffb2c9e45123753ddd07814db38979ff14b7a9b07cd4320401c396e447c6fcc1350828be8205523002eaa33cd46f052ea2267366391081a0e05dc4ff898dfe78b00ccd3263d47b02251de28701c00143e0fb0a8a63a1df4323d3b07c61e180901a6a759820cac1622852726297b86b913e6a700519ce5077fec0f4d7a115ccaf2f46b4acc76824cc2ae93f759ae1abadd23a480b605da69285f6e44568b7ec7844298b49739567e4a1820c3fcec60cdf642180b3cd5cbd37a3019994ceab90b1f445c2508dee06c89df408c8e9a55611b590310923c7084ff6454fc8f08adefc5b73aea63a21fd79403812f96628071690871e8eb4ddf6484b563a38fb6e945a09ac71aa4b829f3bf5065db707cebc00db90090b7eb875a92030c242a474e510e482df46fb5cbdb82971a3bea1f22762dcb8fe8b41958f202f739dabb4ea10f405faddcd7315780979b0c2ccde6f71b3d3ae18a5ff6f71cad56348b1634339f298f21ed9d4b035da3f8453d0eac3bd96f7b23a25b8548af843f5180f142205542212334ecbbc828eec1a46ca5080c2be92e214643c5a70f8029bde5feb10f64e07b0c199501627856355164c26b2ad7a20dc7922ce75be760881cae9951b44ae49eac823bbf8cf3f941d9a764d65ed51ab0969d8b350c171b6d7f970bed0e47592607a3ba5ed7ed2f387cbe5cc0ba895f8ded4a4a59ae575d9bbc212c28e280d13f2e20f310123067f8e506622958eda4bab0e08313379583d2f369c91ebc2cef9c326b9a93daa011a53b39ea44782f51111a892e4bcdde488d34f77c92e61d2bd86d3d279695ef8da6e4e27988096694fa36a91c9faf9ac84be17b8a819ccf97974c1c71a9cd46607818eb4628e0a6986eaeac8cf5f60222d21f9e6820dcb7fad12ac8268e93d87f9529ad5b8eec04bf9676745d03576aa8336a50eb51611c4465fe05815ff5bf95f63e3ec05a74dac2c7cac1842410d808dfc01db25681be78a5a256a49ae1f6ad26f68e34d3819f2cda9295fddcc20d01cd361cf10f66f255ed97ed582be25a3ba92d5763d40b6a800eba53829e1f0a34adce61aa170fd0661d8b7692b0b6888b6e1f25195655c0f5066d915db64b7db96737ceea552527671da0156aae0fb9d9b33a4a9027f33d213e89dcafbd77fe8f7713df647181a5a1e29e5c012770b0b02aba1557dc1ba426936897b21a33806c6f1071e003458642f54c0f87ef89e82f4c221b349849a68eb7c25e2ff55431e50627bc6b110d4901a3d7f1ccd5f6188dc66fd7fec5d8d7c49a796256bec55a4ace56499938046b60036ee5f37abe65d43834607b51315fbb999ae3c0af0fc8f5e999925a5005376cd5eabb53d135466073c860a37e9c9a76abf09bfdac7bb4d701db1636f826484ff67ccfdd3355825b736dd85ef7b745c835fa3e43456e8e5d0e09e8fe9930eda77f8f5ad79147afa0a38711366fef5ae899eb572133ef09e36c3650733442c8ca6898b526fdbf340935d3e52fa6a02c9af3086d2be29cc9a85575c024a5a36faaaad50a3e5432462ca1a90ac2be8f499ec9cd789f0d1ffe9fdb90acfa9b4c5930595ae115e296e362897b23fc6a158d4a491871978c2cb7f127f5f26ed41fcd5be39b8cfe90f99c04b70b610556ee520e3ae8e5fe6719f20ac53d1c4462d13871656970c910b418e53efc8272f591f1999038ae580a95fb04d965f544fa3fe1ef1027a2198710b489862faee23d77bf448cb61fbb84fbb100c981739ba59e95e6f6a1c55829233f47f6e4245d2dbaaa96759bf58cf2536529e9c5c695761e3597cb2dfc36c82a7ba2f3f7f3caec11478bd62b119b779ea22e39e5a66a76780d5019da4ac7d722f699345c8ff26e2cf488f91383dadcedd69a4a0d1c7d9e9d265fd30eaa138b998341b5f143b347db99326d5207a3e6b3a5144e1d3653b2c6a85af15a63ba3a63fb2aed97a85d22f4a8d97720357a1c4552bcdc75775b46329a7f287fc675735468790cfaccae58aaae30a5691fe7e728634b8b05dd83f5d2b52d5cc8dc745d7a10187084e58c43579243a3a75b61b95852015fdb75486e5cbae08bf7f2546e406e7706b5ed17b519b3c411ae27713200b9c1479f116809491e6348ac6831bd88120e2d62bc5d7896a6d89c2deeb848be0daf3cbcc649bc8e39a87c116ec60dcb2025085382bb41a5150df4b0d8ef886ac0193e6ce218388a6aa0f0ac704b04b0a78b29e618e09df757acbd1e5493b63b19991f1c0c74f2328fbcc2f278140a109a4cb64de5db7822dbaa01f13b5c5e803c291c3ad89dbbf62111ff596e95d7d53ae923953ee1bdf84ac9804ba12613ee7f3873eb4ef66666ef66a620f81c609f6702f398d714aa39c68c15144fe3d5be0ae7634c1740391d6a7dbbfe8039c3b05897c4c8390e9a0b9281f8ab821389f553aa87818a7d09b9aa18db89a2f436f289bb57052149e489bb451496df4832e6c0a63fac8eb1df4f560eb87714db89cb5640c297f7f71e10461643c0486cea68db09c469fcdff6e26cf9c8bf6d1482350b00797fe08bef034583ce641e289a981abdab77ac5ff7ac18ed7e139c5f78e4a47acd3455741252633bba522d49507c29df0e50f9875a6e6c159235c3347749eca6bd79d780a1e7cd0391ca368c0e4834272d9e33cd8881cf5dc2f3debea8e96660d00149a4bb2aff992008b3ff44174c03b91bf1666ffcf6cbdaba85d7ca677c2cd4bbcbc4a3074bfd18eaecea72fa5cfaba4e33e82210a74ee7d40df40530626ee3d46546b7434dfaa1c423352ce5c28c8cb5319e1dc1edceb90c9e67b0a214f254f1ab8507c39bc8329552c11528ccb93a705f1ca4aba1767bb0f06915a8bdeaba2e976f3ef7409147d745a7dde8f4f2620c61f3e79cf8200485db127e63f039dcd52b00580719a889ab2f43f51252ed17e3d1adba8a75ef8d0e6ed308ee11f6240a50504e663e71f913a62b4f43fb9bf76df330af3c274f35c0d410afc9b5f04ab864587b3793794c28addfe84e0f7b35ae2b1dd472214a7a8553f6a30a13c543757256ac6cd9dca90ca561c8884b694de2a30e2d797246c4301b565716fdf6f554b843df78a72845581e19b006959848e78395cc77622a990871633b46615cd55d5468b780fe062c40212ce8d80c72b5f3be9b4009c15e97483fe5534aa133568e0ebb3a6ebad13c3ed24845bb7b2b708b48ca4b44cebef4b0c55bd9575d6d124d32cae1ad8e36c7fde9db2a9e56f3e7b141cc4d8cc416097f308c067c55decca4d686c13a482e7f6db9eec713bcdd8487783c26464d8b310c5a3fce501fcc2a40e13623dc3e29c15b90ade0c50112da58f3593b2a34f036cf47bf2ba6f3705d443f70bc823d2019f8c4c301c92334fdd95ec1aec64187d04cb61e996c4c2e7ddebf39c3a1b604b25c4ec9f4f54c12c1e3d0ffbfcfab84bc35ed7b8df931621a3fced6d81348488ed3f770b450664d0b9caf4dfb1664bebacccb99c173ff6a4d4fa3f62ddbffa4c6f2d2de1fbe80c378dddcf26c9c6a88fafeedbcbdb78bacf6090b93dff68365973b1f9564608d1a6f6cee53d253ff93844b0d5a7d9ebc6e2a73b691dec88f08f7f1d645f9e62ca84c32b313b7ace92d77edd8b5f9aabab0ef0835288ccaa93eb91b3440faff79457d7b48f10e2a602391a0bdfb1299da8964c00bd8ab52c239b8da2a23503fd4dda86d51ec48cc2399831145e59a809486f16ae55deaaec5c825aaa9dd48ba118bfbe4d52e297985201913629912fd2f0bd56cf868105472ee4f9ff16c561a44fb47359f2236f22a58b2388351869acbdf4eeb2295c51f95aba883c3e1d20b32a414c304cde283449ed7c2af4e5ee4c4625af59648d218e54b001fea29c2f701c4861f667f0a7bf376bd3aa4141c2687ea9330e4a0f9c7474ed559ac71382faf8494fec785b423727d9e9578ff32ffbb724ab9077e86f947e58b134e265f913f374ba975a39fc4361737f44140391416815d062162dc5e7dae2d8040d14328ae468d3dc18d1b330fe638ee27c159ba4e7478541d3af629e36abf592e4cc1b916618feeeec816a5b732da865c1ad2b6a33d2091675dc5cd23781d229fd508560833f72e33f39900352857aa21a118c40ef382d62c4c17e2e4e6296a22c12cf355b6589d2cf6ee54dae95e4bb7f1cd05c5406f945425c507400544df7fdcf99368202d6f2343dbb60dd578e6106f8c05d1c4602c96d205c95650d990f5b102c4abef1918225c28fcd66311e4e26b86e516d807961a98305a9a1e825fc1070ef96c022426733807e2a0e9a50978e5dde299324f7f7d6206dcbd7580b0ba9b83ed9f902d3bd97c063d52030d21139bfe8b08eadc61b3b6cd25eb00a2935303ab096bc20ffa3b0d39a421941f1e90cb50dbc05538dfc6e751895eabb4d76e4eea8a7e5ee87a138e4fda1aab56be76bb2efa56b552113998f1da42ed2abe17689b1eb24ac1be94bba73d0eba616059de9b822adf921c88c3337fe1d3f59170bcff5db563f29a403c60957d07a0df18e854ac39e7bc066887465af38c69710752a5a677159118ecb181f3ad8ac5af41da8710ce4cd7a4102668a278fd8523a0b0968a5c45cb2830893d948aa23f6aa8499975a5279920b5c136388dcaf0f009180652bdb234334826107aa84cc6c762d0ce6e090eba8cde10c7dae0059fa52aee92c0d2296788be3d4fbee6f8d06accc55cc73095fa98025ec5af19fda287e37bc168f437246ee1a9c666a94f8ebab0ed26e6e5e9d8c005d9b132f8005e3c0f89aec4d02019a08441857e372eb8aa9a5ffec401e7d17635a67f4506428304fe0797473c174d78fd259589963116450514eb4e9f26d3ec6cd21ec421527f10883a928492078cf3df9fb6dd09f3a4cae6e74aeb5936fc31b452e268ee28e0a3743ba4bb21489100829d06fde70b4997b58183c1fa90bca11047454c0762ac211a7767b634007265a91fc6906dbeb7691b5e131d07319552364582dbfb2791f188e90acfbd78d6a593110da29c25a6cd6e9812beb7f77b29b9c3e88841b297a7ca47b9e44ad7ec002953f56ab9b7958ca7641897265e809aaa3eac5b1499debef58ee4ffbf7f2ff09ced2df31ceeb3304de9f293c3e33c92236a0f45c6ac0f8cc6f3133fb528283296bfa8fff22d1d37a34051793b99ec2e0ce68f9f6970bc6c7f56d6c29285a07812cdaf791f4489b2067a525f58b3c66b2bce4425e2741f316b0ce3ad79a454d394e7a37e92ea11af1eb36b9e7aebb2990b959af4199cc931fb4a15b38f6bdfc9536b743e3b49a16cb6c84e48ea43df558573050053b03ade0c5f84522b9f989c36ddcfe0b44febe2fd9c183af9077007cd7319dcb330dbea7f1c1e87cb2a69eca4db7c5b1f05108441dde6e03bc6f16bf88d9c6e19eaf154a5b3f750a668cbf4b672295e991b995c15d06a6d9d7ef46946ed3ee4f8160f6071f9be675276d0b77da7e938d13deaf746c9c0993e77a31ac367038482a26175e8d2ee97c9f71ff556f4de17f5cf6a0a2e589be52924feb15f13cde8d827ace9c752c4372cad3b0d6e5b963f45ce0bf39cd949732aea0a2c8a9330d37a3cb8acf8436567031b121359d6a3377ef2fcf68df7067859b453b10f5e59fc25edc6b69c141b1dcd77e40e513cc0d9757ed2f0dabcb9048cfc07da7b6226c256ed7134eeca6ede2b016ff74edd36ecbf456c321cf08569d404fa04a6ad2f61524824fb3adea9cc20b552c1764713efe8c938f6e6e0cf6e1be7040b0dcb576e14a0157687452fc254683d17e3b889ec2b1150a15b645f6a6af4f2e907776ae9892f9dde5459a10ab260f806624c2605716e6005e399aac3d2c04fcf6ad49ae52df1f9429431e897c5fc560e3d1785a8c330046fff240a8f50bb1044fab4ddc78000196c53592eeab517ffaca7c9f73c1ac19266d158d0ba022a9d599f19236dafed5b94d4996139556222c3e2cf2160004e4185fe6b3e1241d7ed82a4a526de5ff1f83702936f5ec3c9fb790eeaa7254da8957dfcbc7ea45fb70ac266654aa4b3a2b541e445b3f01653d2777f330a0702dcb73b3164f366a1ae79eed903a66eaf6e88626e176b1285e0db75397b58b2bb062c2c16ed092188a820ec3c5c1c2837d3b23f1eb76df338080d7ad4c1211b41e9d55de5057589ccc75c887f622bcc12e375cdd3cc639c645dbce4f10e1cc0122d64a19797072bcd86b3bdcd0bcb3f1b6e5910d488ca613a13b356c12d618a9d433393c01815a5ad09ec06ad8b96b16500a28f2da88fcf4453ab2ade39d7736691a244156056de845713be62d1076accef4946abe3a0e5c23c1c2414d5e9d25815cb71bd0db76a87e94fed3a02c41ce0ca7f0f0dcd07b2e1b771353d921572c3ea1b2d0c78359a4c98646a05c60f4c32633cf72ca4e459af5bf4b07e80b90b2cc572a0b362554c7078d45ee41a4362a43d32baccd48c7a8a588197cf9df6045303677ae4aa97e67ba33d5615378cddd0218e141b3f3212e29b42d9e20435bfc50e9fa9c0e0d42b4739c73f06c6091ad8bf3e6f9245ffcb8b5be785d0321867b9290fc79ccffaac977d7cb4a4506ed7efe83b45e35a52029209586b4a411e445602a536cc47d5fa6a68573099ad893858d04ae36599df8bf53260d684d7c12cf195be9c2604a2673068cf54110de23bc5ee693536d094c845899cb7fcd4b936a0f4d89f5d91781f9499163b433ba9e894cb1a78ddec4f00399ac5ebc54a2b92c515b3de056624ca91ad55f85f53796e22fa85fc780d73325587f000112fe466e7c4a515aeec2f3d939c67cb71868c913dbbf3e9df80d5af8fbae5da2881424c043567466928956d192afe138d4a45317f6271f1e848161a1a4f8dc4e070ec0c3df1b3bb727c13bcc56757c418e4256789c638887cb2bd6957f74b1b93f3d3e431b6430597fad3c9d34c18411f253e9889e0133ae297777fd4af589932ced49122f7f150aa3f48e434627a88079d1ebf1b6c77e7dfe94755c9ede67ea84f60c73dbd5a597cb9423fe3c4ff0515817317ba9d5e96906f405244d56df879ec9e4fe6ed19f42a2d569ebc19f8697bfb512b075edd2b28301be543d6cbd1ffa0c69b19fe89e51a3ce23e83ef71d2e6efbef252a6a4401338c0aa817a23075f06d6633bcba9a11bc09815307c3ed24798184e61d470f82354f3799e6bfb2c183c5bfa89d47c6e9870ba4c29029ee06cf12759a04aa2f91a807045044431254876a8b6adca1f8342f1cac6b9fbf005a80c77f663d57c10edbf81c8f0a5688621ed14ebc5c1ec06a33d5e102b81f564905731c431e8f118b85033413837f897c625a686d58a52d51fa42fc19e2829040984908c8361ef8b96491d083b1502b1456971aa266af4286365682250ed4f0d7288ea96039b44bc7e6e21ddbbd0fb055fa7f8163ecd1bcdfd3fb9b78c4e44e46b49e71e59e7baf7962859fe101f4971f47673a96c68ee8d36f2042afee19e188e0e6a17ebd933d2dacbc415e6891e8e29da657db558f92c464c54ece12df83720e74ee748c54b26591af284051a5c2ed4bb87c1306b070712f79e1a72480314ee4fd50c43f573a451fb92a04efe2bebf04d21ed2da63d07f9a15f261f2fbfac3139f182666f22f92b9c428496a1f6d44427a69b97eedc0012cff2adc7f4b374d1c5b8bbd889f3afce2f551c8988829d840e26186c96e6ca6923e4bd117aba7453ffc3b9ea6f53f8d8456543d013a227324a601d041804e675ca773a5d7db307ce1f106ded7b08b68894f0329b22656817ac5f674fdc616302449614f7ae345f9d92772ec2d3ee399b2929a52758eff90f933597493177ab4669af810a087668b1421c43d805d630844ed0c811aa3c55d13ea6f4ac069822fb02a49046b917eeaec84e21709bd6bd136aeaaee01d7f8759223cf51d534a0b132d0d960ef4296f026f7df20227bf5d818cabbb50abb29af60e21f50d7cf65205ec813bebfe3f1156ca7846f52d0c72b75d7569dec809e552c1275b021fffd4c2e6efd4900fed84e6d7beb77e70b8aebd567dce4fefc2506fe442fd64790b82be7d3498a5ebf1e171440facdd5519537367c42b97a0ea8cada55ccbb9ebca057b2dcadced0d2b715e1a36ad384e8806b67a786b0a7ab48db2e8c80310206e4fc4680e01778962f0811a9536cc8ef358f5a9439c414f836aa3afdb8cf13a46034d4646e9153154c849a2b3d9037ba86fa565d14c4d6e5c4cf864964803f87b852d47155bffde7cffea29bfebb97f1ae4fab0835ec92c7d53328a492195d11caacca058074fa81c600d1c9b735d360dca00b68fbc2327c1b6a3aeec09548c6cae8cd03287771bc70d94f75ebc226c1e9ae7de26f9e3d8417732780d209a9e6ffaa677d802ef87d81e2ef3a61c34278298d3b1483561a0f167ebec170028a04f87360e835ca00fb4572aa0a60ff905bddbe9ab5cbc59a02ea8277136bd4c0e0ad09866ad0edee97bcaabc8ccbec9ee04dad0b3346dfe663f51bcf53b5bba9541ca908a06e000a1a46d4523aecc9f45d09a5f123153c16ca694b352409f3d7c20a46129b0f74973fa03bc252c51068c71c3f262eead530be0340a5b80df8bef4fddf0b5d61108df5a9d4be32ec335faf0b91923d44e736dd73992250873bea4f6f53c6bd47272e5a51ce5f839f09dde531851cd3484108d8fbbffbca3b53a562f0238b82e8e47583bded7162957089cad9701a69c097ec9b027c1b3bde0070bf6c2691e1c3199593cb1f6446ac4c31041ec5bb3da1a14f3972e64777520e5d0d4fc52fd2eaf49c5b2d49de954c28b25198f0b3a51b472e1157a48d9a399f9d8f92f0d52b3ceeaed977de396060b8239736e8bfa953105b8eaddeea4d3738e31a0cd97733c08360f50df6b120ce85cde4e88642a46820eeee11054a4a8b6f8a5112db51ec82471b78e9a56bf2822fb98f6abaa48fc2e37161154b30772d74d5a6cb433c2476016f8b56cf06b36dc73fdda4f82f8e3f4b2eb9186c631c27f8e24f55b60d13b1ac66d30e06a5dbca4f510cc29637c2e7f8db70c3e1dc6bf27d6ef00ba3c74954c7a073b090e85451a6fadfaf3b18b0592c7b26fe57ed5d9b1fd69f2d847e2cdf8ccde6963e6d5d96e17bc49f663d14d9c2aaa999d0ea5a5ff1237f37bb5fd75878dde013991c4dab76c1decb1a2dc48605342be6bca053ee8cc8d55f65f3540c934dd785a198b80dda7744eacf01c5d5874b586b841a790adf1a5e8f671654936d5d38ba63a8df15bf8a6743f3bbadc4600c3402dc63b119273b6ec087d534ca0811653ad958d2450fdc9b8fa1112e20da7a2a9b4694382cdbeeb29b85b9d8c3421576b479b2a55bd696e893d241b62c608b356f3c856ad7f06c1fc5ec3e20a97558fb8970d32e9e7b14a32f362028963df57204cefae81f03432005cd7c280d9141b8c04b984cd75460652fddc1a619c2e3a4ddfe4fd4bcbe4f0a95abd41b42381198eac24babc5e2c5b2158e480fb4933ebe027bff24a01104e50dc7c628f16df1f097b3b765f2d48c5972c1331f61838af7ccfaec9274a49403fbe2db25ba29500a803e52d602ff4115cf8c8b523f73d0e34baf235b24eac8472b48be591ac099e607ebd579778ee9738828bc859e9a6c163a2a564aa7cb42e14261a3fc9eb902893be5211430b9b21fc1e82c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
