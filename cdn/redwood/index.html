<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78a12ab7ba58177a417d680fdb23fb4a57aa8989eac9660c93b71aedc2678c9f1f8a341386a146c9d841dd2e77fcfe368fa6b7366eca52ee4979f664592cdbee2a4f06996753e0a35f232f56b266dace799d98ee6954bfea93ee7c9dc0992a6753ce79dad0e456e0047f2aa682e102e682940cb87380b850667fa2b26b5da1ae79ab687ea4918b46c9acffc4ef862f913aeb846c27f33d4ab0a6cdf74ac344768e8fbf005c6ce15798921093eb4aec63382bdf0ff3a9658d4e8c10f78cf9f3f2635bfdb6cf82ea358c30304e32e8d9b9ec632d28e7e7887ef680c25893b556a73d12d9286440f93421338f942e37dad4033dc6525d2a6b6aeeb603f14e7a41252c68b1d1d5e8e933202679192a0efcb8b27a47e6f09279cf1eef847f9fe7fab651e462a5c58f3b031e297af32688f8429779aef24b42dbcbba29d5c0947dec3f372b83289d3e9e02b868921e8747ccfabfcfb578ef9a46e0215a3e311caef4d0616b6115f1539284bd0cbe88f2b5d6ad1425baaf765db910501569e59721ac6488b8fa251a1a3a268e947398a43552009b06d150d28bd6a39069b95d5ff53867324db3d084b6bde8e7e0bab0fe4a9fcced0da7ee8fc25c80fb6dbf0c4e25d80600175917727393d442e2601eec6c54b1cdd979aeda7b8281c72fd05550b037d5062e789861cd2a6eacb571b215cf4ad230cb162ca3d09f3710c6f5fc5e8a95a9d152f760bcf3a615f1d91dd404e5b636d46b7e767f411e965d60e5cda21866ec3db6dca01a4a28fac7fcea51a36673fbfce4cbdd9d1ff8ef4a35e3ba74e0f4392e2d5ac1676aee512eac1a1783b48875ad59d403947a0e173c38552e70a294c1d07817b6de2550506f120da8077da0db02804c63a4dcec302a208a6a06b6eed64f6f148c26d1193a3d496a6d9ef38467dc1c3ece83c5aaf7248ec8e4bd0f31632798be7beecfd0e00ec8fbb47fb4b1f6a5d61a8c1158924b57ffb0bd8052ea59cbfaa1f8a988042ae9edeaa7c5fffa91018811c8ea0f33e2913d72c7983e99a530bc5db2c1d00729605317f9ed7d32d2411325e235d97e3c5abb2a60cee224a94ca78b02736b72f2b50a04b9f41880c53cc8dcccd8f10e6d2958ee769c4aa4f54830fb53d3a98d1f3a8d0f990f08dd1eb536b33c4dc69ffa736a094217693d29b8da1166eab0691ee14bfb0bfc2c4fdd91d2fe879e028ae22d4ecc3a92aafe57ed1e80708d2c44bfad3d2ade5cb5f36ee005d00cf865acb5b3e7013e799d3454b5a7b678c5f742543caa7a8ec9c9540b9ff8170c4e507bbaf6e71aae27f15de61d49760e647c016d676ba71886a006fabef811974ec13c6cf6117e944ba9c126acee8fb48752ca9147f2dfe3aef42d2e530587ad1a1c85d46624a067eb14e996fbf5ae863e60fb509e402798ab838e415e943a11c07282529a3edd3605248725a14ba3ac3d7377e079e277d53fa5eaeb4a967734a241fd2b60689fec2da5131b556da2219194ee07ab0538653dc4394ac1ce43917f34d779cf60d7b23a1a90193af1226d4d0618cb954514c7b7120f8700e8b1c730aa1bfa5c44027c41b05221f2da7dcdb7d0cae195c2bdd687ae437c839e2774b5f6e81eda331f10c5aff1bde628412bfc4d0c16b89c42612bed2e2e6c8e19ad73b0fa66c7aa3c64943134cf084f1d517af527d3a0a5359eeea87bf4e42f42c419ae2e183f36dbd94896e9108ecb97bb4e51e1b4dddc6174287d7142db56878a2387eb7e20279b3cf4b6164cf281caa5b34c5ca7f5a4195f52512a2d3aa0ca4015594007728a5f6f5fdd44b25f12922278baf562d2b7a46c85af1094822247cef42f0f33f3a3d8213dda352d94b7b0a9035a8975b572917fd5455d98e63f894d456e0feeaab9b082a3d8283e66fa42a192022e7d825c6c129422e93ebac871215e0f96ec8f27f82f954f5dbad576633d1dfeeed659dadeea9b04f81d79d0ebdf3fd1bf7cefe4462ff7f2b1091e43bb71599325a0daab823e69cb42e19d340925ecb82f35148cc47b607a0fdd1dedb887b68337859059ab28480127c982ab3984580515e7a9021226d9690a0475feef43b28fe15de9bcf40abcbb9838945dfb6571cf89c5799a7a11b2d998411f3185529f5db30c442980f6eb49a7e79c5b779e89ebe8c96fa838e073bfc5449e559ce202c88d3dd3a5a5de741cccd1baaab7669e40248c2a7a5d8f063da35a0b9a13f2875e626d422596a0d1bfa6c79b6e7368a00ffa86b1bcc0a2cb9d19e59b2f8d3b400998563f4b89c7cddef2fc3e4958bfb6cb4241c441841ad6072a82c008d5e2c2af07f1284d61c1f3f083348729e5b31afbc8841ebba75464a5f853c29053f84bf8ed36e187901fc91739a88e7778936d1e1b61cafb132e5de4f6d256b5e81b5d931a7cbf150ca7dbc41d043bd38668e97e0885cfc4c5ef0e82191abe62234c5e45cea87d9c7454bb047852a29ccb1a559bd0e233fb312122af1d269745392ea15f3f44f6a2e46068dd63cf2bd19adb8df4b4f3596154dc9cdcab09b6154ae99aefc6b1ffdd3e0de9adfc9f58550e0ed2700b41136a960b716f130b3d9bed6d0dc5df5917dcc6e77779afebe900aeff92a2f3f23f44b60296e24cd38b5cba4497d7aae2518216ca39e88f1f57913def8a8a7d6e81d0d3b2ae0c32faea9e7d8fb5e171ab9fb1cfdd2350c6092cc6ea73555c3f07bc72522a65d0370bf7d0418c036be5350741e4e93cd0b8b4519c0ff630de6155cc3f283421f3e468c10fdf8fac45c33962d119a8514aa1a4e7254dc4bf0d8760e583d27c7865b48c43aae73701d9cafce24318f3e616acc1574d670dfa0e81568a6c69a3b52359494f7fc59884c82ddf3449eb0ea521f118cc8fd342cda084cc8be26d7a7dd2c90f8eaaf9cbcc522754df246aa50156849c9c67d14e7f1abbe2e35253f46853bea2611d0369962ddee273560810cb7ad7fc4b45e08c9716947d6012766fdc0c3d8ec6709e590a3247ca1eb24b0e5e480961d2e61d8d35f5fc3c4e7a6383cb90c35cf45612a20fd5fa2b81c00e3596600de415bcffde13e8000c4bca51313a4dcd68d7c02f92f07890199edcbe8b32a2441dc07639dbb8e1ce77c3c9b4635a149c72b29d17a57bb75327db21dbc1a6c534a758c4b649572626ef0f1861da031bfef7271642c73d99134135303ba0dce211952c41160662133a0e826ba45301e7d9d577bfd0474808e841316cd4bf6a0171f1909bcc2e0c528e1b90ae6c9546f93945e0b17c19ac875c69218f8ea2a227d351f55af99acd0eee1903889a4033b0da1778013454f44fa6858bf2bbfbaacfb50a31dfdf9817e9d062aa968e4bdd0f6457445b8b48c227e53f2cfd850b15e215b6cf83518bf78da272460810996a19198611301a6ab3656eaf37fd18492cb700a00167b48b51b76b26147f2416b7deaa9c687db16b722cdc9db735e9541f1a482cc844a014ed828dc6103f392a3038de145b926ccce90bc0f32b8ef86875339b21365a0f66f90d7d5889b2a8c22eebc0951ac880d6d44eedb311c568245d23bd5dcc30d04e6647ec3661b6a890428c73e2403be7f539f09c256d439b28f79842acfa84b116fe94d20b0fb4dd716d22a6e56729a5d640057c18bf84025d8333e9149d31d4c86eb4966743c142769ab9a0ce10c8d33673f1d2a75391097f48c2d7a85086fbffabffb3e765a1dcccc6a7a6cc0f4528427887ba6836fc94efb8d13dba583994f029c0a79f3aeba420cd8bf6b073961efdba50ea56868973b1ecbb29daab5cd15d313ca9c17cd8c667da4f2ca85d9f3f2d9635d8c75ac3b202b06bb4df0e3e458fd795db6c7f8b4bee42dd83a147632deb6fdb53c25491c902a1f11187fdf218b255a328c62043fcee566838edcf1176c3de8e966dee703c827b9dc31760e6d79aacb346fe5e6404c081ae1f04bde7ae06af26c01f2d4bcfd68d14a4a61deb4a832a58054ebb22b561c2f9cf3bdd3a63bf88d198767c19cc8549966ee17c61e226434f7ff55da47e781df1a705c46ac657dbda608ef1d66315752d53ac7b747ebbd2d9e1fa6b2148df5d32b3cd80120c068521367ddbd70e5032a8086d7f3651284c26055bab3a49cefded3362851bdf85a82fa8a665edd025c63cb1d72d4d3b7348c98eb6b46387a15381447b1a21f7f977a7561275c0fa44374182f1dbbd93181301aec6d7b38621153cdbabca982c04cd905b8766c17506deefb832d3af29aefc8683959c6a960a5e885f43ef181b8adba51a7ca30889b9ab792cc5b7830eefde64efc12db4b105791ed2cc8068f2424bf7b2770c47b91f64d74511ae26d71f6fb62f14454ffbece7848cfc2c7d55191c8cbf03c1bd728aa380387361bc747cfb4930c2fea02b8863e35e5c216c59789c30ef46caf3f1dbbeb9176e5a3c11bb275e43488bbc9f0e754697904c9fb6546eee4d2c9642a59a2ec148244c9d38572cda890dc9b8cdb5cf0275806f0b46e30d059130a38642feb77c4f474c7b8a3ddfb52f8afd63bd6f1604f4fd2ad8ce763cabc78d7ff46de9fdc2b8fc75520ae915cfb4f25c5d2a6d9aa699614c80aeadd11d9541f0bc695870469f6c2cd1ebdfcb999917b3e9484cbfa54c8dc26a1711584bf3b2d5ffb7581a4f71988513ba1a4ef18e16e2c1e42438f8ccb9c1b7f0a2fec18da1b7c5b0af9ac62d27d3e48af7ecfaece8692c93df4a48244368ff29321a6b51d411294053b6265ca928e5d1f2970052a1288d49c7295f713996bb4d9ae72c2eeb0e1d177c09a5448fa6d6805119de62d3599a24896d3c05165f4bb5534b775c65a4e5721c81d8b5340517bb99ffd50e4aaefd9d091a3269c2370d65faee78edb8e85bb0a5e76050922e2c055319eb80260d7422b6556d5830370c33582f7244536d98598d978adbf284f157b9fcb2377d4272c47a95ef08679d1b949205c425e53de0eea8a71e21d05b7561a079956ba30176a57c4cb24a0798a6c026bf8b304166732a0c556bcf87f2e33308c5f3b61ea1d312cf4293bd33a72886a05c9e5bdb696eaecb3f432e66611a4b922f002d5015d49915b4f1e132dd899655c92ae1048fa337be39d5198e4bf20fb89834edd2a83895b4bbc73f597e9ac0f0d3b3cac896d67235d3d1636864dfde55e3ee3ae99a3ae8dcd11aa598173d7d3899f3da15dfef436f2175775c6c1998d637889738fb2f0e1e20047e58316adc0f49e866a4fd3858dc26cced12219ebef52babfbeb5020840ce0c9d509f78bf27d5fe3853f0564c5af4bbf1af05d149e21a01daaff0a98912b8644ea6912c25fbd161407fcbe465241d689f2407a2e8f4a5e5eb6198af186cc7e65baa2b6540b851c3b3400d7d02d271dfe996d0d861df015d974a249aae8984630ba766ace2d031e474690cb8945409a9cb3d8d1b727515ebc91929fdf85a85240697702ec6c6a2da3212f4ced6f4153fb1a93b15dd50c31c4506d013758ff8a1c869da4a81e3ef04b87042a72d5eaec72d55ac4dbfc0fb3c84373bd6dead1f1f2abf55f4dc22ba09e40637c84d3452f94eddf8dbd3f117f4ea7d16823f833f09a9187ae4e9b6b6237bee96566e49f9b24ff03e7236083ac54f94940de66d2ddd511a6a624ca9a4585555d037e730ca47eb7e8c55a03e1024c8f21065dc04898a2f6cd18fae98c5663eee0fd4c3132e2ec8ff3397c0fced5ed7786df599bce1b86853aac89e1d8e79b6832e8f3439019177a2fad174969d3dc96a1c5bac9d009b5ad73a69b0e663dd5f086aacbe4e78f279942c3cf0bb86a6cf9d3155b8d926696b08f220d23a3171cd8f4ee00a7302b5c4b3ebf13a11734b6a86b8248976159841555cef39b8cf4c6a2580f076e13e751d18b1be10a7547e3209ec2c8d6b479678432ce7d853928f4d647e2937756e2a89cd023092f4b2e9944ef2fbc3670ad24caa97d20496757bb03679ebf3c624a94de0a545c400ce47faefdab56725f6e42632a73c8a6a2e2e2eefcdc2136bebd400d6647df7426825960a008044c51301c3f8a2c3536f02018f168632df4cea86aecd0a92256a368d596f15be1d8f699b49f69ae363c994d123950bf0c2e8f39293adf085db4c478cff203cd14ca31920b877f08df72650ba1b5c89bbe8c220c3492ee138631c2d67ae92e84631431b0a7b5d8a65c8e9028370bc0e2e606ba7542a1ca79b1d1c05edff97cb9916aa6dcd9e2a3d0f0670c538e6463b9b8789db3f9214e25414b225f92cb292f98b3a8114ac23a9a150fa62879b5d374dfb75c5ed75d5da190f9f8b0b37e46c3d9453f331137fd4b8d63a182d81618b0a4207746d01d3233dfc695de5582255eb3239626ee315d9d166b1a4dbcd1b2d7fe41f496ef8b0769545bbf3ac3c08b3e5e21a12093494416cd5f07f9b897a3fb879912379a30d577bbab541a1325eeeaa7da9f9c43f7a70cefbfaf9e2d8e3e20013c5d0bf6631be9e35353e8b780091b4bb8d5026876be989c939b392afe6899afc77c3c4558b3b0a97cacd9d8999652be8e7aa8f1268969cc13a4b2e3ab234ba3504408254ec2e8ce1901494b04c240e0670df0ae3d21b4495fc6404934f29799bbb737ee674dfe0425b221f9c80627cb327aa2d129381ffe43c39e6d4008dcce5b79413189dc122c7179a8cbf3f8a83e69cc873ee4ba9203510dbdac53561ff68fa46f2dab0ca880a69fcb440e5c37c1bf0f179f9a486c18947024a4b6e57b60706307b2cd563f7e16fb23c0e6b97c343bb1c373a49463a860a73aaa6fa379651a56d72ed2a0bf7ce595f85a0894fe1c9fa3fe1502025d292ada2fe81d62449e5e2b9f7d63e3982b58ecec1cb8e77800e682cd28114e435c40ed6bfcfabc849c0b7daa3fe3e544807430b313e866cffc841abacd1a7fe9020905992f2d9fc3cc492fc4ec3a988c5d5518dc32a4664701a0ac9bc8484085e35d556837eec95a52b591e0c6dce4117b0cc4546ec88e881b4d1be3716e34575d76b031cae070a52580f92b8e052f7b19bab62acd5fb706a92dc355593b3db574541afc661078fc7c4b30e0274885bb2ae4cf4093075d55644364a08ec8fb8d8cf3fead43e6b57b8c424e1356fabe6b0305ad73790730680a6b9f311869dd9c77829818bc0d36725de25b2c15965249efd9989b44132f85874b5e86c31bff3f9924ebda4307af2cb1c702e385d67c053a0816cacb068af16eb1c47be6306fc1888e5573f0ebc9c0205c7596296aa966781e8fb800228e85dd6a8222c01cb902e542a684adf04723821f86061e10524e9e5367cd7ffa30944b3dc17aa25ba26bf12c1f8e08c7754832178bf971decd7bc0657e7dac258c73624e6dd133a513dd31ebed41a049509a131df52d4cc0927803bd3637b888a9848aba14c1d9e73b5d176c581cf09177e68f513519303dad0ffb6902416ecd28f5b030289721a4acf78763ed8f5666203141d02a36b3f24a9cdecc80e050aaaca47e54ed4bd1b216d2aa5a470dee6d6744ef37f0c0e2f946e487ac3909ce568dfacc9830772b0d415e4280ec91edbc014072975f30f6cc1edb2515d41c65163bdd4e756f615d9c41f44a28308300ab8154e6026727f035e1a9535953611ff36fc458007d197d1dbc0c98940e2e5e59e244dae7b071816743a94c8e50bab7ead41c364a4e9bbca4335f7439596537122e4c415f15be7e091287008006d0781d9de81f27ed4a7315bc455b2413c6191dcec60ab2536ff03b56985d71c1a468692ccae936f382605941d77254221ec0cca8ceacb2608ecaba37a83b9bc03e568e5cfd2d93831c207e2023469b40d9491e582eeb7423ef981d571fde1cbc35cf8dbb8860973c1eb2bd2064b33e27cb1c15977b0a3c3970820411157705b9aa7b8158368ac46d56a5f2bc30bd6cd331b53b0ced4d1c435b1c971261189644845b56f3970c35825d3c6e61a50dbb4cc3268cbadd9aa262538cc320fc70fec1fb83c88f5830b80357c10437b78fd173596ffd3e870b2d49a7f0e9bc29680e8c2f17b1ab12880b659f1d0adfe18687f79739ed4546a356829142f97cd750c1326d91511058be60d88c99376d77b04f7d3a273b1198c9a96dc8482baa1c8daee0f82df7ab7154c30f01071b05a42aeac0c7c95aed3cb496b0ad6be807c41e2317deef2c280ab76d80c46a19d5f223acf4caf7bfdf0594ec186522c8b89a444fdb771aae86f14f2d09b9c3193a8023e42ae47bd93bc26e7ac897cf0e3ecd6e182acd6e56b977c11052fd2c54ff4f790ef63f3bcfc1226302aec6e510520dbbabf859410b86cefb6e343f4dd26a321cdb0f37364c2d329308f9650958863155f09e1bb69da37b37cc0cd280ae5b4230e2d4e9fe059aaee5b224a846924506d5a74a2beddc21c7dee5fbe741400d9cf0a3dde0c1f22d33fc0d39b96a1f009e9abd49339c186d2e03f4eae0e06283af975a4b60a31d3e5d7800dcfe651744478ed93522f0ef6bb89bd57851b293a71121cff005807555257e92713c1474c24b7a3c8774d132ee9a34fc3617a28b2864c2f570ad389b3d72dacff3ba2305043294ed379183307ec861c11d886e698ba856de40c4cdcf9a7ce5e19be6440deeb1d41207080ee4103a692ff1b476ebba6a69f4c306d7ac7f7936b2a4d702c393f952cc283a3b1be15c65c7466270f505969fa688e272372eff06540128e21e50a3bafa7218faf77b805449945840a0c70a8d8da1ddc53d3cd70ec9ece2fc38ef215bc7ec9433f0f2771b75b5e42c1e9c07592d8e2589e876607afc03235e17f6677f3532acc60e4e98c3218c10fc03f8d0981f1aa12e8f2769e003ca4f06bedec82e568ad3ffcff175e3c6189a901a9e43e2c7cd36f9d37ad9cdde5f4d75bae3e73bfb4e6f155a99d6b4621a8f19d7743c82f9edbd613d8e71768cfcf8d51a96daecea5ecddec2f8e6c06555ab86ca6ed1b060150a7f7b6ad68f3945ee60e56911f6246b1bcbe6c2209dd36327c21231488293a5061e3e2c18ae0b33503d2b9201802389a62d0056250628ed28e1b5b909174cd79ea7ee1a56122cb33f4d89d98d1a06cd02d9fdb0ccbd6bd419a8ee1661bd85da81e4421bd3ba40fcf804e24436d7340d927ecf7ac6b27c1c32a5f05ffe136d933fae164addb7b357ad531de7cf5927b69d1278216009e5f0d55c7ea5468f126fa2c8bd74f61d826249a5d06a4da7868357321aa507f9b984e9be5df79ec6a8fcacd1baea869fbedfeea32f2a424b583c90362f86597df0421060a4e1a889b283501e568b9ecba5cfeb49513a9618f9dba642152e35daf9725d297b398e6abc3e7d18f47e23cb1d06d31d2474b8935cad1bb5fdfb0efdb4ed2d55e80c368c1e05acacb04b2f0600a4994e2773433949447864d786a19542c23258a89bafac9895b745c3f53706db3b240a1e666dea4713b029a27e67c002b314771b09ef57cc5ff05119c9ed0e03ef59a953bbee95fea0f5060518c26b383274aab672644b8c8ab743686146ec32ae4c205a143bd5c2f47e4d959c67c9f5a7aad4423dcfa63ddb802b22a76061d817f995f409c5669b7d971157f066f1c822ae9e65fa45fba6369bbac6255f407c20874cd3150ce24c3f382e0d3d4cdba7dac1dd4adcb78c4f7678c40b34102206227f8ac158e1c41ae21e693b77ae80c04efe647f37769d1b3d03fa406ac2aa1cb0e4ba0ab52a46a0decc55d98808673665da87844295cb77f4210eedb4d9c4424cae96b79791da54962c59b31263cb64e7f133d5b0a41f894c5ddadc5eacded89fed1e855e86c21014bb89859c0b03f4175ce43dc3403103c0c11431683102a115b6c46aed8930249c099ad4a1a5a52249dbe92ab3fdfa77b9adaee6fbc45120ef872a34e115c72bfbada728a816f8b83c7e53b8abcc0a728f20859995095f27174b378cd33b462d8cbd94b63d2ffa761701d7d1dff6ff53f4eaf4df726bd0b1bba57038a3b87ae0c31f0f1007e3d0860a6b740a9e6e6e9db96bbe1d9395133b5d38f6b0849a19a83ffe0c789d26bc36bbbf5152b873ce010887e7939e1355cb800cde4e7f53433acd26ac62417c1fdc5b16de36fe1d8e1c3d5ddb461278e9203e84cc8571c7f8b4e5be4e6bd19d925bf18476df4717fbd0f99af481b465a6478ee2e8c4cdef19a4dd11209c5a2925e3e09239971bcd28caef1021d79ef1e069bbaceebbbf10038ec91295d56e6d47b0b16a8b945c7328bd63576a1eb03f668add698b143e5270689ea0e099b7a79b0662252025dcee99ddb9efa365a61af54a1b71120ca86b34db4cbc8cdae8b818158868d6a742d155a02b1077ed88f34c142b2be2d78117e4c03587b1da7c1c5d298abf1534438212d372f7c77bf08510b2c306fcfa7b873e11c978245b2c8c0e87f9345dcdeeefd719c64daab9cd0cb8752ae1360a10b60c686c7109785142df3c5df4885218c70dedd8f58d7513f37dc804ca135e4f7c6b2ebd2f18edaa63ec3afdeaa3c052e9b5e14944ae28713a121a58a6c4f03c2504bb01bddfaca0694070c8c67c7b1dea3bc09c530cfba9f319cdf5c6153f6f1fb19bbe90a400d288a67c7312fc2b55629c7a609336a8d414155aa7bbf4c88c89523c91b0afdcc4ee40e1065afb1926d66c0e92f3e33fd13d8ef440974af5cab85adc4a6cfe24efdbdee5d654e7759d31153ecc70e1061d22bf51dcf295de74d93f9086abcf30f755f3d6a46cebc459aac42a7bdbdcce65bfcbd35955528c3480423405330d06f4ec285c61c0d18ac41ffd5ac677ebc67dd645fd73df9056d414fdd49efa71e98e5ba35e79d1951c11aaf1a4bac2d9e2f0d966f8e7fc897130cffa7d910c4dec006dcc9d63c1bc8806afe23e531788e9e15d0539a11941aef5b7793854b8cc12c276a583daf0785d31ba56a7e852ad96aacd6c28b2ca83d588c52c5b711843afe6a109ab8cbf95e18eac904b082ddc52949d7c7dae77846b8ada6ec5e5ae98ac2c613213f9dd17f1f3c3a59e3485cfc05f18fe2d3050a97db5600e23cc5dd120cfc6e234d3937658cbc32be8d823f11007528d73426cb576bbdf776d00de70e1b8f7d4bee4ec4169e82c2747e19120502d5d974eaf091d02bf93ea6ca35592981b34f2ea148b3739432f107c1240fb0898fd82b211e090b1cc685a0b624ba7cbfc123bc016e2d99610aa4f393db832996960a935b6f3232697623aabb3cfea8d42c514bc8457e99ec1c1fb945e063f198ed55017b8ee9ad3002b30f4d8085fc9cd1253000596ff13eacdac86214d000b7116da667a74718ba3feafca8e6114134efc27ea144b715b0d93fe2d9f97790303855ef1b659eb0f23fd75248e9b23f4e538bad4dfe24987c8d3b7623b1354a2e9ada49940fc260cfe790bcb848f0b3d1d8bab650aac74b777693904dbd7f9287220b9327b3a47bfa0d5d6f9fc7746e790f16a6ecbf7a4c083ad79baa93fd05ff1b94081a44a8a2b788b8055f76eb63339787c2ed3d417d2306dd73de7273bd7a6ef4d2fbcfae750384e9550440d872e2e44d75554f4621e1a3756bfa0c72a413e6c70543c22eb28ea72e92dbda04318f8db9aeeb32d4860e0ccfc058c66046a8ea79b837cdc42ef637f7a4d0532da3810b9390f64e4d71e49ca08f07256d0ad03bf250213f52c32f87a49626e459a523cb64bc392a81023dda7cceef18cfb683ff7f47616d10fff14486964536f6db20b87f763df763b714d4c1edc82aa285b51a7ffe4d06c66b56982dc53141285033e8acd9ab8519f847bccd702518b478006968922783e316bf112ebd63a445cd88b7aa0ac3901df63e0064423e5bf58b8dd562e97d2ddaaaf306bcd6ddf4ba530e7b61233d7b5f926ee2a963e0d67806dc289351dc89e3f0445e761e8ccecd7a991dafbf4da20b77f82fbde417b0158b575e5d8b51e313b0664d06f9cd75aeb3524a143f9e950d0b2c3bf93f2095240a6114bf4b228e10c6d350d8aa9ef138ba0c10b5e4482a43c9abe56fc78036c5bf175aef838ff071e258c539264dd57faff0dcb41c7ff0ba36a7cca65c01570faafd0a145e74edca617e5393ac479331173b4f682cb57733ae2bc362aa05fdef3b8d7e0560de808e54782687bcd9b625387a5ea11648bb377bbe92628bde2e76a0d509d4eadb7dcb6ce73f097c89331554fe650af1f1fa008afee54289af5a6ee266c02efb7ae1945b40dbb805e5ddebe9425a561e891b135556284378d59503acbf33aacae375a3607dd1f81e98d68a44739e46c7a3cd6827a04d48fbad772e4d0c6b80b3bf39dae56d43e7c9e490e20be7ce013fc38ba344177dca6d3792cc9f95a7e0f8cdf1cadc777b41cee885cf98f7631f574d7bf38c19991bf302cdbce892f1fabbaedcea250378ca5b1b891d676c8bbf0e9131b5c58bffe9659661e8885247f5a544e88c50ea597c331273168f6018b718bf458cb672df7113517a4197fcbbecbe99c4c7e67ddd9171d09c04df5b641f7251b58def0cac3577649e1717255108ffc6a6c2c478a96cb1ca205384fbeedda5691202bf9f670248ff361035dc4053eba472a083636c8b7205299013b7bf297d8edcf9084c76415625f5cce28f1f9f7da66565edf4a9df395cd1de26987ca62de8fc9595a5bfcc310c36726d750ce87c660ae0a30c64c98374040479fcde2f6c992b4d833eb801bcdefc1c59e2d5cd4bbc383317daa71201eaf9a08e81340a61e2c16cc12b7fecec50ca968b66851b689523b0c18ffa28857b9b232b02ac753c6f68d5fb3eeac42d6ca9a505ed3c03b8e2f29bbed4eda455efacccc5158f8cddba61c3a83fb7dc042082b438e6ea15807d09c30dbacf2762e258074751c8c55f02cf8961e834ee1b793f0e6e366cb625939c21701e1f14b57d92ba0b70b71333aa700febf937a17558fc25f6ae3321bea6b4f6405937933adf11081425d8794a45a7745c10f900a9291494a8aa97d330265356cc6162c39bc0b3636336b5c5a46138b81e1a79e2708c0214ae8714f324ac09a761041ab809d734bdabfec16ee3fbf7a512c7ab59b802728afbcf7420e44b213296fb1894fff29bbeb36407a01c90a4a8e983045dfe15bb8f40680717934de577763aee9ecab8a35cb886dd04782fc99535f496f43027f70493ce9e6e9807be4fe2b6705a6255d3386233ed5f58c19da5145d2101b3cb75c93261caa3e85a8657831a015c3d1688d3da7bf062907e9d1809c3928ffda11b301ebe8eb8953d34029e51afd36a7b3fc5a32f7ef687535391b728254b6b13f7dcebca329a22f70127f80091c327572f1d5e9981175044fbaa1bc2078957610869f6d88ebbec75bb9b59432e32f08d74cdcbcc4362bbe264a86cdf28c115431868e34381c9a5dfbf7138f75066a23eff553b3a79a2aaa4fd496389b5c2bec9d90cbe373fe76084f7101fbcb5b97469eb14b7cd2e9e532b53bc932af9dac01e294253d0a8d5625e63d5b9d70c0bdf4f268e3b695d6859cdaf09e816b37266a86d3b5f7fa7c2bec296d553e3df25169fdd3fb1fa821421994db90dfbcd8b121b88ee5af47832d3f33524419126cfd075427432aefb1ba7bb5c22a57d49f70d9f4e23dae4fd9e5a3d1a2d1e8b03572a29a9050dff44250faace91c45b12f65ac69a52524bf14a30961329be6ccdfc890e323e43a01c1a194dd4e5fdce6fb103642bd5172708375fa8b583221e247beb478c83bc901737656f29ccaf6f98195fd332e0dfff7a13b7b8e7ddebed0b0df3c31b668959e787596de8ac076049ef5ea36320804da7f5ea60c1fc7249f2078025010e786fcb7b2caf89e3fedd24aca42a502833e57baa7f308ec45104881680022ad3211833539855497aae88077df23436d072fd9bb9e9f5a0934025765d92dc72676357ac1034b776953c13e5e7ef6afb10e2260db5b5704a76a29e8dec24a9764bb3fb3311aa03752eaae2ffa1b4130859afb46406525cee66a0b28f69fc36291474a1fcdcba79a43725a64b5a303549ebe9859bfcccefbbb5e93d76e9808667020987c0b7371ea2b0755ce4b45ab2ad7bb755216fd5f8be6c37964b4b27867f0526bf4ea5eed01b47d40379f5e5549e844bfb7808696116460e7d15f69aee5b86863b0c717e5f89c364a36edd24be3b7bc32aa7ff7c16370283befac02908833d1725eec3230d4cf30a42a9b10a76e34962660cd7e5667f97bc3b7359b070385df151a230284ea81dc359ef623bd515f80a80db22fa7b7d2698887b467103c2e3a387c75064791723c71a73b8b7ffef2c3f77a073160731a56ca251ea9484e11a2f134d43b8f4a1d93ec63f58c8928e4e393e5f38afedc1dc3ba2628099d37558dd3aff7d4a686a95db1749e2a1f75353b89edfb1f2494ff82e2cf2531f1d0c012fc5f01201801ca4181487bd6e3101e3ef4fe8d1eaa95ae5e8f5f6cee9390460b64342319d9dd98d0e861e717aacdec84045c4f27c11bbc8cdde83da90c7f47011542e4adff7f91f5f2eb04aa3594bfe2094ab2581cad6156a9f0a8b2106cd403a1537702c81793d5e790d2d060187f85f06a0f3b60b701941b47bddf1e70b36a3994488595a78bcfba5398e784216c94633a533091bfe7fb7f9bfc0f1440f215b9a710662818430a8cec7aee6f3b6dd67cf64f71743cd2c9b56b8e9a935b7db34a63304ea1d99a245c09d2d621fe89cc7b8cf772c132714b56de87f9ece84ce9f45d922a565006acee4cfeb05c6279b82f5bff8c76479dc5e3cead931cb4f195da9579f6cb86c640e24ad24d874e57b44cef030d0bd49dc351e9e3be6c75dfd70ce183c00e56a3bb11470c39c6199e119a8f10ac0563b99cb7cdb92a18b5c37876f9cfe5eabb58b22c0c7b9db5c711e53164c4ae1bd67ef3b02e522d1a65f49ff0ddd1c6e20bfb95b209408ab65211bb0eab662c707609af9b3db7d6b10434d4bc545406519d11f451d3543994ad5c1bd23475c8d3996d274f37b846ee78dff9615cea2c843939a59adc71a68543dec7875559d867900d0b54488f023cd9ad4151257cac59b5d6a917e5bab5ce3467c9918310211c9e9a26ac9c03a8f2405e4c5c56bf1e995002c392cafb1dcfb71ccf8f48310a797df5bb51b0e2fe5d7d64161041d4334142f6cf40cfbf34efe4f3bc71a83b5ba954e967c7f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
