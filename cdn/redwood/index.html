<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15f5da007bec9e5954c9a265ffd5153fe2a7c501c812700013fc9a954fcd81f441b00342f661a0b82f2a0d5d920d8ecfd54a43cfd325168c822484a04d4f707e9dafefeee1ec1d751862b1021cd5619a8fd09a4819b2ad2e93e6754208e1c6971c03359e700aafd5d3cfd2b0fd9b8b1d88fd856af8cafd25b1215f075823218cd10aefcda7d6d23326ce42ffaeb83e705a046e54b66e68a1b2f213285d61572b44dcc841dda3b2060a182ee55634ce2d79a4cc729d432442f5154dbba062438ad6cfd6bb411c55c11cd0db2ebe087d8b7c0ac195c933112de56f2b76dec0ff54f2130d24f147d0631b69848295f6b61687b97e4745451c2f09f59742399300d38f42ffb155722154d19fccbf1476a7543ea8741635331790a7c554bbe8567641bc46d5a80ebf2cc9a9f561b84c58f4d5253626fd8db60baac1d2b26debbd059394f42db07b7d54509b6157dbc3177a66df62235bfad2ab0b6f318177c186928db4a1935b823ddecd990c0ec86a059fae4753fc8f9ffc3a1c06bf4efe8bf9bd577cf8628079f13bce93a422456db90cff5145b0b742f239d360a66227cfcd268f16481ba0a6a7580db5d61aeb49a9852dac87ac6029d4c13734ba3cac5bd6ed3acab84a08974285a280ded1b6205dc592a140c8b6e0294ad42197d208ab599ec240b57d83740a909c5795d6af4deb844a3cb59d3ee16f55d35dc4539fcf240cb0c1aa45317c0654c8685d47829effc7c95a360b6bbeb2da2b053868f6091f64187a526463d5bc212919b42c66e039ec3d4e617ae9e6437158e1e29698b1db998f9a592c0c51e5d6f149cab83f9fef97e07dfa05feb6366a5909f6bc6419d73c7751feef1c500b261191f9010d6c8ed19c2dbc5e736ba621b5c8b7b331f0ebbbbffa60c2f1835e7a318bf4553f4879236545b4ca9365129ba4c4bf703d122a11d9957d36d10d1d2b7fc06e189fd001ce2ac6aebe57a298778d2bf18c89d9314acd67f8e9a13c95b6d5b7f59d02543e03178cee4538b98cf483333fcc1bfb981f5fb950c3f5942ad8534047e750135ddd9a5b335307a941f792f2aa238cab8f65c7a74e60f447d7c583610a0bb7b7f6585fbe24bede2fdd78ef75b8002d4280ae2f5a912a46ae77d8db4002e57346349ba747777427972ccd1bb4481fc461710eb8dcc656cc96cd44a6c53ee42426745630e5f6d4c24cf1ff3eddae76919b8f1e7bd0764a35a1b5f35f651d04554ba981424dcc9af17ec07ed9d05d7f14843242f2843565086b703bc7d5244b0bc9403a437df99f3d12ee5e409f2313957e5b20c2c5bb9481ee5f89cea2c05428c7d1df2e06ec4ffbb6f72df9fc808581a7ef9fffef6b86bcab58fced7ee08ac07073254781b8ab589aea33a87d047337ac4aa6cccad48e1504b946af8fcf2ae3b1e06896e677fe6797dc574e7c31ac1c100aa1e8517fdeb96e24019d7e13fd342f7e029e36883cd10b9650dd12074b0e3d5331182159be9ed66b5207d947b4ba10c4246df22284e865f6ffd856e32db798c620e8092a2cbe72b47825f0715fb5ec9325bae377fa1fa66a03fb12f0c2fc0547e1d4186178f145b3260bdac8b6b73d0487d48f7c3d09f63a55f95ce2ed3c80173a746e53a0e030db355e8b723bc1acbe78b4cf85f050d0bc80370f50797c2ee1598607be5e0bc1af4411245ce22a523f32e352d6edb74c0f2c9d599685cb6572c1077d43d39808a3219e0a03f775fcaadfd7476acf335ad61d6c1b21f9edb959da2988252ef7556002561c4ca414786a146115027e744ba3f297fedc3a7e5802757be1240fcdf48efc43cf74c662aac6b229b297612394f80ec24a71e226aeb719123211d8ee8b9f849b9c577aee5ce53c50954e36c3f1062131610ea77dc4e962d3ea94e35dd3c15d23b3e4e309f386b64c01a1b4adde7d4d65b2ebb35d27c912206e4e768deac8c36ceda96b38286e59ad69c8a168bd3c4ac31a080c49bfc1d33e174c13d802c228d9e6c8e6b41659b4099cd8638911615757c891b25c4a9ce61199693f83a2f2c47cd8222072ea75d662b714eb74786c5d5ba7ab7ec87b6569ae028d2945f665657a27ad454b4aeed6ff3de9eec82e865e291be8046123560770f8547c40a417035fbe2298dcd1ad0789f5f00edfb70c9cb6c7ca2052c84a8c8574a0382eec3c310b0d1358b8240ba9274163c40554ced8205d4eed0b009a5f856a50ea197639fc630e379ef08382998adecac3b332c6521c02d3fd7f2e1cbafae2339aa37ddb68ec729a8e4152a4e1944dea84da2dfb55391e2628235deb727a116beace1db40ad76281363c3617ba257dcd6d6d00d8d9a95e7272cafcf05a9fc06b21867085ecb422cd9152a626dbec5cac2ea6cc3100e27ddaa0c4618648b93e4760b5d1dc7fca333d972fd20e8584b1a800425148fddbbfcb9906f22ac3bea14672f01dcb6520256edfac2562d2db988cf874027d565792a26a7973346b10ad14cb5a85a6b13ce02a429c835f68dfa0027a5fab01987e40f9e8998d5cccfa255886d0ace5b1422f453f32ee7410182543eef61e5055ca3405a1a74eb594bbeadf00574969842a85f663e2996e1475e98b62e913754e1aa2c5d97bfb47d4d91349e6af9b3177be6b99b433f3a23202bf4d8e92699a6c3b2b86f9d6e83f748e6667ababcdc3b22ddb5c6cad50b9134dc02c6a3f55483c32ee96d8f632a355e0877b4c26bbe2ded5d363c2350d73437448577faab940e6ae75a0df7ef5bd80ec6c9f672df837ec9def5c6e89cc2818478c97ed3f0b1f211d2a24178f9bb6dc5cc7117459ac92906f2071a6f2d1e69f0c98f588cc19cc5276c65ddb7e21a949dc4f94d4f1f3c33dcd8ff7ca8b315c253bfb7a3a4d1ca0efab04ade45016b5824d6b7bd7447c2c6bcde7b56e8bd8cef5425a17c0584afec193e24c76e207edc1f998ec734108472bcd269f527b7852900237dc84e17817cf534dcecb39f0b40ec7ba80fd223cc63134bee153a1f5f33f15095add5027b0652c3bb64d344a06961672bc290df98a532d49f99d64e6c1b477c0e6186735c05d5228b6a1788d188e36a5f32e732ca7a8f040e69604c2829ad53f7cc678aa61e41af2859eb2427f112d1aa019340cbe47c63222d2dcc1c4edb551a000ce38a37c0dbed06beaf1e80c5b8eafb39e5f26804e2cb70994f14687b31a539a2856f80573b2cfe7e0be5aa976d8a8f55121140c5312ba1e56d8c7a66465614a7d87a1b77142b51ba23320f5e94369dc18c51c92f178c03f223394f4c02cdf106e37ba86fff48e7a1b475749b0235bc7b8e0697865953650287e278a623577b25e9c1779261548e6e1de03ba9f8aa715e9b5b8820ef56797605c4e724d4c139b5a1322d2d235bd3dc9befeccd232e46a241ec05667b0271a2ecb6d34743aa55580fdd201d16e78299a0c45df2fdb2d0fc985c2718eeffe51d45f6d02885bd7c658740b489ce39a0ca8cef2c455a110034c20db5377a186c3a71cd945b22ac4a1b3f79f2d23f6c7cab4648c250b7624835ef24beb95e7dfb6876b8e896afb54111ab38b693c71a69d73e3aa0f1658def3a026277587ca5dc82c7225a81ab4189b17b446e1d82ff922af8e6293c644f58ebb71aec0cc141866ea7c033f6d43df055d8eec6d36260fced3d5f8a4cc9327f30946f1241dd15388a6ce19492d342daa2a18348f5321d8b6ea4620818ea1565ae3562fddfbb37fc0bcbc618b7eb1979639ee919c22d02ca525c666f3cff19ddf08788df3f2025e8cdbf3a518b1a3357512580a4200b5381e51ee10ecded5cf58012a2fdd8031e89a9d41e193763ad587e615fb59b62c7cfd531338df19acc9beb7a05666932350c0a59a6452c0ea6bcb045b37da8a4425ae8005ced3993f9214f427f9d625fcbb39d4fbd5fbd50e6e9d3e7f66c0fba87087c25ff2624cb7245679aaf5cbc3c3642e9929a21397391c4ae5a1683a2b36e3d9639ce527c1c2e376848f39248d8a90e5abcb70fed8b9dea40e54b9ae83e14dd0278f95f93eddee9d65407a4e87e7cb0284f9715fa0ebcdb336136474ff9a88b5bcc203d5520c3827ce6d9493537004988c902cfbd0177f3116e912e50feef3c78f8c1d21466c93fa9e606e8efa72eacecb08c3ddb58d191f557e115da0901de143cc441d0320a257dc4d158b64d9a2b641a0ec89fe932b5e1484b19b7354d49ab6174bc9c24778f234b05499718c79cb58abde02f04c039d20fae34e4c33998c548e5a223f9e172e7de7266f9466f24a3cd9be4c1ad92e70f97d8d215c47f30e9f988503ece40d0853dee19fbdf304e6dc584223a27ea5925ec534c2df96fe5f0af56e02df84106add65850abb5a76a91dc3ed34bea55b83546badce76fb70a4745987ff6d76776096dcef60cfa2637a3a7ad30ab5cf3f26def9a7b4135c610540f206c0a2f5046b8a62850f4904217c7550a425eba4ffc878c79ed8de7b466f75448546dec0532213602744a5214fd5dc642e9b8ebfd9fe9f81c2edd12b802ce2f5af900987a914926f678772b1d3791505877737e999f01174cd72b906f205b970ae882d736f8a3cca47b37eeeb5130f1ab5112b868433f4006c1f173fc72464dc0de3bd8ed10d6f1b343f2e058855535775e4cd931275e4a36a3f56978d454cde1097bb3dfe2e4bf7048e464b2a700456e066ae4d349529d9724010cf9f39cdede6374b930a2144559d1648b106d77b7056bf0fae887d0503e20c63d50094810ff895fbcf850cdf7a35433391d17fb54448de4703d0bed8facdcb59a175b2c5e1a408f984e3a53518992500ec25978aed71a4ba1cf8db763384a5b97b7eb57955c0c504d4ba4588f1e534b0022ba3a18c4b124f72481516b0ff39d47eb7033229765d07ec94673ef726f0749f9b45c2455c82dee5a318b9a4de3e56802c016317d9cb930b807a1f20ac2697a0ff8b58ef1786e14953923012c7f446aa4a61cc4d7dd6f04c0d81c5383b8a5a186a1288640d124281ae8172ef7fe8def71003b8f3530cfc579cbac396f9250431df31614d0ca9f6067dadacd90d29463dcee72eaec38e6fc938ea1e26b6193f5b79080260a883e5ce25dba06fbdc9114591edecdc8e92a9f3570029f7097b31892dd21af3249933262ce74ea3485aacc837c0f228b44a0c8efe75df7ad2885187154a74918f18820db86d227c610715dec0c2ec50fec2d55ced963e33e9deb6cd4f22c1f0fd9737942a6c3563c927bfad9119decd5a04c5d3cf94f7c7ae1a78e7290e71712515ace726e0b731e5ea04aad7e1c16f50b182e63f94d13151c413dffceab32692cf6cc35de4342d1b8ab42dbe6a449d6a9a370d243f49bfea8fb2f1a546aed5bcf445ebf694be4667d44f2b9e09ed8c6fc2b61ae26a918cacb8b86754bfb4a0630f266657f336aa04e2059f6eb204179b8df6066e83086651ace5e35cbf7798df46e07472d0a4e24fed826fee179892d163a7a6f44f2d2e67060d28b3d9a9c9e4fcdd7ab6df2a4b61b502d5e39dece959a5f5001210a53faa88edb28b617c210a2b5bc6aac55e719cecc4fe4794d2a2dcb2c88b3d49be2c4cd57c7d41623e1274685404427ab2417914f98a2d76c8ebc76d767d39f09df2bf6f68b43c239f828c6d33850045c25f22b7fabb609d989200f3e2b9af9c24dd6ce230f90939c70f5764cd3237284958787f1d1bff902e69dc8524ae17200bcef19d73045757884b83c457058ae35c7c89787df130cd7b4df1b98257d5b31c26131cea97e6595b1d3a740e99a49910107dc0ff1750df440ae0adeee0f9368eed3f5270310902206ddca2b86e9deea9534bd918e0041d3573b541c5a49bfc5c300a5c1b24c821a318d0d777516d6a7aeb23e4d9a799866050888343c42cdb4e9e3ca47498370d8171130a11da4bb84238469032c166b4864b8bccc54eb7ecc4b359b11f669aac9208796f7c51b3508e399b9b25b67a177e716123beeca7de5a402aee23224a902a454697d4c2592c189bfd5d7bf01c8103b2699994796dfb7770b0399bb03ec36f821734013fcc0f8e2763aa7e4cfcbc4b0734df6735b09d1044e85e3b90540d085370f8d253729b529ca3251573af2f915dd567fee118a38ea8562f98601aab39cc5ca3a4496addeaf4d81362103c9f824fe0762ffb0cfc723aaf73e3b87f0b5fb718849030c9c6d76960e3451340d73aeeeddbadceff15117c4f0aa58469df0098dfceff9eb41b37fdfaa4ba969e73d04467068a3b04f75f5c4986cc062eacfa62182a688cd6c860dd8f956e075168a09eeeb09f640c6e296ed6e340a2f1c51f910bd6a1e9dc75a43eabacadb1157a5fe068d37256a6fbca5530a2d44de1a3f6abf32d2bb75469f4e574b91c68ca836b32a5222896f3ba862707f65ca8ca740320a463b32c25063b6b87fa4a28a33dbdd29ec1a5dacf93fd5421021bac2cfe154962bf18e5b1a171a38dc3611205f28c0004b117933b4bea24af3ba3eaf9153df128b2fad3720b7bbf46424664339719bbe43241f08ed0aa1b997dd4d21833664d5f5ff789de4c293e4b4562be1195b0bd16371ff2ad82c96c51c13726cf1d62f750c2b235ed1f292f69fac65b7added908977071db422f861c1fa0ba6dd17897d4a4062dca87d976aabff760c6b051ebe8d2777de9c274fb070e54a1b6469480d403cc1b30039ed13186023792fc6a546bec605113c27a1a648cfa5bbe782933e4cc7862f134a9cc0e0bfe30a13c7da7433850a56954075740cc2f2de953c27bc47805536fdf7990b7334b99a5a725bd15effbf5345e51c18120b2360cc7dc2cbd73199d822ef2a82f0760e23bc3050619b8163b5b680d3533ebdbf2576a8d81bd58935930414ab0f8a504c29bc8d4440d8d99499a4ac6fd48f37272419b4ba2f0a188dfbd1342b5c08940e029cbbadb1f89c3d04f6f35720a1b96c5633b71e73114598215c97b68ae1336743a7bbb830e7f37832d28156b274eabb7795618d14c3d819e0fa70b1536f01e380826c2fc31855738cf84a4b7ff15630fa3367f8d22a52758e89c93ba0226875bcc39e1d5eea48c08381c90fa547f5ccf0da527276085aa8b7eef1e6f3197a50758a26063bd09a9ff664cf28d689472d2a31c417b9f7f3603316ef582b3b16036158158d5108c8905b6c6ab035c11e6750db887189c4955afab3019984721c26ee88a04b3d8fd8b9b44545f13c7fcdd8e29e28439f6bc6c1af9555b01d35cb19f9b42e370ec3c1784a89f9271e0ea9937559c3f25da9274b869e3c4f6e16c1b547190632acfb0dfdb1f98e65fc1d28ea4186447dcc19b28c786757a2700f8d132408e48b66d3a8c53945f7cc0a3fd118d1bbfefee1d43411b98170ba13e2b6fef1bf5d1aa70304686858a6fc49ed6f61ed91caa04d72636d11c457504174bcfd08743a65e20e2da66ac3cc4cb73ee340edd34c0f32e83dbbe71f1d33d8990660320f743b327ac7fd363597dc539543b6fb467653d8170dfa87a919a38f7352906c7900aed3c786bb588d41531b0a458e2006d82715c1c922fc77bd8795171aafd96586baacadf5a67c636a9c04a6ac0e31e79dcbe2115dd3ae599eec21ccad9023ba13f76801940ebf350f00f6b3d294d95394e4b62a1522f3837048b5b50131a2e64655b7e33db54686308e64309a01a9f7b10053831259fb24febcf6a70000dd58de564ac3f3d4dfb1097bf8e2a51ef6349908b29fd8eae4f6f4bac88ca6f54298edff1125c248071ce538f2b9d8210a640e4c1aa12014acc131c53a17343a2c9a0136a00723075717d71936b98c51b361640ba4a9b0265aebced4cbe07eaacd39e8f3d0702f3ef2d76e034758e08231873984a21810d29d570c9cbcb53b64ffc3c23a3561a041324dbeadbd5ed8d41ca8854b8fa765067940cddba9708398b471ea79c29e8d4b93eb60c5ab2d6c38384580962b09bac602e80ffa5cc0380a5eae70b26f5dd753ccc0a0b8067fb9e5d7ffd520d91a116f5c20d5c469e1a5126d697045685497d25d93126e399db595f23e7cfe5a510def8c4ddf5cb8589862d715ffc21e521cf758336c04e43edcac88cffbea225d420d20c2d7b57a5ddb52de583a8405f636cb223f43fb30ad9dcfa328576cd28c71ad40f61f7bb22808e9e8b83c24edd788ecdb849b5f7a30fa5b6176637f466481179648728e756ffeb64ef33eaeeb6384309a33ce81669d65064bde9dc8da063ca6ef8f1b6428380aa08972a0f8790c2bde63f3143adb872c90addc3a4278695745d84dec61c1554362aa6859d56a8aaa3b05bc4f8b6f8d6a4cd59c78e89a7e97b3c1dd5303ea1c381c9b2674c9ecb4a205bb8bbcc2879350e0dbb3ce0c7b0a30b12a8ab3ea05b1ac8e71e8fb0695b47184ee08c28f02335b389c8a83fb71a6e81ec875a1941bc4f61055438adcc0b0114bba807160793bd61518a864c4cded62117fa48bd54861dfbf5bc96c28f29e411120cda94b9430d181b43e05da034b9e02a73a605c4c56560c5d4084c07ad6b91ca016a2598ea364943ad8e4a7df63269377485536797588f1444e724ce72b5d8a93b7b607d38d447048278da39d93a8272ca56be30f137da1622fe9c2d1de45b3f01b54512323bc7a27e73d7391b7c75ba429f29da9b4293027ce2c5782b0a0101f607133cad234daac1d10febf299b319c8f52e49c813c6ab6e310a6b461b10ce906ff8718bb7995ee2dee2bb9892297ee58b5ce926bd286e61c42764faeafe49d7e0b88ad8622a62552fb169612cc32aa257b0ec284f8c16e1becec2993e650a5f81b684d7d6cc16172ae614536e77b97c54164e1c50bc7a14d2127f44f984a3c3664ae9415d9a3ecd524ca81a745889d096123432cc57e64281eb651245530a6a2e6f9ac47428f4ce6858a414d421b3570519943eadea20f08ab92acc45a07937c7015f91559fbc775fc55c94112021c0bad656513151abf62ea6428a085461a45112098fe819242fd34bec40de3724813d26da3fc3d6c9a6a19cc017080055a1261861fa5965eb47264df1882971b52357acd2e2254326a642919123e1f963358538cb2dc4a9d5ede3d2f945d78727412ac9ede730a989af1ee852ee6068e01736710f38de7bf5f29764cc6d57f7a520d340558c4db67c680fa8ce1bbc683ac135cb08c10bb04dcba0e3ac0103077b9f63d45ba661db525b1126b4c9765eb06b4e8354a1fbf2ac441a2d613e0dd1105c3ead17fee017538ae7eac768abbc8318b2c2e7e1364e713372c3ffaa252c318fecd49c3b5889c1f2ea0aec9a1b600b8c02ed08593fcd874d005ce1c6b7d77dd45b6fb0b011804348ab2dafb5f288305f0a87a37ded32fddfaaac04ccd2624bf78a469c129f02a6a617c767db3dbe0e2086edc55d513f81a3416410f024544a1f2f890f78a988497951042a7bced2e91ab9baafc87c05c46990827e9ef9ac37fff68d5d348941ae09687010f6435c7fa090f4bd347e712af0f4cdc719997974cac4c4cb57e3ba8af2b877b952ad2666f8c6826e17dee3b8b2f91078231075f974a1b892f58e8732240ff3ef478d9f7f90511413615dd3415df1e98f1e19fa81ab0020455c9d921a351c8c34c34fc047e4b13bb18e1560bb7839a385adf4db32952c93b671fc2c87b5ac4045f4328e4ddd62dfed3dfc2fc6b14e0426a6ce556ea070091f8024061fe57e2c6b93c10a99fe4388ede121d228313ffebc6b62688542da672ea5935ff5c9181ae2e1821b150a44a4b005b9421547e6cf1061f3ef4509107bebafb198973cb8d9ed70a15963ad8ec9cfc7bc358537bed6df8af15edc96e9bc2106d211fa821009028627fbd50192aff285dc83be0414dfdb1bbf1628e07865b622255d3c0ef5ff541849363a23385b6d5eafaaa011c6b8091be5b90dca7604b1cc0260cf70a58a643f54286d68d28ba248e2f61e0f5760f138c9affc56dee26920d68f36013b2cad479f75a0ceaf902d49cb53a99ba2136e496c573d3a67157013a3e024e5106a224aadf1c0918e3b4852c172dafb4cd219e19934080e428ee5f1b0ccd791c5339b441daf1169286c847fd9cc82a178eb4a5808bcc9568e34ec7e0927850bfd0054bbf54ce122bb308051a1acf25b3c6bc84ad3fc33a678428ace16f04435514335dfa3f31a47593bf966d442fb722b1c3fd85d32db75f41d28880d3ab47c9147ee4a53aa018be221db1072993eac5aebd5238e826b23d625a884a92f7011408f2e72e218b5643a11d094f15831584e02c935cc7090e4ad1879bb10f595bbf75b468b952194a979e6cc2576eefa630a76ad236dc5aa902009bc3cbfa946ec4a7a8eb3a15af64b36e613eaee6913c197889e0459f83f5c3054e76021324d60dcfa78db783d85f84cda775ef6122ad9c08f5d1a5f5b714ce5e3e733a19e91308d61c9f7c3f762bfb1b460b792f5b1462cb40865c1dc60210c86712f3f5966b873f84e2cdaac4baf38aff91d29a850ef7305d543b84d582e9e760da94b318cdff8b6cb27a4d7deab6d39e83850266128408cec4ec4470f9a22979db514e4ae2550100ed71b4db8b7f5a3d6df19a872247ce88de3b96fc1dd2e1eb38ad15be0fbda414b9041f0647395f29a76d5063aa3936746d928d02f22734fad2c3d8e0f417673ddc61c435818c1dd5db3d9f7a83a7b5f72782d857f07b663482901645d505a85f21fe4d7f41e31fa2b6baf2eaf20bd358640a885230ac877ed1763525f9d9c00b32634ab759d226ee0d58fd8bcaa8a1d9d4223f52b1520c73379b502c5efc6e19dc81265f7a057c027099ad6020d881163de6c3ab1dffd996a8239134dfebc7b3a4e48c40611a7d11934c1e0a165542c126922f1c08301353ecc6ac5155f0219aff6b6ac46eada8f00d67078b4ba920a546c46295e57a1ec4108b5484553cf1af3671ea01b96beb54ba69b92697d36df7e8f0759ceb3a9ab691389b01840dddb3a189439c1104f93514760b3c0372574f63ffa3f69efe0084dbf67c7eeb345ebb2ddea013765b4215149fd1593af335f2cf523db8622f5c6dcc4fa09fd8712798c9d11399f59c83b10273053db37f16797daeaaf25ccabebabdda3aae8c9f48fb41047a889cbbb867311a9a8a0d64dc284548f24b5cb9ba1b121dc7f856d56c24527a475fe546fe7c47f852686aa14b20bb945310fab0f69a3b1467e1579291ecd341504972e79c7f453a44444227093e55f3989916d0e3a5f9dfb57ee12f11c7f7d70d145c03c97c2cfa764aea1363a4fbcc29c4dd47b34979c7a190dcd4d0172567d5531e4fcb893cc9a6b1b1094db7be89962d9273d38e7d6764224a492c92e8cf9a5653073d80255d7038903bab8861d47b701102d75ab4462dd1917977bcdd98e01d927d265799c449980c9910c0515cbc8659e1fd4afa504f7d4b6525deda14f5a6ca6cdaa562132ebef8d6da7d56d98627c0b4f90d1feb5937ad87a39f6af762d4080867e5e2e9140681ecf9e0afccfcd55ffefec5efbd033c156a77d9e4a2e1ee38ef610dd945fca30646d3abaa2fd4d355780da8b10aedc9b38e387ef50f21b25d886bd377629e57ab02126c82b0dbfbd0f21b27cdda30fd600a38f6548783a70e6b52fe7a760f7f5492422b7b7df5421dad09b45d2c090830e8178fee40fad61b5f9da6eb18431bf558bd55eeca2f2e12a03632d16209f7b6178c5c4890459d42b02e0ac586fbaf008aa482a2b3c5b7d8932775942aa00cea5c5781579b6bcc3c2b29e47db9fc307fc5d18be451ee9ff83528c52beec64645c3de96d9bb6c495aaea66f84b5b608dcb09084f59dc2dfcd489bd8daba870bdf2619daa7bd8695d938619cd09878b51f7353d8794cd218edff157db214b23ad8f90973331097e716ae6a50b3ddc47e82faa09dde044f5424cd7d9000538933a06051508dc251f8a98998cdf549e89fd1565ba2ce881265d93a5cbd936c20c0cc648e8cb13a05ad71097df93a63b00fb5cf795282db15fc1aad5cd3807c74431cb04c03247c43e9d109cc4a6bdaf194c497ebb14803b9dba127067bfd5849982ebb19aca102121626c22047038e41b5c8e9fccd2ab4498f256afac12d994df586d0592dcf8b235b5d224a8be342a9d9bbd3fbd34ac2c5aaca4738f97c5fb40f7d03e02cb497bcded825a2ba09d354401d9197bfcbec90321d249aadf6376899694230cb95ae27aa8720f526a512f2d82c5ef921948e8dbf68673861bb0faa94f9e13e2956e4b97ac25e1ec1b2a55849d5f85c31b942802c54277c5936514fd3e054d5822072d8627cbe5ddd9dd0ec8bb0a850b3ebd7ae58a9b1addf02e462d93e97e238d6c200666c2dd9f1eb4a175faddcb8bfd1bf41b0a0a830ebe8427a473dfd7aa08a275227e10b363e476d0af0e927b1d0ce5fe53677abf82f0feecc051f79631e69e93ba1d32194e1f9f1ded883f342b7216dcb926e723017bd22e738ba4bee32777eae8f8701525f62015f72907e0b0d303415cb10cd4d2959bdaaaccb780393869cc79ecf9f0ee20a454eeb40b6838e6ae0a78af8870d0040f7b84818fbddd01e88c49217e6827896687df8fed029a28de333ecb7b694b904ecc5e848714c682a539f74033cb23a5f00801dda774b6eae88f888f5ac38a107e1a85eadd48c48505e7887829fd6e4f44430751a24223af27cc30d1fd40c57908ca0d6d5b3220c6ed62614c236d93dd31e6932503961fa8df72bbb2df1d1c8231e9a68c54a30dc37f041a5cd4d3d4d6bde5e8b8618584495df4543d973cf99c3c97c2001be46dc34b65454c9c16b47d23c40a47f9fcffa9b1b7935f10641f809a9e2045b420504c1ccd6a0da3e38bccafa036c1bf589d568aaaf92d8b00be53488006b1f7a4a1499a60a65ff373b9abc8dc7e469368a9b680bd975ddce3aa4e12318d604506f4362681993af35f4efbe2d763ba47d1801a7742a1cc85568b142503933f14e6ef09f5c4b6695b283bb4d80e86c004988fc3f2a8d5334c4f82851859183c171b61e7d804f3f0727f6dc5d0213f1f07a1bddd837712411751f6a3bf3ae9b10d6a6eaf2aafc8eabe23f487c1fa9da32efb8c8276d03e7f90778d694c410fb5e2d2aa6739311c4e9ad0e9c68aa66754e7ee0732f2741f087b35fae3dfa31db8f04b6e112801cb59fea64ee93357bdd8621653c94031307f98e4d226ccc28e25ffb04261f97e52c62c7b6187e650eb565785f96c1e2e483e43b93fd2b534ef6c8cd00c8907ed6ec5681914fad9be9ce249b365b4401e83270a6d0bc99dba389d28586395f59bf21635037157bc4cb9d98a7c7782a255c45d35fb7379b2e9f7091ae6faa3fb38bdc554c44d7cab284837c91752b46a4d15edb120f163591ef9f43290231b96535d20ffb92a124eaef0de9ca9174d86642232cfb39ecc8b00eb9da340fd9b35fc60a6a0680fb916aa9c8ecd06a000ac4e99c5b428d2f90a58c6fbc5ece4ea360a89b6db624aa7452f0117b4cfe9dcac5c1e45db87e6844b003e1bd12125296b21ced88dddb9aa6a51aafe3e5b16c7d5e8c31647811a0a9ab0ea8eab21a285a896180645acf35fc98fc467217e3ef759d2dc8f15eda948b0e44c0b1eeef02a5d943a05bb2abb819ed41c62e76400fc57fe50892935938b1ee2ca7390df9ad5a4dc08963f6a58c1728ec336a8d5fd146ad1223a2e2b4a1cdd85c906ee41d68409b5e9bb89c665c7340a847ae2d6783d5ff8c613db99450adbc4fd841a457f7dfca072d64838fb8c896d1926827e714c61c1ee59524f60cd8d089fd0bc63eefeae85bb0c0ecd0ccb04dac76e5a4c9b78a34924a3b9cc39598b3c41273dab09f4d39b7b75f73831cc311d4a64cbeb439576db6285f18d0701d0c98ff3e7c76281685c0aff3df45dba8fc8af41c666c342d324fc0bdd17e44ab4d6f29a9ea82c442fef82b06acc0d0cb2553b8beefb238b5b1d8525015d092bb2ffc1be0c7d99cd22e2403ee3207907594878f15b8c4ecc0a1a08127a1081aecacee0df8ce76ec2fab21bd8a189434a67cd413539584d25e2435e6d51c763509761047bdbb3ba1845e8c18f1236514c07aed2d4db4fcfccc04636d460744bcc6be54841d1e26b03fc1d945f6fe0e7116303cc0af35fd743945fa402e15d3b9957952bae87b5a7a62212dc10e501353d6e2edd96cf3d193706b3ee2f3a5ec828c8e363d7d6579ad3a44ee317e6aaa4d71ab0e2205be54c98a12d532de57d0c2092037dad393afc481c8ba81c6e25e70206bbd4e7191719e6b2169320e6ce4ac3d9b038ebf19326ad027b90693a128d03c332b570c0c7cc3c4fda7978b8a8cf536eafea79caf0d098ba0867e5552e0fd90038906ddcffc94e9d3f44c0c2c14d9397fe51bf140ff9b0d4f173f09a9e8be168aee2334087e52d15a2eb3188aa96394cf31556edf37f159479353a34c19a8516594dbd81b47af952636e1a3828174a3fc9040f4c3081dd1c26ec45b6de1b2b437579e822ae80c7a2922cc5afb6daa32241d002664e5193f5e97c802e186c0a6cad4ee0bef136bdcc6eafee0f19f59bb9dfd20221139b67d45516d84f844ea2133a4bfa419eaa8fb411222712524a32def7ceeba71695988ea4c1767fa6fd960057dd8ece18a27f761dc0e67f0cd40215d06a33c93d3cd53fad8b8ee4e362f9e5a71f34ad434ce1bcf862dbbb7fa31530d45853df9bd0e3bd1ca374fa693a19aaaf5b0f4e09638c29c1f488d01844507bbc4b06ea44b53d22dfe64344856190c9c2e163c7d9ab4ac3728b9566b3da9fd62bd1500f0107694d59e678dfb0d235bd01aece4a9c735142dc1f5257ba7faaf67d69fb79487a469754642da586acbca47f1a276228cf506cb9cf535c4431ad3b47b662e2506dc53eb2a7d01db650a3acf47f62416428a1fbef59d2792cfadcd90beb02144a81e8a34b34052b9403b98765f66441d789ca78f77a278094077f0797fa168a6ce8a29d2877ffc0f664dfe499fca222fa8b05688ac9c05a5c442f2b9d35834f3289e5cbfa736e6420452a29581c0b72a18fb72d20d201b38484c569c8ccded34cb142c62112a2e5f198cb48578b017036bfb9de447433e08b7bf579e08fabb3f7da255ad8c04f8d95d03b2f60a98ea0515a91c8287e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
