<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb637aabe4086c83bffb24ab1c91099925373280af22cd93dcc17d68e7fa6bb4e4521be4bf61441dea68354e9c093a84c1c88d95867d3a049a687e4cbb086d260685e8d8cfcd2aa66343063a618a4d015df80287053ea9062a15e65a465ce3cdde46d2aa882eb241e65bb25e108a07704a0ba06269981a04083de1ac2680a0c48af9f0797326475b4301f1a521ff2aa16e9feea502fb3bdbfbd7ea96e2b63ade9799261026d2881d48b22ccc6a0bfcf1adb681ca2b6967c247d49d3bd9a368b675435c15d89682ef889cb4e3a4acf9aea6ffbc66199b9d01cc6b24c4120f369f748e9c07535b2e629e84b8f09312feee018d7180f14eca4a3490f6b9c15bf131e7576f94e82c84ee0c9e551f1958847ddd927e3c40cc2b848249903175bb8a8afdbcb216724eeaa0e52d2576cf1b3529219d2850302422f07f0bb5ec4f6c3daf57ba3903828fc4199201d2d3cd489c4c0a9167279503bf88e55d9a036a210a2425213b4128637f0719ac0f7dbf4f2916887346d8816ad6dca48e3bea2ba6fd795c4889419dc181286d356b497df8fda4848cbebc63f13343c99f6021da9b50e3c0717a713fd9050e4790c94c311d344e8bc47a639ad754a3440077848a44027c43501bba25cf242b26ac92463e5cff4ba69107c5618fbb758cb507a81e7687f1477fbb468f51af903835532bccbd9be90f33b6b5fc98548849bd2fcc301291f38b7921642167e0ab7a3d7e88b1b9878d9cc1104fe5bfcdc012824fe128f409f14847be286c4109a46c86bb0a0e09aa58b827765d0895781352880715f3412766f98636fe4024e314e9ca46df3c2e58f2b43f7672e9af5bd2a7fc240e7b90f661b3e0cb2f9b3a054c3101d93963d13e86b97fd5a316bb944936343c48938113bb41cb540c3e00ce16ad39889039b5f98154f8b00218567d6e8bae250082db31c8be0b21ee2e5fa2f377a55655f49b7bbefdfe899e5d023942ca90740c44717f7a1b1a845ce5c6286e20c82c13638d2f84adf63c74828aa5aa1fc14bdc533124d6be2b236699974ec76eba9193b08c6b74eb8d29845f7710f2d40b65d6651303ff70d459bb4260eea0694b3e5208374eda6c2b1e42d020c9d6e92dac6de9ea97691cf473b397f3c8aa3559bdd7d3d21d1664c7512a1b9e7cb7d7ce521eca84985b7db2326f96a101acc5a83c0ef12e0443ccb6a8bedade214d54913da0b07abde6bfde913a212728a7d0d1fa74406a22b002ba380d9209475adda777e7d59a4aaa5b560cba7a1690863257ac109e374fe0d7e339444544e67614c801af6bb929d67fd7929084a153344f2bdb58dadcf660d8043f1464af955b58ec9bab3114cf482afa9b0b222756df35221fd9b87c5aa16303bff41aaf726e307757aab04458d26b551b45f259a507b18c0277c75757228efc1534f8741b117776247638689bc02549b00a1b7c09d26a62ca49b340f093702fa7a62031322df813c2a1ed34ad474752c8114fb9c3b5b8772f99128dda0655bc51219f3680830284c3401d4100602750f14478e49948c070d1128e47c5845774b4ecbf78d5711b4b1793c4b846270fad76d563ab1823be5b35b4a7d693db63f0fe2d235ee015a8165476bb9955ef3635d894cede6beaee7adad55ccb0a912b81692de7660a153782c74b47d1a4494e5ba491012ddf76c70c2f10619d46dd61814b5294b1633008d76f36c5804d15701e2d586d780c0a9d51d8e053de3a58264dbfcedb537a937e0dca8abc3810adf078c2ec34bd70bcdaa84ed07bf251dd98d3919ae97e59314ece8538a30f2b26fab82fcfeaa93777fb965ab2dfa6c0fbd9cb91716483eb9c71af78ed4105abe494d6910fa733981d94f701e29c88acb949a88f9ad773cdab2c4e0b03ab9d1cd094dcdd8b920de06a88d892a3ce302ddf47035b0a16b7bf289cac85f48757de5857530d208d28ebe26f47a60d08dc5370ebfeb6305206aa92c8faec855741434c221ad3e12c515a06cdcf40a37211ec4db6dc0c9aa5a342e18d0aadcfbde3b1c915c84762a4d14920ae71e5b6e62c2bfe5defe016a5871a1e40c241191dc9d41b5b0695dbbbb0587b435bd8eef0526d445b5eb25e173f51640544d103d75a0bfd53432923a3b244dbc89684b5736ab15c69d73094e649c7bd3e60000b47c3949175a48d985a61717568a12c1599e9099d7cb17040477cda06b4d1b44ce52fd2584dcfd479cc3940234de7a6e0d0d0d9ff3a3ffdbc64ffcd4fe3ab847bbc76b7047f21feb2e1aeb85c5af19802db36c89dd2a1e42fe8da8564ce1dd834448c59215bb35ae74db8a743bfef2dd8a0e07236cf6f82858fc867956a7d54bb58a17f8fbb709140695aa7e8a73f7044b47a97d3b9163ae89300f7dc50d89a80f56795e0b8d30add07f3e4e54cec3788d3253dd65b2633b8bb631eb80a9f28c3f2051a686d9c27953309d0de1f6637a57cda6cf3a5729816c0cbd954cbfe2bcac7f1ee8126045e1c39a0b7a03851f7cc5f229111ea791868e8f34207d196ed6be16915238514a8e1624a9b1cfdb84281987e92fd6e884aa31cdceaef7f312c82a43fec5775e183a37aedc9b29e8f028833905872a70b44f09908f209dc6ecd0ae6d56b90b580457a4f27884b6a9d36824733cd0ba2d48b10966a0b12dc49302a01f1d0464bfe578dd21682533eb91354aac76667db2eb6c3956a310cad072abec5d634cbf695af75a8d6a32732fa61379cb6de903d54f955363179e277a3c7edf21cf38a6901b3e9168b5a01f6567d070a2e87f941249f6c97f5bd749d36d5224a862ad816438cbd3873cbaf27a640421b1a42768d8ca7d855771730b039820cb42d791556e07ef3333d18c2ee95e9d91d0f6cca5fbedc2e8164c6f935a648b98ebff00aeb033134c67643ebcd59872111231fa7b1fe304efc88156921c4db5e53c4e216e46b8393daa69b0e69475ede8476c45cd22062fcc92fdfa29de5ff70b6cede8bb7eb29d2b14b5cdd1b081390b91d96fd444691e8660df871cc2e77412130d75296e83c66c918e89c0963f961be2bdfda5ce278f5770acec9288c7b593307b3db4f798d71fdfa38f14b7034fdcddb7ade604da870a91e79d81200c71d6fadb838bf5fd410577c8c1a23bc84e75a7883254eed64edae0217dae15e4171ef3d3add29d53fed1c4882d6cb301fe3ef40f4588e9716d967010c1d727d4aa6a5d0d926f404de24b3986d40f939171a54da5b96af95f0d1543cf2be8353b9e2d765f2d11500e32b1b8818b2b6c81f015a9c0aa1e6d48977806fa09d6a6b6216af1cb85dce8bf2bd09ab4677e128ee0e06495075c0ca2d511c9d7482423fa16eb152d6c23a4eb03a18f2d051c01939e3dc7c33073fb48d4fbbed89459f23d3dccffa76cd9dbd625b6cbc62a2d907712c9125938e8f51699d9b5ea2daa9345c0b051b3b67a24bd2d2461000fe60756731890d15446c93cc8046309b30d4b90b6bfec287ce10430af69eee2f1f649d2f1b0309a03c638aadf68091bfdbab6afdaae2f7f3b8daae20d9dbe381102579296403c61669ebd9aa3f58fac85380862a4d57a8334995781e1069cd3194506a5c2ef1c286d0c5fbd1140a9b23f570e1c6f49d44dee6bd3eb2f6fb55e2283fff7173fc5f1b624f5dd523a6d431547daced8f7eb0781930bee5ba203df96d623bed8d2f5d7bb5065471ae2fd1c2deccb61a4074a63a48cc6b3ff3ea86a69dd862d06e903c7761bd335efb751db6c3e7d3fcfb297bdfbf61393cadf57ba7edfb7cb8d43219f94903993d4a6e1d24eae8a91018087d733fd8fdb2dd2686867182f9e23e87ab8defe3c6bae52279bc5142ac6525c666ce3aba4548d43216f27ab04e06bb9f3c9ca2eeb7efb5ab3aa99344fc29ad3541141ceaf2c240bd1a247681688f4576a81eff910a07c8d34465bf13e859201dd9697c6f28cd358f1553f5058cbeccc4c1aba4e8879cddd17f63a6ad2ab9148bc8b0bf76648cf3beb4fcce58c7923fd751aa515e4306b9850c21d83aeb88b7df09694047d0bce5f6c1bbb6095adb5aca96e1cdf2bb64c7c9acd8933d2dc7a063d4cf5d11f5619ad24d74dffc93fb4c6c0413049078bf7871e1686890e16c458375533e8a9ce09373a531e5a8d3d4d53f5373c93cb98982c213591e6c8e481ad1146cabad5065bc4de638443aea8ee977e35fd2d595dfbc7658fd18673581932e6eff386b0c82aa220c30e20304c40f82884070110bc2a083d9186f20e0c9f58c6370de2de0afe6f029b375f3eda630e284c072ffc3a0e9bde07c1b1b486c4ed81d15a812ea0efd1ebfb695cdd8c004fe4b99615ede313408e8b37bb2a000358cb9298d8dddbbaa72c3ea1d1aef77a7cb3d8a27dde1bf50fa95c0ea4a15ce746e953239d221b6f1d09e47000617bbcf73f0b1341cb58535c18ac069325a616feefe31e1176c651748e782ba5a071d2cfc97cbf267e00d3890748bc3d0021ad707bceacc7924d9d420ea7cde43bef959609d3ee0782aa16287bef089fa32b414ceb2bada476475a77015d190c5d8b2d7333e57986ae7f6612acab2c56c6774d2eae820203ad46b064a1cb7fe364776c782ebb3af11be27913c4a4739cd92375fdcc78dd20748591be4fd59330d451a5045a620a170fa86bb9dee29e42fb19786c6068b0096d433f0bd260f855e6e66a5f7ab67c764ad29c7ad30e52c063a2d2c3405eaa356a2cb68875d657ec531048e4095c324f1bc90bb6a9f77edd5db44a8b69ac5f592117dd7b74d322824cb66befd195f37cc2ae0a66a26d2a68d02cf6d430d95149ab23e9d6079524d70abb34319a510a945d7e9245c42ff860a2183fdc191fb5e4cced1232b4aa0eadfeb0f6dbf3a88c67ac42b07afd74a1a4a06ecda79edc9ded499e4eb8208e9be14a91ad054c748974c9a50b1e0bab8a2e7e4fabbc5688f65f13e969872862c87857befd896e6189320f1f046f14b00253acbe49eba94b46865248886ae31fe44ce10d8e74db416b7169e8f36f0dac62e8543734469d5ced4982101c84e6a0831baf4ee3b31376cb940a21584bd6cfeac65fe1208614a9f85b09722c3456ec9dfcf8c40f08a08e88382d105296cd41e367c664997cbc8542d2314a57bd95e39ba5ad23dbcea08ba434f917fb9b373f37666a5b2664bda8d240dd1368fec8f3428416b8c40585a5e0dca77deb2ff6023f80d44ac9eb804f04b66aac4f4c689a803447e222abd611dedeebf304ee77b451c3f33b4a505f2059be423feb32acd156356d47e8dd32b24155d8a7bb57616b523c13c784cd53624418ae595ea69872d763654af94de90e2a562add56b285e7e2503e0a3dc5ec7ff97c6d67f9174d1dffef7051257b135682d22b44309840ef6d586a675baf8c1821f4640b813bd5da163a4c8f5d94dd2456dc1efb309d1c2e2a16edadc06cec3c5b0d7c7fd379171d992a5d508b55794dc2f3a82d2128100d80c821e70f9695324e6df9fd7c39f65cbe9b15e3bb05ef1e55c37a276f3b5d118167f091de9ea5863c453767061e380cc0c9e2dc0b79f5ec2fb13d8860cf8235ac047e86c7490273b62d58d7aaf0d6a7adbfc46144dba658464bf4eaafd8687ccce5ca72ee28a96e678e638551d63d6d540cbeb62604237934df6fc50e170c1bb7792c0df36df6bf996fcf80372bb893c9982fafde1c0a44e219570027172e4a4b6e561824f881d355137e7fed0051a55f4378e9cb56d881bc4d634fdbfece8bf870d5ae9dc898bae1cab1b72c5c3d84fe4868c37d438901287aaed6f2ec6a934b8aae69771f97b2c2db6fc31c7a3769553f7356ca0bb6c701a8d16f326c240f7d3ff74004ba6369fb8986723bf1e653c0e738af6b60cef236561de4ec86213019644cca7034ddac097a1928ca6e524d8ec76301166c9bcdcf65283e6533e50bced774c54b72c3b2e3a1217c11a650686c7f38d463b35f369e03c51024cdf3e0ea2404bfc050df0c98a7fe567eed4348c746c5e5ad13cab29e54cafaad291c617eca4a41821dcb21e400be006b6709d778b70ce0d1a5bc9034c4200f013349cc27dfe563ae428718ac99705fcdff823f4b90acd847e0e420bebe0a3900abcdc176942464b2189457bc6300e8ef8e412de7cca66cc0160c0ed1a315a3a22e8e6e5339d8978d190e084fe1a6b1291aecb561894a31fb2336749b9cb2282e3a7b5b582f01def059d28518a7a3df031560c65a8d5280f326aa7121af8ce9f1015c846cffddf79683d6dbb99f6004182daa9a56294b875cd8fd80aa63f2d6ba063d3c948117da00975856705adc83cb28357756160c828fe5d24de62078b07066db2d779b0f106c147dc5357105e8639cfc454bd84871963fa1484e4b643ac94c16fa0f9bc01960eb504051b5f5bf5dbb2a70488277206c3fa5824d24169fab4b504c4464fb1e7ef8f3d9d283bfd23f658136844d902a18020d9c498d1184109dcce28e93560cb17e6e2432af0404ae0463495612324576c29662387705720ef87b873bc57f26a19c9393f462fa6475ecfdfaf1ab8395ffc26598c8dbf2c03789fc395f2440ad85c7ed45c45cc7beea8f95bacde004ca16394abc0eb8dda6f779e6e889f94c29dde7c1b659ee13af0a5505ec19d460e2beb419699a99576aa62af606138123a96bdde0e7726510dc5cd73c87dab18ff2a72bd4b23cb2a035328fc114f126dc86570f125cafbb974b4ca28bb8039c76bf8f215c45990015a9e6866ad98205a899368980c696790fb715add23cbcd780a3b429373660a95815b07da1e5790eed15a117e6ef957ee87fda854107466227999337754224448821cdf3689d4e41cd4951fb30e426318be363aad5fe33aac3ee9ca761a0b6ee7bb6f5956918042aa71c5d3ef361bfc62e375c29ea6a2c6fa6a5adee6e51e0b45230afcc7cd8728876d3c02119d487ac3e7ffd357a2092cbf85be951bfd7f94ef1438c68f703bbd8708ca952fc676f2362bd086fbbce65783fbafba40b975869d23e9e96b1562018d50599fc09ee6eb721f11e154b50d68f70412487caf1ab51bcef08e935fc4f4e6c5165e753b3025a72d56d25f60e2582a457139302d1911c8800cf94acad12aaff66075ea323157f5ab524d1208ca8790ac914768e6e74d1b5866090e58e709de9f1008d40c986e8e57a7a27cfdeb5f46b79854582cbc72ada4a8ae24bf0fc67879a5b5fd2242537c7e8963d3ca19bd7a3517a290e918523f92759a8f056a625de89b3b85e6e6458392eeac40676a3ab9ce933a043b2ffcaf02346a747255af1a9a62a401247c9120d323b4c2aa30f2f1b1ab18afecfdfab46f0001b8ee7f841977622bb52d10a8c04f4447fd176a2c40325824f3cfff4ae16cd1f02e76e0b525b3881b091371b6471c0921cd1fd48d2874d7952c121eece2b129daad8cd7bc5b6b2f999efc934a9073b34c9547686bacfb2405de5fbf46faf54ed94d0d1c8bba8b2c5cd1002171a5bfaa123baa8912308a90b4c2cf0d2471e4cfb9d49aa20c6a48e97ab510f7daeac54a31d9aad1248729d566819562fd740b4bd02370f2cb4623d107ea5a19bce3ea62ed4a94243864b01f53f670ad66c99ac2dcd43fd68e43bba7881b66518c099f4a1efd12fa4938f5cfdfec863c4ed2ae4e45c81ebc444268a96f2b1a07c3088a5b25919751bfa91829f673d6f5e50c92e0d2f1514f673e1b0f67f1838255f853a5bc968a480d8e148c1b1672a34525467b39f5e8a2b7c06c0adfb84cce480e5a33c78b0e214e524b29700c99ec59cddc467062eefbca2dcd6a2a724784cf8af0c7ad3e70b40fb0c81c3fd3b7b099a25bd79a2bd28c0506f9510d8e9e8974903087a85d763d3ca3584f1547371416bcb3fd7c5f2ab0b0867dbc3866140c166a5aa39ff97913f630d38a598040aa1744eeb22e9335ce1ea8084de37afadee60ae03580a5f4c178c81c19009d45d9a3470a8b23783602de2b9a09ebbc783415e6404cac6cd63c731652cfc3bb1f5d598c2ed4985ff4b156c132f16735abac2ca82148a41f34c2e97876e655e0aff292fff6e7b38012854c7984638f12ffd8432b03a6eb89733b00a1f55e26122fdabf4db08f0c7c456ac6b0c376c1035617ed8c27129e117768a87064a7c697af784ccfb63bac1ffc33d201ceb162a4df51b25f20c164d698412bd192ed930a21d0ca9b5c3ae2c634131584d8ee8fe71c4819574ef526c0372ef6f677e2f779d0b7bf195824ee15cd861956589e105fd35072916230505872efe92adf1d2d8870a120b3b1e8967ef3de401c5d9f6079de54de1c081a28d8b76b403a1d21b96d7c558e00420b3068e512c6e8baa330a35304fce1c4f4a8a94ca6a5b598a78289055e6ee747508a76f587c9e19b0d076a6508806741de74ae5af561fba9a9a41e5d45bfbc0f949278b4cf9efcaefc942e411aa8613b3eaf5ce1e8dc8846ce9df2d08109aa4b5afd94e032f3b6aa9f12eae0fbf39c0dff2851812780ea866b2701f3ce36d0de8a5da8d503c6797a6b98b4d3515653dbab6e98d39de8b7baf03a5eae5f6f3560e6725d9ed5235fb979878143640ffe000fa9c5daaaea545ee7588c2de118773bd200594253b604c48a4960bb51f5559eb6a688ac5a474d51b0dc4bf50b5ff5bd3a238c0efbc51c705a7705927c82a6fb9ecaaf0e01786dce4bce294cc34d0bf4ed83abfeb81c93c0d0f890f73edc8b769bb663dc8279178056ae1cc759dcdd3af8ecaa2d1a95a2ead91814388e8a151b3978888d209cde958e37fe2234160ef31c0cff62356785f56415bb19158ef8dd013ab88b9ede663749d7e27f18c799f7c8fa9e6b2255e7ee50aa4d2e522c7d66e311c04be3ff03d0feab0b9482b63f9edf604d81639a1b32b726f0c7fc7dd35829dc1234351531a04f7b7ed101033e8b5f939f210ca658522c7ae453a67d302d810f3f4be49f09d54ac3f7b4a35e11353f3092a1f1d82778ad1801c819c9852be15948abdbd3bcc1eb1abc97b3b93a3a000de42d8d2dd752543b7c148c5a2fbbbac4792e173a50532df3c60b9d33283d86672a77d25644066c3c3e9d4b44ae5a751bd476281ff4885ec549aea68b7e459b01f2394dcb6bac52bc865c9e38b67ebc3f642db229239e60ca6d8b068c4c789e0fec1568e876abb89bcc8a05c13ca89554f6cfe211871b0fe494768bf6813ab531fd3027ba152992515f4afd59b34a9f5f886ec1a172c2b7bf81ca5d658743b5918ed1cdaa96e123300411c66d4a6b361cc2403f1698a31e6f8c87c81b1c2e52092309a36dfb8d22bb24e65d5178f9aa418ae34488bb08777f663feeda858be7eb46ef984feb4671fa91d25dffcb42ba234558b18b4cfa391abfb54fe5e78566f7479778b61461d964c304055af470cb68e840f420cd33c01a95eae8ef2e1ec01dd8b7cae5fcc680aef9e6bc662a85af8197ed641d5a8563e535d2974e387b6eb4e82bb50022099ddc6a626ca92f7032167c3e0d14ed00196a80d350a512eb65230bdf082fa5b1758bfa258d34b6aaa537d7322fc4719b5d4979ec29e26fc699b5d4aea029b0c0811e3da081f922522313d71abdff6a78c08edfda40921cfba69788808a1b61d378530802ea4c744b52507ad83c215fed8ca3e3d8d3d864d8f9c0e9a498215d88c2517e1f52f32641eb6330225f1b3bea3e5a751e547382393e7411722a54902d73294e47a00d17f92fe6b892e295cd2970d4d564b4c659e0885b91443a9226e438fc3b10c5f155f9aef52633fb2cd6d3c66aac3c9c2609e7e29e3ef578e0d7aced14f8e2f0c8757e12a20fa3a332e266e48010df23d1a12023a3002cb46d3e09b6be9a7d87cd080a9919a40134efa8df8e7b51b4021721bb80a0d8f9a16bc8e9b8c0991798e636c061a5418a1ed0d17e8698c6b29f10a299470d02a42ba594022f145247c851b5fe2857cb35adb0d8e506a9f7265de359bd00355497252eb247954112ea5dc11fba50177c6f0da9400cd2b8af62375a1fc399a3aeec4407ef1e743832e51bfb44ca706c5111c96e9fe4c744ddd732a49c37fcb3db24a32833c94260551de23d2e203294bfedcf9803df9707200b32db823ce8707d2e4f9f71d179429543000f16d98e06290d12bd8f4f1d403123d6de86864fb7cdf9049ed8144937f07f91755714feccf09b4d7d5f8ad53db79df5401ef046509411cd6c5cbd971f814ccb8f543caed4d291b6d9e2e07078bd22b7f53706161aa5ffafc16cd2814b96f3ccda1b24455aa1e7417ba3d3cf06f0899e3bf99796695a51faf2430c00544cb14012b9403aa9b551b677423d092b2d21ab4827d2cd396b3aeb8eac4ad429902bfbc5f5b2a252f9f460f3ebbbc6ae74339ac58cf446a453cc7455ecc04957a53d3d6698d0b04e082b8b522a9144b7018efcfb7cae0fd4729fdbbb4ee477c9c663aae3b942d4d52deb86ac3f13ceae41aebd8543a01123ba7263ef11fe2328a1c9e72f99ff9e4f1ca93df57fb3469e85d7c30cf4db5b208ae39a49e09109c9c984a339c9f621ddabded6d0cf33bc93d9affb5592817e0abff3827f0a22b4052931350cd8c96287e6f10e3ec69866361089837cd03df148d0fc7c72be643102464838964f5dc8e6178948aa6258fa88216d28911dc7936bb37229dff8ed0dd0808f5fef0e7869b2295e168eb33c282f7631749e072e46b7c6b6155d9d1fbabb04a84202a597e3ea4a7c2c35710a3280b9c0128790bc5189da4d62b2c3129d5fae1653babefa17411fd44abf3321b8ba8bcb6e9b67ff6b0e6be54efaa9bd9e624ac7ca33b58735125ec1223d7337a9623260e4977ca681328c39529fe8db471aca18f175c112deb5bfc0e1f6326a6cbb5b4c242d641cbaa2d1d6c6245cfbadd90455284b4c7a5d72a5371370969f53c6b1e3a1724f9b39e8ba313c6683cf608f7490e8c07457e139f0328e68fdb9d046380837c3ac7ba2d3bac796b96e2f652f796e40f56e0ed0cee51255c22a35be0c2c3d370f2b2f6782f45ed7e134cb879dc0deefb84382c7a0bddd307ec87f861649fb6b3cd50efb7219c4c3de0a1824bfa1d018ce4e3d6d8e9dfcee8d86361d5410cbd7729037b3b3f2b63c567828c08dfd1b6c490cf3e3eecbc0538d600908e43eb74e2a58ac64dff160c68fe23539db164e850b8f5bf34c8b4c81958a7a7cb70b5bd5c1f0dff0f482b586ee369d298c11b285ecc101003a1c914a858378ba99f0b08eddb0957748bfded7dd637caf0d332bbd03010394b7489798a191b1e59ba6793d1b9d00f271d12495360f7376db21848e6a7fa574fe05e9477b01c506323a9209dfc8e036e435b1372e46e2161e1cad56b702c2111c607bb3a7ba8ea31ec7ac5481a2524c72ee1eac62b4dd430793b8050df2b671f0350be281c1e22a9a13cf619de02001c226b4ec4cf121a2cf35f1d15a7eaa27ba8b6f0fd587af294742358acd9793d2f32bbdf80e21ab4c58009458e0c3338a309e71f1a867f37d0a0c55080521ecad48d35d11db4de87c25a37fe292ad076a581f402c07a94e749df71afca63cdde2de4e6ae07414c7ba120f307742890370c31b1e73b9f7a7a0f2570305493516c5807e46b30bbc09233a7cd6ab55ca862066c864264360e9d5c7634eb03aad0f174c59dd08e7653b111a82e164ad7c40d82a1807e9d7b2acfeb413e531f6223d6808e80d7dcfee8e09176aacce737842829707b0d5d30eece628ea0c31b385eacc434669925cbf1ddbdb594f9a22d44f91c5d8b4ef92cfcd1cdff00a94f277a878570b1661cdf6af42d38b223b0c98dca1944529d4cf17848e299f410d8410eab55bdcff159a16f022a8a3d9f5a2a97ce31cbb89c32531f6199cdc1d94e8dc92db3d0b46af1d9388f5adf7a24c6dcaa0b9108314e9900eec03c6c0c5ac15f153ba251547eb3a613a71a2f63d00d9f751979153982963a5f05d5c45fbcc4abfc76532fa82480187e83a089024211210b48ffeafbe0b01d303d36e7ea50ea9e091834c66f3a6f24905dff4f622868839d447c5647eb4ceef976bb31c15f31a9651e81a3adce24c404419aa82127b3b2c48c75a1f0641413833a472b1ecfc8f7b01bd62b80830f100b425468e80f5779ede78b1c01cb2d3e034fd3075473e69d9ffde62173316856a960453c6d381739cc379752452df6994a277d5d8745349e2c65ad46feb613444c3f937f7c8cc5058a20265a2be8c27179d5f5b6003a98fc866c587f16e27098c836e45cc4bc45f9bb0ee62adabe8f02807bba6b4d550a5a472bd58d6f0b3115a82ebd4abac0f077def3bc689104fe3e2437a779cf190d7d0d286dc7aaf8171f764a7838fc77b43325517d8a89e4a969a84c2a4144145b7860580ae5f53aab0f9c37299b8749376ec4efbb70ff188d42691fe4bdb5ba437bbeace42e099fb05588634cd204c35e953197be3080cd27cb8a0b5fb3036a2bae5ad0eee12afdfa669355a836420a75b709430d2c1a78a15cc36623976f07fbf9b0d9c9a034aa6fa2f75a41348ee68685daea9849fce4930c2b32c712224149c0804cead72c120f7a183d71e49dd5f06e57548c7f6fb79ad6606bcab858db008c60c62ced42d395714a7c47dd8f66a95f4a3da2d38ee33f638bcee1b82b31046a00c7152f8ef21620e886f388b9150220b7f502ae1401f91e210c8d39fdeec28d2f2cd74bd90a09db868a455351d6dee5c48f1e3d2ee3498a5f06a0cec90a7629e4ffc19b35445cefcd0d6ee6f14df56ba061ded0d7e6646e046822d796c24eb105768542ce185038c52767f3172e011d0f0248f8e063eba6cd89ccafb3758819df1402118fff1c189eb4d9c28bf6cc2a06aba506535a1ecb06f6e5732a9ba427f7b17f6c94bc7c6d9901d6e52a7beab1efa1049e7afffc0f9b3bb9bd0e82304a8fb66a84fcab13e28205012581ecc6960aa4629038810b4efc967bfb68b95a2c6ad185fc3bf762660dffe4c4aa3df04a0f023dcc8f4885ce0fa5ca76ae1d1363df75354c77b7d8e6d04b91a5042eba97b065cc0cd1153858fbf02095ea0b376cac1498dca5d64facbd565ac85aee7de07886acdedb13c5cd8b57f1e84e8c33aef9a18e2249d50320a8e5293a6c0f1ab08778d1d58d3c523d1674dd493c94c48acbbff8c5bd04d6e0dd6fd82afef72f84d8f5c1714e141f0e6ee43aad1d2740bdea3383e91b06f555321ce718f9d2421669b0849b86bfcf674e5d67e99857767ba366640b50ee35fb05165cca15aba99470a4239ad7ca6f3d34963ca7bfb59ced974ec595207dbd82dc99603698fdcb1dc76795a78995d611d5dfe361a1322d29b51d6303e23bee32efe0d4274536b36df6d3edafc1a96f57914d6e6ddff62d2c13dda60cc0b032a5cf22d7b1e08e67cecb7c242b1e6f551f4f9241ed6fece8ed98c0cf9b05470f6e3eb62af9d5e6a835e307d6515c3e71bab68581465585b7d2bd007d015c8adb2e9c41f4acb4c9e29bb145a172aa6851c8001e66e5e10ac13157696f0b8e2679c9366a190a178aa88eda7373b58ab50c1bc2fa4bbda05a2427cd9adf01f715efc45e37ab49b902446ecca47b8269a51e43c32a9f8d081a473e0ffec7402c346c7fad28229cbbeffd20c0a6c1c338790d758cdcee2b6809b268d737a1e368a73b4acebc21895a1ed4d0a6afb453b53357d8a3be6da251d8676b9e7b8f83a3c356f9f776f3096e748610fc55ae66c1e2b8e3e739a76678b76020181b4a35742ac5ff5872d61230bafc23af7b36eccd61aea1dc2d5680a93e60b6f021e3ef063d03dae80f4e3a86c3088dfc389b680259b1c02d73e8b94baa9ba96fb8265e8e621cc10116fa7f8ef9c8511fd32a3a17c922ad274a3f8ba97c75bd02a993fec3c4b9fe0f5a2e60e54b703ee9faed032c8475e249d967edaa0f020ed504cc7ce198f407f40db40115765077e4fab82ef5faee3ef07ed3ee41498d807c44e7d75af144780bd40fbcdbe1fe596ee230f55fb2e98aff9fb782387a5588b2522c04cb04a7c01df1f74142224fab2c812003c9bc5fcdfa11b9d101e330cd9e8d85161e30408b5747c3a46d72dd181e1824befea9568b96139896db6b21e003d32ce080e3b2920c22d145f64826be2cc5f38a762d5fd15644cf1113711f1e25077d5a33f75f972fa916a4b6ab48bea14456b336714bc11bdf6beb6a8e5d9ad087d74b7c090eb950e4371cd0e65548a6c55c3e94808903cc0d05bcd9894d82ae78f424b9436d52d7b0e41385c5e9ce4dd10b182d7ba131c907da99128a2601ce0491ca9544fdcc3c17aa726795c33869f501494534d83606e513e925fa2a75a0077a9353c76a834c1f7dba809d89690a584b123b87fc7bbfd2c259165b500ff366661c0894468bbfad339f9a5537bd7015f40214dc23ba1423e40a45a602a67ace4862bda66c8514b59d46ffb4b13522bd0e036fd865e50237891351b6350e2428b54895fd3af580e4b627ff5794193a7a858fac7b253fd300fb8125bc2727510f8a183483f906d4a6a408200f9fd9704fcaebf62cecbd63e1834861b246ab553ab4e5e7b3da63626f5390d3bfbd2e1d1ebaf805a4d22980929d95b438673d2e05d60b12a70b8de764e7a5f3893d318d66f51159db49f996e576e745c9f70d14c8e0c119605d660206d60c8ec5eb55e5413abacc796d61062bd7fddf5a1530c4554ae3dd5a74a3783329c0628ef2edfb272a4513d5820432935c1bc7249b2fc23f5d8990401528263994a6f096893a1f1fd61f0266a771be378bfa2cf27e3e5111c5339d26f1621f77ac8e37faa35a1c52857751d735c02d2607f39de1ee378cc2f26ba18625283c5ab37a40a241f25232e430449befac24b5a54bdcc61175135fe2dc386554d7f25ae46412386a4e21085f49831360c11888ab484fafbe6c7eea76df331a5f88fffd7aa8d71fecd84282d92b90bec8e446ab276d83ac206de703d587b0b51eca3fbcb58a63329ed83eaa761c12f155319c06f69d8fdf80b0c755d0cebd41f90d162274399341c97f5639c2a58a06932b4bf1110baa5981332c451a1709e8dc1759c57f72614cdc6d7b9c485d5d12939d4078fd271a4de603c42bc2c5dd94e68929cd56fad402487aeb4c938482c4611b064c3874f3ca5aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
