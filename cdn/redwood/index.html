<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"306d56c58c69dcffd5839558c522f2065bd72fd5df02269ab396862a90c291ad0503a918bee0e6e619e334662492d84629086d1137549ba59aa38bdcc7079410c6e7eefafce88e9b16af4a347fabd5b47b10d81a4e19096fdbb5312f7b7d3af520ec0a4cfe922bbf133bb137ea6fc6ba7ea968d8aff73e8b9b158334682d3a2ae6986ba5c0cd29d78879d7c4afb93d2b5ff3856364d6a528692fffc3fef41210e2bf5acd4a342af73b97fa1de89ae3f70ca8bd02a74f160138f7c3b281f8bcab2ea30e2aadfc152d83652affc712011a41d692475d87e709e95c316df080f8b4d082372e11e99d45760de1465fa0869652a2dbfc310d66ee39e557dc3ece6c7cd838fd740a6e5905a9c124d9fd445cc061544b72dd7d4b9329366066d5ccf6f234d28401515ef3cfe8f6d774b15be917b34546a32fbd1f5cb50784ce9dd318938bd828e7425cf26d61ed5378c88566c1777daa2437bca88f5e37cfbd77dbdc050be2c697a3b481306e7af33b7934e5233963b895fd9c38dbce18de14a95dbbdf14d14ca0a7d42cdbca74f69bb70785b93ee51b01f9f7ecc0a4410b0f91f49f1ff4b0d2588d7713fc2449e6601a199aafcff2822421a6e56289263e9dfd0729092c6eba61c9f73fbc127bfdc29d6a17dbe79ec8cd2cedc93636eb5f20ca53bda659ebfdcd0dfdc8c42aefe65f4758c445c08d6dfc61cb8512ce194676c52f4bb505ec21dce9baf7633e386bb0e505aecc9a46b13b1aa2338fca099666f2330ce187699820f6b27ef328667560154ccc27c1fbc2f9ff02a0e2ad29d33d329f81e2e6e60ee68686026e8fbd138a8914878d621e239ef200ff5fc9f730db181c67a202d45196cdcb34dcae6612111878889ad2eb428a678b4815c5fbdfd8ca5aa60b314db503b6810fdc89090f4ffa412e76d40151079cc3e4532ea77608b6490561f3497b0c8b21b1c7f195ca5498fd5962ddeb2d14d0924f3c8268e460ca24d76b65240fa17ce8633252c4e38d5b85248e7ae05519de1c96990c548644477ceb898c01f1b62a0c9793ccef22da3754ae6a0d7463116680cab8bc409721faad287d37eea745b2edcdcb97441d51cb5b26f69b9a77fb16abb9d5b19bf9da1f735014e6435cc1e45fc73763111dd02c8e77010e3dda99b315afeb7589017f77c43ce468ee8a5da2adab40cb2e936a26407a7916645e5ed0fe61ae88eb4c8e5d010bf9b9a415692976b86746a3205676888d49218b2ff7ee074dfacdd526cf544adc33951c20348825596b7f0682af4c8d92ecdb8b633168f7626fe48aac192b3b6c1cd375b02100d4d8d09ccf34bedb54ec5f8a1b4b47ea8cee23b78d2c1fbfb46917b2913c658a2804eb56f94db8259b60aa430c50dfd7e670045457848e8375d0aa96e245da26f2695f34722d9f0c6650ae14c81dd3edf5b4d9386fb63372ea24029d5cda874291955181a80a8e7ce1478037107e6bb2660ee534f4af56bf24f3960a357b29ef1009ac1874288c7133322c0b729e8e4a7d18e7da91384aba2dbe11a80e0aabde1148c329b063936293b420810cd4fa9c038c4e71e0070a5b7141601e623c60e42c00f3a2d5ac065452a0cf526cada9cb46c61d52782f2eee495169c5b9500aebec2907c5ef57df56f9e80c12a90b5ea52861315c3b2d33af19f93295ffda635e60dba99b141e859834db11a16775f9a08c01260f95052f103d2dc248f341b5e86f1decca18f06df898fdffd8287d409eef7a1f6eac01fdcaba1bfd27fc07ee878ed6d964451e931f145758a1bbc7af2ac6f4764046a8c3e54dad1e55738b6f1c9fa4e6f03cff6c497db8d19c0352ccbcbbb161dc218256611818dd0586e547596012ff18679eee03ee00edfc8553f50c3714352d70ae417193295b41fa6ec787da07afe1647cef00ec146038b0e9c0864b9d8e7cb75ee99b8b7c16217f704638a3add9ef060cbb62a641070707cf694cfb343c0c8796deb7d8a399df933399444afc7daffd60d30396e802fc5fadac8581e57de6b480c3544238ab8e3fd798bf248d6f49f65d2e36ffee36e6a3fff98117e28714427b7d5ed3c4921e2a49ff39228a8f40dee3dbbfe64af44d870754f2c75a8010c8565b075abdbf5a31f99764e811c2cdec5f3db93f7b08799f8345886a99d17706123769c1dc5fe246f7fa54510e7e18af550718afe5adc2b5bd9ca98e017d3c10b642b06651d3354eeccd883c02ba55edadba652d3bd1183c43651760ec32216023062f7ca1221d04d911106081485f6076331357008e1a8576ef6c98106dc946ad7576d45b62153692e2d516e9d0c7affb0f040dbb322b7793b96c9e7843c209c0b40a8fa245ff5f799e508e41ed328dc40a7e009f6def554f3ac84e2c99065aca128624c74a34ddb5b70f7cd9a1eced5fbef44b5fde98496458eee0918f87553ff525834007917e5baa4b6716a6519f1d309aedbfb2bb4715c8e29b62d9926136b388f1a3205df6446bb2e1981daa2c0c959d0d60f0d4587206ab10968aed139b414eca2872cb1eb60ae2ceddc10a48688c990ef25b7f9dc70df9040c9da8a8d28b6e666e01dc9147981d633efc88d1c8cf2c21b90be3e335a7df98e07a419115dbc2feae25c836dbc2bf925d3f1547460e413164862dd2bcfa579265583f9e67fad8c4039a4be9b394d1e7ee5af2cb2d0195cadaa30ec073d376ff0b202cc3fce34a8f819b0bc55bd071f324fe23368dfba4b19e3ce7e31486d75df41556e4b2e0b6e822688925f317410c1e40c19ebec3e8e6f33bb1864c6f32791dd9e3d25b8492112dad7a78fb5addf538792cd00da6c470049f12e108b512b8416d9076358566d7f420749b8c019b6059c7fb413631de45b6a3f50e480f678ea98a079bcc86d47cc14a7057d2dd381eb02889d9d9d2c8b5af8f4dc752405d6de66d082c8cb2c99e510bda3008bcf2cc60fd1827171a8268738bf705ddf12511a9c09ab471aa87aca08b726deac4eee09f6dcb25e9bfc1979fba01d4e4b1d1090c25ac2fd5b2add25730e0bb9ffe28be5b75f8d96665feec9d7064a8564584a18f74a0d3f1eb8128afd6b56e5885900800fd044e954f21e46674041ed0636f393b863f91e1c75dc901424994c399ede306b48d6c21d1126654e3c5ad18c2af6a6ba99d210909b0eac25afd141361222b9663c898f494b7782b9869756316499ad90a28626a15454ee8786d3e356a33bc28c02dbb34735e426555448d7bed57dcaa67a503396e84d592e430b3b333394726f6b2502e006c4fee9ccbf79718b586c2b21a0306a3fe9ebededeaae00cedf3facccb2849c209d04e814b3aef8cb25981d4b356db6a5feb5ca1bca8ba1ff3b39d691ec0ce2778bcaa1923378b6c34e3dae10582ede7bb9e3fca65a3457d078ab0ec108ae16458218d7b755fbbdde28cfd2238f4864752a2411bb5f4d029b8ae83b2f014a77cbda225c1c925125f469334c7548d51cd56fbfbe907c87c33923d34306aa3784037a42714d5cde8cf1c7fd0c1012dbc0a8b2882043f32b13851d2b9f4597b46fee10de7aec9ceea92e8bcca61b36edd8e1c5b497a8d4330d25d4dfe8d3113912b3975f7e365a723e9240a27f3303420ffc888219208fa81eb1d39b3b94318a56340df2f4190d94771de86975e0a3f8672e8ea050472a74e976f8194edb764be6028ddff6c87ae17882f60a91dbf1b1919728b9d8fee9933946935245100cb5936fe30a946d21ac64ea57f82dbca15a234057ec0e13fa3759c765c3224cc6f32ba0022a9cc0cfc5b59eb38505c71303ac25dc70582442057bacbcb50d6a72ef3d03450311fc808d086b59a3878efde8ea37ca33ba1f88847852ac4513989f51c7cbd4ff8e9c8927f752ddabd6d0ebf688b3b1992b679d81e1c9704b1798d80f4d250ee93332c9acb9854b47aa475d581d80a055a579f4ac31990819b84f250d8372eca3fe78df87584f6ecebe4807527924da393bb6a0504264f287ba7c423f60e40bbb79644e0503370538c3b5ee2cc31c580510aa2bb99aea64ba4e00201fc6edae0f82139baab8eb6fdf9aa86fadcb5b59bf6e5da68356300f66e83313fda1070fbd3f0a46788dd455e91a8d7a8033b47c7cad38182461c12703bd24ac4095f838c03107dd372671a2597283702a485008f9a82423793fe86253471beb7f18453c8df70a1c8cf65d0bce1096dc51854706b454af23d828fa925468e1437884c2632d7c60e88e6165dab39f598e4a1a414cbb304c74a33bfb286ceaa8da92489fb137be6a8fb7607d49bcc595c7d49fb46b0017fb12ab603be9737cbd9def577f9922e457f23c607349e2f1fab1ba8589e81a05d138599e8358dbfc457cdf83377a061bb0ecc7eacec858c308bda01e46fd1035116e9fcc6a3a4d0d7541806a6c0152fce574dac11f3bdc0fffa9ff8982d486f73503a7292a73df7c03625bab83c741f23fd6206fefb497296ea02f448ce3f81f9261eae8d5d6e26b7870a35651b7d33ecdadbb9246375943c6832fb893b072434a30b076f410cf14119384b0e37f04cf8be068da1560a869354e7ee568907b4c604ba054809f3de9ef63049eb9b0f53ca97875f748c8f2d739d3226c6b5999961ca036342e4fcee0f4b050dd68fcd7db93010459f0f18188a3220d23e7afe312f6e212fed7baaad25add7588122220019bc1403ab40e8b956b45a55ae410b6b44ff4b1ea2cebbfa7aa704746309962b117878c57571edb6c84b1c8d2564511e17f5d0950ed7c2a1d8dbec8c5914c88771edfd48a93475834cc4ba2081bc8e3d9b89c96b26528d95fdf54e1995ac8c313349214774d744d6acd0a5936c6ee627bac1b8c87d19caf5172eae9c99941c983c7f5ce7ed060e45e136ce7e5aec7e1e1e1c44db9a51f2e1602efaf5d089aabfc087339c639d6edc9bbd0455387b92eaed94442f881c84a18355bd2a1fb4cb220562a4fbd3fec01b738477661a9f6db2ef0e7e4b690e7df1ac422d6997c2618847007140cfdc50ac728c6c662913e3ef55ebf7a2192f6f5dbb4da6883dedcc2d2b4b217df9bcce2d115189e1888bb64250319f03b646be887db56c022e78cec22f399d0fc4aa4eea7fd0f3253ffdc6bd7e700b51ca6b3305e04529cdd15691a5ed325d3c6c0672a33c7a451f25e49e47f8b1bf9576afbaa4efbb75c6769798a4cf9314159dfda1f9c298e41b2977e6cb3af5687aeee0cd3a6abeefbc263d9950da3386cfbac78dc4c2e01a9d8c96812585c71d5fd800965a3478bf59d019c7304b9e51e1f47bd1d72af06187a56a854b630c0a3206b288cb4e33b6ce34ad2074b7cef7b119872898b0717fbdc4268cdf581023e78b370fadce78c3a742001d939afc8fdbfb77e2c66063b045f4643a5c0772cd646108d25a27e09e0bb079130e4433d10d925d6372630c306bf08acbb7a0359b815c4423029c70481e6907c0303b247e0831b2011cfae97ef168ac0bb2b5e5891378d75d352d1aad5544772ecf57950007d983768c583f90f9a65c0bbd1a06eb62e37ee5e9fea3ea9a64703d069c8af6c54995646c13c3c25e6b4baf63f10c9cca50e16bf6cd973f6b50da002663b03164d47f862754f94d54ae9d3cd0a19503183300ffc261acd3c89997d11c7af37e9fcdc0524964aaee2a087c408f46d4af2a995c78a5f4deb7c8fa29238511d746231bd345fe70ed74d7eb07d4c59e9a9225ace069dda78d29cd9f8434a6ef60ff170d7e776d54be4e06fbe1e9fd9b81c1134676440ee0573faf970a62763d2db954bfc564406572b0df785c0b8ed9bd3373f46510ac9318c75ae9b1cdd3826d2ad33d68788d80f781986435709c6ce14f3633b03b2d8c410b98249494d88de318c5524bc9b2356b73f11c794522ddb9df9df9c701b3db0cf160eeabe1ebfdc452618e6060105161fe749afcd88a50f366cfe243dea1c3a5888a19f4ca7195bc29050e3e135af064c6345df1467e18c158289709c68b5b66914e1f8d7ff6e47315d662f850a63bf7bf46045909b479f1975376aa2381ab2b6fb834c4a1bd3817b02c1b0f0e9b085179f51b358ba2bf2ed3869e0c76fe992023db3fdee8622906c8655c9b69a078f17ca6b6c5f04e8b5ae54ba2bf6ad9c308c1f3af7114814a8908322a73a1e3e0b307a5993ebd5bacd98bcedea1b41c916b11abe84342c85f4ee9fdbad85a9c26339711822ab6b5c2070c4acd2e0e723ddcf80d17e37e810c6e5e154277c58ec23ff02a8ca50504be65eb07f9571fe41762d1f0ad47c025f74b653fac99809d00758cb71631a6536723ab403342b34cd0e819015d8cdb429e7569c4bca1a34b12ff2aa1a00a2cd1d52ff1f211dfcdeb5bf397a8fbf09d089830f935a872441400c3bc3165f1e2826dee9903089bb90bbf7408b0c929345433c379b2a8e8635783c3ea39a6cba5c7fb6952f2488578bf3fd9ad80e5e91269f2fb8b53ab5f870a22873623ef99be5763a6a242b062fb22134488e2876b49f2568cf2ea9f40c62b203f51e21770fd9f583f1641148a540b8c1b6d5e4fbc1b27c3e5b07a5bec23b022ad9c9c76205204e5ea4601a7c0c98c7c5c9cb7c699cd77de807c099d57100a2c418e59e76b79ac93a275e440b5c122245232bca304ecebf8751cb5a7b4fe922f6ed521fdf0e2955c49224f503ccd4bf1896cf00d3ce6328701072e5115fdceb8ba9544d2380bfdbbecc73b53dce473a72508dcc7ad97d4f8a89f50f854189c58c173f226f9a64465b71ba4b85894da312ab95ffc388202c960d8939f48ad353bf2c06b8f2bfb1ff5f8a7cbb4b412e6b2d3385c0eec8ef822b53b1cdfc51c37c1fce020563f1c71459b0114e2287e3b633914fb7a901e6eb5520e44e641021ef0cb62dcced5acbbd4335514fe7c9bd895eb75e205e480638415b563acaa59d6b8137d30759ad7e1a20d48eb1af05a8f0e44d348f28247a4256191a5b2770133d2fb8027e3d19f940922655748adce4abbff7e1a4c732a64ca43a12ed0940cce10d930ef4c095beb6bd1da922624a32f06202913058f2472767af0bbc9139258afcab3d7764e849c84b69be2cb4ebe260b01f9e9b9f6b8cc58f695073ff9238249b818d6cdf2261e5994bb7b2e4b16754b55cc5c9cd3fa3604517fe79d0f82078009503d92e6b884c1304ede8e76ba8f58a55eea48d4e2062ad8ffa8745f28f1f78dbeef2f66f2e77686392c7b41823db1203d2238113c59dbce89f1e2205bcf353bb77c8f3666914dbba59600ae00e7f985e66a15592b82354a2eba161b37545b4e7bb02077a4d4539f99efc06062f8be624a4225c06f94bbbdb4e5d8fd986c43b877d7d37214b852a63ac85219da9c1aae5cf8e430c1c400337dee766a99289a9184de6542989179724bfa8195bd430faecdf97d914ba23879f5906c03645a70cf4c8e16f36eabe891c5c01356e3d6babf686d6f022b85f0bebf4e40347c1b3f66b7e225d64e73536f35849ac73864ae342494cf8394ad90e160c6a1114693f2a6cf6ba4405e72d90d5d0b0163a6df4bf3afbdc59a11a80770edd355ca42f613deae1921c5282ca4071d442485fbd142ea32ba684188ecf2afa5b9ba56a76252a71736944d267ffcf90f4dc4bc5ed4aadabeeb69c6e0c030b756d0675925eee02fbab257dadde9e932dcf9c046a74cc18a4c5ceb240e78c675db5077e0123d9837d84069a822c13f40c946d9193c73c89d9c5e153a23831a38cd624603e37875464f5ce2e01a2ee77865d8da4e2deb875ca3526e3a43c35d28fe40581e509bf325c2f339f7ee5a02e05edb5e0bf69fa421020eaa623ff15efa2d6a6b5adcae30f5e4bd0d5e41ae39885836a477cef7cf1264b8581c6cd544ddb9dd72618aef60342454d1d012bb611ad7a5aff4a7a5ff32d2b885ceb73b2f61f63b12c857cf0f05b7388dfb66052753a94d8626f91bfb1c99be73edda6ea8d8d67a6db5206841dbde088247f1d0e1d905151bd34f02b7c94ca0c77d3b57e36cebe0cff75719b67f219dc5f1d19265985784886a92c2e992658776b98cb7bc1f5f4fb1fa0c9ab50be2bbfdb9a48c9e6a8b0005264ddb80ccb02bea46980f3b3075e803f7caceefe180c36be2025aeae663315587ba4c0ab70a80357ec5a56cfc6123f31d45a911837edd541b5e59067b4536b1e780f36b7dde4cbea1bd47fb5d536e7bd10f900c491020210c2044bf3cb742a0713fa0303e413b5c585e773ca5e2ae3b7ac7182a3380beae5138b9c0e994b734f62512729957bb6a930b1aad7d9ada1733765fa909897616253183222a8c607e29aab03efbba55d58479f90658bdab952ca1d5b651f1ecea722a7071a4f250958a599e9928e2c7524973557a537ed8d572bc1ffa6fbaa302e123c6c910c63f3322b48f1641369359fabc7fe7365e6e281e3c5abf198f49ea23b9daf7aaef6740a1ec1bd8a886dc478c56c62fd28b352c9fa9c71890ce214ea6c28ddd02ff875f30638b4d9da5d2721877d6a2dbb6921e7e4632702d95dd50befd0cb2d9449e0bcbbb345bf6c0de48bff7a6b9b07de03f17d160eb52420cfaad114964054fc946bc563aba403a5886a5c297b19afb663a3ca25e6df89114c855c65c9fb02af416f972eaf6864f2521ea624fea1341e03f69e1ec7f47b836815b37144e283380f0d17745c3f5d39d819a443bef199ebd9f90e623c2970c8536727430072a8f20cf41950cecedda97e864c8275840e4c701ac9774a470071e7dc10e546716d23e3db7cea8d7912d14dea0a403d601397b0d86a8f2d1551ccfd8d38c26901500442f8d89125442b7eb25d18c337fedfe11da68bd16eaa7cada49c2cfe2324be0c9caf0550204f12e1f60395950c6169ffde6dfb2871c7618751c8d05fa5ff2253100855eca9ce61c300d6651cdf49f71c47ca60a384422231f3238d66d2f17b063e9d093c430f390d080cedea360ee856189fde6205af1b3d304975c85bf60dfc712513622eda61a4b0a5667955e941445186ccc2b19c2a9810662eef33b3b1db0c6e893824cd027e550517e02ca76966b7d0b990fee8cfd3005faa7183ad456ff4a015f0e1162929a62ddd25ad53f34b393a46e93e150eab4a517b02d7eddee00dcfcfea8e631b216b79e0deac07ba9267374a16936d623f6674d3a3604c35e68cf365bb3606d6b8e2ce9e442311f2bda83c0e00c6a4534f740a8031f5dc86fb650622da13eede62c2e366e11951bd72b354e098a42fd5ffa37846d0458eaf67e3007cbcd4fb024cc16b176ef260cfed37cc463302ec9b9fc7d2e7df07172743d8d6378c5c50f2d85321a9eb9e8d71fb9a2659367da8df27e606fa385b7bf78db941a818f430d69c41b2cc115eb7eda8e37473f38d36d2389ad57ec819087c911e40339a40e786ebebb6da95156e98f519795068268c4d1986281970a307b31d455ace1a6c04dff10edb09196e05e80b80229c6315c1ace7c91a15ee603fdf3ab1d84220951fcc948b93f294c5f8a5797fc31728effb7f86861db519a4d7dd38b05fbba1fb58a67c8d8df709be001384debbc935f23ba190d93c119c4d17513afa0b6e302dcdfb7c0bb6abec97a68508c9954dcef273c7b3c61f6b598c3c4d8323da79da3d7ae44ea19f9c52699503c655314a8b10e16317efa4f16b5e861bfede7029edbf4ff65ea3048e616f865f54318fb66507f762677e7d28802c2e4f2807544f0bc1f15e3765a56ef8b2f78c5d6052a7c6bc95936f2d8cd6406a8be03dcec64c1fb7357db7e3f38634f4397ccdb56aaf7fe6a1a1d7f36ea927156295d70e52d5b713a6410876f77ae1a750c51c7690e3f2d6535c305d3c671cc6784fb8de6258779f0072940c0fde6afd6e936c2900d4d9455aaf070d3c3a68ea71d2ce143b0ee26dbfe2bca425a76ff50979c2b44703791cc1ca24f9e5284f12eee1e5fadc2bde344cccaa4cc5fefa6dc77c90f83aad888fdd82e912aa9841cc1aea111043a0a3450485acbcdd4aa2be96ec9571e78dd581facc408a2318df575916831232c805d9e5c04fac4f5fffe586b84ce14280d31f37bb36b563b09acbcaa2318569644093d9464f6fd1758ba396d67b992923d83a33c08ab73482bd10cc0f33aebfa7817611c42fb89c8a265fc0942608d095d99e00de4f1bf61555ae71ea01730f59c96ff930e6f5bf3e85bc28cfe7d7779505631fa6f340e5efa3802e128b326d18359c6f301fd67d6ab5c7330e1251f6d177a58519eea4d83636eb317b3e62296bae09127b1248e5ef4b1c7a15dc665f0aad79706eb942fb2d2485ff925b31a61d97cc65db92841f0622652f47a6e11e8332048823893c8e986519fe827f4d433b1cca5f3af85c62365a5b18853d9ecadf3a5a4734916b69cca2ea7b7d1a168279e4a6970e07372ceac3d3eb917c001470e5a3a8bace0389ba2d505f497251f8dcdb047b3abf0798ddf2d7409776f1be79ccc277d9075a6e0966c03d021427296c0eff79f1251e999b399457c9fade0ff90d26c3bb71df5131db45ad04c05bf5134b67132918c61b73980fa27bc1f3918c0b569408d8abe2bb27e7ba69ddb3129007e2b7027b75775cab613817cff0cbbf4c5a38888e1f1ae82b2df9a17e36aad95c73c21ffe209c448d0034229ea3a9b142acd8b950212588341603b316948aa15fe7bdd002e640046ec51f7c6a5c00c5f2fd18b87f6e425a9529c5dcf439cb62d360480bdd75d21d4cb280ee7d4d945e5ddf721ad1bf71d5fe0d429f41436c0794fe317fd20c4fbdf1d18502289f44d665f29c66958c76b447df551ed0457b47a28c745699f76c89ad7c42b797c2819c2ec181ce4022e4cbc166e79ac89f4b6c4897a0282fa9373b5e31199b023f0e89a1cd4ccb5b15b3aae74a9d4f08a5bf28b6057401fc3ba6a315ecbf127319d97d317b43bc2902e9bc9fd96795516753ae358dfc7b100904fcd9354d3a88a201deb0ca6e241bffd82b459326137cb496f826908c767ada55873dab29f13712cd6e2eb468ffa22df512514cf4f277ca24c2d189f2c000aa9c6c9824fabf8901467f27a8b2583d8c34961d311b24f845b548888b8f804bca5501e1300e2ba2cd41a363512a4a1778f1db259da1d8580c1f268f47266a7d4d14bc2e85a733a58d09634fa2d985fc9f35af67d8a09ab3b297eea9d5e796860bb3852dce8e16010c20658c658db2d1bc587d30108f3b0a6ad7e61c0d68fbf05814a421e06e1c0ee00125d438ef9a8ce23d97d4be3a3c4636d8f11624ee4fd1853395b9b16f81f4a76424597d856a4d8a793287ff458ced98c4d6c23a47c4c07933f7bbbef2f65d9a400e31bd87ea11c7051aaa502d73bba1de23edbd8f3a05c65e2f1838ae55fb3dd30d40530f749d24fac6f61e48706fb22c0b4ef85ee94c2906ed61ee158b9a27341c46187ec753bdf6394c2099b82ff29c5a7d7debfee383fc5c149dc7cbb6da01a6071b5f28947fec48687628fda0ab42ca1f07da5c5c617568d7ae9bd59207e2a40a2248152a60b3f7c91a13f572bb1ccc71254d89c03d261cbc5fa87b56da038ffabaca47621bbf083186f352d5c74050dd1c8dd7c2711954a3605a6a62190a19e6a5a28b0a8bfd4d8caf4f757ef9262f9f1b141e6c3109b5b79bfa5460edcb21a7a1c918cf55ebb7cc13805f3aa083703c2a654f8d31b194a1510dbf941889dee28a721a6f34b9a68fe7d41801de5e61462cb01515b05e1ab3f00021e5723c91d29fdabaea4e670dfed9cc031dabd126b736a52c1b237d01918446b343bc3533e0eb79a2371cdaf4f76d602f039535daf3bd27872fb86d3e96addc9968fd6f532bb4b64d15406273f0da37c219eeadd1da7381708b7402a8ce83b2419bb11d0d89299665d1e96c6981501cadec615ace9ae7d6b0b1040df6d32eaf3389e7cc4d718cdbd169377bd683a632b931bb05d60a4837bbae9c52e15bd065da4a38be55632e17dc426365b9cf584bda41e1bde59f9a3480d266174485304043d1fb01bbabfce3c7648d95450128ab25eb4ce83a9c445147d7f6622c73386308486018975348b969cd62757b62f614525c9a099b15e257e4f4574f4c27a3a25b5b196f295e04168a7b6704083a77bd6d40ff46bd521a6978c70b79a5c5d707dfcc1c90d18060b5bb9720b4e23dbb8ee928faeac0c2d4cc837d4cc6dd64011110b50efbd2f7d4fddc862d01a93c70165c4822e3122a967d3bc0d50cc926b1120de5ea5b2ce3cd7f1a2a2f67331ccbae85ef9434736075d66bf858940bec4f5e51047f17c425e09c5947f59ab21f50b8c1e6f42200f1c32d2c474f66b3dd17812e4335b4b9ec5a45afc3128894889d08686054d243559dd2ec61cc10c95e9e0ee8135491b55526f5f61b24bd25aa45de99f54ea0ab755168b97413248852140ca023728b8d02e9f959e6fd711dbd083ebba652b033c0c8c91f990e6eaf548792809411c1d32b5c1b524d82a92111ff0b3960ac807a994a4ca243c1201c5dc14306ffe81b40ad0fbd43eaf37066ded91fdd89e0f70d5ef588600b869df8485c600fbbd88987704ea873801ff9f5b1b32ef76bdf41be5a50d0fb04b98430bf4a77f07e69cc679e6cde76bedfe740071f2440625c7c3913697268b095ce8eb398cba1b1d093dcc12ca42d600f95d0f581c104b70ae4690496b2cecc15a706fc486eff2eb751a0efb92743ac91d3961d42fa7a1a0033c09a5ec538167eb288ca059929deac6b238e9f9ad16b86b53f55094e9d487cc3c13335c161bd12b72ee1a43a770e5841031f4d96b118da427859df89843313a00be585305e7332b9dff14857ac864975846a3d243d525cca710755a2aa7ffba82ff5453e458166a8dba2e6ff92fe6f17c374ae928d58dec3b4556d591303af67a5fc22bbf3a612b714612c764dbe8bed957dd3c8df6626a3521c0880a08acbd44055ce8563cd7767f15a2fd9688fc966848d028d95f4c3e51bb0d9c892f59a0bbc3c440f8008ef01da8aa44c98e4c6e1b580e1f4fdfaca564501cacc1f666b540f99b762945f0012090dd02e67e82ca3e8042bbc6d89681d8e9863610904b0a5053b87965b0f8b1353cfb13de0c99b8cb4619dc636e6dfea7459e5e5973a3dd7bdb7d52039e4748618a1659180a9a29959fba9c934de6d77c9d9d9a3e0d92c33135d69fb09815131903000bed57f38f98b0d98c2458c0df1fe233338f109bbbe0cb46d736787cb44f18912c7de3195b38ccd54d2ce7de92c78d27696d565579435dff778dd17515019a3dea2df75abce17c43997dfff1862aa3c11a7fb589141e859b9579e62f904f5a449186d82b211a24b1f0ff3aa3025f8d32f75eaf9df106c00d21ac1aa7b1614e7a0114e8d62fca3034694ce375cf5b13616a70a43a041f33d1e78a0d57d3073bdd4149180939d8bde55ee1ed364a3e90781f5298a5457c3c6828e22b83641da7cb6e802f97dc71da5f18af4afa2f461ea3ce86eecbd8659bafc1bbc8a9d809fd9b90dc7b820e34bec63d6607484e43a8a1b69d386e318424ffea9f574c7b3a8ba6e5de336018b62d9bacda393cb67e4df8d1af3fa0b98d8d0e1d24d2a3b5cf2d0030eea2de6e92dd402135bddb46b2e0b6ca9a917ccb65db0a349f5001736110ed26b6542e51facd200738ad14845342ecd77becc1a50fb1c1a8287004b13f2af4d6d50c99faca15330962ab1f6af71c0a0119ff78c008a473ab9488fb7eafcc31e888c46c106efed1333cdcae399b811f4b6b1e8a9a9e2d9aa16983e9714e62aaa3bc6b2c25bf19232426f2a4d07f021dff6cfc8bab18727c95a56ad7ad7ffd26718dcaad56b53a78d2438e29a988bdc0082c977ed5ef2b69aaf17f1c282bd58d6274625d4f86277248f098760096ee503937031160b272d5d3c8baaea4cba6d939ab20097723115749306bacdbc819c768bb3645165a565f3ed8701d0fe1dcad8443b34d39929e744a081f60a22bb7433f59aa5ac2f6f2088368c16d350d50163c5dc2d86353c944aced4811e7f6fb4d44d44bba39f934fd65b9a974b84913bcab91ea4913b6d34bf68d17deda405c461fdb4db743582a7a52f6f5b6f2b86f87f788e9bf284435830577dadd22d945f29c1a16e22ca6bedcbbe85fb054bd0ee22d16b214972682e848c5e322b60f87204a881907135c569a34f8b0b72fde5aa96f50065ba7801b82cbb31175e1fd8c4c63de666ca9d0652c76f92d01584285e590a636bf62959de6bf4e271dd5aa7ac615ae2ba79022be4f6e81381aa538408065041b4fbed782d383aa1d097c9bdb0b8b64641a2ded5ce663c12e8d917a1b6f40b0d9f2d6b6ca3aebc44d556bb87ca8544bed248faa5a47a6de5ca9b9a8d0543cbcac1e0fda43c615f3a5f3d1cb75611a2e223bab9c1be61305b6dcf74883ea411dc15558fa0d9c64fdda00c1aa2aadad16748e25f286f36ba045102d4a31770dfa549ada18b8523b0e6a2fddad4bcc68e52667d3b93cd965931d706c32ffb335ffeadb6b4e0bf7082c2dc8ead8ab85137b40b2b52eb87b124096c4cf28323e2933e14b9c24e82d86a96dafba7c69ed8e56be8da0600deeb49e09068b210244502936542454d29380106684add03a9a042d62018bce4095a65b7f86efe7c04238ce4e5a68d2bade74b6a19786e4b4a20c24491dae98b50aa81a80f8f398d0bc38919609131802e24155f9bed2bc68b837f614be846bd0a2cbb5942e0a89a088568bc3cb4c183b0d0f80b2e591b86652c8e6f59a835dc027051965371b19dbe94cd5c4205e3bfa352cdc259ace45a1121c1c8379ab5adaf0726caee8dc2f50dd4b04ae79809fd72f39109676edd424abd9a9bd1f49fc2d0f0737edc4ac9ce261db794d09d8710d7008d68d3d508ce0dad8b32e7a9cab4dcc23af8bfb597c4e8f7a7a309be8fd8c166be0201d94631c603fcd57021cdeb875a2390e3a6d315d3e438be8c49d9dd8d6f15a11c9b2880581470d5bc7795695ad7a351661149606089c7973dd6effe1481f7476e913888832497b46e7003a3021eacb01acd44222da05c0b68f43749b8aabe657a03e5b50b6732c01405b96f0bf00da618df69455816cf665fdd40e413886c0a6948e07de7d37704682ae97ee71fa8777cb763ca73620bb2659a8f09fdd6df93ccd1a2b53a8dee3699787d7dad618a034739e1f6b13ff2a263fa6583a8ad8744a2f0c7f590b163003878aba667a7e4ff0c9eb7d358c1a467296e1e89cf82ce17d49d69ad0232fd1aeb4e7a9a5d0df86bb3d1180a18bfcdcc7d91e3c415dd2c73b2d2eec6aaed0ff549870c5581e3b736f3721980707ef76f0f1162f20cbb65accc07e26bd1075b36104cca606e4c1419c7e14f237369e76fad033f21e0d7bc381de4c0eaa78bdfd79210224d8734b56491d787b8c9912de9bb2b9b02e243447f575b77d09e471e5ce7390caabc297df85ecb39d57ec74726c1ba0594a4d3c463089961e29f19da862fb1016203e2252c7eb63647d577611b5639a2ae5e36991c94bf91abeb3f3e9452f69889f8a5422273126efc2500668372bee58c17b05c43ae467af9df88c94e8585e95389d1a722dc581bd0728abdddf55f2a316c6e1abed0cc5017ad80e8c8b0bce4ce879d162729252d4e3884f33cad6d3890e4f8e15872c263ed46ad0dd0e7d72a177057564d8f1a918e3db08753b5dd0eefe290daccb8c13d1d7ef5aa1b18ee525d7a571bfafbec1f56dc9ae95e9b63a74a97fce0cf7c127aab5f87813135d559b65b3d7375c629ecac07d083e258917d6705054b2a4a8b31a2775293ae5dc97de388b7e1e30c9be43b1baf91e6777cb07c3b716599dca724f0b96dba01e650fe3b2efce37050073172279c97e33b18a2b60a08a709d811e290caecc8433e629ddb5d57a14a3a3fb0e590702004545a34cabfe484134e2518e9cb717dfc0f132ebbdcd8c0c77950b3e299e3e1dac5f7fc75db63375e9dc46e96c06315f1cd4f06d16fda2f0d39d7d114ce8ae97a6a3252ec9c8d7f08d1aad948b1f6f44d35008d0579194a51a4e67112bdca98655a939cdc3211540e2960ae8452c01e0828d5f8bf524406ea7041d1255d8ee068f3288271bcfedcd6cc295dc8185755cdf546f7b1a490a2c61869bf39559907ef17ae534f8f19539c2f7c9ab1c4d89c687f36929bef9d2134b32bc5eda90c016f5e7b11227cb8ca6b2489cefc9fa2cfc90d54a05307efb157e35b2312abc30e0bb8800896b9e695129395b565aa83d596f50361711a7cb814fe1301663feec6e512344f25f781faec07898a4c676ed07554f0e37d8ba1defb8526f0205dd1984f8fc8a76f6ab91851409e528f5e8ef8367c88be14201d128348c758832f5bf1ab53f140ddfaef99b7cc7909dc97bd5c9e5fa2d77e5247836c506bc71d4b457c27dfea9d172bf2d7ac5118f622cd651332c1b064e0e803b7c1c31ebc8969fffe15b4489caf8f2517dc655d3922f6c02e6f1210d453239e30f71580700274a363b70f5611ec70b4381661fdba0aa67bdfec5bbbfc9f8db1634320e760ebbbac79380edff6cf94fadfa6905b320e253e88451f7d84916616dfca3eeedd0aba4c354c08254de86a0fc550d71c290c24f1525fbee3c19cd2eaf23882aae5144c063700c5e0644cba3692cfba964bad0c52e6a16deb56f1d480ebf5202a53657ff5dd31502aad0e94a7fadb528df598e6943114259d4d8633e7f45a0a94367fe0705ebd45b1a8b04f52a85c50fc491ddbb310e94ac718a141b552e2c0d83b51e2aafc2ba76e75162b58228b337d04b305299a187f819e277f656c54cb19f2e587011f15bcdc60ebe8dda53f7914428d1f587afe99c6322f7ff6cdccef6eb5a6c378974ab465372f65f4265003b46245c41588a935d9411185858de7c9fdb0ed0e1a8421c6a9ed440dbf119945b5f22c3012ab6732a930bb50d1b6c92db163971dc664d09a41f2b53a2caed83e2f692368105fb7fe10454a6849425083329997c25bd744d374728a49649a443dd90d36b7e9faf8663877ab09da201b6a14f6c5e7632a73cbb01b08d8a538ac05d17e4ea176436e3b7fbe80368baaec8cd8708c55a3fe399c3b84f0fe0a8ef6383199db89f6d37aaaa7c33b68da9224044b2b9f41d2b14fd27796c79813965390dcf57dd822465020b7137e4f816f2fd7ea8c20528e83408f25bf859524b7f01448d693c7d887e62d4048062a47d6f3571af66427d7f7cd00392eda1323e4d74de924e2a85b294efe2025f00a8dfefb610723d375f125422523db0d66645d0f8a0983dc54016e352e21e8b2ccc594999ac4187518783a038427ee16acb1e7b22a396d5b757b44e9c5ca72baebfcf2e28f85cd8dce4b5985e19a48c42941d0b1aeba06f18b4c033efcabf555a6d026ad1dcc0d9797a863828405dfaee1d5e4330b2b1eefb613c7f3aea887a15c5f705c692677e7b1a9ea3f2d5ca2753873d0139e4a414e93b23dd7a511a04fa0b032fc72b573e409e4d15656c4704290971a0af51a8a3339764bffec4c88766a3b03420353b9d02651eff14cd03eff4062e01308365950d2c0fb1b29564882b67203ac2d43774889a93fde31644a1e4b10b7839712e8c4d81084e866d026a985f90886970db5e7ad717f42195ad0325b7dcfff8b2154170886889413bb597c7b6509411c9a219cc8ef369be38fc0624e15862e61bb7db8295fd925f13e362e12a3f7713bac262268d0488044ec648ed5acc0bdaf76aaf533ec0f13ee2a5060a475885bbdd5ed85020ad7d819b5de98eb458fc8d0200ecd82884d0b9f9408d3b938ccdfe1fd97ae80c458417946d7b8d4482a3d784db9bbd7bd429913eab269a4412c3b115719f51d2ec9d999561c29deb4de0ea5cd52a8d84e7c4a5df154bbb9c702f2ed346a15989770a1699e2d07b38876b514c183cdc97c3844ac9b65ffe415d5a5d951617bce5470a20d6a752fad833bf21ff1db7ba0f2cafe0d9e751ea7256b25d2df5d32b0a81de6bc8571bbf46a3b03921e1808a4f8e771a096524f7570052741c3a81d2dab8b303d0249fc82481a492d0302ab897b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
