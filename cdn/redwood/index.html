<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0c418e98e0313836a7dd31013b48335da8d06cce483465db20b987366b6729698daefc65562257dbb9e50c4adc91b2e387146b7472d57b86cd303bc901e572a04e02c072ab9eb38ce393b47e589192dee46809c03dbae1ebd49eeca6d50f10b263de5f9f4fd7b79a94a444d3d20535d6a4da8da5270bee1a94bbfddb0de0c54bce7aacbf4bc19c8aac3bd882e9f2d3d2cbf218829359bc26382aaf6574219e37ab29f335bdc0892aa03dd2d47b9730afff7b2f39a904a9f8880a0fa5a0c379e4d98129e9009df4cb33f9be41ae3e395ea3baa490bb2749c399866dfff720240d20a7595df7eb0d92ee025356291b00497f16e5b70fe7ac53bdeff8c566bd87f87fc85810211d4d1fed945ac01532d2a4b81bfcb9566022fb4f4dfc87433fe16ff0812972a2e88341d1fdbcf78d351c9c957369774ec02a1ac1fc93b6c1e2acc4ae58ea1a9f1b3450395e8faf24dc85a7e43ad56d6fe69e82905e5261ae711e32632cf87bc5c7e4453bd86f97971fb281466f23a63d427e34be1a2204f4069990382923087fe89f491ba517946fba08a55f010ebb50f8c3bff8b7f1c4cdc62a6e2640c335f23f1c572b695ed5f8cf59b8ce42ce81909b2f03ccc1a55e248c3147444c2ead5260d626c470b585a56b75a2e4cd0c0df91bb80b93867b1b986fb71779bd6eaf864fdaba5f20bcd4bb7f24ba878448984605a5f3e46c94feb1db29f67fbbbff2f6181585cce9f2ed0b3ea2f4ffcab2e04e84a1a23fa36b9fc6530a7aabb4b7ee1894ce2bd399b6a22f300b9eaa1c54325b3ec089826fd4f69aef9b8b5d4f04fe4ccbcc424c9523a72140e9c5f0203b79af9332b057a4c277fb41f51b1eb46f64ad6e23176bb14b914ec35f82ce315ec80711e80aaa36caddc67a0980218b8dc157013c7094d178e6dc4d7cbc1db808a16c8bf33adbb40f5095c0b3a64ff855e4064c32f0c46184d263c506e1da4140012c4ef3118b521df670deb177c713930661116aa673ac576d60580a31be30ea019ae93f7c785e2909358b72fda6db0a8284a52f6f37ee6ca4aa16b795e0f905d5eebf20ca53ac1dcdb9e35fcc5390da0bdd28b17b229539149139a06233177a9612c3cba8e45d989778747e066b3628ec5943b211a016b62cffed4b71fdc2425dcca4476d6ccf7d3cc69fe0a2b29272da715ee59c62534137facfe6bade97a6c407fb7c97604c05d59341e652f3c0de9c34ce92a3566b6c6723bb4e6eeae9132dd09bc351ac6ff2bc8dbb853545517c760b908e45c6d2644144088f235bd1df717defb80ec36842aa6f033df1e27445b4b210d6e8cf1ed850f53ed54034925bc64dc7c1c6454e76f9aa558d0a563b10ed07d62e43f1d698b0db66028ae6c1526a58e325e936dcd5abe66bc264017bf6a3552eb93ebe5632f5a9a6253fd75dfd89e732e4bcccc1fa808af0c25ad7574e13ca0994b243575a170cd83944da36ae38f3d58d3db45c81f00fb4a3b6ef94f13e2ef6ffa0f3290b7c5c6958c1639e47906d5433bc8c6ab1d8b10e56ae10a5931419e3ebba4d664cdc2bdfe3e2e1c263cda64b7394ded77b1ce8d57c4774f5eae3b746162bc2187fdcfc9dc3a296256d550283370b1cf0cf5c1a6ebf2a34edba9390d2645ca31d73ecf27be1608bb7173c237aff68157bcb6818b8a1aaf2f02acb541ee22522e6341ae8e730bf965c95fdb495995a74d829cee06a9e79ec8e7e8a9d05aefaf9c324b4ccb066329f4aef938180f6945ba150459fc3a3cff485db30248fb8835ab685a49e883e594ac053ca3847adb7d914f8b5620c32e1b960f8962c3a903b6fb1fb3004fc44b42f2ffbd02d6e440f445a843446afe0fcc08bdc87bfafb14853569e66ec8862e2c608c10807b1ec126b921f5b842069af2260038a1c72ec25a2d36415fcac5afcd7f0723d6a9311263f904081710cdb092920279f3636404b0f797d1cbffdea3d62e6959f0dc3bcb1972cb94086c4fe218e657bf1bf7bac037f38d9074d664b4784ed74e189561626fdae3c80d67f8ab4cf8fd3681dd58d8b50c3170d4cbb1e87edb4cb0c79d743a72a28c25ed4e14800b65dc09168516a15da6311161f2ab11f75a7bc69461db4575044e9ca34510e313bce0f4bc205f86f365e86f8e54db5341128ea6bdb5768b24927e47b5d4190d696af4fc61f7e4dc9fef2de8efc0d31ce2cf4805b02e11f59daf5ee2e10e77e0e0c7d3361d9d406a4c17195df753c63140f2c5684daa404afe6ee46522646ee161c937edd3349c628892afdef2202f09a1ae6c955efc5f18af7e75e088a75472cb7203f6b88837f8fc3c302100cb6ba183aca328a338a69e90619c47f9eded286e9c8998c69440f071091018bdbac4230ae97bb9e4dfdc5187247d8fc42bca62187c4654c41ed7e1c4cd699f15cce74608f4663792328ecff01587879dba1688ccfc1170f9228a7ec79469c97301241513b023a6b5872b541eefbc51f3c4d2666304a5eb3f7301022f7f059639e79c945c825415262006bff6a4ebdc180941327723e45149ac36395716e565ef907343a3bd79f8711e1c2254b17659d6019b7a5e289bace7da904489aae4c38a792aada4948545c28648337e0a42f5b805cfd83b1450f0fef967122881e0a8557d9422f80f35a6910edbda848b955e18ab49d58b687cb3f61f7bf5b2c0746ac820331698435853fea194ad3ff2cd6c540a3d6b8e29aafa24f952b01aaa52f64c933186ae532704249a3fe521a74f7f41f9ca25d5693f2e93fcee4c9419b1f4664a897e0db73dd5ddcdaaf914c0d931a5f6632f96c2ee6a83c5ed8e0f3c3bcd3656a951651297ad34747d6a4270a06191c6329588fcf77a4a59a6f610d712ac399b122fd3db737e0a098fa41deef36cbb80daa70c9268df71968df9ba6e3efb2e87a35ecfbac4b3a79dddcf6d72262beb806c728cd93b7624cc09d5e525ee2ce68f8b2b8f0bba8b9f92d12a3959b08c49ffd0c7a7345dbfce35091fdd981deed38dea0dda8e0c6b78ba0c72844ff8b8ecbf82e3eba49fa32f396b49cb66c1a3515d3b7c2f2b076e922bae1022dba610650945f7337a75f382d1d1afbfae0748b8145fa15ed5f448546132c7892fe70d75f3428236da881e3591354fa4d563bb0811ccd91e3bfe574cee773a5d9434b93be528258a66196f8bc96e9a4251e934cc400104d34b8a185c76d7135010ef84d6e41afa4f24dc4fae7ec1b1c473debe4ac57e7923215539a26f8414f9fa03321562b7051b1cf08ab0958fce28ff3eb0bb9493a4fdc4320b470d79bba2a4aa53f59ee8128e698573cc0e03e22603edaf28964d89bb8ad2ed0d61c40afe277ca0f511776046d89b5e5d70ec1e5a28ae5a0964abfe2d5948fecd9c44ed08034e7c20ceb142139fb9444ac5dce86b1bb787bd3492fad0510d3b2d23affb2d4d3d39e68682004456b108a5aee7cdc266614beb88ff9f4bb9ee8bfbd476d9182114c41b01527282fd8ae6d221eebdd4cf67b164b82af144ab86f0adcf1f62e030fa6d9e498ea92c77ff33ae8726ff84471e0d600ad0e0a38b7204d2ec92cad8d32073e25ef8b66bdefdf39c7af7fc74797c72b1ae670610763bbdee28a53ae9e0a060efdb2b0b4bf95f6c8a20b9932e9cb797e2d1aed98bf567ccde799a2d85c55e9f40d23efe4c28f145304e296734506d68ebef00c9b8e967fc9ef2e598305b3e861aada0689180452c84a30b6db4a6b49677559cbe493bdc189416abdb1f030801d73ff5be23a6bbdbb517f68099d791ca6115437d691df39fb5b08ba0c770313dbc1d0e88b9128ae89f90ee74587d32cff647dd4b72913f1f58f1acf04dbd2d64f322ac2361de9d305610ef65a85557d6f4f868500dedfc82ad66a59fa7991b20f37b027fe86f8df8c6685c05ce09173b0169deab565e424d95fae8f778b1cd518aef8e91323f6945b25cd9d1fa21ec3ac320495d88509da2b8f7790c2577ad978c5effef70627ec3fa2eacff7e860e58bee5032a7a32428a8aa4da25f2a43d21b4a16d9ffbce47ee7f8d325dbff2c55e9fd885f52e921276efd1e4bd06b95e4dfa4883beb1a12e9935e29b47a6e54a943b05a0dee6b3acec7744196873e5691ac08b4be8387cef1ca841851ced27b593a3c5b66360cacb7a98a9de05bfbfb8fdba609702d43dd95565a7851d4b71061569db0490ec07d3c71892e3a7540bfb5f40d67ecde2010d22decf7d4f0ef32d21d2132fc6e7631525fecb42119f2d127589c5fda18e125165ffd17c08c1fe889bf8d797f68f27984f823b027f3dcb4ef77bffe76b178fa792f5491388c8a5116bfaf79302b3aa142e6646e2f9a5dbbbd2af47d250ea4c6c21a31c94135f6d163a4f686f382dc038aeb8a945270ea83984c7726c7eb35e5e304350c0311aa0c34a4160d502e750d330bb3a3f694af5c24d98d5ebf8ec213059c99d9cae9fc9792b031255f42a4a26c9c313142ac86e854b58500e87159dda1f33fff6f36ad3292caf7772437f62c3ca3400c110276dd168c2afb0310f593b67d2c4c022d6a0325c7441927fd92a573e4fb2607192fcab74b4fa9fbb86bff717b1419a58d18ef603bb504eafbd8bdc49b8f8aa5ef854daf8762dacfb7052d6a243776c44b29cd7f19f3cc1442924686f1112c693357b3754fc5d9cd12bad88387d69741f042754290313f8fc3d9cceb076d15f6ef6077826d71cab13f9620c0fac4e5c01592a7826eead4493ddf5cb9a9570f0d6ee27867ffa7f109d4ff9c1be70827fef68a150372cb0213d9d2e547c9cdaf49d07b3d84d85615572b792d679d1c6317bedbf761e4a4e8373f659e15897cbd7e4aeaa873c64a9bcde1e7b3783dac4dcd200da742ea0f2871d23a1450e5ec44c1b43cf56ee924907bffa9288ebae3de108895b69c49f6349b7a50a6499dcc339ad2d9185008c7f74e862ef99d0266deac2addefd39a174454dbe1c8f2807c1232479cfa8d084df90af1641238b0afd559749f16f60b1fbee9c161e9c8e59b3248a81559349c369beba8ed7f13a22f16aceca60851334a806e5b616b06d69269b7c5a430ab39746d08b922f231f7c1ad40bcbc7e1c5429e7c01e4daaf01740c406a2b0753baa70672f93a5e1c3a8488e7875a27e2bd5d4defee627710bcf5c5787f94b97da63233fcd6dd3469d053c9490d58d1c0de06c0ebd2c12b319314f4df540c23555d95a7e30892b1e6414cdf6006250ad570e87eba8888805361f5ec8ca2392f7c9270abe1bcf12fc2968d1f9a251cfe8d1f6b7205c8e7b50da31fdd38c8eb95a43a5b12296ee2ba899e4a5c9a7288380af3a66935e4b491046cfb3108b5b937ff276433bf701d8a59ff81e76a4be5e14680b9eead9a77f036f4c238f97006d5368ef609f69c5540238b6c61ce387dde8bfc9bb12320dd42a9efddbcfd4fc621d53cc58d68795083ef820590de470e8dbfae31d20b7a47f0a60b1f3f2f3a94f25a8a425c6015944b48c446b3bd756c5fb7e9e9ebc0f70e5889562e910d0f390a7ffc5cf4f7282fe0e0cd7097ec69c12d13816e28c20fc59c501b27ad255bd601837c178804a85e73846481dd53d6f71ee4aae8f68b6bab26142ca2cebf37444540f8a8b68a8d541130e9cb8f272075bf656693562cf7a6ab181ddaeafffaf13ac208a781ae4c184aff29976b41b2482604b7f33f934362391c20d3151677a58270b49d61a4a66db2eda8c94595f3743d78e441de9a5487469e6d2c82b1a20057096fb9682dd58326f879755a59c3299c46d9dcc5efbb4f419852b9796659a7e67c6f40f6a79be5423c018408879f83e83964b0a771cc498288e7babf749b4cc187187e0dcb905cb72f208da25eb507a17c5f5137467b4990d9001cf81b2292de499df2b1ba928a330a1b23c26ddeb1ae465a84d7c77ce40fa829f45d6eb0e746b3b0c138af55ab08ccffc0de902245c3d395f5ec7a12d1ed81bf44f7c82e7b50747b5cbfb2045b87fcc1e44da78730069b11783b58e491270b63cf5120c014f99020071dff4157f539289bc073c828798856d20bf7a964bcbe7c612918d4402db53fa26f4df4f242d71440ab13007215e449f979ce62e781f7616b94c2b82f1a105a4d867f3fa002e7f1d7bcaeb820ce91376010bfcd402d14d6952164dc4634c2a1d6b95b3fe574820e2d23dc070314d5fa794f62d6ac676edc8561da98c92eeffd8a137ac538042528dd8e8f4954a4aa440fc622fdbd71289596245d8961e21d7b06d7efbe0714c0b0ede9749830fa08e8a20422bba54e6a51717c66add6a6ecb856e1107e1334883202cd776bbc84d7be52d1d7dfbff7329ce3c8767f3a921dd7f20ac22d068a5260f86fb08f4fe9ed163e9a9bf4cab451d5a86715f7ddc700dacb264eaf77bbf34bbb30e2cc12797e8ca18dd29b25e968dea868b707908644011df6d2259daeba9dd79e0ce447f1500c8596c5aee4bd11de4d1904ed7d67add3ecef0014dfb152c1688c8870a795e23940828b8b2389462981c6cb9409ab3bf6df42fe39ef3d843795ab45f3e56dc1a84df1902d2d591361c3313a4b650d6273091d4f0a6c8765740390c1ac8ab63b814611006864b3a0a36dcc5bbfa3c45522d5076a85a4084d8eb00828e5c161d01659a26d4420de41e500ef2fe62e0b698cb357bae4d0027ddd9c8f2e4b127a6161e707178c6dd000c0d1905c3e736b89ba1259dd6ba0e728488f6fb67620dfb9435717cb11be1fefb193d7f2f422df055a6ef9c822b2f957a68698970699c8ebdd3c9d193aa96d5618e91840f0bfaf86d40cc71f840fdc6ab8bc3dbe7cfd2f867b22e732ea00acf5fd6bf282d6c6e04c1609a8f5236cb7c395da0e602d7859d801d97a89b1714608020c762efab6d634436fdbd7fd0bd0652620d01770611167d3491cc658ab8238ecff6361ec63ee60e9545fb1bd9dbdce4d5db897b00cfb2db673b0916377675138471e1a8f9dd98cb9c587804d93d5094be9870512a48048cce451476e2f6c937316a3dd8de087e3d06bfe8984aba3615d33747fd54a4c07d671d3c8ce6f8a4b6556793fb4b4d95b293ebe733fe87df8a5adb0e731fc9195a0bca0bcc5a3f001f48dcdf4dc0637d0aecfa195f5a6d4f35fdaecc6963942b0bc4a59ca7df4c03b3df2a3d2745a25428741f769a7d53b7a04881c6869ce0bde186c656e93511f6c79d538ba9c7a551f7348ca1f061ca190973ae534022ccbe254e04488b98555c9ca5f3c2986e3cf0938f1186c2310e30b1a4a79df63b2b1bc0275ea09d45ab5b5a38a2b8c33270d53f436d19fdb9b9439c3c098c7f4e8b065ff126ab495f2df47002e9368fe8eeaabe925471bf5fef9fb9816abe4b2017736f302c255bfd388000f75cab691c7c09d0edfae321e7cd0866069b7d8a0fa83e6fe811cd9c09db2193d72368a7cf073ddd272f1d02f113b34597459157407bd832ae9c9c2379ab7745ebd80843bb9fc245490898e720dc63d45853d908255d2dc6ba29a5a07195be9fc16ed7ab1a4dad055354ba2306bc118b3691a01e72870d8a64ad1787ca89e67905f8d3ff9219964c0d0212a82020bcae6b7ed45c5119232dfa5c771a344ef3cc5e4829e9bc7e63fadf3db05eceb352e841926daa3ef4f470ac82177ff9bb9140e256cf75b3fe6a40fe0037c23a070db6290fc29cc716c6e26be50bfa023b0b577b54002916b8d442fd0711961899e5af6c715bd813f9298942e23119231d449536c2a7924bbc6744f93436fbabdda54ab9439e9f8b78e94f91a04edadc1c930ab72beccb0d8ddf9178b2c7d9e5d90530f5822ddabc287a0bafb01889dae6d630a2966712a86e35b85e9b7f51be2690a684796f26611e7754b9ee8a9e9b281ff2698d38d1f3153ae87b529cac0a6a92ac3123756496c62a5e72afd00648ab84b7075e595e96add51b729e96d298aff0c93cbd12df8905d7eca4f501e4d81ac820b2af5ec968ce5aad02c820417c7abe624f4abd3c653501bf8096b708820ad257d3917b921516611f3797ba93db98e9d24385a0e9157d24662589cf6ef511424229cfd662fc35a788976065c379343a149197d80a1f38eb067ac43cdb2b52c3613fc52f4ee072a7c62f13edcc103e05620682c9c9a048371353bc9f64cc1272fcbcfbf33dda359f0d2a7ed7c8f661b9e96a5b80124148ced6b85dc079a9bcc748e6cb9394110524dfb70fe5295387cd6f5c71fc468fdd9f18fe1a9fc52851b313d516d4fbf9fcfd482d38d40a037f957610748cae46a25b8cffdb3c4f30402d86307b6c4ea051a8136391f3ab9200af86d312b6d1d346af8cd66a60767195c3300ad265ddd0f381e2a9d54ea8ee5a60b2075f632985bfdff718ce1c30b4385804fce9353b2a054c3ff13b7170a2fa123d91f6c09967aa6150d2e98444aa47b000785227b89eaeaca661872aa32ed2751fd11df7c2fbef83e38511a15daaeca45b3c283a58b5bcebaf42c4cabdaaf9d2ac26f31cc23c23070b27f7f9f24ee55a72c42defec806cbe8b2c9d1fcba2f1baece68cab3f893818a58ecaea97990bcc02169c47b4bcfe99d89d62ee0524d96a169b7a6554ac95278c8cc6e5963ae6790ea2a270bac7e8ba6266f27a1114b577a39051e910ec0359e00534b2ce26a0657e871df003321efc4070d69e4e486e794f02ae85bd15dff9d8fde813e357b6616adfc76a6254029a041adbd25a472c9c696b2cd5d6d17fbe97c2f727194b615e07c7a4ca8352860ad8d7c1200562aaf7a4a261136543ceb9817ff15fa8e294f608f207616daae1c1b794faf56539a617b8b85388f31f585e575cdc5e86215c41091aa2c9b3e5ef4555d06d812e5befe61ba59098b59b108dcffd8a84cadbc772022594f06cfd1f699183f2d19095901f037695350463b32fe52ae3b4c9c49fc8c9ceffedf4c9f68757da9b8555b5aa0450866f373913cb2f1c336c571896fd9dde368199eff51ed6684680a39ac0086bc8b0df08056476c8db95b3af705faeca478f1743d7067fd722b7b6258d06e41e21a4bf25953e926dfc980fabfa9e2c1d86b66ec0f0d9c461cfdd6888df1f1ab0ef33bdcf9264930c3ddb1126784e12874dfb2c1b7ea0da6173c54a8f198624741281f408784ee0ab84155603a1ad31cf2ff7968f6a4e47c6ee437c631b979940baf4126d506f5cf5c5cdb6f23f13815bc0dec7b413832b2a7a58c89e4a041d93e5589796429a1c76dffd856d116ca4c351cc5981090894388d4675bbc54613ad6f09fc45ff21eeedd75408b19602716a1ed63658595355059dcb6a8fb99c107e31647f4d08f48eed22517b89541c09b8bb7dd1c77667abb9e49101bad1904e1147dd286a3285031ef484fb8a934a2203a913d9af1b893428de9e3032db7e23d71f7fb0a8a0c6eb7db2de480a10eda52e94073d8652893086ff6434ac3af70af81e4f58f77db8d85f6f43d5cef75395914e657a49761f8728cc40e9b18b93fdbd8593484746fe6e85812cc0636ad475d82834254b1c71e7d34a7b77d9a9ce2267f32a925fbbd6c6712b2cc689019599655a2e9280cb0469df8f1881ac32b72217f14c1a2617594de28f6c4efcbc598c4766d2bd07ec09b2e7c8ef0161e391a8376e11cd60b59ce9a7c2a3a3fca0dddde6b0a10ca0f345e205c1927f7e7e690c7e5fa85b4aba363dea11ff78074e191de3fce7e9c634302732ca6caba853c39c8c0c6b3784ffe00f3ec6b4780b80d145ca32db8f1ba544f24e05ccead35fba838e0db7336803583601fd578c1cbaa72db6e5218cda5c2b98b052f3fca87d1088cd671d1e6cd10c35a1b80a8c462a53b8b59ccc8164331d774cbdf87d3156e01ef6afb2754c78c34630256b0cb466b39dfbe5d687a9ab3c0c69624965fa7dce4f7eb38eb0474eaf2c2b4500926e39f7dc9735427b96dd55db9f0e67ba3bb405dba63422522f1f574a40724e5f8e5109551b8a9838e55873ee76e6fc07e70457ac1bc9683c6bd8ba9f0463f01c4182ad7ad823c6615e2fec677e7e0f136625fa52eb33820379804b394b2abca3c17f86a17f07a67019dc077da12b2a32c9d63f295c0b7ce50f7d136d64a93daa27b388d9cdca017e8da71c9ed2dc45add92f98f75bbf3134a8508e9f264afe944a94f762954f866b307bde9e1fcde68700b2363cf1921f55125acfd5bb531f5fdf5a889060093a0a4dfe4c03631fb51b6f32add57f090a181aa2993f753437b95087b1ca50747f916762a7b9c8b0568ef5b72fd7a2782f94ac47c8edbbd282dac54f4cf0baa802c9c7841081f4d0455ff02858d7b9f1784cf882a03bc56c836d97eb49b426258d8922def238e1d15154b838c49ba407fac6804698294906459931e047750c7ecac011f9c4c76a95b37674c04a1410fd821863914629653e4ed410f114c0b6eb5bc1751b335eccf8cb9663c60cd13447d7aaf431b7939886b59813a03c726b5707a5603d76e4820135d6af73adf67df5270d6b4366f0cd51194356b70c8ca60dabbedfe9ca5a21be3739dee29441206a5aa042647cb1711c9a3beaa6d23d8f49260739c17b6c67dde353f1698ab87d5a130a46850a7736b212960a46a0775822e7ac723b8a8f6f07aece8e87b67ec0ef299ce6067fc6fa3eda35c509a79faf9bd944ce8742824aad619027e294011c05b75d35a5ff80d9fac4c1ec7156db20bdfaff1dd1967b14b9baf636b4c0fdf436aded0994c8bf07b456aa8cbd07086e55a5fa5311082439f4ce2a6a34b74eea75b4dd73fc60bc05dc37bc3bd72f5c641b6ac0f832d30ca701ac06cd64244c877b732b4b0f17963228b3d9c8ebb1060c7a03b87bbe6e071a0bff135d35a5eb39ddce25d8b2bb510e25bd61fab6c40009a522261587cf5969024e2147c7e86290c9a0cb0d093318f0bd7ac8be95e3d45cd9b368df4149a21375becd438b3c6c1d79810155a78665c6eaf8570b3dcecf3270c325be5fd6176121de4174e70a0aa6507d3c18bebf6cc0fbba4dc9f6c26404d9cc5d26c3ab029147da5e976f187f8808ca58a9f26584e0cab41bc73a7568a300509996b06e562d6cb6a8f85befbc64d3f7d9e88bc77628be23eb6bc415b60e58fae5e5313a8e627ff02f81ca7b097e7f5cb34b9a82fa39e60402dc1698ef3c92cfae17b4b770c285815a16fc6524252e6586fd27bd92dc249553821ec62856c93ac2bbb8d41d3f93aa79b4244aef72197eedde0299ba1875a00e69ab89ba7b5204c264d56bccff94673e30ebdd04331829a59a911d06e17fb5e811ad6d764482c3ca7727b51374fad554ccd997278ede283019201c658a26cb9fc2b53e69600a62cd79a99042a5ec4d9a5f216b2e9e2ca0f873bbe8c39eab50d2216505ab7e6375ecaa6ea3d7b749801a5f601db30d41da646001d704f7080d8b6e61088e312355652194d46ba910e461947ee6cf6ce4be665f15c08c4d845a765098ace68ef761fdf8d1d7d10e2dab413be6450c77ad8fabfb2cedcc485f76577e1525ba4d9befbe9dbbe53a6a72ab5b44dc00e1e01fcc0e07c03d810a1bed23c11d024dbfa898863c2b8dd5edf960d2a3954f1100f62b64534ed3cea3d2bc390a365ec3cafbe530c25a3440edfe4d24a3f4b9ad80c3f5d8820dae86c5bdadcc7747a03636bbe68f7507386f342c86894f544c097970a4fe2a1c144e2c24b18c4639abe4a05e560dc8805f6cf67e5f830eeaf9e7f1a002efc4794ddcd0d299e2a37e00e8b2fc58d77b01d2d5ad561e12538a87a6d60a03a140def9fde667077c39b53353da7c88cfdeb38610d83da243e5fe11a11f3b8286b120276dbdf5b7dfac877ce898b3b926fd1be5e1cc23591ca1bb74a151f8d21d97fd244c2369608b3eeff376ace546cdee567864c9a93b08bbf4d93c41896198710ecbd2adb3a0ffe714b235f47f1af77045aac0d42f0bdf6a4ad301f0f16a64e79af03140e46b1cd36afbcf27c57de1a5b2a351ca985fe8c2aae39bf92ef58ee1bac142d5a83090081fa806ed4054f9bd9659045bd1a25a0ad0fb2a7ca3834f9ed18ae0eb69cfa5076c259e60d8bba0d4fc15b65c00c5feed61623eaa530a5adbbabeac60768b1704299f05a4d4dffdd104a887a10778e77d4542c5e66330e3bc70219f18d0ffe0bd855e242a8a7da96e8a43b497532e30e80e1ddc3c5b1550b2e8802a022f70298f758b394709bdb5b54e4fe8bd2b1192e990227b1d64aecbf005bd7661c386954df7dc48d999708a03c70f1489b7b9588690e2ab026f5bf822c052aea46fb6ea072e81ec198b79ed24a096194fc9fb571a83b11ec0b7a7fbfd0b3681442a4a160fa324594d60726b0efb2fb115af3e3e866d2c4c255c964cd5a014ed471303482cd76be91dad34e178026637571959438d92cf1e1920cae568d9725ae4969c917e18f723a9d2858042b7df85b1e6ecbc457d52939892e7ca75d334d392669c509e00e4ffecb5d0f71e81e3269f96134828540754ccbcedaea912f1254fe9819a1ffa079cd1daf7fd6447afa3a997d0c10fb2ccb69febbf1b13ac6c69e0da0ec9e00a85ac91937ecf9a186487178f9b4d5e3debd41ac39743c52df0a1a0a201c81d52c087098fc6dddbe528b8a36628387c0aa91723b10a2109da4087c990e901b7c68f2b6f875293075f6207c60c7138afb97178ad48d1d414ce03a867729783a39aad2837fbd8240de66481de60b93a52bf7323c8a81479efe7ef9afeac2045971908a7ea80bfe23a242776e80cc7f0322b07d7ac575c971e167d7eac52d22e845c092598476c257c39c966800561743fe2c6e0baba316e5a3e2d76afdd9486654d3bcf0bb319a86653f87b90d29f08a67386ad6e8ee067dba90a4880fabd0cac23342d418bb6ba2f6881260ecfa044d159932425f6ecaa52ec984a1c6026eeb19693adf829da833f705287d6241bd25f8847aea8d96d5330078c7ded70c798695c486e7d339e3f9e1311434835d16bb17195e27a63bb020ad765d7ccff55969a117259f589e82fe96a87454ed344ff9c408fc523a1836f90eda2d1293bc536c112a3634eea4f90ff4e70eac1fc42ba4d918b7d57c76c7ac9cb00c981851e7512bed96af3a5e6843e90ab47ab80a81389e1a37d3994139520d625dec6497a1e1ad5ca560a46bdb900aaf38ba8cfe4f660d516108a7374736e28d643405c269598b22e655cdcffc0fb2080ad5be619a0400115a7dca91bec31d097a726c58651a89dc51f54fc5e1e353ab426c8e8560bebf8080165dc77075fae7490c350ab7b5f3015e8a1aca069623d37afb9a06c90142517467a886a83bf6889f98ff89039ce777c0c8752ddf6b5e2b7fa331aefeb4e9c2220a06844a3e926a98859bb02e05bdcff169e9351a6a685526ce33642c371101987d504d4c671f0d53733878c2ce27ddd3a37db2b267a672affedb77ef683e62d533317a1b147252de42548274eb55ed71119bcaf89baf93a0fd8673d227852372511fac5101d4ce839b5a5e57e5a6243755db8b36810d01eba80c7d1bba33d8243924e87283d02ea41ce5506d510deb114d0b1a0f31a0d10919f204793e1f74b6ec98e842b0a6defb870e3118bfdb7b985014cce96691979a074bac04c1437300ba9b230f450b7d862a38d613316223f297da0392c5ee14114759d973f016dac94959ff25f630a90c331af49746d08002b9e025ca566a8a23a8c23a5f5ab9ee076f620160c5ac550a6c3a3deb1a05c09ebe0bafc652206bc99087fd4c0af31d076ccd03e59511a0f8e5856e84f02bf586ae654ddea5fdd4bdd2b62751907eecb9927fabc44603c47f19d9d7ba9152ccae5efc668b105cec07404011fd0084f10cbda33b25dd33ad7cfb5d385975786e9a3546448c3aff91cb1cb7849eb6d2cda4eb322ff9722f4481db77188e12eddf08be305c24f9f6fb9d95849fe2d82ef373a814f06d0841553e1e8490ddad83dbe48bed0aa8d922dbace399d0b6fa3718b12e6d95ca45f2635581821bea5b8d965a66fdd83986b192e08fa826a459571b8a418117f6e4d0826f2b9f8ddc1559d0efeeedf6e38a85a0e3fae6aa09e630130bc182efb409791b1a7ed5a103b2595abad8996d1dd644e23696d0905a837373e5b8a0e63db8839112c52fe5d30516e6daba29970b8165c9d5bdfcab1216fca6435a8ce1983a43ca3076e399bdc9621d9625ba7125926121ba38ca7200c68daea0ae45eeb0642c290ba545bb20fbf6d466fbc1ea018ca255af61f5e70d3f7dff61a0518dbe747fea47754ae0792f05a42c27d6451ad406c2b2891d80e96d641b6581e8249f6ac4951b0c25da4fb49702b261f5a22f11df7fbd7e6d15f51346ed6dbc21f1e2d5d577b4b154571cd3f055f77b585b71e2dbd7f6d3b20d1928da0bf8d0b4c62b5286f1e901394a134818d119eb2b062c3288f2c5241d97b914ad6c23100654c604765be2db2b287d9e6ac8bc580e28e7a0a6da45ffc4326bfce6cbaff7c6fa87a7f7cccf5a0902f99d010a38bc4299c27539d4a43372f638cf1bac704060af91d663a980e238212f1231cac331153ed1865b1191f2b02c67468b63ae41cacc5497d7770b6a5b7793ae97c6d328f3e17992d4eea075b67b0faa850a9d098c5bffa15313cdca8d478fcfd0655a2e4cecf9127ceedf1f08dc1b1419241bc918fed8ebea60c326b38c767a3b76e73f74526c3367e20ef7465132a6f438f9974b8473806669bea018de3de524ba44ccbdc1c38cf11dbb135805e2b84cd1458404e50da4147ba0675f8e804e8b53f0995738af0304396a95dd86c80ecc8e7e5cd26c06bd577b7d96907caaaf61d8b3b42b4e6ccb3d5c27194ed6989ce7861d60ba17110ff748e0bffcda5a8a8d3599df4ae92f45eee74704af2187e038a0f4b78be932c789d31285bbd05b723b805e04e5c3bf66cf81662ed4b982b63bea9ce570618ca3d2dd84bd6dbe3a7df0933d24a50152483be4da0ce958b87d294021f2a89a88a6ccfa2fa2d9ee7e9c2064aa9933698e3bccc5ee21cac7991e0cac7df5e97f5e32b1318772b8efe9f319973db86ce483938a692d9ff7f78bff17ada1d68d971c052b848b6cb1ea8bfb085bd311e2d2bbf34b55ab7287ce2bcb8829bd0a066bdfeee0eed7582d419d216731bda046a38985911f87103d0cee859e5aa6cb3d1f427edb320baa9c6f24db2ca85039a43c87ca04948aa198971d8e5310c764dfd5cb2268e91c5bd604decc35e5c1a300a211a7419e44c2b8a63677659c02362606961cb970417f74e2c5719ab49607894fa2bcfad69dd205e9b27bb4bbd7708ea57869e593ac635a817de28912214aa640a56db885f7b4ab5570027d0590f35fb3102670859791c73169d2891a69d7879bcd01392ae8346edb5d611635107073e8b14d7683877536fd456c7a8e7fd6c5feb53d408ddcd42901b71a315d3bf352c89d05d0aa760c754a5cd8256ea317825122ddb409cb152240711f9efd0c34bff1b18390407e9d4694920c46d1294e1157ed4f834855d14e354068d670d34f75ed5f2799a4405ee12fd714d5767a484b723d45d0e6f936fcf6c42f709972f1d5f23b63955cfccbf4b4b2c40f3c09990039d347a9054f89abf840c2cd1af56efe3ec29d0cbd74ecc066c45e5edd4c11bcdfaea4ffc4fc51dd713111c2b6f3eb81038c25374d34c6245d8cbf0c000532d0f91fa7485441f24263a5df74bcdb1f175c4d86dc911512c20711895bd573ab5f315ffb3b986a07fdddee0b94e7688c434f2f08b2b1035d15ae189f8e156739d4ce37855996b5a5841775786b9de94918eb9f25e0c0e633e54138a843cfe4f396455b9f5b80839aa57938f72c400dbfd786ee995deadf7333700ff31c10e6a1ab331745b2730d4124050b9d608b9894c93341dea16a03860660bb0e15c3a64e49a6a212c44d3e55c06f6154fa8af786597122ca15e3e8942c44abd5f9756813eb5e64949333fe0afb631769d46bc5b3ca75497746a517a7da9e8d910ec2c629b8b397bb293335cb7a77a0899d51b5c7bb4213e64975f20a14e730cc2e9009366f23c66def887dd23e3370a3f9bee781317b810a8c9352b9093189b6b88794da0be15220b95b6ad0cb252e16a1addfed18c11b276b1d2d798e32550aeeb3a9704d87496b36c397dec0eda8140ca0a23de7bbe72f1352ba898eb3d635fd9528c3791389d110640f9f94e6bdccf0633f7c642df1a1749aa6d6fdc4f8e11c43539b767dbc98e64a4a67042a1b7227089b9f84dac1b2d8c3b742c2432ae14e957ee2510411fe77f869fbfb029ea0c75ee1e6e54580cc5f80bf9a22ff3c44c5465dfaf4c4ee76a35cf5a257788a99ddd90c9a9790acfc35ce6d83376cc857007e224cf279081d52cd1280b74c8ed17a82936211c623371baedfc3a7fd4d39d592ba3a5712b47d12febb23338a5d1304b7915bf241591375a578732f3349182bce6e99b4979913af0b9d3cd8465db6a1e66eae8c1cccd26a0061a6eeede9147184eeb2cd13aef65697e4872ded4bf544de9a92c327d9758d706a2ff55b24e42427b9fdc6300d6a062c7d05ab4b656d6d64ecaa3390827fc50775e247f8e2deeb110be5ac335188a6dfa34522373d00361c6eb130e64b85a93a8b5a9a9c3b7ebc0ca0384831108731d7dea95525c38f08e78c0f9a22b255c9a9fd7200e306c671c3d82e936d22434a736feda8140b0a451ba1ed328e921c2b1af67df55f6349ad28bcd8b1788dd6ba193a5611f4d89cd9e89d259c3d5e3b10bbe6961a35709e52642d07a153832508621af28b56a081d7906eb8a0155f303f6c2157a3882c340a739579bbc3e6b7c5757af5aac485462ce9ebf6791a8735afe0e94c5e8cdbcb41a7fbb68d10923783764f59b610b2d5f7aae2df44b29c656a4f021d791d5e98678e986b2e1d7bd27cde1c55b4a938d0478b64c5345f5c6a22d17272025a8b49abc6546d366bfc06adf569601cac01364c6599e51e23e32ff119585b3a8c9ee43e13067b300b6fca1737dfc4bf49213e9099ebf44b512f3d8c2f99dcba49f7bad89d0a6a11eea25b7229f68660a3ef9ae027cf53860a2bacbd36dc9cff6b227fce27c4e221bdba3ae21de23e30eb4a7349f50b5a189416d9fef1898bc807fcb4def61ee096992ee9db68e8e889f581f1c923a9af7d024abeb78455dc52ddf5bca79ec2a5b8f165a096ed1fd2e37d210f3e70322f57c3993ca33db556aab6b2fcf90c916ffa181f0fb76f04fbbdffe093624f8fca054238065823522150737c3f78f8a275cc70b224686c6f1a9e26bd3b6e082d5f7a9b02d209cb74511672b81551ddbb2a970fb8668a723d4c94a9dc2dcd97865ce7228b58a146887d7e587edc144e88020cc9c804c9bac3c41dda80c0fed5b246f2897afa1631fb272bc3076c6df0d8ceb7be52593431c76b300ae8e351bdae9dec62ce9475a959bc576556c28851ac2b40815e1721e99b7413578acd66b817d296224396e886cb3b0751f5fd0abc0ca8e30ac497e0eee8c04d2de7433ecd9b1eac26af97d9a2f7fbc5ab9ce26f0b5740f2b88219b7c5490977c77fa2fec961446cf9411d1c213714f58e39251e4c1a38f6dabb7fe46d9cad3b7e988c84cc5e70a0d3888cdd43879c0d9ee19ce21591ad570940924295c2e5561254e3f319298aefc479286911caa597f55fefbbeeffba7c9922b5c66f0c94153f98272ae3756476848691b9221a91581b615d1f028c04d026ae8b131f3a4952bd36a39d6a4b31ff5575e176c0f29c33111a53d6ccbec62d4e7828d51d968089b481126a982263f87deff027905c478f4ca786d4f8c90c4cb7afa4e28e984188f93f7505775abba6d7bfb605689007fa6578f7f81edae98dc97fda23b86ed07fdc5495216d8fcbf44b52bcaae6d4369b6983c297c3f3f0c7bc444a4b5154f6de81b91952f722e72fa33ca82ff34b4c2424cb1c10f2cf2b027086c56f090d1d34bd488adb8f8e7dc52a8e5b0503380cee47ad91f648c69da25d020370c5ba6a8ab11096c8141c92fea3078a97bc06e0bf12e06e80db06c2db995e44daa09bcbd07f9edaf483","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
