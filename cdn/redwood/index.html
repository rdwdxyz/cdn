<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ca916ef9cdbc9726afcfb8c198a43619ce00c898d40f54802eaf45d420a3f18a7a23d6cab5016e5c39747a31f87927855a092536acf3d0392b00d28f18d15deb191586730a5ffbb6487caff871463839ef193b6fbc1488a26e4f3d21d7d8c5693d94ffff568abbe83908d5217401e2c64710d889ef6a9275bcf8f94192e48fde4f9d7bb137c927018b5339db0ca7490abdcd64bb6b2f2edb4042d2bf53678b8b42d8756e74bfd52c8a2be9073626dbf56d6274f85ef978cf9c68cbe12816ffb4d56e17033b0d2890794f77c1dcd73ddbb3264d2ab7d90fa795c68dc18e7119be4a5a3e46161b8ea1089e3bcfc54acbc57f455e6d0cd8728ecc078f0e93a983ce28281fe2ef009220f4f39ea4d91a4dfba52dcff4a24fdd7c0656dad0ab24f17ea2bb41608590fe33c37261cb5ff81328c08bf81c858e497a290771904130b570347b66e29cbe2da2d50f245661b80b34e1f660dec5aa2f8a9a3a92f5edb5235e92706391a1073ff597b1de214d0f03aa8672a60d19bdee1b9c6b542d1fe0e946d61596a37ed76d280e42b5cad80d8ba5de50b82abf78bae5541d27793198cae451ce465e73126954beb898a499dd40487cbcfdaf03599f6b3247b2797dd3fd74b5a8bda8ee4685c4476925b20b270325a6ce300892f4ef3856c64dc7d356e256dd8fc343e9bb236e09c152779ed29afda2c6786400fd49c4a71fec5ac79eee94cc34416470d85dc0641e53889e4f9c6acd9fc722811d153781b234cd356e1d059af8d84083f9cc12f18eef27bde343e3f050e5685d737df9845e5bee48ea9b4e32c435e6b00efd5453ee0e75ef26d8b67e1773e928b3243100c92d882ad223d72e726dd892b3da9622321415000954434aa3de2c0672883aea370aabc39c0ca1b23999b2ac47a0c9a12718be8a4221c65b1a8a9ae7b223bcf7fd0bbc9f389ffa018f5fbb607b6cffb8786b5431ed3d1f7ebf89bc2c19c18b1d1a72a63ec518ba3be07eeedf64c7b4ab8886a896a8507d13ca82e7ead7fbdc04e8ae4a3a39b1e15ad46fd5833966de2626ae2b4ad5116e183b8033e010ee8dfce33c22f51d7ae17ff2d08a0aaafe77976cdcb325d3cfec0105f52bf2bcfcc1f4c56b6c8360ab95aefb723973a34e2bc9626f2542a4d2bafdef69f69af40c3ede360bcc115a1cd54d5f494860e9eddd15aae057cd8eecb814893ceccb05cef634ca7003642d2ab39b9d7493f276a2ca77c3c78dc8ef23b6ebe389c598dfc3b04e8f208fd70fd39d514a9f6f980ab3ade2971551acbf4e96a81417dd368faa813c5a14c08eaae1f725cf311b3852acec69dfacd0c086895221ea9c325c40743504b9b8ca9360c2de0d7219711446d417352e4fad342c857dee830593508064695f70ac1c729bb3f26e61b6734bd8907b045fce09be249eff62e13e5d69ae887d62e44d0af0656852b1a53ebceafab88b0ea7da230def08f848dcd67b1b0c44bdfa129f80a1e67d29668ed86c4060b83ddff3f650135ba7111d8bf3c10d0d2a26596b694900d746decafa66635821fde4b208e3fd7a6392f23fea247b847d9f67f640cad902068fb7ef8af920468ddd8e155e64042790e3db8253bef71988e4ad5a158bfc02ca4aa4c9340de283aa05b5459d78a111df65563f46ab9fbad78bea73ac17df0d4ba87ce251ebd40709158594fd39ba38cab49ca0cce83e3ef52cc2cac6ac767a8f9f746ccc7bc5a8828c6ef39c5c08458f9acd038f20e84dcc03f6c1c04a09195b38f386dd415e2025a40bd04f5ea1f9f6bb6797b68ee14efd974438e4b407501a809c39ba945509de3e72084c0950a4085d37064849f0e9b1cabff1bfd228a5fe623b1d51e680472bd99e5c1b689d0755a434961ea8a3edb3bbcdda2e4284c0352a4b95f0db6e9387c9c0e0c3de1230b747de86f991744710665d18f8510c03eb39e69fa43e6c2f3d923adb9387be73e830d90aeb2047c482a0d216a81320d2f4ccb2815486a0ae2eb691f37ab4f4e37079550f0dc38382dc13c0ccba28db36430c6594e8ec0bab5cfcf89d55b18b5878c79208729f7e72aa5c8c5da1eb3ccfe1337f5b3ebb21592fc57f95fe1e41466531997b155430fe82b6a88b3f8f5ec6c0bd234ac1c7ba8e7801eafafc5d7c234f4440800faf4f49365d8c823059b127fc00550a1defba7f3c4835a8e10a52beb08c86fe6d6687d94cc4279780e8cc2ff2f8b2b2d0dec04293e5141e58248a37c36081dcb4b1d2cdcafc100d6c0f67b0264da1e0a4a5c5a835fe63150e0c6166ad7dd467254775f550632166774aed00ea3a14009cce8be162aa40b7be6203a4a3d76beb9d630934994b714f6a15fd1bc4d00e2b177266b0efae9b57c4f793597c80f3d1b258701097985e63345ccc75cdaf4e8c7f2dfb790b4473b0dfa15e3f4db4ce1312b1a47a9d97346a21c7dcc55fa1059800387f57323c2de2e97c6d8db9fb2fad19732dd804871a38f85e3dead66927f8e5cb54a631881ac591a16a66e289bf7e5e2cb64d682f145ee071540dd2f2ae1a093f041ce9a5f802a9edda914c36b00ebed112bfd1019141e9e3a8775f97e0c5503fe0286035b09ebf1094cf4327077c04a33bd1e82e8df4e75010550cae2f3e31cbe6fb6da2b1a3b610adca63b2bcdc16501335680130a71c3bd681890588d40eae0f634ad0c7eaaa726c27f20f744f429a2656fcfb2d40ed43dec01ce452385c5ed3ef70e090c6e84329936956f47bb17631aff8b84acb109903e57591a477b09511844941227632976b3fce391f41bbdaa46d8c1ea1eaa8db846ac8b61c468d6caa92d20e92558b328e4847b739227e49d81e9a1dfb94c4f2f67fbbdbb310f0071518953bdc1ea83e54522425887bbc0fefe782045ae3e8208c009c0c99e500699421ac4961c5637f25bd776066237d7c11b15dd4080ffc3f68c4d1177db347c21c14758199095f9ac9d5c4ec7ea3eee47461de36707273d05a3091745193d3b71f6d5ba72cc4f0712d7d67efa458bcae0093ff7202c0c94ca23aaa6c4bf82cb4b1ce808960699a3b872ff1b7d16feb95b4fa10021a3e138d0997a06c667f1e6d185a15c15344d322ed0991465a5aa8f2201023186452a663e6ffb2ad4b61de9b2a4855dc0deb922caf56af688cd77aae0f3402d435b115d78b3f406935fc0f3ababf363e7af95183b6ec0c25f5d00b5b8addc36b2ab171da108c5377d3393ef28a4409cdb5cf093891d18fe24687198f96811ee56731866b0ec077f082d815fa7c67d2df2281f2f0e4deb6ad93026f49f930b39da172e254e79370c6200c05e9546526578e9f07482eea91c0788b0279a117419db2aa38c79d39c1939e31c649ebecaca0041a323f7e24430b3bf24628797373ddfb0ab806cd044d12209d605584c5eae47afc31299e74e770e8088ec8855cc7e5f7f709af0420fb272539ca5b4b8cee2023d905ecd62df29aa112149a0f22c3487acb5245c63f02412dcc811d3cee2b50ffca386d2304ce7a12507c737032db2849ac74cc6ffc4fbf230502620564fcbc23c6752cfc54bb9a574eecccb49060cd63ae07ceaf4f65ae2078c1459e9d5f9650ae512ad03ad8e19c8a81d7afbccf42267ec103a67e2fca8d8818f5ffe669b60855de4174715bd669353f581ece5466fa9ea81a39640510262797b6971d82fa709d7752870260bbc549729611bd3bdc71b105f5ed55178d740e237ff89ef9a7a8b58f04b41b9620ca31924791d87e9ec71c25af250a8f833c9369492bef57d2feb302fa840c4e8ed9f9b1d06b289539ed29e0698e114ef7d89af04993875d4906f5516a9e88260cf2fcbc50719ca8dc660c2bb399d17832658bd908bddf301632aebad7c1de39053b5d6045c32d0d3fd4906fca38d90ff592279efb33ac93be2b8710d25babda52c371378774fbe09a5e5e69cf4e0f70e4bfd1a9b69b6e74ec4ae13ec31812f648d34d56c44a844ea7a03981f8325ba42fb01c25854d350cd9050439b61955e21c37fe2cd973bf60ab1cefc9bf4928f0cc74444ef6a97212a78679617b8e6b56535b569288aa200ef96f558c41e7aafd4d57e9fb5d5aead89cdf7ccd46cb6fbbb98d75a168ee66a572e3ab6c66fef65fcac47fed7be6c2de8108a16e11bb93dfcb390bb87e3a9312a8f4c308376cf2ef0e8a57fb01f8f4dc948ce6b82740e32ae1ebbea020b346465c5ffcb5eed89a26fcaddf945c674ef63733e0fa0f77bb14c64618120e4d3208d1b87938b2c9154f8fac78d3e59832bc4cac485e1dc8c050275bfe2827412be80ef979ddf862b4070323ddf7fb068db84172df589a7c68fc5c63b9eac5063f44c627af26676a69d48183394822b528a08f53f1f6e699f33187c530d3a4a2d2f9d76eabf89b4438ef72e6aa2c287b7464715b0ba76e4fe92206178bb11425fb7c023e112caea6931641e4f2bf31b3961d32615a98927aaea62339cc14860a066a6873c881db14eb6c45ffd2b7c204c4d402993cbde8b4a8873da40a65198a35c23413458c3d3c00374b08259580ada5737f20040ad5c4964c31c0a4cc96c9748d98949ec8973a6c270f0dd90abf6f2724f2e390a87fd165c44830174fed7d1f03a2caa90ff05dadd22af7519528708d2d070fa34ee2a914975aac7f96b333a0079bbb616e1acab912b0fc71f74f871a6c91238408236bb1ae5d4dcd47b509d6dff5b7a020f9af5025eadf145a965fb995830b97b43a3e5d0b6159b2b4515c1161825647d4a327aa464dee0b3d2a8a748f288af6948bda53f15a567b715e2fc723605444ca882ade3c780ae994d06291a09bb6590d8a454a78597bdcc6d3827220e582b7f0db4e1545b4f2992c89b511d107f5783921ca8247b4539f804340a11f4183b24c7c6acb39e0750116c627e8ae60220449e7fdde187df2df8a37f2ee7b3a3bf837869fe6790cc493df8daaf780e0e661332483b394f8fb0fe65eeb75d312ff843d7b184fcd6940a5ebbf603e4ad547d40f41138ff0511abc1604afbcd198422bcd0aba7d606c60cf242bea15eb209b09629db3dbfe9f669b34abe1ea12ee18296b7c2c41c4b44861f8ae5674d0d43e99fd3a3b4f3ffc0e5af4cdebe92254a0eee675bdf62f4c41969464e4fcbd22f3f90bd5557040d4c8080b13e9e1ab19b766740caf7fc88f4df5a900b2360c9abac0cff90efc021faeffc342e2af6b12b6316a0c46f6583150ed3c293d7eba35bc53db399185dba39a4442a403c150cfb1a44dc8aa653310bb9b231a08c19d3372031f6acfb70f151f4bcc81a415f3d7d536ad54efb0ef5fb4c987af24e47921bc030219e9290d7ff2f0875eb18e188c484518927876b1ebac52441b705c8f10baf5c5843ffa65ec053cb9623415398f749bef028664cf99caf7b63633fc150768b4b99248eb7f6f1f021d5e1f85c9965c5459645cf2d4ad834d638d0ae367d9bd81c140d0d142741cf1998e24648110369e95f2c64e427473f4774e7bc9c44d422ba20fa443f939785443470fe7ff12d9f2c941dc18e3591b3a5ae7eded055cbdb7ce3129a9234b650f059f8a717c8ee42b885d907c537d4c87e058d48d96adffef97ca0bb6a3ddd3ae3c9f43633611f2f03c7f81dbda360133ab927c390c75e4da941acc7e095c4d2ccfa7aed29a420e1796ac1ccc9adb2f0e1b7975d98dc52ebaea19063b348d1af8f1dbf00a971b9567d0317670bd8201c2cc9c7f87452652242bff9c02e171a9ac13fc0bec742751a614252305f47d52eb977abf25acab89c79a33c27e6c39f890ea306d89141165452d58b1c85ae51552acf336724a131864959be8826d909fe8ad6ecefe8bd7a8afa05ef2766ab2c7ba688b3187c06e5af41da39ce31e0facf186d35aaa307aaf189ada55465b36e80ad19126d437a4fea9017c80cacc486701b32fae18cb66b5a83b2d09e0810314e02c9a3590c79f438ec2d1f6423d0182be493a1020b60cc6028f416e67c7845b9576877278e1350038148e7a6b84afab8aa43559420996a92b837d559f500fa4563b0465ec62c7201624ac22faa16139bfa1d749483d344d196668749b28f92f816dfcfb948ea50d9e7a6f56ec8b866531c49f2c83a62d1a6aaaf606320294e9da4dc593b34708ba4dd7b005efaef5eef808158ff31d40b54c495fe1a3d02bd2e62cab84ff4925d837195b9c5be002a80b5107d832f059271487ba58a09f655d4fb725791839bf5ad7f0060453a50bb6a029433f873349fe9bb270513749db9942cc67a3dd13136ab3948b376580f3f4163d8b80f21b20af8ab5cf95c01553975bcde46dc9acf312d90539b07f0bf2b099e0d832332beeb10af6eb82cf03999d2b5f487804755f7902ca2bb976cedb5fc78d14fb0243d4d148672522c0419321bd67550298e32f30da48bc2b1552c4b020d501e087926b79eeea325f4828ce0c184f8e21f36d0def19fdbed686d7a06932797116aaba17efcd03072facf7858f6d94968b3f4b8dc8df373f352957eecc487f260f9cec74605e3fa2a88ff5ca80ac2725e7b487669a01087c13e62a85628f406a4820bba6543dd2f30e391b40c0607ae1e5b3ec5b681c5949d223b78222b741a9701e771e03693ca12632f36189e75ffffd0504ab0b9fb48c3d95091ade23ff42e3c0f6bcff336ac9c79e7f8ec248aedc36cb8e4bdf7dd55cc8918d0bcf5b46798b9d12ab9dca8de06788321ed166eae3cb945b34c2554182ba1867918936c294a5266bf795a6d628267237977489e1ae7577b0759bfe6a4fbbea812bd32ede4d6de956655196442e4885539d8e5a5e5ff775c896693df02f9d63c10173a047e8306a4b134f926bde86a64e3bb711dd34cf99e5ede43782874227ea8b20f315b74505954897bb26a734f2250d234a28bbf3fa1a71398c8d49d07c23c21292e517bc452319b45400221fd7250cfba51de039cded33507ccc9b469e3f2c2f27a9ecc38f3e1c7bce9191beb8e923b1a971ecf9defe53321f3a8342cb92cc970ab2d528c0be7cf3054206c9bee66957bf5f6cf50045c2ddfd4b3b22130113a527a3349a0d8228c0e35baf25bc864986b57ca664de05aa30083624c8b664772182f4aad384fbb12558e9a46f820dde69ec81ddb891779c735665d50cdba61ad4115124b39ee2e89dac6aa1cfed8590a18c613e9d00097f1cac6f40bbd3316526396dd324c0ef688d34b08f9805edfd9e755c70e5b6dac5d94985f6bd5e8c73b91aa05fc6805be8bee424414bcf1a6b872e8fc8f03f6331e4715f7dc98248722a4667afcbe03c352919a288ece6f5045121c5a29fa437b0b05daedf481aeeb703649979b4deb8ae0190b36604f976853e6fd3c50310dcd677ff35cab398ad5bbddeb836611570ad26957d93ac84c8ac185a31380bafe22c326f707b5fd970d6f6dfa89da8736277671dd7a6e46f8acd0d87cc89febb90d5232d181887ecfbaee3eab6cd0257aeabe1d850c4011169a5376bd64554eb855a299718278af0d5c4dce1bfaac270cb009eb9552510840d0a312b331ec02c62809a8e9de2175a2f6cfaf7b658ad2cd17dafb1538c6a09655744bd584cb3b33ec36527ef1885318a062f6dc6bc3479a1d307815b63e69df0013bc249841720f9b7a8424385a45f9dbef82f0b2d53d1097a10819e443d1b71947b3ffa5cee0dfbc0d1b6f54bcda14cdd9160f9392101998514e45d2d8c83bd689288bc7841963c15461b6f7e73dd29011e037c4abb67825566bfec1c02a6ac37a321e8620aa6fd64ca0c541b89f5943a12efaf1c8b46c70f45eab1aa2ef00d8d6a5531ca6f2fed77c8dfc8d2c1aa32026ddd4454d8d222fd760e8945e76fb76aaeabc7dd8917c749eefc8c78d8459f150ba9ce98b63c719df2df61301810aea6bf840cd30830b2e8e4f94d524fe504ba6432da345e7475e640fa69d6d9fb6b424f0954803c3215341c7bb95c761e74299fd89cf3bde31d253d760d0d89d5497413fb2453436091b77c3e24402c0150cf0409ea39de35aaad7115ac62d7b17bee145a3070c1ac60e7b4f8baea666b1d05a1a443a4810d70e621c72eaaab16211540dc7da9b1ec6d4b4915bcc106bbb5998fa27b7fec46ab2659d3dbbabd1abbd31c2b340d812c06cb8e3b4df476951aa85d19e3b1b9afd0dc486e64b57a3fcd399a9d7ea621f21f2ab4469b849d44329e9ad69a4e71878db867b029da989512c5be0d1a162487ee010c485c091f3430bdf68a8a2a35b4b0d9428ae4ecb6acac721b998fa8e9bc7846827bb2be41590240948e2d4a353b4f7e6550ff3e3ec709de2a3369c9b03fab6578da9265883cffb95215596ee3af88477750bb93a727df4fa95cb7437273c733f1164a113169af570d9a635b0ac3610eac5ce00575c5d059f0b72a4c95b631e748dbb03704e4a9630728e3cf02cda428bd70b0855d166fccbdcb7f8807fd66d6eb964a19a2166362d9d1621b0d06b791ce12306c00df32ff3ee6344ce1faecd2857e13702f4688ac754d4144ccb4236ec7b3abc765966886e09b6ad4e667100d4e31ee80b8c854a0013763fa5d60371f2d04405dcf16136ad672e8d9cdb3280780196e3f5567ab1aa8798e93efa1218dcf94e318175f2b8f9a86a1fcbcaa95333a385a93980d1e458a726885e50f4576b54572650794f8eeeddb9be1c7483ab0177935bb4218f17ab2c56b51a67e03c3a5b3cbfc5e84f1a4c02aef5dd9d253dbdaa131f40c4526dffd1905f3963b1c914af9af53d413c88bdeb2ff75d01b2578714577c6aed90831166ac12b1335724f71bb7c255797f5bb01597659506cfa7dd47c215622f6571927bba0d450966dd1be449ca8bd510ddc55b4c93a044c81023f4c7bb5312ed2b6f097413dd03b7cc88f14f35cb627288e055b8956d8704daf186a4c4242b3b61cd9443f5262b37cdabce0cd03a3ab12c4f477108ef88f47c3ebc2efe9d7318f987b8f77587117f265b925615874583e5f1efe59be09263f4c7961e49bafcd6699cc630d1607a9d55c768aea3cec5d657dc16525ef0450acd927e281fd1e202a879027b6c619955a964b348e8e6be82eddd43c7782302dd8d9c659ac761f579c8d8cc9e07952e2fb368ce3a40e520b89386bcea16333bfb613cf36dec980b99f43ec13f88f8d8c6363858a1b401923d1ff7f68f709b8c4b9082b3380e41d3ff36cf2e60abed91e9c478e8efcb29282722b9a3917a7d54ddd1140c3b5d52fd63c1c027019a437e8ff1899369f6c19ed41da6b77d407c4ade8a5f3a8d0f777f0837c53d8233dd568f119c217d1405b3622d3fa913485d4efa4a1164dd30bd954129915af0e92f4c24860cbcf5b0b3342e0861294f3743e28d7fd87c80e53dc340b6f2cd704781619e02e5500f14677138a3e87af308ed6b35ceaa7e07b10838667e4824a198aef134d20e456513bbd7e58e42d5d65c12b82082e9f75a11fbeafb0ef9f38c600a9d139deb4b93179539b87d5a14c8b9bbc20a3f0ff05b3d1a6d722bd87749fe1a00e44f8a18c34940dd39588fd64b7244836820f7150b2d934d7c5fdcf5823304103dfeedb32fcf2178d6d46c18123e92b674622a8cb517cd4f698801333cf3decd6f8f33d9c17943787b3cce9e428afad3573514ade1ab9661279a91fc3a668434d1054be164f9b2b6a21b2096520a11a4e56ec34dc96a2ea26980bd5e7c2d82029efd4d72543d3303b0ff8830581f7d4e540687120ce2c947c6d12cbdaac60aa2d8a55399301ab0dd3a71a56d3250f755985afc07c2763f618d9702d810f3ec14687d2cb51ace289072c5caa89d47f5c2cd8fc4ddecd7cdbbad5f8898530ee1b93bd73dc655ef7e6b0a4eefbb333f44ca64d64ebbd66d960a672dcc21775fafe86fb05e6032c2eaaca35f94ca7e76662e067b1e5a7aaaf3bbc382cac016d6e785d5055f0b5eaea5d4d7d58ea0c6d64e5de6de123473e4b3699f62bf8ec0692392cd2e35236ec6e2e139791b56a3914b16db345a519db9550fa4aa5200202294a345f713db550ce711a75e519049b8e6e36360cd81a9706f367b5bf1e18229d094f74ff114b6b3a67b4c35073df9c88b7324efc44fb99b7b9ed8d8c401b1e602b121d4641524a03504d3f3cef681ca420d3da0ddc7ac9f86e0cfcabb66e2940ea21c38218f84b2d96603832142ed17c73089938735a1b8ca42d0ea478493437229a15417c9dadc1313971a5b4ce085b081b5762380a9e558a0972c9701a1bf29af6e4801262fbcd207a7bda7103ea8cea884f3d479b37ab87e25aa28c1935890ae3a98d39d13a57d86c271520f1bcaa012ab96048c7458e300dc651e999a1e4990575dc9754ee52cc5e4b1ce8a1f917915eefbf54efddd1f31aa1407377975d5929792858283ab3653336a99824c80a048d353e8dee2404ca3652ca859d05daa617fe0a8b6d122496add16f71d54592c234ef1da4a880115a510f423abbf498b94e87d927c383900052f204d3b616d0dd3f8bc60536543cec05ba59c45fecea524c1b90147b1364924c2d8a146ef6668e7f371c4cf79b5862cbb44cc71ad4ef8a304772e8a04df24afadefb7e6be024e596875ee8b0a46490bd2d06d236232e6d5540da34907aee69b3cd481d193bb89a7c7e38bd7c749ee7894fdf7497118bb641c62b1133c50fd5a828636bdb607667f7062ca0ed23d2d5da4fe575d684746e6fd17f0a3a0b66214ff7fe38e3009b095677bcd6dec04d0ff0cfa12da813e0614d4d893d086f3e40c99978fcfd60a5ccb93a7de7b6e1549d04dd7bd90499305b530a394dd2cd1f5ad4b677c9bc1ec210640f1d8098ebcf13689e8c29edf72df98a72d73472e80f4fcd867126ea8613c1bb700b72e6ef22169a384f4ec8bfaeb5865b17677778185244c024339965ba52ab0d0a1eaf15a055c63b71d58f7b17c74900d81a56cc63d0a27effb5f0ec3ff630fe99964c70b06929a48670aaf533e37128a6c1af6b699eca6e209494a337194ff0898a597cbc0f46b16f87d6e4875a20fe50b99c1fe749b2aff40e2884cdf92e97dc51af38f46a87792244413fb193b54effc2801c0986312ac59ac892d590686e0b4d1cf91fdcc61d9684b5c0473990288a8ce3266473e093062158d668ad78bd917ac4a51649eb773e9fa60cfd8752ad6a83859bc78aedd54ab1dd7c696eca95e35cf9bae968bd1e6eefde5c6db29e7b5d6e2e38567932eeb3b3d31df46a39d241b7cadd8eff6498bcefb5b1b9e5bc316d70104205d9a5cf061e607038579a9ff3cabb4cf5c9cedc52632a4d5ed9b9374fe74a8d150db5b9b2a28adcec98937b210839c4996ccd543164a8fccc58e4ee62715d9a0302efbc1ff55b111c09d945ea24f2913183be2a42ef112564233a383dc5731efa306bf19a108b47a69962a1e2e1f4b0a4c55064fb43f02dbf5674e0bf30cfbe987e77dfac72d32d9f5c5c9b5cb4fd99fa53e857f2dd136c44946a6b5f500bd977c065b6a36cd5d6362c3690951f735782f2019490537ea3c2ddd4f963e16020511065ae3171c39359977ffb589cd22b2f1ca12ca045ceafa91c22e924e20a14870a3c648b5e5d567a985df959a231d3b709bb879fcba5ddcad03e7c6f30da1c739df4cac9ba6c01264a5612965737dca0e285f17cb324f469dcc7d2b81fbbccf7a7c1ceb7a22ab89e1ac74987668dd5984ee4aeb46ace48571eaca69b535e34780220c143dc335f4157dec57d0acd84a434e56c7d17e8731f51feb4c8e3e2d2d0b3ad41e154550b3e52484781dfb1b3a5f2ad95b813956d41c2f77e0857efd631ab9222ba659a7747713a9d151a692d4cc60b0fb214b7a91cfcec03a705c68e5a2c57ca703b24a89e62766d2fb4a483a49266bcc7cd89d4e3665f3915bce259b255d4f7a4bde1287ff84af7c950bc9747ae905e8e8ce4728c5e29420c9f70e78fb42e3dbbade4eb99bd9bd96280f096da29b23ddcd4aa0f5836fe2a28b4fd844469afa2fea6db2bac55110744827660848288f71af525202d039d6370e21afc9a94178e16ca658ad911679ab66d5fa2dc60c3017a8e0f15a4089a9d8218af41196f53d8361755a56f4510e23678fe60663d7ce891b9f2be710beb8ca8cb1176d283dbfba464c439850d58d46137265a649637071d0da36f4e14193eb8ed98ffe15e517390674e63a028bb4ce019bb487281718cc086b932f018ebf3347b1bc736ed14f1c9edb432df0e1fdab7335614593e0266df0ed1d578dff45f08b2cd4940386a61a989e786a98d966edaea62b25e1b6c6cca4d18be1b615e41b324534899d066334a24fef0ee51b3f060219611106c7a9380b66758b2ceaa694eb66f351d8106f5044683a4cdf4ec7c503ea89b9dad5cd79c095fb58f3db37192de56f588eb13bebc5854d2c9375b2d6fb87fa3d1ac2cab3617f8b1bf8fa4ad5eb52294b6f94f7cc90a0446b0238bb5157a371d8ac83808d374f89b931c0b58660761fd11e1b3e6b1251626131ee01198e49e2d7a25d471d7b5f5600f3a62d1bb85e69b2a8ac56ba72713245bb6340938dcfc203efc95bcac9994db73fba1fd4ff26d98a172567d3b10ca2069e2416269751edc592c8eed01ce34e9eef902ef63e55c92ca0fb36fb41b7a4e69b45a447a474ae864e03b98c056c1e49651da8035bef18c8360eb9f2058731609d40cd63d53e6239a34ef15efff52de7c0c059a10a3d8c7a04fe6229564db831865ab416faab21c04d54388836de37decdda2092355f51566886196132009060d236a1d260beaf14c5d3456d01fbdb989f5cefcc9081374801b2f07acb204dea75eca77d1f35cdcffab000a1eebb65d8afd002c357d4d97aca451f63ce68dcf15f36f757d96f3602e68ec73ab18c6d7c11277b5a9365728ae47d2659f37bade8911bfdcd9267486d29a0bc15c3c8eae5a4e45a8a8ad37e7d942c08516a5ae1f612f6d4700387b457a8922dbd6c480aed5f088a14c3b8c224162c71c79aa13f94cb860f1728570da5fffb9397447350a0612b0e6ca8b9a9bd0d6be6103dea92f6e29e4d6173c2cc250f346507a39c32bb419ad87ffa711fed2888a33cf5d5db6cc9ba2115a050b7b2606bb56ebdb40348336bc717824cd7d51eaae5920c572a0083b207f0adaf0902ac5dcd5301e914eef719b81219cf3fd091cd2890fc3ece8a4a6d70e3901234358f96aefb5e860d355b538912b895a47b09a1b6b7b347d52a02cef3dcdaea5af3a00aac66cbb22e443cb6171fd441c3f0be27c4895e8c592cbad9ed27252d524691b3f0246396ef58c439281d6c8da61d6ec6e5e717982955ccda0f42f3b9d84939d408dee8040698d00eef3bfab67af404add2e0893042be71c81faeccdbced2180a0f89324694ab1e5d4cd4047cc0d46c849ed54882055e6cff04634c18328ee73642573d110138a9edf82a73058d281b3a2a7045f5cd11b4af3d884dfcfebdee1b80f0356fdbac134161312051f70d2924135d4d10bc7483cd9832c8bf25c3c64104a1c4122ec2199e7d1fa7f6294a428c27886772f6f38904dabdecfbc83843f1152d40772de424d08b06b7ec9dc1a8e9ccbb03dbb85ec864a87cb6df3ac390afb2e034dde59726452c473b0225c84442e4ff1840a5712f35432c5e2efc431ef63f19140416824af46edaa93a0bb4b3105774585376d89c2d2e367a0e8ac0b4c5a2233075bae04b17c7f6deca01f65c59689b0d8973787357b1b7e7ee71f63247341bfc22e5fe1d19e0fd3434aec44f091e31686366567eee10d206c1d63f2dc742717ee5874d4c83cc62b98e66436a4093bfec2b2a31449120f08db06f490b4edc344a0bddc06b70ac3c317d2ee74c566a706fe71e7b06e52247cdebaf4da60d8a75804faed2d7c8d1d63f6dd877d22eedb9275a13b10e3363a24b10b289a9a1db853e2e453ffee300e1c03b64c7610a1f2eb84a314a1bff5bb79ad6bbd6353a80f890e4a5386751eea4f3292ebce7e02f4c2286be5da8a2ecb851fa8422b0f1e7ede42f5aac3e0724ccc66adfe40da51703480c7e80fd8de41c060215664160384f8070b998c76b3373b91907ab06a4de0bda9472ea4bea4366d6449e8850a2560bf1092cb78138d5404037f3aefebc5441705f2ba74582d9f75b2c97e55e26d44b8888beac74944e86d40e9339a7cee9e0f8fbe2c7bf029a56ad8897077fb427b7f21db8553d8cd20065a0f5f4ee76ba07559cb8d37320c096392c0c4591a8bdb0d7c16aaa75da1c51e64a8326b4db24cfe3e7f77023c85c71b90458746ec8db05241a71990d6a0bbe6bfb799aa499dd6e99972114eda53c6147e9d31ab8cc101fa36161969898096da234fd8660f213738f9ba4410c8f28a9fce8702fc20e65a852fda530f8e4b22394b173d2f3a60f1d85bee018d20cb739549f557d0371640f53bacabd5be1160d5eebdec62f07117b064e75c39ecddfb4f047dd68e9c408e3e91af6c548dbb29ab35179f97894519fa00e11727afa7f28e980dc9b3a54018a6336eee3e010b1e6b62d757ef55d9263b426d823ea1cad1be6c1903c2c9e921307a21fcd610ebf8f4d0ae609d899f1d4e25d0bf26597d310527c36fe0c3240279015c4c56158ccc4b5b21de52484c547e283d4646f0821702f6c5b6a32418c4e9d51a291c7b6ff1a80eb9e9d83a108b243f844c786d762e3ca6c9cb8ed477fdda16ca7397162bad10490a3ff5e0daf72e152d35d8871518ab3ec044aa79e54e901132fe00ecabc6d609d4ec402848c212cc9a6461ec6dbc638a247ad9b0de2aac47358f2a5a1502fe3a9e33c6eba8032b5db7f6d5732c4e71e2553faddb89f535949da9eac255e2053b74f2fc15e5114ab74bc9e8f43fa432eb25ad022551334152d2f1cde086e42da8f78b4a8bdff284872c8e81d50b2e9243d9f3fcb77a1fba38245290370966d2ac445873bedd3f165b675bbc3a65e04fcffb8c8014f3dc5bfa9e493f6150731524a87373a9114787c0ea9c45d445b9477908ba8155af99bcfbe24b01e8b77e7643a8bcca5804601390f3f0f07b6c3cfac54cb19e9899a1a3ec06900662b66487f8a64498795f01899da674b84f073f8e02fb2dd682f6d1af4c10c6bb26aefcc120bd9a02dbdd7836346213c002d7cf8db91e71cf6f318142d4f64dbcee335671e7540fec54601e51beeae9e9c68f3cc73105bbc8382521b88430d7030d5111e8511fe4a81f9d719d7b8c804c728bcec5e4f9e50643f7b98a9a82e99633d8a91ca8d2721019163da869bfd968371862d0590b28912055e26b5df03e304066eb64bbee412dfe264889c6b1e30dd03e7f6abd3947440626701df586393803649559fbebfc259fad3b07782777f978c204a3ff273c1611a6343ff8527b014dd7b07eaa764eab6afeec0bbe39caf57c600f5df738b7d03e0ed12a94fdd734cc9873ca94a3ce4fddcb92932d8cd6d9d5002670a55775edad4356d629c78461d21943d180171d611f133773c8a10aa783940438b81fd6d0568b671f9cf1895fd3602b391921fe3c9d7ab8eb64e9520cb948ed4cbe750ca19d35e55ab4142f6a52017f4eff32fa79b891d08aaf225f491c83de656a25fa09ab89f407b2b8038090166bacb5001e8bee55dcf2bc95cf507a5aa1dd36476e05ae7cbc0039b1e59db855e37948acc081c74dcbc3b8ba67793e271f3bde95f9aa2df51fac1d6e655c6f077992e81e40ff9f194fa8e649e2c5eec5af8a563245d8fba5c407663bb5319f973256fd0880da6f3d3e99db67526b665bde5735838dd8de0b67eead4da19cad4d7aa39143fdf260a8edc73ff1ee132a8e94a61808a98c13b21926acaaadf939dbffb184e6757ffaa2ea81f36c1d470d0ac030b8b7c40efb9909c9429c4974a3fa4b4ab535f5a1e5c42fa6bab00113bc74f973b9c33944c55d2a10d4f0051a8fd3e7f07c037372ad4a05baea359d65c57311d2dc38b313c0ef24fbcfc143d6b6256c50b4c6cb2cac15c74604f1d5c07a375716d1a878575f9286990a041ae16d4fb49457575b0a53951446371650031290aaa056cff818d541bd70e4899f4e44c9fd77ef6cc33e72be849fb3945d7445366446e6352be923462feb27da25717ddc3d5c6d1bbc8ba26786f4a89b6a137ba53985ef16ef8e4aca3e42580926dcbe82168fb0e84a12f6a02a29700c91d9a4b475bc34b76cb0074638e4bb1b697b251a318f9eeebfd2aea5724626f4431c8fe96d3176c2f91f82c4f45bb05095db93b4a6c61e19c8397605ff5034b117a2a183284a5453634ec8a7dedb7eb3e78d8955807fc21a195f13af08ad510f8e298beb240d329c795cb40217f5c807c374ea970491d23629b973e453cbc3ed547ae4f8b041d192a86a83a8eff0028eeab6735f603e84480d24ab2dd94139939cbcadcc9d830527ff01989c83a6f2d2d6ae037b93f338f570836a3db9e31f6ef611aebefbded7ccd6f311f3011af80b0e316d3c3c3ef0dc4b2e32f65dd4e8f295571ab3f3c54e70a3d1dff87aff9af17fb4dd3c7b67e5289f6fb4ae6bf921653560018c061b96721fae65dd59c59e64d5fb2bf2d19f20eb3d661607fa00c2608cb45f0506795a8f793fa2d98ba0cc50d82dbaa109dfa7c2671c8f9f3e4af4ac87a0bb7a2c8b593c7d5896d268d79196ef56dbc4ecb3d870d29ecc7bec2b40b85666dd310a478bec1436c8e0b3157e5fef5cceae837dd81b023879661f9b336a21de3e46541d70dda153864a49796262c3fbd2f07639868b641ae01589841698380a869cc7694f49133ef840af9a65d64382b8f33169576819fcf273112e632a119da1687453c35e631a8b74a0bb731d0ec5b61c8a3d1e2c8e57144ef556b0bc13f01edb0d13b223bb9d9a211f2a2e47fb0e486500575af82afe4c2c568dfb747e53eab37e7a1b0e41c86acc836a8f8c5a9628c2bd78647ef0827045cdaca5d672c4f788a5471053df1c9d0bc5ef2fe4e8d35795be1a5d3e3f1e067335670396b5ea3bb03bc90f2ed2bf90c12668f82bb8dc3f30d4f2f2be170fc777d738a0a6d781ba50b7553360ef0bd4ad3d2cb794871a8477881514db7d5c9fcf806c48ce15bec08d9f08d7d5f102bb50f0059c140c5fb8e1ca25d95c3bb1d66577ba8aab122556bc3bb066e8f4e055ed80e4a91f69d9685c5b578ac02cc28bf3d81bcdaf32f3c235197671d91d370679eb2f48f170f4e8a8aa36f0514a85a1c9841ff5cdd812d3dfc743acd7846ea6ee8c9663a38d6431723aa67fac68375f638afdf83a73a4f88f2696d76cb16aea7bbf8d025e5ba4cd26879292b95415a52050ccfd95214880467cf19fab65ec6d8b372f39e77498530bc5a1bbf9c65e7c1f9a8ec227a39499817b934905c10731f373af9ce17312fb9e6647c37d2c888b3377b640dc7c0e362bb2ebb3c47014309c537e12c1d1cb9f73186c5b249be6306ba353aa5c185836a3723cb7b649c77a7c7f77ad619337a981b99f0614ad47102b8094dc7aede92a2a5723c9aae2bc8b55d588cd50e5648e012714bb4f24d79f86ff41750e37472a8603cbb4924c875cf90a4c6f38aa428ddb6ea8ab442a81333690bd801020c5ef12071d43c9bb081bbbeeb1718f0d6aa5ab60e52d269e82981e0a94ad6c08960fdf29e51cb5d0f654baf773d941624fc653251db04a4adaab97acc0369e42d9cc14165319a4c5d162c634e50d8d81ffb3d1a630c05c3f2a8d20c84008ec6927c4cb058a66c08a24eae17222244e1b50c507de6d36e65ce8bd72f62e9cf3a55b604cf062c9adc70c54a07e1762f03b4d88eaa3307ae370a70f55c17bb517f25a6b5e206c4feae5ec65d30c894e21efc40681a40bfc2e12ec755c816919aba47a92bc69979d5ff3fdc62e096f24c9926c44e826cb4fcddb0e5aa653fb35fb34b1209e413de99128216b76c5ad756462b7e908d7ccfa61cb56eff14ae305f4508ccf342c8ddccb7d0777de21bfb5ebd14ed258d031842afb4d418751b416f157a905786402b72595546036facbae99acffbccfcdbfb2b7583c1e3e61b5e6df22c333986a054f6a779aa38003aecdc378e66d3c291972cfae3d775ff2f91","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
