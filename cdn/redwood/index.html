<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dfd1b9c3e6094f574eea70b88b33ae335833187b5a3c68108015dc9cd8055b199596a7cf90d05fd49936b80bf527f9c125f7fc5ea4c92bbaa156fa005d2accb32094ff484c3eab2d88eeff6df5539593049946b7fa32008766203cc3b0c2ae5096c88eb2f4b808cdd0e8cbd1c6446e6c6cd9dd0f7545aa099d56f83ea798a9a1840c4322842f1d8771128954cdc3fc2f72077ab97a82e2973e7c90395ed82a5b6003102b6b6a4b0a9d735329c81cec57664208d2a08b24dad68176f2e72a1ebb7fd1f383707a9b546134e2687a5ef891c5ac7b446f99f584e57b0d1aca15d4c20036762f157274a74158b9e369b9f02ad3811c14650c7f7994a61199538840371f6031478f1ba68db7f02b0bcbf08c355f58b0b1fdf19eba361f824afeb2e95d4c374bd621a6d979811de80747f1816de4917e9543f87e97b6ad1810a3a424c0a1e74eb6e57217f98ee08b49d79fd07158559e51c8b8777950b7a9eb3a1bb8e43b67e0e4e0cbab4a49a108d39d24b06d40f5cc2451824f2ba540d68aa34eaedd4444ef19dc4b6f76abf82d2bb67c99a356046428dc5310f7fdcb3f089febedb6e181c3919e7185ce7633011cc910496b59e5865c87759b8cedfc5c546914e62b08534368a14334283a340a2030234adb500db1ac12b937916d20f5051e3c4652ff79a8e9877aaac8576e46dfa5f0e0d0fcbfd185e9e92b0350fec8e4240ad107f5362180bfc6b771ee58a8d9af912ba55677bf6e8b6d6f80334d1735cbb465266a3703ed153301a3ebe90abc673cb7e6191117a4f21fdfa308b654b37f35fa46fbaae20b4017f1757e5ddadf0df6ad21257bb32322c8ce579489dcb2804f693f20a2cc85dbd671c3f6c34bba3f868beecb1f88a9731da4b40e26265244e5e633b507c2d8af7d910e34f1dddf33a60fc027d6c2ba409fb3ecdcf9be54b5e5044786a57a23adec02f964c6d605f7bcea1f997898c16bfa45e9c8ba10e3c70db102cf265ae2cce92711034da4d56523abe9ad03dc8abb7b39539f36e9d0ec189bd1a1ea712389d0d434eb7bf0206fa4643c4edfee688eed040c88741d6d1dc1ec1da11cb7310826c0a98bdd6352d18de1e18acacf126b55b7f9d0c512ffe06c76baef77307da4416f827588731083a5a5b450322650c647403c040ac1917162b8e884d1e20dba4ef05084c6114a515f043e011f2044d6075d0eb04dd808e96c03ebe9b3348218ab3fcd7f37aaeff082781bfae3413b87eaa16e5f443d93de35da28d46f4015e6202fc7d741d8a00fa9b4d088330d96b493c4b37547ea9338da40f808583b63ac32c762164e7ef82a65ef6e9282d0e27a822459fb29003cb682b384b0179aa88f14e05d547ab322d490193469f72cfec340e23723f1cf254fadd6bd835b6186790a35beae44344846e339900a7c4dc85b7ad280fce6a92750ee75cd14b630a2fb667092f4790dffd21d5d3801149ca001b951ca9c5d4ef437d5c5f29d3f0b8cbbd96080ee48df9d57cca2c6d2ff3ac106fd7673081c9ed91147ef4e97f5e2eb5b87400c2d60eaa003ee4d1b1fe3964f2f124bc814e54179892ec8b48eff18107f12ca23a225c816e64bcd010201662484266bc4d9c6dbc4b79b73527cdecfc743ebe718789665cc3b3c749852bb0fca49f0b2b571336e159594a0e793ff0407cb5eecdd9bd994626028ed6def2afd343edf2dc7c475b5c101668025f1eb71ce58f4f513e60bbdbfefd06f8c53ddf9adc3be2256a4ec286414e03183eb7a078689768021b96486a96ea11ea9da032fd566643a8dd4636504c4280cb5342c113919046195ee8b7f04a44734d27eb60bd4ce88187882e186af977a921e832042b92e90d108ccfcf7b6953bd89834309894ad97eed1ec89266703d18cd94c7020528f5ab4d386cf1f8987ad969ddacce5185df5378b0b4983251277569143f6be39585a2f601f911bc18a5b1eac327d5cd4c7dad1d523e88af385bca8f6abc7de065888b87df2912d1fa273d5954524ed36b24ed336ba67a53cd3b7415081a0577782c641442ad232449682e2910624635bfe4ef9157697eb185d2972067a40ecf35a05710fdfcd8bda91b5e771cb47bf4a882502b1bd16e144f56adcf020758393d3d368ea25c99a93a76379953e93c7d726c59b03861cb7bcf34fb78fa6aab3699039807eb3561be0e2236dc6cdfbde699f5e5e434dc51b516251016ba19f329487320db2830343880280d29ead2253abd2f632b7b0c968eca8ac6c064abc94b7418bf2c81a1fc9f08bf1ca6c96a7883c52e8f34d0ccd1f0d5f0c0693d980063dffa51e39eb3a23508a4c475ce546caa3f2ef2bddf8f79acb57cdfc35a9df9acda7ab7d38fdba332328933c732832d28c074bc0067d06ca3f25e6e8d790382be8cb0120a6c5178a6644cc4c13bcdba985856a49f24b72a4a5088e74d6bf882dd443c0b4322b07188e7a35b96b9ae427f8f30c428a742f0f1626524d7a53e40a9479cd31dd4b56c4de3d079aab23578815e4a18c4830fd57288a131f6aebb27179f9bf93100b822a7d1e63af7a655a1d38c46c1561beef97b5f6b8923e9f5a805e40ad89326a1d31b36c9fc5a7beae74080509922f2c01f5900d8914cd326fe3764ff295110e48b6d9148ad1087145aac414a3a1876099b4fa16e1af3e49e7b168d0d4012d1190c5b7340efceb02cfce76ca85401b20a650cc92a0816d693752d4f674af620a62fac4d0d34e4be12edebce85fa5a5310a2cc5c3bc351faa5473fb00fd3bf00d848fe08971b54e430ab2d7c522bfb7b6cda1aa7c4046d11f5920cb90f5ac83648366f3514f13d33c5d2adc8132cf7f749a1cdf0bf257c59aa9ea2186fc7fd69f58cfc5d6c90be50dd498f52928474fdfe46ffe0e7ce69a522787e1f7ed52deca57ed804b2882f09763e466a976f78e6d61b175fbd2b32f0b006c611cf9fb4d29f6765aa0fec530217f12eafa0b74912711c7ef44c36003b32a14f184b8beb40fd797803b28d124656ddd05015105f2bebb5276800a38554f1d1c2fc79f5b7ede4ba6400a55b088e5978b0874bf38d61d2f1313f47315f70d265d2e2bae1617d015d9d12e738fff2b31b0ec2a98c2b3ffb24cd691cf7e462c1c51c392523513213c511cbc07b5169b9eebf18a2f07f64964e61a09a39b25ce41adf97154478cd4f97c3257e4ade9637a6e326447618444666cd933c6c81010425044febbaa6e91634557eac7fef25b9ed6b6f1098d32d686e6bd2c802c6599ef5c9b853cb6e5337f49ef6a7b10cfb9eb8ead2ac6bef3caed7580bc5653f07e2b32da48ca8ffdafb930a8f1831562b475b1cf7e527330a7898a0d4a5a6c7382618cfb1f91888ac4151810165953329c3b0f4c9e9226a8e3a064af20a3067a318d06b8c06171391f7aed602d7a9cf001570ad0544390a73b46aeec077d39f28e2b2341635188f0d03f72adf5b6e55c5b6d946073bf955cb1aee0d8b61193f420e8e5b18118e1628f314ce82655970d2d906b16530763954002f51f32d6927ac55c13eeabd5d7f48ffce5fdfdcec5c31442a32ab9503952cf68bb3eb923395a32cec6008d0912e0859c0a44f69014c16f2299cbbd96cc17300849d8e420a8769a1701afd685334520707bb8a0363f0bfccf7957679f8e5530d090f34d272742215fa6b297fbf04ab809102023e4b7c4c2c5362e9b47866c7efc543581615f198ffe12fb391e9ea3646768861ec1f2829075f0b8747eb677c61f16135aef60dfe25b2656c5585503669292c4a0d7e3c48d0bf8a004599253747150d76ae817efe64ace432d7a7b1a1c06115a8ac9d293d80190f6e01e978bac0b5ec3e5cb7685f57021ad5c8f8b9ec486c17c5fb582c8da8f77e8256a51d5f649ca731bd850749d224cd104cda3661c3d05ae7ca729243b658fc2669c1996e175afc1ca11acc684d028ebd7e43e71942bbb2c59907ae64bcb58f711f15ab2a6aa7b6167f64e4bb71fc9ef7672ecebbbbc1e69864c220d2121abed30e6c14a4186d4fec380601529f12d02a5e15da00f77cc6e66cbef26d3c102de4bacbfa82049ef81d5d141fabdbe51c556d90bed4d8d7c31f12853ca8e82abfce0f5ced1259dd6a31709c1fbc1e760e89410596e6dfe1e530fad23affd57000ecc0d2e9c24b8361c0942c440b5aad70fba634bebe5bf09098ca84fe7acd76b0651d460050f8b4cd6369f0c56f6d6a6d7ba6676c8ed34814f8df64f6107501af7c4a1318f69abf66cddcdf50a28eeb995884ad5430dcb5c7407bf5dfeb4f56a3fd0b735b0800b8ead86ac409f34f3a7ffdf0d0b176cf6a3c225cf4786dd132978f7efeb17913394d8ab1e392037ba323e5b2fbb0a5ba04aae895c35fafe5f02b71a1ef14c21e6a1ad03e53b42aa4e4b2aa0bc6656b5c8bdcbb0fda5017057502162fd7b32dc31f1fe4770b26e0ad0e3337f42c58326a5549cb3cbef3889242bfeccdb8003d5ef5f411802cba9a222069303422ba267bf67e8b608c5b09e30da433c17e59419053fa7afcf191eb6696ad6c5d333ac12df45a166a60afde443cfce9f386f0f419fa9f11e6e1389d5a4c732abc0ea7b59b5300505e446c3ce8d780eb3d5bb461eea3588479e8a90e91389f5b4ef89b877e01d76707aa38c42d185ac84f436ad5bc8f0379ef040d9bd506d8682e0e0addade3eb35b2673f1b302ff4a242019f27c02ce843cf0f9b693f40128d4c7c993111a69065f8c31e015939445fd5d1c25a2a21e440d10e8311f52e42a63735b51c0dcc25be415e377c5d144998da78e2539a027273c9e09b0718047e84ca0823cc6ce07b0e6f86c775ca5f164e8e6545f25d1c91b6037bf18462ad79f5599d46d388d71467cbb4285d3be9ad56c1e07515dce02f3cd1e8b81a175898c8c85c4f10ed5b0db8cc0cc29ec70e3d6b676b910a27cda3e9a06dde316d51bc0d90fe5c78924bde712227a7fd42ccd180e5b68ceec035baf11df722908feb5e9ffa0371c07b801153745a31d921dd8fc862e5d0881cd46b592c5e6aa8d0545fc3d38f1c65deb1309d291e0171cc3ae7e86086db52237a88dc712aa22296a5e346225e775b7840ed57855a686ba0243ac7a5799b08c6648b7edaaa7f78aef7538e7f4ae39d56cc86d519f9aa6c06a4e443dd1690dba2ad5656dc3124ac07696d4c35acc0629dfca9526036715257c824c25d492361ff5a8a560c895feed737708378b0590aaf4b63c1df3bd8a098c974c93d05976d0f991def675eed15b956e40715d9b2d933bfcac911b2c58c78e45a41b6f2ec646c0e3eeb22ef28af2ad2fb8bda0dfc2af409d36ba856a3ca97d9f6e08c3257d7dba398b3fe9493e738cee237af40f84cdad97f7264f8670d761c709f5117e636eee4cb9899af449fe3b33f721c03f6116282eda90316352789f2dc01795c3bf2ad41d894721fcdfe61c096f91697c97b310de61fc490a607e4374899efb819807e088e0e4a5fcef73b35d5071b5494ddfeb0153f1cccdcacd4690950bc794af8e6a74c055b327d6b8abadd87dcfa95347a02757b58dbc4d0ed4dfb653c299ef26ded96cdc1bb757a4f4585412bf186a7a7c4b91ebec8aef1509f2aa5d02c4b63dfb142fa6d18635df2c079211a20cad78086b6875679bb08cf4259b1e2978b980090ca677ccf9890d917e5801ebd51beba84558ea9c83357bb93ce6e99a82764abfdbf19205026de98ed20a313288e5b3af4aac8817d18d9e4a1088d4f71626202a1b32eac0a793edbd2ac102336b00d8b007a9fdce0a10fb566e1e889908f8a8097303f7925113a5d7addbcee356f805d3900489e39194bd21d76b6d291147116ad7f4b149ad341a80841f65cae7d882059929fb6b1d6245cea7a9a5cc5c2c51a7ff3cd0a95fe847c3d197b90aa903c3f4675687bd238cf0c7337183696f3c81eed571366250c8def1ef6c163e83eba9a771347c4f7cc82c5112a29355c52bab158cd16e0f9ee626310dcee2326f4c7ee43bc3fa474238894bd11a1824ee86dc9afb2bddf4af7a68e55f40a29ccd26dbd19c756b3125bfc5f492710a02fdf5062febd51611651679e94bd5b552f0ecb36a173c002509cab9af0e3207c8c08438764118b92aeb18920a3215c75cad88144366ff2abc6d9f8ddd634fa40615c7a011cbd0676c925ff4679dc59f11e5aef47df92e791148e3ac410e749ec1fe61eead4dc0da1acc96314e52380f643741ef96cf496bba2a0fb125dd23c44693191c72bbbca0ea15c81a653e8151b8a5871aa04b77b52fcaecc6726c376646681eb39fffef4086e546add847eaab4188628484ec26a9eaedfc98716893239fbd745410d128d20841fe98c00aed5392f8602615a08bc584b0a1e1c9d7a26ef1ddcbff82d3bc1ab704a4da1c2d35aaafdb774686b31b680cc7521939772ccd6d4f085e4df3e2bc572f235c622eeda0c6807eaa794bbac863f5f2c35f946e6b4cffe9f5a2bd756ec4a5ce869753222d47ee7177d4bb089f0b5ee145f863c235a839c175bf066002069ff186f866f30545837248db2b38bc4808a0a1d2f85f04e2df838e8badc41d199b49468f4c22f2ff25de9431c716a6771525a93f103f0f0c5da73959c9bd8626d1b792ef6b8e9cd3244f590ab398ab80711e7396c1cfe6619079bd55cd633de8cf22c57929dc5bbb165727a714f411ccb5db57b74e55f679912344c24d6404408b6883e7e6b9d530dde076984cfdabb2e7be9e4cc011feba943d806d919baa328ab413d6645a117a1434090b3bac4478c628b574d25c9dd1986381fa00f115720bc0ca1e49baa5ae846c5a623d94ce7421e64b590280a6e1908b5e0de1d8a65d173d088c1030808ee3c316a49b7a8f932f72f9adafc8bbd0cf35d30f8d1fad002962c75fff59b3372c2eedfe4f6af1debadc7e0b4cef598603ae7c894589cf638b8f222ca3840e1d09738dab23db86f664718f432f9e07bf89c0be649b65c11aac293e64a09032157ca9dcf5daf888d6a306f9826367d0e4af19b6ad339188ca1c683b33db4a625c7753f70ce3a5223f270b164a66242f5563ae8d614bbfac23aa0bde8b9ff843c89df8c212acc112e017a3d5581c768321c053b8b4011a4fc81d19b4ba0ba8a9d769dbb36500f1a659abbf2cce37820d393840ed508299e0cac64071b9d540534db0ec80209b2782e56fa6a2d8fe0b399110de8463a1c0ff5282639a1a36b0c32646459b4ad4e0bd5dc7d40954153b7bcbba814c97161751ea881619bfa69407cfefc641d0f137cb89b2f08192936f97d1c2ab3c9661a358bb489bca2a8b3126a3f3e2a4dcfbd2b00e3bb1bb929acafb322c812b67f8292b46724c415b729cf51dfe55ea273de8c8020688a148fc69bebbb83f074851b0d7ae09defa388d273eaad03bd7d2bd16ffc88dd53ac51b554455f7835e7f8b1f722bb6af06ae0544c66d60888724032123704b088e7f147462e894e0020f4884df98dc08a55ad56a9eb7092859d9caba35b5d45c650d654c128376b190569f02302eea413cc689fd27262fe66298b780904e4a5bf6f47bbf923660f5801cc299486cadd1758f5962a38b3ff1b9e912b54e091d811421da783a29a007b0ad57e5006cf5ed7750eb45eb48e04ac49d68b5a00ac832a19882b7398a673c3adcd76b43f63df826e45681f3a1aed8de5627616182946592dfc2670f3209871f98e73554a45b34014fe9f0439326dbb094373f23bbd4cfec2e8e4a0f3bccecdd85f4a5dc6f85bbf06d46af880e901adc4457f6fb315ef4c70eab14cc7f14a8d729bc85a0092b3ca11391035a2757f76309187d8a10a918b24089f4de18589d448d77dc018954890e849dbde2a81a6195da15a85e484e8e2fde93a22906b8d0b8af3a29bc6cfd92b76b4c798acd2cd846d164d27ce54fa49fd72a99a30e331fca96827f82620167721556b16cc21fdeb10e2183081802ba875f65cb3def508a3101699c6afb2db6785080dc5bb778087d6405cf91aa46bc6f2a4b078648fdbaa215766472bdd6b9c0c195435d395ac29a99ba05a8ee082ebd9d67e807420bb7788f2ec5f907f7e66eafb8a9610d39f7e59a9e783d4a65ab68d98df282f2b7b5cd00cbd3aab5a2ffa3f732f55aad509f473d70c7eab48bac1d0f66f73e1379615037077f14d4616dd65d4741cb8e9cca4f70b23d0855d30957b7822bcc4a730939e9e9010a9f101c3285412d705756dc619992e994af7907578a9738f0cd85fc8ab350996735ee56809de61bfb8d4697341fb254031a8033bb96906f40729141c2352f5514365bde5aa38d0ae0dada41bd8fade61a3074113b428ef8cf82fec4b357ea9f09adfd22dbedf67f006272c94f4b467ccb1f9175afcfad7159a9889bf972573600f89d5047775df23c8c318b430d4f6d6c873b4e010d33b0293a45b55c761aa38cf7498f350b412321010e3f5cf5f845b401332862441d3507051afdf18b9007e3c80af8873439611bfbc99cfb886583f758e2b2e3441665eb1b50d5e4d250d7886eb26d966b954b551186d35a27ac79630be212fbea1022e4de4ab6605b31e6a922ed1ca5351315cb9d27d44da686152b1dd6f332675163243a9fc9b93b9be2df35cf9b667d3b4c7bef0363600f79df9ea81434be5aee92f53193041ce63f597bf1b6d9554aa71c8a2ee21b06654438a733a6eadd326a4103e0455aa485322a615da75021e9fb78123b4c17d0e16900c36cc45072c18ecd0cf9555334d0d457295a2d87347259267f62f276eca858e54d2c20161c11b28ee6e1fba49b24684cfa69199da00379f4c139dabc2559f5e9dd34a940ef5d3c738341534a4c61ddc95eb20a575247a8ad80ee39522b38e99a829e76fad2a7b2a2040cc46c919052f640a529fad8969d47292201a36bd6809f22b1ef7d7f00119842f0784f99bf39f3a6a23d51ca1d76240e0a51d9d4b3461f5e05f1018b1935477b930dfb02b90e60305239dfeb370a24382206728b1d2b42bc267c76a3e9f174a1af590b896284ab97c9f693c1acbca94d300886bf29bb4c5df313a5595397dd86fa06884737f12e5b1f5675b70c0797911d769ef71797680c27ff19018f5a5e9c4a39836351a9a92e59c0ec076adbfe58e98bc79464cb635b1b97ac8d041031ed83e09da81d39d17e08cef7b2543a2f495b34e82f6478a227e0cefff601c9bfe36d4a36e585fe45a137c084c90ba94e93cf5b154303591b70bf30cad46f55f69667e15699a6df8ac20022227e6894bdc64cbe617c7e093f8d12db7b8b56d26f5a645ef781987642158449d6ef51404e4d65b5e99b3b3accc7f08f1ec11d4738affd3c32beda655c347a263e3807e6da5d6933426ff67bfa4559b1296effff859dd30c2055410cff253d6205df4b3938cab77f5cd023bffc76fd7f73bfaaac0741abe12c9f3c68372c477b1115f4d4f1e65bff0fa69f130e43af7b4ba51fa1dcada32e00f840fb4a3b64b7ad021938dbcc285d700d9e82e013aba6d516f4a33c1c57e0748972b62ee91210de77e11679c8c465289bae46f30ab73d88c196decc936e3699fdbc460ca8a1b212c1ea6772317aef03639fde37109f68b3171cee093b786ecbce72a06abc4597a65b675391eea0e60955cd120002a2259be3fc305d97b209dae9357809948fc7f5382418bb7ef86de326da838e586db7dff1b6fb9727e087ae1c9da5b92a67575e0bbad81b1e0a040dbe2b295bb9f217e8445255272cd5763d261cf5df034b7f9ffc4d0a62a55471ba7c4904866e78e9c88ff5782b1876f77b5dea888df3b8714ae3be1e94c5924b5fb92a8ab5aa6a6c617061709c78df13fc2870f3062c470c818415de3d118b604992765d6f3cf146aaccfc5d068399ad55c6e13e08ab1b14b6f015b78231e7cd0be14251aa28a52e6b610a29b15e9b0d160caf53af40c73d63dcf21af32a7b2fe18286a85c1fc702ff4ce62d92a25dab5bd9abdd44b3f7148708dc3cd134aed1382183ebcc0c85ececc28be02bc4314ad61421bdc08531bf5c7a4e8e1dda2325540f965e72293cb988b788a1838686a8faa5b103cd0449967a9540ddd5efe21eeb93a4dabba61ad83df319feba1a742014bc7c29b4eb918fcc9cadfc671a56fc40c538af000cd79faf02bacac3a5719d7632cef56ae1c4ae19a7cbc7d7432c77ccc1e92944fd19dd0c75a8afa9edd2e18e6b15a8a118a00c91884c1e89806d517c6d34ca8af814dd1d9359f3ac555b769918e54a39aa6dbf49b4e462f1157e0eec63a086c90620d3ba29b062a7bad75964d329b0e9996a413cf445ae35a818c9e4d60881659b7fd985dda1b1ef9129f72f62aefa346351e6ca27e306b5d2a6b81d4a1fb4daae041b534bf14751675c65f37f414518e7ae0855e205d7adc3a11e170f3e6b4726602dd64b1f1115844d102f9e55183e6d0973025eeddf0e6d89cdbc19e391f7ffaa8ca356168fbb50ef461dfff829001d5d95a77b4bf34ea11398f3129d1c1187dc5de39c8d010802bcb17f6fcf0ee71341ca045913d55100498303651d3b06a5cdeb80644c5b8a85c5db685f2f91d431cf760726f17140f6e9ada3e6b10d0f22c14376420224753962b18cc4b89f88716d01f4a8110748926e8dc7b08c6f6ecbeb7581f610b780008b84d034bcbb605ce67b0033feda6aa9ed2fb804cabd6abfc1ae7f77c61ebd71c0c62a70f1c89308f6fb6bc72d44513ec053fb21b1a9505b68132b87c8790646dfaaf78f58ac457b78bc556ce047cab94550fa6779ce1155d674838aa29f5b5838e6a28f41419554a2e17ff2a8585677278fae20304f3b88db327bae989fa271bed0ddd478a9ed450beab7f527d0f0275af4e351d5b2de53b7197633b1d1ba409df76d80ea25830d4a9412e43c52ce71a0b10b5da666dbea27c48e1af343b8f41d0ca09cd02992f5e5d957c1cf2569180739a7f8a887f40358dcdbeb6f709c8e04f1dcbcbfa04286bc02b50224034d98e9bf657c963188f049633abb5f212a60ada45a0a3a722e73c53b08af37b14f4d768849c235d72d7cbf1e23801fc25b0302f7703eef191f5edd988f0e4b2bbcbf5a8e2c62557b9ef2b2b09a13db78f9f1979aa914f44408083a18a3242ec55a05b2ee01fa9bea11bb933913860811b6a366228842f50a6ec6a620bb2db1895c97cf548bdf18c3d54ad803e2f58b2fe547d971a5a3166bbefa37e2cb4221600e4f7c878239cdaf69cec0430d97aa3b9248d76a60dfc173386854603f8f2fda8ba43dd88d1299f97fe9b8a829801fa1b262248d0dc863af38eaf7e8cdc6ff7eb5bc8cd6e3c1d0d1b85091c1f0b49acd70ec8ec82ae54465473419a7e8386a0b021464baf4cea4f1937812ab0ec52690d765243447e79b6ad1767cbf7c6651eb51f77d741a5a6ed2ddedfe8aa2f337d74dc2ba037f151c32b50fa4d6650f30f7dba4fb103f3d0e1e2819a34e69c4f98d5117cc87ad9bed802af141f45d3366b7de87c46f94db7de5a752a30deeb303b46d431f6eb01fb18ff1833c42aeeba5f56ead16fbb8319f5965285d649b7a1a3248949c9087003c179019552e810e905af279b0c6521d9cbfcdf364cfda17307fb3fd1e6525cc6a394c7917e911081fe95e2b14765332ff3c52f733a580fab659a4d7cf8176713b2e57b0ac641ce9464c1a6a1114b7b5bb110078bebef30734124ef50af2597d6b9cd321f9e8e3db3b26a550f85f5ed61ca213e68d794875840c464a2d56e36e27883b601077a2216f4126e7e3d0fe88d723c23fd1975789c6ea5ad23b50300b8a4b0928a8eb6b10d36096954e86b8a40964774cbd1317ea62e4a9f14d9eff77ec847edc6b8bf1efd1260a1500a63c00cdbbccce2ba6a0536a866d7400a113ec0ac62005cd578b61796823cfb1ee5bf00b13c244196322aa77ac4905369e4fc8aeadb6a9ab4259b6455f3275a32f9f59f31d438d8a0cb5fd1f13c1558d9c74df84e5d01b0fdee01b5f0b29f269e6a5d7fdaaaadf2436c23707079b9189db94eae757a2019ab55d43372db0fc1f4fb1ad48a37ad46be325f20f647e16e5cf720807928723997d67d39097432cd02997e0abdf18ac23c35ea895a0e582239e5a7018d8d3a2a30ced2ddc90f586a0b9c09ae066c8f341c57244f7cd27943c7c67badc4718ef79084a311d2b60bc98571cd12d6c3502ed6bceb872ce029a9de216c1138fbd5766bcf8c1a1ddbb5982f773c27397fc8d6234fc3fe187e54a69eb0544d25954734a37afb86233597a511e736a0e93888be2987e3578f5346be99206a8ad2ed79246cfc46d010c24d85e65c914ec0879edce25d2f9953378c1027ba15acb82c40b43328d584c9b1e39f8c57b539973b2e7f6a46c3eb2ed8dd7918755b983c3bf863dde6dc4c84fda0d65ab52a9312d83b4c529df76daf08e0c909d50205cb4601bdd63ce5fd6a72525d2056096816a0cb6431c36cdc743883ec541f8cf506f28d790dec9d0e0497f21fd927329592099285812fb66a2163b6514703ddab69bfb4b135d9118b6c7c5e270f05cae4144b1f0dd6cda78b72d95a0eb3a1e5ed59a54f3a568697c57e722554bff8d9edd6b796115d1b9417e815113e6db24c09fd4d490e88eec037922aa77450f05e739ad6a102ebabe490fbc62dcceb571dd9a147a78f6765ab40864efa5e74c53e2b1cefbd15fbb8658eb93734546ad342ed99df7105b101e02673dd80f0a43e97fc2bb89c3726739b377906700668d72f8be530ccfb8793eaaa0c83109ea32e97a78ff229281a07add541bef8d7be0ef9d1c2808b0522e6334b003f2d37f1c4a613697e1be952e4f4fdf9983b58a0ee5613d8cec804cd554f9879fce5bf20deb8d79683e98ac5d18bd0dacdd5eb3e33f9f0f68baafbe6c916a28c56475644d3dfaf3ffca3eb60d7871997760be067b23fcad0908a6d1f9a1e349b6c7bbd0b80af5d1e30bacd0219d0e63482e9c1db90c32e7d48b780848508e5544c206d564678305df7958bb8ecaa7388b181ffd524b649b0d0b8b8993f56ae291262121865eb9b745bde7020a6f3d809858140325c4f38bf329152e819a885457b518dab20a533e0a68450e9b83fa457c223110eddebeef3e6912e656a0dd87e4150e1b0a77b2af776bc6cf2be2f22134f2a6b80260e85a8bef730337d6b10b24afe56b921d3fe26be0223cf87a4934d4ee3c2e89fcea0b73c9e8baa97ef566787cffa498f4591ee725e1ec50ac587ddd8ce1ff839d09a38318bdfd639865f734ec6a52c863491a911b9690b5554ea9900e5694a2b2f1afd66717db10b62d375144f3b1b6606f207a23643b787da01f4ce576b6b0683b59a57dccb5baa71c04ed281d4de8f601f0d392168ecc2a59404035f510cf654caf5701a39b142509223507df4235d6e85c8d6bee0d2325dfc334c5b1512a00e64fd9f859eb8e644c1779f4888522423a7dd3c070ec6e745e94a09fe8e826b7ecc3588a0a073b99c431a38612ba02056ea837ff177f18d39b6a9a95bb06af60bcf733f4933838cc59da9267c1daa23b02f8364a8c761fb36cdd98d809a3ca595cee3102da6a55bc11c8097a2591dba9a54eb59bbfe9f1b60145842f878215a95cd9a8d1efeb3775fa6f71f853f68cf0e577cb0638ccb426a187b9d3b2083e3b6ccd148b6f0b7a95879b33f697a7a99fb9901ba9d2b0f4c1cf82322cc42f1f9a2602d9904d41920a0b8add98af23046d58f81013d6c7cd79de4ebbb059e689dac1081ecd53482e9069ebc9adcf32fbecf63b660de85a27c572fac9f0ff74349e008f40f15189b84476966ef41f5a7e1cfc532e9763af0e8d172a744a5424c6500483f88891665e790741042cc69566e37721255263aa5323b623a32adce2331e0061b257e9d402d7d07ae2430cb181b09a023772a6cd42be996e9ee77e4085bb4daab818fe35fee080a264b3d1197d591988a4890a8a38ded39445464b774d145b945d5d610de4a1594dcc6a5f9d236c512f52798d6ccbec0878c2f79726b958e45636f7073023008c6d953762e256ee1f14a6cdae30b36fdac211aa6b58790d317c0ecbde9993996d4276a8af447d78a83f4872ed61b8f9fca3f664be0a4089e9b1cb69578219141312ced209f71ccb1c6093dee7113b895df0efb542030fffd5e234b634be5277859101eed4fe7d6ab25032f4817e07b575d9f76abdb78c9d63f685cd61964006a05c2d19991d7bcf49c88cfe20adb7aa3cda9037bd801f7ad64355f093bbf756252e3af0a88909df5b3365f86a9f426aea13d7cc5b943269fb1801128ed3cde85d65c3c7f9c67efe85bcb3c0c591b93ea42a7b9b55d528f1a822fea251e7942de762aa8fddd72c6f71f3d23af608160f43f8ef68fab317de65a36a63c7ff422da0ec08e2167f542d72c5564a2e276c791a1da8fb9fbf7bd10bed38f1693bf2816adff44b2b5c10db9c3bcf620edfd220e90d346c2081f2b9b7359f7ac1958fae01a24560bc60c665ca7aced5fb2b9788e4fba84cef4ee79f7ed4a261fa7883af393af5f7a7bc793b7892c5d2d692f127ab75855b1d7e7f398be65a6dbeafd188d882464f8e651ffab0c186147f2473bca0a82494a62d90a7a25f62dc6590675611ff70d9165ddbfb6be7b78678c95435635d18ebc4d2a92e25bb002385473d4d0ee1770e0212195c6f3a2d58d7e626f76e8afe15ad8893fbc483f19aedc27af4b81b248c36ac4372476a813ac451cfecd48398183db9d511002f548c24adf120e22caecc946e1fef8b058cef65f2b5cb42a4a0c44ed7a59c1d0cdd044f13bdacece82be8b39628e5811ec81524e8edf1f74dca5558fb69dc804e389e0c46b89ddb849c758d2e03963786c48457437b3d3ceab2fc350cbd0faf6a53782074e4d2a3af826b65b0d271c7cfe86d305b70b7f78350962ea59a675293b21c4c57cf660e6d08f4517d01922f185771e393e03c82a45bac336a47f16b55bb39ef32d3dd505a998c56f25801c14d7436033b6f64638b973c5aa99f51eba11488352bbfc6d7c2a699801668b018ae185d9c7cbef32a6b06fafd295ed9684815f6e3cda110965d1fa38aeb99eb56f5dace751262fbbd2996d648d123d917b4bcaee6df840c4d46144dc3630428c31b3180d4a0d25fdc5b7348fef4eed93cff663cbb5c5979b2025a4ec07e06309b7b87e45ab41cafe0430fe69f707f840e73996e32c657d97f517d4f9efb7bbedbe44b0a0b2d1922cef13d8e0cf54f9b045beded5160974d53e408f110fb5c25bf3f1580284ffcdb3ea7c18d94b1ccf1a764670cafbcdf4dcdba7e3494d5597d125b7e82e3ba1377721898775eafbdc28ee76bca0793d905baf29b17982e3884c5965d983394fc63c7bc981b220c304d5598801aefdce738dab4da54714b41958f935670c4359f9d2c0349adeef0ca54d64b913e8a74cd70928edabfb8e8461bcb111d2b39d5715194c2ce46014d492fad8947a33c38bd5cfea0f47f74674eccf887f0be482658b43654672570880bb18fcc8e021bd8ab2c7fc2a0e3b515b4aaa3d05dc6971a500626b7cf93f422737a2643f2e2f08d6b7db3df9fa11cea770fb68d8ffa6d5e5531965a768e17f7506221c1026b1f006597b855be9565c5c9a5a640df876240a526b4003fa007a1da3bd50d3d5c1185f1bcf03a1f5d90060e0cb209d37b2e7fb91cd6749ac5e88f460d8cd8e54e6559e23a96eb93928241c5d5e54bbce45f7e0cef1d3c8039dfc37401d1dca16c8019a9d71fab98411568324589f1929dc1b41b3fb9473f823687c70b7bdc9896f539e121b8da4a74e85e48bc11b44fcb641c208ade3e4abdc953e1f30f69bc33b958a4d7a2529c7795f77e12ad29f62ec0abcf5bd02a509e45340b12294f3947a1d1b636701ad35766034eb4e200e5a998905e60496e4ffed40ac27010eb0d2dc3a22cbbe11a947735b0ba8b77a072e8e90a782738d9fa9ce35513b028b7244ae5d59ed2c29cc1f552892bc20392a94cf953a0cb69401b4672a3bbfea5fd2678a48d49074fb30cfa03fcca420be22b2a0f51e60fa899948cc80a10e87e77d712d1c23717eaa2fb94cf170e53c0e0a236f33d1ce1ad2e7b2244ea9a003c1b1eed1356de8efcae05218ac14a1d25e5d7cdf7e0bdd12978c5f581839be6ce329031c71b58114138e36109ba5973f0cac6b5b61c0ba47f8603c52bf30394a28e701f6adfe1a883aae61302f0eb5e4a713de801bdfb0627e1ffe9b856f1dea15b6a9d8ad62a41c9a544597e49bef62ce37d4a4806e664039a61f2fd14789584cf2ba967a800544f9faf0da763df6f2b671ad2702f860836d85ad8c960761d4ca8130de7a9106d416f2294da68fad6b9c632f4e5bf01e6a42a5f0cf60b5d405ce389796cdfb2f3f229fce2812dcf1f214fd07e0324ff1775a3016d38bddbfa9f02965066e83191b62a420c9311002ec13313d5db264450d7f1afc2e87c8e21047d7d310cf1c189d246baa82c092b7f618325f0cab8addfe5f2c349926ab89cf09ce22f37a38b6a62c426ffe37f0adad292cac2a3e25d9a1ac7b02438ec906453f3e43dd06b11317d63983df948de80970d1dea90eedecbfcec696cf23f089000b50d16ce1cb962085fb6234abe90722f4893fe1168b0770d9eb18e6e00f6a041835498417c8e781351b565a8c6deac66498eb225c1ce3a8312d068f57cf92cc92229f3b7b52ed8e17e703c2caf228325299dd3abc26a4ec2bfccb49e6cfcd45b4b619cced9725ba3816ccc6b7597eb187e6bee95995bb40b13254819d26c988ddae20b2e91f7f1ea6bfb975b803fedbf6a15e3355322ad4b70e9b0a38ff4e95080fa96b52b87e4b7e49e67d01d4f24d3767623cd2f412195a8460080f49e4c4f317e7b38bfa928a40a50d174ac713b0699ebaab833f41cf10c41292978e8fd455e1a0a12ea9e6a2fad75b972cf29753a7cffa9c3d58bda351b97cc2ba6d308108231e3777f269b33ed7da7d9f6c2c93115232289adcff6ca6b78ab8cb8a5a44dcd2a0a1da0cb7e41d3d6c908389fdc9ea66a65f39acfcdb8b2465ebd0714a37cbdc47712becf3c118ed8d56fd6c57207a1c46f209a03de5424f6e7c0248bf4dbdb206d99ab8e965cb1e12bde0c4949d006928946c759d2b20a8325019bb43840f894f4fda765eca6de73cad81bd1896115e900c2fb1c75564988c7699335f5f0df57dbc57f0175cf549455cf94672b5115cec252749d535ce11e998cea4b488ce0d86f1cf60cb0b492e6a62a1be99b84e14092d7258482a26e5f5e61e889762eb5a258502009e6a19f88b7c56c89d9e9515b0d81ab6f163bbf700059bd07cb5aea56ec2c0857d7b403131f7a13e372f881b74ed18c7c36cec874796513d03b71a30c8b3dbf0037b0b8e6060f373cc565ecc7a61348fcb14a6d94a87c7bc7735440f0f0b64bacdeb377c02df885a795075eb6ae20921e0ac2be08c71e85b2162d0c6f41298fef808980bbdc0259575969d95e2c27c19cd2503d3cc8428f425a6a831c5d40803f8d2632bb22e3d3ff76f556b260c0130021a886197af4641444e697e513689348110eb71b137633b0fcfe31eb2afe8ca91703957633111e4715590b30569462272dda2a5ca837d2eae2a8a5a1fb73ac68abf26666d2f11e17fece1476092d738dede343bcef0a43f5c2b3d195327729be347c52f48e768019b9bcf43ce14d9f6e0ed77950b2f788a3f73a1af93b512c4676533f6ef2de564a9b6d5ae26fca689d76dc5b294cadbca6d182aa935ab4d50acc5a436d8ac84271cd66288f478517b5b56507adb3c247eee0253060bbf665634d0558993531e22ab68b7f384b2c1763e583e18419bc174592c1c79126be10d61a140024019e8625c19fd0f82d2921b350350e3febc6ec6709d10929dd46c2d0d10521bed1ce46942cd06c3525c9ebb4b52758bdd550acc18305879a98a90bbdc965876ce12c412a0f6490b447ee0383aad17f0939037c57ffc1916bfa0b7245999fbd6fcea47697f873d8433ba72c32637c18e47815aed0149950512128b7cf5db4a9d61a04c56df6b5101473430fd134","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
