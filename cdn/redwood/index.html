<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"888ab2a42aeb798910e6766c2e6ee3b22b7a00b90e6e04266c86f0da0dceda999e41f73ebbec2761871b45b18cf6cb8e75e89095eb6204a5e042a120445838c759d745cd79fdafd722cd3f35d9f9f8b683201b1c84285dc85eba80a4d1cd8519d406288925185d7d81027a4ec56da69b76bec215c224eb3183e77fd16994ebdbc4c2fc5e5f9eb575e3ce3a12836cfffc4e961dfcd8b907303c053a4da473d642e60684c7d7b1dcfcf6c37782e57c19b0bcccbfabef2628f06f4f2a14356230db898d781e19f16ecaca4f0a8cfa8f8d8fcd9cc7aa1359beb582db2f8a362ca8b84fecf391c8ab1b1d4c8a63c2e537821ff6818a86f9d3426984ed6b1b8493d69157cef4a2ae00bcc9e39ec9322dee503e0f3a1f31e01fd2f9d0396a1660d8a6b060f2d4a1d25b62b05c6062af934dd57facd5a55745505b837c46557c69c0171ba7e192e458f24d076aca95467907d40cd8c2295787a53f8f6da829b6322b23c8adf4a3ba82fec5f435484d8b4840f1286e5d4bdc300664d53d9340ec83dc5b797a902840dba2538f41aa1df2affbc3fd21b53beb152d8d51342d2cc365cb25f12587de4b1e2fac983cf90b2acfe4f068d26df4c327c77b6ba3c0dcb4a1cc068732e0ac5ee488bd659675e6ce9961ecace73033c6b5160f4a10f40e67c34107621f2b196da25232d2d68a37bd720cd4ff6c3dc473140118c7134aff51a89f2f3f128d0d0038190ffdb5dc7b1bcd6d730b0c8fa04c7bc2944131e75f379bae6ab4b016adc4a46c21cd4cbe2624a5ebc213f411e3678467c37a9c4c892f22caec6a226e374f6cb049a96d588c74b14c5047efc0bba8b787830e2f020a9fb976398423331d6f5b11a73dfce780cc5b5acc9211bdb07691f03e75bd342ae18155ce04d34e5858a48fced8595af41ca93bc3f9028ccf05a8ae6aab84accfc79fb83c994be0448c9579b3b2a8f98544696457412eb1f3dfdf794e362785a2f25a700435b29bc08985d59d10d59dc93969df6914778dae9318d50b3b8f353bea0892ab41f0ba7769f158083fda65c24cdd8bb491926f2c19ca812dbfa20e09551e250aa1cfc3457f5ce7f52c77ee65c60e7c5cd6c8cda160eb71fe954a533e56de2da586da53ebb70528d53615e5c8a9e96f80c1d6c5992b1c33c7af7e2df2d791e5042622d1fbac7d4f7847957204996f28e4a3db3c0b513173e4cadccb2c0ea92d3617a9e2e7c8d9b438d4e9072dc5bc16d45ff811864cde4d60dc80fbf2ac430567c6e0111806a3b0d362575ceb62740ded82252eed5a8cee6c398a18dbddd974568f67941a3e95f51953a86b5084d9f2137e39756705092d8626d076b1231bce35dd782e573b6f1ddd14a4b825ae11729ffa0718d61a2a5b3efa7509853a040babb8680dc0216128fa8487b2c3b765c942066f8b8bdd346f64e61ce19ee933b4e5b0a7f6d01f00fcca6a166e5933267ad51658fbef51ba8463cf865de2e40e386e199236d28fd9d2ad746181a42aa69709590c9d1bbaff36fcc588a69e9f58fe9f07b177f0831010db5914daf7b61b5f4db12a6a9eca5056a3ae5a413511878c26265cd79548585a2ba1232b92b1735b53bed654a6303c81ce6e37e9844bf7dea851232a0e350b927c4c0780e5b753506273c199614fd70ae6f9b47d0785e72c05a3e1506027c7d0317655023dfab06316a03321bdfbf7d99ee9164171c691df090338c9ce95dab10074aa4ff4529a5cb77dcb0fd74e554f62d055e601e58c86457881916eaf3f92355e02245acde84b275a7b020242ffda87e7642ed41dfef64295fbb26dc933f8fda9cc6e74eeb78a176c98deb8720c94e78fbd32de0a5da4a4909c3da12750f9401039dc746b1b2c181d16e9b0815dd64c52593a1236e24bc9c633640eda82a09c0941a5bfa057561db64e03383d6ea4046759eda195641ac9955340a2bd97e399df3a696d0f8b9f95a6855858cc147a82b28fb6d7bc166354ea3036020b4b2f1eae05358654c099aae44733bdf009dbbda1e41adfc8f55158be950943349dd67b7d49f206131662d34b7bbc994e846e311042de9f2532d2cf9abf2766e086f43be6ada0b7d919a5ca00d745ed998df9c635f42bf9980b0de1205efeed14d0caca55a450da89908654c115b66575faae95e319c680334aa05ebebb188d2935fcb58f1433d3da7b63967cde7a02e126fa78cab091934e5a7080328552aba2a7bfcd9c64678b517d1803ffa6ebca95c03a16b1cc644f3c1a3f82d6c4fb4b0f70bdb4e84892f23efbd12db674787aa791a81a9cc725e8c400fee5068f36036c8e98ad0d6ef6da6bab8f5d3065a450a4f039e5c6c99b54c7adb4bb152704f4521d35fe9e38f754c6035ab82b08561fee6a3abf9bf83b266555498ab649d16ca0f2ceb65583d32b525634b412bb5ace740f4c7ec228055826f8206da8103aa0d43282c889599aa7f82e03d1479c41ed8090e01117441be08b393e88da5f22056d5810c4e6adbef4fb59610930fdf98b374dc262913eb6e853d3133ec855b48f1ab63675e1c5c76cc03c0f8152334543cbbf8d8f9dc5d2d058f1ab6241ea04b9220e45a7803df87d63cb4c3ef89bde3dfba9a1908984281235ef7c35800cacfc7a12abf068a32c06bc4291fa9d16d9b4096d7fcf5d5fb9db29dad7d58f7b5051ec22509c5eed5aab81842d8821490e64451fdacbc78a33b9ec59217220ae002dc22f0d5dc70b44c7daef5366dda1846e07a0942da5180b5cd1691f3e8d6973c827baf96867b23f8c3381044688e39c4e4073c00f55a1b0ffb11d3854d0b9bfc6f26e91a64bb6233183e708092c899fa9e6a4f760e3aba7193df07aa2ddbb14768c8dab2a3703b9b5e3e40be07d675567c6ad41de50f31910bd3ee39a54aaad35bb4bd73e61253d0f58d7b1bd04a2ac6e3159e268bf285be4877b0bc134ae8a33bf480b872a48ec308139403788cc22f5d4ce4a7c2bfe429b3cfbf8a3a7ad150da3f3c22c418b88da27fc9848f7dd32b7530b2f2a0d82d2a7cc36611dbd3cb78fc7dda25697edef6f748d24af0fbc4499f1705dccc5230fca11d76c47f4ebb22aaa8315a997b3b2a25eec18864418319eb8446b60fbb9043780ffa49467c814a613c68990000459f6229fd23e7d60ed233e80918a2c90203790d871df0e4dec0b1e9145cd7a5906ebd0bdcaaea7293280a68f7c9851d195c33d40b4db5a1eca404e94d706fc2dcb0826359bc1b4929d7bdddf62bb3af96bf5be5809a92ce120a7d75fd4f3c52024474248c395245b8234d7b67946114c86264cca8657fb053429557499bbcdb4072914f8eb8b220d4bb1f69f47b974b6cc01451f5ce24897e82252c29da1719e290bd6aae8ee47d622ab682b48452be1cfd8cce374c01ce3e0823294070b1e3e537e4e300e0a10667e3de271f5433c9f5626f68665143d95a6aee4a161237b93a41864b4b5e291844e8e5da6b51d419d0d3b1d31f99f4999ddd8ace61e768876159f0208bcb2dfc5657dda44b8a34613c840adc141e82240440b55d5551f7725133848e4a4f1fd5b054d4675547d935f4f1abc986029e6875ecb8c046ac4e177c44c6c9dff2892df816784217c1ab29855a70e9112e181d6dfed4d0977f1b270659ff06e42b9158e9edd18c719e79a24268307f078689fab67e1d2244bd4b6077d85d7439beadb3cabcc917806d07fc372bbfb313a5efb1f32301a9ed08b23819b4a354417f231c93be70714bc0b23fb690db0339cf647aff6a02aa62876406a4a2a3a4552b21f082b11aeffb28bc3e533f3960c89e356c13ab84e1239b4cc32cc0714be907ba67c52b58991710738eea14f2c63552b0095260a679d3606ec48868629853fe53cfe2d25a5480a5ad9a3afaee9cb29819626428bb7d19ca5c7dcdcf0314fc7e25d008ac5cb60ed93e51acd1c216de99725b63d3cd30cf0806b6808e52fac75941d87bdd7065b3dcea055e234b27593da37207d98e395a265b7d59afba56f27c38613986074462898436253bdc1438c6e93101f14dba3e5a2191b334793863590b84253b1811dadfb4afe6af67f646fa980909a8a6fe14498ac207ce9d52e017cde4a698c56432d4353488df18b8097d0806745df41e3074f1d0fd57acd4324e64ac329202c50b4598f0825f561c7885bfbb72f272e17e787f960eddb7c1dac4afe2653cdb8911ea258a55aeeb64e93a719300d1dcbcaf5c0b4e2e2e9f681b8e86350e219b72574523d7f9cf5bb5b4b3918d2035c9d2f605171751c649c320fe319202ef7a6ed41f0d59a15053012f863afb2d6175285a78d24f3f2dc5248cd788a118b61915b3022a0b3bae93ff423b127a6c9ac6de9b9b98a0d3d0112809f227c9259ea86277f863b370e7dbe92fe36535147223bfb3343169a67edbe44c91e25975882f2a542433f6b2c1b1ad3345be1ed5d7e0d594bcbf508eab158ec6ce51acf7e54ab6cf1ccc99eb000564c2ac4827b62bbac7f4733916a3359219ce023eac35b6f5ea4a32957357e9584ad3803b1c87eff282e70ff1b79b8975d1c3bae2c9513f7a34f586ce090028cb5d0244bde818370c1d171c0b8afc78e0616bbbc780fdf787741914336a5390f7e3993a2127d30db7f4a1bb2b5b229417b12967ea51b31b5c2527f019eb6e57ba82a3b37b718bb7ecf6da26850f73e5deb40bc0a141157b14353e64598490998e3f6b044a95022411a4b1035865df6a0bdd8a4bde79108a16683f40da4252ca7d5b1b872e52bce4bb40f43ac34a40ff9564335c90b72988d97d5226fc6fbc4a69d424bcc3bbe0eafdba7347a21821898a61e0e1b486af3284e710b491a1ca644a720b1879718bcb8bf5200715b49a272e8459544ccab8243b3ead5eb5f45e0420c1642aca54e294f554845bd17136f449e2a9a3e7d1a87bed3e81e39a1e8b97623df111ea45e6a6a226e69c3f687138794d12906739691cab1eab603f393aecfc791912bbe39e8bf105ea742d5a50c531bfe814326bf0bae5ed3693c432c1129568c6bf7e2b00b40c9903bcb061b1624b9913a0c319012d25558ef26e4e8c43e1d0cf25e20f68539331eff62aff2b2bc0e3eea8fe21e49ea542432fa88dfd1faf183c42844cab77b2d92e0c2486ecfe23d3c963e856bf3519935680e40ddd0c5c76db6c22a8853986b12ab8050bd21641a54ee8e6f8b478eae4ad8fb6c24bd4294b9d9e51560cd87f8a5a592cbad2f3fd2ef9a77fffff4290b7a79abee344ddc21cea243e60844dbe964396d5907aef1dfe1d62a673d39662d3f766d19fdd7e35a00467332d93c41da07b8e8baf75d794e924eacd2b28120f6711d1d024ded37035de4af0aee35e047e6477559025f521dfc45bd8b85cfc436f968b299dd3dc25cb3777ca09255ed659a7b9d88a0c5824875a76c2ffa06da03f5f29b1caca539f7f8142e9552e5c2785390e9b24460f5d77b8f7d5b8e361271a51934ff98811667b3e02e475e2354d67c9901e73b789b3b065aee5c85c239f0b1e3db1de8772f811576ef7c25b6e6313691d748e2d782b1525c45e9855219f048792fb196f5ae2008368a85fd943a643a499ec52fe22cdd4208f78a5ec12b90fd987a0e6682a224e2d3265cfb94786e55c9cbb023b98d409025aebdf2438c6e48bce8d73666319e813ba232f2ddb34ed5765d5d6b6ed4402f6ba1716687f9c619af992d88c79f7271835eda0a601f977a508eec12bb00aad19ffedebe1915e744585292e6f9bc64baa5f1bb0f0f50999f922c06a4b6e91f5f0c23289a536347e380eb21c60830885572c5dd2e31d77c1de97f31529ec61a86ed57a5ef0dffcfb18b2c2afc76cd8096986d8759e2469e34ca8197428b07bd9116d3f968a520038a145ed9fdcdc189894871522329ba4879eb1cf1e09814b1336a7694c9dd8af7140ee5dbed579e9dd6cac6a87232daafab84ed6a3521ec5784d2110543b0b5732055b43c5e6536294928cfa0613e0b3333f0523ce249d4fd6c4a3f4be10b0537a5f148fc0b0cc15c34cc4d393d041033955002bc567f89197aa01b950c8b524d4e18a93648d320caca6de845530c1ef08e36a5eb5018a25f5c16ce53b56dcc8709101a8f82ef2a2c2175d2619c854f8dee5e749713a8ce571f3173fac87ef8acff63327cf7d2ad1184fd9de62be0ab40fafbb3c8df22948ebcee3e474453eb4a0347a729458b474b0d9d0bfc8bf5e6864d25cd988c2406b8424df43f77f21ac78e7d1bc235bb202889e2d6a50bd46272df599f8e3ab8630e169a29ea4dbc72a606342dbc34b20a3c97ba65eb703355fb3c01e0575ab307ff0524a5e912343b1559e75ad39d467cbf5792f3cf9bf95c91ca21cc96410946c0eef9eb11e3ef03ac855f9c8bc37eb1a0d3354817ebcc8430d57bb0fd40d02f52d36e8ce52f89cb3547ec6fb83a78b4eb1e4aad9d33a81a893cc03e5e90f2798cac571071af609249f8f6ae7e4d1a6c5715acada2313327de5ce7b8fb77b58e9a83cb1ab7f2b86bd559eb8057f4033a5fd961d8bf1c4bb59de7724ede6a359860586827d4a30ffd29b52be3859b46531991d2f0ab7e6fc98b3841f0b6be3c9edbe9d262ef10ddce60c3e78c857dbc831632eaee6d5ff9b52fc4d25f193f61a237d2d944a899e445084a20b74a38391042b64f428dad3722399686f1839b5bd1bee7bef34a35d4ac1ee9a88a86aa896f70dac4b66bced87bda6471f34a0ecf94b57de64f7015a86b032f2603a3efd04f3dcd8dc97b5b70dd576841174590fb2a1ef4d0a7fe2f29d3ad4444eb714b316ae76db4694f9849022ac64f83e200247fddf128902864ed88a09634bd021cbb9dc6f727bfd136de53e6d8e215b44756f100c96986b02d6d7f3fdf4753ceef2c82f95da0ce0f45053d860731c58cfd71a2dad707f0876e0838e63dfb1c44c69c0e8fca4227b74750da9f5baf1ec180a0a17f9b52b9711284a2698659e0045525bc25fee8d333b7a2f0d4615ae87e6d600c92b3bbf1db167d009e3dfead328edd383dbf25b7a258eae079d101c6e25d01184c23c6c173ab9b2a9fb570fe3c5a4e490dd5f8ae1f6e7bba7caa0bd0c4e59c485e504e744980d1b1ff2f209432c815e7ab4a8db45ba329db867c6b766d375067347b0649442988a3f6d80417874cf5eedf93dac49be5baad1a1450ed51c73efc07386af2b276272f53d3e4143da006956a3d5b13254a552b480b36983d59b5bebe716fd125b06f4026bb9df715f772982d31c78c60dfd5967311de33dc8b3f0a644d9f39c78b7bcff3934039b1994d4c2ffba93a3dc27e1cc9f2adce3bf57128697d10d1b04a0c843293f861dd857c3d7173100b1ebdb9c6beab6d34f2a0eb99255e96720e202b2f5ee18292930adab3759bded628e7f030425bd2e4a0d54044e05fe999633399860f8173678d52ad312961012259290b77fe2e87daa0817429eafcf8e0dffbdfbdaa03eed299c5c02db68b4bd903cf4563d91ba277c34034c0000154a090de2077cfd709ebe1c0ae7efd4b2840bb0b87cee591da0c445017624ed309d0d066ce4a3156a941decbfcbc53632212e74b6c907eda2d3f7cd9cdd96733854232429944f24f4cfaab64b975a88e4c6816aa7685a454fda66983f0174b2324e3cde0a687451362731ce356a25f480b3a1975a56dd104a3d540cbd928f21ef377c8476714757ec1c3b60e0b862a041c56869341216768c15685aaf8c10dd7553748765bf4eb695138f940ab29fa8a9a9f1ee046d266a2048782a6d85b84f5614e3c7cdc64dced09d7d34c29f91c9b2253dd09659851249d8b4b7d885688339139d72c2606e82f90da4abdc288d7b7504d0195059b9cb54ee2114be6362bc7224be4bb7fe8af0037a744d42abc909313c8abb444f5c5e93b312cdd51a52f563464c87fd4b7cdf84cb6d189c646b1b13c3854e433b033cf5ca9d143a72ffaeefc1ae356c7644468c1ee467302cdc0b888d73012469cbaa12b68e12a77d8d88f7119c7d278865997a982efa706e0275e8fafdcaae760de25e1b92f9917817af74eb2a37f7908c8efadbe749ea1cd15eecd2df0a962806277ab2bf20a72e4afab2376469f55aa4927d6edd8f9855c27757902bcd6ab286b3cfd3f3fe8b767493af05033a1e9ea7aac02f15521b71ca97bfe41fcaead5a74af45d3f2b06a56960bfafae0e46775c83b03764f9f7102e6a01400e32e4da33eede4692e36f64b58e6e5c2ab5061fb163d8603637406594a9e4f7166e4eff1e012806a39d8bca57d18d313a021f1af6f34611a68c86b903202da6c94866467423c460cef6fd39165b5fd485d1f910e94b52fe81141f93a1fe55ae1a9a3547819b3f7b263158597f5197b449bf3e7ae9533d2cd0c58f8bc3fdeb8ca0c622fea133f3823d8508ee6cbc43d2615f8a013aadd20f6989570e588eef04271faad70f89b34504fee5bc02896104daefee4bdd73b17e21e104f93fca327f3674049e31384c25322df5a05405e51800e2c671b678d14de011fc438296232d7d8e49bfa9c97ddead9166cbe09c3ab81c96648fd344548bc6ac053bb1ace5552fe348e3887c5ed85d5d9b6f0511115f481494763d855ac91e41a887aabcc08a11978e33233a27c0f9daa8f29d4ea8a6203f0e1c3547cd6d3885e377c35ce5ad24b91a89753abc5190389c334942109d0d6df6f879e2a32d2bbbeb4ce3fa3e363b0fcdc29fa968e25ae5a122e6d2fad1843b2fa0bd616aba13565479080496e90df5861715a0f5e1fa45ba55710d11e2bcee40d79890bf765298ce6b912722f3052479dbb2d7fff765b386268a5a104ac48db693fd80999c2aadab53c1ceeb1279579e15e7042edb7ac08dbc486abb633576cfd0dec1fecbe762081625cf17e2d1b8ac8e92679d42dbafdf9c92f7c9b0cca12a6b5098f5969240f1d445b95a093de7844e99b77b5347a097ccdcc62826ece3b4c5c82caba6dd872a8535fae0e8cac47582f5e27876a8dd1f1d816b87a128137e1f256ebb4c6d16f841662d9c1615215303ad5794fa76a5a41e7bb544bf89423c9cf82a0c6fd39008154e45bbcb79ff3928e61c3d7f52018b8a00de43a769adfa016c3d8ccb0cc83cf9e63ed910c215c496e36bcd50746bc0b0531b168a5323117f90afff61493fd42f60e91c2ab2c03116fc9c409baf1fcf4c91df0c197b68284597f7b2bafb1140529b4bcc1d396a838b28133f271b1be80744649daf2848ac8eb7b682efddd54a285fd67f03b0bcb96844d36333ca002c24e98a7c893c212ee0ecdb7bcb047d026f094a9645cce4594a103d89560c2352543fce9061d84022d4dc2a8fe35dba3e61ec5136b29bd4b3917d6466ea71cb75b7a1aed32083dd3aa0793f3a4fa28cd06296131d0e4bb5901ab869a8a6512f25e2f01e9fdcbe383f32fc3909216deff8994c80ef5ab433fa7af5c978fdd60a506edcc37fce248b8a0b7794ff1a483f583e2e76764b5a426c25879c8e5f54a1bcb9f4d53b3a483c1e48b3770da22c7e0421ea17107cdb5afe0aa8b2bf611be932ed07194a4ce89a857cd9300f07acb1cf90b32ac4d8933f0fd1ae76f69138d801c39f45285a9290461495c9080a1a6b4137c0dfca46c7803d64ebaed34a2115a6a974b32e4fc8860095ba7753964d8eb5d9ed21fed5da58ffd19c379e6d49833157a2924b1c88e4350a54f73ef462ac08da23de9efb1b16bb387743d03447faf58adb3b79b59b17e800114840f6b6723c21e801072892bb44b6b6d8a1100138e88eb8f72efdf4731a527dbfae727df41332dd9495be33cb068de52c50518f235032599b3b656bde8420757bc5eb9c3c4cf97373c403845559f2d2501930db7e34ec8252c6f88e0f54f1ac3adc2660c9dc9d4f3e476d1dd6c6b1babf7cbad1a76c091f995c9bf1f802aaee2e754c0f931545be9a4a53f80bae1893444bd19f0f910eeada22f7ffe12aaee51837e4a30849dbfbaf20bde1097a0af0533989b76b330897db33edb514266e07361264baa158e9b110fc5145c0d6916145110c378cf7ff7345967b126ed2f3e64101fa4183ebb0dcebe08d54e3da390dee15a93d768974d8d0d5d2761314767f9907db77f3f8860a05f9aecfc9feed8dee0c50f7462dfd273fcba60716b6db325d118c37202221bbe756bb57e3e7fc400a75f37355e2ca3443061763eb05dd806294475ac77584c768772a505e823c87f7ba4dbd7387ee386235ca3bc0c2aa4118b15d971075442f1eb369669ea79f1f4d1285cce7f364992a26607867d8bbd80ef099453d636222ac94028ef0f6b2f13e0cccf08b9aacde6189fb327a454c893f861f109be67d08f88c8f66fcf84916a0fe6200f7377df9df3f7eda1290714c1a6ce386780fb79e45c9dd5fdabe6e62055276ee33077b9e40cc2f6aacfac76ca72f3a8d2dda248d9e79d0dbb9379e9dc5096390998fb5e88ae85f5c77d6ee2df2d3d9a9d4ab74bfc33db110f7067d5eab76ea7e8acba7cd27323bc57b6296156ac489f391a2c2106f54180591d1b64585639e541aa839e663e7da18a62c093fba472a747b3d62f806d95405fe23294f47c36593dca850011d53402aa15419310d547d31e0dc4484d08bc1b1d156a0298ee649c5fa7e4875d88c3a8839ed3358f35826fb31ef4e648c5dbd48ab282d3c685a12c7cf3b14ad8f9d4bc95c36371e231f38afc081e47d44d1897c04d741a0894c80b0fa5ae8fa370470f3eba15b7d30f6732d3f98dfa73add2d88f4e03fb08da1581a087fb8ba8892700ee873a853d955f70f313b81334edde6c79ee15b1c34253c48c0a49f741a9079db29f7d7ef995d9e498cafbd6f6ead543e321c9b5dc4e1902bb83bb67d18ceecc2fa985f1ee49bc0a1ee3ef6220a19342c8a8e4df80778e535fbb88b288f17c48c09502b6960efd877d2e64e9acd38b064071470c87985aa9cb149e831aa1de5cf6b9be8c63a3a087e9aa80af87352f5101b18b569a2e67c76134c27c73f1574169e87d1f8c8fa98c8437603049feaf087246b6feec03a3f4a3695e5dc11c79c4b0296f908388db3994f1f762fe5fa0ae32c21a291fda27f75a42659c2714afb44d64fa5cee4cc69946ec55c397c10c215279e1dd1b504f0bf9fbbe34be48b8376664614d53dd3a71eb0b1c00c063797f235ae59ada1294e1aca3404f6c76e6a11f69e2ef06089be3c4f420ff92e0e8f6e4de9105ea7de466f47c1aebe267165b3262264a77f0d52b7b167d7527664d8203a909c21ebaa1e4d47b8bbd6804cf7d6c21db3a4b342971883a00689b8ce08d7f72a9e5e0e020408b40298d17c16c1d1ac2e48cd493782c392798fc61abbe9a5a55cb1019463bf506af3959d4b551b44072c56a5ddd0d683ead6a47af5ae5a838c052ef8d53f7f50d1c871fbfe2757cc8c81e7de5aa5da6857127d1db2f1c164e41b001141f620444a952a16a1543e6e43a07671accbd8117608b90f575e25942662f980d6daa6df6336ebe3868829d94358859f16a0c0a6a93a363d6185a1385cbc5c65300d91a42ed10b046def1c2316a0714ae0ec4af8c93edadef96ebf614d45b94f376914d5089e980aa46e2f634145d7eee0195e7c31870c5619de8d5c35fdf57fac34f3569464678e6fb93a3e854a0b2254a6b9c358230393a11b4fba6a12577bfd23e7fdcc0b61e313cc8076f9e1016439bf4fbd65b8e555aae4a3c88d5ae30c3f5951f88a101f8889142bb111125d8442fa08d840815f64d89b20375142dbca62e3cb45fb2482e32c056ef30b71f2c56002f5954b08b82c9ef684465644048f6959c7d150dbd3425fdceee60332f8bd657bf6c68bc66dad752be4fbf43b1e0f5164a683d9c9121470c875bcc2cd00e9358baec657f144593c5aa63d3aa4f22c2818c50667f2ce9912b6f5bfab5ff177bf3d14607d0bf95ac8c45d745c0be1404b7e6d96f743eedfe5ca0cf9f9e7ff91bbb27ec55671fb0c132d90dc644c5981cef0e763a086c6fe798f8dd7243e3f78de8da40145d724d62d070b23afe8e2d2b636b130f46960c6190af1620dddedc39a6b5c98e3497aebc66927eb58cd3ee22aef13e886959aa97dc795b0e967bdc2451e9a50ca5660a752757dd107dcb80dcf3216e76f5da529ad6004c8fbca72f8537ccc78b3e6abb8458495ea6e439fa4750e362967093626506cb53ed419917437263cb3383458a4045b6660a634b05a8edaedb5f82c2662d13e029225ca9157eda9784e6414de472a86157a0356d5bf30f662076b0249ad8e5ffcf1c4153131688da34e23800ab22ec192ed849dbd929418e5a734f82f08734974e03d0492c1ef5d82c56add1898fa3b92fd5ae60f42f8a27d926f33f8839a1bdccde6d1422416c5d3dad1a451cbc7f87273781c81922318994acf1c55c5aa2b31bffeb965121ee0ddfc9d6e768ea01e90856fcd8c19597623469a11bc75505ae42601680f4ff717d19cf881e30e8cb16fe51ae5a6cae9db53d09bef66acfa244225a62fba5458e3a2928fb6db85bbc9d3edcaea1fbcf54b7a9bec43bdc4ab252daf25941bc7cd28df57af61e63ed377d0fa520d3e355396ec3c3967d9d62862af19bc9c7f830ed324d9727c80a78e8593aeadbce5d662ab15814fba6eadb968b1b362170cfc2ad19ce0ce7e172eea0646b8f4cc3a931e38b020b2b93f007c922d8262ef867e48c952932f7b3069f7b335e40b211fcf3aab10ce8a11b864a4d8d1bc0f684e5318c59e7cd975ca1ec18707908ea8533e03d0aa6d327d304ef639839dc0848cba5b3b160248507cad089575c17a9b1cb01e87eff643e2ef50ddba31cf8f9f207a22ed3dd3440c520aa63dd9bf3bbdcb72303909bd74379e1e715cfd9087da991b304ef4680aaa5933ddf8b7ed9fbde856dad951dc7dc1e539f61aff9b7ef2b8cba13e48dc93843792299bfadf098922f56b4e21f25f0455df2489184fb9a79625fb4254145a072dca7b245b502ab2132eee7f9c101e47ac6b0a2c163200e5900c44cf21938d99ae5314862194bea56b82b70c0e19ad1870c07b1d4139741593023504ac573b90efe3736f25b456dbab9e7ca07adfc2527c1c07c94ee22ff44873fd0379f126b191475557178c27d75e226ccf4f9e613690eb2c5f33264903787088dd698c25774045767cb4a23e147104b924e83f236843c949663c147c836558e5c3822a14d410e1ea0f414c3c03542e393855808df6c09b73238b969485db269caefbc6cc53fd56d7022301ca0901c69789a562a3a70a581af229d26ac4884cdec7680a210384a174940dfd5ecdd762240f94f6fb0b8dd2f97d264d5698897a827922e922368dae32b35e515abf2bffd535e8a928b993d4f0f1f0ffc026e5b00d80c18e7cbd8fe7247bc1dbe0044c9991a7c1b5b2feb0763b8ba0dfcbe815a60cb431365b581a58fd8a95b3df30ec8e155d3997119311977d03831cd8d105338836d10f6012b07c4deba2aa84b6ec02c0d7cfc15689677fbd9f82cfcb4b241c04c3a492dc1ac819945293e6fc7289e471f9f65cfd77701016bca8db2df367dc46f1fc9dcd02118c53cefc49a8aa0f719354445f97f1c45e50fd6e7441c1ca9ab262c5102af23b3c19cd9c449b06fe44feeb9ce2cde2201c7d034fbb2de3683f57743368b46e66190727e9be903ee732279bd516d516fb02813569d58d215a69e58b42534b22d2110e9eb0ef2436c395df68cff455519eee7996da07bc6454d37c5636e6ccf45571f724e4078445e8854839891e315f3663e226393fc34737410c1319a7cc46885ae0cd79e7e1133a9fe6f7a3819aec9d7a49d8d89f64f8f9ce7418096bcdf98cc09e50cce9e881908260c6d0e614ad9065bda47279bea86d03802d27efac83ca956898c0a62ccbcbd215547a8d0d2cfbd70afc3274e3229fcc380a3c955f4fd713a5a96d03a19c29894be09cc866775888f774132dacbdaa493d7f9fd7e0225877d1a112e2a001f0a14261ac7fbb34a48cb5fe7032c4843335df417a9610569d8e64da0deca29314733bb5d26015253cc660d7fe9d46a38bee82c637c56c20f3493dcbd35bab5131a9774cacc3b2299fd5e786a93e154af5b659474c30ea5f2edc56d443f82b527119e6e6f31422d9b8878b9dc1e11af69e68b38cde8a610e003d6afddd6c2e6dd294d1d0bc2d87a0c37ad44e7e7d10bacae69120b6ebb77550744283db5b38eabe9e50c679b4133124ad0b091b58c76020bd5a0452e8864365c4af2595ca13363e2ecf597f744361c47d7e7f7d541259da46fc4c0fd8a1fda010b3968084c15d2ad787334c84dbc7f393dbd597bd6ec47b8dfe69f98372cf69c362c643231df71ea2257244b57d6474c37a5a6fa19d51663d8b974c0d35c620b9fff20b5c0c814748d5b0925ac397e90ea03de84951ca0b29ab3153e5eba9b38598e9522461de61fd4f13aa0532873584279688cd782626d659144c9f57f53013ba4f5724c78933aeb81debcc5ee81dfaac69076c22b167ca82af0b3fe82871b72bae10762285ed5f0600d6598a4836afc3588a01e31b838d41972c9c89d106a623d0aeca144cf6f77f5248710569f8fd565d1198fdea00b9a891fc556f02cf6072a38bb4131a531ffae9d3ddebd070b6e6a9802ffbdf7eb595b6797996b052e23962f7f0e267cb06f3625380a337d980972f3aa86ac212e8f682836d6e2e09c2779348a6ebebabe2f522faf5cf140eb97e2ac579246df73a419c963bf7d1a92352dda88ab6674a6defdcbf30f091280905958effc15865f3942ca6c5f8f03b94cd4f791a5cf3eeecacced7bb4253317027f3aad29d7e1948da723719c9b26a8580dedaf56fe717dbe81af4647d9b7edace4dbcfaddfe6b86c1cfa6b3da8ab9044153544792a5c033a41aa51b3b5741c85403d711bfdf1abffa872ee26164803373a5408ef1657447d05882d82688c39af6d0b88947487e0b2fd757a0b033bb1f7329c55bfa0014d6f51c888d2148ccc498382de6d64251d8e301a58f81ecfc05f5b4748a55d9795f70dc6b35ff4be2073d9513e1e2810dd97637c988dd73f0a759114d6e4285f5f9f3ffeb7b477a9249d4b043f23539c0d19d5fc2dde123b0e1ba37dea015080830f8ea40f357cd7a917c8a449801536303a6ed63ebaa6b07057a6f0714293b12251a15e53347e97bf22392e924856fd37d71e3797a887c080d47222927a35524dacd6a32162814559aff98ab1d3ad2fc29542b43e5640a560d70fce716b0998baf6bfd35fbb134b2b1a5fe430a47da8d5134f11ba88c463cdf353039a7ea49b29d0868ef1629fde36a80995a5f7f7dacaa0d3fb37a8bbe7fa23f458c260b64d3db9822129ff4183a830303991d28b75e403e655bcced793af884f8b53d67ec7a873fec293f8b02d4922a6280033b2d23ebdf44613afdd55283f6d75bb456e783aba3166017b66ea8f46f835c4c8d97f75c7404777634b3ff9c5cc143ec7bbb1176ab11e55f20cb9d29ee44d148a895999214a1804edb36f2c094fcdbf47ce8e653dd72bbfcb62c18f998a8624e4fe549a69b88ef7a19952d92c2eec5336a67379a370e83101e96eac5d686e4fa2cd014e38f6304c0a5da546953f9216b412b3ba71a9e304bae72c015a23930ee099f9ce576033d067f8ce03e2851bc081d61af74926779bac651ef303eee641b3bf0e9fe46bce4888107ab79c4f299f2af7179e3132dd891980f583da365a8c8ecd929dc7f4d4525d05b50184cdeb1d4a939b158c542ee9795eb1d1ef705db2e6a064cd2970e8a95164e12d276b95aa6208636a1fe8a953c9df510c83cf201ec6b01091100770b5e326ffb6ce7cf81b233a03ba7ad8b39ea5ec965888a88ac9744342ef644abbb3f9be6f428c27f30f05add2035a6993ff8d4c023876b8591cc67b81a9ccf046d323451e2604537d93327e174481198fe2161f24f28c68ab7550010204e2812946736e3d29c8645383e00468c025f551b1b1c468f7f27050f48dbdff72fdcc18eef62214d49449e817b3f54aeda8c7d6821a7c4a6b2cbfdd721553a60dc4b53368988f4ce26d9df55c81845e00a6de40a431c070ccc676502d1b10f0b959a19a405851db8ec83e4648b027879b38d30c6d11b8ace34a2e1f28c3b557b3067f17a333db41bdad3996e25392e77efcfc7c122886655ecd2a61d3b83c65b8148d2420ba4f58504697c1de60218b5888987a045b6ec9c6e528eb0f439a9f2040d878359ec8188a1a638e14f99a8fb428237551ab94cf454e40cccb5be09e9e7ce234146b809ccc7de987ec906c7b05fbbd9d1c6b6c0502288facad6b8ee88646faa9c6eed695fe1a0f57a93aef88fc8e28dd3c11c5c97901749338d53e62b97a86506d9cf701252b08a9c6dad095d59aa11049014268a432bf5428bcec4b17e1b1898d333f7719f2b3787cc805deadc90289ff54f2b791cfece9a2de8162c57f00243eee5e5380ae6c61809f6bdf0dcb5570426d8684e9a49560eb5e3fd03a7d3a1645aef44fdffa43fd972488bc6d53fb12a33a282191e7140f47242d95c18c808483eecbef2e182efe55e58b449bbcdc1b2602b774e71e2ca470182bed6b25759e04b0c7b167defa4589588604f6f3f38eb02bb6cf2d753d7be170c651d56c744a50cb91de1a375c13776b6a0a4cd1d5b77d72ea7ab317c11d21b441cff6a5b5dd2fcc7f287f5fd538f5fd66e6b7aa0289a71be0d6a7d85a3a8ac28a3e533f71f1e8e2d94d4e292cfd893c35c708d03272fdc8bdac8ba16f2b89d7910d539270052ad9a061e931d47bda88829fc6af9d29bb44c478ee80433417e2a3594f41d789d941a72d43b791e1d7cb294a72294ee09880132bbc677e89fd61a79f0394606d112922cbac1258f3b57cafc343477c05b3f44077bf24cc07131fbafdf2b7385c35cf81c6c635e5d27e30c9a9d5df2a6c3da76dcc5f0014caf524b95f37c174cf82604a2fc0879e5650506691c12b99220c92cabcaad0741b55fd97909b90ff74cfb0ab9cfc7277fc24774590160d032e3d02144423f32d2e266ab0ddcc5850a59a97918a691cf72736da3c17f4084f98990421e95ba00260557052b5c798a87a22e1e9fa1be887897e5e27d733c31b8f26c7ed970d0bc9f713f9ff47966b57db8453296a16ce2296e2b49dd94a26a543167ea32d0374fb9409be56ebfa1616d811eca7bfc0af3df5493c0a8486b06422b9ec705d1eb192494d92ca6fe591887bc6a22c33b77e731950d47110b0d353cff52882975aefad25516d8a792fdee7e0130d454fcc211662b348ba9e92df8bbff9df303642832c7550d86838cea9d4928cd6bada1c75df95f4935c4a5d449bf9648f608f9350e227ccbee4a10dcca57be55cc182a65d349d8d9f8d87724952db141014c984cac57c086d96670bc0fb79deece2708dfcfd03a3620903c978395ccfaf476ebd0caec3bed94c4573e3a0fd08484e81cd93ec334b4f1771dcae0d592eef363e57ce1298930bdb73b2fe598f32ca240eb77283b71151b3537e25486f3d2e535a38c35c8f2826c666e769386b3fc5c08b06b229236c2ca125e513382389b5cd7ea2db49e622e1e2d3eebf8233d0385e478a4298fb213e8b3f6eed9b03daab68cab8479ddc7b5587cc7d893b7d5f4d747330b52811c0601cf83093577ffe9866f78887125b7fff42eda74439fd4fa10aa7db12e1a1aa9dcdfa0d7d42dd7878b98bf27c60be90b9a35d7c12c2f927395f97de1a60d8d228e459bfff4dc31b51001d9f94707f3ea8def89e6f68f706eec28f4cc0937a714ed206257089d0e41c325232a051cbd7f5270caeaca37d800d48801a971b3299557ec8320861ae7f37be6d148bb74b95a25a853a2972bcbe2244c2108a2b2c025be28b8fb1e33faf68ef262b92688835a480a92d9e6c769af53ab8ea609ad7d9775be0e2ed33f27bf3b5fceae952eb0c3ef6825281428ee817e2709bc4116f1719a8d047c815c623b264d120da76a29d4b6b725431b83ea747845c7df44a2a55342334d0061a99f2f687c581652e63d4e712ffc2520bb64d3c0855e30530d45454","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
