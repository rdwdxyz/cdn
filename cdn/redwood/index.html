<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e06bb5500d51ab6706638e3fc59b314e66707ffb61742cd818a167172c90b8005e08de4da8d171762c24498bb1da625abe662c6f03f50dc803bcfcce552cf4173fff7694f6974aba1eb6470ae95f791f4db01fd4045aa28aa5aa5c573a4fb8a24da4b86c384e0884f4566da8b5beb4b4190d71963ed3d4fa3f9e880ce0304898ba517143ad0509fc12b032e31184f006ff4fa1e4a1381ff025774e1be2133b57750731a153fc80d247ce990eb7abb5d3605c2e8de7b14a0efe9d826a3e13d6b768803b087b7c0ca2ef70196422e01361f9bf866d79c3673adb6e27ced98729e48134c7b52654a4e7d2799e78fed03395d2cd569934e2344a4d2093c96625c74676033bf88d3df2aa23fd31d4c76fb9f242483dc0a3012c838248de065fb9a173cc4fb4bf943510492a6a23eda3fa1c4819570b4c50a3d8515da24181e42aff7eb9059c9c1cf25b0b513fae3cf5d4ee77417970431dc3effd72ca0b5ed9435ddc73811514a5ed64cb6ef46da21c50752dd599ad20afa9f4601ca6171a7c0605e47ce9e6b8c4294c28d4ded24009ded1adccfafa2d4b1f1585e46f987336a90062525726db5f6d258d4c7a56ceaefc7aa6ff0686d1e08e978acbcfe78052b0a63320c470286ee57729fb97f10b0b458282f63a6f5e890a694dcd99ca6b1741d3a12f8420f8b7da5283004653218b2b9775544733c2959afcbdf69591fb99d58a1a3f5f48fc06e7a04851d67a216e762fa7b142ef25f1910c79d85a15cb40356b5f4d03220c165263db6584a8ed36e82e5c1bdbd49522e23dfc64307ca053a2b837668f8622fee4dc67cba9fd0e9463eeca0b59c0ad5c16af0ffd454b1c2a0c280e1f952899cdcec9ea9f520e814fe7823b53e0a56a37d2350de434168581e446957b5e5252efd48fc3733cc20c8a78edcca27816357b7fefd44615a0e6b8a267128a2e4610754b630f2409140747fab6a068334e58f99d3b8471b28e8b5dbf1f5dc3f3346571f39752aaa044910ae8a83a996011870d2aee6e9affa0d37abdd7a5bafbdf408fe89823a722aad3db59fd0fb612275299b0eb405bd788fb99b453426f47100828a337be7f20e495f49d889355c79af766fd13fc6a87871683686968fe3ab1d902bfc7b1eb637ca6344db23382a215048e86e00d7659163d28a1478eb0b76ffe9468f6d3f22087586aa0ce3f1919e7ef27fe4a976edb3247861e9e5e9a9b943a4789f17b8067610d37d9926531383db926037465509d3d37ab2705d7811968707ce814e4a0234b3daabfdc3261c8801a0435bf114f5fdc5a3747c557362b15d7c8850d1b3948a1fb0d75a1aa03bd0c1014739c0e0d81e29f858504dd7e7fc3b3f543f389625d121db32cf7b87938ec0feabff2cdddb61e1785f879d331f4f0f9f33f622967b99cdd870d1174cb404d11c42a69a2776c4b2ca935feb2612cf548ac0bd9dbda9eca85d5825044a9e68146b4b38ae5652b8041d7ae13038632c9be3f2ba18870710ea555c348b85f1ce50817cc6ea6e7cf3d70b42746ab10a78043ead0a4b00b677d2575f10a8e60fe5ba1195c794fbfebbb85097b80f883e7167ab3c37df685015a5e4e7c5290ff4186919b4b1efe942a2d766f20460d03ec5d6668ebb3661156aa6eef5eb5b266047f6e970cea997c987e39fb4a272b43cdaeea04f47966812230075a38aea82bd6ec548bdf5dd7c87c4cac3d33d0b4799864dfee94559996bb19377fd69771ee0f2f5cb67b5157ced0ce67480625ecd54ac409b464f51577a3610f064f62c19c60a6bcc915c09e8497c1730a67bf9fadae576070d37b377eba04569333f89be7a1eaa18b08935ee84a67346c0ac57557c03b911fc953d3ac2281d03304416d357478ebebdc11f8e521cf72ca9fdcec88c0ce3587a8f355ac3051fafc14de61a28a724a8457df9fd29527e088f2f053a57f3277d62cbb51f890074f9c2e3db2cc96c245a9ad3441ca2fe867f383cd5808ba43a060efe0462ceb6a41ebb91b1c5ded1bfe86aee1f7b79bd6499794191fdd66013427c4d7caa9f76e3f2ad3a052430a2a6009eb134360423e3fb4f813ecf86229cd7a8937c3f463f41dd59df3a44c18bd58bfef66bbd1429b63ef00b636ec42102f9da1223b4bf474946df6e6fc51a679ff0986deb4a3d01e7f2d814acc104a554f038aa8753fa47948f0a72e0944b30e63b484cfcd4df6745ec5add39d54211d39c8fdd05aae80d0884b73ff7238fe67d29f32af5bd8a258c12fadfa0289cf5711a01b488d1db9418458045cb27bded17feaa9a8fb3c1178acb5de7c4f7b10e46b390fcffed4c3e88068f5628d4f62671ddaba5bb8c7e8821c93b1ee03ff26ee03333f0884b221041ba85c2af3343ac975161e2e8af17765faaf5542a4c58cef3384cdabfad17b0dbfa0f9fd5c7fca92e13ec3d2e9bee6329210b20a0f33913be1600470053fe59e139a0562d909197ee66d6ffe2736b7a1dacc28482c3fb3bc39c2c760dd75ae3ced93c8769df1ab50301315f5a7cad0a4e3cb0fef9b77fef0422da1b9d2c030e7091cac462b1475009317f91dc6cf89bfb1d0a54e8460a6022b2961bae6a9e49cabe7fa3a93c2b339d9b450569bb19b856e9ce4fabae8a51cf5bc3d638f588de96ea449cd9932a893254f75154897f37ab02c665bb3bb3cb8110ceb78eb44f4e8dfb6325984bbf5fa86ee390bb819bb5fc86784a61fc6b8afde616b44e9734bd2d9be5d3f50599737d1dad36b7dd4e1cab7ad46fe1c926edc3031c590aab1509eff9bd8da6cf3a346f1058c996affee6bad7ea5af94a6ad6ddf90d77a10d496515d34e5bd30a2701eb6bb4a9329fee868a50ac7c116e78f9ee465f1425eaa0597e8599cf539c24a1da3580725c478f9e176cf696d776665be2f6f4cbd0ca609f33d26d7377170ed467f8608a5fcceb92977bf6c6fb846738f49fdb94d7d50bc0cb0993af427caece4afbb44133e7472cf8a021b0b1b103333d8e3895f22af2a9a3d4bfc61dd137749a815dea9986c25c74f9c7d85fcb7c2e3749bbc5dd44ac82b8c17325097f69c71bac48cef7e0601876dd39e1c96c840ae83ace938ecc91c97d110c917693fd9162f8a0ad1ea6934da9b73663df61166adbe444fd860c3513acefcbcebb4768c5f9a0d11d439b3e4835d0f8e266255c110105d110985163b62071c48c34ea4a50c816e35a305235cb9dd28e479bfc68b883082e83c6bd3248da3ee253154b066c102a613ce7af3d8ad2f83e0b9100db77a70b749f0795df7b9fd5b03f2a005f19e96e08ca702c7add6ae848bd190a355716ff1fa228da2db6da0c298c5a5e1727a08029a7ed4342d26b54c24e5b79dcaca760e674bf9664d1d755b4e20453948a3e67f7e63e9e2c25b2cbcf2a3d933c88f107b8737cab12159687c0ffea47b8f58fa21e290b928a054f3e8ad2c26c284ae9ed326dd027c9a9b3de6a23fabdbef3d328c8dc5d07a6249baaa0f327333317ebd8c75307e392217c2b9bbd2d6e6325a3382b1a79d3190eb9ff845018ff92da0facf7e3d8a9e00bdb3a784782a962967f6f88f1313b488846bb3734b730795efa18ed41ec909abb6dbd6411ee0a9be7cad83689925e0975b81dd91a9aa28c96fa7197a45a1ed94711f6f6b69ee99000334d14bc4ee5a9faa38a9238cede45a41dcac15868e7eb8a8e0de51dc60bdd0f46a3243f33ecb0ce66d2fb3200a8bb27943307fc9dd3efe9e35d05468dd1e4d64df295a09325e76567dcfe7d982b02f8ce5757e4a51591937e96c319489459f950fe033ab368d4ed54faf775fc080fb00c894b153c8c894617455d413e7b706f7ab11d759a8cff1fdf1cd8df5a90fb93648e093fec7646c2311e81422041626bb3c61ac1098610cfcb50d395d7e9bbd418a32af650791a7df14ccb2cfbce1de476738e0a0d542874ac3242e9f3c47e2f67b8f244c8a42ed53c79f9d28050aa446673536c28acb1d70ea64f1ff03efe0078733f716c4166b7ee1930b0a839153d947198a0f46e96288dab8d931c0920554cb25b4895a1ebc6284adbc1e987f0b032b8eeb394f7de1ed2eaac4ef46d067eb4ddb262f79a65e33238842b1219cc0959221272be5e86198d9268c1bbfd8c57425dfe706dcdee5ce8ef41f5b2a2fdaa9b2f51ccf9bec6d76bc323098d2699347a8e135df2305e5ca3343056805589048dbb946fd72e4f2f16d83a9c7d57a177bfb16c400ea6ad504c134d300a06cb3d04c32e04b67cd84838a6b6b25c4a3d3ef5d7c6183e3d9a35ec07403d39495b2394502aea7cab93709df80fedd446651843a34982aa24e3da2d145bd0ef8825523a6b434bc4ec756cd58ef136f4bd6f1b378310868da3efb45ed00f1a7c2d224e4b2a4d04c126a463607a1c8186f3e05f2f14d8dbe1772b9c5bea15dea067125e755671fa21676078d0985fd8fa0c18af4ecc019a214878cd070b8f02064df5e17fe204216480ef4c30cdca24749490d43da4f3ffd3493905abe5aa6c59fc6714b1d9093dcd4c1338f00d185a3b49b4a7e3129349f3fc632d151b271cba4dca9a0d7bc3a2cd555815c4a9b686ad88569143da307a8c239ba027199dc0113af307fa235f1a2963161a4116d7cd2e8531ab040b3510b2a8e30feae7d2a66a6d29f7d927567e938ebd45fa980940548cb91fde0974f28690d19d2decab18b468801571846633cc2d72e439a67f8ce91080430f3c1c11099f346acc35b64d917938f6f6a03dd57ffa0ed8987ffde1b355937cf2a6f455b12efb6883ff02ccba10fff524d7ad93ae30070722dc4eb17db25178d0df6f37c2492764cf7cf8b5970bf167c54f9133e77801696c29405674a0b1ebfb7f8cf912e381dcc9a804766da50b5c85afddd5ef44e86e102efcd12ca25da5059d74db7b7998ffa0ea12c6edbac63353ac947937306c9d16663d99ecdb65e90c199875bf29aacf568aadcd8081d9f2f2df56003cb7d1b1ef5bcee66654cad24f192a04106bc26db2fc5a9ce51aa949be7ee0606d6cc40edfd661c557bc4de32832769fd0927d90201e0646716c5bced44a7fe1f77afade34b9f62d3b5cf5cffcdf5fa7a03ecb637d55a2326cbc92625caf41a8c40600127a52116dfc9e3b51eaebed99c7188d7ba0516e155f258639e19381032ff3405b3dd89615bff0a78d4dab5ccd389acbfb285d62897b89c0ab15c38665ff46a975083ad677a4f8215c8c4d6e7011a5979c7a08a2e35eedb5310ad3e5f66d7618d89693ce0a2223fc15fb9ae52ed4950fb271bb53249b34c22f4009391d4d068e729ff2b5d4e009367396db10ed2ec2e760c329ac6a00801c08b80b5a197a376806896079db1141971542d21226716e2c73d76cff495b3744b6b13eda58cb07585c0fd7f22210385a4740c2bd3b2861c51b80bb4d998199998bd10510a9865181243108e16b396e619061a9332fc2b34aec6f0ad3ada48b76bc780eacc591080ff91a3767b5961766fcb94de607a10a72c766a509cabe45cacbb16d48284d5949a117324bebe1ac26f900f97ef713312b802e8b2de96b0fffd542583cbea26dbd2ccdb72e24813fb5451019f1f0886a3489fd78a45b7f9fbab290b460ef034cc265249118710b3e8ceafc904477e7e3a497f979cd3ca32c34627e87267d68019aed97444db76e9220b7bffbfb115de8db7e4694666f39473d73d91904e8f8a68abf9a9c62fbe1a290cd1fd108314b29fb540871747f2fc0f27c3f628bfc53c02070c94782fe817daab021ca238d8fec5506036e7adbba692ddb81d59bfc13a3d8de4a02790f69bc3d75656fb6c8fa70be497beafc8b6461a58ce5b607e9d492a9089ad2ba78ed0eef07e49ea55c04d433d867920efc7e001f83c9cb3ba56368bc5c9b50fdb9e4d6f90735d8325cf1fed9ce84f6713f76a1042b3a573104437265f44da2dc1dca60d11a2e6ff3978f6f8d4a61242e4772ef5eac3fc3d2216309f5a1a1a7e8a3ed40741f6f4dca7c158ce684be5b961ef9a5fd87274121319da586b640baef9423c7b520b5c718d069a84c2191f727d7fc5ed086c0e0aa5d8feeb68a75eee5f744bb57889e71bb9a09f7a8181c19e6504ed164208a1762dd9fe76beb258651242be04da1dfe57d4cb46375cec62496e76e61c2e3c8ab0558b0299afff460b694813ba33b473f8ce036000d505d17f5b4ba58dfc5fb0256cea62422f815d1470af0777fc59a438d763407716af10180e257afbe27fb14bf813d1ae50f6d6649bedad0961819e1b88fac57aa0ebd079f1c1672a4b8481f1ff360b27da6aae81132c8aee2804b8a0041486e5a4a6dd159ca7b8512851a8d537d7ba8d9a2592ebeeb1a86f005aa0b3936b0d828a82f95a406b283280c75fed9d07dab47dd092ddcf33073761affcedfa02f41c978dfa991d9d36cac3386af0cfb3d6edbdcf38da0b45b710e850bc8389c53dd474fbcbab72eaeb0ea88b28908702f85729fe4229f68beabb607dfa11dcf0b5498fdcd77a067a0f70ea0fd624915194c6979cc37b4234e5d24e867408bebb44dcdab11fdba13526a8ffd02e31dc2c6a9ee01b5b8a490e63d7109daf44e0c0947d04db07ebea05555288616137569a813fa1c062fe345a01802aef89eddf061795607e2f2f51a08cfb39146f785612a5144a9b021443cbb4fffacf2a820e5d6bee148bcc6f5ade20ad9a8676ff7910b791e42d56ea3d7144c5ee967c74add71a57eb0404c328aa27026f009f28d45c7d5f46e53c14b465439d9ae8cb049d41f5754b77f5a0393cf2f9174b5ae0f6f15740f2ac244a57ac658492569ada1143b765808495c5e83ff8c4dbd983f610a467ed52195c20a1b615e8598d8ea15e5e42b7f3ab7bd7ed8b4e55fe2ce7c80090596521cc892c6d9a1f71251c90e36fbad129239f6dfebadb30310034cfe0d35472fb8b2831269e569415fcc0a923967ab48cdf806e05c822111349398cfb39f2158a4e4e08df1085e54911c981eb464407ffe9c8df23d3df575b5ae8eda91eb7e02813e0b2e103993835f5e57207b3e56ee88c5950f128906f32a8ee3b7a3ce25b6bfbda3dc041785b490c1a50a7396b0d2366a4bcc8fe3bd16c7386eccf7da0b3bb25d6262c16fb68ed4490f7135ebbcba899c80f735b9c119fb568f73e65022fbaf8a97c6e93cf3bf56e9936abb7c05f4da6a485a6a4ea184acf7514e8ed06d43014e5119634625ae21e727e414762349750394d6db00d63d51ebd1ce2c2b7037ef179cd49afdf4e253507e8f03667b570b53087970153c002faf5c52839576e14cf0fd0ae4b97b7e68a5b78296afc656bae6f2738eb5791d4a12ee5ad80c7b0146aa69b35fc44c58d929818de86aa3f9c7db63f2b07abb87bf6080ce222f40e122924e2d81251570c80587fc3b6a9f5bccbcb395ce722d9d75df4e3e55923b60b29c47196407deddbd481f42735b87fd3ed7d4efa9cef126cf9e210fa4f0ea271b275170d0e5ba9f7bdc25c26400705710179c78f53b16564eec787affab629ef3983f99824b2f6248199832c25654c0d167f658d348dbbe8b16776fe212e86c716ebc69992d92bf6cd9803db39f837dbfc4a9a469548b6f1421f85da4dc5d56a8511ef4d75b6d0a68aa77675e8c8c963779d94a7f096ff8cde73b5bbec600e1da0535efe6c1a626352c9226f6c977330c8b1d73824dd2489a6a7bd00622ed18d28e8ea37e139eac457e5add649a5c5194e960bbea081100ea31c83d608f3c1975741afb1133efdfe35ed6c3f30c608ae444afd85609c1657f43c1b61f7568fdae66760afcc939419f616d55ab952a5135b48f565b0d6800e753fb619024cff35217b3cf5ee6f772edcb050c713e926abee2ce1f287af335fb3676d9f023c6666bd8dd5238852ccb140ff570d3135a798e2c0146301515865448435e77a1b84b725fa22239113b61cd3d522c2f30bfefc2ffc60e96ea88c9b2cc7e1b8d8c659e1c0a3dbac98f52ee5e8726a5d6e985fae5c0471bd88c3f40a1bd2ed0b8ae513d48055a4a5be18dc8de70a5a1254f343671a2107920e02702f41a8301a425c83f37b99457202566b2c1846003230c81aad6ff9e4a77c035291cf215dfbfd5f4be09187b581b55bd7aa5b64c7c971db00fcb2e2f44f6434a3a6b41da51e40c2671ebc68f4435d63a531b4f6c2a1342211b5f45ae843d84a85269cc6b4a99b45e5c25b438c0bfd59da134a068512a56341e45bdb3fc6328b49b611ca171f7ad9b346a187dc7240bb57235691c53ab505f9de2c1849ef5edbca2e20d4a5eab81ebfa9a8d8542420d19671179af7d995e9491d7a174c8529d1428baf1b7838e0ce25e8dcf0edf9bcd6436cd9a5f7a82b732257bc6c62b8bb7fc2b6461cb1c01aa7f86fb0e98a710723d2e118469531c5c3c3d15cd981029214340686b4bcb349d6afa2ca66cf7dacd2959ce30745e218f6c2636ad17682b4424e8f99f8733fc30195fa416db53a18afbb77ea96ca87ad2a37022feaeb270d5c3f23e4cd163a158ba4eda3ba86d94093f2bf58e205a678d85839183f47310d9d715496785b87e7a6a243c693072261360dd3d7130f98e8878f8667a354b2f16373d54ff9445de2ec4493383e152f92d1151add31a90bf00d58d4d7f90c5e13e06b342dcde0996491e79b03a9f0c38da85afec4fd2a78e6ae4d58f43b542f9ef0d0fdb48496f2a4a773a1ad0039a719b5d20f3b3fe1a1aa34e8a760cde8928b37ec32c8796a80d4e677436649dd6a0bb822980df885f2c8afb255a3dc33ebd0ff8f80a8a08b92becba6394e5d0dbed4545da1e8de9882988db7457fe019eb0c94c13fa6a699471e88520c56ac8efc61d3f17e8ee888c50bb9d20d6a9d1192f6764ef86a99482b3578d25a05797265c9f4b05e15f4294fde8b415cc799dc89eb7f446e4fd6e8dd3a762836ee0c629752de3d480de612140c07690e01438750e8ca8072a351f0b5aa32fd472c8b2237117cafd0070e1752a91e0858d6baec31d030b96ff3c6bdf320b02d2d83e86abc0ce5f623ffe3e1aac2b433bd720f3e6b4122c74b26766539a9eb3a11f8496d1ecec8abf55a3ca1ebf5f23714efa352fb192419a41843fa4f3f0e036d6f808b5c04bd9744777cb93dfb5cf9719dfac4f80db644a3b42d01892dfb6d705ecbec874bce6abba57d9ca686054676d47201863a6465517abd8291cc86e31c54360ccdb05cb9e19276c105f588948a415ff4a03b0717835d5872a4f502a284a918d9a310d27c3941011d009c46b2aad214f7b15b5e5476f2bf8b28bf7110ceb1f30fccd68c8d943b7ea031db47f2843f0bae0e8a8bb5e87fc4eade26e540594c1dbd7a5e9fa3dc0d1ea473a8cfa9b9318ad8cd7e40584db89bd80ad7bbdce1a53abd89f3cc5e03d815cbfbb940555e1d6d279f6d5f041c256be2fd754c4cc2f27a78364fc49bdacfffe14329406af537ebaec38c140a81d566e30ba6d429c614093ed9b249929a4c27c0b749657a56ae386710145d8f81b2ff8c83cce6585ce79c129f17d4532ac91e00cabc5d20871ae341009c1470e673bcf4bafdf954e3c28e2e4563495744c9b0baba8e9fe0cbd0f369f4b5d7cf253880ab226fb446f3b80ca18ffc854ef7708cfa56ea3fa7691a96aafc52a6581e488521ba906a40cb97f35915b25df3d36822c26f79b8d350ed20cd69dca00610e05c7a80f9adc040da8259ceed38f645633a749c4e2569d9e6d012923e2ac15c7fe46170d53a14332264ca1464aabe73b1e657d849912843269a897fc18dd046cc22456240aca40aed4558f5c14112fb8c8e48929b95794c1c0cbb386759805481ed7df346a24301fe0422fcdfeab79da486ee3d4c37b2257d530240df9cd223f5b06fca1e2012a24d8654faaf05e49e66b94ebf8e5247ea028b888edfbfcd35c0f30e21cb90b4119f8d50226972c5b5a49eedfd8f54461a660f27297ea20419428ba3344c25a094308023cb1e3f28392578c90d88cf526c3c63e64b8124efab357bd8a30184875678640d1a99dfce3582c20783439a7befe29b6b5f8e985366dadbfdf92210742dd67efcafff7486dd178f0df97f7a123afa76d813d5375e18b48da9e4762647ac8ebe14e3b5dc39fbfe41caf2be24bff504e0647270e9d1b30c182af113854c5e36de0f4937cd8cb35dcb9eacbfd6731b4a57aad38a00201767d8fd4e5a59ebde75a45920673357e87bba8bc8ec8ebf82db80ea41c5c2be79be4447413667578b496786490a275a8b3ba374cc33faa425069b1c41a51a936472159e4c908c48cef7a69da2c58a107b0f2201d6564725274df266db70f3e2e6d6ecb35ee0bb8fb434efab8da44e051bdc08d37d205d3a0951e0e61164055a8475fc70a8683b6f83881c5454c78482cd340f57ec57824649f42cc3691db3ebc3c3457cd871d2eee605f5efb068322ea6f64da5911cfc133ce30adfd070dd3b606db0e1603a44f8c328ad6e3ea6d1e7feafc46762f39491592e42803814c30864079eeb0370c94c9aaef1d68930f4f9ebd24431fe147b2dc82d38ec000928c104fd135c807658f7d65cd785b6b5c961dfe827ccca3b3477b692751ee37a513ebc044aad7ba891c8530ca5e08e43f410754ae6d4f19cc1974fbd934457462a70b7366f2f79bdf5c5248c00d6621d05dae7785561c41f0ea6e59d9b5b628f2fc40c59a57ac1d1af7a83536fa6534bc3cd9428ac293e46b2d3853621b6c01afc7298d605909b8feec6e0dc149afc008d8406a004ef2d800cded528c867fb2dddf67344745e45743df31aca390e26b528698fc80e86f1dda3f9ab5d50b4c8bb708f48218fe6eeb60f6fcab1a4108b3324f9f77515fe66c2e136c7f5bae27b9499474b2aa4ba569054e1893b1d2a68cfb5eda126e58215a8a335d87dd29a6eb208e58a1516214cf86748f4042943bb41398595a3190f007cddf3ffcc6da0a0aa63987e36bba6c42ea796929e9acf338bf945fbcdc10e309f81ab39eed31b904d9287477db78a9192679f5b610eac4a8766ae77613f61bb81bf7fcb93c2d2803e70403d409dc6a00976ea32044b03614adee0b97798d6d39e8c2d2e357a3327a1e163e30aab6ecfa4183a6d46f9c9ab3fe278af06bc949e0628768faf26dd1f89d7b1e66210da75de6e32e45c37b96eccefd746aff615317861cb663c381f012a1a38852bc172ed0e04ff08458cbf3522d2669a9cb5bc3c001d7349d31ad0d0dbf5a816e36861c70a7c52c26c88bf854d84a1102784fcde098fc644a15c954f1bd981be3b781ed3a7c50fb83dcf870ad5d01f99872c09751c438cb5bb2da7afa14a7c0828e4812d4d081946fffae7a2801b91d8a14d46c72f3d3aaed60ba32f3f26b09fc764dd99555f924fb03e610c5aaef4b3ed001ff6cb9f1e3b64b55a0e238d8460a0f041a70fb7f82bd970238801726b351d796afd02991c21a12e969695a5afaedf1e095514c75fda1fc49eadaae48226955a2a28135f16e801adcc207a978385a7556d047d6c00777ee751cb6db2fa050a79f6f2ff0fa8adaf6330582ac3e666df6a93701245074652eb48fd23d3c1c94abe2d96b656a212d2740336473b8694b7f85d64d4f661b19760005f5c5711abd3b27689440ef5eaac84a6a95e2383a615412fcfd1b1611ee3f6f33eae919da329c85d061aa761da4a9ba617e9af39a6a6e1cf84d50270dae77e15bd1a720431da308bbd2a0547d332f853ed5893b1bb8067519de9f1efb9db2c0ee758bd8ffed9ed00c012bc0797d6c57263955a09e8dd71b224ff98889a1873b012f2d4e01685a71c854dbb1658d5f7164e3e327885bebfc98a94e6f266bdd72b112c34fb3f56a939e4423e84543b74eae31f2c6e5ff53793f47bc6c7bf815eba6b8e2b2fa844aed06333cf71070ccea65280342f5265baa939d647b67c6d787d32b0b223b6be955a693b78e31e4a34033c7d8241f4b1f744b7c60a2520d02aeef30b613ce49da88475db8996c008224fa30960661d578a35613d965cfbbcb1cab217df976566a56b4aa2098edabd8da4ec0b905779b0a90bbe94d1fd5702dda656e45c9b25f3f269d763deee509067d9009fd8935ac69bd2f7109693b103d678cf61f8daf2e065026b429ec7fc69984de53ec729e6a9cdb22963c87edcbb83b9780644eeb76a6ee8dc7a58ca4f3859fd63047bfb005ec01befabc2c19d1171cc4da78513d66ba2bef7e939347cd140840c1eded68d6c3e9a6bdb19681a6c4a35fda5cb0c6ba339ff1ac4351d2212b33885342bd54a2cac330c7079794740638cd7b71c41e3fbbff2be1386965eeec85c33468d845f015a0051d4af58d680f4939ceafafde063b4bf67c786cd413654f59a48c223063edb9b3cc2c8aa01b4ddfc834658147f72a4879be797ab645105e83bd3f4da7b80a46128491d434b2c196bfc2428f149af6aefa6b87f9121556a7135d9dc0696b2d244dcc1b905d71df9716f814728518c3cbb9e2bb56ff8440fedf069f60d7b2b628cbbd8d715746c3967d6d6233a5ed6d8b1122a17357eeda23cb1b8d1bc94744cd6b9415a1547f39e8d2d8c2bf87de6fe4cd606f7a5c474b8b48c071abeeabe094a520f4e4953731eddabd17ea1d333a256d755aa798241cc16ef5a04115a402e495c85f8a7f7b46111b8af0894b1add44eba70baf9626ef16b5d70073c4dc4a0303947fac00670a22ee6b37d02a00abf5b65f3a242ce0c899650da24ba86f00d834308223bc5ba2328e7fce4cf46cc7f02bc21ffd3a041297f637eaaf0e3aa112ef309e641dbb040b35cd79547677acbe4b676ea381609d3ef1b3fbd767fe63336251e34b4ce9005b029fdfc745130ed58e48fe9e8c91478a992b6f41dfae2d885cc22fdbb9b313b4a3a749fbac6d7cf16b87f37444c4f1734fa0f84a705b0682df36239d22d57cee48d33f0f7b1411ed0295301c3ed34c34f6b2b800cca6489481b0fecf6f5be410960b02dd8d39c07550b78ec39583d72aa4f405b31a8988ec46c1ba8223ff64b6d3d03a603c2e576d28a775b342675b726263f0a2015b24315a156c6bab4f259e2a70abda379a76ce883b92942a016005071576593476ccf6c23c033e0294939a9d324f4f3e7a625ae9c625ab2538d64b478e6868502236493e0109b03dd6d28f2985e7b4629ceeed1834ac9bb68521d24892e89dcbb02798e5724c0db8ba543736cc913051a17f5fe21cba6c01785bb4fc1d981111ccbc83d84d26d288502ce16b9fe4eb6a19fcf4723c4a93e89a50e682e949c876cbb718c77117d089bb1dd30b0b8334ae3cb4166dc1d4239dd8096c8b7ec2760259e447987c635ab7261536014597f79bf73bdc1a9f9cb99efd8943be8075e20bbd2da9271a70ee2c739ca8c820dc3530daad048f960612abde2c98c431ffa498051007180fbeab21317f91d0243af921b84f4b775ed0915ae770f8fa3a2d16902de56618a50f0351557d7a79c19c24c53cf6a2cd3cfb49e26f0779204239a8a32952b1d0aa5155daf3a943b8d526d1648804a6ecec2ab1a0b1142a834eac3e003e1bf4cb79f2a4d2c2fd6163f807aef7c1f0823c67777633de2549abde14a789f48e50c454a037512df45e179e4ef8bfbf5e4ec831c183a586b9d976eecec472b4089663eb9d1699369ae259495a5f79cc29ee845f3dc3efa24346df1cf9a540df1e741fcd83d96cf4d2394de2a9b459606343c84b29773b0f52fd59c4d2b8cce7636be1f2255294c239660f2ee3ea169ec90db2bcb6258727c8c32fbd674da3f59a733422cd1485c9f916f349f97af5e66877e7799299b04c7394c1862daf9dd3733ad8904940f108a2c3e735104861e6824cceae7ac27ac9b046be167effb6c79f4e96c07e8135020209a9100eb99561b4e8676616b0cbeac092a33aca5200657becd70ef997bf274d7e1036ade213f5196a1caf1d06de37497da34889aa32c1e18bcf4cd387ee9937ea2c500675213e311d0af478f13507ab8b7fa1842bebdaf1f5f1cb14fb701330d4b4eedd813c5f0c8e5d96a72839ffbbfba923ad1df5557423fe52ed04abffbad586d186afddf2c1f379118622b65d029a0c79cd3b78c7dc16209fe3c0b93a1a954d3218103f7ffb6ab0899bbbe6646b7923d3eb83577c1ca467bd52402c4544cad60d27bccf4ce5da1aa1c6d3824344f4ed9d2269a64515daa6a69eb4764fb0b5faa4952ae80cb0095c325e6a7bb20a5f32fe1d93e33208308b545b0b1b41d2c2140612ce7852964edace59d3562f1686ce6d7fa7879296a40afbb757c7acdc5df73a6e7aa2aa30ae0b7002ccf8a165b5f53266496734fc12fb20694ef79841895bf9a6d1ef34804fe7741e95f2f84b7b5302f063ba8c749bf482d8198767df0273b29dc45067bcc1529441f56696de7bbd0eb1c6553b7c9f20769cdb4c9734f2d897e6e6429cb2381e0af7b99ee250b8b7ba7ac0b37efbb93c0b5355a40a2c8dfd7949f711750b543b4a98f960a8a27295b50eede3976e51eaf54a700bfc8a42dd5d6ef572448ccbb1fd38fc7c728c968cd86ef2227f00b30de327d7c0f041ba5f3f9fc0ce542a10c0e2bd6e0aa8bab628c9cc5659865fa1e3c1b13fb06ac18355655abbe49de81ae461ad11bf2db8c00b822314c2c41e3a6b53c3b1167ac8fe5a205b80af6d094c80b73d1f67acafab393f470d2a230ed4801eeb9b287ce742695a0d57d65ecf817a2078f12bbde99b769ace151fa132e89494ad6abd103a10f0716b6da04481cd8baf53d2eddf73802dad579df5c952e8b0af010fb096119243085f8e69a14f24cd973179e1ca51dd3ec65eaa6dbcaaea03568247b20d52ec047764c9b2fd98b701e828f4bd708bb9d8d0b5e6ceaa0f59286e24ceb9f669afb0edafcb2b257ed37a384b90f39d6ecb5693095ae5cd654f2602c6050f1287c08a2202cef8c5a52e322d0a1faeccb8291a971f29a2b5e9738e789b398c0f575c995690632f64631aedc74df8d04f0ab59831a984997e912b700392b8e3c169b91b5b9fbf0190c0094d5f1d7b6e96a51a68434396c23ee87514f4f77c19fb197deaaf949b06311e0bbedd94527dce78d6fabf1f8f1bd4e4713ca0a0814a25ef46e9eb70b946f245b364fb1aa8cf5623eae985758b9d596f4f2768d8f2fb1a0901ac198b877e32d8d93510c64ee6fd8ea81a6bfe1ec15ec878dd37b90ab446fa1724924417a266a905a5d518d3df3b116a876d1112414c4e8ab27792d2c7a561e432e5225fbc109045d9a8d3b84d29681053d4b65bcea50ed8efc0dda8d0d4683a8b7e3e484cbee47d60cf0602b0dcc6bd8627826463f4151f3d3d2b0573e96ec028b575381fe70b10058451680577d6eac9feea597731d80cacade5684d2080a0279b5d0ccf3f2294920b7075b0c17013e81fa5bc3201e8981896d0e7e662e6f45974a662fa24421a164e87cf407ceeba1ef15e349611c06b88a845d7a0071c22cbe04bb969fa1f6f36a68a6f35edcd0e8207c5746ef9032938f6d043661eb07966d15215033f9ea36a63dd6390161c827f5086659e76ac9e9265e917d192aca0985f664ded9b9218d713cb809f316588883b3573dfe150c2cde97d41d4587f6d3e0b557579728cc74a232feb932ab5c02b2cb8887037e5b4f73b800febbaa1946f69f3594f8760b1b35eb4464a296e13fa26b90b92f7ab6b94065d4ebc286306a3edc74112c99deb12425b2c6f0eaa6070e75c9d200bd09d99a4684dd50520ac5f690793a0a4a96ae9cf4da5f871851b73f0a4b869f2bc5545315bf7ef1692386352d3ce7e4175d8e38489ca00b201e9b196a681b13204fddbd92ff716fb997658ed72fb22400fb8c1a2abb66c9c947461abaa2bd270544df807ec4d1f873b1ebd731865ec553df71f81737b3ff3cea5059eadea5dca898805e62e3f83852489e74f687687e0e42633a3e88a4a7389c7c4bcd703251c161275634127f541dab581d25997a1c9a4101a0c1b79d8115b651861b01e6c3783e16c4e499d0453b2f86061227d789a2e12302c41a9ae92e13797038b834838195b6a83caa51b0b1b01e3ad6adc1b427c85104106cc8c72fe2530d81262b1a10d671194cbe4d4ee35850f3a1ef0fe4ba28828d1fb1d711d39526acbff62488f2d8b199381d4f0876e8522f75e2af0765fb264d4c0f075bb28f147f672c2b1b978f206c6bc68c3a6d912f2f5aeb0a1ffd8b3efb88e0db8a681637c4cfbc1e9dca1a88818cc7340f840791c3f16a005f72bb56e230e979ad2d02f98668bbfc68a2d533513581badaa40bddae78e6c1d8c801a914f3ee8e6f1b50df09428985c1c7131ef013be69824d47323b6fa5fcce7de48953c8840a3df75e0f456bd02295df0e06077ce8fce02c3e3f6d32f999c0c005f3cdbe4eaf3ef27cade0811701b082cc759aecfbf93df1b7995b55ec28935d0ee88fddfc97fe6e0ba37857c1de17cead4dcf06ea6eeab054323b82bf6a1f92693d660e5bc16bc15759451800ec5937477723cde38ae61cf4abd1d5081abcc3d444bd277cf6a097228064d6a604cabad68a2001ead532de8f3eb8b68399f0bd9667292cbe79ef9b05c05a47a2bb7d7f1004c78d8d9b251daf42d76327df9a3b861aa3abf043d4ac92ac848cde6f5c64a165e66dff1a4815cb22cadf00e1bd2ee6101ac724a4fae00aedb239a68f2c6e542e9c5ff19b692aa2780337a46fedef6725a0c8f794e40bdd3d8f19c52a00e38a92964491d1e14b1b03c662c7b7ded592601e266522477764a28ed921031d90870d021c656f8b056263d61590a9a857eb4503a022b4e65d33ea44382734e1bc744f7644dd1e927eb1f28b0bc9809cb2985c6339f8d290b1409c95a81987a82e0e913702f5180e4439947e95dc00c2e905914a9d4683c0659be4132fb23880a03798990f0160ecb63aa6cba4948d75efdcabb627776c04cab791d8d87bece12ad4c4de88cc0d7097329a64d7d519b99032102ec184f566d05e6b164876c0c38222bc1184b1a60669aafc160a6aabc374ee93e8af970a883fed735f38107088567d3cd7f11e3b9597ab9c29788e83a979805d6abbd0869dbcfeb024aada14e7d9e926476764afde7cf1cc9c6a0b94e12c391c9ac07d3c088e3a06d9cfe30d1fa00c0d59f64219b3479cef65427fbe3e4bd1393702ee89dbecfebe45a6bffe9e2345a251ca78d9bb73041e37fc2059ef9e7a201447be04813877bce610619ee5395a61bc01cc97cb3dcb17855caf000349f33fde426531d0255f8649c9f04c9b2b1c4cbe963a39e40d2f1937a37e0206f67e44d90487cf44bdadce91e4556e8f5ef8f223ddbd1867672abe0ef7874a6eb284e2122ae082389b78345858bfd65ae8fce58fa62149e282238a4b93bf60e81cdbfcf6807e40ce294d0bb121eae8d8d5c34170800e2233b9fc425fa07c690b38532374d8e2a6e1751105153b35f4725cbe08f7431fd8a79607ff75daa688a5153c680b102fbe58d2871e008237b878f7487a0f9e84ae4056954062b4a62b97b276cdc2f015458f5da070e8296893e01d3ed5924fef4ea2ae159737cbabcd7543c75b69ab85fc5038ed611cafcc5910c8264c7873dea5e175282679c8a917e460b8be957952a89fb979ebe743bb767e900c18ea5dda471c195b0e0b71e20d5a2beeac4266fcc05c9507b3331a38ec9c37d6712883493b6609a145da7d25615b8c6443fd7719d7abcc51c1f435056ec8e7f922ecb654d0564b70e3593e72d33b79198fcd724843f71f772a30e82f3a5cf819d499de702397c0e455cea228f0f5484421cdc2a397373fa0c2e2c720abcea74c37c75ebc79e30d50dfa627aea48a539e75b0be5e4dc795dbbec3edafbf2a6fd09176c2187366df72e6ef69031a5ec9d2e80b6f0020a4fecea73d68dc50dd6db417842a50167a77ed78ae862c524791cc4d9ca6a32ad8a80e0396c13cc5a57715e6bd65a8e41b5f18115808e771a397eebbe03988a27947fbc12fa2e83767961d0fcfe12b4698c959b2ea8bd2d0f53bf2ff5453fcae5baefd91e296762a3bee8b6863d3fe2d74441c21c7b19bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
