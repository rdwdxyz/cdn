<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dbab909b12c5ab488fec771706770e6969227a1965ece00b547c8468e9b6cce9339aa21077887d7e07b459598a5185296f1f6e27312cef69ce4665a1da2fef0125bafcf81f1bdd72eb61b02097afd8d659fad7e6665bf1ef4682b354421c2fe47c4158113f9d0b0c66d6b9086fcba74d828c659c1fba1bfdb9e6b2b83c950d93187249fcb722630aa3be69aff4caa1527f4d1143c49145d2c545bd48c04ccccad3b22b2fb01a97f0cccfb03c98cb1d9b6a4fffe5d3643a6db8d4fea0698da62754b625a8dd8473d0827b92d0eb237671029a78bb2f631b3ad3aeb06a7f8a6d8d56e26330195f8cff974368110bc27271ddb5cd49a3323c5485fa3232beb4e52daaff68767886e146457c77e53f672dec3a2f9bdaea0f8169d211bc18db164e43a08dcd1df5da4cf924db2e8229ba6709d13e689a33d9a7bd778e2c7fa152039a1b88d79e7a9587f7dcb7ff171893f41827409d02aa88824903d73ecdb1bac4934c272175d791c1861466b8f646cb7378b296e89d0b168c736cac7040f5066d51e79a22a40914a7e74a0194e0b07e1d6f2dec0b936a9f2d6730d2e8c3fbcc4715af71d7b808de985619c8286d7564216b8df0238f4081afa3c4d338e688e96706f0b46ef6b4930bbe12e3d752c2189229c042abaec6455af1deb02986385e23e90a0a2f7089b66485ecc2c5035cfd8dc1975433a204857f0b100926391a9077e61b995a8c61b9161b7fe1dea40c350c0a7d172348598a0c953e7c30c97389ec702842c1bd0095286df5835f5905d00caf885391018e681ff4270648cfc36c31d514c78176a843ecfa1160a375e09953323ad498703a3a98125eafeae8d1579da54e13a0c81340e6939ae918b94093c7147be87d37fe6edde7dec27f0473df60488ae664f68c63f3dd2a3b214dd21ec24237df791102c16cce3a946964024964f0f648bcf99c967987c162361db87834a4698a5c1e3c0fe1954edbbcb5b3200e384df538eed62a6007ceee5d22c5f3f1d375ff21d9561a1a35fb3181c7925316d3170623e260f37bf3ae2f5ed5b42b0b57481c71b50d4a3d1ba28b9629150834872a1b0daae6b8cb07f1a7072d5b43f44f12c60be47e8d1b1312ad57676ce24483b4dafd1139bf1a0127750841fe8030d5f97c74e769b390368eccd14b84c978ed551205715582071d05b5ed9a243ecdd94751884f6ef331ca36efd0882603c48667e148af73fda74aaaf08913192fcd14cacd3d1b5daa617434ca39711b342be2cd9ed423dee9145aa696071a49bf1d5859456f3ffdc67de74bc0fdc0547e189ebfaeebe20aee1311503ef2ad77d326e7bd981f24717f197ce84fbd3ed3eb888b4e5f2dd2faa256aca80a21edae18406ec38249c57322977c61f67315864121347fe5840349e58c6ee52f606b716036cfba44a6f9db49d3b47da72d718991e3ffd88563e00ef58b76b1533d17811fbd20466032eda600affc30920780404936329acd8e5d0e07f1b7ddcf248193337dc41dff36fb1efaf740c0bbfd8d151ece664207fed5d8563f8be13e2734636f2782964b843dd12c945c2c67e4d2cdb40b7878ea46483cc4623f002df8f8c8fc3458e8803ab9747c439d25070a9f1e30b6a1b602cd69191bfa36c6011a4d18a874d9f23c8be340ddb3a0d0059cb2346db6a2db88685aa53ec3167e56f0dff35ffa4ef99fa89abf113fa72a2640af2d647efee510e9041d808249b849dc9446b7e532766fd323051fceb99cd1812b7b9d22391fdb2e0ac82526fc44674e787e741ae451e718cf1c980b89a6ce0af56d9e6ce8d57eca38fe812d6a1b966f6bf97ae45c28c8ab1a3ebd053f79de6ed4c9272292e34b72556a279c0e71c9498f287f17b11cc863376a65025cc0cf78e12554698ca7de5839a6f7a6d80e09637bf806997328eabbdb19fba7bca038fb790a506723ad9e99e62371db01c914752465acb3c3c2d87cdc37d2470abf6a9c3e0e15896afdd13ec3621af25a73899f7f91694f207a46c58ece77673af89e3f042978f15d51b7c58bf34ad61bf8352ed0f4825e53523020a402fe607a25d89667826754831abe0ea469b5592a2ce4d09b14737c65280f8725d96abe60995f548da091ced7af39554ca1e2d57ac7ce9b2a2a69d71cb8ab957cdfe1927520131f09a6cc4f6b2a449369cf14a65f426e4f2bb387b6f3aaba943412f4879ec5aa0325bcc9f06f488ca2bc2c9a52f547ce76b630fdfec23665f7526a020c3a46c5a0e43fbdf09c7998471b5a653d1a9d371a7978fe9e3792137934410b87286e9c2ed7ab90fabafeafcd0680b70c75a47547d7fd46780f5435dd2683fb576c30999d8dba20be9ee22408236078101c4feb844c6393f932f9eacfb9948be33854ad31e957c572e47c153e13cb43ee1ebd03532e26e0be7c543af35e774d0bc00a23661f95b2a48e67e8cf3376102699035df516b523fc865b262f7e1f8bf005f8fc8439318df645b62c5a32c0f2ebb5c573c754423919c6d883ec634fee3190a5d37379e0950d7d2277858f31a24125c643c4d9277005f6c6cd127c2a32d4513a581e9ebd1f4814b39fdfe12ec2a0509acc00e08677fcf8867ade76c3a4b513b18c3ea56d90847fbff5acc54e74c1bfe3e803b263bfe9bb73a27635bc34b4779c8e8359a9675bddc37027cc4fb3d68143daddff92e39d221663a75553078521bdbd2d225833c2136966906387bb8fc17fc1733599af560e8c8d8ec13b04707c1b74d83804bf86d26524cf6fea5651ca42fc68f45c7ca7fe4a2de3be172d91df6c34f2babe3e65fd1ae4c1a968e0653b6c3608679d3414f451ccf989a95b830272e13131320036e3479eb6dc5169c61dd6b7de2d36ed56560c6a1c6b953a0c6827fac11f5110a91bdf7236a9129feef7fdf40a4682fdf7c24cf8f0eed999a09ce171ec87a8d437f70af0632411acd8537f2825c165a8b04edf9137f1db8906b9b516ef16d10ce2cbf4bffca313f18b86d4c55149dccd5914b3756f984fbd39367810a6a34c2e74b0d255ca644f1a51581f700e8ec774c86d309149ef08cbb738e7a598206570012106915fcb9173bdd9a9f07e981f801fd3aeb2c5048cddbebf0aa6adc340b2400dc601e87249213ff0c044cbb652651cd47a61c81b848fae542aac078a8890caa2ff01ad0e309a5487c1e38e0ac0a91c5db6216fb5f0ffb2332e2baaecea2ba5124bd2f9a5e9d73cfa7e4f46308c533c1aa2cb8914e62cba6ea21c56fa21eadedc2e814804eaa63d3eaf1129d8d65a549f83666700721f18deb3114b1ac6a235324f35bbc1362038e09dbc5e06c8826875add8770a51d75dbf950a0000f94d272d238996558c6f55223389a0346706c64700b07df4a597f43455f06027930833371fbf2a01ce6fe70d728cd3e14979bd269d2ebcbef8b2069f091abd5b5e5c07f30007d206707cab7a6219f35087d81b2c82e2222cae9c603dad727e9a7271891b75084ec171d5f464bce090fdb41063c94bfe6c960f3428a0023b97b3e12acf206c31276ece8e7f81d8317ebc7246f60470f7c4e05b5c4bf21d3bc4e3521e863b01433f36497ae1bfac8b4273d2a385632d21e1814552e89f1a52657870ed8c75e4934450dbaf51e8894e60dd7f08feca8044b963951677eeefe9a59b16bb2e3d37c92e814b884c0e6531e245ed3c58fa647992e3f73962775e50669e220c0e88a6a160e2164c8f42fc0b6b65737f0d18fd808aee44b117711201d6c3e83941da2de85fa06a1c92edebb0e72c5d9dcb6e1d64e63f66d47a26b87b99d969db546ce6a817cd164bd30f83b86a78f89dc17f85daa023c43190f50b989b7aa1d26bf1b78ae8f2fe045ef8ab297b29057f2cf62fad7a044121f47863dee024df6cb9ab4b7740671afc2f2135ff0833777d13cc589626db7be9920f6e0a834fe04f31bfebbae91da367f48d96b8bae317287f3464faf73122d9fa08e7ff06d124776960fc834823401bbd3c4e2daf29998f5cc2826de10468cb10a1154bc20e34de1ffcd21c4529c2f8907d98eb987f5abc3bf2db3b36038d08592e0bd56c423932ed05536324597b07a8445c72d133f9d218a91cb868bff87212210e2edfb670dbfe401d2901393f8e9277980100415295aaf1c866ccafe6836329fc3af3276d77373a294d3625582203cb845918ff38c13bd744853d751c981b96f05c6f9f6bce00d6d5565ad78e74bd1e43b4b142bcf067a161210745d039694f6b9d45c0b21fc55e48ee443147cb4dc5c52fbc0cb1ac166656e6ae50ebd2eda1049cc799503911b236be2b327f04ba4f0c466fa120501fa0b4e2149cd4f743c342968843e63d327585eaab5a85ecb551a2dd9bfc030bb4cf341b0ee82172c674fa797ba0ede1abe2780eb6088e08334d21b2d431214b8258fe1c2629df59936f8b74a124411b49dd38ee6abae766db4cc1693a4d1e6a71cf7a8ca4389a78fe45513d015648251ea0473413075c33534d7982356d46e867d7802ec7334746b6e800cab73f272f87cce023208e131ba7d83cfffbb1e7e3205818c887fd43b53c56c8cc0bd546233c0154f31bb7bee924b68ae03c6853e507a12d2f796c34078918b246db38a6c866813d55225fd50ac1ce0da6dacdee628b770619a09258fd42b2a08921b57f5c464cd756144010e1aed3608bbdbe0d1cb1e2755bf08c008de0005df33e2d7f7a6051519e2e1b612e0f4eb80ae485a8744bd94d71495e5f31423af84b1044c0784be70aa83007fdad4da6db2e1c6d35a596dda3220b894db0405cfc9666f089abb5a746fd982c7806559ae40c1309b7c22557ba7885f906d9e8b8d433e03f99f53cddf250bbfb8dc5cebd7d6a2967ed5bf5925e98fac7bc692e2269c1777ca945160f75167913a7daa62bd8cb491df20a37d73a6d410a2d88ecf4df2ad0b79f389e5ae1d2b575bfa1b7b8ee8f333ec0d6450adad5c625b740c8be08a9cc32962af7ccc125abc80733ed06f7bf48ad7ed3c3b722ac611816d4f3a1eb3aded180fc9e924f66569eab6426486720b4564301195368e2b9d3ec9c21f8cf82f95ee47bb2f9aff59e5af25f04fb3e583ffa3d24bf963dcd055ed121379ac03f5f22bce1bedf5f80436773ec19118bd0265bbeadd6288f53840a70448af59bbf2d72e3db13413a8fbfabcd20ef2d9fc9efa5c28cf408f582db65cf3f5b152a3a4c9ade4d3f2df7d6074e599c6c6497648d8b9d52165a6d91e34eb983849e72555877ee1ea2904332dc95bb2417e40dbca02bdb785af3b4cdf6e4dadc242c5a3489bf26d979e304d2ee3e14c78263cd57b5c334bfda6ac4b9e833682557a094cb2ead7017d9a8b4d3b77abb6866a972f98aaab7f76d2630b946001b0bffb25d49d20f62045b8224716b2dad73a7c885b1f853566395c8fe135aa14b824fd17c6ae1804f070ae43d905406bcf97dae4a09c076c19ae0075ddb84a70528a678f870bd5aaef1f304eb87fa9b76adb41bb85422a8a3d189ac3767eae15f523d659009a929c281f261549fa7034c5e5fe632cf58bd66f35fe5379c83d248a29b7b5041d84398c24cec23c34c1f392c7249898244f0e842677f1ae1da9531b9ed9d8312a37704c1f8366b90db25754dfc3b0ca48d1e1823937e9f2749220303759452d473864a7bd3b9d0a0662c7025920cbfca488f3d206d697e99479fb8a88a352c990a163125e855bc8d586e2f03369325f61227159f14a27633e9080fd37261ddfd2e79fa262bb51998dae85335586eaf5ed20ee3c613c81f8630f27449b2e2017e4f0c6b9d1e2d1d52a443d58151cd01fa9a5e2f8994786f80229dfbad2064354e7f6463e08a66ec9097fcd77d52fa9181aed1585ba8704ff43e548c1d7423c86317b4e90f4a2d010ab8100804bf26aee6f9b106824078e948a1d0b1f4ec82fe007bff94f4dae1458ea5b14e74c2ea7f5b7a9a72b029305a4b12ee6080edd767f3cf89aa9a770318bf4aa7040f4b48ce5372e90b986c9cf74ee7671b72d9f35460491bfc3c050597947cb62c0b4043affa2cfb70fbc1efc19c6df6c2f8bf95388c7937b7301bd427e382ad88e8d83b16b1366cd169dadfb4ee50d8396737acdd13d91ea329087d3840aa55c1b2caaa597560467b0113b54d9d98942f61c3d25f3a026166fed132e094fdc3a869a2ce56c2871ddc7b5f28d553c626ead0b85f1e2497483b1c39e7a53fc43205fd131977e5442d1fe0c5690c245d751f6f86c90239ac7e1c1821ad8ce349a9966cb2bcffbb6137c50bd3a24b774ffe2f2030fbc9cc8441f03123d21e8a8db42741379366a0ff308763e2bc076e8c265e6a31dc3d3f3004208584cb06d56cc24660ffdbc6dbbbffd927c35752416806f353139bb841d4ffabea5839bad9a32a855c65fb44e9694c26b4882af3bc8ddf0f101fcc7fce2bcaef1a5e5fd4dc7323fc3db580f1f2ada061e31686f8fb9af756689eb46a77218b4cf21a4c7033e0f0edee327449eff47a5c7bdaf021d2c3025d170e3aa9a6e4e1fd90ffdc360bab70cdd136a6b077c7d24ce49e56caed973f263c4d4e0de82341d866548cbf2432895a8db79e1d010d0c2aa89cfdb3482c5db3ceb271a80d29136f081497cd1ee35c346ffb94f6c7cfe5363613bd75de406c6db63770ef6b11f083dffd99651883a0c5b54256cb3ec290641eed379b41f57d90293c1cd88b940f3c4e46078e7b47c7d691a5afb39873de5ab452b2ce779850fc5de919930dd4f3f45decd4b68c448ba73ebf630caad8bd5c1ca3680041599d042beae56cc6d101a7b36237d8c118a228998bd4437225164d307afc399a8b37810ff2b978e802c346518e291bc92aa9bfc69a761fc4ff48d64bfd8e29fc011bdffc3906931f3d990c3207e2724e0a2f17614253b8752811889bdc864245c9c88e0047c92ebf51bde29be000acc31b75995e0049cc44eab958dc4cae1f0ce33f47cb403aba7bb940993741e6d439b0e330f6b128c84e46ed5818a17004564feb64ab98ac03e0c7eaac177830700e76347c7e24ce5b7ffd3174b6c67ed482ec8655cdca8ab0a2a29a0654bf977d20a2cdd1b6e0597a384f8522e0e6d906ff10703638e5d7380030cc0aa6def6391bc7fbee81c6dd5ea40374ac1e5129b496687c186093e3fdaa829f1067e98e174aae93ac0078a1e9a09d7f24fe2af51c20ded775ea988a484e146568353a45b0f38194d42aa6c262e84d92b8505215959a3c1f80d8932c02a1c21d2d1b9fc0076113f1cb46a2e224d40d11ed7ce51a7cfb0e21cd08f0e57c356a26b4f2b3bc7b2ac88bcc8fc9876bcc5674676f9d8babe5519061015308f8626a15c380165dc475291ecf821124207034914b84bd4cd492338b5cd2e98e90d9b28a4f4ea73518499961d915d8dbeef2195d7fc165d460df7b42d19fc1f1a3af099833bb3f8602ac06e7d4331be2ab19b355c74981d1083d64154eab78203e0418f0e31c7cbd246b083d6214dba2b2ca2ef15caa69aa85bb9bcbcf8fb4b9b49ef8451d780c19d76c75bd53c4d2ced8c85848c1b0321e31a959f75dd414b947d1a6bfa446bea52c845b3bb47a5f49435fa8aa240c3030d53dfadd4adeacb4ed4a39d9bd3646922ec149b81d4a6259b0fd859a531a1238daad7c4d0ad31e8161a35ec1d2dbf3adfab129f67aa882b69c25752c20377e2a8d2a30ef5251f9fbbc22354e3fe04b2bb9dc1bf587d54b4d6d4806043b553fdcebfb07e389d959b51d6790941f2dc24ca87a6c9c2eb4cb8cb2689d8876e48651977a723a26158920f47b27ce55f6981b998e3fd976eb82b41e8c0d7cce01c1435cd6da401bb152de6004cf51aba1605ead0fe93e1aeecd7aaed607b86c8444fb330f16a0bdae7f94dccdc748cd8b54d5498631cc37e7f580895ddadd41f78d83a7d5d7ac3225376d4a80aca81879e659e5ad543b9bf44f748503695996c11c4053fe370a001b78ba1bb5d615f39c8c606aaee7eae092c070083b9e2a8cee86c23d97e022f8418c6350b9d57a3681d5f72838d67d59ccc6baf173ca790b779e515567abf58c49cad699e2946b1d7853eda38272f12a41760b01ed447d9e012e921eb3a87754ff3b11f4f9c2f7deacea6695fd1a82b31aae940b46e3912ad61df8bd6e847ed7285b625822f0c25138ff2d0cd31651ada776476d22616b4cf5c458b4a228943b20a53f736ee3618859f301fbe4f013302b027cf8fab13a337bf1cd2f5a165793e9bdaab90589d247ed1713de2fe7fe7d92fb666add6a817d69fefb570f5638d522f4415873b2364f698bb36f7fbc46ab821a0fd2d534852c5187a4ed0ea034c55c15c1da9612963e9e55e2b55c18506c88ee3b402b863e3e0832590b76fd2f98d10436aa380014af8d502fa08fbb0b60cb8cd3a4e8a14e9017b9f48499313d10009a5e3ff1bd5608783a2adb136c7e98ca64c918f1b28687d185ec0b711ec615a2432106c080e896db729877f1e1d0689fdd98cb5bb44282a679feaa215495c00e8ae4cd1cf4ed1177bac6beb1897179faa44b68c0ef7dc292cb4e0cb1398caad2fa740b0533aaca0839c6b584435dcadd05b7de149d3c9f2bdafa1a6d8378d423763c132ba80dcb6dfce936a71f78d174d498ecaec7f58bb4672fdbc8cb18134f71fedac6fc522d2c128fb8d1cf5ed557b096cb7385d5c30e548adfa1f7293f67aeca83e4f46a05a6ee7c76fff1c8977f38c3dbca82c1a22c667c6726a56e114ed96fc2aa4fbb215494b9361c0d9b2ae7ef9bd8e5298f9aee5c875622d268f7472fa3982ce0d758a4bc9923da64a60e64bd939d55a7f4dd12b4358776bf43197a2b3a2c1f422eae13dc1f5220b6efa57069ec1d30017d39decf57dee99418a27a6bafd9f7933f3204f6b8cfc738e6ac4f1baf82c02447b1d44c0103d7f6d275e9d2572a23c512ce5c6cf23097ee2456ddf7949c3f83dd24af9bca531d1b0223e88ee320dbef4a3ebfb9108b40a1aae672c46dfd8b7b51f7a11346ca11ea4eb134dea1e4f4c31a4efe144c89fd66d92dfa1953b0c176f7c217d5fc30933ba67654c7fe15b3b3a841ea02a9f313c4b68973260dc4c465c79bb2105a361d67a41e9df24b5f8565cf4549ad32f0a3c0b743fc85926d3537e07c6453e2521b29ee2c95293dc7e36c36f93a9de0390d342070d724aba9b290fe397f922a273fbb4a9007f472d94030d6aa220190ffd686671f86bad14dc515f6319659d9a3276d39b8537dc76531de969b4c786ed8baabc054e1ed1a7204897392569070b5514c4b6e5f827753371515433afce8d169cc1a92a0c228481e1cd678f32a87612a754cf226fe48465f34fe30c4abda0343d96429b13480438f6fe9d417c25cf92edea9c605ac506fff834b18a695c8559f90ca28f8bb2f9a67ba432933982604e81b9c2cf22266faeaa3cf35c92884f6a49165c2c6cfdfff84601944009c5d65b17e6195865b011f334705e65a1c43855aaaa86bacc788495c66a29f400778946ea068f05836cc3a18b8cb94507841e761f374766aaece184d5218a09299ebba94486d995a4d94b575c4fc51492ab1025b187165dcb1ac7f197cd65707f7e8543ec919d557c7ffbe768995b6d92e36fe06ff36efa604fda7d67cd0e055e611bdcee3b9a820564fa045380ce3643f05c5ccf796fafa6430f4b880bc4ab8f39167d195f1ea290ea4fa30ceade85d6bb096d4c4da39d4e26cfec1fb5d78ffbddd52fa057c55732e7ef0571e7caa986e9ce8b7270fbdcb7cb5164b2c7310c45d6caca467802b0142e5ad41e21854544d1adcd1b68548bb9a18563eeab4d4f7976100718c1e614a5adacd38fa42efd4340942c0bb54d49f49b3b992dcfab10c9642a669af808b4c6b4124309ce6515f2e20db0b5f3c95ab60bf9930fd8a5757c213ebea4e165ccad55497f0d8c816725a94b63d20480e109d4dbca1f85154ee6ff2b048bb2849722bee83650219a0d9b4f13a81f42157f849f8c49fd7631a8fcde0c0ab6eead63c5c6d76373ca5076fae1a06d6116332e869e6e40b007f31071fafec240501a211923d1df1ec7aba054617251f880acb41e4215d312e3beadf5c50f86e8ec5bb34b06646b73101b415664dfc243da5881fb902df026af221cac34f26cb4343f585aacd6ad80d544cf41805c2ab73cdde57f99c39f51f85fca527b85b2702b9153b7e7bc40d69138d74eed2ffae05ed0ff303e6b2ba32cfb0dc6be7dae4596f08fa67619858a8e1979127bc8f3b16305b0e10870bf8d67d928279006486a3c4bee22be3cc5e37c2b047188db6cb7d8dda7bd22424a89e78211dcd4dc32323fb9e8c4ead5b8c71bd31dd09d26ee701f3ef519232b5b4393afcb1ce9dede2326da8285295e2c9085ad86535b26748a16324a5972b9b6c9a38e77eb25199785a84557f77c89a017083d771590fa520cbb6ce0b5d3fe907eb61be279ba6530008101453fe6333c6bfda53fda34b31252c0888920d9d6ac8092a7d83ba698a23b58908a219bf17750842baf59f45fab5aaf390181b80983f6340f1e43caf559fdf89dfb48aa6b7d61e3a28a3fa151383902dacc6930c8d2b064e1c617f5defc9fec4016d8285995ceca2c57e77ad43f4e915a5b087a5c0cdce5c7bb19bbb2972d39541fc6e31e0b5fe08dc474cb003e0b693716217b5f93d89c83b6613771cc067baa1ef113d28f55ce54d4fb4a474bdb9d7732c2d4ae81832e46a3f413c5d7624608c76404aa35b5679458963d6a3e614be2949ef7908741251f83405f825614008cc4a9914523f853014ffdfce0243d2f8b36b959febc35fbf92324ef07a8e758210839103d235913a817ae00b2bfb1865d4c78eaffb0f6869be68389a82cd3fc8a06ec85032781dc2007bf277b662262e14b7bfe56c7292491b66bbe234c9e3d366ff87522fd0f5cbcb772815b4447eafc75d79662374460fefac4928b072ff79156a11a6969faf297fcf79768f821033b4f02291b1f930aba42360cdcb11020d3ff0cbe38f71583f8b9fd07909e971ff22638a71b5bf9fbf7536d25aaa7be9205eab616f81ded9fd3d0551346c2ce2dcf6efdfcb3b4f8a6a1a1d31fddb5fc7ee0fdf94e195be43ef51686e7d64fbe79ab2413ea222a6881c9d487c6120da851295b15742df4131a0b7178d0fb8e1ba2933610db4b5e70ea28f40992e01f4f750387d3f394bb2505fd3ae563760a205a9800bc427e1e8c1b29f0604c966f28b667d24d4b744b24b959c25863e51c4e787015701564b51de83ec0258a1c5f2b7adc9481c19502ba91d1b15c2e385d697889b545e950c43080a8ae9eef4b2ebeb347e391f100cc52cb053581af408542c474d9cdcd61da71470cb5646862c6abd6461ae8ac67710c1c3b3f73cce4805bcfe6c57188c16c9ef2ccd31a8033c08265b0934522d8bb7fcf80f01ad8a1adf277b3daeaf1e26654f6b7d228eaa8e72e5bf0d17cebfda1a777a51a8fd6d4c936f19ad08b742efef77579c8c303d762b49d2a5703a1bc39a5902cf0dd2cfeb0d9f2ad98d02261baf3551fb930d97006264b6b4028d653ae44a47081fb9549e14d1b95d9ebd61806c1c32948948af5e2af0d7e21aa119e705682f0daae3d90fb826e531475532b92982af7e70802a9ec2190909bebd45548fc1b997bf7b2f28b44a47220a5aea89de7b01f0be464dd8ebe981bee6153b9af38eb4412a70cb798179162af9374b00cb6b0a79009feaa66e58c7869c5cd1e42d99cef56b29271bd1ef28e9d510f42a093133ca20a96b6b49d6ad02f0f92340388b8a53b76079dc1bf5a8473a3a4872e65e0e4aaf9ca7e522801d248beaf13fa1ae546a9096559f4498ce992a15a4e4d4b7e2932fc4df88b91fe63c91f8339d92a03f38acbe417b25d9be530b49143ae74bbb4850c35fb72e8d3e8295e1664785a3c9c087dd339102485e9798b7093c20c73aa2e972e2a1a1d7d4a0bd4b56ed438b5d8b3f2597bb3aa8393bf250c49dc82b64c53c9f7d95e00fa2ff0f20ad3ef9df62977c6f8bb14d83a029ca7ba6ede5a81e28697e8266d285c6f1d6edffd224396f7d79a94aac5055768cfe39f26dfac798c59c04095ea874feaf67686ea7848d5b0f1356d95593a61c1ae1402967d07f3a518c3ff78592c110fe624aead47ba734558a5c6a42a29a84f23facc3fa65084cd66cb25866ba6ccebc14ea44bbcf07bb511d056447bc304fef7013eb8274b236706f2a5f1ccbb09f2273148aa138a857695e82e5854f3e3cd3e9c7d71792df8ef84573c75e993e82b7c0f2791913a1d20aa29c68b7f587d4825022b97199969ecf15e35da3e24571aed31420a93bbfa9c0161193312832140a4fbae6f4689c4bf326bde8241030382b654348b0eb34f8c5982a2544893ab8e22e0506dac6882c394d7d0e7cede9e3ff69d9504d7eaa7ee6b54789c305c3f7c48d3b0fb47f98fe349b205077d2ceb7ebddfea8b6f432439c7b8d12dade1a89bf0a4a2c9d70ade68a1538fdf90e77f757932c535be81cec4e1908a956cad2bfc638217c2270794539a296a1690fad846507f0d18a6deadca10848458e5ba9028f6ca4a7524eee569df38e2307e8936ea77db0d0731e2e690edf4dab783ff36132446125f745ccb1bc5c468ba89f2f0267622cd15ff16b673e95cb368c9f063dfe229c5f5588ab7137ddd824e708f9b4be7c32beeb726a45b5661c17ebec4acdd5a4df079d999e92652162acb26f8b02f7c3415fd49ee7a9e054f83ba1c0e9b55060a5ca287abf1e6dd4dbe021c3433c330fa2ebac01b3ec2e8c33f4387cdd36578dd99e0438af1e3814d9a8b37a60775a283ea99b309caa715e8485578476f820c923c5460eb20e3875041232871286120624bcea0e484b7386a2feb2769029a3cd43675a35cdadc9b50c164800551f2a9620370caa5f264a0cb794703b7dda174e99b356533458bd5519c82aaac639331213d69c582b8091421e137f9d27d7bbca2e353e56f53f019e58ad80887b3455dfc53e326a7b41f7a3131e0b8b99a162d621277f5533c799acdb95b1866cab98890393b54613ef7046c99c67b83583a7bbabae38635823d8ee552227a604f86031a60eb84f11e4ad87796cbc2ccaddb459c71a85a8be411b6b0e9728c28fc2211b095a68e4dbda28d639eb478911104fbfd989cd6c73415b6c45cc79e4dd86ca5b7c578303fd433da827b36c6bdfe15e24d6fb809c36e8c328d4456d5630a355482a4fe07cbb9d1106f97f0dbbe8c92695f52c8763e1d0269efa3338c32d71295f2ae50933821f1d665e80f59d3db41efb98884f16f6ef5779e6867f5235543aa0fadf9ec36895d5c3d45ea8db79644326d05d6ae6be6804a2fbc1b7e502a055113abcc1371ae38c327f18e58eab3a23459c78838e7b646c68537e25c2e69da0db549ef3754f4e7040351dc10b20001a64275b3c5c7864e85150c531816271abfc4183e51d24b5f5571fd540a0d0c603019c420fb904bcf77bfc3a0fca059f631019bafe1adc0ddcce3065f7ca983cf65c7d914520175e2892636062180aaab41f0d831be8c50cfe3006df88d2d4af5910b93daa6075070756cedc96253b3d0241e0973c3f2258c538243c6203300b16e26cf63c308241265eeb991ec030103f842cbc4a5eae247c20f03ca71f75bdf05f4ad25dcdd38bbbcd995779ffeda5df2c19cdd0731231371950624ce8ccbf7c2370d5c52ae538428d96c0f43c3230bd0d074adb31826d5d2446dbeaa4df065bb43223b041d1192028a1407f1d9267faee3bd5961694ff642788b0e3eefe3b4e75a152c806f14fd210ef0fe05aff5e056e46992d1d3fab9c480a431ab1639ab60e1b41c85f5643b991d624aea2016815d4efb09e48a7d479f1d17f2d2535263d18bd05977038b3a5c588f1bf743a2c1cefbb548805d025457650efe6786bb99151490607e9d4bdf0959bcf046996b59115c9d091fa137cdcb547b666fcb8d37c8b88207c4776115b68ad2ba0df2b297f0f9ee2137328cc75b3d2c2b15ad9297aea3bf322221708e20493187f50c41c196197575f5fd5d8bb740cbf5eae6ab99078ac1ba71f49c2b1449d6cc2753c8da92966a7642c5fdea8d6801af01889caabae980fa91cf8df32d64167868ba79a1ae78d7e06cc23b71bc17d5654be044ffef26372e5c6a14e4438455471e3cef15b0e9bd3c08e8a62b7df4c7f742aac62dba3f4ddf4e9175e7ea86482725277a3633f70fb4a02cb426af10fc899f1740cb9c0cc75864287e7287152f3bd73d5058027d9e2108acc9766ad3d5fbbd659721bffad745f1072acf8ce9ce6a4a1d493f24c02a5aa75bda741174672c3225df28c2adbc10eae042132ea2b8d04ba4a3af9883d37a737702602b4922fdc1ab7c596e76c26b82f3b7968dac97a424dfcd93d1b679dd3c4121ff98b55a8b1be355d28bc11ed89369e42a799dd2cdc214f157b315f33c3e6a64d20fa88a2733990ead9f5f8a99a1695cd4e81f87f70b800828e96d8e5edd8cfb0b43fd921bdf52f2e238f98be3171c20f8e761e2265ffb2f70a2829db65175779cbb494d9d52aa2041d83de33af89878bc3d7de5229a286a9f5013df0bfb9c43c82ea8f74ece3df98029c276b18001a5a4c1d41007e3134ce1113ca8b732ac88ddb525ab80947de7845fd2dfb351921edbb42122644bb65399797352a2b8346e6121d68a0c3a76fbf1a6c2b0cb27125ffeb8b6d35a352b1f490cd03397912d9bc982a59fa4ec72455be4049000728bf10f545c66f0bcc27b83cd7be40509d177f764a6d23f7df2bdecac77362561a45c68710e25c2f9c8b2c863dea9aeed13022558847fa6153aa6a7dcb1fadf6b973fdcb00f8b31e08062fb88012285a4376d2b252c338f6c8f36b1a13ddd8280f13a514484f496d2e722a9a417dc81066b8044057d4fcf70f428ff228daf449c035ad90ad52834b0e946d1eb1b58f021cd08a29224b94920f2331c9a4cedf95a75db930d14c8b19f80ff3cbbff9a940091a7e3111a1101f121112482c6173cd8c045572085091cc8be484da59136086e687a173aabd3d1aab3686cf566f835c8e047b4d2fd6a76d634fa3cb5540f9fb9da5eb9c9792449de7269cd59eab967f04e809aad4e60f36ad8d5230056f8a2864b78ee11495300a0074df1994df738ac9f9cc4bdaa2445acc73d2684eab6cb6404f428ef2812c25e98315091ef6324d7820db2766999ca94311d8a13de0c126f71cc53bb8c293d8e3ec26ea604a4006a2a3fe1ccf78cc0d2261d4b65267b414a495ccabbfe7f933f4c1dc56f6257d937bd274a3d2cb17b961782a041435081d153727227ef8a57f415ac5144abdaa8fd04b3ec270eccff5e8886b7bc09e1bf39da5f06e81753af1bda92327b796a3533781320ac5ece31dc32fbe56b31d07484378a5aa95f0c43935fe236ab9db1deccf21dbca07e489d8c80633c871e7ef18ed088738b4863e032c7bd4d003ef3af62531a89880e40244706d3291239a38a5c604055e4913b633661ef086a77599dd4529e9c6662bfeb1639b776a8ee3f745cb1a85d6d97f3aba6a1e31f5adef9bb03eb10b602da837ddecb39499c5dc3098dede762ae0406aa07d04abe9898e29e6dd003fe603acc993508bbff16d22db53e656b07b047a3edead1d384cb28c3a743909d4a6ceb7bf961b854085101d968a3df1289c89d2015f59d6cfab525ac82429f7aa43fc41fb641ddce58fb4434bac03303be85a719f8dda929c46dadf06972512555acce726e3e0f8ea61a78d1901b2d83b0f83ce70e0a400486a7f749e7a0a32a9e73ba0d232636beec1aaf5ec51bca73fb12c3a4674a1412835bad4739fd04d8b7d8255bd80c4d362d95c8aa265e69ae1800f16a833d6c1ec5dd149e7b2c414a61b5c68c82212cef4447936fe68703e37ebceb03474ac3ca17158beabc5f4a76fa8aeddf2e22af93b187490c6f8c485050d58dd66a3776f2e9bc90601a64368828ae9b7c51d146360bc6dbb6bf78b6d7d5161726a999e38100eb836d7fce8c04d807d753d64299d4b0456e982d38a401e98126a52aa1d3ebc14655aff35cf88f7b50da49a21cfdfabc40fbec6ea53bd147ee34bae8a8dfe6f4b0a2e3cee5c571ffe861bb4ed0d02c5274d3d51d319926472a1394bca93946f0e8a00fe8b72088f1b3fc64a8ecaa01a54f3d7dc992452daffc0ee0ada2e8a8ea1920e5ab8a7dd160a3cfe4ab29d23629d451fa823187c7906a7b67d90d41d0b58b8806523ada84f6a5c683aee91f965d6d78e74bc123b210eaf53ab033fdcaaf8ab7bf841b8d1a6a4fdea9862f6300af2134dcf5f3eb010f62bd0ea9168ce19a47337d0d4b413fd2d23b4420d2d962386135fb69d07a94ca761aa226c14c9bfed50270e2f6146407da46be476f82635c4e634c0df43d137bec3216af8fa5c704c4b9a45ec1966fb78c8c938d0b149d8d9f31923cfe593cf1057ca4c46ba2eed1aa4caf18fe3f1b53cc092b751fcb194c74cf78fad595485cc443e83b47e09ecbd6fb1fbd5ab6276a5795dc034b90b6bf86430029732752c3ddfbbbbc1ec33424e91585bddeac02f38e99c378f24d0cce830cf2d06a1af6ca685e5f4bfa14d1071f7daa21d55b589cdbed02729b50a09f7c8c9fa9cbf8c19407186c26915f6441862712781197bdbb64ab207eab6de4923a67f96c8d5715798a5a9ea6406c00eb23cb9e68c41369922776cec60acb4c1d4f077a8e7f111d467e165cb70b4c7527d7b00a7e42047f717917aaa8cecbaacfc6cc3b446732c3c3796ed8bc70d92a536649e25c4216039f4d7c49f3de3467f5d3b20ebb1802b74adabaa3dbf2d9c8acc6721ccf1d59b55cbe9034e5f615d642efaf90410c6e0b8ff74fc905378b81ff8883de80a01c5ab5b3fe6140ea4d34c9e797a60969ed47ff78c9c267bccced8b9b55551800c29c3208886efbb1518b0b247a405e3e19a558fcb4a8278b1d15d0e3684d5508bc34a24ad0efac64137aee50da4cb521e371750adffeb335cc172d85e41b1ec9f5ee9a027d284e83a79fb0409aa1ba836f0f37b40d833bcc3cc8967202d10c5888daa70fb739cf926fd7869a407b7491788e0386666938fb819553343f51d0f1fc343f568d763b7cabcaf472683757e4c59c5a05532f6786f97c3be0a49086e44252ba9f59d1f28eefebacdb24ad69064b3ef5dbca54da2f2e1c3e50019c4072aa7a6a922ccc594ecf06c0983f23b548184aba11cbead6bd27678388f0482eeac0773732559ade136b0b78f75e392380d5e09b9c9481e133f75a014f42a7061562b22547f29d1301a22ffd95b7b91d504eafe66c70361cc61f21105d49e55838c77932737acc319de96f305ec0c189b14c2762864d087e8728bc3a6210e556c6290e388c6a85378bcc157a2b8cf00506a7da869ac8bb544290d0275d2f39ad5e20bf154f88ab9013405f72b29b3d33a55c97aa1aee672ea2d519708e041514ba0351fd1cc81d77a27771cb1bfd7ac3fb70b041becc7ca91035ad754b8466490fce7244b287e8c7145b5d58a25aaf265b12a633c0739ad1d2bb1af230c3f2aaeefd967597c8a77d3884d8c86a44285134a9eab70000fc965f01fa1fe8ffe0bd115456b104f072809321002ceff94d54896d671d25ce3e261a9184ad11df339b74e40d214ccd1f6bfe386ca07a95657e0213b0d0cc278ad5654abb17109dcc550931f2aacf3c1c9df0102ffa897d3a880b1b42079c66772c9ab3d93be469d60c2249ecdfbfdd47820814022a6017f1c9990ed6e36235c615d875674d1c72c9079a0769791388bd9dba8ab5e0653d516a9b94721ee03fd2fa0f58ef0078f581ed7b28afefa74249d39fc4c258fa45c72bdddc25fadab05042429199c0182accf3232093c91b6a210db1eb393baaf6995caab3982ee714cc961c7dda16884a651be742c5e1f3df5dcea3086dce4928b47d61cd172ec1bf1be0bd3c8901bf7532b5678913bd0eb68a54abaa6cc85bb07047ff3a07c58513b169acdcf5bcb94e0fe0d7337461c0d133113e6d551b196d1f6715d25490041c10a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
