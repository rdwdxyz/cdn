<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fdd7ed228d217dba9d2d67d3a89609dfa99f2319b3ddcddb35117cf490b70502d5dfd965ad91928eac2a8177b726d1480b9ac554fbf0d780daa4d4110f553ac3cd94deb6accf43e50abff057b1dcf99301fdf7663a75bebe730b29a199f7013ba76deedac128864cd709b7c947a6000e55254afcd330eb956d01b9988a87ac8feba9179cde83481db92389fbb8e3dfb966b6cc7c8d04f6394d4619fd7117e93fcdd901d744a9b6cadb8269d45e36fd3823ccdf23980044df1f6ca643e8fb13410dc2a956c0490dbd76e9fef809444ae581f8f8d3ae21ea66cfa7d28424093421e7bb15372b6571d8094df0fe25bc8fd264452b40900c31af8a173af304ee2b3604c3f556835d56af3c2c3cf1fdb737f9874442534108f8db8edf8f38155d75a792bd2a7243a0088d93d72245d74c16d69078b67d7d30d5d79ed171f5ec933445a894749082c3e8be87e195541053e3097d0b97f1a3fdfd880cddc14f566f9042f03503b083bc918d1971a4876b0ffb2f04144d98dab13a96febbda24e9749ac846c2e0ec4e06edf2d43cbe1b7e464642f1666a51a79c6129401b7d37282a09c42d490c37a36d7047e65bd94a9d2e27bef700a00ef356c2b02675e042e658f953cd053c770c2e2c6ba8ba5c0e98a6c8e53e3b4bde0e42bcae9de47f08c6325b3d273ae043139193b7765e6c91f2ca57e50b065dc9f28cfe0f40b665f80e499626f2b6ec8a00ebc5b22c785e8d7a2fb6c6da225a51a6a7fbab8bca46d5e2f6984e74bffc3d4b41e15c86cf48e42f41531d98c3677e65d396491d0fcff5577e1e446d3f0c02ff5bf6628b8e92d471b83c1b583668faaaffb2a0e1461b69a40a01bae125594c73e1dd3bdf8cb5e6b1b554edfda1ecf7fc1dde3cf19357695f023fb47431610c617b88e0841ecb0d6ca9b081c20714140a85b6642508d27ff55de9670e3dbf56a3ec538b873cdf643348358473d61a43c1c9551381e803c7e94889c2d22b067d169376f2bb3f565e35fccf388adc0b2f104ef7b3a2a11c2efddb767644cbca834e7da526ff5ce752a4a088f7717e8f4ad9efa7d60bff4ef53a9235fc1ece15f700f15e2a84df73543dd3bb0b11751c4b7d068414e2a9dff20cf1c4415a7d6369af9b66f08a3524e9c1a1b7f5c094bf331563b727b6964d1868299818f4dab9442bc2142936e2a49d3403d93d79b77660a7679b67612981b5f0928d79fd50572d2251d97efd8011d5ec5abf0385156f163c67a7ee3086e87616fadb1d0e1666aca480ce7580366342e3b034619e45a294bc5bf79f1510575909e7a045ead7f003e3ac8efa83c1515f65a7ee6b1392414b13909cfd79d846bfd3657e83538a2189eef8e7424e3e5a7bc0eb44e11dfb0e3815a8a07f095f952d9f02a52fba59727aaa6218bbc7ccb2c1873b4fbfb5513f3d25e18e3949addb2e178b95fc7d3be045d7bccb4073a03a77e96c773b42865cceead34f5c7591c0f0980767af7fc5239e49a90660932573921e2f83803be27e53f592befb379b3c5689f4f27b29217103ff2c81e7580abf02e76e2bab09c46dd67d942d55baa785656a67f2d3a2d594132dd7ae9b0eba69b75d1c95df7915ed358ea34bf29d479b054dbc6278ddb45b28ceefcdb3766a8333ecfd100cec2a65b05ccf5d4e0339b321978ad8ca51c8ed2ae1d963462cac04d9ec7358c95880dff7869653eb5e1a9cd1578cef2b00eae7904bf9acc30e8f186597220cef5414d5e59c926c5c42a0eba11e3c3778fb371b49e89729d0c65fe3fe1a14cb1fcde12dac1511e0f4c79bae57481920ac459d2f7a3c0b2bf6a34b93418fd76e5f9de3a371f1a8787b52aa55b1bdaccdf782bf1b715707a2594d9f29fe0611e82dfee69bae54f37439248815d3af68396d5f9b26626beb8749d561392437f43fc2f84840aa76fe32c3b2ca6a21c392dbcf739c6d54551d1e44ce0c4810c119dd0fdd7e150906c75bdfd1d666d9b7eafda790b92fa4dd2147e786232ea019c5cfa2eb5db34d5dc75f4cd3edde32567e99e258dd2c657c3c7c239b7d87eee9ec5f5079105d23c8b2c623c3967028ae65d65be3c9775d674e255050700b83338ab818f859d031ea22f2058a308dc3ede2a4e3dc39d8c8718a645f471f100224b8559021300399703f2f1f536eca808f64f8867d952028a52e60039309f5536a3ca30e0e228864dc9f9ade03459f6009bff14f5b3d1dcab8549014bc563b98b6d475ba788e8aff0869230e66c7d4c87a3f989ec0013724357fb9c508d6ed8e4f5c017a7920256a29453d5e9dae8b2c272d1308483794d6e176e592c140ec897624e92eca1c21734f658e62db151de9e80f272408dc26bf15dd7356d75cca67062f218453fafec35c7ebc4f8ff3e1c970c1bf0b43a53abbb1e3549e1cd34619fc0cb87cced12e94f4bc5ec1c2ed57445ad916321785b6fb09ba8c27972bc45e5f9114b3d62ca8b7e83bcd75aa7a7a9131a5df4730a2984a92ae292ef37e82c85479691037e788d8de8b9cbac000396da1a0097445fec714a4fab30d688b5ab45d41a1fa52b043198a1e8e2aa22a45b8f09fcb0499f11c073578188a8f63b12129f1803cdf2da9f2558ce705cba22dd9443e0708755f4a46a9c75a7373017e2e8d1dcff99fce67fab3c06daf98758b02b9b20acc550abcc288b98f313c6238316a588672d9c242ce2c9ef98c0aeca98122ccd2879bf9c1982ba8ec0827f7ed945740a2f632048a72e78621b95acb52caf7fa84b42f607c901facaac744d277559a50abbeb5f4a1cbf0eec6d7ed75bd7e70c852a867931340babe02a96fed66ecd8e912ef3ec2dbbb5059b1fa1ffe49f0d80e0b962ac4613268dbca7128444ae53c933c2775b25ef194c2fefca15d8ef3100118467ca7281a68bf6f122ad44c46e30a4179160b7097d81444c30b52988c7263d5f0f72da55be9d8fd448a262cb2c158311ee837e37b2ad55f5477e56c39f82793a1637917cc9a14f5e329c0bd998ec285cadde1d7614787cc900d96d8587b16bd9158da4a128feed3ce9e8f20b7c60ebf73703257a0a512ddc3c5638cf7f6e6d33424bfa648f4a256de0f3e78a727e525a1cf8a0804341409a1712a8e33ef12d16118f55daa886dbbaa2090762e71f65e15be87cc5c533bb5563fd774441f22a76e7f24f23d4e47aa55996aa9d8e457d14cc502da4835a7c23781ebe98652870907e0e3d381834aa3cf3f3f14d6e0954e37075856949e496b2da99796e9a1c896ddb41a142e0ee43d89922587d1d7a24dd8eea178965882bdcf2ee27c1ce63177f71d4f63889ae0b9fef6c13727ed64e62e0dce3d3a40fad7ee1762ca9c68f3985fea8c6856603e213a9e2a50aacdc4dea32790eab80d4dad3afadf73eb57af4b22aa52dbd6fba4abe717ccc6826068a37069fc59c0dab58cb58924767b184e2674c106f01498061934bbe1f9ccd2ac8d4afa97d7fbf9166e1df135a7ee89905adb005abe3eaa5cd09528b619e20b9794b8ffda44f2f347b85ee589b85eef7e2d756cbd34749088a6cb51dc983d04c7b258a1a22d015dd7202572176609b65bf9f1814b2ac0b34e76ecd7f3e6d7acc57bf680c0ad31d1e7fb197913e998686c19398a32eece2269fabf2029fdf6c8c18a94ea10f5ae01995b719fc0ef6de24963402f197898a770358af62c8d2c658cbbe721ef1664495235e73eecbf62af23aeb01b9ee1461e78b75ab5782a8021fa3d6432315165038afaab563a6d01cf4ade548ecebafd32673eaf646612276bac2699b9a7ab1cdc13f7d1d1a3b14230e41aca0dc9981b6a037e84867c61d56deeea4f89aebb5b193e78956d20a08c2e0bd2a90a961bee16a2ef48d64a0a1af552f2578c6d248a7150aec565260d16306cd79b0cbb290b9730497133d702ac0aae3a34a5b64a07e1e4c6b4d55ecac5c2c09bfbb745ba226eba36ca4c4c1ba844824df0646bad410b854d2a2f0fd261703827f23946edf7ce72e208977f29bd9c95dcfa8616cbf6dbd6ee2df02a6b1689a994d010458536845ca1050d47add6081f43d53c59f2f29832f619ca92f3cc5cec9eb09824617265ccce4a5821004f10be680bfa301f4ba7c303a170c860bc7fe88cb7b12c8dae34887e2ee000ddf747e53c61614c6d3c8102bb673fc80b89a1d61ccca521806c622b804869bbd05168e2387dc467f8ca1d9cf96e9d56323b6fd6f0759c6787d7886633bb3c4e5493e7890499927e8c6343538c3283aa78d7e2919d47ba9eb3f12802d124e19d92b761b57f28532a0ac70919af45412f28d1462b0a3d4743253a48e3ed03402881b0eb05ae16a7bace9ef2f79078970583198a8fe41176e4a2c5651d3e97b48f19833dc380582a94b7dcb8d9ab7e0e3d9354b8d4713b6bfa1f842bef3dd221c2ab720698dd82f1c4971cc23000c8ab66e05ad02a9904c942b4e58c998c6252a3b2998aaba97f61b76e56b337c0effd40b654caf1d743a1c6efb4bbf1274a8873389505b03f60a0d329266490d3f385ff07698d911a4705e5911860c1ed775c82fcbc1e21e1100cc06e631f776b2644efadb6333bb8f6cb01c06b897adef55e720c163c5ab3e230a681370b287c599161b30fca48f7f5847bcd41abf8c9158d1748b982db5a712b2ee26d8843333ac9fc58dcc85f51efb74dd8537c04c3b0a2caf5eb8e8a9272f97a71f968e8b8512b9e3fa95625e86431ba590833073da785663c9214d427ce66397631872cdc1ad7569769b70d0c1bfdad4d30cc2743632905ab831239c76e38b996eb73014f7231451b3ddd92bfc87e479844968b0dd228e37455fcbde90b497e2d9652e166a797bfec2ee52c229b74983eca959ceb6e24f687f664d1e1d0083a8323b678dd53df712514bf74a5dd7e6b3868271a53f7c11e8a6dde926754410da15c052f29128eb169467171901f68c747d8b01d4abbaa1144db833d9cbe3f60c32781eed0fa1f9d73d0457ff3c72cd613eb9522ba2e8b2d5289b25f5583745aa89fdda21ea5642ebd4075a204a5d3c68c1e4b94cf7cdd5a685c6badc5087eb2e5b6a8132d939860c9b9ca0bd014fd121ae8fb03d319f3e1a75183cc040656ffa8602f49358660f255cbb360ed666f0e4d0dfbbe1007e1e51ae53b5dc89c868c1e3690396e1f55420b42d342ada866456f192fcfbd7e90e67c93fd49381b720673113f719f4f9cd6b994f5a43d749122542907d9689e9d277d961ff7a449e5533a26be7452cea79720b63bc08c51cd8538f4ec59837b242f3b68e0882182acefe47840bbf8f4cde93115dc7583159e73f81bc3f34229011d8bad5131ffd2ffc7ef599f29634dcd0eae454727f4275a481e9ce58f9bb6c0156faeb9051808825184020bd5e7b31aeef3fa41ad7464f2ebd58a6cca9ec8e83e24b47a43c7f3c5e5b28815542aa1455a3c5210fc60b115499a431d84fffb10f4ba9487b1c56fe5c772c052b52ca3522498a8a1a521881bcaf54e52ea78d9b6359fbdd21c605dadcfb7e86a09e297e284de4ea23d31489fb32e2852fcae97e9feb22d41aa6de7a6938da6a5e52a0a94768e7ca6eb097916e4104a5bb280c2c556c313480574dc62fc9696e2b542b921060aea2e833ea8d1122efc28b40de59e27c66054e886fadadce8f23cb368e52cf2f1f6a76476953252c986b55b37ae7365164eeec5d9c128404218aecbd90f5d00794b4ea874377285c495ff629ec3d4ccae4e9da13bcd81737ee082e6282403e6d8d98304a4ac596a2a94ffddbddabb09ab0da155d14d5825828025a039b979cc534b561befeb3ff374d7bdfb1dd68969e99192c0eb5e902c55ec0938f0efcdb4513bf71d23d3c13699d3526f62323dfaa6c3ae740437e18b97071f30edd32cb0824a0a9a17d6341e5a5a4b671eb37672170a76a2101aaf758e17769c0036100f462708189b58aa9a6de16ebb1076457cf4a572955a5f5c674c324df6bfc63e573536e2dd18870154fc569cc8bbf8bbba4f2dc5feb8a28bf16ae0fd2048c06083a90371dd59cc51f0f89c250e4a38d29f6039e22a465b18b7a5757cb16667b789c01860202e43de352e8497bcf4793de64bbd21edb94403e49b87a89898a821a27a16d3dfddd3febf9ec0c34b3e917892d79b09d0b5fcd9e8ea87691f8c448181d3d3380951f76b813e39e6a5864ec2b9db9bab847996db9bef68f0ea417b97349f6cb255c61965bf6991187bb0a41e175ae0b40fe579ee8633ea8d97396323c5815a35b0a0ba5181617cedaa884247f354523709de234ccd20411ebd1289c89c3eef21d9903a447c29d4f640674a7add9187f1d80cb2b1f8b6c9c3aab401be3226612d0221811796bc007d8fd8cbd5c470e5f071666269ec84faf7a7ff3ed9553957cb7cbf79610ab59a1efb82d4792ad75d9db2d5220ba0deb29b23d18f5da0a937a4b64462799795b60858a5342624f1893e406bbb5772a2723f3ccd1386b151a773e8de9b8e8a764ff92efa428720bb601db479dc3b198d953edfae285914b6eb5ed9d1c4afbe57a15a3e84ff9793f6caac216cb9c5008f490a1c0b84e61c05b789fa879adc2abc57b3fb2659f47b3f4511e87783a88aabce3cf19ae4ace1da727b3f1a6fdb74dae3067d31a19cb1856e9f554493478fc03773932de8b6675819725ee41583298fda807b5c9cd92e75ae17eb2ed9e64fd16f4ae15d672b5af88fc792eec6cefd12726c524e793c55efff79e6b5cd13e46e7cfa8f6a82d6064354be7612e2a505eff98a13bd8792b12147a9cf110da4b8bc88345501ae3eec277dec6a8be4163c8cfd7e7912c1518f1fac906120abecf84598552742175bd2f17be5778c9a933546efc7331e525f19b413eee1413fa93b05607f871d5685f8927b9e061c485f050c466e4e4e82ca54304282d7b8d0a16af15a58379d86d29d64b89c745cddcd34900b73abce3818731ffbecf16eb9e3c7b02d186f0062ea00e851cb04bd24efde515936d18e98a1929bc9c35e231e1f00f73966959c2a88dacaa5b6927a81fbf9298a6b86e8f7bc4bd59c05ca8cd036c615ea6c79640dcc59459c67cd59187cb0ab180dab3040962dff41fe61d7c903caba8c8ed0ed191227bc7d284f6b32934bed3e5339072c91c6d9d37fd387833fc99fd0bb78f47409fe4b6f77f658b639624034a97c7547ec79d4dcdc07faf9c7dbd789d844bf1963453004f6da82c2283c98976c3f941c92801a587dbc2c224ad1deb45669e60fefaebc89e46342816c04bff236a00620fd28a7667f1956dbd9dbde6f8ae11f6f41c995fc6b177428b7d49c77bb27e3764bd082a8a47cfdf25f4cdf9763fd37ad2e28fa84647d79f1e2897ff16d53520a0d10e8511617cc46128b9916872ae39487c2b7d52840cbbec44271ba55b5dec58857ec913cc4951cd1526e93085acdfcdcb06536fe16f6dfb29b1c9f46ffeb0c38e0b415b80986a01ea81b5cce540f45da3ddc4cd502c676194125f5905ec4d6a8f22a12ba401a65534bd408e63cbfe24fe3f8a7a2f0da97d90301a95d837e1e3290cf1080f33497877d86bc2e7974a64ad5c25d73375dbf6528c33580a47ca67b53198eac9fd6942ec04a9bcf3260956c4f5659574a0feee44404fc9b618a0d553212197ab93505e74b04ac03eaf9f8b4c00c029080e2ef76ded5f287dd20459e849729e617a0ab49fa2a150a736fcb50583635ace767bb27defec82ec410365e676c5c4a78f645b4322f067619e970499b468dfde276a68b22ec61c26f2def8df3b9ab6f36113d0d36bf77740bbcd3df0180798bda18c1ae7f07e7c3b3e19306e5c0a39a3b0995dcd2c6eced92656c2494a3e088fee07be31c3f73ff553a786123d9a33e7b693007e42b6bd51d79af4eb630f356fd67c488b48bb03a63606be583e9c0ae387747e835e938fef9d491dd3132dc467d59eddd9158494f5cb75e2c8961cf8067b91b79593b29528f1afc7455f361a3f8e911b3ef5f258e05ffcb8de39d815ca132fb81c53b7a831157be54cf268ab412b103999413962557e2094c13141e5b002d4d18e932eb19948a127f850e46d83b6eeb85b442d047d9f2e751fadc290595e78e8954748eac926369cbe62077ab46c493ebc03a8580fdd3db4a53ebc0b2384f771d73848ff246e2a095fa07a5d35e3ae4d3f4a22c7b0a6a80abae928fabb37bc3a00f44c6db709c39a38d824c8dbdb3fe3f6700f009e8d172386d495ddeef6a5325ff9e5b6620a153120f7a09c01e812fee7378a2de673ae179a9d62b39a6bc40e2351d6c2b59daaafed48a2a723fef3acc203b392ddc24fa2bd06b548fab3eba5402a694ee6c98d090efc74dca4c14ca99788381657c90a26908c9fcc7d909c478c5e619c5276b749dffaa5dfc26e775b21d6617bb293c2a34ab3a9b3ded74afc9a2b32bbc27e8f4d59ae1fa4781d532fe4a02cbb50793c07853eebbf607aba5d29623c75c08e45d08fa99a4af073bca133c4082492a7cc10936157e50cb73920013ed0359ae6edaf501515d86806256caceeb2d148e5c6c7d838c02d76336d691883bf1c4c14d7a242938e3fabef3008b4e5cfc9733267941f332c907ade13dec7c4876d9d15facc4b94b22d2cc0bb55a20e76c4622bfb6132b8498f5c3ce7a3a020898ba6ca8a5da30e2dec578a2c0f94773439b99ad4a16f25e8bd62df3349c24099de4a15261358689b5c1b28c72c1a6ca0bf62ee15a034f95d01b213c15302dc45d791c1072787a143ec26f55288b7284084db1efb2635db577e7d0f6f6786c732b94d5a8ebc081f2c44be10b97a14786e139e28aac44e520f11a3d70e5aa593296b267f866e9e575fae2a054e6217532e21c2fe5eb0858c1966f6af0488d3143fca4688e4dced58f636dcbc764514931f27e8f78c8ae5130d49c7f9e56382ee459cafe09c240529f710dbd76622a07ab262d632ef07e879da4bed7cdc202aa404eb36bf97d8d9c2b9e66df3750b334fa39deec59a90a830ba5e989f009a297ea877a182dd14b077e5ecf675cc9dfbe4c341db4697d86c2bcc411cb3aeecfa3f15fb6e52058272ff2076334975e0dc36c8a3549ad851a198fb788c002784f3a600f271f2e6d74049f1e69c7f15177cdcd19ce8be0d71028ef4c2e5592fcc50f5188058f4074bd600d4b20513577bbb7b655f571f9c94e1585f172a2ec9957ec9ce183f39f37b6bd1cf0784d704288aa65774b7080be24058a4461d5c434ee3959b3e0389a03b649ad5e13b00d67194a9dc42777a8c677d9030c8e1bcba52348e4cde6067bf7323abb80174ba3645396109cb658f20b69dfba2b9e491a3b33a45f68d3bb603603f9c4041046f00c3f056a71658ee00620f6fe2f2e34d3160f3e3bd2957904b30696dedb365539205c97f0ccbb3dc3e6ac5a8200f5985e7c05f677ab526943abbb4afcbb283f9db63aff72e0cccfdda9761594a08b9a73c7ff599c8e75df71f96fbb08ab2290e47775262cdbc57985087b4c2c338b5dc4ddc2eb9f26e02147246087d6c2cac730873f0aed9b990b50f1a52b208dde47954c3a5b8c4dc0119c1d1f0f159d5ff272235600b016dc75480579fda2e7311efa502be95bd85f11666c57410a219e17e8fe7818ccf429cabfdd335b85316304af21c4463699d3ff2d3980ef0b2735411c81527d5ec7a8efeb72338872be432b896d1289ad776fa3d30c3c85fb407fa07a952c682916f18ca033cfccba9e9ab6b2eef95369c373ada77431107a353329d74a0fa25f89225e1d90bf0c45b389770a8fad5180d9e547f2737cca180de7e99b0baae864de15388068a1265202459e9250f3adcff07e6f833d1da971f2bd761f6f0e694dce0f3d7f310274292e0e689236c10ce30bb6f3be4fe02e9bf2c0aae60563041581f58a4337c3f6c8358277d1f6fdc52996a9b5ed95b776282f728fab3baa4edf9f5ff40000330473a477daf4e80cc5a10b106e08235201475997c9f652e4c65477631acf2c48b0b60a2f698cfa1e40b03fd5d49b1a26737a1b824ea6310d97d2e32a12634e9c084558181aa25983e2044c1036b69630365bfbedceec6a7158c379b803a2ac453c66095755c342cf7fce2ce023a561fab1673d76e28fbb6b1fd7752f2edbe8b5bd1774ad1a1db3b6c58d610f433fbc7ee461f67a735c0381c7126764a1cbd74e253d299f0fe04388d0449977e7a276b52c550a0ad80a7d63d6165cb39f5193683a87311bbfc8f26237e86882d14dd2ed70145febcaa7196d67e515b0a9ad62278bff6aa6ddc4d055e5902eb051dfa2da5716c32b515710c0e5980cba0f6d6238eab19092c122e1ff17039aefe94f27083f17626e0882b9315068d9f447f15e8f854c9c57e4c3aa36ae15525d73447e273f67caeb9e71adec1306c1b049826f7e90cdc73d0c522f7086a034de61f42a0cbbadfba2b682392ec0fb36e66c28850e8be9548904fa4867383c87023857578b9d6db8049f7bcd5d038f35adf345a035c81f45456205852fa415db1b034630e2847561b70ecbcac66c87aecef9a679760042510b0c15d5ced71be93e5a4e3e4fdfc11d587575593f937ed70790aa55fb11599e40ff20ad9013cf5d9bb6d1829875e6d3a35328ad97f8297b4ddc13be91c3ea1f0e73ef482f2ce04dc1acfbf4079a1e5a32123bd2ec191965ca8dacb2c0812fc583938b38f7ceb4fa76b514093436e6c00b725885acefbd3346fb914a9ed6854d9a3700b788a49fb995e392a9ba36b2a0eb0f7bf03e37a143f9504717037527816a1a0225545c9dd7650249c476481ed188557ba80ad2cfd7daa27e3bb3bd1c6d5ee421d474e18ab74704a296c790b308a581a9bab60a51864f87ab3d3b45c81e1c22e83ce4d66639ff9310580486487f7e331dbee98228c1926e55fb22f7cb99507b5f853eb4e65d5414a996d946616675d34f98a558e5dcf87fab98ea6615642e3c3c70fc9e07dbc447be1545d2b213325b2a1b9f5407fa32f94e1f12e743a8dd5cd6fd45b38f05277926ba886f1b5d720700ec89350bfe3ba55ca6002f1eb0d148773c3df37d89d93ae18a68cdd2f21d2b28860fd91731501879ec56915e605c8c7a07f234e9a582ec75186b2474315845ce36b1f042f4f9417ba246ee188d45fadce16aa07a07a0f5c8b684994fe4510890a5b4c6e097168212186ac3f04f834d539f0633a1e57fb88415b41349a13292701a654bc264ae6339a56c2bf32628ad9e52500b56f4b269f16f5df2011e0406ac6784874a316f7acf58f1ec1a9eac1c3d0f87deb897d92d04aabf3bb65fac00c2f50334dc872ddf7ce40214881632d056cc7f8769273a441d09f7f1dda34a224beee211b84f23e576fe35e9769feb104f691a5e5a3589b082cf882e402a434b8c89da37e20c84a2af3ca31419056f1306f6252d687643c875214f2ae939e70e6546081bb3c8359981e36487055e910de36befa16e40d0dfa68331f96b094819f8c23455281d2a413e7fe35b0c1839968e43d697e201a5290ec4123a5f6c0a7261b684ff36930884d4a6dd3bfc710c062e8bd96da1256a1098f6d01749b4edbdf4a242c2c0c56ca6155d5b58e57487ed674d4533cf66107df16265e5c1819590d148c221faf192fd4886507d97ddedd7fa72a6e13e9a8db21b0823718066ed03ceec8c426ec4a9f85d6a8c285fe36993507550307bba9eee51aeed4d092bc710f0d0e2bed423bb17a94413958b3f3eea83e2a50d6c82c97f30c66a22689ac652930e65cef239b5367ccdd09235f1628086ead3492df4b74b502da8924c2118d80db51c63a49488c47c03a47b2b15edbcd33c35fa788c5e802076ed73ae63b8ba241ffedf3e98e5b7004230d7fbd450d14b634034691356b2d3718f927ad8c67b98c4afb6d43b8ffd9d95a4cd6fa048096426d1fcbc880fbccc85fb4a912eac90b7674609c7e4f3a4c938e23b772f8060a1816df84f3fdec1a85e711e8f6da4f05f27646483d1232ecc00b5e0bc509c405cd6b5ab4632ef29092be5bd53287008cfb2acfd18b38cf8e09b8f8b7155bda1ce4e36c3d72c0aee98846de9ab2e556d1718b419d5c834d8c95aea98419b09e912958a3d4dcc98f1e76332e4b4f6c1974b75aa3e2a29fca84e6096410903266fa59ce230448e4ba6022abf61389a5ec1c888220fffb1ccd4eecdb97baff8a56a1645c51cb1eec59ef7916e7177504df2b48fed217b9adac6cd639a90c657de2526245a2cf9ea77c2f48b4d30d194ee84215d182ddfe95c6e0a7afd62dafff1ad0eeec38fa94fda4941354d46622e2fe46fe81281abaef3c0adabf92f4719c0a2b70d041d7c570a0671f29289b065c8bf573250c9f0155d9f3eb16631c19efcb924f550a3945fe2be26ea96d3890ab9daa77a33b8fc94634010c629ab33576eda542ac931c1674c787534448c25c0ba6b1abc9cd6aa3f17c7e04262da1228592a33fe89317fd9e9a3220431a6450e02dd93c7fb51c9c06284f3d211f648008de5fb8816387cb14797de52a94a6868e422c271f293baa1ae28d98dfc430c30d667d07ec13be3cefa93c77268036ee48d5debb8ae6725d6122314542dd64137d0f08ffc6bb18abfec37faac4df831e6b509d609ecbd49a44c6fc70c7a82ec30f75ecc8c281727a514abbefe7695927b6322457c5de02daed2f73e376e86d04b643ea0e00d9643c245b364f736a7ff0f13d2724fa5521943be15e58fcab45b896f1b9c79e2ca1f6392224a183fbda7dc083fe67e9a966af0094afc99facc9f945ff645aee56bd0f50cfaf3545981021a40bc6fd8ec94460cf66ba97a0fa0958a54508e64ff76021e69ad40edc094f4fd90aa448d94e1d38994b8ef0a7bb4b6dd8d17c0299b2caf364e5d5799969aac0105fca1883a395a5b455aa9a45d0656c6a024442cc631c4c37a4dcf2a6beb6d07639226652956275fce6b2abf5b2df5bb18b7d3e8ac17c62405ed694382ffc6cc9ab78cc6a98ab43e5c5d6982b73b0cc6a6705049b600503c01b38dd945063be5dde4f372805fd80d53ee2f6624b37741394a8103b3fa38f0c04c4d47a5da01fb80f8ea21f3fde5399416214c9d8a9e3bd1ffae15aea1dda28f133dd40a62e0b1a742a7d6ec3aa6ff8538625b226a065b1ba19fedb96f8766de28913051a573678801dc1311c42fee5ecdeca8961076b38baa5ae7adc8a426bb8e5fb42421632684cfee10dffd1d2057fe9220c7413d4f8c86fc34d877e8b1ed6859d4438987afdb6c0f1921bd0ff7d8497f2e92a1cd5b0a39eee3017e12b75885812c639fbf65ed86a4581edfcd974be69dc80d80477a1109950978933377652803767cf780703e091b88e2c6f962efeaafa2e72a613c34995603570bbd6fb18264edb305d45d82a83f56338998650fe56f585644881efbdfeab2a7f63a490bd234cf79f72e33338042b976d5944918122b7342bffb02f7d005a41c1b5e92155e06f62b853d3eee598a3c9f459013f2ca6acb8d7ec9387bdba4e5aed32830d95632b5e0b3a9d88995b1ad8079a6a13dc7a2b20c374e85a74639ee0c6727a9141a916ea806c669c1b87a4d40952386b0b98fdd0a79b80ae1888155844e2ce815e4fb9ba7fa6aad56088aa75b656063b096108c99e80c46bb4c3b32ec6f2d62b24bf4a26ce12965958ec02409185a4a0376409a3491b832e6b9afd2a7ec9940a9ec12560e0b16c6f50004160f24a7e4880e3bbcad34fe62ded57800748231ac8b0e0b323b9eb7e403bcb330527f2ad6f794bf24a43efb7c384abdc3383bc648e9587914c012512e4faf8f726b477b1b383e8f2024a2b1659b8b265554fc3d913889e8b0f8c214a9b333da4598564b7a545877e4b78cbe932855d5091576675581966cb3a94cfff7f47610de85f12b28473d7a7a48d091bc1c4a7fe215aea97a01ccc5827eb3345741d62914e728a80f0f91109f3c3ccf9faab704fd140ca98b7f4bc52ce3ac9006e89de13a4f6e39dd468794f223a8d658a3b6971fae7db14a3d0fbd3a8678ede6d33e34ef742c0c39c28255e2580206830adb02bdd53a0148dd462abd529d825b1fd326343b979b5d809ca21c1e4e685bdb2d1ea74701137a86189b551666b50664e13f38587af3e3a9efe2c93c36aab7ec2254f555576cbee096b090bf0ba9ce75b77b91460bfe4bb3e4cd18b53258cc155db2aed296028cd7d4ed629c54402303a91b152a165b7efbe1cabcfe7ef4e8bf9f9cb36d3b2b3ae6319c07e6a8eec92027064b3e4f778cbf2d30660dc8821876fdac0ef19811865ef23a05a9f6a0a8ec1ef61fe0ad9f5a97415d2bed76e6a02c3dd106f66a16c5d80ebabff6349398e85c13adee479d9c727703f0bd346903b9cb7f3ba3772c9190493efeed569f6d258fb91b7b8acde66025df99497aff89caaab88f413e195abcf92e80fe890baa7339248ab39d3d7d728d925e9f77b4987241772a347094290b5061b5479fd3e6a28a70130c22ec00795877383f0612dacf781b8ea77e072e5471fecfd3215414ab426176bb96f78712318642f928094699e34f04f5d31603e96d683dde98f50897097a357da57fd81e744080d754e900695bf0350f76072f7c24660f0714735d92cfbfcd08aa8bc2e6f255ccae958ef1a8382971d06f37cc8d878c069712a79bc412b8d1aef9eba3f8aa29c173e3c005278ebe650e2bc5303085c1d2f93013dc0c8ee4288382b31766cf337262e08fab5a6fc591baa77f646c88e1a2ad6aa24b702397547fde341b931fec7541b48167a4c61011087346179424d6ae89d160ac8a3fe15b08009bf4090bb9089f7a5a4079d80c57760a77e0a82207ff9af4936eab1bd32bb93d9dcd0a8248d8e2ae7d55aafcbe164d721502a9fe6467db63b3b96af8c33b7f5c244c5102296362cb811f89346f92e2dcb3639c46e04f44f0986dc9dabd3dcb7c6f2302eda9c11af2e06b5667f98e7fcdc867156eef095dcfe8f773ef941cd79d0107f500af42e34a3ec099d0d9e75ca402c409d7ab67c047f4a32c44c90aaa7c3cde356b14146da2ea58f6a063ac49e7b1411c1321a3d4cd382c55dee2a55581d87ba58efe851474db5a08e06456a0ae52e02253e7da3995982abbd7e10cfb5b1d58cefd55f31623e40a30714d6bfe6da7df4181779e7a641246cdd140811e9b5f393a2ca68a1841bfbc4a80f1a039281bcb0ad68cea34a9bda27631ad1cef44a7c9291ef868184b528dd301e7d249d3ceb034855d54d5c12d5b7ab47f689bdbaf02d7d5e1c4883af562c4af833d1877f46e29aff84cd992692496445c23a549d99a358f153eea797184e85917348ec1b0a6eba1820f77d2d31c1deb06aa19163868595989f80011d004ff22f27b92b198fc94073bfc8c0566b00f13e97cdfbf713bc479cc2a28176aae5d484f013b532b2ab9d9915b977eeac706484d1bce9a04e3ba14abc321d30baf0164859f34d82ba3541b43e57f550fa87535dbec5b3d356edf59be80c05a412ea2cc4aa6c84b7cee8befef7045cf6be1566983a8ebaef57553357a82a5199204321d4819f7cba858774d8c9751564e1a08678c1a2c3b879b0ae76dc1c430b89dc17cf447282d0f7abf990e009352cb5974bfb7b3b449e7fb1d54baedbde9040eed9278233a165bbeba9546d171becd4ad18bebadd77eae553d4f69e038382d50cc47df9cc18d69625911626107fe41cb7685af0c06449e46308468584c2dc780ed411e2c752f0f788190c5b449f525cf93abcba778a659a22feea8f1b6d46845fe91f0fd4a974b845b88f7797854fd7840639594fb8d0d8958c2e958a9b8f90b6c53dfa7ab9f57df0fe2b9cbe372f7eb2525dc6e12cc81922be145c4c9ca6250bc5ac99c30442e8b2d950f3d9ec239cef2e0e5ca46db39fc791b541110a0ed097f39e089525e60ed6e8dddb8d0ee385aa90cfd54958212d0db21b8a686943d8d050ce11250fb1caa5b14d38961b17f309cb337c41267ea94c6b8708b9b2bd94f3b8d70e7954b5544fbd33cbf6f70e7a800b970ce76af47542ef72aaef970f8140940c64b3fdb9d3e54f43d442cbe8d4f923593914fdcf75381d9b280cdaa722814b1b423d26741153bf650ebda4defaef814e98da9cfc86e3a6c6d2da0719467345fac6242168456c131877b5c4fd04e16501ba3630c071c0490e4b69b69b7e4a7fb70c5a25f3f6afc254a48c133c1d5c8e7db314b982ce9adb4f27295c737c39a6901094fc438199b624d5ee80e0d3e64c6685aa0643d33929b683d641121739cd8d0a63319963b401b8f58f9efbd78ddf7bd96e3463434117bb8fee42a9546208b7d1aa7492cdf8bbb3fb58855d6dc84705cd79671362a03ef9e82cd4623c5a616f428d724cdf691aa89f60b405c6aad86b6195c4d9debb3f952a79800a446ba5dc2af1dee5c20c331351dbb2310b581b638f77f2141e0431aa63e21444383e236cb9d1a5dec6d619c02ddfccbbb99a8b23a03dc4b3f1c7dd32c8f500e858bd31a9c491d51fdc5a30bec7722039f3cce4e68fb236a69164f982ac4038057a7f893de4500bb96ef1dd0829b13382e3e8dd25177e7712a68893167a2cfb1fc5bd6d6004e79fcb4645e5937ed931185a3dce0567f587a63b8e06036abde6dc258d1e693e52e0e8792cb2e9e252bd99683d9f70de96aa958e7fa3204f86b7fa456277b7543da5b949dac2c1e03e6cdf10f66dc7d70e50b79defab8c65b66ef1f3e2c15e3ea5e5e6fb40ab86fb49dbc4a7b1678dc44306f947555b09f547ea3445a04991734a712d88d6942cf6a4f213fba4a51cf4a4fbfc01fbca383e02a99b912b07c03c457f09dc34419208e3f79df25857456f17124a935308135485eae67e75542aa29797cfeec8bc335ab1fd961db3d8516b949bdb267fadd28ab76dedee153b367ad506dc9a06accca9d485a296c9cd5fc8daba5ec6bdafd8c99346c6ef6146f3f38b8c88641ee5fa0d4cadbd25674d61cccd287d11831ae962cc6ff4d925d392168c4c283bd246127cbe69858b769316f2b571ea52007b6c7f39546b86f29f78034eeed1bbbdd66b06d22e9911af1ea275a9de6b0cac9b1d88c8787346022522cda9e6ad7e206dcc00f65b82183c3d58aed22bacd1ceb1c5097d58546998fae47ce48f2525b2487dd24fa5097cb6ed233155052b9b404ea4e9b42eac63c981c91cc96a99c7d244a9f2fcbbe88f5f664b4d55a03088dd46958f6dd87c2e6dc2b6c63b7a831ae536a3c904caef301671469920ec4ca06617e0728c63802a7f03b75f4075504a3d2179065482e0e5830340eb0a9efd59f72abae40f0f5aad8a4cd2f08d0ef7c132669780b76506fa7b4cb382a411c63fe1d9459315b6f1add82bb8a97a381887cf85754b1e624401690b36c2307c68f7ddfaec8c5f55236b21442df8e562a854706f7012434b31b6d0d59504325a5a4b40f3836d7835fa623e73554b2b6d86064794795835bc8ee089974eb8d8696f50f50e55774fd6bbf7a70d7b7d995f17e043d0f80af1d6552f0b1701ebf3f16589f0dc19cb1668c35e91e717a1da2fcc49ab2112bf524ad01722d9126623549dfa56a6b575c16a8ec0f8afb0ac92d85afab5f64fb10a36766aa849ca8055c6fecf67892f79813a65d1d136867cffe1791377beff8e169a892b35cd15f6e340aaee4205b0e45416f1c60fd3cc822cf9feb32af4abdc196706669c98a94ea6227a94eeca0dced24127e49eb6a0ab209f146345cc82974d70c0824670a7dde41504d268f34346ed5199281e2c26dce7b67917e6ef05306d53bb743bc3fbbdd32578d8b5194a179d62767096c2a837bd22b957705cfce04892a12135090e8e86616de4c9e87d1a8df60febb14bc9c941bcf085faf25c66216fc89086ecca647727d8ba0cc2a1ea8525a862f848a13918e2e77e4eae83eaa4bede1b2e14fb620bb10badc1936d8b4419457acc328f5a26f8cd19388e2834da455d6c6a5280710b640dd6ebdac48b163d57660623583baf1b55396a21f3ae344c030ec090dbf90cb4b83d5913d7acb25f5364102721f4ddeb5a294ef5d037ba800d4989c0b763","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
