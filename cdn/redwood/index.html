<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e16265e19a5bca4b66a9edc26a1f280ab2b32cb0c8815a269b40e001f7e7d13f1eaaecb7fe0df5455bfab03fd209f779c07128691a3fede05a17b6f277f9e5035f8df90b7ee3fc1475ccab5593c3c9dfe3f03b225bd2d6efdf090a322b6c142627c69817191d5455ec195053438164535df1ce83f26d4fd0a756b68c3a07016edbcb9d58b4c3456a70b418e09fbf374be496328e104d51c3b6cb59474ecd6d9ba1b20d9a9adeb29213a23234c0e02002eb546c172cdf9538d08a17e0ba1e8bbb5b201ff5eef390244b44585484e0f886b417e87b8a9d962f1dbe6af141c15a145c5cd4deaa85ee1a3880ed3415b4e6a0c4bceaf8871c02151542172982dbaf3a511b4c50deefdc0d47fa3476182558c7e2ed74e71986fa14db06ad52614e2413b2a0e6670514de9b0170c2572052f3a1b0f24efe01eef9db2b1a8b090b77b5360473bf2ccb4f4ec579d8e62ce2b5756d1c597bbe982841cba804c32446a30ad0f2220f237d4ffc5dd88e42547895c15f8e6c904b2d4aacd53f81e75d06e64c3a655c7963053eecbcf590cabd2492aec61d299d0e9692892669d5fc68a82c26778fad865a8caa25b96d35c157293dfa121737664edc02933349d361fdf76cc5c4d89585ef085f7bb0dcbde5b45f5db1023ce1709f6d0c28ec985bc7f5be632178a2df5fd870ac3a206861ed5864a4315ddd5f311edecc0ea4aa0b826adc04a3ffe5c305893bf583cc86ba05f720ba6e941a6c161ce46b068949c12db0108adaaa4567967ef352a62237a337126a9e8244e5113fb47ba53c40a8ff943efd786c0cd2b983599719526e35defa775d20b9e148b3376423138aa8ac12217599f262413a95aaa175e348b3e51600eeed0b395b6b4d2e9bcbfd71e4950591b654515a723b2ec5ced457dfeec0ae074010d788304b72ae6d71b5fffa82917064df49f1c9bf5ca10604486c4f52c76c17eae302b7ec964ebf9c57f91f32f9a11f1284b61cc207f807e7a97a7a381814820a560fc5959630eedb416ab1fbc6daac306c1bbcd77e54ea17f9f99a210cbc26f526bab45c13e0521de2f488b7a5aafd475aa4ccef37828b614a4740ee4f10d9f57874cc0f7acbbadd67d3f19909052bc3e88d9804c6920dcfbfe25eb98032ef951758927c639228d2e966cd63241894994ceb495ec2e37cb54f2c44171075f9ead094a4959029b071b7954c7bb4bf50e5f61516e232d7dd3520a7831ca365171c14bfddd6dcf6b3c926cbab889ad650730c1cf603614ae8fd3a783ee4d5e246523d75336fce1f41868ad7c98275aec899d9d1b094d10fa21383360931b92333ee30855d19f4d039df006a421f845b07c34b1cfb292a33cf84c9a19ea91bc6794199c8d35510c3ad0ff6ee61482c8251e49d0e3394815bfaa29b62f4c0e143143e8960657d7087472277316351454736b46719b5358176b160ab4b7946325f6e76d2c0a9acdd8a618dced46e60c5407c1b919538a1fecf1bf33e4d460ee8fd1bc7893da0e65afa58f4702d313000f122519776efbba497a4d6d9b7f6d09a77893f04228f06e2364077ce0bd3ea51879c7a064e88e75c5523d5f852af692332eebdb9ffe713fa6fb68470c7a86835ab7fbf08e2b3c6014d5d6b4202ca9cf4d55d61c93f6da29aaef7988091c3611d2bd899dfd4fd1a22f5227ae0745a77c734973c6ae34422b0bb0e6006412743768b647f6dfdf25133070821427701cfb2f302ce56c113590736a564487388b1048237fd7da39b9c77e39f1d7611875c1b26ef7ce13a45cd95e8bdc74b0d7f4a1f0a839911a415004f8956a92b87167e21c9b2971b738fa864e972bbfc57df95e51555f7ec9888ee18394fb7da33487d5d07a526a07bdc034f5dfb9e9bd2665f077987d9037ca203f0de4ae527590f157a900f5ae8dd4c626628e9ec8860c32c5e9e82c71e8b9293770d2f830fc4489c828543e30e805f208805e9c9ea9aed477344da37b04f7db334853d4e361d15803f9691f71cbbf69a3f4c7be37f921914ba275518d4e3d16cecb8483d9f60137798e10d345091aa854784585370d1d7e2597f8ef92504a0368d1afabf6a1e0433bdfb3aa449f340d51b1b203fb471026fdf7f3c4c3ac45c7a805413839a82584aaf1fdda155972902ec50ff5fcdbd8e2bcdd17c11f571371311a01ca1ea8e625ec5362e0c9419da82e37bb1cc94c78def5035cacf9d22fcd37d34658554731f9f6adf1ee4be9090b0cfc7851a44ed377cff8ea3b110b380bd75a4f3e7879edf37980f92e3318e6f5bfe06a7e2a33db0bad9c976d73237b19c8a9d78b372991c45afd5e20cda839f888c5179ae1abb2b9dbba094027b1ebb4b1e9347b58df2aa575680cb29eb010da108b614965398e26a269f40ef1a47567143917c42ada87fbce043bd8b7b24eb549e8fc433ab8e4efab110ca98f3b5dfc7d0982d3a8cc1a11966af021720ac0ccae3889db6984112800b470fbb8f088bdc2ce586f204449559b31b7ac6ce331089e59eedec19a3caa6e42d4ee24a8f5be8e27f15b6838a8ab7a6b0f15824e1d85ace8fb09976c984a373cbaafdca1fcdf9221f022349fa3010fb0d07891794418cef6e701bb481f2a585f893822d6f93f6cb00b8ae03c50ca47d4d2c974002482cec7430cbf4dcb5b595e9c4dd05d51d8613ae0a060906906dcb385eb88b45c98aef895dc495a131af31ed388161070b7d6046f092e024ba02fec82fbc29f8450c471952e69129857d4416ba7a6cdbe1b14782c8e9dda6c971e25377d112bf2f1abb6ebe53f7b803c30093637e9ea545f439bb92f3e645735e61d06f14d7f10a161149c8cc381c19857f4e2286429f1783feeb7ea83fc1cb9bd9515501609bd7457b417a078bbf6f5d4acec690404232423c1a909d245f11926b903118a592eedb3c677d5a0c1bde103bc078769b5b16f01060770d4647a5cddf0de9fb129cfeec243e284fae82b3fe6caa8886416518b6511ee7be182884532aab6b1f0d8388ca8b0fc60c12c0d4accb3de531caa87eec33f2c9506a3c33582a5153e2b3693bc58c65197b8a30bce31817f10d09c7b89d45cb5e238d856f589f4735b930b7a343a0c8d91c5f98f3a281636074d5c9e504bf062b3bb61ce2187554647fc3b7b7cc3ba58673e4dd8b06b2d544a9b8e25d4e21d6b6f318fffd1497234e66e4aa61df530a032192e3710177b6f9d9da79aac368c7cf49de5ec6e565ac2b66e32c2ee0cb90b4da06eb1d047c77db8fe761af03f6951c9063fb3ed91fd2c2b9e719d30c66b77735843065d07fe8867f7a9fea76e2be77cdadedf1ead972be54e6de2c4de94bb6a885191aa96c45a560708d7bb4d528832152850f27b290b624a1fb6b52fbd4f280ed5b23fa68d102605f94d22872f6dc0ca12249ca5980a87175e5717f43b0f46518e18ff070d74be22fc1df0012e162f782789548f6272f20533b865dcf1d055496848017189c77a7916571dd4c295032bbb4bbb7e65f69af30f0366fac64a882e5704e1a3ae3f408cfcfbda81bb1657627519dfd8050622c1bf98434c29efe81da17292192d107c2ac99a376a4f7292071d384b369c38492aa6b9b2849fc630c25a4b48a9308bf24e7c0dc3b9a4d87a583aad0df19dfd84cf3b1677cab44e1337c5aa62ea9833166001401b46e4182824b221c448d7aca214dea5868321a7965b789530ebfb05e604322cbc93189f6e614562458212021322340a1bc0765043eca879d33850bf4f0eb533e3759086ce3dbe3f8a8a2f9ff74cf22c4303e9bfee3a2140f202a83058a4fcce10328e42b5053fef1703719712ee32066464054cc91f10da5ee9434f25f28d12b6c1df23f2488935823436c17bbd75e5fa5b837196ecaf28304d3fa1116d57abfd79d48c2e8453cd6903b447d6a1a0bf2f5f0da89ea8adf1b977118e93d26fdd1614bca328e22a66e68800f99140da84fc877107250b18eeca889396ffe59c4ba6344ee95027c09d351f33f2f88dd25188881e89a9d6a58610d853298d3910cc61f3936863fc2b72b2bb42454fd2acc4c0e318b24c5376d303ab4151856dd9af3c101a6489b90d3409de4ceafb1697c1333357bd168efb8f97a6b206ce08e6aabfd4778b7de4adac7bee8f3671b02f71b065605d731bfafe66088316d9b871b194302ec469ba367fda9700d1696fc41484327c0909bf99376c57d9847616db76c9807c951445abb468619ee2901d2587b10aa01590996bf1b8337251351d3de6f8ab7e9293780e0578736f19c8a18964c1c42d1506978e3f25591534f58739b983389aba3a249a94e95bb91856a106c71b8ff32384fc76a543569d88ece810dfe80643777cbb61f35307edd33d7725b0946117f5d9289d1e04c6c9b48c453a7a16a7f83b72f33b45ac71146bde02850a741da9f944292d30c540cd5b65ddf6f9d96fbe80a90e35a68e72a8cf668423d5f216d301fb92c767c8d48a1b095ce847bb2c662e8fc3ea5564a52e01d7ac901d4a5f2134ad4517da723eb1bb6c727beeee6f810c5f2a87619007a8a57b34c09ec9c934231fb725d7276192d2060c733ea5e72537c88d42d3e6287ce636f367011305a5c99871e1ccfac08976c977a25477a7ccbe3f5853e6c9ac2a284e921a4832ec2e2ff9e0bdd3ef3ac9e181a4dae8efde2f1d57960bcb29c27245f3ce465d6d39e965492af8e7034f746b0277cf3d4b6b36dc9251aaf8a6a69cc2155ed80a5ba0c1d15ee0e82fcb5b29a2b20bffdb0941e2647d6a9b1bc1fb998bd9e3d4b352b483cef3486f83e969cfadf5f9b3c93f5924eb70db0cd5bace9d63df578fd74dc30b94706423676434775c7560e7c8a62f413ce48ff7a39efb94f20a516b6be366d669f4e3365de9ffb2f7afdaa05907b184fd43d98a409c6cccfe920fd33ae17de0adac649974bc2c67deb2c33c8f5869920fb0572d147c7760e1bc5a03f681b5860aa452029287e20b0aa0e12d506402e51a57cb84382dd84b45d8623c70789ab68f84a3f21028a50c082df4ce7ee50c8c0ef7733b87984afc183f7ded08be54a21a56d447c77f163a12eefd53296503bf3ce757662b876b3c3150e44befb73c2db685b966732bb2f4e964cd2367943a5af096ac5593a3c33716af1a3488f98e4b3bdb36836c39ca1ff94e3f0c227c072183c552a2490f87b6b9e597a7390d1002f7acb9328610b8593d03b95d97b5047e8204fad18ff63e75cfbaa26e8ace3290d3201144fa15a780faabaa293ddc2d26fce2661d63c2f1bcb8d64539596a187f3c0a12170fcf73e05b2df268c7959d7debc76710a49674883362009b5b73827a96fa8a71087b500e2bdd71807c92ea26b95b783318f168395f89aac82787041903b37daa4590cffac4f310f4e3b9ce266b970a319bb95dd5229e4f5af44e4d1e778e6e9ce1e0ad1de858d8da0b441bb6bccfad52a7cd9378cbe32c8622e1c5c27d246a125da25eb263255a5a661d03b23a88a531198eae3f06b2ed55ae0472554290736c9e481a301cc48a03f24f85aa8376745f609b4659aeb9a89f137caad3cbcdf760a05f83420765c7ae731d8e1620ae6ab7fcb3babfdff23f1cd1fa1898afb30f4ae506f57bf526ea0254c0f935264ddf8213e5ae097679de044c30527b6083acd7a16e5ff93095c8a671a6d9cec991f79e960a64fe988205f5da5d779926e1aef6b42188b9cb04659d16191684684d657d5e0793bd09cc3adb7d5241eee33082294f8f8aad891f6a8fefbaf29cfb24cd5aa87343ef58590f91d9041faa1bde9dd1cd39e27556b1c9ea9e429efb348418342884300d4f195827ae4fcca59f31365e83c1eac1b7528a3da5675b2a4f3ab0ba3fe9b6a055bc2efd57b6c06809a23562fee9b4e627ce2caba4d00ad7b698eae191b41ce41f8b5e36cde3aa655e688360f6fc5f0f6018237d0863b8bcc3890c9766963c06c73757113422c15ebf0e9f2c9fdd17eb6ad595fe9d1fa172e86887ad463bce1d0d669606f3028d7289cc9f4c03e62328b2e0b1e73b1a5365c852aa0ab1879558007d6ba2030f4fa45371a76aa13f18307abe0046eefb8f0d9606477b28a3f0e6dc21f3ebd6cb3f38c0923a33f51d1c8e8cb9b3d4aad0071577ec8e55a4579c97ae8bb2e80ef70e21b17c7642b51b352651e59d407c5befee459e8eb8ba53f1c57c3151135dac6879663fc791311fbc8b001e162ded03a34bb4da514f11f5a37ab02ab42c88b2558a49f0fae6b4cd98341bf1c952d113cd14255128bd411f103cd56ed732f02d95121b81f48ad82c7915c93186afbefd7d81ba2eba7bd522cb54d4bc43e305de17a03605220952ca8cd00c9c91bfc664b94574a334457d10621c8f2d4df139c803a1695de831d82ced2910664350f4011d78138543be51fff2237f2b0674c80c657bec4f9c7e3b9f645121c8a9c6aadf3421f3e24f1c847d0402b3610b66d19a7ef51fa8d2c884c8c2437da2cad5507fb665bbe6cea8d84646ba1ddb96bd4a103c890b610230469a35569d32f61759bd0cfaec353fdb5d50657f3da4d8300b4eeb2527cb1118d091a325f04e91e18b0f0609dcce98a0b868a37b8a78a3a7bdd80d18a4dc135ed7ee9f50ae36548ba50ce11fb598c8e3ae3c602ec7c32bab7d7c3cd891a2de56f7f4adb02eea36341f3e3ad0fbc4c6084255b294db0c0395be9d7ab66b3583b046dc1f0f98ba41bff48fb40005cb59ae8de002d08d6bcb922f6e8a8dc685efaca30ff1c94509f5e555fa3ac2fa8e242bb67e84b7d42911223cec1682fb7c62c0a474614650eed08dd86c2155536f107c28b2e9a8d776aaf02fb88efce98be5ffd40f50c8218373a0c36cb86b72264739f9915d301aa9a33bf98fa8cd1bcd328ffe7f9bc92d350569e4675509dc59337ed172c32cff31d529a57eb0de6bb2626995b4dc06d33312a238c4db5f895387df27599a4eb9ac555b2ba352e0cf7006f8ab1426d1986953b2a4ffbd2b7b88678c8e0b6c4f6912b3277b6049c87588062603cba477489fa884cd755fc1c1f5b4ccaa7a5339157e76c294196de10659f821fe3c5463ce22b93644c70a86be75f85775efab9362d634f131b9dba0eac7878c1717c044ab3dcffcdf417a77ed095813ac1a87285ae2084e7c680ce2521308a15cbc4ce364b083624adc4e8f993c570bf4913da9fb432f2c1fc1a786fd948ae8b24389eb93455e8ff8ee8a98ffd8dde253d46b9ceb05465cc261f70ddc0481797dc805f8cc7678501d314c421d7507cfd1138e6c559b82071a830a39cd2a4ec7aa0e0f21ea8d858d1f8704704354a7380b0c9218250bf85ad318bceb76540f05738a3d7feda301662700a6009855d25091062a97f7896ff90a5b96e3fe2971ff2a68b00b73380d1eb5c98ea6c30de0e34dbe914aa05913aacd55bac3c3bf4c2e54f81a03efedf4f522607461d83fd27744546bfcff62583c384965eb28d4c54e91ebbb2baed592a839bdecb9bedfe87d0cf8777249f53af48a17957d5a40e088fb248ab2a29f6f5340daa48386392e20f3ed1a23c1e740979463f79a5c317a4366e5a23f248e88833e2669cc1e7a5bece38301d986bd8ab7b6b37ed14cc42d7037d13f68aea320050ca4b5c3ab42062edfa19561fce1af38546d09ba5571160925752684159a7da7fadcdad4995beb9ad2c015dd7a72f308e6fb764643aad91f6388236d15d7d50eec1538046b540992f6b3432080f551894f2e170a7eae4c2ab330bec7d773bb1867fd2f5e9d73f4d36be412764e0a8af62b69b7bb8834b9249f91a76ba3c94c8c218a77d2b159b45a7f866e57a5299bcde5f234bbf9483e3b092ebe73302d3dd59c8a618fbd734b864aac71fc951f348c2bc0714a27b4a1893885be700139c7d000117b8c7b7231a79c6ad1bafd0f317ec3c2ec37ba44b918012669f6e29ef12b79460ed7a0aea2ce2a051109c1a2a0ae27b54854685db6bdaa97d4ddc13f0959b112c7e091c70ca802d79793dd6296499029538ceafcbb7574fa641875202ba0d61114de6cc43d5fcb1fb5da171fe644d48f72ea9a153500d13d9e3336eeeec89c33847c9b59d416cc6de01fc8754448efd7d9d393df3f6ebf544107b765987546872b3febd2d6b16b3e00c31dc0d282de8e17a15285d86c94db877699f592e39a5f595f70a22a7ed7ee05e713bb793bad403a1c0229e7c47908c2c7b4e8ea744b775fa852ced763feeaaec9b2db7f8d9b049d98da1be7fa8f3361592199bd037127f553392b8c7b14d356360a9ba2d25391000d26ca9f17e2efc4701a2b9a59f691930288fd4ad70b478c2d9a5679304a9bf83c08bff925a6e3143b6df2c4c568e318188e6333628a703805c55cff11be45b7e6626e202b3655bba572c1752c13785a70e9b0dea3cb10b4e1258f2ae86cede54f28eae9f0a243eec0894aceacdfd9d768195d5e02542830a19b9d9028d18b3d607fe0524a2fab3ba4a4cced03c72eda8b269e43fcea40b4470d1092657d6f2faf9196b9bdea88f892b2f5b48861e714fc5b0928b58489856a9024a2242e334bffeffe55ba9561d8630e55edf6d9a14b8f66f6c44214e04dfb1fc086374f679afa4c308c392d3956f22c3d3488ca46c460c2050cbd473d44453fd6a89272d30365e998eb75e7e73ac95c7c3964f2805098cd33d52d889ef1e2cc0801cac14232f4a812bf76328a1bc3edf2edc38e2d17842aa435c54373e1904f60026423ab318f4308a00553b477ded86c648ec9e52413d3cbd7324f3cfeb4a110b83976863a8be515b9f7c4c2d796cca0f3149394456153b53f35675858a0f66bbc5d6e3d88675e268b5e86f94361d034c73546a19a5d4daddbaa0be32ab762739578df2a3ef0c5853284ab116ceac71338f9e9753b5023b960f40fa2eb69a23a774bbcff10cbeb2c0403f60d2606a41dd01ee2ee3fddd6c0e09a846e6a114e02e709bcd2c7b4131bcfc455d22c059752453af536f37f15f7af88bab245335e91f4263a68ee1e3b16a6bb1a79bc2b1b51de544bba702f696122e35186907dd6cb9f45f5a924765e0889668c40caee7fc537e04fa43eb24b588da1d7d39d6401949d31bed4afbc7748de24953871b24cb79095b634d279b28152b8d1445b171287440985cb6526db167b0a1556df19160688897689fa49a9c05bef945fd3006e49463827d58c29fac51b144eca9b39758e46ba190a771e6f9077083dc7dd5b76ed8d28ab1fffaf3e12230d53874b00a599c25d66d1db28bc5fccd306bf64b5b7f4a9c0485926f1c5abd6a52ae118c4240551533ff020582e4dd7120db45f2c236d035c18473e538740a04b379436254b3a59def0e8f91f1beb66c7b6d2d2e2cdabdc866407e1c191e5019e3c90e1ec38d82b8fb62c1cab01d0e495562d63de4022a70d29b2646022d1218a367efd15ae5045c7f100de73efeb1b2210b7a04f02702a731ab84cb902577b9b894a8d18606a6ae49372f63dbff1d4697df820bd768bf09a1662fe5f3e4a636c643da4f209dcbee10d5aebf128f56e31e808d459a6ac3a2c368a2f8b0061138ac18e8fcca05dbe4b9a8d71d3d14b3d2cd5c6eea31457316118f2889e4aada46667e9596e650945612c159197e72aa5181374e181f5b73e09a2734c74bbe6b007b71a179259c429541cadec5fad2740724c07f00055de0e16a09e45cc5ac6ab30cda3c6af2f61963a1af1e7b79e318b8afa9d9cc7b01b7fbdab606292958ff1d7067ad3bc113ed604f2e46ed6f3a1fc9c6f8651d5f7b540700149022fbb6939011eb99ae66a9368a1f8365ac02b7dfc98190f13dafdfc20dee92f595ce2c5cdad7dc8bb7c1b88fc1c075ed61dfa360a173f21d4478500e8c0f7440856d0736410a4bf6c460c35823a073527501c923e9256606034c3533a8c09601174abcfd2c0a2219bedd5b5d09aa09a6985c0ca8f08e4c11c13772f6161e07d5d1d55f49df3ecb7150ba6829b13b978b96fc6f8b086848f6ea279308f415f1198f6877ebb2154adbee3945c103f5680846d3304c8b6b1bb4e3660cdf11e4886055d05e2b4dbfee663f8e294ff80a271ef3169c27b945134006ef60b3795692c100f2600268515ece75f04261e1ad8cadb3dfff088b91e560c956ff47f94e7452a59ea2e0924592be7f031d8862453df0d7112236e3fc6a7fd529188ee9ed615dc4c206d1590cdd7d61a6517122ec16202acc6403dbe0cb81cc05bcec7c3efc816b5c41161394804c7b9c08f62408d2e60a978b8c360c130c20ac13f1f5a101785ca31a46a490045eb5664a74a594cd0b56ece998a58efbb4b693e109f099f726647d10a7ab73c742953c161594bbd4c1245fbee38611b292070874d3ae40e8a78323fbf26ea7b5aa894067f96b508ff1f1783a56d59b74343cfb708a5888c9b51cf21d46098db2e5f72b8210a713b3fa26cd0da9ac9e189e55016c43e5594ef01e836c9b813fb3f7f272b8a5fafbf1f44f144eed39a323e321caa7a6d508c7a1464443ff18fd54d476dcc63198b46563536c122a33a14193be450b2ce40359891acee7daf0d284c94072567739176973d03e9d7123680cc260709303be21510b449700856e74d39c33eb9a5728ab715c99ccb84dae745ab1fef7b99db6cf8907e4e0b6980e1a0aa3eadb63b26769894f8a6cac8879f036b33b4f0ed7d51a134082305f80084154b675c20cdfc7802376fcad697550e3002a670a8d70ed5755996c3409a51ee2cf2753eaf4ac371ce8c897987d70f82715ae48bd1d8f132b583108a7af7cdf505ea4d6103f9fa9c872402fd5799763535092f614a815bedc64ab310f7af4e29a04bb049dc0ee6d8770dd32c41fc5d3e7dd71a24f6b24d6f081e154e4f8043d0cae58884ce9a484011d826e62712caa3d2a278d5e344dfaf6b183e9d0983a8b50d417b349a0fcd021a6a4615e0c0b8588e78d54c6f990289aad2c73f1f119bf44507cc287648396aae72e735dfc20c657d49d3e323cf8bfef0eed73611c4c1d20de3ac41bcfbd712950f85777d7760898375c0b1a4098ce143a254ba8ac67f0946e5b96ca59550c844ea30a35f0b6df75849a726a0f8bc6d48022f2997e39587dce7f77b65972a7a9ec8d89c4f6f49fab48b5d9c9bd88b38393de17084955f676ef7fbbf3ca4676b41f789ac0c5f5aadb7ac1f871107826db26fb6d8a44b4f930c889fa8fde88830801a009767fe499669daf1ace73bba748c9f51e5c6e7968da6df9ca252dff8847898942eca702e3612a5947169479e3ac816e72acbb0f4df43b9b6863a4ca95790ff32c3823e51119bfb7c3a8958e4154c110bc50e198af50df081ee1e2a62f1c049e6444194a6e0435569fd55b01d3d4c3e5b544dc1b40bdfb2df2e7ca3d63a907dd18e9714b909e4386ac02aa012d94de2e83f0e4dbc0e58a5b338a2d97d3c2eaf454eaad3714ab1f0a5caba2de9a6dee1aeea9927adfd2f31f974e079ecafd6fa2f5ffbd31fbc53c6b3460e94214f9fdf124df8e712ffa55c1f621d9e9bc7aab4f3ac4f656f096b2567d44437f878bb3bee76333d1012313ded292cc3b9bfadf2a4491bf33c9986437d72e48d3b1f7e4047336d18b3b0c1f3f3da1d3c661516930b443f7d3bca5fcf509398adc1a684ed7e97d22ba51011451fbd27dafd87b2e47d7a0a08eeadf0a49426a163d4e7a7241531a28e7b391205ff82edf36986938ec94a534940781a23b289b9c6b26bef0f70ba8e74872196970559ec2642f4553db90604a250af173dfa4e2191c5148fa6f15f905b771386337055b4219cadb88c76679eb81a591e3b31b45c2630bfcf0168186525e8b56f711a3a34a6d28ab6df853bdf2f7af00ef3ff4df43fdfa8e444316e35b68610c997cf6f9c0f23e2f835b24a2eff389c09a7598c047f39a8f2d1cc26bc0b421491d95f728a9af6d8983f3a8b145b0b26756bd6dfc8c867089c82fa88698543dad01417d3b57391895ad809c9ccb671ad2d1404034822686cdc22d136ddefce3cd632e8f0a52381a778106d2925fb81d6b5d5293d1357c6a5ee612b0515555bceccad188dc3da075a6212eda67fc1efe587fdddd7e9b9fae90b0a3a44561ab1dce75ef1062806d71c8e3b1ce10e1cacfc687f1f74bb4e9716e57abecbf9102dca1fe22e506265f171b92a5e1a8d0a58f16472817362d296e1bd52e93f204085d9af8926ecd6d498ac85d5455f23750cf0814970067c31447f701d88614c2b4523b3341b6f816f5322b7ffcfa725be95ff70584accbb5a5c700123a9b4b420600e60df3d0f2f16d39181157d65b8f9dcd18358baaa8d85e42b1dc78183e69a68dc27453b7072ea2b02dbd9e65fa92eb485c86d549905cf1e1166661156e5eaa1a932257efca83c7db8abc4fdac570266ec524bceec73081e32c0de7f351be4410609e6ac77002034d51e545f979913a2385094800ff1277fd68b120604853b4cc028a37413da334ee7e2b947e926cb384c4494deea56b42af40bc1c9e604ba2a4fb61c16e1de59d7ea2cc0b5f2f3fa71c8f06000ebc04d1a742dc6fd477d7f2b48a27f156ca45ceeaa3636574e890e2ac62fdd4ce24d9289cc1dbe268a34362beee32b40fb4370e522f1ceffa1e8c411dc598f5fda3d9425e583fa125b34d322382be391f3552817490e9da5980d93adba48f109aaf4ed373b77d92cb1a6ba57c6074d00a5a491fa05aa3a4a33ff04a746101b63bc2b48d1e75b8f94712ea2c45f12a5ec2c6b95f1fc4b03858bc8d449a8d07c595b0d426c5f2f13eb6003ede2f71d4c738c56c1ac2fc3af1206554da0ece6d0e58e3d730415e4aa47d15007cc32fbf02134140885a42de870bc274c8cd8d918fee69815a9545136e320baa67f51b7a3f66ebbc596e83b91e781764664192fc1e8e49529d1a88f666b7493dde69083995e96458b49d2c2dfb97729e624b6cbecbb6acf616de1a0493a080e17de554c36b7fca81c4a1e895fcb80e10c9905d2223e51b889d91303e9acec07dd52bfb2640bd15b123d098b70005b12f399ab20175fa8a9ba2d2e7d9e457ecc1e8305dae3dc5eb0ef9c0acdb2fff7c88d52fe10509eb40880ee9fa3dba7cf702d81ffc4c467491b7c8a75972bbc04409633711aa78fc1c4001417e90daf09ff06cffb68c9fb8459e16f4bf55311bb482d84f583aaebc532fe59de8eb14391bac30e50f2936415527e5ed3945f17ca0965e49058345e1a3b1c8e47eed6dac895476417cfb176cbdc6fa16bac929f7b433f488e5c42ec5a42b9970fe1b970dad8d736e028ce809776d640217114722696c4025e42412592394b80ecf09fca15a2a3bd028c1785908c8084771626273bc3b44be2f078a90df34f04109aca0a237d8eb453a2df2a8e13e636cddf4c2d03c599a0feef205f8ce96d2748dc7f3cdb022ec39323b30260503e6e4c4cd8fa16be6c665788e36282084fe7b0783c79925899eae55005c8a2de3727234e3d8a50a790edbc51959f7fcf074aac4b2b82ed2c66d3f07756c00e17b0414f42449cdbc0d9bac99b83192f4e51005575bc0af74193e0f671793b68a878c558c864e21254ba65f8447ce934572fc488bdf3c77699ddd72d496eaa7d7cbf3020175b467684cd10bc21b172ed4744b0acb3a591765ba022e46c66f1352b75b7d5d87b414e742f45d910a19092aba42e8835a53395d16c211321ce9ec2751fe5ca38738d3099eaf7725725a0a96571757c283144c5cb30da0afdb372e4c40f52c24897f5543846dbde4bf7fc9808a0d8b7e941a0d504b277d6722fa60a534394c7fe49fba37c15edba149c255f250809924abda77a47b67b8ba5043382c1a30f7c2ab9cf7fc1338ce80a875f3eec8978ed6c521b7018451875bfe46a5bfeef4d2ddb5a7a5faae0f5cebf8a5c7a8aef872d789d8762e135f11db672e615f95bba9337f7833ac4b0f919d16a5523bfd44b2e39daf92fc044b3499c50de2876116d5325eef429d35099a40da3bf31c82e5981cb701347fe77f4c08dc20aec9312333f1f694e2faf47c5d4460d5ae861a37f9a96cdbd268ed8a573e457200520eac426b2371b0365481cfd5514ea6025ffd7eb6df750097327e1838687800f60d67c0d504167715d0030c2a1281ef034deddd251a42257ab19f08abbf8e0e544e7bcbcce280bcdc8f0f2fc5edee6bd8e2d42bffd7855a05e6ad2daeb2e9f92bdc67f5dc5cf552371ebd76d91d6683a86e89a7f6ef056ff87eb18c920a3ceca1f7dec2803b5e0fc09ba37b1104015813dc3b6ca0d25a11906595fb3d6dd13c4c6b1a61e37f9b9b700aac6537bc94f555bcbdb7adc9822db142eaab84898cc51758e289b116831356ddc2e41afd1b55752b192b656e7f877e9abd0d4a6b636deeecc8f3a028c435be9801eadcffedd47df63e424b9af709c716c0345e9e724097f89feb0d35cbd18e7ac08fa3c91f74cfe33cb3f423c82297b61ed18154f2a0d95b2f62bedb71c8f354204abfec9b280c4e073abefaf288003bcd23f275e9502a7dcfe17dc129191ee59d197cd2084d8d887e79bc1a156300d227e6404e1e50a0b239ea1ff93a515da434c953af1c467952dcd9f625e0a37cdc7906453bd221ce4a64658b53efc7330bec3b933f77ddfcd17936648c01338a36d322d6319169df1827d5d250fc91fd065fecc4479edd5667ab1ff3d37c12d7022fec1dffcaf83bdcf49811f44e72999ee224e6b8b018b2320a5058a2e8b97041c646d37d363ade1a6ea578920c0c1a97c8267336db7ce49a9796e457f1e66f56aaeb89422f249236b0b7f2ba0f5c563caf2e41f9105f1ffcbdcccbb777d06f188f8b96bc551ccc14041d3cd1f0df1179bfe318aa6aa4aee6855545bff77f453571d5135cb62fa5ed163d805af62908b7752dd867973ed57450961ed6ff6c6b8edef9520b1076d50335f88af096a1e1163b4f2ad9046ac2d171ec6a73d81fa8e68a46256d8132dffa97937f6b16db397137e500d89edcb14cf86d9737da379a836d00d592f9132f6b6691553c4a9f42a83cc26fb54d550cd8f952ba4bc8c7980faf44fdbebb49d5e82c8eb449b9715037733f824d0a9ef0c6666fb102908e393c0301ab2e4cf573891341de5636563688d894b72ff16220540e2352885a0e9a32fe0965ef16d65a22a8002aace5afbf704c1585fce85271f47fca5c35684b0d951dc811940ad1cc800bfc12916ef24871f370df301ebbf6767a33bfd98af7b3abfa15e87ba0a28df08be376bc69f2c993ceafe869bb790fbf88212fd953cfd674932de311e54ca03719a390371e6dc220c55f3ea2494ecff4456fa0995919671955d736bfab9be80d18011028238d721a553c160c3efc7462151ba959719fffc596de583cb8686804783c8829783025d1c16ffe756e8f773b3fd9fca34652b9ab93dee7b5f86ea8deb2ba833024292a6e07c1498448bcc6aa1163875dd3397670a9379db0d571b331667454e88ad575b44f532c617eeb2e62f97f02ccac6b3a0fb56a8d433eeb50445a8a4a916bc46a76fbca54a488365236239f6d80f7e5e7112a69cb8eca68d527cea4ce94454cd2919d9cdfa01fc4ca509432a932436b516387fee4d555f03a5a8a036402c83a996ae284b193f44b45851266ad9da068e3f37f032cd48d3cf449074b1ce71449678af3edf95365a269dadc1fed34333449e1c87b3a20744d0b8179a3f410807772648fff42d2736efddadb94ebcb9d99696a9f162797028e794596b39f62e77d7eaff9c630324f625e67908114c195fbd93dac7a3691ce2f454eb59ed3c6d47079a78c9dd5af05278f6104f9e224217f01e49700d6a09b12dc9c420cbb9a035b56752b6c129346e3e6aecbcbb3c5df5ebd32e17f16896c832934b3cf23c9a87f6a83670f320cde6757473e23a95816ca77fa99a1d2a303987f2f70fd662dd96f84a58332cc417a5a426a496064d2b98d453b33b043559e8ab5867f9bc30c31358aaab68970fa639fc15e71fc311936c6460642d892dedec8ebbce2be817e13529a28f13100d67a4b9131d6bb2314c8f6b25f9ffe1c25c14445953003b98b4db208453a8b8f2e856b07bb8a36a5e0fdd2fb09130aab9fdb68280e993265faa8cee6b145a54815445131c582e9db6dae4794905de4ec85c168c5b457f7e0dcabeb23095838bc1da1d0daa28be6d47f02e701a96eca17395947a60818d88cf0d96555f338d3887fa595fcc404d77c7d5d329fc50c2b0eefe836362b8c5ff52b73e3f6fb48c4e5bff663428b405e37188d627c136e2e175b5c0d63e9d09417e71a8b26874fc9da3ab4e498ecfd867af2ae839766f9671bfc8f11d5830ca10d08eb1458b6913479a190d8e91e37c1a9bd4a360d739ad6967cda98e2575d4156e01c3ad6ec51ab680523e328a9ba2cafdfbc16704a3878141f653573e3d8aeef27ec05939b88724c9c1e1f19d796804bffe83e63fcffb15c3dd9dd456a25fdcc6e74ed785a5ca0e1a69a2a5ab3b4ddd777d04ab32476f8ebf77c0cf36355a19f821b57594bed2af89229af7ae7cfdd812a5431db71d345f81734ddc4cee3e66f4d54fe4eb95051551ab4f7dfaea6c420ff50ea31c42c1da7b8a786e594c5ca2cb53b326f8542666b5b42ddde2b4145ecfa019e1d86057ae48fc0a7d285da931350b64eef1da09b2627138017209b7d24f8829b008415a86a2ea111216962412668a381d803c8a27e69156fc0e309f2d4b5a13dd34a055a6051daf9728ad4b87e07db317566600b41f97b853cfcb5dd5e31dc35e5e4d5adb9a0e46a7176dc7d9ccfd391a500ee9de75d1eca94698773308d41f7acfb92a6e6271db634dbe29f31869a9f9bec4dc387f94cc9c2a37242120c1be7f30746c63d19abe55e5b0343767ffe086d7674ae5b7d7e95a2cbfc262b34a99b00e25cc6024e0d244d33fb33139f5eb8cef702114e81ded75d1f28f3ad7255dbcc278c97002e7d12991721edd91ca4ce83cc73d0bd627b7722b501120ef4d9d01d648c7e1c7f56f5d27622675b3d94ee04330961a9d01f4768da91736e02134b0f0a6cf270db7d7279252ad8ebb486536e72b081702cb8c8fe4cba7772e78879238a4fb51841fc14d27af6d4ae75cc3dea7e331339189876200ef769c96e8c7483c66526585f36130fd9a2e8f22001aeca79a5b8177870e2217323752c64c3ead068e4113f447dd2208d185928cd08dd78791c5c519caef92a2b203acf2cb474d42ed4f67708b543784d380d15be6f4ab70ceb0d8502ec7e01b6c885bb945f06459a342732304bfac13feb4b141e42256bb9cfe357537e735b3281784a9bf0fb4b587bb9e697950c4167e9b0f19916c5762819214b1d19dedfd470e609938d10a69f732bcc6f01f4a2cd0282330f3b28399c8b784902ccb941edb6f24a3f865e78e96e8f8d6f5c42b2013c3351c4ca9f6a3cac7c45451327b47856e0e9a385a4935f02196c84b5d1886cce01718125b6ccccde870b5847c1fcecfa59ba9b659ca0482f12d025155126d79595377e16b85724f58c4877b2e9b334cc68a89e55189dcbf91b5fd99cd9a6295d0f40b6afafe4e745265e010c53198b710f803251c327d9d38bbd297e98f66701a268b27d87d847fca4ec6049c1344a83deb85430e7cb35abdde6d637b266b3b0921fad441942481e2167cf4a24cd366b4d49a5a035449fc42c03745b1c7b6fcc4e3db8c5b87ff2271ceae17bcf169e0abe39f93356e501eb54245a660c22add62a66e91dc599eda05a316ddc5f95aaa881fc9cfd4edacc2d4a1c6314e84a6461c3cf04286aae8ed8730a5d6553ad473fc15414d36793416dd66560ece6b4f1f026744b3e4a2243892ec36e0d9bc68bbb0a3dcea0d224386d71e6924133774b25c4ddcb9304b344f05d0e5291207b5f7f9fa4ccf9a4e3b879e8985a0592ce85d907e09e569f1871ca79c9a20ec4bb61c2db32d1143316eabe19f47ca6fc4e61558d4a2c519bf37928fa487439d29c2efb4c7e37629e90f09258fc341bdf6326c81418af56b0dd433c15b973a7427bc4874b39b06e41dffde61e24bb0afbb7da404a711","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
