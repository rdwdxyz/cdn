<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f631bc33a81f4f485d244bac1e2565a322887712c01a9eee431a0abb6860fadf61fcf015f9daf80cba28d2d79e1bc2248734057269aa40b846ba503c488924243a2fd8b31b68de45bdf4ee40e567615e4cbc2fa0fbaa9ede5fa325d1ecec1304041e5c92275068299f796ba1e146a5da2795fd5175065ee339d9d6d762faf2eb0ee2095def2a3479aca83f52cc35eddf4228b882c054778f681d998520cf8ba25028cbd3855fd64625c12879f57a6c99bfee397c342804ee519a3e1f35afc98f355f1ebbefdb0c19ef8f5c8d71007ab785f0333479f77003520325f2a9dbee1093b433931f9a593b4547be7dde93a84c27884f28f102cb1613636d2457313aeb1afce95df1dec5092ee27165214637ca5d97125ef37e56eb43cc7e3264d51cae94801d66d7275f95ac60d7db9a8aea366676692979e6c39289cd4d4df790faac05dad80bd38c52bd396c1fad8f5084624395131b696bbb79f891ed4917be8d917fd8399fe5901e5555d5a8e35381845b8c8c54e45453b12c8c43510a1a2d0e8e3b4a568b9688458aefe64bbe4c8f8c2dc93bc52e012202b01431af486f554f570632b592ac58030b03882c9854c95757b120a3f40fe1b7981d5c67e13b0bc71a6e1d13aeae550d0269b0db994235b947d990f87a0e5c8700ef072a097ae007b4f2dfc8ea778816d264a985a20cad29c77ef1f355f9b89dd9e709e8941723904e11c25ebe89a99cfb4962ac699e9b203772f6aaa0ea72c1cf6dcc203c953d0e5d8017fce1c6907fbc378517098a3b70c72217689eed7afb46de47670b747476196ff2d656fa6cf178e87839d46871940a6e8fa7ade4fdcbc389206161a73b42c4c3349b7b97a7d89d7850d62933ca91d64d0f72b2c11d4e2df6aeb3499b09aff61b76d395eceae209857587d96f4c5b613204acc05f99a4c88d6da9e99f02ce66a0904dcae1e071d89f13f89a5eb55c1fc9a316509cc3940fc4fcd7f812e95584c574c19761d7efff0134601014f956e8e708d70d3e3cffd07a39a7643cdd430c74b9a221e315328c7cb5fc3951d6b9800de3f45a8f2bd1f985d8b561c416baccb931f1041a8c093a2ed7e25b4dc0dd9aa837c6614124b6a005be2bead938cd39b48d792f1d0d8453cb36599f3871e399b0819f8e68cd02f24b61752f0ad278b7f47b655a4b9b36cc7a608f5e70136356e24b40d00e789e8665d368221c9eb2617b250dd55a6aace7cd060ae8a905b9e8b32ec672b642be4e23714a000c5b6303102473e0bc656946f2ee00cda80f095ac43c39b3f46f393f3c48c165cd2f91960f75f8ab35ba3f9966b88cc3eb43ef0e9be600f143339d72ef8923832c4a3cab3700ede46c2ed8a37c9019df24f08a6812a0852c20e4330318d14212299f26e8452d8501a2037eff717ab6e2b982526054d3121539173ff114e6d911d7f6f532558b172ecc396d582f610f1798929129cede30c193af34339c505b4b44d4010bef34792b43c7974a7dc19cc1bfd176ef0fd6b2cd57fce2d8b10c01c0296718baaab41305be30ce5978b8df145e7d1c76c863b9586933b6f6114e6113e7fafc19e2b513713e602d4b317e468802585ea4ca56c3cbd1e2e2ee7e2e16bed85cdc845584444d2f4f27c5ce573615acb9766d2d585edf7fae5ad5d7b20e4f8637c91ff80f46cd960150cc7294ceb6dbd1e0d634551f1bedce6c139d4955bca7ee033706bf0bfb085d3b866cdaa4e5cb8e2ee5a71af6591e8ee78aa0dcb987822ae61f0bd0e9af879e9942892a77a47d5c216ff48f5c27485aaa07b63a06466ad628243d23c8ee1bfdbf68badacb69cebba442e7c3dc54f2c45e6921229a884ccae8bf59bb8a64b9a01ed9764eb95df39d5648d36bbd35de88e8a8736cbed0e5632102cbf8582e446de8e82537e5ef8fd2a8a8efcb63511de025b4c92530c5c9cb3867a023865b43dfb0e044c9bf615cf0716eca0718f91eec7e46e2b69e3db3f4c46d890c69f7f0c3007601061bcd979f00444b9e6a36e723a29ea89c918d31208bc95300a396fd051a9281821a9205030ec859a95c369a057500e59adf5468a963ef10410332e1ff688b161e3b8beb219d2bb6bfb37cb250e8cb756c3106c3e79799714e88c753d29d897af59ae6d62031da30f358ae0f72c3eef43eeae9e0970639c0e9fe03f8e6a7abc12120b11db24aee7cc00c0ed2046f59da76070319825045449d0cc0bf08684aab4e55abc517cbd3a353abfca76e0edb1302709e5973c4f48843207fd189645ec251b9a48db35fde250b03d5830ff891ca0ff847b0045c3246cae5edfc64d4bb753bb4ac348d1e075bbb5ceb12f7f8481125d0deab98bf141c8ab0defb19a13ed01508ce42cf99dab91b6b0b77b3e6b88f72b9dd6424019ff9cf375a0d7371475cd99bc7deb1cf98649f377309ce6a84dde328336dc2a07b20b09a84e7806768b8db658b03066065cc4955cece161fb297d40890f78adef642695e353219f25a904fa23aa3888cc2780c0332c56db736deb5b2fbc8ed62276078bdc8fcf3b94b98f7fe39d3aec881d52e6c7dcc66ce977f49cc5f620b4a2ef9f247d3895f13b71865f95e530b796012c6aa87ea46aa5a1adfcf3b5a9fac7612639056da6c301d0d5e6d279bca5a09a79a9d5a21ba21e97cad1e8410d7069f9f3a9679315c1e826597c084f0e51d247a5dbfa2555f21bdb3616b9f9e6a409bb6500edaaaa527fa15ea7089028fd74b023431baf60484c125abc3c29112061f0b6373f22689793b8883ebf1de5a60681af301538cc49b170f1aa32d08ef820f951cf0318e7ac1996e78d1c67a31f343feb63e1bfaf5ecc7feb1886060f83231200a65dbb3e3e173246e17544642ffb4fa17632cc3c650f603a55071813f02943120ad23a0006e21900525e1029ae7c72867a3419b50e22dbdc0cdc5264087baf5ea024a323c504fa31d936a8c5f3dfa5653341c03b93a6b72bea28e0816c998211a956bcc3b67ee515994c89b3722e80abf51a3d4719343faeb178c193d4fa803d72a86b7e9d81ae0887f97dac77ac340c5761a36bb5b35ea72508d1ec7fb3a793cd3a2d2cc08942b87ec0226a783ce6b314428d60d3f74f58578d82f67d344422d1afd57817504787e5fd353250736cbf4cd7cc6eb88cd5ad2ca7da2e164cf2b1aa6adf23e999cd72d5eab7016c7b6c27e688ffbfe7650a9bd1d45becd630c90f9d5f3928835acb4fdaa4e71259f44d570327f76cd4bd4a2e68173155f2f1ca57ebde50f318b669daa0112ef39c6a24e7131027d81ab74824fdf07b457ae24c5ed9827b699e43bd59fca0b259afb113075516c0f1ef94979f3b42987189122cb08ebf2c1fdcf17af532af69d25fef8b48d17a667236d1e85191acf0920a47b6d0d0ec9e3285295c7e037fa06737c7732fbb90b5f8017b0600d2cba769a76e855e5656c3376e098c9a1a882e4f33ea32fed9691f2394ba0ab46055e6a14a5726a88f166b9389fc2cb2541b278b7c04e56e5ec87f0bf18ad9783d6abf566c2b2efe84373b9b5d82ce9f9c4bbc3b981b5da94a1375d03652a157e145680a36d3dbc0b17cab4166e5a04e3d71f6756e050d9166755c2ebd361242423809051d5ea1b5bd5d11bb093223ba6b8cb05b4b846c6f797302cbefbd2fedc3b78b4e69234187c70883609c1134e1be7c160be01aa1bfafbecd1407d625c84457ad16545b40ff5bfea76dc0c71725f02fb62e342d29b9885075bc27e5fd6c53495d4e44161fdb52c2d21cbe2c94a6d64d3a4672f60d2c7fd162041ccfb365cc48cfdb8f50edccdae632e4a89cd6585822574eea14e43d23f8f27d9b120d035ffa4cc1e964db2b4d34d4290b6ef9c5b9d862c820c7d096e8951e31e5195b1548f963af07078e9284922ccbc724998895c35778571834790bc2eb2e008a34b52983a8a7dbd3039ab34a26c7cafdb03299b33c0816e4af33421fcba5090e4bd3af2c541ef2c1bd8126a886ced0ef2198a1c7a73f50a6b49bd399fb0e6a2901b4785421d3afedd5b79e9f67396bdb95a507ae5545f810c50c4de362421589b54ffa39c8bad213d97fe3d5c38d391009cacb6cc978d14406f462c174af5c4c8b05b14decc0de07b8d47cf3130de484976484a6900092774a811a0df401185e60caed0f3d8c5f7e1fe28e0a22b69549ec935dd5503f6296b35bf9784c02efcb2d337fe48ab0fec73ee365ffa0af43957578d9b5a284384ad314a1f50fd01e962a863fe02e4977823c1eacfd2ec842495b44f191ebb58b565eee87c5a240fcd645718460dcfca736f56139d0e620312ce20d8eed5f00c947af2f0bb7f899bf56d34612cc9cf0bcaf8ceed58f4600a2a65103fa116467912bf058cac8bc866ce755cf71b76b54580bd9b4ea9a74ae81e5743f18a75d5e2abc1f3abd89a838346f1967f9020feaec8edf7f012291d5a203a41721e747e8999f9cadbc15cfdfa172cdafc317ab21d31b3d4be8c3bd707e28b5e42de5f6ad6460b0bc1ab66bc3a85dd1f06e4cf9ed93b616519f603cbdd44f6b945268cb68158dbb24164101e67e2ff1132e789c55d3a758890ab129b844ae9be259b6a8a6515829b36a0961f2c205c65f428a781a70e90b225060b064d54a7a8b4b79b0b156eec4feda60ea5fda6b57a799b79867b770c41446ddd8b9c2e4ac6360ea5195366ee69d492641db30b215fccfd6cf16a3d62e43fbc6e1434f844ec43da0f1995e372dfce5d9c55ada9cb8b6161a4e8a06a0753873e4f28c3e8d42a96fa5ba4ccdd2d255be24127b7248a7d5a7e9804690a605989c60e304935526c1a58c28bde6197eaf5d4062ac392eae765bb349d84b86e324fdd2928718139598e78bbd0cc5dfbf62bf8529d992bc0c142d2ce8112f603e4137c24abbed45129df8686022e9a0fcca4ce9e43e90a1cdc2660310ac19d41029cd604faa22ace3e4e28558d6c385a1183ae8ccf43a080b83c13e7792281705ab2011f84042fd2f0a2732fa09c9c3e4369e35d7f51d832d9d89f5415e540ce1529fc428804422479fe5413dd2bc11dc071ff668aa5d58d194d235c62014c8734f7b1d35a0a030352cf208920883a5e9622e7649bbdf24eb25b19bb4085f753987e1bfc7f500cfd0a8ac820e2923b61d4470504b3d5af4a5399c7ecdfbfc72fd393c58c26afeaaba09ff1f555c80cbc7bccb6184d49e23ac06881261c8a7eda66c26f3a4e00e8ef32e00cadc30793d1d6c5f33948a93b71add98ed58f86942e93872c64cfeeca287494187b6319e64f1e62987520d4beca803697e13a51f84c8e8e68b781362a4a5faa8b28a3567a1eabc1d000c9e19135b63f29c3624df4aa2eb5c74dc974ec9a533f5bf1570c6f7b45dc6494a2c81f8699d92ceb94d39a7d98753bc53229f9256c0991ca9afe1278b89d491669bc059bfde54536654c9a3e9245a6e5496261c9cbd2f3d4a55e598affd37ce214609da3de9ecbb6f0913961a4bef08859892b917a807b7ec95b3983bb562196ab688f7e929d7c2103b15fa35f252f0ce5d657b5d2b7eda36fb3d2b423959a2aec753ec4ef4854b637e4f943842684bd6dda87a00685afdea6b3bbbc3451f6004c0d5eee3ebd8ef44d69cad8d96b5ce0dd2f66ab933357837cf0decc6352290d1762a13b4b634ac5c20a6b0c5a53e16f3e799ffe81c0369e884f57052be86948ed7961322ee8b6e1ed702b6e230b84cfbe314ab8ac4422c91dced5c652fa656865b9e459f31a5b517eef50aec94b518cf0bcc4c43d5551080a62a23d9b8f7dc56aa647d61064ecc6e6d7a01c23f5aea4ab1d8509dae1cd413be3fec6070fc41b080d53d57e42bf9749fe24f1e270b41ef308d5db0c9f5cd9371a9d09bb6393f7c3dcb5f2df4009ed5cbe093fdd9962bcb7f728e2cd72b2538d3d45dd9b68585cb593d0b0901206cb3c5d78aa0ffc79bd55c0274eda838c822d4c8b9e7ae61e193d2442867573361ef628a6f4106f627a86ad605e1c1b04258d0fef60e3105559c25da0314cbcfe5d52419c1d7077d9d4b6c1712d52b6909a3d6fe7f7fcdc50fe81e45c7d3599617e888d4ebe10329ec44d8e8d0ce242885d9282966a6fa079b40b58f199fc6e4c5f28773b350008b9983e281c320730267b5ad3fb7a32f571ca0f04190a12f722f650073b46c124ba6c01f23f74dc62726da7b9923484f2b57087e9a110d4a50be1edff6fd2aefe7bdaf9d7dc8f61116e8b55f7b033a206e761cdf9f2621e81684d11424970a9f0a4d063e2c17aa12f2fcac0dca8597776c68536610442f5b121d31ac92d1f0577c6393ac3de980f074395ad0f26d8926e226eaa5cdb17d0bfe0803727f337fcbaa25be930b0348e6a039d187f7b216f7f5bfe0f9ae586d4b7459ac06909bd30ab460798bdbe1f90d5586568b3902688cf941d877557521e67ab56af3d9fbc641599ccf132d559201dfecc83c8d0da10827382eaca801bda9f6c1028f49fa90875b0b8646c8fb30f06fd6e030a2512ec4f1801ff5a5f707a580a987e5108fd98ee73b1a6bf48ff44ca2e4ef6ae80ef261ac1b92ea7f789f51de68ad19ef5cd6fa02b95288644b941c0f4e58fa5e4422751111df1ff628dd86373f7eec3d2f0dc84bbfabfb8ba78e178f05756be44b1ede7d4cb8cf01187cc282382844a970c2a748fb557aedc1ad47f984649261f5ab8babfee1d7aec05a84300e9812f50a32de5cb4ded07313d9ee82e4d2fc0808c4ed624e6e50cd27aa437a0fff044c568e3d80a2b84bcba7e1a81cd7cc8e433ade1fb8c5969e4d0921e0c5ba762ea2e9f80f3b450e38c34d5cd6fd2e97c51cd73043dd381d7339095e5d86b20f8de6274d5d917c165ce84a7575b1f4db3505ccb5a4125fe22b9b3ec1e3d917ee7f8d7690e31570b25c6eebf2f2633380318885721e777a303bbb8a69969202196d39e812f75deffdb1e916a071b0aa87597bce7b8b5c91295a4e288e998be8b598dbdcabe6114d1a83ec3776c15cd9f0ca64d2b4c9f7583e656913c88e538c2972f67c79728e92f94e682f42d9b2755245febc58019ae51feb6be59917c33d3be1bda8e2a094611d589e1716ea26338151770e7f65b1b9bf03f3f2e9b7171ceff839294ab41a904920b8d11b5b83bd25ab0b34115f301e4f0f4a4e3824127c24c8ce5f98b3f0e4b198dec7d946a232f0475d208b3529ef8a019eff89574717efde98211948512f90ab9587a180e27fe907d0ba7774f7b95887e014d59a7713322a5efe67b88e9b6cff424291cd0fe4de85fa00d3f4f543a203dabcaf7e2796b8006c54fece82197e87b7dbfa71a1238c4fed5061c187c1902a3c5f7e5b38aef5e8246bce1ecdf127d3c306acb5cecb532528a1565ee6f887eaa39ecc5f10b8043369ff8234e568458d85748ef776c602a36166823638baca836c12fad13f9202ac940c79b46acc2cab6283d05dc6275ee461816cf45e799f6f55719f704eb417d9ffe630bdf023bc60fc163e7a20ce51a66545af0cbf542ca75d4a129a23650a2ecc67ef899cd14d43f727587fde2ae3851c8936bc6f2c123a1485714b16c305220348d2d1f4b8211a13a0d239946972dd8e96bc61c490e019688ff2950e62fe8b70ebbd9603455df80e80dfd4bbede633ed998c167a480750818e450048a034c2b9cf56ea45e81cc3dc45b0eb92bd3b3cf37cd82d9b1d2625167e8c3a4430aa48de7e2c4249c6acdc2c52492491acd701af3dd7373586acf7a6faede0c94c2730b4aa8c62b200062935753e795862916c4e7eae792c235b1250329d39730be8f4034191682ca77503dac4531adef2b60b6e7a9d5bce8b08ad713a3cda72a91ed96d3df53b6f16f1db9d0afcab072abc58a3c6e10b13ae730585a38895c02fc5af69c837275b16975f0f396fc5505813b71be421b280998f3a8b79e727eb4662bcbb44019505836549a540faaf106b8e34158c4c5842afa3140d5e21ec25cea41b645c9ab7275e75245c4e7b533b993743ee9da9186bc772e5c72f563248fabcefffd08e06cc4facefa988a5b40e3629fca0b276911c3e3fb3fcc293d2970dd25c5d8845993e3d4e8da0b16962b3551e144f7a6575f598c3f34738b2b6fdd5a7c0108484129d2a9cc97785f15690ad979b6e02eb851e3b07e81044177ba375bcc08a12f6db9fa770f247f2bf60c465f3d26bfe6e44e2ef4430c4f2ff4c0e20acd434590a7aa27d7647dba8ea67a280d4ea3d8fda109d300ffcd9c50435b7cf7fdcfe87209ede58c879f761fb17bf8646051109a5ac7fbd2c37e25a35fd34ee23150d2a15060951594fc8f89940445be57a21d5a9b39663e407a167ff7bd436ae57d150491d96a2d077403afe6704a8964a4f77d7f3b6cdd9856d975f0f0ffdc48228df3d5746dc9894094fc03f7e4ebe45eac2a28f6b14908dad229d6f66ee04d5b15668383924b2ec47d14eedb8773e5bb10df46ece2b31f6919b5c66c2e5cba2e11e2b270f041f8e7453abc206dc464612f3927b4767fd5bd516d351a9e19d0118a150827b4851f08f864ed0ad52c1ec75c805f484aead35f57c8212c2881ee5ab5c7f1ccee7bfca71cd78730a175de8307be2e6d7ce4d75f239af3f01a7f6f34da762e6a05cc92d9877b2d133863e58864a1ed9b45a48fa41534565fefe4546551f32521cf1c25a6ab44895d8027be484d60b406e0348beb1791b2c47a83ddbb9f3c142d3e3642b8a2cddc159ed406a320ab75709f70629e0870dc6dd0f3f8f946a17d67a3309aa19e19bd98a2fbf0cb1a5a6ed6bb87b27cbf7228143bb392f676aca00cd6b3a4b501e39bfeb229f188fa9554097bb45b5dccc6cef5bd318d6cb784a66f4de56ebee8f7ab96f96af0b3628176723e8e26afc77734aaee29c005ff2546978eef63ab1be48ee307b585824f8c0378029f6a0a0d4618c783d5be4e65c5835037a40c7cb8a3d18a41b455e8dc53189efd021a7a7ad26e5c487768990dfe3681a6d16cc0325e983b3467b606341186311c56502ae7c172d87ba6b6677b3a3dd61994f1baa7fd05d7d90092d83b2eaa480fd661b32869ae9c675f2b1a8544493b17747d5dab4d793239b26015534fba87dff11bf4eb72fa9e8d571ba85a8b4d02c2bbc5ae5bebf5ae00cb54260d5188f12f268a099d02cad81c13c661208ee444a4d5d22a17b85259cc40e0691a128a8954ca7ae9b7e9672e6ac04747ebccfaa56838bef24086a8af6652bc43f3f66e859c0fd419419f12a8b8ade834387cd0399a32b29ccc534e78a51bca44da74eee19965d7a40acb48385c328e620867130c0fac5652d77776a6c8d4d02aef550ee8699f61c9dac91f67e93c09b3e56a9b3c72f9f5af34c0782dca5d17f3bd484995aaeb828bd9681224f1818731b76a44a4042f9d4e8a6e0228d37db82592f41711781a4581de5ca306707c650617f42692c7bc7484f96234a2f69ddc6000991d588543c82e18c4e4a2ad42c3e30ed304a49fc3209240c4b5f4fefc1c8237f9ceac5942b26929df1aa68228fcc6aa0d8cd7abb80e4ba5876775dd5819206435850d58221576209487fbc7eb7a164d75e76121bf310b66af01f59a371ecb5e29b5a4ba544940bd64092a28b68383d0a68adbe3ddd2b17444a4a7016845f4e4ea253d029748f509864f17c66a6bb1286e1e4ac6acf33878a93eb6481a96ebf09dad070cf2de9038364562c68310ed3912dcc6e4f3c975f5eb7a2caf2992f157c94b76e615ddbfd59be9dd826d417a789d07be796cbea2a11e40f4fde2d79f36c744375cc977a62f662b52df038ab4d92bbfa205138650f16a06e28f34c75966a9c1e1e76f81f464354c77a2b6d1119d5161b15f8848dac760742fc2d669e966e5bfa66668323bfe8daf0e89ae5d34c6fceb96e3c09dd6c4014c8675fd54de102121992260fbbb48fc7b72c18f62c86536ff045fe2c78db9fb94d4a69e12190c996461d8bd745054784404f2ef2b28c6e06acb807927e7d481a23536bab46a1a466739ae503a67a04676157da40692b928bf55ef0e628cf487c3a3e306c7d32656e53c449ba08fd9d701db6466b045c18e72657649ee8045959d3c1912ce52c918acd37a562a65afeecaab42d789c73ec27df9bc5beb0c8639cd0fa8a743c04757d81a39e9273b8e5653fca35bfa2d09ddc6e42a7bd389f82e89817773e341c3d48501669ddef715cffb14121086190250240cfb906a668986e5038a6cb2d14c10f1d0837903beb4a4af5db33aa2b26863d2100bf591d0fdb58fee967e10cff64e70d915cf7c441843971bdad43d803811529f4b1b9b92e0bd6bc429da4026e3895163640e6e6ac3ba5a010e3f6bbb4d97fd7f1271555f83a7a1f48f244850fa859e0a24bd7dddd708e59bb6731a5493933a10f55d449475d72e76ca2ef7be7c9cf3cd617faa4f9909da404b71ac143090b8a0f6f1ebdd54f629a4243b269a1c7032677411148a4d0070bd4321b4ecd059e8bc36157f89ad432c362fd23bb1425208bfbdddc494aa923f65df8f8776a75919473493c66eee1140131c011abc4080e843948e104a13265e81ff10a737170336f750f631a245c7605f706fd8a94c9b3ae93e290c74b7d79c14b96cd185fdcc4e32ea703dc9d5814e0f9ab3b109f21245fe3ae1b3dea8b4118b2975f7a33d925a126637343db5afe782a8868113367d3945bda20ff4bf807c18facc212384854faa57227afa3193efe12d7b1757a114f4d2ca7d9ad8d65d06d108c6e57d22d0c1573ba36c0b2d91f8e18873675496fc2c49df70ade4dc6756360fd1ddb723d6083baa8182f3cbab99f8f16c0f556b50f308306435b31077de95735e9c6dabadab91fe67d81568a0aa72cfd85e0219efb53e8116ed69a4adac33683bdec74c03149e9b0a9b26d13252be4511912244b2a3f511a5c16cefb202a4252d5161da058ff45a9614549bbcc6b6fe9a89a728762747e6ff1652a5f26a3d77764974417062388a51b375fe0391fb59358d82edc46882e0d1a70a9f41ed515d54a0f0246a7be7f9fc7bd3237230d2c329dfadad3b087f2a8dcf769549ebde65618d47369bd3466eae62a0481d6f0c485fceae60aced575d64b0b4eac06721070828efd6726dfd92ec85ff686873058d5377411b2da4144577a8d598d0d6a2a9c08085b5fb22c75c3936dddd194301c05a62e2acb95d4669258f38b1ea9cd84906ec4f9e3091ae6b76b655ad6e0ce4c95a59cab01312adeea23ae65ff403d2661438699d014ce9d4051e1f1e2db1767d4a7fb2f89fbe1b8f922dcfeb126a81b59ddfbdb912f1ca2e314411d9613ee015050a2bfde627f79da26b62e500ac52132a58b546a2bc3b8e06d515d91a8a556943537f3b5cb7105003d6fbc0d067fa1d7912de3ca3d1603b9ed470333561af70ef8bf3708f39be0bc7d6de93ebab788ef2aa0f44ef4e7cb9fa5c5bfd2af779486b62f42935bf61595d286719e5b6b55bbe3f6dc30d6084324ec641f00a4b59cf9532d639d70a4103e254c2ee83c0f9d03f81a06c49a9a1a3bd1ff72818f673562d3a3b779764c5efa5bc8ee157dd47221e4ad1afd41d4dfd28c60e00a5b8835e7d801f040c40e623be1056293e191d54697a9c41803439a840711a6e4419f17153530dd6a03163a216f0dd46a667bbf3cd365156f401de38d3a27ec2e87bd843160663cea824e073a6a98a030fb74eae89ebb356d41c4976fdf2c6d1c333a8709bc9379bf65a10b531382c7ff6696b46a5047c84de82d50ddde3f38f2266cb3cf05218560b2eda098d36157c9eb011d452831e51ff98ea00cb2b2fa8c21699f4cfc78504f441b887b6ecaf7e3b483adfc459a305827c88ef2fca2bcd308968837e4574811a5837e13d894695213d7b36c9e7385d4a10fc7be65b9e432546b0f5966f910c8a5fbf7215bba6f513f4d3c93038a97280fae1fe1354a082f67b3a47fd1a244b357409f315e7588d72e62e334df6aac40b44499d871351b3e35a1f7073adc61494a1d4b273cda3cc1b46eaef6d2f3468b5f68a562492859721724b1e826e6ddbc25d1ee8a70424d7ebf6158208e7134dc568b84ef5cded225d7581b2735e8089642aea3346e1048f2e4460e1c44790e778c1b78331056e0cbcc0ac9f8e9bb7d8bad75b19a384ab49c8eb7990f9057b2e2bb554d3ce61b9a9c1b0049eb90d82e00e558e0c274777106906533f1712ca611e64c18706c9d5b64b7f5ba5ea18b6ab3e446ae55adb65f50916657a5e3296334712e7ffe2525dd958219eef1114ce3477ccab50cacfa61f29607bb459aa1e3ecaeaf83a3eb4d9473d65886bf9c2350079eccac75b7803744dc5f78f5605f9867f902614955a296b70532f409c93219c2da6aa918d77b8ff196cc4e63234abda2da84f736a477a1a2debc9a9471abbfa4de52dd4ca94fbab6b2451ae0b5481eb9f1cada21027d58e6bfe4b7de53eb75a5384b24dc7b46822ca6e3c8910d87b86a089c07dbcc1b054000f417de39b13f4d9bbd5c6376978c10204ab40b65606c4d900f998820a571b4d3215d87dd14bae76e95163dec120edeb15fdbc7356ff26a5bb135860dc386361556d8181a0230595560b794a7f108f0e1512d24b09b1c40c33ebbde97888f9f3f8f609e0c85ba9e71984cdf8f9b0dbc5f260193281078e0fefe6ee49af1354b7c80cf672114cf1aa3ca68803ee2bc1f2c36bfacc6071de891618a2b5392b7d3792a5135df53dacb88f8467cc8995e0711f083951475aaa0eeab5992d287047ad11b1612e180ec29ae6b968734532339487b1cd1e028a7c4973d053bc559901baed72e6e48d10107514173ae56a2acc188f09c2367091c6f70fc34ffd548e7a9f1ffb072e9f4e782bffff514c140c215f6daa92291aa5833047bf3246e25b43b15fdd419a3916a5c05848da351cf581b7072012e5c0b43039cad9067f6778ba49fd365c025478a0b7e0f9e43b8d4fbe81d8f4d536581e9026e0caf91cc72a37799bc3d29f72f1e724bc32ce7782ca008c0cfd37d9d6f5ef54cf20bb692685d736d11240fdcdbb9340f9742a781b977894770004decb4d861895d14bbe7dc9510c0aa96a199ab09a272ad571a8dbdbab23a4221e12c291d1ea55c7ae3b7032539140ec1cb082f0f6a9291f242ab2bbc1405bab4047515ab0861a9fff5b6e148b5e86245215a8cbfa8f50917cecde106583b18624764354e51f5aa6d66f9215c1e034a2429ed18b6fcb48d393f331881bce1e70733fc1ebbf5835deb6351285775357639a553f5c40a54d58ec00c4f1ac48c8e9b99e4822045079431816695d6b18976b928350c7593f47a14333cf2f926a41cbbdf7314fff2f57e3bdaac66ac24dcf92f15c316ca7732aec4d71889869553bc7bde8dfa80775be93a1686a15ca2f80a45fbbe28db72155d1877648575e2597d14b6608a7f8bb5dcdc604e661b6c30d2ead88da874b80dcb4d6db0b1c303edc02f632f4e04ff5b047580e61b59f31ae0520dbf4cecd47478b4fd5760554d70a39683af4bf5f4d768d5348c5a317a5dade98ea4d735c40c4af03dfe9bf1bfc5fc9c73b1f806d1e0648db20a6fd7c8dceeb3dfe2f7312407764fbbd7b71a522d74d4f2f7401556194fbed1142803e98d733329e6019f56cfe718437911d7d4934051b965682ceb9dc07e73df2dd0bf49bde690406ca56a5cf422d45dc87e173d82db854bf990427dbcb69963b0f2f87aec9c14f9fe0c0e39862514e5d9eb86726a1d5cf19eaf1dfa12e2fd41bf898134e64c64ab4dabc563e923636c1f235e1146cb0973b961e5997c881db1822fcfa7896fe1e18210e00fc570dfe703766c834491877482bef8e2d76528c5d936a4f2c41540ae8f099831d6d383d242d7534b1511fa815f2ef2057bd4cbc0529cce385f81831d02cd4624f93dc7212823b07d183f850a24003ace0a3ab2c440a18bd5f74d6be59c46dcebf6e4b43244ec44f6e5da3263235a9feefb9e857763e6f9efd3a85cef794c9635db4a3a503b1f5296149e1deb9b770f81c11832272359720c0dad9a89b045470dfc0038afd1e8a6d0c396c286d3cb61452acbe69323b7afb9a3e514df99b6d3bd3181480b792462b0f2a8131e606ce593f9b25f468908425366b94df84b55e7a3bdb84766890b38cdaf36350f97d7b3c1638e58085e25706c98d1a7a9eee26feb353655c639a1428d16285334dfdf05e9b4a5be62250deaf9fe6942f0d99c8031d96646d439fdc3d23dff12fe614923b73b388105bc98f04793f53987ae2adc9a0ebf8bc7b86c4604867a315543c22d19dee52fce03a6f9a9973c2c742f6fd4cb700431a5b3cdc5361200a669b90b3236b27a3cdafc08f942024afcb4d445b56e1372f849e2b256622d8724cf76c091b45128b861a6e865a0924dffa3c001813be8eee0038bfc029affa583fc0c077b86032a74f1671db9b5f54a9264671b760347d63ec53b055a0346008370421010319bd72a6ae0f363ab1d0518f132f0744d63b5ac12ea7b955d0caad9d2def18d190191c4c3f9a4581819bb16ff1408bb1bf3d31efeed91147cda2f445ba401ee59fb49d763b896d5d068a9e2f64ba1bf2dbefe7390906e125eb5ae8f1b57d6f472c896e20283aa7b29b0818d838b2af69a1b544d26652d4fa18ce9532a0ac50d28b58be90795ed4ffe0c6d8c85d41162b8d97f8b69cb3474c7609b93332127c880d2ae0352cd5bae8f01d9f585397eb609fbd437605d8fe66effa60d994fc2ac31e4a2317e39238c4fae6712c5a7965703a8471ab45a7f7128051fb84aba976daddb926f0eea6f6f4ff8bcbc7ceae5486e1777be1ca7f9146e9a45f543fd20f8794b10aa4b24fef7ebe811839e27f96625364d56f4389d99fbce5c69a3a0c2c0ac0b61d327c5347839dc786163873f75232850993c3a4f1c8064529166d6d123283a4e4acb51130c338c91709a330b917c2c6305c2a0aa788278f48997373dbcb7f3c312b8a8880a8c766dc87dec4c243f70f5c45f944a705748b2b6fb4a4c8ea1b4161349c83185fc71aee27e4e62c96f39a531585851f34012bb8646462e43ee91f9d00f8ad56fa9fa387da4272e4dff236d394aaf14867f7e339b6bd82952eaa24301fa6d8cbc37b15c64c620364f4e2374c34a7831d1bd731eabbf2b7e189860086a50e5bed34bf7f1c683ebdb1c5dabc6dacd9ff68dc6e045844c7699773aacc51dc727e331d46224f7198f37f52c08cbd7c656c86bd3644f1f26e8f242a2dd9e5fc690285a694aa56a744bcf612cf8a5a25337ad3425e4c902f9fb33ff2546a540f7957c146f63372b8f8aa56230317d149b2241bd94945fea45786a7005a27677b6163f45ff46061af22f0ee83fea5c66ff270501ca801bd8e7c5a2a3a128565fb4e31f2d120a7f2c0b77038750470a019f8e58631640d7be37d6ce8e26c59cd8a78292c59a1dfb3b6147183f7d6552a6f5a0ab262ccb1785709aba9105afe34eb6d07d26b8e23f8dc0f8296865357bdeaa1626c71be789c3cd85fa8d2e5bbb350d1c230974d0007f232e67c9c6b689d59a35e50e467c439aa413ed04f8e3ebddde3c1bc64799c074ac626b126d5933c6c2f1f6e2abb3efbeb7c9624ab0db6d3ec5689c72ce4ddc23171562ba4daf67f5bf9a2e1cc2673631201dcffb51b1b9b18681f00b59875f3048e8885bcc288d3f549b0f0587b22ad005f30f8f5d8c16a2efaffe844fb11493372cc9848a868faed7c78f9c689d3d49b96976c8f37cbd21e837dd291286bb29aa7fcc151ee4035ca4ec5935a012fde89bca85715f6761ec45e18190a8f440434390f912ebbdab19a0d83bd86ba0c8c324e6b064e67ea32e60e9a6db767d7140f16e63f8e2a9b52ffafb5181c7b31267319361cef67126eed0958aa5c05561b0508373637dd83f5a2a153b874949e2341e9c4ac6eef3829402a8dd998efd8aaa8ac8d64afefb8e5194ccf4e0d13b8ea9c13416c43b6848800df9b368029660c011f9bd16e7f147f1cea358605e46dadb155af3c4fff9b585f02b26fcb2c2427abb8f5e9a00f88f4a6f5bacd1fa9ac10eea75299b5cdef00e167383e7cfda0b5c91b2cf72d51c4960702b5d9b55231c0ac00bc02c87e3e2990ed2f70420ea1853cff0010590c43004e45347ab99d7efff88617449cffb45f0013c67972f3133f998cad38acf74fd659773ae3f265dd047428810fb6fcdd5278ff4639c7316b4c9209918bf70db751d40357c5db6574093ec57765a0ec32af3b3bff704353c9d8add9729e73bbc92acb8be79e22c06972f937cdeffbbb53cb433c88b3babb7b66b0e5df1415fa4b12a8a21778a341ef1e6a86fd1a52ac7813f1c0b59a4bf94c690bc80b2cc8a0e37874a39fba7080375d71013c6830e350e4fc8a77650a6ed442475bc50f98ccc00ec373dbe7732b3e81d2e49bea3acf7a1eac15083eae7e27d772da0003dead173bb36fe0cdd3a393bc320aaab1ff1382ddf8cf4839ec77254b5422d3cf32d54ba113cc7742c412b2954ad877d26b6883d85d1c3ba93f55fa8dd71ab188282f8c4a99e9f919b2e3e83d80f8184ecd11d5740d4f43e7f0b4d42b62d9ace310a68c277db447d1839c3f455d1472d4bb0a402e39b1107960d0f478e568ebe18ecc3139d0f93a10261121fabd31aa881eb7d522978ad7f5bfa9fed01a027149ae39e5b2b71d9529e482f93eca778051dcf280d85b604ad9c560522356c1a3237b440ae9a186d6472b63361c260aaf61a4cc39acb9e909f2f878a791f4d718f82b86f482a349f4f200a8a983e3be44d02e992cdbafa9332eb8c905735ea573802c346ffcd448200ce09045161269a4e0fa1223abec185bffa3174945917a918f87c00cccb60647579c27ed4d1c401d8dcf1f0f041b1c0a61ff7a08a2b909cc557919a6d2c96fd81ec408ce4f5782656917e463a57e90145b075671443853724473c1860c565e718fbf3820faa816b7cacb8ee4a2eb9ae1cd3adb6cec2efa10de77503591a1a9f8870bc76ab7d4e999a62cca6999bc74435914e2f5ebe434d88fbe665cd3ebb61e80d2241b0b689172a9982b6789867a3648b310228ae851dc01b575e0addea50b53ad37e886d1af7a81c75fcad158e95920456c9045abee18b4e8a6a17b2c1f42b92e7b6ebf3fdf43c9919a4b9c4779d4b569cdab94de7b573400baf968166eac658b69f3edd4316ff8e7f6503b1dffc92eeae20405e1d747a853790e7a99bdb7168b9e5f7de3304ccac7ffa7a91e1971559a2d7d0b6e855ee363cdfde92e2dad06423ca444303a4e1ea62654f5bd9c74175becb206aba5f360414a67c5c15c31a75b4631994705e47ab5b1f0d21ff7a2397cc34c0b0609b8f21ec60889912de0c3fc12597c3c0e585cc30e9af91cee24156e0275919b24ef9282f8f6058363f849f622c0f1b798e734adad96ff01e317fb715a44c69ed8ceb6f30527069bb46efb7940eb4d863a1a0497643a4f483bfeca03995d5fd0ec136e8f10496808b1d2f60a5c00c74834210c4bf55c8ed25a8ced0569b2e8e1eb66f4b0baef737b748e9cbc7fa82da641fa4ac469d44f374af27e57a5718774039c19ce540f2d87404c47d7024f4982cc3bf2167b88ce5b2068caa4500f714a51b107409fa6c079a30fc65a9e825b8538ec6834b8b69ef104b480af95dbd0a7bef2a7e1c9ce2ae61329877ecb20ce8e4120f984345d15378f3ba4998a8f4d00045478c7886a256c10764546ee8bb30344dda0d0d797dd0988529c2e11cd891ac358b0a6b97f7299954225dd136a276c274e91fd1ae3e39ba6148d24f6951026c98b4f2dfb6490b4cf937a7de280f7e08cf3970244fa77dc4bf8ee70995e2b44e2b1a4e07831b431fdf78a4fb932d40f7b412bfd16c656e862270e06cfa956e0a8dac67023f67aae0611b7e4b9ac090a5af5e6639187afff757f72e4069ad24118781869d678f25f8736239bc2e83bebf54944604d03cf3004b9078dd34c65e87d8462d418036d2d21d71667e0b41f4e382af2006e4765740ef1957fba52961643170b674fb350356137cf0b640048018cd67c0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
