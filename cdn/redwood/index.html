<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"593319fee41fb3ad2a50e8fd38cc2c58e2a42eca28da27b1b2479973fbdb1d8d3059ef55ee4afab905c160b7282cc300cd58144853c462fd66a7aede322a375fb5b9762c8db2e7bfbf06e021ccbd16405bc053df63e99e3480d423d0f09adcc567d3b93d416c373ac1a322da85f758baaac07ffe6662ddb286f3e0a64bf6522449a12e9a94945ed8dc2553aa6dce88d46ac3bf0332743110848beeaf45bd4f141ad555e95d52c2daa99f054e4a97d8cff1b2920cf0fe2298b6af9ab95df20df6a91412de9fa20fadecaa4baef4c2d8c20971a15393054f79362f00cab900e90ca87f45b2df9271c360137cd5c778444e3c419c3d331abc72e4dbd3c3648926d956c4a46a361f7c7541179c7ebe2f5b5552a8979ba736dd6b3b86b7d2817403b0d8d3bd77456c64061bd2c0183d6acbcd7ea1487f3e44f9fd10208742430c9a93b2b11b9b7e12166d398afe26568766ea6d9df98fc2e413ba9798d18a7b94cf338355e153062ffb49e52ed2a07d2bf7095d1fa97ab92a1c572726166517ff9f429736b3f6020a0125e8cdafff5758a1c1a0bd46da0905ddc92581f97cb136f5f2970d3a0b6b4261902520cea40db85ec143aafb551790edad8530779969d9dab43583f1d426455896bc3f64defd399a194dd1633d0e768cef1f50ef60641d09031542e139d4535e88471f83c67b81f1290ca2af2bcea1f8c8beca66b3b619511027b604d2c9ac051e9fccc69204df71c2c2db62281c8a82c17d770cb0f05348d702772d0a3fe2232f07510f19d37cfc54513e2b2197172d188a401c8e9fe1e7c2672a001fe2e4c9b489d61202d17558ae2d84325c0d7b8feb28a9bd5bb49df9bbddd47d1aeb5483ac7e071ce109fcaf337736bcd57f08ee3f8a13b1e881cb4243dfe13bafe99b16db9de89efd258a8a81382f0ba416f0a5b46ec8dad11f5f0a5b640a7a27219e6f632f00f9b69a5a55f46276e647f0500a01c663322e91cbc715d8d929673fc475e32e9429f2115fe97f79885d95945f8267df9a6ca9d02fbf2d6d2787b1dd1c9d65cbcb7f8f1ea5813af2949a10824a7ea591e2e59e47fded4e60ed7ff48acb9164a8491b16b285f014f260f1444213fac4f261090f220429fdc64cec2a182d79f687c033e90be594e73223c1ea8066560dacfdb7bb5d046ff3a28cb707d0b644733383e30269fe76e846b01cb81a34781d2458dc936d813f8532d77b9ff791b44b533c0a427a8b624ba7b075d06360f0b367f819dc89299adc3cd10af905c3e52c6e8b77378ab2544f90d292b8ea563d67fd8a60c076e17c497aa895ba5f8f53596b7ba0f1ef3d577ccddc9d4ea815f32a280541ed0523d6a569580a43035f6c72699348c8314f6529108451e50be2228bb9092faab04aa9e429ced215fa9e2da5515f8962235f2b5e7c5a694cafa59b229c9d14aa27eb66adacb3fe82f7a1296e96323ece59bf4f0245804eef0ef1dc99575b90d2e575a041bcf990ed6e22d79348b079158a6d40b122d1a9f94ce18768b542e6b3602bfce2c8daf93600d1571042758dd0272e0991438072c96c4304aa9c26d7ae4becf218b644f78423aad1879edbb1224c6e51dd8a19fa62b84a69c24888fb5e3cc9dfb2c993a4520cfa071844e1000080e3bb00e0fef50de9facf916b52800298f7065caf3cf7e9c2de0a2739d53ff4eb2b2e98409cc3db544e54066f6a57ea77e18a47d640413038de005e3e884ba467e209dce81bae6f1336f604036391f5adef9a9148a3e3c6e3e55768fff7e38a545ebce991646f50b91f27c156f1ef0d0dec4f305dc0be8f38931aac1e8eadbef92389aad6bca474b0b049ad886593dbb17735d83697d9370278906f64899755e4393d5c29b136d1aca192f3c1b197b6f4407116ec7fddfc42c5f5de7fcf405596e9192188bced315eaf6f65a59e2eff6f667a5921def6d762878b8346c06d35be0a70efd51600df906576d16ed7bcecc3e7d02b479cd71a4a4b330c027f292f42ee4189be2a8607ce7026dfd0280700eced4d731287536cb7525981c322c29bb5fdd7f5c36c9b75718c8f5b52729ee9a0c9ee554c9bcf5f3d0ebf144a218ad273be87cddcca4bc60960fea29d6a534788085b960938b748b1bbbfece35ddfec27a848e91d585b8b581ebe1b7c7e551ef59da332029e94b39c4d1bf175032288ebdd464922cf27743dd4eda6e934d22de937c7cfea17c31f7f81ad74af47294da98c709754e012593902edaa2108a5ba831c2ef99844f6fcf118c2ed2b4850201235b3a27fac2810e4595aad6eab77ce621d14ef2dc9db91b0ca6e8de2116713592648799e18ef2dc3919b97a98c6ba17caba10ebd7fb71dd04e8be9a20f6f5b97d2fa481698b5d24538c11c05f4a886fdbd52a21dc3d08194371a297ccca9c6a16a9fcf02aade229533c51ba34bd5d1c28eb929fc802c64db96579b66fe13a1c424906863f3ff78ba1948f1fc40a3a0786d53020b316ee8ff1fed584116e872ed91dda4578c4d19cfb5d15804dbc83738a61e4c39a25a8d367b05d174b8e033f57d2d289bb768c77d3f6dfc70637f3fe4cd07b688169cf2a6f71e42d37c510c901329fd1d52a9498ea4b906f111e78d5e5fe531dd2b22d6d07a62f11465903fba135754d9c76b7581c9339c14032feba3ed391d5e6e9ae0da7db5ae5d4815e34757fb7a3113daf9b2e30025864557889f939242b858b1f85fc661ba90b52bb2c18c0b5dbc8aeed7d930ed3b51266ed97107224999f44e9cb6fcb1e3d899aa644545ecbf9656663ec7b05339376f980301ea972d63a942c25dc2e79b8d27b56ce16af8b8e9b369875a328e2feaa4a4e8437e88a3575601518f63841ec5f2b10cd77d685acd647e266653c9f1bfedf351d5ab0bcb772ec9719149a3ec496f0f837e1b75260a32799c9b22fa827b63ebada686f6591d3ebb5eec52aaea9e106abfdb98ea945b1ba320712fc475305342f98df02b2a42300808c86d5425cf6f82ad0c3817551dc02ad073f423a4a42897b38370de28aefb4ad7221a8803aa86e9df5b1cef2e23f4a63bcff5df6983de894d4740e889a09e4c54f294570e8bb75a05eaf3f43232fc49dede5c45ea882184282a4811cc8b62e428a226728b391369013d500aba0d3376d9fd57dacc9b373cfa61a2463667fc66e4a6dc89711b005a761c6968304473a47629f52cfb3dc32e9450a739fdcd88ee4f1bc7f3857c01ddfeff4d478898ff0c683d825ae32d5e64f853d0ea3f3d41f899b36ddfbf6ca55404df85753d038b7f1efcd415b264961e7acc369ef8dcfc3a99cefc7f361010f38583172038f4ec43c215c8c70a5727f2382c74c71a63714d1d5f55fdfe87457caf3295635d122d6d4c96917fa98663530b09207283e401ef0c84bc829b1a4c7ff460dc4136731e145e232599ebe0002d1e459b99e34c05f03dd87f95e2c04e2a637ac7a2a37481ab3520093bfb39631ec86c03cce01874d7e03e175c3e8d765c420dfdf96c4b12743638dce25df3a18d1699ee4288e21e59767ee8f9218d18112600da4924fea9da040f835d97920f9cef19c8c7c34b2e92a115cfb8b0a4208819f9d09f2258b49894113311bca9bee8d9f720389def9fc8514cb09c87df9e6f9ff69763c5477ccd3b172481397eee3ada68c87acad8a669f0ea81c23dfd8d1ab00a2200823ac80a82f09964006498de1f8abfe5cda7593801332431aaaa61afbe3822a01f285c1c61a9d59230220cc889827b92212356c6a1787a4f3e4b9ce70e06c2007265ead1bbfe387560b0ada8c9183f03d602c694d97545093310a500879cfa2f401a62f1a3d985b32a6582cd83e8971665c8c280d4a624e9b63af982dc25ede12a00a0a394ef189b71a8d7932e8014f556195a4ad5af1664490cc2481b9333459c6748fcea21d83cec03f6723d7a083d4dfd28882ab687e5b75249229995befa4589ff4e0429a5fa158d4dfc196b6744b4392b9fca91392056dfad674d60ad30700b8969475c26963ce7105a9b20b391d2b570007489fd3b53eb369b89459007a63ddccd6e07be6b5d49476a411d9b8cd1b047fbd8ae3f14d70c5c9b00fe3332b45cea60029d732dab10216448cb232d8026456fa1466b734aceafe265d84adf8b56e9ad5858b855cb6fad394a37b8d606d9ffc60e116682a85eaecd0bb0109ca1efafe78b0c10c7290e9bd0d053a14a90a06383a135eb5c9d9fc69e9ef5444959a51458797ed0293ee5dff78d5e4adfe314e85e0440bced3a9be7f9a41e30e4b3833f48a89053536abdfabfd154c2ac57e6e9e291c5401a850f982193c51fb135b5ed50a1877fa06a99db26d471f26ab309fb94f16fe1b4a248ece17ee9c00292074eabcd9199f80882a33f968e430214d79ef484f9117ee619089fbebef4ce646cb0f5e44243baead4c50ff109986c5688796292c7fd5c36b78d977f2099e26d173e97f1e8a3cf1207872269658e24bc24aa79ae3ab2b8941d5c623218af5b2988605c70207bd753eb4b868e10cf17ff6f46ebf78b026aaf8dca2e6ba6aa805b3186c101df818bec125958d7f26ebab8ac81fda232ff83ef2692083a7242f4649f8ab8075611e022cd4fe2ee7e8e3e1396158c473b33332531da1e6d2ddefe0d21f60c3fa03283e91024e99899cf90f7b06671ef2306f64cfdd29d9cde16f22a9c0944c1c7d6718b26904ff489c8453184215b189d72c2d49ea70abb2e00bc9b3f6ab904f73f1b8b7ac4f0835eddd490e93b6f455eea76c04ff09542cc671716834dfb2a1e1f8c81f5084f76422fb31c4686992fe35b9be93c466ff1faa34fac8ff03086bfe1573ea2bad2e84e77ee40636d5185f9ef34455cfe7146ed9b2f810b4e7dbf846bed48d604bf77480398a26b1098921451ef29b47d5339777a716657fa07ce0faffe33e501930ed7c5cc50d103670a43b57364ada27e2172396bf2d89537ada1a5cca68ae4ae458326d3acf4d1344755f207c9d86b1c2e0913b22fb68eaf143722b99b576a1d333eb3456239db8da9d832cc2dbb4b1f6106223421f70ae053719666f7bc6b8f1032b1551529aa3edd551e16d1df15f1cff09ffd9cea4c18ba496300b84a34a02a710328e04aabf01a0d8790b6245929ac56fd0437735e7c9b8a93a7da489df75cdb849ce5928425a2232eb01b7f3b9f7e59dc24c13e43ee8354542f353f2c22dafe1bbd83670e1f36b7934b138deb5992969d96267c94f9b2ca583ab853484a4a1e69bfe7072d14494bee23640fa36602668acf29028afb951247c4ff8c22271c7aa83612891b80e47445781634aaa18ff437f545342cbdf7dada23c99c43290740fcc97996cf34668e6975d9833de1de4342ff167c46a96b5c43d63e7c3deb36de0987c56c2078a7ba53417284bb5089cdcd33ffd467920189d40e546f6e57d45f4fc4bfbea67a912ae835eda358ecbb0334b3fb2f6c7281f35d6f764cdb199cd4d91175e990450ef266966364755ba7c3cbdd140321e610b2d673c13499a2d89d1b20bbb0773abebdfbc0a179a3944d0419d9e080273a7daf1f2a54bd7a5df56485688f2eb794937128aece2ea88146ee3880ee1584c9350b1dbc3764ef81e56df150372e280d492d3e8121f6d3cefdf39c373bd8a7ee3f6a9a3f5fe5656d0ae71d8f90d3c5b8242ecde8792dc09488cc2e3fa269e45958a448f1cab943c41ad00e5ce123b7f4d06a7b26b946ec21608b0a54a068cbd4f915bd7aa0a3b803c5a154dbf68fd9e1d09c25d1cd5de42bc17cdd7e83fb4e53bde003dd0f1cf8f94018a4f61ce6a2c443a2166870124b9de150f5639a77b10af19530454e705f023039f000baee1781897f4c8ac60777d70ec9216d6f7dd557adb76ec34bdb5c68e79fe231062cff51b9d02b8aa00ca014accb25c37c9682bc4bdc972e56d6b86bac60bbf230098c6c9b831d2656e779c57b107ba0d6f22e9b5d7559f5b924bae581c925f8464a0b3b952774af765e9d81174be96d5bf3a483a073a7ceed12f80d766d92adde03739cf6f689dd78045aea464a18a3f56e61e0bcbdf877c44f06310e8f3ea26c6c9b01f72e0d2116e6d202226fb78321266cb4f1f1345a5c85d9185f8b80b2d8b2074f2bdbb20679f0c96ad7b3334ec40e1884fedb2ce5b9fdd9b0f23da42dc78ac0b4ec12a89990f98fe3ea61bd539a3f69b12df8fdd2d7d24d9c7b65ea970a7f1fb8eee40ba131342a7730c47feac6dcf3773b0d520e6c7276dc1c4ecad98a52559441a342efda7232be95fa98c295cd8a282b43417b217825cf02275a634759405b7ab31b6cc643877a977ea7c682b0f331c99dd7710d891226b67d5f14d7c522a9a2f955296b2ea45e1286acb019d33540cf41e0666ae7c1f0db07dda05068ebda05fdb30adcfe40fd598e608e80925ceb5a36e2a3a1349f861283841b259f89d6de5d791d473ab05f5b237b1871a70d55bf7b8ba84f682c8fe4907eda31528e744d3aa6cb3ccd80f20cab58bd0f63965fd481f727d39dabd2a25e0c4c8bbcec468bc80dd11bb662039d22255520d283cda37d99fe214163437b6a885ae023a6acebf19d1ba74b9595d3ead8035a9a9a74abd96a9f31fe4a480aacef6a8bc2ad1e90220b81f8f09bf43bd74c8b333dd177b1f7b6a33a1ff107bb85a390ab73cbd9de3a95f74d8d3997cba1cb79983d6e5f90356bf003eae9486fa8c91c401799e774fad979b8232583a7271ecdf487332d73f9f5e1a7ca6be41408f10c4d0f9ab0c625ece5948dfe4f13efbe9f7a64e5b0c6ae898597b89b718485e95c2045db469b48842f58422d5fa2ad209710ce86aabb5d4a8aefe6b84190e27d721434956fa804a92ad42bed65dc1b59a67fba3cffb01e30fffe13581a488ee43e90d6def521bed9422c68eb014d27cbbece6a9c4c77d3bb93fb699667ca840c920a2a26cb0711945866a308377fef1d25a6d76ff1d7388432325cc396306b0ea27f3e04eb548ef72fcf2713ef839e05db2d12d1506e1bf5311f99fce545714e8f720a886209c91784a5621138d1684ac92036ab7d25767c667e7281e9d5c2adacd6990ec0c5a84c316c4a62794b6d23715e68ff06431b44d0d492bc8c93c3ddeccd36aec252e4d49d86f221212dbbf8c2e38094cb414b134df59f71f50413edff8cbda9532b71a7a14a3c36aca2f8009d51b8183b7def486fbecf2d6eb7c814bf1ef8a7b4285ae1f8ceffb73d5f747d647db41641e5ff8a83d15fb88dc9541f2687735cb07d77a50548842cd09760045abe1bc586d44d878423564d07d951300e8c45773a83770d30ae4992113d7c42fc8bd2d86020be6b8c877a31715c0e594140667410e6f002547cae1046f66ec4daa816cf321fbc746601e146a15b64f80920a381c74755d4fe5b6cdfd3f168796af09f7ae4303034d834c64cc2841e7cfb4bdc40ed5a99e8a56ee70d3b36dcc91799b2e7b2b05dd909ad2413d3b22f4b8a37a34a4dfd884e2fc85b1d873ad402633e233a2b25134271ee02cace17a045f4d5d5a7de75cfddb9db70a3ea27a8d3cc90c0e7fbd3ec90b26a8b6ea9fbf77138ff0408b53a9df13f3d67593ae3e07548b92d7734a96c5f5e1aaaab0d0199c8dbdcf2743d46ef9ceaa9341fa185cc76c9a14dfa108ddb8d6fea6ae6ee1e1773465ca9fa3f5c073822a2a2b8f7ecdb72ca0df3835d73879739da76a5031bb27fff4f339d7d47d6b9fd62632db076790c684a8aadb57539ce0b7f30d3b2f143e2a62dd7f8d54eca6206af6932008b65ab86d6701e88d3f2e62818b348bc0d452ddab7c0bdcbde1015c939da5ff486be4df21ef6392e40c94d5bb0a0ac2a2a88e4385f64c01aaae3b4d000e7ba9361b8b2226a9a33d7868fcf54744d3639ce136fb9f5509527cb9d929eba2893679f25b69525b152bacd23fb1cb2ca3a321bd25aecfd7d919e38470ba7a957ead59ced05c72dc2c7c67a3e73123809b666f4e206f0d31ba61e115fd984fafa5b8f3453ae1a985b0ac862647eb6f5dfbdd3961d40dee479eaae8e6a24d4e9012e222bcd7dda3e97ddcd9613f98fcf8be64a47ae2ad8a5d7db1747462d021c860851fe752aae640b88d48f527bff0bae31843b410324a7c89ee18d60c53c96f42d80961c40e11c4f66b03a1f81fba4e1e9718748989aa838b57d15de6b4d43ac710a2dd10acfbc5c1a5967004ebafae1fcbcb45ac2fa9602f9e635a338a88e429efdaca7a39be87d036b211aad2e4c88d2f24c9608f06a9ab18c575676d782be2072abd9006b8b1645754fce9d774fa0b7849ccee754ea9debb7d7187fda1a3b8073b0b9b9e05636cd0460d6da932db7ab39bd3e432b00d0fbd09ad298df9e476a18c196b37d7e9a49d33977f6b727cced286afd03ef329898630fc8102b1f3e5420d152da5e46cca9650a818e9ce9cda5f4085f5cc3a4e27a129647d7102d6319a411b5e7446c7776865164f3831ca93afe33166dbf96078704851103f69211b38eb4a32e2b283eb50035041a06daef99139c93d7502bcef7fb19b2a21df7819be5477160786d87d6716ae0219df047f531211bf5c2da27d0d37cf369c0983cb46834dc51907af5db43d662dd302822ddf43dd470f9c6bbe10d92ae939f81a4ba6bfa17dc5e95664c9315eec4fc9a394068ce46d216b179ff9b4f5761e65ecc4f9ee144bba37fafe514273d055da048c73a8a4d28b7842327d0e7be653442bba880a9769a7fc67768ff868b1f009f03df2c9938540d008276ec1f210ebf3af36178f954b6e4b4e5a920daf8868a2cb896b782ea3cbb5b07bd3ebbf1eac7a5141c451066e0bc1b6d4fb88e0e3ddf401eb9307b2cd2d385414cac512a6abca5bda9f00e3955c60ca569fe53a2aacc127b8684a7dfbfc3ec8c52a00d8230133b01843fa072c2eee4c1031345bc29d809d7cc0e1c8f46869d8e411e260872ad67255ad150ef0fa257fbb7a611895e588715f4eb68b4394ba1944a24271eb614903cd1cc76f227bf4441f687d554b4299513bc127957362323df8c8590560b0f58fbf448d287d74cca2eb61d03975a3704689106818edc04772b1dc431cdd15bd7fadd896ae8562bdf47dc5f529c3e42c7f7646a8550b1022945d1d06a5a92aad9ae6b3a43e1de48e702f053f1ba52d8b28eeb6636c2a1e1d9482a10ca2a3f00d924b8cb6435df9ee780c7afbd68a98366ebab757ea4c73116b03b4eca3f0feec6ba69d7f6dfb12bd33a18bcf1bf17ba44c55a78744ce8a2e66760083c450bcd51898389e39ddc49937e02b8af79ff14cdee01478ef6279f7d9d54b44fbc592405adf3cb275487632005b3f0f27860d134369f20799a2881e40900bdbfbfe66d3f29a616574b05ff4c5e16bae27361ab41f89efaea2c3304cf6798df2bacea31485af8dcc7070afea9d639b837a41f26835aafb3003af141a15075e8f490df7a548045713659f2752d0ff506a20c477709ceb03c39f1474595d3972f5ad86e7eac295e0702dab83ac0de6c86e02d89847f3936ea2ad2d73ebef59373008d1c0eefe9a712b47f145a5bf518b727a29ef8edb8e61189ccbb51aa9af93424f1815ef3c744f7b80780845eba84259f8c88e0c4a3d82829a23f597aeafc60b5f71c682caa258bedcc888c2061445f3ef64852c64b6167ed0c0f096af898efcce9e9826dfbfa72f9fdec2774d06ab20b2f2dcd427c3ad47d497feed9bcb283eba696edc61a4eeeb27279e9a705a323cf65454ad6fac03f7255cd12e9ae539ceeb6bdca48d25ca9fd869e659a470831c7f1c16669d701e957630fb943afc66419cad594caa780d3403656ee9038be08c5c50edc3a85e38d2fd96715f37fa4ee90d88992fbe38893b180dc27dd4ee81de9f6e1478dd7579ec71d53e0e899ff8202edf9503d8cecb495d9674496279ede5a738f08a3e2d965208962ee798f4383f921e1c1070a9627ede888fe4aaf72e519aeca6a2af647018be0dcfe108bdcd7d7ffa97b5df1a16e8feda2a997371a11e9bb33f53972b9b9424032de3fb674df582bc455928c2171bf0b7b60c1b019e912ed599281bb550efd48822580fbf298f833770908e7333acb3c21fc9bda6fa7b3718c93cb98a04cdc4cccd421c09f0eeeb34cc4e92d987577afb9237b3a8c3dde1f0b627ac5051c929c449daf8a33baa3d6d3e3939cd6b8a5bad1581e25ed983ae2027689a47584ad378432ae92f0273dbe19036f9eee08a331c1fdbf1ee4855f09f7cbdfb04d1f92815e0ad1f0a52661134c2dceea47e1e85b9ff787e5312140e70506d4c9118991963a351f31cd77e3890ef63f6bf299d032e9a3b81810d18c432a0f841b7c4dfeb70f24739492bfe39624ea8b327fe595e0af08515c6aa8a8f5aaad61efa9ae4933b41a403e8bfc917e6e3a17c0ba2f35e193c6baafb76bcff1e9f58e630d83e5ce6e08e9b12f63b02efbd7ea36c70b6e878ab98bf400e02dac65aae6dc8157d4bb88d05d4e2673b4b4582338adb2b721124e0025684c71d156584ef9da95385e86a32f9c9d84974026e4ea70140faa89e3c36073e41cafce208667a005b5ba724423c281e1354ada073734522629830b733d14d89589a1c47a5c85d45e052aabe7c8e59046f103dfe7a0b8c72458bcb15935c59c89fbe30eb73135d7af52e320e030a5ffded293c97971398f97911ee4a342619797b108fea4477ce4d670e3b3cb9c3a632bb4ed7b593b8bb9aec48080390ab48316711219a7508f020a10d3289cc8561706baaf0aa595666172b603c6acf42241bb39336821c195d7580c0aa8d1a2ff216af61bfe01b0789537eade6aae8cd30f2da401ab9ff10b718fb7e0568a66702636586dcfb994af8a7451024e05a64c1084f709826c0bbd1b55c25dad65db31c3e7d352fb0a1e727b01af64eaa0bb230c09333ffa71e11ea99cc1471e2fb19dd8ddc58005afab32c3e583a5fa6a504b6112af92505f53c889d1bdaa7832fd369b8c96fce87d9a18a228ea01676b677e5ca8fa975ad20731249c9ab5adfe04c38a5e14332e73390a736690886f157ae44a29425c77c66cf9b9c2f30198a7e1a4adf15dcc9efde00a680a02f85f3921f38b0676c677b63de95a294f435fa4ece57c04a6b6da76833839384190913a5a25c68eb5cb2a52896f44fbdbb9b755e3e1d2698d38034733ebb248d11d3d0bf09d7ae3f9c2e24338cb6e39a4f088ae09b949d96033598952d3dd51d02ae6efc5d756476d23e21db89c6402f220ff97ae2bcf129dfce137716da124f058f6c926e941e82dd45c5546ebe49cd2d3c16fdc573fcdfdc9ef57ef372bb8af5e3127c28c528c17887df5cdc565d8bedf358164c2d0cb1902c0f7be2f80b2db44ef8ac91196e50a402146438766f4466890d0b652c0f3ed16624b448aed7e7dbd7284853a52ddfa51f467c5659707313a7305ebf82511a4c363b9f81dbca0387eaf536e063c43fcce2ab8927135ede5612f68e6096a9d3982a781ce946304d407d242d8dcf390372c4150c0a8fe86f37d1ab8b9c961ce7548924d039bdd290c456eb1f1523381c596ad1f1ca36cf68a90af811234f13278a72f60a8fa48089840afabc6f1ccb12613fc40ea277d89c7066b8c1aa638d509e5d9680a536db0c15b3143b388d4bfad8483e894598eb6cd5ac2ed3c9a2fb7581801e2c837d0b11c7c79681e5aa19f46e4793e402cf80ab4e3122ae5d030703516a1f66e11e073e41ecf693741cd249f987ba7162b757530374f9708f71eec59847f8883ca9c7b4c7337ea3512ebf997b09c05bc7ee42893a1e2add52b2e3cf8842c5b97fea3c1f6e9370ccffb9a18c404ceba301265275cca30d14846842b9b7633f737b50cfb60cbcc1d6152418a7bcb29f52b964803de6e4212f7ea1e47de61c8657a0249496c73075d4ca71efbe5a3ee7cad8fa4d623ab6aefcb553c957c24f5c4d97ac60c407af99296b58b88d31d11114ddd10b159cc927552188933646ae8a90d96c4a3dcbc7e112953b7910cf2b7dc522e097441365d991c2ff3d37249843b23ead836e94c70eeb26a7e319bf4e6cb552518e605caf3b174a580584022b5b501cb05c604c734d1eebf3888b2e787576a3a20a5cd468595f736eb3f7d388bd879b0249319a8ccc89a52285283980acf911dfea7e5f628bd8a02d4ece05ea1b98b24450f22ac773cd21da852ee1ed8c2a8d60f47c24943a87ea44212898c1c2bc6db04377fdd3bafc67ed6dee811995823b9958e0fbabcfdb8511dd7cf8e08a74a4642dd3f6bdd3e8fae920b244c26add9d336f2671b6f8c2bae7013baeac2c8c32bdd9b4311c5cbfe26b93737cced4012050a028b195b0c9b7a6dc70eca3091637470331f450ea60b8c246deaf0d13a1353928dee8c48ed3f6c1824ae77b99c35fc6a9e35c9eef545ed2afc6238d0092e2d0a0532a213f185376a8250b5f916d127266dbd0907adada00d6543f0ba33231d34703b775fe907b41ff0ec38ffce7351e9338d4eb86051b07e78e0bf3c17250bae5cde82f8867613e3edef9fd5985e69d4d17b858cccf780e56559ecc6cd46d7e18da0c0d55a873dadffa872cda81fa5a89e71eaff0b7e5540c7249acd9789d8204dfa08c3d9e7370ddf99b82309d81bc1098da37970aa0021439f034a23a0c9abfd93689d7312c2ac475d03d1c007af3a213d5bd08fcb115306df1d74dd0fa4776c0128147ea118488e3be29048e9793cd659aed1f8607c9b027b9f362b73994070290cbc4f4df2cc14564d7764d8c49b6eae194eacb822627cb3a760119411f45e990d589feef035fd35bf8756e2ce8fb0586db0e6d1b51b7064d01d7e2d756b2c0f66ade1a6daf92b2cb7b992cc8047e90e506244035ea3cd42f874a7bd6a2dcd53e102123aba95a6ab8a8fbccd14f01cc7334472d4130ca740c67ca135baf0bd8ed7277ef89318c9d694a7e1f36dccc5562096041acda2e0621c8006f53281f33e94107dedc78ce950afd6b0089fb093b381482c9d6ada4f9151a637d670654a8b4037893ec40315bec1433b24430284970b429b239a22af59f74f876ce91afdf878c6feaaa4a560e3b6fc692bb148ebbfe2548f33dd22eca238eb1193a8bfd4251a700d04d524d5e49d1f0b810c42591758b5c031415298c8c88fbf2697fe467f5dddf4d9e7f7c587e595d2439a8a9d895c51141ad0c5f295b375c1371daaf5f5b3b182e7c18360e14760d5b60d99b950695e91d0aa479b5a08d57b9b6955bb21a0367c04f33b1ac07dd907234f2f6bb49bb5a80d576c54c15a34f49695c5b11c1c344d72a75c1964ecc055d5addb191a5c23e7de06ed40029115c45f5086aa5c16dedb265ede18d5e90f4037993ed12d6f3944faaab741a370b165e8e01e7501436fe471d45642a37a033035c826ff2077569c9c20e408321dcf2c32559cced5be52d21c9890a5622d2ea3686accd06c3292beaf91294a0806fca48e010095681e0953670b3c767ea2c7eb2ff9818906f8866dd14583966ae2446268a0a346933b15ff426134fed7c01fab4d74af5a35d7caff534fef449c055761889c4df9c22d656404b6190a6ca5f1446f01936e59834f12a1adedc840bcebc6f0b631adf4d95c3b4189b29beb570a2f33fc79ddcb4ec546fa7b5f30eaf49cb91d618d02c2d46c2962fe70a1ecba6498c0c359baae0c0adf2121d83ef88f37c2dad1b16de8d76cfca7c8dcc3630716f60b820d9e5707e574784784f950faf7452f957fcf36744a16ace4ecf9b8aa0812ddb94c9f26c27e88b000d7aff9c02b6f9298ded329fe85c0faafd8465211b719af208233d0fbdf8e6549fb44373b9699645fdee303d6a1d5083ed4970c73b28ea6360b6f3d38e3e7a59dd9c66320be3908c8122569d100599817950fad01a80546cfbbacb61ef0eb58e588cb4c0be27060c55638f1af7cf69b9c683aa88aee20be510e5ceeaeac77e3ce70b3440e4da4f84114b0714974ec8f9e522290ea7b737ad2ef58937d09c97cfbbefe44cee32221c79a307e1ae86b9206cee61a186acf30d79d61be123ab8a09cc5aab63f38e884be0023fa537438869e9708b6dd44c7bdf564f390340b48af2aa4dc3bbd6c82097f7b61799c6333d5565048265f5b0bf625a19dd376eb243f74616996a60c4225647b482027c9407646aaf464c89d97ea49cf6de98a5faa9e0c19c2c750de63006d04284c46c2fc9976d87e4734ab7fc298ea22880223aabf8cc5fc2983b30e9c377da2788b4fcc07bd2ea7630512a62efb82f5958dc0f14cf8b97f62921abfa8922dbc1a2ddb02332d1f29996a918f2b299ed7583df514762f63472ea1243702b044e29cab70f9ae98b1190e6e6ca65db579d1ca34ab34e32084da48d5f39762bfc811ead88ce1cd847e4837bf10b2d60f1bedf3c4afbf845f24e44440a9d29d9e0b5036140e221877c44111aa36e5d92fa98106f950e0e67ec93c9733ad2417a107244d917a17ddf3e98f4aa10841af34d5f903a74545ca09f131130937bd514927bd61e87cff73e66718570f382505dff9a117e9b2c7259233cac36e8248f958c83fd3dc0bca597c3168ed7f1601617fcd91e3c8229f51c8c3b3774da0aa1ce38e68316c323f683991faa87dac9f6546e4f38556c1668d09772805107c65a10f8efc2246e4d5af3db68d98421d7ef571ce887828f803fd64b9632f2915a1ee8c245389c54bd753d97479e7d51049d3818958a20cabc58355725924978deffdc0a29f9a2ed4610d23ed392a54b13e02270c25a2cee802c0ba57f5fe81a749a34ae5fe31003559eccd8cfa675f661522fdf27d454d4f899f4fead92fda078a7c3562bc09db6635b6041bf2be789d684f371ea9bb7049ea9621823c7d9b689e7ed4b88fd2e26fe90f5addbe2325e1e27f6dcafd71963366305a50405fae85cddd606af1bb020536ee2b8874b29221d31ba7720b61de6e7e81003136ea36ff46f90c4a89750b6af6ccb851c68213ed32561b459587d8152c592a3ee2dc977432c78520c51924d21969b1116aadf3df2dd7d97e5e7e15c902737047d20723a2593b2dfd1f0c27c7c79672420214d08bdbc773e10260beab4a8d1b9465304fdd2023b2723cbe561a079a83721e0bb8c061eef6828d6f85c1e25bf092","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
