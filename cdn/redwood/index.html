<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20d88b211cc7c65678955b021e7110d139d9353548b61026193d43be1d3cf9c8278f4359b81ba0a7a0f1af98ff3149155981f6b6cdf761381f87cfdd7a8e02eaa882e21e3939aafe27d891ed68d7f07e63afd26a6da63f0e9d6cbd39b8b233f78f7229d5a44bc232092d523319f33f75e79476d87f87e033b109ae237cdfef4b3aaaf52a55407cf60128e31b73dc96a7deb0f30989392279cc098cc7291ac3fc48270b56f78373dd0b2bdba88e3de1984eb92055643ab5126a00f3a533c2391109d9d646e84fa61d7fbc7201e2e4fe9a8d76867a4445c2b94868cb994cc2c9966c6009c821fcddcfe7f8570904f1a9d62a17e44755cc410ce50b285ecf59aa6ff398fbbc912f7cc411ebde11d2468bb7aa2056fd7151491a2992df7c9245a784cca3f964aaac1566381023b249cabc5a94ad6d5f2526b3a8f72e0234ca466a38c6ba299ba879e1eb2f79130865df6cc95516b3542e0a1c0bdc0027a20334b49e7ad2fa58d16ab5e70bbcb994bd2f213da7b9819f54154f90de39cae029bcb9c8911951971cecc2d58ef85acdf39bb6fddc625990e23116d0980995375a7b8bd4a00a1b0d90afa110414a5a99e8f4c3fd9476a61f5b0176b183f84b2dcdf911bcb9a36a8dea16bb575001dc2361e92367ce63c8dfb56d582ac1ce60ddba06c98908d881740bcce12e682abb55d458db44e5c920bfccd2c312d8c309b1634ba80175a5e5ad8f4b478933076eb0c159e5b847ff36aae2d5af350efa125d06b40d29da850cb4949768b6638ba001938739d7c76a648d058ffee5fba82df5e39b64f7702199a95fa59d27a6ce64c8b2edfedb393d34c512c02be61c3ce00ed189de0dae80d92c505cd1dbc64caabaf56e4480949ed6694e10b7c29bd40ad5ba80a558588f0250ab84959bb4bc006e93eba40c80c958c4440f2ce5f1ff7298aa350ecb6410cd299bd16c3370e611b5f892b1c401865786857b71ca884117f6feb2091e5b38fcc3a0322c8d81cd4abfde3d5c26638b63f6d0877dc8c77c8ed3005c24abb651fa737dd935a187b937cee1209579bc0fb1dcd4951f9ff42578504cd8aa0a8bf80e8861a473a597895dc271f1f9caff584aecc940bae944e1a0e7703ccaec383112d0d9316717351cbfdff24957c80e687cf7e561ea8f49fdb4e1bd6e5a3f5d93f401839dda82b54b1127fdad335de5f52abaa5125dcd80bf161122899939d249fa585ff7de1a9001787f15364ddffc1aafcd2a68d66b5a3d55ead8993ba0cc3746d36180524350323d457295e0c582acd29e74eafeff8604c303b974e60b1785595838b5216d7ab49cb1499ef21bc9b99bc5c316ebb23b40fcbda894f89a8de8f24556bbdc55dd085f819044b77a72b2d96d714a2b2c0b651432092a0fe707e3d1a5c88570a7e21eb5ce58158417b8a36b7ba10735b6f05b68f782e86d6ecc9f3c68ca18e1f2f0d3a14c48240b1fd5f1a0c110a3a0aa5050928d428c326a44f97d5e6298e5f5415a6b442b8fe73c9dc67cb78b24baf58a8e57af586a2eee927b91fd24d87dd4bda3e90f20899853bfc9a2759a1906c3aed2271ed0ec64724bad5e64b209e37d2251e3d9cc63a92ec2b438695956264f4c5143963bf41d37f4a851b5f022f3b83d7d179fc6948ba8c28ee506cab0f001518339fb2626c49f43cf58eaa04f303b49953a977ecdc5e8ad56f60f91a71cd3cf3f6418fe66d48d005976a98b9268652bc5ca2bb861f82d8e19cebe8e606fbc11f7d21aa1fd9a72ff505b9466ce2554b3b16c8dc4e7fe6b2da2666bffd1bea9ced1770e3138a2dee8a8cd6ab324b32164caf9a517a3f61ea710011a501564f930b39ab896b0b82e2276daaa57bf3a4893a31c8fde2c5b3c2422d759d9c682a8fbd55c05590149b657fe01e471de704f2423e699d5eb807a74e202b2f4c6d70ef26525eef8e55cd1c4ce981e6744459fa48e25eac94c5a3df1a746692e8f741d11abde8f66a4a02a6d2649bb5e57eeaa4ec42221108d18c34d64c65dc8b778686c9fbdbbf515924616d805361f421e46381171d99351a357ca91abbe6295489a94c074fecdebc4b9a2ee73cf77d895e4258197559a44743dc702fd5bb037339d25cd6095cb81d20487f6e627fa6cef8a66545f2a6bbf1408cb69c0498f4b125cf3889de58243f8e0a82ad0998905c21262174617aab2acea937dabe1ea690be9b905ae854eaba3c3901a1c105d81e2bab57d83fd8b6165d5582e1bf5bbed98fe98c7fcf12704e92b2764479b3bfb08852e7ea2a3a632356ef937c8923dbb6b3e8545dd0f74541cf7932e56c47d3bef037deef5ca57b9dc95a8d844ebffceaae7531c7b0a05bce9731ad8ddb418382b7e0805de67d54b90a8a914224c2e6f734209b4e383d87535d855fd0b17be6906b10ce307e06485ce48d3be75bc3a2e8020002a0987c3e357d377c865ba9491c31514cf7e044866a86ff59f7fd9a9cb12706c6ce6e2bf4549c67ce3cd8bbfa71ff772da59980b0b0c2d0350cf68cc51fd4fe21c47e19b8be6b82b527a1f390565f831a913f652472af4a44e645cd7614164bd1ee650aa711f279a172ce06ad311be291fbf403af47088e6a46034f4ef564815f566c038ac1da50be617d306eb0b85da5bd953300d8fd49cdcb0b82f4fee7ea08481c8260cfc1eb24217a92833668685c91a5562a2a9c58aece5807b7feb27f33c6425bdb9692dd0e132303c7e83d4c8af66853797f9c00f4e95bc7abcd32cd9abaaf9ab99a9bb97ce7bebe9d394c40ea3f801de758e720beb68f6625a8bf1d670696be321d4a3487a87013ac03d193b9291eb89bb28fb2e4c7cea4f0a5de30a4f0fd0c4297b9104e43b29ef4772c840867e77054832735c96cd555dabd45c6d58f1ffaaddf91dc325b607a8c918079e30069e14c99797745964f9387b3bdd9a405d4c676b98b85afa365c2208fb4229be789e8ce632f5fd000e51de69c44bca6f095149ac298e30e63d407883dc63ce8cc314a6576497e6d3d0dee834702d555b53704c459672898e3d5ffb25ea249d221e6b741236035ed273ee77bd0cd4233407ba4c38ecfbbdee6feaaaae27ec9cfad3d19fabee844a7af8a9c561d9d615a67dd15b3c850097dbc05df39beab3e41f8f7b44b4ac63c8cec92f340560b05e7f05825d3a7c1dfecef86d66dae2f462821c226abe70e734f9570ce5af4052aae3c7b49d473c440b5269feb6d52d8affe9f525c7f01a0445afbffc9e6d3687640e3dcd532a4a7ec8b4f2853476cde7bdf8242f8e53ac0a80d954ab7fcfc90d81dfe92b13103786fafcbb01d4f2b566c2a2ab28dbde9a255ca092e02336b21339b01cc7549621ecc401be9cd4334272c3aa7d2501f4c005d2aebe7774c38f82294d64e06194db765ad3401ad4acdfbef496cf289801dca12f742057163bc4f53591556093db31e1595a70c8b7d279357394a5a0cd80d27a24d55a5b005d6f1b43d168a0c00e7ca8791926317ef22c4e7f9a9890a795607620b5dbbf20a386c3ff53400a8bb35b0e8482f2a4206bdb1dab1e05b3c982260adb2fe148a0ab2cbd4c2f5e49f14c8776387bf21e7cc4e5aa58ea5292f76152564ef3b0350d70822a77aee5ba61c3c2319e382825e56d6d6d24b7ed5a73f3c45418ae6f68297e87afac985ac07fc4dce08128fb51da478313271bb872a311191eaf213a1642e7a820afc2f1635f32169b04ed7016d772aefa5909c4bef86ebdf965ca8ef0e20450f1ec025e6c951cb354571f9a35f240e8432324eafe656b1e0554fa4fb8c33892ed3194d29193c7aee680cabda671e89ed5acada41415a5a2d882209d513b7c0f74882b3e6bf3aa4d8c800ff0ebd42b435e8f8fd1ef89b8c40dff0390d6f3009472dbd0f34bad4fd6597e29f638bea1f8d49a67539b1a5417bb6a3c7d6857ad909355bac7f20dfd5afc1f3735fdc817c98180fcd4a22f9e61de854cd9166c251cb5cdb1d70e57844daa39b0c0e3d69665f95d2ccafae47d40a5773e1c4a44a6ac94d5add196172ef7d4175aba0b25fa9e0a7f8dd75e6460af71483adb45a7ebdc086d069f306d3b90c6f97db5a44a892e83922036b97e3d123e16ed2e3a8dda2599e81115743ea1d260b265549eb42c1fa4440367f7284b1e76e70aca18d7234d1a84020000a3dbd9519e4b6fe006a41e82d260fc0ab30e8bbe319a20e7efb2d58f3e08ebcb1bdea9f267dac1782836dd59465e998cb8b8f6e0508dc70706a36610f1e79724e57e668c987f115f33695fce977c97bbba4c22006fd8b1851d273fb0270a6d65425df024d9292df210fe1dcd4385d4543efa5e1a698fe5df2535f9360c7a4c2b70e15cc83a20b087b7a5615df0eca8175d7aacd3f492b450b8d113517c16396de5529f5595f77cc5475cb7d1cf91dba540a15ff13a0b41566e28aa801de35fcff79002205e2ae4d59179d2ad03d51f21cf173a30c1fca40fe26b8fe80c7b288d265e1e4f3dd31d809165742766fa7341f74c79788215fc53eb3e3aa13f857350d6e4ae2ebec9ba1594f0dace3b0ed08899dc5bfd5598f13b5355616de035e2c7252aa3b2d3d7e77c9c19bd5f9cc33fe8de2b78ec087bc9467ef9c9b4e49ce464dac033807139fa565714a217f46ecf76bfab8c25a9b4491eeb200afee1e1a9363e19f0f8df33753d4a1bff75a88187986480e45d46e48905e40d8f5db56680e55b0ce54549267a6c6d1605f5a32986745a99aaa584e792c3e3bbfb1dc86c2d015689f3d08ab2bbd2d4d4a49efd43a9f64d50de4f12b56214a4842e8f3f138218cf367cca02af03a66bb055300b42a46f573c4a6661deb26720e599f52993465f50316fd92c6d85a83ad85bc1bf7653b1a7b0659f3367a5bed6515a1b38c101d49579d31722bfe7d4d585f7723e358ef046bc619a5c384e4197f76d1a56746022d657a1fc7e905b62e51d366c5fe4a57fbd7e6c9f21cca57e020b3c98d2b83c8ae9460a5e9ff4ebb90315fde483613d35e32ac7051fcdc164090bb2728c8cf05b33f11851f6c6afc3caad09d7fa3916a5c3bb72f5cd620b0faa650b1cbb77d622e4d615892ee71e21ca76581865a4b284e29ec4b50ab5c42149e06b2598c77bc8f6da9d8c38bffa260731b4a583eb1fa4af2e46dbf97e3eabcebe1f81afb73f06f6f44dfbf97a63b1ca3e3438e4c34ea54755ef1899f40d2c6f3f0003c02b3d621d21af448d704167e73abd216059f1f6c23385201dd857891b647253274809572973db7923d62bd20b3e1086656ff7b397447dad6c6ca173ab8fe0a2f08202bcc671b765cb0fed055fbd330b6a93c69076ae1dd03f606b4c42f8482f34448d27eb05edc4052bec43fdff352f1e60b608898c1e0ae62203300963792fbfbbbe0805107e570a1c05efd1ba2a260024c1407c346dca8d91c48fdf58415196f88af5d9d9315e29165da41398ec6b81cc905385c50949982c6cf1ba84861cdd6e097405665eab30b6cd1dc8d76551ee4a44b5305810868a3dde5fd89b042b16f88b092ebc0d4cfcf4997025c07f7495f8286e2aca16690da33ea80dbfccb4e0da51bd0148469b7a77681f6d003255e0cacdab2cd66f0e65846e0549719c5fe5881a2d1806edefafe3a4b6e2aac38aa589fc01dab8c09b2ac44f58ef4a06eebd2c4a9fa22827c96b17d903302d52fe1c95c53191b801841ee3731cbefe857b39a923615d2e2aff901215a283934967b476bb898b7e119169da2aa9308e6875d2e666ace4f3098a8d110e805e56dae36e18be6fbf97ae29b839dbfa0a4e5cd34cb6ff5e5cd2e3b09c68574512bb36b5d9af3b178e607f935fc8aec87c4ef533a5c942c85043d982c2348cf06915a9be4960b8fd6dcb786f6a4b722f0b4c4fa95e000ee41286c81bf2fa0e4c32d13ec2074fe92c4c9fbc78b621080e7f21370713e0a5cc6a7261f03f1a57e9678368e8a879a7f7fbe7f6eda6b6809b608eec4aa5effec745c7b4e2eb2aeca07f4c91e27dac02864c364e008578397e23ef8ae31d6b1d75892d03024804d9fca126ccde2b3b7e2e5205e4722d1aae9b411aa4cb2541277bc7fdab4fb998acec196077802a6f2d509db94b414289986b3b5e56f401e0b030ec340f1f5e730bf8504918de1ec9f784e8ff04d6466d3ee63a08e00ec197527c79568c1ef3d133ef8a7d453d3a379f387ea6a396f3cef77e575941b5fb0411b70d9f7976f9864490bc3bbecfaf73666ef71551f638dce9006211ef1eedf301769db49aeeac7f7819a053332f7f6188e983c45a7b4e2e7d552f6c87ee806b9363769445f7277c6c4854c78ac40a548cdfc003e9d5ccb924fd44efd7781cefcf967a5b34a5fa3a9ffdaff7c0828343ff80f30de3dbc6267112e990fb5ea004a6c3384c40457f4f340a82779bb31e7145fee1e4716288a928af41ea90b72c3a6d772d280ae52dd18cdb85a76bf6c8a9db295649a6e1233042f3eb1028245981bb4ec880939ab33f19f9f7fefa48b156ce54cf93103ed5bad349212469a276218d9467c1cc60b4c7ccf1ea24b202c399e32076c05ba3922edbd1ea3ce4eeca64f09144cccfda3907c9c433e938948c6fd007dd03a89f434c3ffced8dfbdd25408058c34f42cb8afde9b8af0f0d2319c73802f27bc8f15b1af389da6b8c0026f1b05186b812b7bdd93503bd09e3a8de231096d2364e81902715ef74f970d3aec1a8c001ee397ff1b98af4b7715c3e62b40d024d1e72a30c30f321311decf3603a2578237d908298eb13db86a03cc70cf4fb2d920f4237af2437ba4ed9cf3ddd6fc6fa4e0ea3d932ede1cb0c963591ef1850e6563098bea0962be89447e3591e7feee56b7596699e97e7a74254fc5fbf3b58ae3ba2e67470ae0b1db4970b21f5ec392107ac1a3357229fe75d0301b5250897e5252ae4eb7f55a5e829b7a9af30d7f8edc4bafb6cdf7da224d065a8bebfff7908311dea635af7202f1b7c4202945b0598beba20bed74422b4175a05fcd7962aeed5165244df159255f3351605df1250a62ff2356a523917132bcc7416157b99ba6a09c2be232d1462f526cef43cb3234e3b24fbe79a97498871650f891816b1706b1701bd907a6829d058d4aebebd841cdbb1221574bb73824ac5e3619279a771f035b9a7f2b6e7b59802adc42320bae30a1e44d80427d809abf4aa87151063b7ebe8ff288e6bed96216d79683a0899c562b7ecefab322e7bfa08c19b3c45a8c709bc2bd3345a17a51ddf9e9e25f91f9e5b7104526805f64f984caf99501e1eff4ae5bb809f619a70b5259f8dc6b6d9c1854ce79cb31cae4783057f704ec7b6ece84e376cb046c567350d999fb077d7528f3286a50e6d80771bc53c3f1546685c2ead6ce0e42cd4f91fe01b16e77e0ef0272e059372fe358e9d68d01d71f87fd1208693904e2e3f0839eae073ec058e46a4d95d37df5d11e3f50baf81b81857a3e5df5c49bc5c77eab80e2f07775ccc306008f7bd709ebfe34f11f7bf351a740db3f96f26958283b3d65b7a12c6149d35926bde8894f53268785b6cccb4ea7f0986c32418603186025e798651ec208df5a3bd47ad8837d269af008e9176ffff22c5182cb524e532feee74c4884ed8ab09abf9e8c87021e05a24fff4e0812b937f1b52e986d8646cd39b0f051781db336f68be8e4ba427318cff9b24bb5c3558432b82cd290c816553d5c996117fff8b1e345b3b129220ad94ac96b47eeb1ecd138e6cf8ec752ef4094ea387ada329cf3b642d4e652527e23f431606cad950c5056481e06928da4cb3c0110c99ce76eef24235bce8958456fae4ab475345014ba993c78bacbfb3d66adda71c466aed055ba0f83de12ae3fbb5d43ca2c46fb4c5a176b09774404682b0c7a9ca670e7f04511b9b64f5897cad12360fff399496c27bf9190c73e42079e7bd5daf18462750a8155fd9f6f65d079c8c7d32f99242550796d2ca6691064b4b07a512e0b260e9623400e2c59031449b76a8ca41de1adc41f7f2c55508b65f1de785fe5c4ebe0fefb2dcb1a387a47ee2e70e75a69b8de245f64130f1c0eb0eacf2125ac5b9c255b0e40f05ed0c364fed53961c24b5040d68116978823de207ed8fd9885f79dca39d500aa04d46fe0b1b67facb71b2707989b015760b7520364fac07f56624808072b3e507bdf22dec697cd912ece9a92108f092cd2c345881569613a603d6ce754f60230d4299fdabd07f71c8d00ada6b77f262d3001d6365e4ec885f2bbceec3ea5a93d29a596ec65363bcdd79b57470b8eb840592f2683e4662cdc91d9e57ceba0e360087204df3029c5b6c68a68adb39b9de874be13b1116a5c9503e6f7a166ef42758bd874e76560fce4808310a5575ca89b7d1f332705c193aa592ef0fec804a6c1b85e3fe05a5155f1f051c7c0fc3b2380c929248bff68761a3f51b11b7e4f5c691c96142601b13dcfde2dc661cf1fe28df36a755d66eaab44b0fd5aed64009e4bdf982234a36d62b0a93e54e8fc4f830f436e4f3d732ee6222feaa901caad6f685c66b194ea49092ba473900dee601b4a77c8fa76ec79093f8827d6d2351a028910a465cc6a7f336d8eb986ceb9d0e117ba1072e5c317e7df489b7161c0491a4b3e3ed6d099ca302e650591b7789c2e126e40f2db218f57a0dcab31a5e1898b59c25e51ea77bb37bbd43800ef8de4f5dec09937a569489e9884c8c50a1e37ed1cbac315fda88111bd63e3f5d48e32c82d44ecb49b90d3ea0948e4bd8b90faf3cd031e68d9b33cf24e472ae3c1c2941ad68b2cd2e53c47843b3e0b3f9d9fd96d078f23a6f7f24bea9b2a92d7553a5cf31298eaa569f993b261457ecbb64ccea45a6fe51423f690585b2cf56bc413e6fdb9b967443da223d8309151a6cac7956044267235a255c4812809151fbccaa19fef8d10b360df22aecd5e76d98c1b81dddb007a2acbefa6374cc1e5c1e425727ebfb91c1fb9fc5630486e32931c1d70118db3101bf5220d0fb44d222dded55d20a4983bff3c4af4b3a157ab828298701f45e4b3beb033bd8f09afc2dd4d3e080b86f0b232f4e19fe9449846966405cf6ab6ade8170089be5cb0a72049fa6c0be34181a3ba09bc3a2562c285da7ae759300302f4fd415c6275fa81af75abe9a8527c38ed120afa5a5e85808407d0e11086c67a78b1686eba213d62a0aa881033de646449786e5f75cb01e4725023f95312375e58e35b840f9383ab47564e7e3f43cdb07f7b10810b3f91609043057baf196a2b599c1f8836a67d61cf0c536dc30446c2bc76f7ce1f6ca0fbb4c70c897e0eae9ca3455fb7124df21afad58292d82bf6e20b0e8a4933e72bc97892dd1eff1f5418a0187a4e510c9bdc6fc4c04c2ac9f99fa06bafdc61d3bc526dfed3cd1be4957a59a218a0022fc337445ecd2a0fa2e05f8fbdb2a1c1397be9fe4b702ac1f39b90de47b83f9b33e7971e98eb3c1e1ef0a08e02192d80ac1626c42fb38f998a30bcb1fa02a62beecc4f751e01aab6ed999a4cd0ae6d86fdeb992be9636c862938eccea33a351a4ee2c2a2224c14964780a8c74e885fde989831f8efb4b8e1bc02a9c460ba6f7718d43b032e1fca3745080ec2d4d255d32f57562a73dc001b6d5ee6ab3fd8d7d162eb05bccfca419ce8d3f2328cc3b00505b225692f6b05c44b02ba7550d591f27db4ed63e046338e9a7c0f724a3e5f9ed2fdbc2ad7588fc7c186a8416cbef9e55dad83d6eb068ac0edd137f46c88971aa2a1ef19af500fbd3e58a6cac4791d540d26436040b8e51742ee74c9a790589063753e9e9f470164b26f6fdb1dc511a9bf7cc34140ab29e87568f4ed1801863fa258e09db94b1b31629cc45e6a9265a307072c610bf19594e4b87fa9464def58c7738b91b651d32d0a89504ae48297cafeb82af8933ee37b44e48f6bb85024cba067c85184b7021ab061dd338e892f33e7dddd88842c3eee99140d68590f18a4f1b07e249d477ececa1e947de3739446706b949191c0b79624b2f87c4dfecf862193f6246e65e6a40df069fab8a19f1bbd5b1d6588c737ba0c849cfbd68f5904a2980f6cfbd765b7a515fb2cae9a82140fad8283ce9760906ea4e64ea1264699786082f76fced53235e2a11618b53cd1c425e88e55bf15a2ccd35aef0742da83400a7843c0e3fbdf505b55bb569f52a54ffbf2a3b59c771b344345538848871617db713c4ed16eeff5e9f33c3fde8410e36ff03f37b8981f3bdcbf173be14c02cae5dd1bc1c4106f41206cfc3371f11002ee0f4638bec54924fef3c1508df222a4f663acb024a8b3be9b4338e48ce28640cb9afb016356b9bc62f381bcf3f54a53b18ed0c56d14db64e0bc9958f8ce635a77dcd442bcbd321ccd837cabbb3b170a03bcf8c34cccfdf68716a63feb1542af9ce1141b3384e393be651792a4265542244b7d4a542b822713d7534b3a0a9c9d05b29d8e2a3155c90302a9f6fb6118ddc51ec1b4e10342c5f707098d6fad252e4d51750a9d4510e46e825997299a1471d3c3aeaca7dd5bf443ddeb78831ae9832541bf94350a13e86c960cfc7af82c9e2ff7595b60aff8c68a1f53b7e6bacb5a1ddf7eb2cf72d7b262e598ea336cd31a8a2aaa486a2bae8ab9189697c84c086f03f2af64e8277e83eb13683f0d9a5d48ecabff73666e95b7b7d4db3b3f5e2b2078113b1bc92381a1b080b9a9e28aad28e6b3e26aa5c19ea9004e9a2e4e747b3164ad7fc8737a88aca190f3fefd665df564f8972c4eb4a6afa874c49472e633fcde89211a589a91064636f8ff94e3e8de6b5540e6196a5c9bc6b7e9ede8907e17c4197b5f404d6e34798ccaf80c07ca5bca31a999e6239b69c77859f1017289ed970eab5265b822626f6827ba9743313c18072401e970a30b7b56a9035bf2026f89c262f2f70204c78411bc92e2acb5e92646198ee5c27f13399d0c24c1c373fb5288cd030758ad92b8af9cfc7df1ac5edf246122dca2ff0c4b4b6bc3bd44ea7c3ff94878390e73dbd71c3a6d17db970bc7ac2fe46cb54087deedcf06c7fbd7ee09bfbc1a450bdb2f200133382f5e3779e98e874e94fe37950b0deb340b235598b2757ba1538dafc1812c80f5e1ea9d1ed460d29af80334eac4db69112611bacd89f8bf071ae0b17fe1be24cc5bd8b59994d3b468b0c0e6cf437b9fdcc829d8701647f757230dd5a23f05fa4b1d8d43944f512379e679e17885ce4847b7b6f7f38a3b75a640b33b27e0b94f8f9c239a217477b0dc767295bb0a7d361341a2dc3837976426f5255cedd460a35a7ba347dbe4acb5d3685e09adc7c8031728cf3a318da1d43fe8fb85d416740cd1232029fc8a82f8a1a55500fa782046ac4d5585047fc688fd61b57d28b16a6481be1c0ed8f4c429a3c596bb576c1342eb0a465d51f7c0e8a8ddf2d035902335e2dd25800af9ceb777639638725fee1d8d7a3cbb9cdc89e0d27d15e803198d06c8842335acf5c3571380c0578aaf4499eb215b9e7b74f40019a23fed85ec6a5ce582511244724b6369db1556c8fc7752b8af9bb69ac4e0e0b9acde75aa98621753ec1ffe8c3d9b7d2a3789f87e7e7cfd1885a654bfeca868a8c294b79e4facd955b2e893c2fa289c85624c14bce6842b37d3d6ea4d1143e21f40f053d0d3fd1e4d8e74309da5f395a16031788e545ca688179466b25633dce37f58c6b41024d8d476be8da716a20985fa40d93743cd66608ee7dcabbafa789ff58f9b47a96e2b44d5f7377b637796594d44bcdd37affcf144a49b2852a783ae31961fe1e7acb945ec3d1167714bf9b8d327b60ea40fbe45b436a45aa2440c9a29b00c619d4e628857606398dc7793a3bff7d237625cc2f2b493458499e471085c34b8dd4c281161aa490e84fab3ef6f66de3e63126c400034e7d041292c2e838345497a0679bbb6d85d829a2d216c7b7cc309eff6dfcc2d37ab0b2ed9e7339a4e361e0e75b999456bc6140ee49dfcb9ee3e72c45989c6f8cf02ba74c651f05dd7d7162cbf5414315606e1e0296a4a18481a1d263bcf88d14f5bf5fed3c3cfaeb6dacc246ab713c1e811bf935244db3f5bce540a96498b785a8ba0550988966fc59b8f6d47151b40409ed845659bda9c7072c8f3d40b6a07181c57309e5b21a9a4ffedfb0921693511a2c639d927f5abd553c3520b09bf021c4fa998e96481269b69eb0884c54f04c988a48919edb50cb9a5589df78a5fa0c118bfca29501619cedfc559c0dabbd5f9bedfe54500b15c301e38f6c8a1941247e06ae2592e776546f7c7430108cf23b5d269a92f74e0973f9c1b6b740a375af917f9b7af724d42a8a19f837b40f0216a7f7424d3ecf821b22be81de1709a76853f1b857d0d79471adbc1b054b0beb97c352e39a09c5aaad9355ce0b3eac49ede22e144c6964db43f660fc3c37c26565ce3de64d6fb8b95505c4866bf6dcce293d17c76d42d497e10e98cb57d1252e063d1ddc55bae45c98d7de5112065927998b9b02b335d90825165c5b686d39fd0062a59d8608987ebe6d5ebe69c57cec8fc718449d402082a8feaa5729d1100c2ea35cc9f4bab81536221fac186e7c4fbbc504a8b15d122c312667c78d88055cf0056aedbe227af66990870cff96ff9611036d57ae3bbd22aab91759d48283a6de5437f02238649c0a2a2ffd67c255e4a536459f1e500eb7ccd348b3be07a12a43b0fc48f8fb69179b043fa4ca1ebde4b7490c8bedc9b57ea6db0c3f292cf6b4c64fdcc0a1889520be2779da1649b0b085b6a065f0ed4f6cc92c95c0c5099af85176751da817812e6e92cefeca3ac168fdebf9cd7c3f37ea7ca648f6d4b85fbdd8fe835fcd489ca8140a920480d7776d8dc6aa53ce57a0f6b74bf6cdac23a9bf800c1c35e15d25ad069687978726e2def6a06221c4df60cf78de6f4e5317ba99912eb73ee1fde82a242f6ab907906b5def411cb58df2b591f8aca6cf5ed716e0113d21cf443689c165a1fddb82891ab6861815cc04c5c43fbba947c2da8a76296836d9ccda0debb5aabb657f9213a21b9ba50e8598a565e3027d1853aae155f1d9bf35c24ff44f06fe68d27576c35da9ad9d950eb3402572ed78612818c77fe518e6454589bf6a69504b01bac5c1ff600d6fd61f1ea1e672ca022d5e5532c4702040e29185c35418e0a39cc07f87199d418cdaac7c43c4af0611cd26e4061c22d1d99fd5820a81032ceaf5de3072b06ab478212e07df455a2d9e340ef3e1cc8a140c8b0e73e3a2e9db1d47f0b8902027f6f8da7f26455447650286ec7b603518093732c57b4a8b7e3cb32ced07c590a707ae1bbdcdf00d0665d42b0da0fbd6ac54d888ec522fe51721dcd22bac6be1f50bb16394617af065b272919f44392c5fb50970d0f57ad01c3589c6b7cfdef0a8af64c776f6c0030de4c69c838c4de2a37bd8bb83a77d31dc1593cae5bd961bb8e2b45de0ff738baba887a54e8034f68dd1b62f17ccd50f81be145b1412658f805307b40eda04dd87df346728adada645773e97d7ba934e7f7a8130c7fde4ea947ae79430899e2ac6301c46c8567cd7ae210cb703fb5f272f66fab862beeaa88851f5ebc7c19066254c42abc775e71f1c7a8667b645663aeebd9604c392a8110ce25bea955dcdbd6a9a4144d9263970ba97b6b1adc052c70774114856cf3b483aa8fe16cbf0a55a564c29aa8032e795c2498a137fea28c94b8023f8e85ce15015fc78dcc7eb4c4168fd25aa4dab6c943d546e3240f1aa3cfd31fb21fb91cb7d652166defca5b5edc47bc19bc2295a9e28efdfdb6455ff4a51d44983c852914718851ba800281566debcd2ccc02ce3787e18a9212e08041584d8faa2d174e70cb0f9e5b0034a15cf67446710fd438621035bf1d3ef1da2ac870c23e03886d8737a01abac7f2ae950b4b6c546590d0a5473bbd3552857e9446367971ce4f19db7462ebf0417f8b80b132d4f353fb1eb403589d1b9f3aafe63ade5476786ff7a8afc7174b01e6640e83df71e91d510e86b3971e25325828d6d1273880fdbce897c533003728b7d3670d2066f8f1a6c54f01ca2638bdbcd1e1fa56e449cf991d13c189f599db37205f6fb7638d762c9db5d0ea312fdc172c0760511545bbddeed5b221453bd8cd89c56a1fb9d6b9d4ac18624b82ac0b827f899bd6b32870aa47f8382cb6bc9314f55a0c17d1d11e9348a22a7ea0e6a7a96072453ec39fefee6bb783d50f5c0138bbfe8bb727f6870e1d8e0e4a4e0511d7dfdbd7bc0106cb6243394a99f7c99a7568ab88b92dd20fadd8098fde2997dca0e2a7b12de031d36982d4fd117a6dbbf03766407e6ff6ce84c56ce81359f0c08e2c162689bdddf27dede8bc4028b018648a09ca2a28fb3200ffc3cfded8b47ae6433b6d6fed687edd5b187ac46ca0e016a37b0295d904c5449f1230cd810010bb5c9cfb0b98423423336ac00b32d69edd1d2ececc6ef3062af017d666a1e9749534b6219f6cf98e6d9160228ac9e237c78ab42d46465831f4519a55d34a808e24c7003e53e65752666ececfcd950780e2a389407cde80968ae7c0e5f51fb92a8c889c104e46596de1347ee9eb1dda4525ad6485eafb4814be48dbf57a4069722ab5e1a838f196ae58623179fa57f5144f719f3f185b560c3a631ea9b87d5ccfe0b619a5a69399c65be390906185da2881892f8f69a0ff28443d830ff4eaefb9ded1204f6fccfd84b65680dd73e913bd94583430df3cd767d3dabc143011a2e73fd7788c3efb6b6ad6108730534758e4eccc60e23e641466539a242d895f8b0070b78f100ade4487299d82ab72bf5e626881a839887a315272df8e6dc76a2a79ba25b817a0a56ef015dca94c0242d735f9dbbaff2cf85692578a05057e342bbfcfe251fc5150d32dbfd8169304d3296f948dd97def8e6a3685cae910de685205a8c3dc819b8c4257aa4766633b9a3d0aa408cae8cfc451386b30877989af702dc62af7aa589d2b0d89c5eb119991794333da9c7bc2d399fa75279bd5378bdf232291ae3374fa7cd5ff7db302fef89c95567300346ea2e763f0b5151e60f7f06ed22d556f7fed9ccb94d75ad3e250bf28760625cc28b3494013cfb2fbbae7fd305eb2e159db3ceea9bee74162fbb3f1dfd2e50ef32ead611628e44105117b89f402ac655fe4915d1e9310014d9edb12bccf71144137151d8d7544bc614ebb55c9fbc1ce872f98fdc32c389729ddf789413579a4dfe92cdeae9869808ffcd8dd01ecec37891b03a0318c3b7063e3f65caf9be5914a580ea69a18654543826c4c56244314339d06016f854b70839199dc64888c50e1dcf8cf2e267969e814bfd5a90d427e19f0ecb0766e53ca33a3951c69558578d2d36cb19be8abf120aa37be2db64b01188c2de1b0220695c2aaab3a9258d9a7a3ee14651d38627eafcae3599dc3a549b8dc18b48c4acbee1f8e62d0ff05dcafd6da1ad0f941f31c40d7e2ca5413c9b07c54bbd17d8ac168731e273805dd241bfff588831d979eb1cdbaa26ac56d7cb83136c30e41a6cea8d6ab56b2dd98efc52707477cb1ba33c59c12819348c30a4b0028ffd7cd1fc204b69abd557ba980281df8df9d211910dae2dcb9bd8f3a70f2bd104a1fcc56c792270dd0c8812989ccd700d7cd79ee72e64ff97a17fef09915fed2293384310f33104d0149e2c106036bf19b8d6435ca02ef766845a8cc29b839e8caeb4d1eb7bee47fb905018cb51883fddce42e29b69df20fb4c6a6ca4362094e748c427cf776bfbc151f3d46834b44a264fdaee2ae9903561ba73bc902ce235004d46bffbd6d05654e801ce6bd2ef7097813caecb27a4bf82e9b777e079bda8be6846ac7aa70ea2e301b7939d7bed0d8140f41a07b034f87b8d312f96da25092a730c33df49e62732c9c3a9bb89cfd8afacd2fe03f6f1aa78d0fc7d905f73dfb8ed15df509a8b1983734b1aec73bd3c59c5a9466af400b70bafa975bffc61b3d4721488ff25c7fe43468852f37bc1099cc85c3ce6cd1aa2e93f1c6f0755a1dab4098e446fb0b229962704b98104869c69e16a65b5f71c118b2f24c9a4d4d3eb303ff28b0c84f95ff97cf68211d808d71ea9b7a9c6746ee0e7eb4737b905e5f1ea698fb4dcf37dcfcb6127b07d3c17761a0998674cd79b7d6e82400c1acc95819711717e01a50c524d461d97f76b592da81a6524abc27798d6c22c7c6049bc3635b0e5bccfd8a3e60c7ec6b71c71efba5cb7f8731dbdb4e420e42cc158f042a667ccb4150fdf08a54b280d579d4a32af3a27cebdaddfeadf2b392f9929f98e69784b6a00477d050b118a5e48597e4a3010b5595e7f536bd1542a3ad9404f44aa5f3b407b9e7702d1af5a1236e128cea960112801d042252249abc8fefa1a76bf00f6055b5525799f559d16d0fee08572976cdda2d0cbb473878d56b2072efe8207675844516fa5d5a6d90e7a290e993af4054a04e9a7fcc77a78891714c4e400d59da1db87b3dbb8b3c0ba0340c483056af08dde292e02d6f85eee43ebe07fe6331e3b55465504ef73bc745ea3f9e99eebbd00c292649bab512a9267dc753d700a94f566727ce9be0480bf7fc83dd0a8e22bb2ee61635682f3e5d0c720a8df8d71c92006d081801ed8c6b730ff3163b9557d232a5ecd39792a251461d025717677380bf4f75eb79fdb3b76707fafd012138df1c6a045370cb9b53e8e8a17fd9813e4daafec281e8c36e4a2f9658657f4f3ed0470fb2f6e822101bc3ebf599d6b377ca3ee8d666f6431e2609645605665a81f006960fecedfa1bcae06043b30427dc38233493c34bbd5985ef82fab9021f2dcb9fbedaa4749b6bf5973ff90a5f9333fa1cda34027c16959e534e004df816834a6591324eb55496b3e03d0fca04e1e0728d4b7a3a417fb971686d6fd8e7696bf05765bf41c71acca00c22545dbcaf3cbc0674cc2ccace712d93872efc6f6fbede898e9c95423a85d791b57bcba53d29fa6146020b3f0fbaa0a80d172f374bce606ecdf1d0630a22d8ad7225c052ee76a9e5f9806196bfc00e73d65b4910bbbce775df73668b842e8cc1ca25003f8addc59a597de00b1d099b650144379ea92e846fccc095124ff0749f76d113decbb8121e513f8408432778091be0b81a5ec7e1af730497274c7d30df53f993898c109bf357c8439670d8e7c95007e995c5cc68bc77a931a4cbe1d3e5d07e610ecdf14b73212681c49ebd7fdf0d0f45c21392f436b387ce3acff3347d2bcfacced0c8a34dbf0015da50047c9840354956f7171d70b5a4e10cd79241b6df80f765167b72eaf2fc07a777690a2c423916d49bfbae6f3f2ab4fbfd1ab12efca8ed067c4a74522dde446e5f0e69a24aeb404ce3ba0807de162c197b15fdb3fbf6b85ac629a76d7318247d5ec4b1181a3aea132cee2eb4570db26ba4ef2b7b758676cddc68ac645fd5b00c22079c32ce05cbc58ae7b38778d665e908524eee2c225fe0ca4a908ff5ddd1ed6b9e4da37000f80941ef073d310ac6482493f89a8a0f7adf2287d60632d3a724c890a48ed163d89cdc95866d4e4edd0949b65afb7dd505eb484e79682da2bc7c2d1155e5a75169ada33d30072552c643bb551bb4d7878e7a8f3cfc71584ebbbffdad5a2f04760a1cbc36700b6865415fd35c0debaf7a4612266485aac40e215a70dabf2ca4bfed4a4653bca660d2defdef5f536755c9eb10a12406f65498e2af6521e89f938654a1e51ac3596b3ddcd0564922b67ebaca2df437f59daecf79016ac2f50e54025c995c7fd95954b1880d4ae62f728a6480af3177a44d4b83f051a24fc8b76dd7460e5a8bbef38df7be003f210082de1b186dc4d16a7ad99101c56aa9f61ec500397546381a37123fcbadd4465a2a0c2510ac3ab76fac0ec61c76ac239e415d7a5c833d4083985b452fc05dc6850da790b3804418a4263dee5e814d84c9b365b75831bd383de20e787bdc8a46507cfa94311670ecb24cfc1f31ee7f57a7c7d5cf1d15d672700f87dffa418d928446e5e581a6af577c1af2a3e97fbdc6da40e256214e34a6e5c01e0517794956d152be31b5c430a90a9a972772c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
