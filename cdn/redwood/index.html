<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d949d60ac3ddb009392e2b3762922785cde3223ffc8cbc48aeeeed29e9a8b93da360ed7806ad70f01eea5b0f4a07c9cba5406d112cac7b404bf9f7c0f6159312d77bd5ad4236573a906d301cf3b4c64743819b9ae917143bdc4a80e46cffcba3a0a5ce975e9df9e91994d2fc86977ac3bc2bb1ac13d044593e66860ffa9abfdef96b39c4e0503e6f743e9c510ef3998ddf709f68aa0a77cbd3095ce7fe1cb169177e1c087741c7995d2ffcd4bed8ccaf025e399eee52ddae7d78c1c07503daaff40033dac7d225eab68fb1692f416e800c99c3ea069c87768473402d477952128b5d1aff057f97187a5a467a14a8bdc3d898227c38f929461e4b431edf7429259f58a7a84952961da8e2774e073118a380ca30a33e28073bc2eebcdf319c8d350f657be3b58ba29e4ea298568ff0d40ba1ccfab61835d26a709e9308695dacd8c402eabc672064df44bf2feeee6cd016976e5caf8ed2d190b57e1e86c64406c1aed6bdfd6842ae63647990d84ff6be0d50040ff5982e5b9a2e7952769e861c4c4eac5233cb2de7fc0c55c1659b47b9bdeb15c2fb57c6d87caadfde967b2bbb83a60eee200c706d1fff7cfb819f91add759532588bcea59565ca5267472cc4bc99a075e9554a3ffcd11d226647564b0b82b80611e65f2417b7f17184c7de31a8fbbef47fbc50ae28872e3b4c0eb4599de89212edf181bb8962f93b490136b2494ec1e11e39abe5472e12debfb2a96a1e441d170e22225da3c4cdaac2eeefe144ca58528f2d6e20b397a5d035fc39c6b6cf179b501f8660cb56a3a96271e2521cf507ad7810314b1baa9c5b34647db7e0e0a73f6967beaf02ae3c2dbf8bbbb146db6fef7abd91d97b3d5415495973638b2bcadcdf0fe3a0ae1342094aee32d14110726bb61845d2795a22326e86ca451636268e636c364116bb5e3d3c35c2815ec57838f22387b0bca6a197c12aac086c0ed6d9ab4722feb60567ce3e5830af165c10459155b94a298cdd5e67388f91d13b62ff17c0d3f9598a7cd1008c09ac04640c287ed55cdd63bcde09c5d16869e904b5c2d4dd8a1d9250669e9c4a2b97e98ea62fd7b321cdcc1faa138a30eb657a46a98e3ab4ba1fefdb7c5167865259c9f3a113e64958dd43dc3c091f12e8b647d6136239b2b3de3c3f0a196002ec688d4bafd091f54624637cee87995867cb6805f4535a966a54b59d75b6a39fdde12d4cf7b30d39b0d055bfe0ff6d4f7d48351a5dfbc9c95875c5ef26a87d5bdafed8daa2e9d89f7993bb4832d3192639c6ed978b8e5e96632406847ae3b33a156e26ab85ac96eb543fd702d8ef14b14e556592ffac6c1d77d191f4eefd19446abe09240ad5b90e35d3344c57ee2f417ffe5dddf5aaaec1bd374ac080ea3abffd1f0378563201a947b1aab45fb06a1a2e9d74b2313cc4a03a6485649f1098c5fba2cb8e2ddfc750fa3e7a9ad09dc46f015a79874f60fd1d3b99cfb1a8be19ca0ee5700e84a364f1c3300e4211f4c0ee8608a4f04dce136170406b327e77d0423e609ed3148715625aba29aefdcc970aebdbca89eb1b3a6cf91823db3886d04f776beb9fb5985e18be95df41b2ef453e779ed24d298ab3a05ddbc358e3873434fe47a79c4a107dca22bf4fbefff57241d408fc7f212c2f9dd94fc57cd9c988669a544325afc587bae77031bdcf7d854ed1b7e77cc5a3034d32169e7aa0110130b390399912971f5ff0262e4473d9b24e38fc45c7375f9fcb31670b2c48410020da007e1ded41c3061ee6a745b3bc13413cca09084aa94c80654d0056316c32153eaeac47cf96b989d28c4a7dcf208aede654ccdefb694a5a2d79d05bcd046b045ac4c34438c15fff49ec62c3e6ba1344156c086327da1ce88cd02e09c966ec773518707ab3f7a5262b704f715887a686ce2cdc57cd2b8ff9e8a9e3d213e6a18abf26d2adffc0c9792d5b2017b00bc887631908f41255dfb81aaf0338609e3ab02db3ca15f8af155676916d2d44ee4e0a1a84bb263e30ce443c5e9ba72f7150b373ec84ac288122ef9e1b27ace6db613ec1c9c9062387f89d30ae1a7386620bb539221fbf07335a882a2de4dd429330b76274cc4946f0d23ad436c4b72989d1c0519a614e34018511b7a11b08924af223ec5412acb47cf2e91f8c95df03ddae609c73cfa2b1d90bbfde05b79ada5ca7c1e3139f11a0e1ac04d3dd689c743d4b87b15997e55d953e84ca0d3eb9e6ed7ffe87936b725f83125834e5bbd2766de626dddefb8aa595aa94d1afe8eb03865fc306e45fa4601e4026c90dd3e89b86f3c419d47f9a3127eb2388f40f530272a4d796252f251e51bec7cd44031d4612195d2f3d932fafb8d10644facb9587e109e5da4084280b660fcf21ba92ce373b5773990aaed0a9f05cfb5ee3bda49dd9f8b15c8bff67d971ab127c476972c4dd9f326e8c33f98cac0ccc556be53fd3e64ecf04bdc3dd4cf97b86fb483d9fe28f13ab20e64f89f693fcfd8b7915286863018fd1f882752823f61f41abc4424a63714c2fac6dbcd52c982c945db483c3965e3d8875b9cf58e8da30ae4b24d09b123c27ea9a82d232415fbc1750c0b613e0c78de81e52050522757390da6abb6ab9c61ce0af3a7cf5386dfdeaf26b9ae6e83bdfdfaec8ebe2bb8f92cd242324f93b0e02bb565b174764fc7f15e517995e25a987b00a7082fdf8c7c64d6958095dde5eb79e5a17c22c372d7cd26c1d1881a95d2d39bf7ecc7ca99d5c4127f451bd004afa9afa270cd6c0610ef424d84474410e3c8d4d9f0cad9571b5b553132b675fe5be4717761d92c36d9af9474604a0fae6aacb4e8a8d48b7a78d927b1569c09567221ffa56180ed87b984bd61c86584f41aabcab3d499510bb2808abf2493b66c094ba0d31fdb80f7dace6547a39a6b8fd445752eac890fdc6e280b139a7fe7494c2c85a59f277dc9a9f9c967882d593a2a318f913919d0ece7b3e9fc5f67b241208316bc2b3d6e8913118dfa87c2fe3626f44e5b89c0a0a2ad4889a469ae343ce6c482d98d8ae903659f1f4da023a671bfde4989ad688b31cd2815f061f09721e088e323c3357efe6fca2368d4728277cf80ceb7cfaf31c3d3802e92f44fe910ee0c4f35002755d5f2493ffc64878d9a0c2ddec1b60571de019f59ac358b0e740cd2582b45f652f59f70f85c95d412673f9a6ee6af4d49a0ec1b6b737b75ded05b11e190b9b6b6111e905caf663dd678c09b65538f752fbeea2296f0ba43ba7bed6be58fd837f0905285f6f3305ac7be1e20c45945dbfb18fce4794fb5cb175f72502d48acd4788e602020d29b863a046111d254419f504388ee934e7802c77a0c3871535575852968198c029f3cdbefaa9d08d416bceaedd022b6be99d9843c50983370da660ee73eb6dda41ffbe5a599e8f8651793635982412279f27a311ca1dab3bf781864499432f50644224745d95279427be5396af26abcdd7cfe0f18b7c16038d5f2edf598e970df992d5e638d6b5a496d8d9f82c1d2928853220f1f2eea05a8733d64f04910a3f36606d0905ae71e837afb083252f74efa139e05f9cd4201745b7e15c9653c78871282372a3afe387173819ec7488fdd3003f6bfacf5cd8cca77e36563d95049dda7b7795be951d11dd1a16be92742e6616b2b56eff4a3b9db6fd7b4bac1c0c2de51eaae92bc8852591e2b9bcf1e9aa70c204e2010bfedc3e63acad23bb3bf42cf35538f342e74e791746507db16c92048afef7ff2c2919b13ac7e9d116689c72bc3b37e4daebdc36318aeb4ea063123edbe1670852a4d16e98373c3b4d5a7faf9afd94609b50e318affa05d96d5f5da60be3daa169fa33d2dfa2d182019ba8ff8cd3c29d465cae200917320f25de1c187e0907ae82d3c34e55b8c3c95cedeaa0f5c79ffaf315fa4c60543e3f4c31fad12ab4cb4b59a5cce4f6d1a1beacf403b62585606334b6ac19fa6de843861e58c303105e072957f289bd70fd92330ef54487f18e6d64431abdf543a245727c4a5e37a6e646a64a28d14cddfee5820286c0ce4ee0677f897b503a649cfbe1de349581e8b51c18b7e5d323e7e785ddc83c2d21da45bcd9de9b2dbb05154dba8e66396131c3ba161067e92aa25dbbe09a3d06ae8d0064dfab343a88592fab9c7f7930159e23a9f636c49b3f52b9540e86c6c91ce0101f410f849386732cc0c74ef38d0babf34240921cb8efe34aa36ef11ab5d48048e07c1e55649030c445a9d8d814093bda011dfb81c884c8b3c307105a969b962484f063ab7108877426417707d68161f1441f3bdfaa766c586e952dcbb54ace9d818b0c5338706de1efc937879f5247caad8dfd5e5a5e6c72410ff468726dcdc121140a39f6866a6267384c6b574e0db82f5b2865f14f66467c6fbb83067c838aacec42ea198e1d21fe84c371bbca4ee276a45feb24b8a364b5d3c416509932b8f4be58dd690cd89ea7f3166ebc44d4f70175634a506f2985e5b8d37380c6edc6c9e419509277a9f1c1e0b16a44e8a83c60d06fcdbf9f34ab894f069ad0b830ea4d04521fb79e9bfed9b220b4f9e88c80c14b2a8f204615102bdf084c1e49941f71362f1380160b00a1f1ab5c30f9202a2b7a03272565302a05cb42da8f24e084832535b6c2e5d916c04c7570cb330818435610554c0daf54d871ea13f08c5c49a28b8c6a9bffa1cdded28e5fa0890deec16326cd1baf4dc5383bcc580a34980ad5830dda2f3b70d36d98838a46800b7925cb434a7aef6d3ca3811e4d07ee88bf3c928729b518d18fd714b926c389a4111e276e9eea1a5fb0463f05730cdf5410bdcaafaf6c6ecf3f7b3a8c23503dc600bb45b747f2a582a04d6ecc0e164ab819ad65a6c4226669e5454feec22ec3b0c26172892520066337f493a43f422f4248c10e65d4423b93d6288b570bdd2ea3c00893586552425b231e2becca8829a86654cd3c6efeab4e6203a8b61c0663dca84792e96c821aa103c84b2445adb3c42a252ed78c0b00915409a7a83dcd62becc2ac64dd4b5235df4bbca6de35a2e8cba2eb922dbcb32de3b92677e558e760b2a9d3e37f3f0a402e06b2f965148ab6324789e09a62fb9c0483bd3c7d4c202ae1e0eb74d39b24ad679f9bc82ca2b2fa17c2c9b9f16180cfcaaad194044a0223d432c4475c98505feed234f021ef773048648f3fe1fbab31e7029582b94c97199f4946ae7cdb009f974ff2423a3529538dbc5e1a023ef2a9470db49e64ecab6327f6a6191ec034f1936b5b9012671425f17d991e59946668eb53b1b1569e3779e42fb16719501f6249c92a0355613d8b1ac980b37d2dd549ba39ee2c71788343b35eadfe7df90f01298b80090c452d6b7d3f930cb61d8704cf78598f764ebef1d6b69dea2e8199e6007ad1fab2572d349abc8bcc777a6bbc07564dc47ef693f6d31803265337e4a9c4998c3daa0ad9da29fd3abaa678494c9228a1c56689af517b973957deceabf2276241cae1e866dea98f275956c2a936d4990dd4e1becc131d31013353be055fea1acc945503b00fc7199f48afa0377c8788ef0cae03815d0026e0bc0114adbd93eb525265e41dc1971db19614999d8187a9b73d58c2e9f8a911e790b8752cf487d62cf6fae96153029686732a4b5f46e6ea093315c6e54f36b8e8a6210fef324e170964d45f8db3b997c7a25e85854c5c0dd117e00588bbb9a2a1784a023eed80389735c0f1b7a0e8b2fae9be37c427e45493285ffb9a240aa437c7e42e653f506a0a3426f7ee7e2cce84f4478a1f58dfd387c96c960bf42ffe32a45115ee3b5d6abe628fa9c6efc805270ca303ce31f09d2393cd499f08e592c5d0013595ea47f146b75341aa1582754ccc55157638533a1c9a602df449fdaf03e01f05b96da52576ac3fd9891222fbc8536846ee57c656a3d76887656f08cba6f62457ef9b38412add8b71e7581e83ab7ebf02ab7daa9050448ad7ae38490cda400d3e3ca2d67f3b61255a3f60aed29b6dfd2b22d764a8bfaf301dd6ceda3259d7d707c3a349c89cf98c71c5ff0ec943babfbd870e314625149ed2ee03db1de79701e254610e102ddd0f07751dd07a82e7f71a9a58b4e249e4e2db238bc3ac10fa5668214b53ae7ecca82d29aee591877e9017f1a01511c6b68c768cae2b8be4bcc50ea5127279b04d0fe575d60fe43c40a4e57024ebc64b8bc369b4b07b075487fd01825d84f8f733d5abfeee1cd65564938c0f711f65b2abc8aa8fec057864c7aee9acba4eccb2230b8dd4d9bd430a60266e56e48135cfd57e7d0e13456aaa4990694ac1caeec1cff978714aa08ea42c63cb471808b08f7465adcdcd40dcaeeb5ed74f67c04261d6c8938c1a383e88d65068a24810df5d46e1a27b55899b53740e6644f2ada2fec917c2137d5bd29ccd52725b0841ce5a8d9a5e192f8e486fe2e69a2001f325c824b8d022550b70eb14cd662a198811f6d4456449d8d08f5e02215e9b331438f69687f31f50165933480ebe1f33648c29dbfc5e214103b986c1b0f852140deed18a01ff8f85a2826b37f8210d8b0c3d93c2e35f1aa9f66e6b1cb7860ad898d953cd744d65e37b523d54d061d012bbe5b4fe6bcf6c1d330c2e408fb4a093f67076fb181d9d15e8dfaaebac8a28f2254a535a0c7c3ece79d02fac0e9dcb934de6b0ef228725887b512d85e238c34bfe53202b5f76fb638d2bb2a223c2d961b2be0aef251e76633531369a2478e489fbd0a4ba61c9ff16e3c4b03256e39893593ba426038c342ceaff2b5cc907fd97627f772fdd5b3d65dea7ada4d7a547354f630db8b086cd18cbccaa961b114002ea32df5c36d5b5561c8d4983e27278e0d5def197cfa0cfdd11b670e6be7d6d1597e05b43f6c3f263efdf642e0c32dfb5db56afe9744d78f31cb28503d012aedd379f609a35a409a50b503262a2c99b82cc5924004f7e948e53f86ce490fafb1716c99e918829a95cb161e7a7b94a592f1dfc65cf76039a3b8809d593c063eab5cfe693f8fa41f25abe35e4b2289731cfd55f8cf5ff8a029881015012223c6e2db23beb48f4c866e531d85e43fee27b9a10804280f0fcc62c4726deba1f085ef99dff177a9c68cc2052bab2a99cac98cd9a4bdba4fa026a138fbaaec1acae476444206d73ebb46267b0895cc3e80c9516cbc0a43fbb7b364b7f8652ee040dd7cc963f015440e246929284ac4a982bd731d14e2e499023ad9120e2283dcfdfbdef97c6fbd78028c2068284356ec7b2ccc3ead912545e8de4c591486b08760743f32f5713dfd3be8c6733df6ff6ae5c55f961127c0606e92d2d88b068dcb4efb207306da49cfab1468b44fcbc41708261532e00cae4975ada9f41008125db43157167e9a667ee6a566b75a6b34a059a872ccbe83e7d49f493250afab229d5b3825809a1f1b1daf4d77bab65476255afd8b325549208d05268dac1190c3032d6f9ad89ac056eb98d64e36e80ad549b40bd54a3987fddc591479c94020a565d2e1fee7ee8e96530c7eeceb0dd1ca6a835e5d80e78d94d92bce9f7b7d941fd8ab59c4cf13a7d3dd0f24265daa29004bc5a969bf296d9e0012e505424e54381e7b2dca13fd2741631429c128f5ad4da7dc7aca1b03346c9f731ace632edbd5d8e32bc4bcb140ae8048deb00966f37806c90eb68332bccffab63d39ee936b401acf9d7b9c95378bd4527c167667b00550b40107216ef0c2288a822330e3dfce9100781740db2311a148979e01e2f8f9a8f72027a43a277e7a671505ba35626efa89ce440cab88db7cd8068a53f2e874ed48e134826b5dfe8b34936b45c24247f2e54a978c94d2bd94ede979fb755d78ad3f6f36c9a1e438619c4918228f309a22f962a8b42c5b693310186d00c959ec5ad529d43eb6edbe4e20d04bc612060d7d40ff9b01d4cd50ebfbe64c2f4756636e1fc6a310916199d80d40c7fe8f2b00ec11f2b70212cd9cf0d1fdd2cf0922c5d5221220f9f91d96b7ad4b60270cbf467edc6b8359aabc3ea8a1b58556cbfee3cab40ea834ff3e9c91bfcb9c883b096856fd7dc77e7e1a43934ce6864a3f5fc0d8186f796a2b35e2f8a397ee041b0d87c1935eaec7cc76fc270173d02941530ffb5d5ebbd089748ca1b9a3337a4b134978d45d1981abcfeeb0088c64ffcd46a79eca4304c8e02f338c54dd54e9f0dae9633c3fece64212addcd344ce523ef3b791a6e3175e1b116d7b773e798443ed345ee58b59f0e706a1f772a12df319466bbca9d0bd64b2e2a253bf4e5bbdeefb4f1b896bf730386b500851ff135ce48634ae37eacc6a3e46e772c1a3d2a1cc3b71494f7f9e230c96cf1d22c41e2f92084f937f6b91c5a35da76d8afbb03e69106bedc6bfb9a18ecd1002b6c68738ed96a86b07c76d3a2afb8966ba999b07808de54edf07e992ef1fafa25d0fb9bd43003e3cc65ab4de0ebbe50892201d64f8b13c16990320d72fa7fb2032870184a7c18376707edd07057eb2520205a12e2cfd1310ea5eab877844b9219785d18e596d65bd6268a01774d5befe3cda0e246a6603c2a1bae9e4cfa314d1cdc5d951b4ced4ae5a9311952db2bbcdf1c05c22c102989e803e54eba1b085c19025bd5edcf769daf3ca54150493f27be2b7458f154241506c9c94a73cdfe3e807b597af7ef7d3718dcfd57d99d31c188c191fbcce537df1804be64d516a6571376a1add39a7b72acadd8635015925f510dcdf6176dd0e61adb483d1cd6ca88e670f2c7cb4ff2a24fcfee4491561aeb90086ffbf9af3b9cdc091fd2a3249cc12437942eae46c6a24f300e03e7b5de693eaaa0dd048e9ccbe86e47f69662cb078c26f4c7545c64c008bebfdfae129192d2eca833a4a5a54752fd220f9f839884f610ffd052075d693c9acc40d20d636bc52d122b8c96a56315aebcfb69ad97d032875772b9deb422bc09e978d1c6a2c1c289769dedb13838c70153baccbdb4088043514735fefd6c668898c4fd4001cd84fcd515c8b8238db17b6c353ebd772a9eab15b2af43ecbbef1e7487a148bf9f487cbe827246b733bc032abd45dfae6878ca0e9b39bcb58e6d23e3dcfe2db7299cb8b6ba7c7f7d0f52cdfb67dffeb96a5e76f1a2d21cbb3a65d99deeaa61de40f374dad51dafc7f2436d8ea019566b047f36163a1be46002c704dab4e00254976874cb8de68201dec1c8e52e94d52c77f14b347f85a75d430802ce86ce2226e3adae6f2011c73b03097ae359089bee0e7c5cfd8c9def690fd113eab4418ba9860f248983c5664981e865a021ea044d30bee7a124d5a4a5cfc1833653b0282120f50f427a85ea8f0376c457f3d84f52477ffc9f8f2867887517d237a3a7fe4feb21ce9ad5186c34e7b4fa375dbe5d3ed8be7f07a934c583e75807784abcbeaf34bfa70d66f998ef198c0e4fc4b54f5f9c198ec2520e2d276e1f438ebfa3a808abf82b2079c0493982ef7bb3facafc2ca48ebfe3b48e2c2fafcc44f25e12c7b95c54044a04486add0ffcbb0cd079e11d65932e8f4a1fa17778ddd6130241f3bb6e0f582c67a86353e9a290ce5f09835095958999969c5f6712e23c88873a060df913f09167f0ffdc81d0277a5d99b4e058abb276f3c2ad95c842dd19e4527dd284f2093228d7fbbdb73d6de38710d7ca99b42e841d6a48df86a5947c788302a897ca8f5c3d6d0447862b8985b0b83214f32dc3fb4d4b580d3109df12be3a1cd401e0a5bc4a79eb7cfde5b9bac4d95987193e80e94f6a6ccf3aa975501f44a87c3317b5bc2aebb896376656a3f6c4beda4f9093c319b313cb8080478d057e0bf9c5569ca4c5b1358f200ece281b9f391aedb8d75b7ea1be0ecfdb36b570e587c883fdbf445499bc0026e07f10d06d080ffbb847bc2459318c67b9104048c6c2a2494f619ae18c08bae65cd9a59732e3fbbe09d0e5f1debb75b13afac5cf7be9e2cb0d21d786342b8a6c007a31351f0dfcf1d129affc8041332bffbbc779b5f037431f113539da6f69e6bf62326965612b3ea5b935449243ef25463c17803b21847103ab2fdd7e06c6e6a56ff2530209af776bca8b9aa12cdb5c8e2952cb8c201bd7eb40ce467d68c6376a20477c2de18eda0e7bb233fd837b7ec0898bbcc02f5e45cbc097db8794c5a13ff00ddcd517873f19e49e2a2fb12ca91ce5c3645941db59bbcb6b2b993332770dd1989816b1d9a76947e213befce6b22f4c79c1d0d2097882c8997c0ec466d9a7c50055dd484d5d1e8ac0e08c161ab7febb2b7dbf7a3829d251fb0bce86ea69ed5b46a918a53567693255327c3972c1731eece128d7e32904cb946ece92dc478aa2c933ddc6f8564a7abc2eace691c6d447282902d55168d3b505e305c0daab409e588eab927d5105297d918cbb0104a2eec3cbb5173ad402e8256ad545ebbbb328590eee2f2096e81a73bee97321eaa71ac675d0576017da581265e44aff09713fde699cc97764aeed77dd3ee756e14c6f7101ef3dd560bf0ba5786b6cf1e66f51680f33544477f886d20a6c7c1c1963f7f1ab538d3fcca64ff5e94989e28982d74c606b3dae09ddf02f1e35e8b1a049352b20ace937cabd6d1954c552338daf3f559828bc7bde4933dbdd384ba16ea5650a1f3c386e2314f1abf348739244420c06508dc0ffdd8ee4f94b95f7a85af2ab2591357210efda068cf8db7d7f35bf9cf25f0b2abff792a19023f5022b6fcb3426980698a5e118918e6181a77c9ddd81b4f11e5f78fc3263f3468941893f1aa05e278a4b2864e35d80d175ac593a122bfab1ad762dee634ff7b1df3ac254292caece8f8070c8d64d5bb2c2c4105a2245ea4df4edda72800ebd9c94991439c8348a9a2961ae37c81b1059e02d29b716a342951d6368132a0da106ac06619ab9ed634db279d73b62b1ef29b0cefd4ef22bc14a9a0044cd3b8840e2685c12aae374370d86b1e62e7c50943d9ab2fb58c0b3a835c657cde6d073677729a0fbde4c0996356d0d6d435626f57701aa6aed72d914e39928b19f2827cd8025bff20102e20ee487c2a443983f74eafc8b5df911072f219cb96984319d3c5c76ec0894d3283b274ff9051c3b0d24bbb16e969feb95e2c7c70a84881842d998457d97ef28992d0854f5b62b0fabf7f172cc3527f1c025836d67f1c95a9b0fbbf600076f70f4399bcc2938ddeccdcae6c89e56a4785a401635fd1c3a2ead5786fab1a6265dab3bbf44411f62d65a5fb04d2b25f0cdb24eefcf3b1bf7f66847d3e4e2342e6da9bba6590c2709ead420094721835bfb01fe7f729da1bc8112f0eef8fe59f913870b7cb4da37b9fe5a1ca28977e7ac26dc956b735cc067d0559411173bd5bb5c62d8bf94470e3d734dade63d7e61cc0aa36e4db8f85e778f932c8e939c172894d284b5a8c059895874c790378b7bfb812b2e3c5f03afa9df6ddaa48bdb37458f768127690e484082f0a24588c1dbe5239ab5210bf8fe596922aa815b5838c795dc718db51373f292fa99b3eb59479cf5a7207d51d88f5c5be8df272e9873f8a38db1c6fee8db54d257e70062d9b1592d2ccd41a1b05724115d0464fa3638a063d659388c7bc7970bbf3cf0d2cd2f2e63a580de5c64668f484adfab3b7459db2e2e53ca64da68ee2cf36de2e1238e5b51e9fff38b4ddec7eea035c2e1e322d7bc522e9d22c74acd60ac891bad0bf3995a1dfd3549bf944c0ab6601ed22007136818680e239630f1994fb207f15840a5d594665dea53328ead377688ae3fb7f12f28f0401aea33f4aa785faa409780ca4e0da1c8ee8f3a102fd800c07e0b291589afea2e2acdb6c216434d056efa909b3a8c24e7672cd217eb4e240090d1079cc71dd2ab27ed424e8c5e1f041a21a83150ce99faec29bf4affcbd22ee505049f3dfca42ca185bc454dbbd082a9309253d510f5eca4950baf40c8d4821a247cd5d688adbc127837d77c8dcd8fbd63d5d7bfac9d595b84b9309994016e6fbb2aeb38edf096ebf2ce141420e98ef4db126ef870535fafd36a203448ff63e4776b2f7b95dd40dcd889c5b818f177c71a6c841b0d22dfc1826e481191ab06ca57ca0088061d4450d7d29a02292b86f2342709e8d765ee5ff9fa39529aabd60dca1195fe37ab213e0102be5dcae86fc5f7e0423439453527a12e4ed850a0ef78c0fe6ad34e40514ca0550d0e3b1e2a09ba6c0e86167f6299442e768bc6b20e925e4603d02504c5170a9affccc2fdd67134af35174462fd5f058147da2454ef33bce4ebf69dbf155f3851fcf2a5f0beab3da1c8ba5082dc7ac112399caef3bba91bab315b9590ecb7d417e26d3fb635ccefb3a872d8c51b70290d2caf60fbbc637123fa23fbb4f803b5cd48c6ee0efeeaaaa8fcaed9863a6648315d61291e06cc36e0933771b155fc63be72a2273933ccfe16a4c76ae972e7f9467f74e7eb512e2c0722f7c22b8a3fd1138986ed293bf206afa40ac130b2997eb68bf7b480a5f168a0b0c35230ba0fbb988083e6b92d05c30fce63a678d00dbd5d1f84ec70beb6ae5f83e6c50e233db4c739edd5c07bc36941119113b91acce2c56bf87d4c68a7842b167c5e9b68d06706a04d7a57858a2f38b3b671cda2277d2259e8cb34484de97c6d91f7a95564bdcf8a4810e7b42e947bfaaca2a145e115dac01f7f82dbee7ca64c4894f82d4d3106ce3b2806a62abac22ef022b583953ec46bf3c25c1d33d9108dc11907020a52e656d467805377954bea7d09076ce994376ca900ca3fb72dd976bfcaff5035b05b42a240b1c6e6e7980303df8ddf4934402aa083e382c9744c7b06efa59f55f03c08bf790c8f3e7abbdbc5a37b8563d45c9ff4d380c2a012a47d3cd74cb66a376e49839860767d1f1b24b4b0f6215a187aa777218d92595efd1997347559aa8bb9bdc68a8fc9b36105c3544f838bc71c119eed22fb5f41848fc2d301872039fd4e14bf6e781bed531a4c5f55355411dd6336d392942b937cc1720b5555b41394493e1d457ddd93de8bb106d9fd487b2412b54285b99f83eb2d2d707ff4ec1a646ec34118dc2851ca4a5eb985b207ae2806060c7045c68b16c1aac91d95e04f256a504e1a7a86a17346b96987e9eb06ae764409d6a5b7860d1955de07347cdfc5be20525d60daf75b7dd6929dee1fe128bf744e63cb5709740c50c98dc7dcf969549715578054297523b497146cf233b6a71061ef4e6d0175519a6539edfc1e6c7081ae9fa156ab330ac0217b9878595f050b256b6f32df4343fecbb141c961033a75e73fcf5515403be33856280219550523e4486d3cff3fa3dbd8fe8d58cfad4db7294abc646e34b7428ac6fa6acf4275353a9e3f471730a8f861ce3b7e28deebdfe5d6e91f1c30de6830183f980ff38640c5992ee57a2d3277ec1174a11ab5ff295d51d0592926c9a2c34f7b0ee9ef1f0b405b02064571ae984e6c4b5bbc90bf99685196f666aa16b6b59262621e073b3cf835b755a638673cd321446d9daab243241f7aafa6c5562a6452fda909b655f7cf33b190ac82683f31d0650d82ad83a29a09858f23e6d778d58cae542ac3d32b06e624aae9ed39ab55eec579fb6d7dbfb235462de93299f3aa41f3625312cd8dd743ba9f864437bfb91dcd67a49ae218a1a0272514d639306428dd1f855b4e5956767fa61aecfca47541663d18bb34cd98628f0657ce8fa08786be1d3d948f01d65543555afef75ec90c55a5181c7dc0de95974663a8769546c92430a1d8f3ed6cdef3561723370e751d0c38bded3187c30d66acac9534904df406368431b4c3359ba149e41b508042f2b45f55167da4f827ae5b55daafe25871def5c5270793e66e96189aa5a7895ab906de187e4f4c111ba084537120d723e1d2978e9e622b6c1cfde4df93b714f1cf422719e6561c81aad7d2c02da8387840b8acfb454175eebaa5266a1001edd708aa7c976f41bda05ad3809b914a9b78e2eab32561c01d38c92bc3743cfc3a6fe98bdc2f086b70bb866886d09b9b2a70af83b79d7b9249446d44456a05ddabf95ec31829cd5b3707efd5f6b38c6b4b871b7af34d5784b4cb0d93315eb3b4833c042a2e32f21f4273efe33b195d319da239601026e5c8e88858f2a246256dd08aaddac4c0d7e81ddfba8a60f94d304a40cb9397c6f91b6cf6cc26ee36fefa08e833250362d50b01da5fea1dd9565557ab06a3692b993eac347834dd9bbdf52618733f1e0825a52a5f0128bc5c7562844f3162e0afdf7da8bde5f9d5ffe3ad601746b4e8f49d1dab2ad9e79ce5eabbfbec69471e836725233c42dfacb65f750737ea5504285ef2b23b31e61eab1c8fa0420fe1e7d1cae7332d2a996b4ba28ef3088e3e1ff63aa97b2187bacc2ddfffa193740a6df69966e0ea716cf79da1f6ddd43450e39fe997aaa3b5568afe0e9925d5c752d1095fffff8cccddae6be81f2a32e048784097a74b214d0678b3e0786634d02da847f2b4ecf3d474e802a4519663bb795dad30f9d611f0a3db3d8c247ed38d5a8c68627a72c0d58d07c211bc545764df6f4de569d9d9f6264b0ce7268b55473aa6826fbfe5e1541ac51788aced4dc0b11ce1bbee0c9277f66be1f89ff4db42114059c54a22d035c325c31b1959daa1692ee83aa35b1132f0ed3ddc4d354c471d9c707eb0abb80d268afc4318d3b2b53a379e41a7b23fd677914a0ced71ed79df7e427217d0e3b429ad6ad4d8355ffc4a6622858bd638bfe8939e799da112ab6293fe1edf47f7b1d91ad1dfff193b52f661c6ade694176ae9980e17886e36d18cee39ecc95e2f69f8dd58edb0d5ee20b177e899971da80398e0212bdfbd7b3fbb7544398a89e7ab8667e9b85c3ce3e928906dc8979d8bbed2c1c65671a6e80f7db7f39dac04a91557bdbafe7515351114555273c30b3c03da089d38165f336e793f895d07d9cfbb9c3730cc38404a15999b1de465b3bdff1512ab961a6d52a1bcaa40fe2a9fca017b25505fc945a3adfabd99352d5bfcc006c76bd94e5a6340d0698839e0a37b8c60bda16e66973272ace372ff5355bc44adb422ba57b723a04d222b35eb691a135c70c562894b5ff2d81deeb25d0b9fa71cb26cc04ef9196e8331cd83e65824e7bd717ba8433d815244ea34f5eddf50b428b86a9b23832bd38d71269496b73a20982937823d93b433070b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
