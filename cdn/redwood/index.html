<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e5644c43920552b4f937604d3c0e550ff6ebc5aafe7392e65ab25d9fd015a7f2830a62d5b1d9810b2ef9bf93bc87a1c8841a981e7e1ce115161605eca87e679db3c3184cc5e1dc29729c4a1b10d68764e6362a70a688ed6f587defa5c331114eee9498b71448927656192ee60c890e90ee6dca503a9ebab4acdbcb0a814568cc21d04e284d9991e90547d89f0b2d02a1f30415ba4d612f85565680da8d58adf754806973c64f4c12901e8af98f94a683ff7d81decebc1f4291ea06890c01476183a172555d919aed6d65ddf9bd33c43a3512642fdde0840b0d456b70b8db54c49cbf5a9a31161a7bc658f9780ecd514ab5650f71037cea2255763e9bc31c9668835df56a5c5dd068f8141969c0c8a6b2d7bc7851bf01b3aa088eea296b7b5227b6254fcbd0d62b8bd870f14510d9fea67b02289862af4f07736934a88ad04fe90560705399041515c3693b4adb9686aff72a747aaae6f50fd417d6e40d5ccfdd130c0ae1b2c7b3fca23d987f935da9c1a28ba1bd1ab5c3ebc9b0ac7eb2a31f1bbac5b9c0dc6125dc4d4c2f31c41b7d0a814f1c3f2c3da92b85a64403f321d33ad9abcc3e53fc2ebe6c049db6706cddd8964fc09c9051c413a7c9b2d893d2df05cc73a52aa27a4f210f26dd7bd32409db349af8f9dd7d474c3f538cd326796cdfd7c824892bcf3abbf28e71da000e4039b9a0b8ef6cb799089a09cfe86ddf94a866d74b380c7f564f2a401461c6f9c73ba431a0ca2a51328fa8586f9d7309d26c41f70defb91b2a3f854e30e90f0d92ba10e3471bc69940f763f25d26a523c0bab3fc899b9ff513729d441973923b677ede8cf2a5e497a146659658086e1e70f3dff6755d20b9c0d40fda0fdd9ed630dc3e9c1a35154f7a7c51bd60a96d62ae260f870cad409f73e0dab58565bb047bdcb73af2ab1dca2828a62f57d6d34e85d27cc5d3487a40a1a907c9f3e8e4985065d9d5147e267b1b93c5010b23e15b20f92d025bb582b79d8f8d8bfcfb4fd4cf98d7e97252e02a724aee17a8cc775b63e54db4c20755e26c57be2d55c65a5dde0022acb98edcd4db9acd6c7559a3ae460d477b59ae27632a18c2b4b549569ba2f321e6c0ca5857a346a41774907256d713ae59ff94702bdd597047512893bd0381f283a2fbd53266326a5b8bf66c3763714fa6c6204bf9965d73f32274d820aeff5f1c38fb3714632e2e3429fb186eb640215db8a80001164b62164743103c5835b5b998ae07dc29c0a7853ceded4c4017cba730c80b3226cc6fa8380852d92a8dcd731b1807fb381b311906d61695fafba5095db2f8b1f63b7db4c70c8b7903abf001a7a289fd0e529b6404733adab1ebea75ea69b19c3ac185b558e8fe998ab76d5e356bdb3d8eaee106e6e37b27bcf834774f6d983d6ca97dd98b88a4462789bffbbc674e2fc853cf1296e2cdc5d31c25c2f5a4463d246d454379c69b5188560283b15293ce581acb7d31aec1a384859f78d21af1d6499be853dcf0e349f6c363a62a6b51ca656e0776f4637a8c6b4b26ed033b995e724511002b286d4edd5fd2a22215055fb75a5f5962919da271a26362c83f0dcdddde840ddcc786c19d3976ec3694f05b9f80f3f42317ee6951eb87bb739915f010378c0f93769d2f00202025106a9c94d9c99a4bef15e80b38b71eeeb0f2fcde64ac7d743c2314be522f22d42293b789aba3d1a8a3398037a82ccdf8588b2a4ad4af6386a57870eda5717d1abd172455f4a48db87937a4c44201cc1f92c05cd1975f446c7deda0c7b457be6887c1450524dcbe846886803eeae90ab419631efc9e1be4f3bc46153520f85a2889a7c9d02aba9c7f1b5072fbf8c911377ba8ecb09391e04d24afd2e73ec7c298e5c3a7fe24eb2ca015f3bdbe3886efe5439ad89f9fc5a32a80281a9b5f0351b9f4dd5a623553b66c98192b5f16ac705a99561cc1d2c06e64f41c5fb78b8e439eca27db057bc37526aed5deee637dd012c5c75d18173cd206c699e301d7a3502a62bda5b8470e72b0ce2f9c015ee64e900209658e3a1bee1eb69060a66eb501d322ca7c248712de5f1b0b132f4ae90abc3a6a05b8849ee83dc4c6fcd9ec6369d5ff2eee2ce1aac4e2070ee880c332eceb78e97b7892fb37eb732b9fdeedc65a8734f4d7da2629d4d7f9bc6710017d349cd623b502700a4f3ca0be78a859c34fcc108d365e33af449d93469a5a3b5bd21e770463248b0cbd8a51d6305c82ad3dd02bd2ad513b4ec640f63f3279d4f91658b52bdb573d3f09b761bba96399bec6e5b76a22fcb027bc62f3d40217ef35bc542011841a08c9af0f74644298d24fe450fb5f1349bc217cc125cafff9b0cb8bb68d16031b5f42fa4101cf2a59c4160da9770392017763ae8134a8ba2f10be0ac0720a49492a26e91b175b9c67b8d06f789aefab1769738e4cf5336944c3207b8dd0b344b3eb97826e42c5edef49542f8b541b88a754eaecf9ddc0978749a305084c58ce72e638484d4cd8efb17f2dc85b348d388fafdea4cd9f5e378e9d6a81d7d4aff57430bf9d1c838a5ac959a28c49a8a0e375359f11920c72616619e45152d02c20d27721fc96418376ff36ac70ee69cf0abb24bc648219b10a8eedc3bdf87baeb488461a16aff54ff40d12d8d740c74d96e865c35c89a91ef1b82fd15f04e7a5ee6a6ff25665e0b988d306d1cdf87e6b385ee700b944aef98ddfd85b9a5ca6ffe8a9bd2727de81250862691cf056abfe648c0f005f4b58cfb712b1a0045a2e5ce36663393f418a282866391c5eb77e3bf9548d1f15d39dcf4002753aa3f411ac525847a08e197f683ba15cf86f2d7a3291ddd5f5d8edc13dffee4517e15b0d4ddbeae4625bc092318d802898e2090cbf2b86f59e61566b7eb8cd834e088cbc18f583e98e6fd3ff54861e8949ae46709264c913ee5c3a411385f235ca1ffe19e1aacfa329139961f42d54d0354e2fa91fe662d39d02b57bd0731aa96506b655f9eec7eabc27589b16f9e85a6f2dcdc18d8714776bd04520d1a7f902f39cb0f2b8fca0d7fef700e6196a45dd49f6a76e6d0f2364c58fd092c530baf3fc673c776603176bd174f0042362d006c837e21cef23f5b083283db0027db670850ceac83a92c27d5cf7fdfac97b712a93cd4754d8300ddab7c183afc950c8a5488de2cf00ab9eca6f99217106c04e2c5574838462be011ac0defa4205d4fe45279cb73269207c81f602b6ee83bba8bc7019385c24e7c19a342f3ac2b4a7e75a9fda04fe80c85a6c3799092d3af3eb207390d49a6bebcaf4777ae03cbc8755b8e81754b2b8fbb3773c1f9b089877c108c2efe918c04e86f85b1bfd9906f12558fbf3c4c78d27168b71785bcebeee590396dc7538ae95ac5b2ab94ba3b8e28e753ff6d6f2ad722fe8240507ede9753861f4071ade31f4a5394bc9bfe58b109ca0f2dc9308378256cd10472a32dbeb810a74fa6b521e39e4a37eabeb999c144b672715c3febf1a9a50f52687cc02d1b264dbe0559d72df74aef2a6eb63eca59060ccbe4f3cb4290b980b93457c76213aad183fc4dfcf685089e30a24ee6cd4e8d6c2e4537ec5805da94a9e67bd7b36750e8f034f507f0a005b4ecceb5c56871dbde4873a0fcaa6e7e60758cfea1795f0efb2a9ce819bcc6e9060fbc6e44d7e86135dd81145c0baf56db86261870f91cf6b0faac00195805b12d63bc618ad16576e48d93897bedb0d38d15115ac6548019b31cb2dc182ec4932a430f0168f1cbd5d3c14b0d1e07c7e7061f5152c30b2acaed1e95d0f4275eca918233b13f72bba59d9d9b48e95f10392d3bacab839128f7a2b27a679bcf08444171f3a27a4bf5897074b73174551a048371b68eb12fd51c63bc3a5f4b8ec8e301cbb6cb355807f5cb0961b673905b928d610a93e2b042ca2ab550f27dc0565e3c4a8e47ffdc48c4e6415aa69fa6ee0ce3401b2a6f10a5a262c43a20fef7d7605b51b456e68ee70520be85e84fb2bfab97899efb23e669d77440bdbefefc0c5ad346b6656e5ef7a3e21b85f39d403436bcf268e7819efcdeeaa120ab6e15cbe961f7642146fac3ee7b59549e9f08484dc501ebd88b54d7e370dc635ec59e94f305c7bb611fc50c9287c885887da71242a07f3ffcd5bce3cd2f8ee48227e61824077dfbd09487ad4981243c7e291da6d74f0511fd659577a5e8ce0f62c43addea768b40f9266614ef5ea5f7a5caa25dcf6daf68921a35b07bc25639ee5fe57efcbe9a2cc1ceaefe40332c849fc2e9a168e1e962abb39f0790f4e04f5f8d80c4af4c41eb91499193dca9b3e70620e7ef17b7c99fe5f2bb8269ab1108a7fe3eefb6e987597c9ab5c248df42a6cd5e15653864c48837007e1c87c8bd7117fbc1f5613dd9a4bd5bf33c681697364fdaaea8738bf732c11544ce0114d673e11f38b0355f9285ea79f60a7f31cc43e6712135e32ada1625dc2dc518aefd53f20bc32abe9ec4e84dcf5212ef7a9ebbc07e19c8baef97c5a21fab455abd7f14743af2745fafcb9173e1f4cfe8c65d84626f854274da1e59a5ea03716f40ef1f541998f1f43113bdbfd3bdb1c60c378d9d8b40f55b2c176390d5f92919bbc3559628e931bc3789aa39bdbf7fb1f838d2e4747ff577b4aad78a6e833400beaff2cc138e6d66dd46a37ff64dff4ce820cd07389ab706841d8359dd5921d64d4e83a68732072ef681e9ee326547b9f8e522854d849d5fd4d57f50a2cfbdb7407f01892fefa7883ecea23596d95ae7b6e2a9a606888695f5a549ee3f88ed56fac8f2ca96627d420213651bdd1d8b1ab34e45d9db7c1b30f73e3fc965afb1ca038d5dacdcd943b28f572569a9f8201f02ef5b2546a63a83ce054b0b8d23c938bb3d76e6946ded531f6f03938b6f9f38fab63d092969ac3657b43ba444f49404af3e907b46b061b98931f80983e60656649c45e4fe5088e0bcbbfeb32b967978129cd2c1c47062a5a4b4de94dd0b434715655edd589b934c2f0991cefa66ae9e59b3aeaaac93c59fd806e8b7103283f3eada1ad92f52e02d5789255fc5611f0f524a3652290fdba7c9a0e81b991ccefb8228c1f9d4240a82f3ec8b7c85f371bbdc599ec12734c25c4378f719b8d58f0f989c4e2b88968a7fd87c3e6f4532d40129532f93059752e7e7794f555d6a062e8e52a513cf9ff0820ca145fe86f6544bb9af06496058d0aa99d5e441778d39236892757ccd1b0c82836a4b290e4407551c53cf00bec58e69787cb096b38b15721811a85cd77da30eea091e20270875488fec6232a97800f58b3c102d27c354289f9f2f84b632f997f857052378b176b38d43b3db7475a556b3f54a9a215389269c1a07f12fb71d2d49f86e3880a1268ba01b73f4c87e260a004f09851bbf5a4a8830899bbf8e73a859bc9949b743a0cc6c7803197036cecdf0af2d37bb60774e7f536d7a05e48fd77f355bd1c5b154c6a71a54ae20b1196f0ca25a3f1543165e16fc33d78890f65c762ad418042d522609019304dac85223efa1ddec62bc9f167c1938b7d32cefd5698215306b2e52d52623a915d5cd7b2e488d85b306bf786785f512fa9d7839e668797b5d8b13d12f2e7dac5466424586d4766cd6a5fc936bfd362ff1007e5ecc76a28294f69d7c54e6163c534882aa9350472e662a37e83b4c809eee6d746523e9031a3aac09534aa45109280d3d52763a4578eb4beee6602524a0f039d39fa57b7a3eda27a5985e3b82e24d176bd7cf4ffccdc2074df3f73a24cdb220e4df280b8f3e587b0df816b7e3838a33a28bb541f6679c7e56748eb0fedb35a1b037965a1522a3380b67860d723b499914e5d0ca37ef25534d9dcc75db33724c85f325e448bfa703ff79e522fd19c80027b257a5c13d5c793781b58e8d1f132da546af81084d32e34bd5d16243ab0c00c88fb2e7feee0938d6a499c23c4b926be882ab78a6ea23318b594afc3a68886cb0369cf2a3ad7b684d3589d23908f57e48477c77dd65e426206d1a91085301d218d3145dde5371cb14ebad5c9825349dfd8f2fabc6af16be510abc1a09036e5bb40a0ed93610b2243138a9ca97d70eaf88b8dddd7eb0eb3d8163a2afd081bf164d7f7897515e6b943861b3616a91e027d2112194b9dd536179a8cb2105f6a2f6dc77c254b5477186ea4973ec7c03a7831977b4f5072e0c48f598be8b6f948b895a3c7ca381f80402231f887c4033d9583af6415d91917ae8e7c20ae52813b94d8f2295eeb016d3e92738ca4565558b3042ef521b72e9bfbd73f84ec5a5a26e442a23495fde626551d820e2caf0691fae5deb84789a73a2f6f37a4e5fe0e951de4f0678b51cc69345f28b961fb6a390ce64f2503e362b3e1f444332810956d5d097c3e1a914e1ae09a65421bd3e1023d413816707fd11ea82badb5f16871e25bab5c6cdcae503526796caeb6f1d88a9b17ef563af871c57e518d80f6724c99170b3591b2c1ad81824317dbec224ee45f62e9ee50f3c4ac99f3abd3636cac3c13f95a2481eab0831a1d03942dcd6ebab817c9c83a27be9b28bcb53f49c5cf3a254c440c5cdc39a70b1351fae2f10dd32cb2eb621e535a2e11ceb8b6595523c69162132a1b81409118f527bea323c4d7b7b5379825a6e15e6106bb473ff3c44987310a716defecbac7ab0c6558325f381cc706d7d2411a8a903fddbc12f73a42134428a0e91c08daa813dedd7a3280b1c87c27dfa6f81d34d10c1183d21a490b407a7f96efed1dde9cfc930db4d94281c51b1a60860089aaa1839e1134035f4fbe3ba950e97e8a52510fb9e0700a952f261242240bc23a255a3f18b3926601cb53aee6ec98b134ab134e1fff41c29a4ea04c1a81a63a24e9aae06e7545f7224afa1f6d9f28f13193dd098d82a070f0ffa8845d635605e24f1fdbef5be0617f07f1fc994fbea095d12e5d50313c4ad2622f144aee394f8e9422e462d4a97bdc702da84aa7e802dc22a11bbf769faaef6c6d7ed2c1b2ab36d0ec5ebae533ca96edc401548180c65f41f59a3da6f4a883eff5dfa6269cfbf092ad3104384ffc99cd3b90253afd9dbead5505c6b4d1f13002746baddd8c65ac35b7629b988062793a3ad39a1176029c3faf2462d9ec108c8c7180567c2e63d127d641800b8b6300cbb7fc69b75cdd17214055f75e9616315b03f5994cd74335fb77f81cbbc0d4c9b164caf02fd06ceb8297d027101393a30bb5cf8ea415afcc5e48b666e63a29af9de2d960238442530392758ff55e11ab569f8195e8eb488e5d5ac28ee416904f88d228eda595410d27842be7d9dc10a1dc7470892fdf3b5039c2bca789e55c841b3449602c8ca6c9c11264e6f02b39912ea4692952461c9fa718c28cf76cf1aca2870a945cdfaf3d3c28aef7d030f11574834526de0e4bf979bd0f2f9342fe7225b3242e267222ce51e42f2d85ef533c8c56de49434a3c06436377df239ac2919f33240b1e99d2dca51a13e858e27c0229085427a1c7217c6a8655a866080756756ebe7bde4eaaf2391fe1aabcbc1e9847efa5752edd6288922f6313f0640503aea740a33ce6a377a33440fa681c9b8f261339d083234d8ee8114d7b499219f003b1dbb61fef96752dc341bb7499fa1c36d4d1a2e6270f2154ef34e8dd708598d38f84e870da14561215813309809822b87ad1dfee5ee5b6892a97882494354a722f704c3f9eef63d5966bad6a90778adbaf90ace77b528e0eb2edb7e68f7b51a1ced2b8ae52becf17c8fd086bcf36bd3b27afe81482fa4e750fd9c9a82b469d2b3edf213ea5e314057d56f6ca9669d882fe739501e751dc8522087941b7cc1aa7999e87b5fa848e79f0456ab39b88640da3121e58d2ce8fe3a7ae515f98b63d70cdc1687f32bb39230c55ca8035dcc1f456d5f9d419c23756fd3d0525ddf5e6806e5b32f4407f1e55d72bbb5dfb823670cad3faeea531c96abfdb52ae9bb6c4139221cffaeafb981b54feab49f293e2b4bab033d50f3f915144ef0d221cdf8452ae220ad226b1db29d9463907dcddcad7618945b0730d63379a02817ae6efd29c848d93a92879ffc0586067a184b589bf3457aa11171882ac62efd47c4933d3eab2e64dd4c3f767245a10026b394617d118fc988d7c9ab9351c7f1eea33a399045ed372c543e8fb1e28440a1053aa0ba5a7df5ac7f1de2de8d310e0044bf718a563963d46a5add2d29181c5fb655a47f18023e8fc79fc7b0c2caaaff39c89b6a1acfd1d2d677aa1f80b1bcb572382a9cdbf9fd621b9b1ebce23265d550e34ea038557215c6fa6009723cdb9de031490993a39d5c69608601c71cf78169947922771f96515e8369a12c097d09df653fdf9438ae3938fc0b5d604c80399a8f8aa3e33056e8aad199f475128bd27d40d036eb3a3a97d7c61a134c5dc0fff395520b640d997fe267b53b4242db76302760994d02b628dbc11f59cb95ac505c77843f928526887be2048dcbfe865c40d5be109e010dae6c27ce827d0b02423ff62477ff306b4da5bca17b9031b7d1ada9c089a8b1addd5d56b0b2df4d12636b60702c56eaf59835e6a64a487173bee9cfa521098834df73f37c08aa7642b59bc3694b547aef9272284a715e99605d549fd980697aa7a10bd7dd6256ea3cfd886e1b7f399e38f84bfb4a1fe84629ad3920912c4c1e9cae26219c7faf482d3c781277022d900e2491771c13ab605eb37da5ccd394b30cc4434f4f0a238df68c6487ab1e8e3bcebced01fe10d3e2e6140d56e2c9d576bb2446bb7fa9af9ef6267d45b87f25c408b3235e8293006ad34a40c9d1b93721da8bad91444a10da82e170fab6ade243dcc543e7664c90768c010842181b7140323353e9ef8181a9fcb27ce01e6e3cd0cee6bb02bba3996d2a11c9a51d9169c67056d25d8fb01b22db3a993297c428e92298bfd2a036120da9493e67224266113a65e42377b07446334e68fa5ee7ca03a292a72335c331baf464df81f6acfa190b1970c229aad5275843dbcffb880287beb27c154c6c6f63f0cb2e7d184411a52fc8f1656aab711386de28977b42a601ecaed881f3d6cc82c043b3c6d1a5c2963f0dfe194331c705f832e90a40a6b9e9efff4d4029ae0a2bf56dd813a6ce04dfbf39b21f5bab62e5deb4d060603baa6380ce5d0c50623fed4a51f53acdcb090bdb8c2351e7826b53179e23ce95ef7a56a6e5668711405eb25e8a7c38b93641255d7c17f8f8e81dfa43e34b43f7ef5dbf7613a0d633c52099302bb06f58673cea87f75a5acf1c9fad963e52082c09da38c700c8cd4920be93a711e8c46eb048e63f16b6b2b71db5bd54d2ead2a607f2bd428a6a465954019cf6a1cbe5d098ae2314e40ab9b6c8bf985f07e1e1a7b7120795de6a2fc3b30dba01f627b8430db0ffbd42225a44e31782bac9cc91155a1d6a500e19bb593ba61e1cb3dd832879dc970504918cf690bb34039d143a69834d70c3bbebfd6bd08b496f3a83f4a0f76fc87124c43d207b06ef4ea49df7080218e65f920f181d93224e229723c4b045a7284ba0089b5742baf8f785f48afa34b75903f5549e4c2444ece4f273efe396ec874c80f07f1d77af02da0856bfc47d13a1c3f75b7364fb60f8517af06319134f4c4fadd5b69d0b73b5b1d1ab94747166016f7f150360768c9025cb4c5a8f74cc05a7823c6e3b897523b2535499b0da72d9646af3e7d8ba8cfba5396d5083f18b210768cff596048440dbcfac28086344c807d717a9592bfa2df3528eeb5384310592f71b4194b4cee4428c228c75f2b9f517a8496fd65c5929930591764a65b72352a8e55ba58e89f448ddf92632ddd968c103bafce7388ff4585560431a761213990d402f9892b266c08dfebb6dc40334fb31c7cd8ff946a34b7e8ee155c320864995157ae562dc6017de6e318ac35d2132bdebcf64ebba55007e41a110e46e518669256389557534d8a24f6fc1cfbea6a4bfb33a7ed91e223dcc1d560d31294524158210b385ab620abaebda6e18b7cf2d0ca979b5918b7aba8ea579eb2993057ef8fabd1b45262c427bc75be91f9895f9398e147bf7ab4d537af6a1b6a2d68fa391798dfdda280af189c535c152ca9180da1980d27e930f0858b885b389d58f41ef6c3b282b5a3b09a3615a916f4883258cac8a91b8cf9062e11116d325f57104c3f9446ed957764778101e12fd69f4aaa1c53029d9deff23e2320e5d739e81af395e5241f72f98183e50ecb2e8b55f7f77955521443f0b5b7289b4fbca3a49651f280915ae81502cca8dec5df58b3020df062e8d1cdbc29b3cda2f06f3180ff5da8322fa61e7db93ccabfd515ff074fea0a222e39091e5655da798c6d017ed9d21b1dda9e054733b4908056b4194ecd7ac16833b5b6da20be1f279c0d0f7a6d8bee199c384e560244de91e1c78feb53cd0d679d011f8ac3fb6b292e33af20664587f4b21cddd7270421bd38791b5c0aa12e8549234a329f3d8eb62052bccf1592d06e93ffdf08cd7c73d15f0cc942258405910af0e703cc2f9524a3f850d18bda1d38017214aa226518f7e7a4c828165fb261198ccd07b614b623e8a8017cb3745160e6d7a5938d50a46e64b6e011e50ba045f56b8e176af13264058cca58e444413b17ba7d1ae89eee43fcc4cfc07871a676516ede40df528e18bfe776f66f2ae658f28deb4df240504d38c15fb2153d588172f6ae2c06e7a26e52616af5b2df7a5c3e4ad25710a659927e0181581a8b827ba41ebb117fc78b5c72860da8e5a9c33d133af787566558cd6c8a8e78d39a051946594822c89cf172baca03b9cdaca85da011aaa229ddb419b2b4af0a6b63f24228450e0bd19f700ac1cdb36adfff7a23639930d9e957d1388774b355ef85b48d9e50c2b714d15cee9983e42527a291f860309dad63baf072b48b35fc988e1d872f49b42981b18a2ac58c54be4b7c52032322e8f7f40abb5349138ed949f24b5631e2482201b535a92f6f1c6dbb9cc3f1dcdaadd9853adb98bfc87b27a773c09faf678d7802e42616a5528d6a9283f78e672c372919d7a981cac146b77343c5c324602a9e79b4770b847cb281b4ee86137a07ef0f72ae3b8d2df005b8e1e239fed997ae53a805752a97991f45acc448ff71e1389aa5d30b666ea48001b87dc9fa3180caeb9bff8375f4ff4db5841bf0faad85f378fbf05880bea04615a7aee1e82550977794f9ea7dbeba4a337d01b7b1ce76ce1431b41f74e5da720ec818d8ea196fbda1367b5a9bea13a5887f1bc6e6e385dca92be0db810b34a4afef4c454cb0fd73cec79ca3cb2ab6a60c4b033c26217ddf087875db83ef2d389bf4dceac544b772e1d105e4a943fc4650696f5800f974a87d30e8ceba886fbe4ed2d1e214707914aa039e94ee8946663ffbafa5035c47e903bd62981876f69bed1ee4ee1da18165196731a538648ba081b17d586aee82ee212528ba0693f6e3b40d0466f2243467760455372394012d44ab2bcf49c00bc5a643102dd6e68dbf9b0773d8569eaebbcfa8ea2995267070156da1dfc237b818b74b41522b30a7c5f1d7fb0b58ba299729d152779d27e171d65aaeddf636456f7cf228854f883da6e56c620d8bc694822211046b8cb3347a0265d8fb53c380d139bca2689cd6238611268e66790e3353b1c2beb55882fd61cf0e5a872985023fae252d245c6268a5cb6f3ea57656b4460729187e007a68dc78f23321ae274365ebe486fffe3a9a6b8916ee4e8488fd9ddf12b0ef8e198e0a2a177a3f03bf45ef3ca7767400544cf7300fdfd89e06e07ee9f945837a76d5424e74795de32d7b4d6d1b302c07e16e1e0b6fd4e24d79bfbfe09e6a7e13130036badf98e42871056b45a72420935a141d12913e35a87e1bd352adf696c3b8611383c5da082d3938a16438d9b86c414e7adf12c7d88cb8e11f0970d021b2eccd1549cbcbf33da5fcf1dc57645710370e8ca5ca861b31877bb65ab080c03cecb790c135bbddacc9390c504766f977b98a83a707c20d151156f07be697c8f10994a30872390360758a6ac943efd3c69f6e58f464a227f63611c2230831e04b96a84be3d1962d8805d2fb6fdbdbf4ad5c64f75ec0f10b30e1a1be5bc3587da5ab59468e4d83c2268b74c8ecbad8f30eb66d67fbc7bb24882a9efc88ee797c441bb42fd34859a89b22413b2873f03f6e533dda000cc15f185ccd4fb388d3044a43e3c67c9f31b42ae0db6daf69284896bd64d6a95bc15076263f0b6fb30d193751db8f8c4c231a9b981a71b7f146945e9f8195224aede39c1ae4f7b0f1ce160949b74c91ed0aa35fd0e493cab3107b93da8d7b7cb224808bb74300a017524c8c67d7a9fe2cfa639f58149e4bb292cdc7cf49c837635b2ee57df8a1a0602503a151d7e9bbc27cecde684ee4c20995f15523e2ec2077e744e7dbf9cc564091fa6968344cee0254539a05f7bc9ee2e2c1872571ec38dd807abc35ff6aaf1e39bfe6af8a7580fab0ff3791ad7262b391f1efa69112a73985752fdfa83e542a6b33970a1ee2b3bec4b9a4b43b6ea25ec87f6daad39330f7f46b877b63e913a73c62b9ef3a0df304979b9fdb91743f8cec076531b81e96f7a7dc30ea17a06ed69bc9731f46e41d64be2543d6d0df527b2c1acecf03a1440dff529093ecf09e52720497cf8af5d4791c8a6ab07616dbd6853e0a445930da3ba143020b7d0996d67d4b29397eaf9ee52aff7e76625f787b0070feab8cbd9aa6a74ccb417e5c69f27a43182a92c5a815fdc3706f1843c8ab71d5a63b8b0724dc29d10af57f4fbeb89cad7c756fc696aabdcd465d4f86502bdb804ee2e9ea51dc48b437a26273bf172245f5f2bbf99889d524f98848a4d567cf0fe4882a9519da951b201c80c9a5bbbc2fe6b70bb2701c016fd81f9b129f11eb307185378b50150e524786af3a099b398e1b7ec231a42796a98bb627e36c526e17b07346ddb6845b49078c42fb44fefb4282e4e750ffb662734404d4492a2feaee06329c08abf1a44c156c926742d64fb0e7a3fe313f0c257a7fe87eabf253d8625ac29945261fea9127c1e42be5a0a260b301bea50bd0f39c43dd24485d96176c3fd6e501d05343e419c1014e0c5b0579ad29db890cff43bc6bdc0962169de842b3958155bcfa83e927a25c0c510840cc053ab5d52638a011f28a26ff3e79bff319b2410fc77f175360aedb2015fabd86280b85663927fd3136308fada279f1ea7c3fcef53b32f26328236ff73f07f96cda38e3f9e8868e2ff25ed74eaff6d6c05fe065a63d4fdbf616ea424672bef54b7c4f44fff8f7019b294634d169e4063387ae46fecf2587cd03697995d3246fc3c03c1eacc63710bf8b8a02c88c708d776e30ff3dfad797d9be6a100614df17787465b710df63495f14aeb62d948fc85ad2af837c29f84667bb90d0f45823ccd1bbb329746b5c664f2bfcaab81979fb7834fd1f98dd3df0d108680b83756f8e45c8a23d70ff432611e5e232c2e236ad2234bf4838128609ecf2cf1280c0168e8e27d4115a924478cb4609d8d75163afd2bfccb72ab465d64d59f60825bf5d8d9840c225bc1a4c850fdf16203bc3a09cc262dd01e1d1ed8241758ef9f14a0cb3847c3193c256f685dab65d9048cdfdbcd2642308e86a66e682b6b3f8ddf54628f007355b5becb5a91a1a94cf6cab65bcb407bc6a50d7f82e37374eceae502aead3a38ee7873f273170331aeb5f6cb9311c0709498c810b1f2287390cad6b61b073a10467863412dee718076ee638f4fa6059beedd07b2719098f8211c00679fcbab5ecb5bf9a02e9fb55a3446c95c28b91013ea321d5d55717f08fa1c78a179234084acf894616462ad6a6181edb33cb49b2035821e0b941c06c130e9525dad798cdd7f6a742a8378d317830641c0cd5480d41a47c63a81ebbfbb0f0d40b6d9e0485aa60937b502df0471dc14e694bf71c5457aa69651b9daeb6a8367774fa75fd59f6648cd42f09554202266cd47e03128e4b6281215e314af0d359ff5ffcba74f8c6a492ee8c41bc98a872a11034de81356a1a192585a1f778bce60531a9cda3297a8b6a26a5e7ae9565e3d68986d0d5643450c6e3b69a785e8de0513632fb35a6e80cc7292e552ce7462f0e865a03012e6ddedc9551422c6d35d59f1f50966f99d64070533d49dcc076eab43bee3d0638aa368116bb4cfa3ff9a4c981038a73dbace4831aee2aaa958c0e4bef57802d043d27766c4c1113428844517dcffaecadfa63c1182ed211f422ccef3a9590236bb484109a42a28825941b6658f4207030ee46c792e3d2982202df373240db629676e1314fdd1bf83478380adfd63d247c6578ea236913eae84e4d8c7f5c24e712518bd15220e052cff8c7175c00ad87cde353e998804209d7ee539a3e30e885d252b4231061d1e4939c771ed1fce3a7f87f2a33b30fa790c4e5fdc8d8d4950181e8caee64a0f3886ba46c76ea4a6b3037c5b77b8557e57bd054f33d72a6b521878e9b851a81bcb4f74b40e4b27a79e0d31eb2f4620eb2c36b920be2a2df53245cff375c2914b82cd17481fec148165af62e58a5e91b656bac021f048d20db446d972b0030429d83c6c96711ec2af41f79e5513c3e63fcdee3559307d6c396c3235a60202fd10ce1891f04d52dbcab412b2c8b44d1260187c832e2233c3db8611410b50f2d3b93d871dde5be0a2f564a5517f81e9177caabd6d2579effbbe8b362184d60b0f7f5401eb2b2426009132c623b80eff720cdaffe4e0fb988682285c0c681230c1bb4a26fbebd86b819f2ef568a5bbb96575b9a7e84f01fc269ebdfac3b8833ffc965b3aaed795eb78ffa6da28ee8d32ddac1fc97a0b5776d3003808c4443258a2498befd2edc78cf88ac58f4ddeb0c94b7a5db8f2d007bf5e74b075372b5b7dbcdfa03ead206855a8876dcbdd375dd4238d11dc66de5050177f9a05959d39fe353aa3b662f30df1885d07367356ccab953c2d224bf6b02a508a361aec217f8d32eab8838cea3c94164bc37bda0104110a0b442e15c7630ed528b3920512df4aebca9382d9573b7f105e7416ec7393fe9c0de87cc3e862c0992f1b2de3e8977b9548b461f12760762fac87fc0cc0f2fdfb092c8ef9b448f6851ced47211738ffb45775cb5ce4dba44f00c9a5c9c50006515578e9a73898b3e3f4a9e2ef716bf1ab8a2c04843ec97eeafa5ea3fc59a99c0867045fd72fe642970a39f83d05f342aa9fcbcf8f2504b8616d0127401887b5a2706cb2d278e84126964d97328c8e64e865651df991c81ed413e9c95532df636a616c23229bec6054a739f845ef64b5ac1ed663f216b8509ce12a6f7240c77fca1fa0d56c13ff650a29bf39c05d415552188ef0d5f2b3e768b137ceee9b9e0aef8fb38e7e7c7f4e71cb8f4e009c2f474428af101573ddd1690827bdab996a2cb5745f0a5c9c4894f04deeb6cd9e88f2e3e68bf753287e02bcfd14b2d792536c7e9f68d13de6a135e52a9fb8f5634be728cf08fb33c9f3a491a1ef3c1912a3e6ad1e160e11428cee607fcd6faa2810e9bc4fe99c9fbd60737bcfac52d03ac7efe3577fcb01d71297a373f7d84d565170b8fca0e2aa4856691a897e9f3adfb8db35fbb324cabd463b7450b8fa536b04731e146deb236f96cd23e220c49af9a272ffeaf2271424efd83818970434fa0a71a6fa82cc0e380b024d5de473e5a9bc4a4f31fb3b35063965af44a9e6dc5df844055676a18d666a230028b43f0b7cd9ea7d7e183bc200893e35f1cb4e6cae9baa2caca30afe0ea80dba57bea4d9354426d08fc1ad2a20c59c6a2b7268b7b554e676a722434f48a618c4d651eaeb52c8f11a67dc779bae82cfe36f0df0dae21892e88d99d357a3860719c30a8d06af999f573065320710868f06ee21aa483e75c9222f9b1e1297fcf1898cd4151fa29a448c834b4deed5cb7f5199cb33be4c28e40257c7164e2089a3ce37503a9708a8d2ed7929ecb6062ddf43b2c99b1bbb0624406cd10edb579c352256649c9a2051ca01c6d93f949c90a12900312a283e8811e0043307f8aa11e78229bebf9f6b4941886b1fe39062c4995a73afacd6258df98492393960e6bac609e1b5e8b193fae471e31e6a9f0419e945a99d5f51a83224865ab64939feca7e8ac84fc19f99b12bf408b99b874aa74a773db9d0948f9e373e390a36e738d621b12a9091614a528eb8ff23f13c9bb30bdde41cf4d6990e0e9f889cc161ee157cdc38c323b756effcaa1ed0b65727ef1936dcd11d35c206a634900faa9035f3726fb7bc2912c9fe9309e10d098edd5abf520d9c80901c9bb55ea50d02532bd24c80e3592951f05f27bca7e2e1f7ecec299a9dcb15f6a2d6bef9dc54b21658f4ba7e16608657af6b84e2b338b67009edcbf7b558c63f0c77145573d93385882e7568a9a4f26b4fc2f620b29ddd9607dc515537db851e5bc58f616f5ae9b3faa8116ad9a2a12770dc8a1221a0234154cfa522324042ca3633958ac32a57086f20a94e07385064b7a5e80b09089d646db4fd7f204660338dfbbd13f0356925732cf7502cf482e2fae42d875b91ab7c01f08d63fb42b7abb422f95642e010ae93dd8bd9059fb1a9e4cd6da253cf283965bc22ab68b00c8b7928f701c3564d757efc50050d77cd5e0cf5abc25a725ce9975dd75966d9a44f4047e5f117b2128f4996a048e1a675082841b14e59f4608f44e07893dc51f0ad609246797420234222cf0eda0babf6c8b3ba593e4571bf6ef250cc78eb62cb9f5259840506cc96b9b81376764e3ddff872ed46e18fb8e08792b98767373dfacdfc498764467a60a80ca8034048fe39fa3b4fb3ce3c7ce020a602452349888375a06d9297b422ae283baf59422d7f9dd8bfaa937edb0b0fd56fc56e2c0a0600934b3986fc756c3be096eb58a45115ea7ee99e062e8ce65ea049313e72437f9b77948fb716072cb29d9b454e5965e2037d0f2e08b3d5cf6f1ef733348abae6cccdf8f96b2fbca51bd03e0eeba6e4b1794a05d1ea43b2592b4e5c4916dfdc07d0df50416a110304f6f3eb7e67063fa0c612be7dc931e12c6690012ba22aef387ad074c62507479221687c9429ac4f069cc9fb6057fffe45fc10749aa31cd7a1f9dc71d2fe33112c3a64e7b8f7ea9846e8875e6e9d7cfe94542174d876d154467a4bc136af79317ead38fcefb242e979010aa660359fe3545d3f5c9579a7faf55100c1f5ef968a19acbbfda1585cb13f5ca3e9196533b2d967d24d43adbd83c5c5902aa0fea31859965e52449c2a2c5584d357c18ee9cbfcd84dc60d2280487d78c2f8dcf42eb460b1e1e7a4d022b74924102e17e1d2b05213113df10939530a9c15c1873137ee4523bb1d694705b9619dc4f9f74540a564923616c3f67a1bbdc10f4ba96725f3df8083b2f460f769630cbe0e52f1f16b9f6b61a74f50a002d8939e9882c0512b8409286ff9769d1264e651f755dba8875859c368a2a90ce8f5ec1f411edb26d053d996748529c691f07ebfe8fc1c2340ed83a715d249140098a08820f437ff705de6d772440fb1ea1d96db6e8e441401f88d61c8c34ba844c5fb5d344c6ff47ab7955ab441cf38b1779259607358dff05a690aa1f43592743ae7d62a65bf24d8e06bc1d17856102fa32d87a4f4aaf8ff39a320db97b5a68b2247cee026988fd598676b20b4c744b03814bd762cb301b59d032818437e2b9375533385e9f77d4bc34fb707f7f0db43dd997117e505f1be022dc150f902566d98bc5b0e38b25bf05fe643d8e5ecc8616d3297a3e695a542d1df29b825b6f82a21ac321f38f00289743c9b4caf8ffc729b518d104ae28e33bf958a71fbd3100fbe5b567c81c521925d0d27b017fa24ad9431d140b437c10830a2db6f00c8ebd9d37bbbad44bf87f2cf45bdc8fdd135932a2fbcdcdd1087880832120f17cda8614db3a372a1b128e7b51ec2a60230fe287fb187bd76ef1b7d40c429226dfedf789819ff79578ef23135b636e85715488a735503dcc7f8ef62729386f8ae2c6576d786b75fe876257ad3a8a3894d43152c0b4eae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
