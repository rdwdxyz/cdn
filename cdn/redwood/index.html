<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6638940ee59993a4937081b60ed3cb3c8371ad78dd2f1600d4328dd7895a7c34f80739fa98b39bce58bafa52a536d1376efdfd3af976f7aa08414f139a006a8f502d1ae9f378be85725c1757b75f8382973e7ff27f701fc60d38d63b2fc8c810778ba2ae94a2b399a22d97aebc8aef65032c8e17f32dee8a7b04f37db643566c2b58ba6d8c1ae13c03dafa66950715264714c34edf5875656ad1b0d6fdc2535e26f0b9fdafb68d678ee68c4f8d4189a90557a3c9cdb7da64f58fb11437f01bc2810edfa620d0c96af964dab4c8be8963a9da64e40b637809e8065d22c32b7fd16e4d1561e0b70f39b121683245397e0f6189ae8e1146a9d6f75d9e3cf14cad1752574afd5e3b54d6d13ec951d7832d4b3bf9cc8de20a29cd057e1879ef04ff6d7a4a89b517f22e34582d5941a8978658d00a799d9c03b8c546f76e063ea029bce4352f19c143ab25e246db342bb9d468694dbaabe0493f7113f8865afb68cdc2e6bce0b6614b64b2a7df10e168bf91a696596cfa24742af758124d554eb424036532bd6fbe017b6988c03e6269d7b47b536d4817bcd060f41f82d56373b1e5170729de86391b3ed09456b417a9ae16e63c013cfe7d5ee889217f370f5de0d62d0a9d0c247e0af08a9f615b6e669045d3ff5a3e2bfdcc0f04bba96eb358c537017720a3eb6a9232e78c7634ae83847698d1724c2ccf0336f2af1c16dcc93f4702b6cff5817c6e556b0cdd0c9f22efbda9c258f9c20b2dc6ca1bbf4a7c8f3a1f0210a419bddde158ce600bb78aad3e20517a8a33490f28f4009c8c74085d86b0291fea5f2a69ce08f75783c4d60f0da79ff5d22625d97cb5309862e1bc3246ce259b840a347d58977119b16c955e985050527b7edd368263f19e55ef71b50c71319713b5a475e31aac562e0798c4795439d772008582791db5a9a664ff570e5d53c9232e6e1ed5a93413995afda4b502cd1560c6739d72a9646a22e3067baa85a7ed8d5ed0a2431549c57dceba29a3bd18118aac1130efe007ae14335fb90d6a9d1cfd6717fb6d08145089c3dffc736dcfad4132aa7600df63af409dc92fcd32ff1ba049e9dbde3e2a1af6471d6bdb68a07cb54d12cd7f15a6d05d2cf2096f05caa3d00dc6f7cc8c1297854984c063806e300f2551dd738c47c275ff5e215158ea8a5149fc5e6286255ad5d83f862474c5cea29311fdda5c991ad45ff346853fc3e9530be598191c0e430c55bf3e00220a57645b7a983899bfafbefe9fb544c427d3b221d894219e2d2e0580964f35ac03e84c96e080a7cd30679ffb80ae53a5c2ff070daa1bc60cc15e7a8cd7ad9fc77eaa3f9785e1caddd4611ab2d89732eb1adaccd2b18fd0a480aeb8726a422cd7f558c1e018d1781e4b4d69a2b0be2a6f5217bdd5d6410fb9960969441fcb3d3d3d9a81ee1878775fae5ad6e6e3183e26e54b456952deacd319520fa60086a99b5b2ac3119c21d65f95fa007d5c3f05aff7212025467471e0182023396780e9a5a28b24eef0f6d78d2677b3d418ed637b9adba7a1c501c1c9b81465d0738652f57ece6d346c688e1b757273d1d6ff4687842a5d3feb41ef7e0dcce8ea908b00ce844809715542cc8f4641a8496c09d032eec2ba402379aa222e31c1898806ef931bbe8f28b2736250c72ad0d5070678ad8ab402ff99a27840f2ded00972efa6011f17ca5fca34dfced6c32b65a6cf949c369fae45828051f5e457a59be11d800ea11a6ff2037fdd838a9a461dd074f0507b010d15c718e900d9df208e71760edaf6a1674b07f0ee9073440be8dbb74a91ce48a15406a47a54eb9c8190c7bc80e881bcea180d1e59eacbead10f12f429a08938309ef3c56fb70d57712c4015d46543d19fd44e309181b559f3979e4ba38561195cb4d800cb2ac21e311b4d5e36dfed31ecbb10a856758127a5a77123f5a24a03b8bfdf555cce10d1d3f99bc4743753eb7010e311c83206cd86f94095c47072e94d9abfe0652b3ec8db61a134e97a21e06222ca177bae5f29e790fe12bd39cd8d43dfc4019ce8cdbe2c30a2b402c683b726d7a8bebda81b6beabc69121dd945b52ec73bd79add278d2338c560a0355745769ab6ef6cfde280c4a9315f23c9e3c66e979836a9ec5294264e0f1e646926c5083c5277dfad99f11c14b2134ca5a60e70d9da89d3ecaf22b96e3547a5d1f5be46b89d27aaca9419e6f3d0ea29f21dbe1b4c01dbef433b7c3587d4f6970d2b31cca2e8682ca8ac66f2a2264215fc1d44771db99aabad80e06bd4e7f48572ac33bbb5ab5b6f4e721a95307beadb8b3cceec139517525364a7c179f396e3ac17fda02cddd4a96d8f3ca596393e76c445149d527692b2617c12c5d8d8109d4cf5cadb8c0ab2af2271df6aa6767015c36d8d6f6ace38b67ee60e5903f35e67590a5feb215a91f1fb5b1125190312c19af300adf9ab050da0e3ef42100b579e56b7cac0a6eeaa4153dfe4fc64cd44de0ff6ef9668ee67a066ddd9f2f217ed12fdef063d37a917118a66986d61db999a9c42bc5f43973a1f301785ab13a245b9be713ab75df0a9bef6210ef09c5966e2a162e7bfe524c2c1fdc0f4b466216593437d83a54131d41e7e75d75d43cf277ac7b87bb1a5c2acf3c7e3facb8a21041f9dcbbab3f17b8a4c1465315bdf78b94fcc2b4d4ab17634bbd8ab953a27e7e2245abf42d1d1c1aa7782e9eb647d48274a6129af896a9f9c79d2dd8b68f2b0271cff89c3beac9753cd7450c09e78429098c9503c5a157537325aa8f53ae404a5039ab3a296a2979b00d760c45351f0fc0dfa034e433ae559777925cf5f78395b1f49add2188db53df7d59fd097fe623146be674fc8c7d1e7d029ff8eb297b986877546482c3ce4a52a9ee672fe47441e7b33b6090ee77751a78e40f8e2805f1486986bbd294d32435d9eecc1187d24c11f48ead2301c47b51d0baada9eb765ce2b1c03aa21dc4d4e68c2879cfc5cd20370873f8ace49a030d8c76185d83fe497264768f6a35a230ae7f78b87a9b5626885bad56966889d0df266106d971c6de03324a4e063c2ff0168f53c993d5c9a2d2ae3458e6056b8a1fc08d886217308703266cb005a1b51024667c90d9744a74e9acb72872c1a62f376326ae6355e695cff388dd3175cc52a0bde2ee65338c837bfab178b473c741da526d3103f68ab3a1c61314a5d81748ecee143677fe058e2949f70f6bb218fcf17772eff98bcd5041c8f0e988e818f6f54897c3ec9e803ec04360bac0b43f9531c090f74c23b9d1281c8da04a9a0077247c2723ca9aefdd56502cf9642a59439fdd25d98fa1bf1d59f1f942125a3187b7b64e7f6e6d348885aeaa8394f900b1a52068de338c2672e35280ce37345568857c9863065d1466158c843b98a35962eb2512b0f715de3a78af8736bc8579875872ad9d46e88cefd8f9cbe60596018608a1a1865455b4f3863fc1afe040a6aad6cfb4eb0a2a5b4e31436d6a3dbae8c271f3a6d1f822453bc34b10d149af01c9b55aeb5d9fe7fb2b43c135b85bb6ac3b345f395ea9ccf45539fef68eb5d56f9dbe7c90003a2529dd9cf5a865f7134ec39932017e84e715b5ececc54fe61a3742253c06b16fbe5d380624c9ee67b4987b9a076b39f69911f74f0acdd6171d93a9021ab98190de98fb1a04ae97a35cd3db381fec935f6a89fc966c7b5adb46c78c8054fac63a2748679e653e79f5c498b810bcc0e318844228fd9db3b6d68bf5c436dacb061696e7e0170a3e436c9f2ca717a4740b95935a0bd83a0ec0bafd5ab3838581178591cb10b39526b093b640f4c0ade0530d80ea71b78324319199269076fc7be6613dbaad8c8a6b20499eedc46084c31cb99581a5d8b2b35b54c9e175b14ed1e6597416c2df5ad6524353334a82036e4d3b05b208d1bd07e29262876ba80ec65a65e184ae7599e0a121008a51c746141c84a1a5887bc3552fbb917a9d2f3ba951c288da96f0d38533aad1b9a0cf675d5f1ccd92c097cb6349ac59850938a54671132dc43dbf7ecbb91f0131e65dc7969b2da0f08c95b89f0ee92c5dee27bf09dc271a5c297a21a0bc4adf6620c8d1e2b018f295f658c413056c1ae96b12c460447db2e091d0eff4d4c87f998f2fe6d37f4af434c3ed4eed7499969ab6ce2450c570d143dabed1d732ba730394fa6c8ee0fc9ee722917a72ec6b3dca1389562acabc4f9e492ccfeb7143dcfe7f15bd56e8dde5f00e9a25688d3675e9124b5238b87ebc6470e29c56107e340b32b04170832fe29242734d001c6c407dc0c3133af558bd4de5f4e1653307cc30af7da6ce3b721385a2f4bf8b8a59572575abd3cf4d9f5a9350fe93ad421e7b84d57fa171a6cf211c1ae0598fb73fad131e19995fa4a655f0bd3d6b2e03f489bfb2791e15ec4ffeb798863762330448766bf96271ce7450292f03940093fe489424ad7d8852434c37acb2b774dcd09efd5b13a7b6e3952b0f292fb44d4fad46820a720f309cedcdfb19dcd224e6b1b4033f7992cfb1668725e49a81875f527315b03a1de12efd0b1eedec4a6eb58096950dc17a5304f19339fdcc71b581ce636221a175db552e11abd48264cd783b8afe33be081e69273cd5143f812991b36edbe27d8f8d2e92e58fe71ab55acdb5778aa4454a0adffabb2bac55a4213cae654e218b77dbe160dbd04b87f52484bff8e81ccc3ab3e20fbf777796a6f5429d38331b87751c3e161fe27f67430cdfbbc582cd1f63583bc4166eac330533f99d3298b2ee26ebb64305de30aa0aed6a575f48cffbb354cafb5fd8ed4b6f5d6231475cba31d5d3b5bf13bfa2fbb38e31642546a671f7318d322b183cd146f57c4bf88400b06f1a131064f60040a6e4de9794e493075f8a8338d781c9f3256c50842e3b30206465bc548b42174649b3831cd6cec9b0caf790c34103bbac27ae6b14532f2116bd24db8344dc8a2db3140d524b5ff837835db470d8a19afbfe54a3cdd1ab983547fa0eb3806603db6ace01b1acc1d5e6c89124281df3561ad32f6d47a213bca4148aba6e5bef0058852ea4907526a318e9acceed240c52ef6463334984e5413630e43a1c3c7cce2259fdbe135cddb8ca6ec7c703a36fa0d1834b13ef29958566fdb3f42913dcf7b87fbdbd22ddaddfa6917040ddd4829f6a793f1880c14b75b5d4359081837a8608c4108c16aef7d0636ce947399bf02fb618e515b462f26ea170f0cdc3f7414d9a94d34a6e60cbe5fc1671af278bf62940f0017632390144a7250f0e654c138217a97b0ef8034505eb93d59fa95d9539b31d0a83556c0d86b88d79f182b3654774d75691d367a3ca6f0b7706cd906eb6b646d5d0257e7d5aa0f5eafc9b868587e356c234438cddc4d975a74af24576b662526c2c64316a2211d618c62855ddfde9b520965454f69edcbacc073a1f0fbefe243a99a1e179e87a27c1d74f807e2c25fd35dd1523a8ffa740a6994b000e3353dd4f2b0b5bc05d8d7da4777eaa54c77aa50065e4d14b6bf3329dc4bc0ee3113dc4d83ce844e3212ea18c69c0673f5bf0146d053261ea794c0de2c219a0e7676844ae488a592c77064ac0b88a672af79b4ea9f9cf4f353206a9dd26af38da68b5a8517b25ab01c6117a32c3c1f473996de5fc3d9dd215f092c1c13e1e28af07150e861c70ad0efac62714611de8b9efd68835ecca5b273ccbb853086cc74f6a258f619ffc876c5cec9462b5f836de7922529974a193baff4b3cc16a6288b1ce6ec03a77f89278c27c1b4351c1cb961be205093b6cd2aebb35bad2fac2c01a9c72a6ceb85f52d8dab14a36f9394874cdd252b6748121f756d0d9f219f8da2617491abbb938257c58e44d02075661b8bc0dfa1aa7ff122bbb7b883c19775b28773d2cc6ba6ddd869d4fa9ccef02908556b9d024dfde337789ec5ba4b5996736c23d0fc1543983561782519f06da4027f38bc87fc753fe26c23b13b3adf14829890a34ccfe2796c5350f4df50f86384ab363afc24d631fae7772946cc5e0202145982486f0bda435622b3dbaaf43af7ddd342218270df000b653f8304b6c006647419e80c9649d25ddcf977332360fb89340407a1c216537a4f609865d140c0b66409337889cd804520731304fb15648ff7a44ea3711c8dac4dcfe4cb86e1e8b860cd213110d96b7028343094be2da84e060ca25448061b6854f9edada0a9f1b99c0078225893da1c0201ee8094ac8e05331c9fe524a7bd8c6ce866111b4155dbf3aa6f21f07bf84d83e65f4f9c0294f6472b2810df393c6dced28673abf151a16516b9458376f09cace76900d63740de0ecbc2315766b452f78b24a96fd4bd8762aab15476b0e4dc6e58440b394c5915bf2aa37d99cf7f2a0b884b2e4c59c00abbc352a1cab61bf1b10686665c521c6140c245a773515f0e1a4075f270d4cddf743b9ee2b45efecdd2d411a1fc3e00c84a31ca6a236ce3c7dbdfc28d43116511fb03347df54be7e869e52b9f16b803583226219487df331226c5bb19f88a1f86d75c5eea52143ee81790442e6a3296b75ae04f1fbcb42a99d5d9edb06ebf299ba0bc61d44107e1e280a14d9e5a50bdc31bd082beb40a2652be17027e146613ad2af9cac3a01e88ec70e7a2e3667ffac1a815a0026a13990b64e890da288baad896996997735b3becae2c62181fefd7a09289cdb3f123635b39cd6a29fe04ffba2738c98ce4e3048efb868773b853b56d66d6141aa26fe949e39362598b77c332dd2506910ad5f43ad867bcbc85091575b3aa9417623c540c85169181ade4a104a1593607932c212490a58807f9a7bd4c9f8096950afc9788b99abf52a2b9a013ce4c227a7e4888077854c94bad68e502c1c34508605c1a60e0d44cb720890473dfad9d83835383d2cbd546feaa9f3fd49321947cb2300c1d166b69f706354f87f5794380f3518ebae65aed1c9d731eb8e00afe6edd247bf6eaa856d6baedff5558b4799076f788aff0992362b41898240eec4916452eb02374a0a1e659fc657038a5985d5074e363566beb0eafd8a354151771bb9809c3a2f3ba0556571776dcd4d073fe1a36ac3ac7a39dea596b641fcb57a7a5e5794c98a5c1fd591e2ac9b42d6deda0263c9b90b680c7d7f2f5a8462950d3bd19bca6df0536dc3eaa2e13267a75de37f9f227314e1c71c871d7a50fca5058900ec89dad386f97c182bad64f252e570ef4ca7634886b9209c68d79083c4fd3b770771c281e9e384b0ac62fee14804301d5c3c3cf338b1b2973e9d9d7e0804d9ce2c7a97282beec2cd2acad56ce67eaecb5ff5bb17eb09f3a80be27e69918157f420ec9aff5580fa27ba8c665259339a6783a799e2e2ed0a064bff1a91dbe7b579f42ee8839029b77dde1c15395223eb0a45d39e13bab3c5593f93a1ea40b5aa1954b2fd8b410d8e9af56d5dbe67b7d1dc46d9c888db2351d9babfb401d1906d2ccc591283cc012feddd28ff154a784eba8dd722f5d70a0617c93c788befb4b845b99d7ad4ed83661688e9cfbe7e0519d83164242e5a7e4edce68cb0c51e047cdb1013d1c52fbd7d21dc2d64c02c07b55a16dff9429c6781a078a80b0e6f6407435a346ac0eb92a039c6d5c4a03834667685c874e397c497d9d38ddba404b38ca07324980f88cce4e2bf08e81ace87f30a3031bef47f092a966d3fca6e1fe652359f2d62810153bb52efef23865f5331654a0062bdeceaf1b064726816042437e80895b0ea1a209752dbfa098790f19685bbc0aaf00a7f7c1dd5159a756d4f4582a61d596734ff40ab9ca7044a1968f4044e6c6548b59a1ffd410371b1fe072c173429b47063c421cace9a906e52036a3d5ab07af260f0f90d36e2a51882ebba3cf9030c76439f7afdbd4788aecc09fa64cfb818911fbd9aa28f6b7269275d3e53ed19c49291e24ba833974d1535a31ec95410a2c477dd7a7246e9b1547370c610f3a4ea12748ce51e7f0def63bc81b1565f67b4757179ab5a850db62a7b348914713d2d1627e5a6f190da07307df8cc9effc149b74e0e0f03a48c1c73493d60bd364ec48d384281ad770e4b7e89cab0db0bb2e4c7693a3b3bb2ebda6cc3f45beed5daf7ea06589c34a9ea0d29745103b64e88dfe15758ad9071d12b1a65eaea9ec6561f7afecdea83b7d1119eefbb9156eaa6b8b72bdc5d77f23c4ed4948254121df575311c453bae5ee65c81adba4d57c70fe71d03266164c38bb6c1e9dd95613bbf01ad33fb57fe28e6497f3b105143657cfe1132494876bb81ea12d82615d6e30f7f258d86c05d0b07035d7df50458c0942f854522fca355d4c2f4e5a19d5dadb782ec1b52b59f0ea1d9c016df064859793a430df112ab1ccf09484f7c79011b059326939c9ce8fe9a1ee7d880073cefc39195240b2d154f835ee7912dfc7b23af46dd4159ab906ea1312eb6c130b63a6e121b36fd0fe630da86f0f89b7e132495f3677ca70430fe15353369890d9fd468b46b5ee2da7f23aba4afdc5e6a60833e82df9a9ce359b6d4b2fea26a906a94c5cfd0464823a08e30cecd4e8deafae210e61457ded271a0833b3e2affdc16d7d301ab6b7551ed73b204a5283e8ba0bdab90c0cdad93e3c39c6ddbb31c91fb3af954c070170108b85e87359c7cce171689f45c8e21b5d9f66fc3bf120ebc67fcc2f8a94c48cbce6fe95034f76731925d45c761f1affc41763dd60c73934b54e57f28eaee892177271383477ba719214e1016700a54ab54d7290ea1a9fefb7ca43c6928b3ff3d5376c58579e1572800f9d49281eb5e3081956167b350d3cb49d0d627d771c9fdb054088c129255bb486e24e1d5ba4d89bd9e232c0015e8b81193a27ed6468d54352f8d4239d05b1b02bbcea773791b475ae77a804df3a72882b729e9008cc9188dbf7293c2b4638b70891995733df501c131f28023897b38073e0cfa5879ce0c1aed69063afaa403047618b347c5407facc08475d87250191b8548143bb4a75cc7146445344132f8e6dfc0b1c199d8d53f2b201572b628f316fe91fcee44e8f9085b394130177b79ba96e6a0c282690d2164858bea19ed87b124d169ac22027afad3c613c53c92038e68bc074038b98c57dd883d57e84584efc377dfce49206baf4a9fc9dc01d6bf7d445cfa2f2a2190087fa8522bb4a5bce0358cfe1bb9ba85285cef9b7c9b7719cb739f00e5c0f20d788bdf43b926e6040fe349334fdee60cd195280becb1118117d04419ec2bacf1eb14b237d019e6b02604a91beb64b54bad892ed874a9eda667cf99fa32e4567a84eae0fed2ee607c44cbe52164caa2274a2f01250eee66ae83b2508fd59f15ee23ac805a188bec1239ec876c400d66041bae9a84df8c4df5a56c54de54faabcb84a5913fea494a4d98134e7d3733b99150ebcf9d2a5ebefeef2563bcaee9cd6167dac37fe6c9da5e74fdb423e77cbeb0890ff34b46cb597762b343d483bd7377ca1eb96d43dd482e71032fd1154c20bfb9a2ac00001b1b2ee74dbe3977d285c8ae4499527f3c0d07f08b6c22d68af6ce392f98657ecb016754c650edb063e978279f4def3f1e30f741309d4087c2c507eec7c2dc866175a561be4039878e5cb1e68070e050c47f5e779b9d9b476c306e43a11da5d81496a7ac3357f34f5f71cc25ab7266ebd990ecc0310668ddf93e818d09209f96e373c5f580b791f9b7172449e477477451a6e1e141b44488d28430cdbc780778acc4b7f5f458847d9a397ed76642e2f243f966941fd5c700c007fb630a21ed0526b4201f0eccb80720ed545cb3bd40bbacbefc9b25443759085c86bd36125174e41a619c55fb40a8f302befd49044ba809306f7919f2a68ea47341b0e89cacc1abaa8170ec99350335b0f5f97bca6c299c2475ebae2d9a0869e9e61477eb297b0c9ec4df035b1c4ad7e27d8dde597715a969923c1700faf7462d5613c9021fd497048c37ccc065ee4df8397ed88e768ad64423fb578b4fc8bf0ce9063bffbb35cdf0c5549ddff947b4e7401b0c98bfa453a578504888057264dfc8f9e530e3d4c967426909145e241bdfe8db418f925489710ddec3926cdf0634aa7e49332a8e80a92338d86745ac941ff88fee4c43a9bfc46a19f0429e7515fc94e69064b3f5f59229281e1cba345c222fbe453e28689604a7d4a390b13c4069de8e1f7c3db327b7788c8c4eb9913d652ed54aba9382ac218872a1c23c722665ff34a0629bf884f2d1089524873af0d558e223791f54804a54fad97dd8582bb15d54faedc0f02937d3b2912d1129c5b6df47eecbfbf6429a0473bee3c3a2a84d0ab2517cd4839005043d81a7a5eb7d9e25cfaf243579c31c145de43fb11fce7a17585366b800e3b32eb2c105a35b8a5fd6f6a48cda619936bcbf80f82dfbf1897672fcf41457f43fb8fbe440273ba62a44bf39c6cbfa690760cbc8a132c2acc7105abc08157a590f93dbdc56ec76b2f9bc2f04cb72805d8c5f0f1902a2ab0cc1fef393ba4fea9519d449a29fdaf2ed47c2e4e5e2d941c064cb424095708f3f804e1d4b8da4f6c70b2bcc63229ff4c7fd2cd5b0f25aa5b6dc590b8ae25f8e01760cd31cfcc5caf8b8200d0e1a6a1611cbe97668deb1f51030c1a7e80365414936f2714ef7c6849af0a058bcf939e71e5f33023124ac6aab9377144e4a63823660c1606031ff37104ba21d1b8847f00e84ccafbada816af62996b2f077c050bf1499fc2c9c906c4fe4c9a005cfea2fe9d641713b21db568b2d9aa4e44e204fef75ad503148c2f6cbe0756956b470f79fd56eaa5f5cbad2307a6cc5b7925b96ca5beb7bffc8740e9352690541a87864921a96c7af0c2793614baf146e0a5601f997ea212afb08365e3316af6e7890ed3a562d9df355931f7f2b6a54e429094675ada2b4001465af744d0477173a88ab6982c2ad251265efa68472f8fb9b6e680a18627256a67b3068b7f43d8ea39dfb4a168f2ec62d1542bbd84227e901ab9ea16218b25ceedbd0b3864fe9d22863dcf5b3d9d0bdbb900e583eab0a6cd34afe4edd8f9321bd7e637e17f198ec0f0ee5744b4cb5c05e3773871d6ba04bb5fb266ef591568c0c8e7b54935e11565756bf9372bdc83b52030d8800123570aee37d9b3fc1f3cf81dd40d672bf4e4b328bdae88b07df6d2beb2e23a49048f5c842cf5be49cc57d23f003da626cad04628fb2858a3e2e7a06c974a58ca8a554d12a1078671bb3c45a30b1170339d536a302da1e7b075816c65168dff496f085d1ca8ca49888671f55199717c0a61579c188ad6f6515ca9d2e14dc15bcd1d34d16cff929b6f1d9c5b732a97b24f7c6af03e5c1d6b56dca75945d487c13554c9e7ed0ed3e5ebea3ad7d2351f1b99fac8974b3e876e6c458045c625932b78e1dc21d9048bdd3758644b3d52e8e2176fdcc7b33301e1ff301ba01a3e76acceecf4d42ec1a8d64779c9414ce3d3a618a0151adf2fe7809fb4c4c31f0715a91e6b971ca8a705d1fd19224d1a8dbfe216df882ce41967a398c6b686ea23073941327c8683cbc2fa902aa574ff89cd6fa770d57f9f18b5b1120a26de64a30de7be5aa928a07395c34110bf71e9319c245632ffc36957b94d4b834ae402f0b48d616a9d0bac3394f9323c1a3c8c2d682bb62dc8b0c94565d4a6ecc61e562785313803da0b972b62d2519a940cf306dd73490ba2f09a66f9c8a732960dcd8215ff0c2c4f77e677e11619c60229c160fb9ba764fa73c4b4cb362ba38a55ebdd9d93f15ca464650763901fcf2f79b7d32fc47ceeb9a4947704615699e836170fd499b4b4ebfcfe3c74ae9d8b4ef8943c1e47cf8ce9e027d7f68b86c5abcea6cbda5646e81820139c77910b81b000b9e93d5f0ee01f314127e3bc23b6226000668466d194d446094e3f7e65ff0670925d674f66b9e499ccae690350604174e3bc673297922cc94ef00862a4fdafad02d1d6e10592d035bb1026260b1dd48aea8a07f42e9946c295e64f72ade103b74c08af6b3521b619c35ca51d27cb19763f2e22e6bf38dc93b74aeba931c0cb1977454eca86f9c603d7d93b0c593fcbcfbfbe17eadac4e39e21daf9303e2ad5424cd90b177b4f8b654eba2995fc64e61413d75ff6a7b49e0c67d4628378ae02c6d00754286fab9182913682f679f78df46cf45fe79c676cf836c043e8df84f170415910b142977b18fa944bdf79f8653d2728cfca14c17e7b2e868cf749534cb1c2fdfb9dc74f5d0e8aaeda4ff2a6a881c6501e9c6ab31df7e7a319c9608093c45f98682a0d9f3a725663f4c89b09246599142bd0df8d397f34ab6f0c4e2caf425a965dc908d377a7bd76691f0818d0c9a7a1ec94a1cc755be462ffe33238a9954c1d8d3dbeea6d4530551648b783c2b83d884961ecb9ac82aeca67a915697562930b1b48f32e3bf9422334ffbaf1e04901b2b9def3c03f7c533d4def39a9731dafdb6d33cffcdc24476b85d12972ce439d4b387dc23919ec97a74a3ff9f61e03b3a0409c5327ba4d0503472058b6d825aa729dbe904a9eb34ddf70035860f6c5d95b2bebf480edc02b6df6b7b39904c7301f06482991d9154750dcc7e605ca4a023441f9be777327919fb988ca850f068127e17d8a13c92898929fa60acc916e63860daff8ba8d8c36ea5cc304dd6b2fc29d7a1b494eb0a7b4ad48f15e8743afac2b9beed6fbff42ddd947e593b63e297191fd2b7f5ae4eea05609d7b9fabca8efeff82cb2b80831832652b25b6647cc96ce8ad29e707953c8a89f0055177b0f007c03c26d6b45f9eb32b2eae3f4fbf39c458b5c5dc21e4f8dd84912c1efc247a4f2f0dd451edc5d18efb65e6ca60bdb16affc0e13ad29108be094374faed38515c04904670773eeeb0a98677746d0553c2478b75d3189a1e46ef3270aabdf3f1153b5610126a8348fc16b8e0dadcfee25a97059f7d77c0b06d0609b521ca04619e27bcdddcb8d7b1c538b3be33dad9706930a48f601c2ab8373ad4995e35fe5830b781399090c13a014e7bfddbd94aee9fdad266352b2b3f7111374bc19733dfb1c10b56bc60dad42712c54a507d9d6e99891e617c8c92840d0e90a78d50472a80935f183e9d54177d5dee783d98b18ccbf46b7fae5c4f77fc0c09f01e9ba5476a343eadaa52be8141d5cc5b926139d08bff9e7bd62857c301c2efe49d3aff3a750db91ddf6a3fb60ec0f86089fb96a06d9ce11637b76157373f319d7d584cc42188824ea1ee45070840c49ecdcfb05737cd7d53c4e00d65d44a7c7841a1b6a3fb640c5675fbd6bac9639b0ad8ae0340d9daa117d5c6dfcc4733461603fbc5f17c02b01930de6f8f7b5222297b6826718eaf4149726e9e4acc8a11306c23627dcdcf5a96765b1f01a6e0fa9e3413bf5156161409f640379e2491551b9fbccd2f83b698f3ee711ae4d798cbe5e51ff3f2583a68359dcae60883806251236e958bf3a2cc28e3a22a3cf8f9e919c6b7f23c2bb7451320937b960add20f67d6c0200489651f1ecd94e30f08c81531d3cb68fc29a07c94e0ea69b7bd9b397b94169e1bed57d62325a9d68c19f6051f47ddc9c78552daba9ac336440c4a351d5b95d4f9039b4b413aad51888becca9879f3ec59840f7017aa19f841faacfe4716c64bde4fe4eaa752c0f876469145e4bc9a3f4211b50f29d3be0cac9e47fefcf1181d02dc5b0fda432dd651774dbb4381ec3ca4540d35e9df3a4003da25786dca3ab0228f572f2766b44e393fb6697225ef5197405fdadb843dcc02997ae89eaa8c7e428a9449713c8db0cf46915509095ec5206579245d8e6c8afefe70bcf1fa1a26ca28443d6a8c94b6ae325db8f1c9d0b4f30010c082e4173794f17826aaf6c0392633f804555add8dcc9a5d05d01532320ed548faaa735489b9e91157389d9fa5c5495284211940b3e5685303f9c46687ec99ac53b44dd00260cba7690907c5123ea4cf24cd2afc1d5b424db299407e5145e9f216e90d4647d945b3dbc9640ed1abd09396d56713cec7a7f5796572774e4946be557a45d1d5dfd8cd1cde49739939e73922cf257bd5730c9153e3e359964c4e80b06528739932525361d34dc7d0c7290a82d8db798b661b77386186cebae10dbf9a9a68fb5ba1342e69737a08d5d19721995a7a713f66a0c4ed131457319c2e0d84e5184e3e2a6a43db1819dd5fa048ffc29aa77c8eab8725eda1aff1a4495cfdbb19c817546d1fc70a1751aa2a914b8dcf0e10738bf5b0b51e4726236437ee44e1dbad2cb0a58c1a90719f5871c97c9c0cb174dee999615b3aa7b29fa279a7d8e3de40cc8270fa665771b8018e60d3f2c769e68de44d9f848a4e4e586506b55a0fe2bf4e68fcbf96bb2fec1e729654129c0c64f6430b53a3de689d6682a4489cec35d3785a6db593c48596976a43f3f26096ff3e83298a386a76f362e5638b99b129dd0ca1228079666d1f1916933a5f6fe26f07ddf442613529b70bb5989f897f453276a430c6dd545920e8b0521b31453055d96faa8ffb96641ee03b5d71c8059b34e4d22d5076c5f30a8779fa16701d6893111f94820f8cc4155c41d3a38312582bb886acdf386795c346787525c7a5558674ec13c85f89658d1ba7264df542c33672c3bda48538fb6dafcb5f18e26545becf04de61a05d4bec736ebb715d67e743809215654bce751ba7326cd1fa80adf07686b4ddf241184f8961b484a781f006a94bdeebc5ce2dc6bfd5bf589f8b59129b967654fb567dc6d585bba96b60c3780d50995d1fbb4712eb26e9508a3d46107bc18b6c48eeef9f6dcdec95753468cbb1ffde6fb074c979d48c60986280b5d3d23cc1b4dd4b69db2d39dc79b9ab0ed2b68a288d88ba743d1d0f7c3280c616bb92b3e6170363074283cfccfbfcebbe1807eb19c7cad86ca3b5d64c45e1eaf3bf5c2513cb76ae5be05bd5cdda69e071fb801ec34df6210f63bf93cc507a1a72d7d69f85d6a97aa9509831dbe4a518f20795bfeaf907a04d789d295322cf9227a4312cd633cf3edee7e81ec6d7aee848f0398b0c03c2e5ca5d02ce67bfa399f4952263533a37cc57ce2bfc5cf777a1b3f57d0cff9dbc1980bb1fcc0ac9cb6207b680ed51e8710fe91f70809d67a03180edf6c483a5e177948996504d4e8a787ff49e06c5d91927fa30a9564c040b272d28","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
