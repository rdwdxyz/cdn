<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63108b8657e3749597dd57e73aba9c9aeffa32b3e761787185fcdbe95e86aa17e8b22c7528bbafa36fd43ab6daf50006d8047cd658f38d65befb70c40f1cc444bb13ef7e827791d4c2722d5d1f413abbd1f3d1dc9f64b03b5e91271f2d655a0ba84727c1634b0f9c22ed75d11f7be5f2c37a5964a98898d804cd7537003455b2ce0b3824c2e41c680fc03b65d0f411ac675a9b1e56f8d25ce46adc45a40bee288d290f4eee496a4ec0cf2270bdb0439bb5d0b3d544da545a7883c663440721abdfad5d7e46e1225b176c4623d73642e2153c9ceca8d7cc07d63c384ea92c75bdfc632dafeca3d6d9e175cffb7b2b95792ec6dad6d95add6331f55b98fd7a547cef8fe7252fbb1c7f258a5e9974e8a6c5222fcc34b038f704b275221ae383d703dfb9315364db67fbcb7cbe3200905107f35c6d0ccc68c21283c0bd3a321291e07254f3a0406fdd704015b5e1557bd91478a0e6d00d047e1d84c2486636e6814a6b2f56021ee0714efa67685d8f168ff0b77d53eedab768dae14e0a8e39502d376b52e0a69fde516fdb845a2d8ee5a46a54cccf682d2056bdf6c77cb30eb03cf586750efc4a888934854d57a64f0f7dd27a443e11bc3745fb919361cb7dee8b27174b4df864c373f4bfd85908ba1ab15a6f8df1e228fdd355d66f96f5ee8bc90d670574a3f462482bd855d7847f40cfd08a130c8537c042648776e860616d14209ccd3e6143b8f6a9e90bfd102f316a9e73d138a7d1add6c6450d5d08f50215eb80c74ae125c96569c155a5d34d15c796bd8c6cd4cd65a7c6c3e7c5e02c2c906b6b57804d163003a07ae2ea0d2805af8352f7598e449d2c989df53f2bbac8f6a54a1b3ab62c852a1ec2b5617422ed1e29e93cbd5dae64df25ffcad719883e38715c170579b8e1b18f45bdee2311cbec618ee83fd355635007a97837ddc6be146d043f854c69145297b207d059917fe914bcf486bf880f679ed6264b4e681283d694f9e350f69e22562d3abc6908bc6d9027b48e8610579c596be2c14bb4e38cdee42f92ff19be58b2d223059cfb59981b4e0f8d537f1f224938b2b7dfc694bfd449a53ad4d584e9590bf7fc9a16e5540b12aba6389f6235c8223c3185aa5041e12eb8a6b9055246d76c3cd0f94ce499f9fd186a78d4a3d03e9034eddbc1d2b4dc273fd2a0137475939ea6b3c8ae781b4fc89a07d4b06735a7cf369113a3f532325b0a371ef3b328326c38ef3f52f2567ffe60bcb972229bc620a51595e4519ee5ad2131ad0b7eca523d269a28f5ed6d31417e4fccacc21882b5fb5e0de1613a7c6c540fca0c3b526c6a1685d4da98aecd04885a5f238554390be9d46c4b0ae244f795d76d0f5eaa495a8bafcc535686b8176b696bba16b9a1ef3270a951eb9d36496ef968da1e8ef5ab72a0a1890129c9347351c008ae278d3146d2dc81aafb685e46cb973a729ee2c240ab923925a8f148a8c90a357d168b9aed4f672f752eadb5bad2fea1c6f58d2be3c32c28b29d971753c4989977e1d7fd18df1982046708b634a6d0fc2dd9abffddaa7ecfe7021fcec3b1b49368e20db4f4d296a011c4eb28f7e53f3ed70262944c38390c6e1c169cd21625155aa71945af9ea09d867730e92b3e5477bb01dc468330b247317cc8de7860b75a9931fa362f103556337a7c84f83287561c5c1962a0ccc68cd2d969585724c66821912b5299cb4e007ddba4e97f1578bd5baf58ea188355ad34c07bd700b45bcd65b99c802a876a9a87fced50b8f7ac331421c3d3f13612a400bfb36b36a3f29c7cb1fe084881d3b2a343dd0cfff4801cd9c1817d47a5f5237434b83c9e4ce1038faef4dc3ba879ddb9ce5e9e44ad1fcb8f0b1f4249f6e7d826d9571ab7d4671b374618657fda13e46dd222ad4368376a5046aa03e2c97bfd0a5483aee874ae9c70c3f40237aa773fbe4d019b40c0e17a04da5cd51c8e68a2836a10eb0de48ef2252ee4e79b072f4dba35234cd9c334299b0ce247435ddb2eac2f9fbc22feab9b41c836670b7c7ad5a01bb1797c362e6be2e4b936771db71ad3af94f2f99581335127e62a506c81932cd908a85d75efb70f362a83205c3c04adc270f1306a2d5e1965ec10e0a712dae832f05d1b78e4118d0328486413f7b909109f8199fa89eb1021a19ccec8f8ff0f2fee8a42cc77003223e5349838ade143c0fcdd841e54572533a03ea9522f6cadfb54f6e5c391a8d743939efde773afea726406956ce45317d7ae765ab1f030f71dc3d35f9385377c398e5d9cfd704cbe0aeb8036c855669e45170dc74baeb69a43e59f779dfadbc9e180a128638b28225402a196b424f2a70e7daa7d0494f5e92dd6d41caecb0f3710b3dd2ffbe64f8b7c7963366234b27fbebc6dc8e88258328c0bf2e8cf5044dcaa6357aa9c766ee1f3108cbc97d1ff34dee2d4d6ee8870b6faf5bfcfed114401b0ebf0058921e3b22fe0629c963737ab4031a3bb39c3ecf6a17b35e08b1fdb947e3dc44c73dc3d17028142dd71d6cf22d065c94c391040553558dbf6f1f046ece04be9eb08e4098c82fbecb8c8d7db2dbd15e3bf7ae718c52222ea5f27a7e37d5cf6ff85e39a938f52d6e1e5a8c0498758e532b249ff6036b5bcea366e87d7411220ab93dfb0f095afb03bdc5a90295111bb0fd76035495e1cfd20d3a78ae370d73db861afca42e326f43d0a4163aa735e3732589520b43ecd0c663f058e6cb2ed942cd4f5affa252c46005608d5721b626720666f67658e9bc2ec2b553023631a24768a6d511b686e8f120cd981fafd13c3a4328aa649520c25b3e80d100e986a35f0bd1d50846e7805754e1239ab8a6b686d278b177177fce70d3e13c62ab07c24c0f504a9172f243cb76377f3c90cde49630c2d071ed8f1d5ee6e5e58f1441af2825cdbb5d67c387a62da3497a99496d07e1d0d0bcdaeb74823a0417c313823978df12873f00f88365de7710c8b5bca8f915e293c4274c3c89bdb6480217ada57be444fceb483b25aa492f2b0d46b307a26f520acae37f8f1fd7e6f0df95c15fa9cbe9b8f2f9c3de2cb6fc094f274c3358d90f3ca105a72f39a43058510f7b2c11e746f43f06427184f93be52d697aa360e48628ebfba08504182ff2771bb2def9a55cb9fd72f9a56c3c808339011e9015d05ee432b1170cd68cc0bda2bfd2bc6c27d3ffb9de3f695430f4e807ec7b13db3b9c2bf0557038f000e80d1c4d64d11e7211f910e13d68cd6123d733f325681727f9906de3bb3d95e5b456c3f1c7a2cd534a484fea1fa2328fcdd4d3d30de308825eda010acf00e3d6ec23535f5b6f8b25171da25c0bfda4315b2d0fe1e23936d69c7f94de666d323496380fc99859d07d1fad8c03a199496119cc23d7d2b48c8a13e19e8f2c702f1bd83716473e6efdcefa72bd397be063dfa1acc0f5994efff166db89b121d9cc63985ec8667c273b372a2cc587b4d85847a8db4373ec73d10db9c71848ed3c34228e508d07531c065b3ddd40e72be02d96aad5694dedf294d88f5e6f4d859edd7b28951cdb71a2980909cb88de05584b91e6c7524e4d1700b0561720ec80e5bb48915a1c303162c41693e6b5232bc807efefa5fe1940da6944045b29a2f121a0bd133c11715933eceb344e8c6b0c33819c3c44d0308927407eb901ab9fc29b003110d1cd56acf28704bf2f948523abc7fe327d212caa4a2442cced376062cf8cc7acdbad0e15d09c9a0f5d9693e5d2143154876573fab8a829dea70ea128eddf73735d87447ee972d11fd81687f427e5e86ad39ae30770bffadb437a67799edcd9e503ae74b558a5d7bcb2257c1620824daf19dd12a3f74020e61252a05e5fd6d9b8b63ce69c957c7c1b49e6b6a23a2bf7d155cb5524f262bc6d47dbdeb8a3e3b3b6832ae496e816aa3d8486bfd7b7cdba5e1d281b474a7a9d1e62e6987fdf88494194fd7dcb44e0e1400f08ee833131f3f0c93f0bc32eda2565e8ff094577c123d527db38062e27d22db876bc344d1f738883d740ecc667d1b9472227281f3b382293b0dda8679d7f86466faf400e698031ada31b5ff075739fcc1ba55f451b9a893d6a55f7567e55cac397a238dc935a0030b6b47e2bb751b521a1193e7d037042dd19ee9ace1555d063e7381eadc3abe82997e1914497df10a63f5f8d220df3a4cb383e1f3edb542a0df37222a4db2b30de816b7ebc8f1258195afef7cf2420dfe5fa0e96f2a02b8359e6266ab002a167aaa7e7ccde0dd53ea942e59bc4ddf3eba3e591891dc2636a4e82f1c0a8aefeaff99e91ccbb0ea2d5924d4de0817f2075e2445653fa518ceae346ce7426fc256669fe62ca777c94a97e45fa2bb0f1e153a14962e80386a2c4d87c7f26232e1408be83b407b0eb64b77ebb05975b446dd18638f5ba5bff50c8dac752ed431b4173abc4fd89b5a71596a72f0e9b425a98c2910f0713e026ad7a8b279fbe4354e6b95548b5a86f75be3032734362a09f76a7242bfe873a9ae73f3bcc9114425f7a03e9cfb1886d0c1bf64f26aa2e66491e5e310bcde2aa59973f9711ba27e50a1eb4fb14973dce6eda29157e1abcda36eb60d2fb941383bbbdf490bd67810403c770acec1d8e7feaf270ad02e26023bebf4cfd8144e9df4b8466597d0c9e8ff87a80fd492a2015fb20c5d2ad9579df393981528d4fa2041792ccdf8878e1939fb957ca14d298a4968a3bee1ec3432f2f84e330d77d5a785c778aac6d651e02a77b105f0a982c7862e2b96ce9a77f2331ed01ab3b4df12fc7844ad39a07d954291afa4f7cc2e940ec909cd5372776270f1548bf7cd91de9799d31cec8e234a984a12c8cdbbbe48687aed80d22a332867c8198b00b6f915378ee3c44c6c435b6c6851e770ce37207589adcd79059c3ddcc51cae7fff69a5415e016387c5c8e1128938fcc0613764d40b0a6115e33e00adb46b0e525e1e07f0e80b6398ed9e70d3be556a97a860fe7fb5bba567a17f571cf2a5fed70638b92fc5a4da4e048be72f14e8e9df2dc0e94ae08bec5fbcc4e8d4502234329ef3f34352ee4f9e3cbafcc50f0a6361f74951814a699de34aa55f0c368cfc1e0fad2f5894a423cf35d10eea307baacb64e4f9d6df40038123c25c2184c324250f3bd3ce1a5408654ecb8986bdc410acdb0e308d6f306611518aae06075e13a41f4fc3c3c48c20083c962654c9dc9dc73beaad60ffb2feb21f357b96872d05d0ac1694e355cbfdaf7939198e1757a7cca9d5d2ccea619b3a310269bc452bc186f55c52ef216a7f0f573f44fd037a6d0cdf2249309fe4f13bc8d5ce127db96343e783bce128275c48bee237f158e30f4efff564d0a0641a1d7562a44411383b368b92c56d6ccc55c90f4cae74c9fb68476ec6cd7ad1511da1277650c0db3439cb9d7716579c4c1b3a3eb77044604a85de0db97fc15e63a2b12ed0e44b68fa6ae2578cf9788638e8da831a1237081a2fde7f698695f5725c0412930c568449102393090375ca48d3769ccfb3c594032e0e57c0c2ce0b877e4790196b76a9d343df0ed7e6e0d83dcbd85c758f2dd14b08191e0f49f1644a63db34936943b2239207789441b40f8495e414d8c98e3323c4181719ddd92ca857e46fee0006ca001d0c4b997e633c31d4b1747a76f962141446170801b5acebb27c97de2fc6d60e736711530b0db23df3a9031e9d852c790410d6155610370ac554d761f8fff0a7e2273b9cd29875fd0d170f736363ab997448ebcc180f48330de4c4c439a6bebc9827beb8260760be036ef1be7246aed52a30c45e32a9955507e9a23cf2d6b670eedfa567c510e3c36b0ae13d9525e4f242f8ec21736cbe43797a2d4c70563173ccd9d2aee849d049a25d066c867242d65df532a33b2e4a7306e6d5a40a563a6c453cc6f96db2e44e40c25cc4ef879453cb1225d03a470d6f14664c7396f8cf3a318e843f1fb07c356f5359d01246d34dfb7d3ebe4a8e092196ba0af033e06fd19de5a6fdf7e9d076c7c795b2d550a29a8b7f4c1bf86296f53dd06aac7bfac2ac3ee2e23abc0534d1ef04f0b82be23d0a5459dfd142745bd87468449e3b3a65d18163f0ab3d15daaa5bfac67b89cd85b99518557142b6bcc776e6c9101050ea0d0469ca89c64315939ce30c845806a34c8c9638adb978b024be48b90a4686ee50dbd014ef94cb7330ee261209189ab973bcce8da47caab09141e7b4317571d3ea9fba310a1a2ad0443a47aa2ea4f41e730ee8009254897e1fb32d08401cf17238aff642397d066d7f33a13438bafa54fef460d16a50a9f5fb69812eed2cc5dc449f9451a20dcf7e66e11af64054d79add77399ea1c9441ef663ebd09749cbf091af527d075ba754f9ce924cd1501807dc68df70212f186af810aedeba1502a665c9cbc4ae3d40390a5673ae3ea64cd2bb627675c6f50b19d74c451d8c4c331c0ead03fd50a223a9e87078acbe4218bbd683c14170af08fef72edfddffe069934b7827131d886e70c7fc8aae144f0dd40f897dfcfe7190d6655352113e01981f8e484ab33d5f24b7b85cbffdeadb748de232e6b6e508ba5ca07d838740b66a8fcf0f1c30ec56f4e5d045ff1adf032ce64ceff8fda74c7a04dccdf335f616935953a791bc741fd2a3af6fd90d29b6222953587034b4947848a0a168885d9d8b672a3b782761d67f3ae57ed549451d46bf434dae9871c25847c61020695a328cf1a4a654d512ef3e745823094f769cb98879ad0479027ce84e36965cfb19b4accb09c2d046c456cbec8d9058dc1f483893ce47e96bb63b25425d47a61190ce405061eaaeaba4ff7013821d5e39a27fa9d027280141a29b8c3b4ed7469938fc36c1b5fc4ec9e91193118ce02d155ed2ceff9608510ecc42cf716fa79b60f04d4d4deab43c738e72f39e5e53e6f9bd8c2eb06372adc20b7973b715f65ba07cbe6380fe10eded6e68af178d0ab17b69abb1f578538d12132cffe30ba2ad48fabc2a37ab9a9f2c85aba98730b1ccc2864f525b95bf7d7aaa41a27cc43c3a42c07faa7914ad4a1ea2b714fb491fd8468df20040a214afe154ded49e400b4d6a7a4db53f64b2a28dc228fff2df6f585120e7c9b9663fa8975b0e3b11ff3f70606fde7a7ee5e08cddb2b715f9ac685a0ec2167d0e923063fbb7141584fc8a64cdb58a8caeba87ac81d0125e18ff06fb9948d8baba1fb906b9960f805bce38cb2198e0472164b6c6f5c81e29435923bf5d12109fc214e34a6b0e452aa84ea3d574e09954ff372bb73e53966d5f32b0e266ed0732f89473bb3007675d3a17a1066cce738ca570d46d70903ce803f1738038049e77d229bc3aeb5200f6b027bbbf9e3f969c8b7f8dfe08ca14d85a335183aa8d13e0cf5b83d2052114d071df2e680212abdb5b69613acaf7cd872146064b2617956f02cb828b0bc7a18ad4614d38b5812809d29e1577e7219180852f40e3d1e0daae86d773712a68901c3025ed7309814fdef11a40543c8b6eb48c33011add1aefae321c13e51739a52239ef7c034ea0545586775001a95c5fc77bc326368e31fb27c0a9a360fa9a75615d092a958250084c4e5bbe9a67eee50760617b504c84a5f83e333ff8eca3459bb74fe003da5b6e4309970b8257d0a9768f20e988d42be2abc08044ceff0f180662378eca44b82ffb5c901162f257bdde5213ff2ec497955cfc1bdce310ea00d3505b4c5b2e1c83b652fd080104eaa3be1f7970e2a1c999b67c576288b9c740c47aaae9b46c1ff26b32d8892e6d6cdcdea90295cf1f5dc1fd3f5ae77c064fbfcdce83ef8b47118eef439e94ca5fb3da00629e4e02268265275cf9e6dacecb2c81e43c2e091bb8b0c5f9fe726683dde9f494273a3fe7e3ea8689fc8074fc361593e3a8f77a86ba1c9128a0d68b2a7be31c4e0510bfa5d377587b0dcd92160aa1896e341b5d6fb744dde7e05c353915b54f8f75ba8344a1e3de3603d51a66abd0a0927311e0b231ba4fc531e132659bdd713f150bd48afd0d4b78031a10f9ee5764947b7df9f828fce576205fb2e8be11b97e2d8f89d8f3b69f113539094f0cb34357b376cf96b098d712e7564185bfce3fa05b6fcf6522c87c50593d838eb36e4f14f44015b1350c98d013485793fe4fa1f62f311d06e901e9419c9ffa69e80893b887206b2d1d88ca06a1897ffadcacfa25eff7ed9455e0ff263ac9c4007d3a83fb8f82804c01336c3064ba76ccde5cdc8da9f0a04cd4024ef09c349afb94187b8f588dd5ca89b94bde7f410f89799e1e833e5f95bb6ef66458d904bf16347f49c9b8314d11ea362d350bc22ac40d897afbe2d2cd8878123c18c6cb15f0b303ff7862d9a1a6fcff8d729712addab453922d1b91a57a6bd1e2072e4367f319a753c81d791c9f3c0d932df0ad7b7a8f434a1fc1c55da4ade1aee2e454d0177c6ff9c5a48bbacfa7c9e69c1fe79ee2002de97ce44927324e47f46bd30174ac12b18f7de42f3edaacf4e9727d806fbfc1580378fdcdbf00847911aa675bb46307cff026e6acd5abaf1831e4b68a5ca055da028ebe0264be481d82eb1ca1d8584d2103efbd71913aabcdec458c1045704b0411acebb3f48ff1568213cc2785c22198975a2241fa72aea6dde135e09556346515e829edc1ce96594200b60c3acbfea9888a597eafddf542d4e96fc9144ad3ab503143e51771ba51976ceb7cf8435fa05f712016bf95013bd39921574d5c2e03cae4a34241825bb0ac7cecd07d943217dc797d5cb7b38151104ea7456ccc9699c49cdd02f326206455ab9077c81e6325d92a26554fc89a76665e97bf07a0696c678f393b91ee1dd65c46b720b25fbca3debc09e23a3a822228b4dae7c228a7b8370b67ec0d040edfd8ebffba8c57ffc85340ae5bc08a7a918896fa2d12c44e13dfe81ef59c948a49fc2ef5fb7b91e02b817f07259c85c667b95d762a66c8db4fc410f77469b03885c4db473151eafdb949991a4e91d4dd487ccebce270e1880a8f575b5a328fee5dcf14a1864689f3f2bd3153797e1a45602f53881d4b807a9177ede44b4bb93fce82ea84e70dcfc1a7090edf420003a754813cdb2f36a6cd477ad688a3e340db06400c95fc0bf5bf53c8b470e6cc80245a73dbe6ca50722aae03bcff8ee68ccd507b61566ff3dba96909e2252805d2fc2d2f8307878265b3a854fa1d67038430954bec03544eb17f0370145366d8080a65cae295a697297d5db89888aa89e79191bdd2cd44b59fee02d5872d4673546bc306bda84c89700b25fdbc37be1cf6be26a8384c137a6cf5d5ea4b4d9ce3d98270bfa9bb0f0442f5447a1f92c56ea1fc9397ae9647d875a6c8f03702478bd303311d5812399a7e29ad20231c1f7ec546382de40f252e6e53ecd2e993fb19b128c340c88bc058a4efe097fc943b3a2300bbb6ec5ab4627b37ae1de5d09920b59a98fa4cd0b63db0e53a3952b123add108fd2f186ec9ba036d5fb02d3d0bce5805b374c2189234e73182d2f7991af2bc55c17e75d9166080e2e4aa7999a2c5cb699da51c505beacefc0f3b0ddeffdd362be2ff5fbb3e1ec36c96fb81383f8b8f37c7d4eddfa0ccf35ccb6d19febb646dd0188648101ae59585a49e1706d3d5d80472cdd3b70809ecf40a3f27a49f75b4ec2488e97a6268ca1f50dc3ae07504f5f7da5bcfe41bc3193fc86140dd1740ec6816c98f79b3325a9422edfa319457b7df132a1465d2974915104a3e8999d4e1eb56105d2eaf8c8ca41ed3f3a9f9d14125c72744ac87e219264ece04399e4df6621cc039db05d6a254eb24d4ffc45ca8f0dd344543452ba24de77f470953867c90cbf99a7388219fbe1ca89ae48b19ffb7a29135b8ed5a248708bd7c0abbc917cff6d54601beae1ad783791206496e335950ef7409881c1a549dfdc637f3657419405393b2f4885581be034121ddc64d2763ab10a260d24443dd0efde55efceb555bbc2773a36047ed995dabd1d5f9a841a84c02bd56ba582f1641455909612f7628b8029d6f868e47fbfda7555849f5e23432347a77d04f91016c1d256240e2b8a2ffe037a53ff99064946417f5b8711b0573f7d329528be6b1233bd326669e44670775e6dffdac8141a8162ca2ef5ca53a804d246a21224fdcebb1eb930a4dbadaa5136502eaaae737e69eccfeaff56b4dd87fcdf1df373af430e8df1ed9bc20cf3285772e21203de5e4338612ec11624e503f3807b5399d118a39af8966223047f206e177d21c2ad4c437265714bcd44c98006fa0dd8ff1799e45d5d9bbf4f7690eaea3957db697311ecf709cd9255fe1dd7da7005112aace64a3be6f274f8440ad014de36c7729c5fbe4e203f96fd96eae878f88d33f9593e18c8eb89ec80007be3cd71d2815db7234ef821359aafbb60e2ce427c1313dac6b2a97b12bf2093b32e36edbc419a4f1d83b9117586a575a7987636ad9441a93ff8bdb19f6f7ad59e667e64d3629a33fb93949bb81a3f11350bf8442f529eb8cc7c87be458858eb34d4f91e58318914b65631b0354ab8921d793344896448b7a7960a38f84241f7ee042091f16e41d9ebf54a102a19ab1cd91622e943c30ff72ed2dd058aeaf6ea632d71608f2f0b9b866b0cd784b969e90b1ac80a2abd0a837c8f0d3f765e9af1113e46ebe820baeabbe15d4326433bde46ecfe3c22acd582fd5a379b2c9ef94730987ed6257a6cb74cb5c81f8b0dd44bd5df1c794a5fbb1baff05a3158b0bce9f85b884a0ed025a9c8d88edfb5a2e8386ac8612c36c8547c57d8db515a84a8ae2de92de07db417951e75c3cc583b0fb5c250cf74b1b9dfa51bf0a51b3b648b420e00940b412af454a4111d28fc1ec0c9ac2d03ea39fd9703e2c37205922283102f2be2a8c28ee5ea179f6983c5dd18e430a7069488e4d82c1b24b5b50ee1b802d36a8b26fe173d33c857529be0dd082a56ca3f33773c30f12c36c420c8c1e2ddd916079ea1b0f0aede96410d57e085c9872d26d9f4d9f660838ddd88fe7946123dc9d80fe43c37993ac82aac5e6d50a2daef466987dea9959d683939e921995e9cc2004674904863fd88d27bcd70c9648e5435ce34b5ea52d764ddbab2e816e616935d9826e4ff780342b78a16b82a31ac0620712f315334ff81264246a9c520cafc69f1e44634087ff7772d352e14f6c768c7fa036e37278b81a85fe6b4e1123c9356525c9a624d24baa176fb15b5a09655ba2579bf190a18c7e065caa0c56bbabde5e04cc1218ce9c68ac9a33978b848d5fc4589751f56b36b6699d05ad5d0118157bb2eab18bf104cd580db445ed63ab3d62b515702bb8d42bb5c1c89e49d4fc111201ae9be98724944377bd0663815b6c7ec3e300901e8ab371eb5599cc0a19e00aa91f5a804807b72c45d2bc057f610477a8ccf9edac1d9ddb7b413473402d7b8bf61cb08f1180b6a72472094191c8d66057cfc19e74df48a8dbb4403b5738663da548d87ac5b4c57eb05fff34fd211e4d2f36ba3bb895cbaebb0bd972e016676b3027d6ddf5ce9ae422232bd5168ecf2dcb360c1a99ab45869d9440568f491c82b97712184aa011849688d44f086a59325cc9800784522d9e0ac454bf674f08a378b29fe29896c1aac374e6d65e0dae1604a883f80afbf1450963b840ce939527ce7a75e1b9a8b5d9227f0594f4d57f118f2d5b484a2bc7894a6e9e5d413d545286362a420a425ca586f06eb72bc83ca31ba805ee89e4a341bdc2b9322d81ad4db655f77ed4325a5d3d62b45f14d9c4ea2e8bb506f0325651038ae568e91a408ce9de2cd79b1af4d830996091166046a82841af05182b4da898c6d6c2fc702a470749758df299f633a6e84530d041b9a812affb073fe96d7c093016fdd63ac79c6b3c8c98b59bc11e674f3acfcde12ea228b2ec7e1bde0b844bd199d6cc1e10c5bdecf3a980cf64333fd019bad5eb523585f0f8de89b12feebb616775d2a78fbf48f2ebd52a0ebf1009db325338150513777aadc33f94a2b83205f2cb5bec7fb92ad80f14d3deb336b6a6cc97b208c9d3f882bf1982cabdc2ec243462247e63a6eb3ec3854768a51f7e40f296704cb2cfbdf404575766d490377c799cb946b46bfd7c595c2e8c9ab40c827ee720d7a5343808c662c920a0600843cc20714da9688f31b13c264464af52662b456fd9fbbbd81320304824da020ca817bda034252d14123c2124881af7a7182bcc7504bf3451e6844efda3778cac2cd88a710867f61d85d438c32b642ede4f235b9db04e2db9d0913ea0cc85faf56c6f78a28809cfe5badc77986abc38d4d15947bbc527b5380ae2f1f3835f334a943710593b0a501c123583e1371a3167376ffcaec5d33c5a93b508e7d743c390805d4c8c8e9e05a331cd61198a3d2b3bf322dc6bb2a2d42a92e23b4b79e65c6e51912fb09c99c2e4383af06ec4d4139a9e8e490adbba810b6574724b68a53e4258134847de84c9b257670dd56897d8d5b5590397a00b71510eae9fe64464597427589a38c12a33fa6ed1d39e94b0916a74129580e016b5ad8e1dced6dfd2df27a85f7a79e3f2a13926aa4c2344c0c1717a23b098f31992c10adf015e08d148ba0834adc9b847e43704413eaf795869959b8aae88303314220d378ba9ab7c68349bcaa8ab03a7e37b9fbd1346f35df96234b77b7e8f778bcf618ddcddd9caae9c6838fdfb3b818738d44556b75a5777d03cde4c2201cd2d539858205a4a1c33bf56091ccdd3a05271151e43085426ddb2df0add087baf797bf72d49c168a395cc3fd52b1723d26c5e81cc9187be8ba98445635d5bbdb9940ed06db5fedf1d63ff9daac3a3edc84c53c5051ab84dd4fe681967449141ef71b70eec6e4042122ecda0b5fe65780bf17eb08420e3f62b5b4edc5f6bbf3a723285e7e3507809a1a5e4eae5629c5e35f1d78216f640d270fdfbcb7a657fdcb617c8b4b69209d500d488d9ddc3e81b92efc0264f008b1897565813b4b33025ddaf3fbe4a73844475b6b90f8ebfca9d5a66cbbd970bbf0205faeacb385c25eef84a60ad41712f634d2f8edf189bec4beb7e4ec1ac5fd46c535822859e071e853ee24ed353d3b20d13314b843904a01b0df68541bf637d8326b66e7d0aecdf4172bba7877dcbf1e97de8ee87f0ed92c534ed4ff60cae56ee73b583829ed2dfc71baa9979ec109750ce6337d9fccadd687308a8c10dc821439126f8ef176042834dbe3981de2560fa19ce4e31fa9d3c6652b4bab66c87e2c3220df4d1d1478c011b726fd5de9374a885fc8b05bc0b76fe80a5a3546f5a085616e6416041f77fff631d660292c9b028f445987a971cd587b2909562b0a6eecd1fec3a4b4a5f9a4734bc3286f874cc04bcb2b2d62871894c5e64663ec91bb205a5201fa4f833a9f9a453f4181ed966c0a9c2d1e334e05192346d58f43195d65c81b9ddf1b9fb554c613d832c0c6f5442f98df2001fa40c064062ed50bbc7ad009bb24a56d27998e4c123193d0d66f11ff70c0dc70c72aa55b1ec52a978132469b9f04d3285f7cf4d198d69222b07737e1682bb1281e56ccf087aed2d10b4e6ce3de6a7ef6dd91d301247f1888c64e1fde4b12db9ca8baec03a6ed4e62888b56e6bb00a67c7268eec1fc5f67b414e1e6ce372cbdb408e2fbf7219205a929b2f3d07c8aa3b635e6ab885d06a3e6145b2ee30b1dc8158531148fa07e455fd4474b4bf2329000f70e2cfadd65d87462bd8a6cf5163c68cba82ffc7ea10118fd64093996ff275a6f7b98981887f0c01ca57be9fb24b96a6a701882235971e50763019fb92b0ce9e8520292a76205be4a97dea24e83791822fa5c8c1b6435319bd61ce6660b27f1cb093f6387cf25e87333aa8f88e57192b3d51124f0390d7c786afb3b35ba571ce176d31dc6a3251cacde0301674538dbc0c88ca5d95922a1236d3937ef4fa781cc1f07b523c6fa471bd390f7dda5cb41b7ca757bfd06e0639a200331d096b722222b90735fdbc4b7d1f5025195860a898e8439a2a4dc40141aa18858b8a61461ca223b2661a5dfbbbdbfcffa70417a50d80ecf60a27a4f35648968a745cb111d252094db240b037cefef306b224224208948e536bc1968330924fb5cd84e308b070e72874861a78a4d08cf540c7438dc7711249c773813b1e48a8777af255a57d3c626435b5d21807b4f59ffc22c6dc21899468067452eaba7ff54e35f156cf5d566a94d0cb91465dc2814494739a6e6aa6da6e571ea14316757d603c242def994e225eb3ce0eab2b49673adfb5a7cf0d409172f9817892a7ab19cd360ab60abbcbc2f37466810230569be06f98706275751e3cd5382b7af6d6732518e10e71f68f86482ccf44b66d9192fa68c41c3e5bb7f4d3b1efa3f6765ca448468e4152532e90bd49f9b82d0cc25e95d87b9a43b80e09ef685a1cd8a2510e2727be2b5e18c70f502f995e03e20e7dc70bb5ee85aed78d9e9f17a579b92cca7a615d4cc977375e707788e42c34cd7a6a82eb3c397735f4a1a9764fd4294abfebe04447222e3c7e35758579eb2d3e222e9294ba431ceb2e041447ad3bc08c40a48085d5418459b90eff4c96daa6509b6f7002b61346b20226b361951cf3588f451b906b97ae0b4345e9e1a5e21a6c9c58aad248f034e6072d24d22b222a4fc59ba0d1e0b8b06fb4fb812d706b92c089913bf436d7dd6f9a3b31ed84a74a0cea3203947f2a2acddab5faecb2452dc2e4e1ffee74da4ecd9d9c61a5d3ace929203cbb97e6b593278bcb38ff658383ba67d655952521a147b38660b2da013e0d0432e7338d4ff3bbf3e480795911ef87e9bcab39e5c32ad29fb78b461e671c330c7ecc20b6ec47d2e02187a25fae09843e54ef9d5ba8547bc72bd8b8bbbb92294fe89993d4e86a9c8b173a3db7e54985523d4d60f6b5d7d3f066aa84d875697868ab1d54a0306a3b8d091ba19631ada4bb2776c0a6f48e76ad155ce640bf197fa38b9d23762799338e37970624c3ac8998e2c1b7dae5e171d2264e9c40e70570c65d826b32e0918b701b86671b1c0a4b5a0f9a55cbc9e733998b8c23bed64287373babde632f5a0020a4600eaa399ad98652790baaadfe21206ce8ae0cd14fbe1a29b3a88552ba897b2d2330f2ce8f296f34272e4dd0e8b1d97b8d0a4d27e2dc2c317c1acc66dfdc851d7cb083140fb1a7cb09355bf9937b6b6755ffea26c3793dfbd781d709dc1a12dcda85351c41f98d75f5a6247c9896bd29cb378ade0197fe00378afc8f17518b601febf38de983659c27d9c3d6c87d8f54ef17c93a603da3210ca8b6a3075324bd42f90e869fbd2c4bbce2313e97029326b49089877fbdd0849df31e4126ecf13788b783b856cf79f102b31da9b5b2b61df5055607311eba46afedbcbcae5f5236e206b80db7c58b5973bf0a9bdc4ea575efc992878d4adc5e76f0c353a1c57687a0bed7630968e4fc6e9a54ea559e012624762921e83c6abb70cafb4a2c6c79d27ec0fa4ef1510fd2ae4529df60c90f512b054019f1db2926ed064c1c3a65002d862be16cbca2c5d6cc78ad69d3f58aaee49fb0941c4079793d66d10b2c790887cb255a146843a6fa810a412f8fac99d74fd067485dea9700c6cf5394761f374e1ac0f66e6cea7e3c8710af7450994c7c0c7727c512fb589aaa793e7aba768c0867ee6a1a29fc342ae81e6b47f603ec852bfd4390f966753170ab093208382cb982cd217bade2a64cb62bd8108dfaf78c228b2896333dea6d92dd8af480067a0aad4e9937d92f613594b7824db5d1dc896e7e021c4218036fe65f46a4af564f8e668fc138cf99d7f882adebca81641cc56a128167c4485f609a5434a052800241ff765e54de3434a3c069efb9918a14cd33945e333667e26bf8522a88e68ec6de2e6918c585d629e761451cbd3ca45f3c4d3acd44851eb98659516b871555575aaa769a822cc848c5d92ef59484d4ab29ec456e45b47a9f476d5c3d4171f9a5a93cb00914f0a25d7fe91719fff05b1a0ce02fce153fc133e1a0e8f038d853c4b2a59c476aebcde94572fdf843f8797b62e6a07ce52fdaed4a16f6228050d5acd3718da34512ba7d981184786b6b70b17f80e3827ebd4a9b0042f83b028ada139d4860b30e03fcc567d125690d68d0a3f5f0c06e26cee153f5e170f88e7a5c5d858b1314b0f912c2f64f3d5a6cf58f8488f2452cafed687754089b5d4ddb0765b0e7d49c6442b14a879bf1baa152b4dda5f37d63b95d2363ff3a6272d1fd4b2e2d7099741588af60d599035aa333925bc31ea0fa04bf51551525da5d0364187c3198588fecf3db8db055792ba8e6c2188a1435823ba335823186220d0232deb641f2edbb9806e8e22487a51409be315e6223ece85ee28f629f36d224b7ee94a1cf14f609f87bd49ac0ffe52e2a59f276e434b1568d01096140bd6f8917b4d14f9abc365b5a275f74b64c8943bf607114262d1eb2cdee933347bc635d439e213ff6c0c1bd257bf61bf9bd32ddf576052b5dfed0159625bb84a4519eb409ff4e1faca4d635c19111fe7e155c961b105a5b9305ed728cbfe01117eb229985fa6b0581818d3464edad68a442ead8ac0ff6b7c1c9b2f622c7fe29b1644a9bdbc03d9ef5f90624c882bb5e1b186f72413c5401dde6a5a885ac40dc9927f4b86abaa8012b18cc7386428e41c575e0cedb5c1eb5a7e00fade6a03edce0ede38f45bc169afae0a6b84f189761663e9a335cd222f435fafa477bcdf7b5d98caa76620152d5dd7ac43b4b17cc1f91d1cc52a3af6a50958d6fc1a8036fa77af4754cc7cf722fb59bacfdb0448ec770abd2b2b80dc044df52b0744936c21c3e6adafd5c1a40e7a4b4fc2f6d203e6d0379dfc5355ef2c6ffbe4aaee2d749a76e05d743211a4c81d096fe8a244826aecfafbfd340027020eab701b1796a8c5f3276eaf51b2bed90ae43e312982be3ed414e0f7f43c558c7ff4608a7370eb1b0a21e2fa6df5282b5ecc0f882fb6c8d85223ac15775e7c162e579ea1518bc8cf295742089c6c0870712f6b94679794006d4af61e4bef77743a0f3f7326972f0c5ea2d52ac0aac96ab7bc5d51be81cadafa045863a190af9fdd765aea7d053e198b6f1420663a83f8d3b4a06556c5a88920330fdbfb786daefd4a228eb2c81b1b9c66906cabfbccc48477a067fcf6c891d8475d4c61918b8f6d6ac01fc053a0c634486300c3b0807013d87ad9a6266065003bb59a5904923bf580698d86864d624ef57103d70bc9a7495d9fc8a301ca58b474acf6587eee56ac087b214d066c54947bacc8e5637ceb29e71b66efe20853e0493c3671b776f4a210ab35630b71f330e4cfd5bec0b56a4feca3b15596bcc8b983062c879a0406ea044a295068e5bececfe680feca3fdd8fedc4348658d706596bb99424d862f8aba4b8bf11bf0f44fb846bccff402c55040d66107494d207320957eb8d9ca68e7e02a7e9825c1cdc4881a830812abf19f847c6d80a9645fc3616ab5687db9c4fd013380e135794785291af65ece0ed1e7c42feeedc557747a4445fd6620d8a9e4a6adabcddf2091e1d57e7b33343f1fe3a49e48b8387fcbcc59c944c2e1d03eaf42193862b20c8a3cc41b29ae33c194cf0bd2aaf8b17b6d6cebea9c7178d41a6acdb76a00c3741c0126c7ed906ea83c49a740eca0535e8ff43da0ae912bee8997e5f44c17236fb1654f1c3bf5ec01c2fe2a38b869e1414ece703226fe062312e0e60506c6fd35b5fd5e2edd159f7d73b47477ce4cd5693fc2f166072680a8f1ffbb284306acae7a8dcede802a6d915802133e82e05711908309073760dea2e47d049983e1936aa0758c09da074a3898e0cd7a28a8aef48d314eb24e4ea26743a688aa60a48414c5c032f0685b080106e1012f6486c10924810ddd4105074d2f44094a0f94a5c70f709fa0692c2371e8cd033da7f39daa2c5401e272ee388809aec4730d2b4b59be227ceef01dea97099f656d760cf3a268d14d6e4908d8c868ed4faf63e7d37d98421f8a0fc201e21e20a0d248defd4f564ce1ad09d633a6ceb9a0b3048f569af11a7aa8c95fc8bcc0e04e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
