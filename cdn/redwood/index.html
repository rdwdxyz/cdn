<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6cbbca85d6b4162ebfb88eafb80c1ff4e8e3be76870248d3e1985ca9678444163bcf7146b1351a0156e66727519a9e978caf50e236e55b77888825489d830638a9111cd869d2bf180cceff592eaa359343983a6f2bc8600520df9573f9313e9bc2fb9c3e52c67f13ab2e816fb4894cdef9fd04cc52a3818782260441ce935b772a72720118d1dd8839495e14c9cd92b40d979610b4918efe096f847645004356bf4f80450890681334185a3a7b029f7b3e04088955c0e72538d68c4e92351f86a102ce4c938c4a8c53db31be2edebc0ee21cca5b023c2dc666281d4498d10be55f9136aa434325d6a68c89f3d5a19d0df7050483e2b88215bc79ca101031b67d5bdb26e33c88559c6ccd18b7715c94855f056df422f2b44fb87ed903ec770aa65d5c1cde7ebcbf9ff84a3b3637dbdb36b294797bb58eced2fb216f773e86aecf1e249d3e8502db7708484900e1d9bb47eff0e820b61e3c24ba07509f298b9e3616ad1259ba561eeb07516d88334245b83322199d5eb701c8981ddddbc3cb7b108c6f1d8ae66cff510dd2a6a1d7878f0b1298d478ff3ff544d60d76e7b110280891a4fab5e61f2e35ff5d831289bfa1eee587d2d4588582fc755337988612a5e2d9d7bd1323a59cd1bde31e8ac6328b7ef661ac2f1baba7925ac78feb72df39419c244c54435548813ecf1ed111bfb85c1fcdf151c19c2f35ad0fbad5043d2abfefa033805f3e7d0f8e3da1b057b619a05bad66d0b4c2f7d9afe8487c9a0a0144fd0c430fbcc077f5c4f29593bf5f44afb8f038c114e03d37df444c41649942f00b9e0e857c96ab199cd2eb69617a384b4ab9aeaf2804d6b544e7559b1540d26743932f4ae6a2d1c8f1e2afa383e023210e498291e81fb00da8cc8437af8368013454f811cb6390ed718b986d9df63bb7c9e90f4abd7a18394d0165c2a03ead91e3846ac82e955a8958e5a408af8a90da6a8e303f6eb01af5774480357b3fffffb4963ec1dfec0ea5f88ddc2f320f148d2255e67e22210c8e258e76249c30e28cb2c6ea3fe695b7ec19503d689045d9393e7b054bf81d7a40661f38708bd7ad5b7329d3069c726390ee11f08eb11d8379eb63eac2adec893b3783b4c0cb1cfa0b0fc1bae09ec347fce2b978e96baca8530eb408830950d7f2592b2aa66570bca9c190583ff710881f9a736e3f60773ec5058de0a1362def8145536a0869df0f47f797223cc411c8e5580fe572fca20fa46a48657aa0f655ef46a37ee81ee7d659952724c619aa0666a8e284a88ec68fa2ff420a523bc8f326cccc7e9e8331b422fa29e4a010ab0fc5e23381c583795fda1ace785fb1629e577750e2328b600a5490d3ccff62ae9398d5e66210aef83b7f825f58bf93ba98a8ea1a487fff05d4b9b3a775b9ce5eef6432d80e88d0fd5687c928153fcabb2c0575d09325a6ce3919e8975c98437bfd871c733fe2ec21a7881adcc3332019043be6253040edec7be90fa44e26cd26fa465043ea9ee4addfbe03b3245d0049e3befecc9e01e64f19267d1deeff9d423dce9932a398399a065cf72a2590db152a0eefa1017da5eb25302c4c29543b831e0692a0220d473c1ef90c754c13d8f1c16b1c3a601efe5e6f27903647d82126ee72a2a7089f887075f846f7aaebdc163efd98379328685869f3a51850227486e4a54bb8a85943ac66a68afb086948d28bd48b10c141ce446afb8f5f7b96bbab31e77c1afc51a4082bcd45056afce87cd4ff64b358bf35596422f31274759e47b91397ae24efdaac82e4a5422936819c549a086dc9f3c4e1032909aa16d5f5d678ae4ade28faa5ffb9d60874a2441e963a9bce3412469bb1022cdc89ff10c3fd3c7006cdc6abf3e9480272fcbdcbe811a3f92c7168542fa6492916bf591f1d7285d33eaa6128daecf8abd416c91238f971ea62d5edfe2db6d2df0de9dfc4b20b6e9fd4d81fb649fa7f63c13e4de58ebfb69a15b60911f4dc2832a1b7b826f4b8dfcf589a609757a375bf132db1d0b61078ef78e665e12cb3da988121e19dc57184d2037ccbb276dc3e235b80c3156cb5a3439663727945754fac4cc7f01d7be74596dc37375c2c1283093bce345a2236fc38514bf4a23a79aa88f84764dffeaaaaa065befed9f92ec0f7652398d56b7c706f89cbf6f9e8e6c61dd0f3e7a1dbe258e99abf3dd7da9ae827d47d7b07bd2efad4614d4a0a09c1c0ae945102a4268eab3b23c3e23bed6322e24f20377bb7a9058d3a39cf4084178b6deaa10b655afa5158fb065daaad7f7a99c6a47e0cd34fab2dc715b89aac3d37ea2eadaa30098be554738605f8a8ead37f045a3b1d43eacf0fe2598bee33dd0d813c0a528950b633b90e311388d17f428643e28f563d977a53f43f4d3365a159bda250b35cec83b628c638e500e33c24213692870bc111d52f3cff54f74e22b941e96bd2c9d83c602aecfe560e9ddcfa0b85ee11881f05eb04ed7f0e8d9aa5148fa1318e6891e6d4c252178e3e4a61a1100dbcf6662f8e070c81962f7b03d8096a46cdff61ad17bdf3866ac4af6086a8392b89c2702ed6a15040bfb9d65eb7a39f39ca271cabaa4c8d1c0c27a890fae57263b50581ca1a058a194225323d5aed5a0bd533d2a21162b2a7c1efa2fea035d54034b32711b173a36336214233a8f7f35b0812a82880e6951bcae1c302e880d4f2291f9725f552e2c57e182ed2ee75683ec78661b5361555a5c6a03da7128cd0c98fadf088716f00315ebb8fa795b7e048f202d28f9b6b2a528773f4a5d711115ccabad0b48d680132fc13dd42d559a2b1ff2fba78dc88e92df2baa2e1cb5659fd26400eeccf305402d62daddb3a0922cac94a558c5f0d69dd6cb66761f2c9aa553f17a10257bf9f86011ce8c62f192fd5394e4c742f80ebcf36441572e42be7809e13a628c83c61a954db7eeb64ecda409ad11c8b4d2be2f45537b0491965ecbe180152da04a347629d78ed6bf955433154837a75a9755d20e053a583b478e7a9559d358ac419490c6b224fac61a6fa3e7dd3d0ae45426e0e4829935ed407cece337810c0acb7768763333f1e1f6ceb245fee709f67a0da84ce34177c6b359be76917a1bc47c24df2a00ebf78c701b76ef4dacb02b401958ec492cb9debe7a01d5a7999b70863cb570d86986939d0f6d0cd94cc58a5f7c07602067e243bebce1488aebf60c483cf8d7ef361fc0552d5e50812df02af8a42dcf03af39e7a1ae37fabd83a2ea8d10e3e177e905ce0db80ee3f9522c921ac85a7e3b3f63956759be445516fb98cc2f6590aecf8bab57b4d26be828e85fcd0c7b1b8fbb5757af0a841fc9185d01a5f1f28875f51920721fc0af4ce970a30aa2f0c60508ea529999b2c1b00b6dcfec78fd0d0220bfdbe2a7ac172486746c31d9e297c5eaa63e4518532bee9957b205a4af773ac958ddc29fb079468b2e8dc5e97d9dcc4e0733c0e4535d9bf5073e6c88f60455e62b869349fdcbc77302428b724fb801053b385ed88543fb98249d88e19b8f6591cb5c1b2840c77cb37eaeeada000a39b23d5d794b24f42ae503ee7a8e69aa76176d00099cae32c9ed7368a95fef04e8d81d405a5858ba58099c24a1dd59bb0fb8d90339121a4ba4a5fa5feb50ac85913ac0e7cbe93f74db603faef96659632428272325574ebc22b3a5f4a4c148aa6827973ca1dba8d1f0ebf109f41d0e4dcda6baea0f3e6825478b39b4b6346c0a27dcc1585ea9959aa2bf18d756c785ad6afb12ea0bb574b45f60bda1d4f4ae5962ccd71528b1d51521abcff076a1187571d0a1ed1a4918378959de115b511619e6a3ad6617b80fbb822bbcb7dfdd4b9239297c688daf072b53792717e5a3e3bc78169e2d40b33fab0f38b6fd2628f0197240ca3dac37aed5c7700be75bc35a4945df8ffd137573948522a1c349f4bbdf39909a7c00904304f561ab28a62fc215fc8aa4b9344e9251726827529ddd1d33b58ca990f3cd20b60154311d2df4e204a76dfd77c3debcd88e92f1113ab81034a4b5ea381e5f3dad566c539290e8d32ec72795bf51edc46b32de19f59d82b2f18a84c5adcd0f1c3a3e746cfcc11935a5b934aebe1f764835f3923ee7b3a181b5b699eae33de361fa8cb04e1bfd8dfb00d16810b558a1becfc5fd3f6d4f087e32025c882f55b78826c76433eb1a2134504ea9755863bf99fd93147669137b55dde75dcc90cd85c8a622f5bbfb3e735765f87cbac9954a04df51108766607aefce76e479f96912b1b70defec47ccf9711ee133cc2f42f77cf154ccc51d19ed87aefc4efc1eed67d70b155963dbfb1a15fa18f1ef0463c3bcbb5a3984f125238cbe2b48860c5778ae440f06954354638111f2ec512aff98c9880afb9fd27519afd649933ffbb0cfb0551cbec186a9f0cbbbb14ed323e8ff61dcbd6df6af869163be00421cd2ab8045912701f1b6be6ae2c95ce7491189dd6650944a096422cb11a34021f21a4bbda654c6c00161826b69a99925b77b484ee0d90cdc7a0c94c19a16cee4fe2c5ed5e957d03da5c2d2e0d7b020cd7453292fc94fe34f9e4c383ecc7049d88add8ba5c51b53f53b42e4c9928a25e865efd8438668128256602d288bb4d2486a459ee6a63bebad0ea2458b60d8f0bc2ed5180b5b6154598120c3aef8869fbb22a4aa4e19aaf8f038bc3586ed48bc0536418a5fa5ab7bf86ab2e6a7744bdfe5016b70370ba219b0f9ea2f2ccdfe8a42da8e07b54a9211205496f84659e3ca0395d92f33e155a052c77369a0cdeb49931125e01087b3c73f7a80958a368db962ab28b645b5eb3c9a5ad92a67646a5927b7fe3e0885db961d01c0eb63620993ff807e158ab13e405b5428cdda233fed38a398c5c6b3c83062e15f2ffba3e24c215fe72974127f1d114dcd8653a4f1eb083f59753fcd71229f03aa4d62e80f6573df0f1da2ee280979259c99a35a479eb7f71f51ce6b13f3d617c029d1c5ffecc6e5c055a70fac4f9c38512faf74b954d08b68a3c7d98563b71eab9bcc8f121cc947dc888c3bacfb445560af222a65cb9536a0d283834102706c75e20884a580fe9e4eed1165c8be80edcd3d82d5561b92484b58bd3aafabe4ae20105c660f9e7262ab81671c4046e21ce4714865e108951fa0d7585da5a483550f3831283bfafd7253bf63e994727f9199b8f6adb0f6bd4ad0459c29e6af0dc146909d0e78e3da62c245fbed75d114bb402fadbc95d94af13daf5ddabf257866024c223ecab28f37443d00b32939012a357526d82a0671358be0f2e94e41a5626c7a489bf49ba033e3626c39d6495b6d4a1321b93ce78423ad0e78cab4fe4277332f0620d2baf72d58433c8cf284ace9326ba8e8bfc7f4ff56f99528dde0beba820fcc919c6b98beb6c078e7286c984d9fd4ebbbd29fe85685346a0ffc0cf550028442b59c81e44e2c9d90dae083b600f12c920e1434868b8464da1a90ae690812ce6117c8aedcc35fe6137afac67ff774c5363ecabc1b1705684a592c62783ea1d069cc5ac98a0b8833aeb6590967e2d8c0ad4efa8b613d1305fc815c0224b27232e23baab9089ec2947a39d6f53ecb994820032f32bdc37ffbaaf7306c7451569f583509721e0d18d1a31368713c6a4d39ca23fc96f6c980f10e4bf89c1fc0f351d768029ef783baaad61b29eba52dbc65b7b78bff3e499a55d10daa11e17ef62d51415dc076d148cf74e07e94bf0e678e0930e99cf74aec7d02bec52a91189782825230f274a3ace151293c33c1fb6149e10bccddb08e21c00cfda5ebb3c0bda6bc27680faa02852a20089f88c99d87311d2cd3f709b9a0d60bc6d9b9f06beecdab75cbb86ba7ae799ba7ace371ad210599d245dbb98f0163e87bd0468828bf09af53b4c07e4c2eab42d8a18a0b89b5202efec498ae7435523b5655f28e6bb6b599f9c5bdcb1cd160360f5b92b0ee6cb8a105a8b28a650565fd1c23ca86de9c1ecfb0726c68f3b901662c4230477830c0414c8a2cf8d80063149b0c7726f3e7bc13a466306c19ecc34f6e6cfda6b00b46c3edda9daec92ad9e838a34df4dbdf283ff3edc116bcd6faaa8c4ccd8e0f89d4a05f40e6c969612a52e26de083cce2cf92008a7fa85492a2d405cf78684cb2810b36727958dc52481687b2e6c3017c278f228398b4ed2ddf6eac06979284f90c8bdfd6e4dda6ec08e44ea1dbe0d65d31e2bdb519cdbe2347b00895130b09384b498a992bc568be4b87ccac822a0241753c8536d562a5eadd202936f6d6f01e7019d84552778583a082a6e46c0f043a64cb6aa2e51b2a5f61586abaac90ed9f1ccd126ee53a8a974b18dce6f5737d3ce5bf9829bb49ca050c9615d75b4d397c7b0591034db3166810c87375c9e20d654a407c313e5433adc6e7a0a9f5482642853cc0a0c3449afbe9e93352774a0d4b2eedb5823c5386141908d77ffaff41853bef8b16b89c26ac3647a46010032278bba8d4b7f76dceea16249fff9b1502858726999b7db6fc9e68877e5533b4b5582f8f9400946359c0b5999ebdaf3d5bba2b47de78214552e9c898d0fe46794720cc21560430d29adbb1f9ba3b38d1a5932564252546eae35f7d819254dfcf52d18be96bdaa6c8699c415f1e46d1bb7e39c645a3eb9de675f3c10566622bd22efb7779744c43edc4060403d70b0a8949ac32c674c4b7fe574030424eea854c7701b8239d0596c49e72151a2540b1aaedf283069e44fa73a4651981e9f831be755893145095bdc460f8993f2eced6ce4d9fbf31794d4f8c5e6c4d16db12c42ebf4ecee6485f41aec9be0ce31c3ade6e0c9aa7e921e1dff51ff559f59ca3930e6586689622544eccb50175129f54c7debed98e464ed5c9ef04cf9f7a794eb456ec690c75b8002d99c727702926cc93c274dfa5c98f1c9beb5eeafdd479b6940959d671b102c1fea30487d756a4c3a36d83059b33bbcad7d592169cdb0ed05b935cc557fab4bc7f75e0c7571f104f76c081be5559f6889eb8328bcf79fc605a06a962a7b9f98131b86aabea2a27a52936baaff5c9c6c3d1b714ef8c8120ab2102d3e7b0cbbb121d9d4b8f864752263a1e58d07de51f72b4e138c7fba17c409059079f5d9a088d2c2a7afc8a065923c945e67163e983d089ae65718abbf6d62cfb2769e7191b4dcef659d531f0818b8ab1fa127e70c8af0285c0adb13c5f46b2638ed22b87876bf7dd331430e7e8a4aa31e9e6592a1b6851565e8af85bf0b42b2650d848a1fdd7e00e7517e0078f92e4beb9b549e1ced89c936a6f6a04e9c2265060f63556bb31139a946b8b21d73aa00b4b1dcc7760b7a7a202258317ed4042cbbdc2b80955d4a091fd964d48481b7c5b541d1245361cd30c885a7bf8463dbc57200198cc30ba5868e4072655a718c32418d34c4dd52cb54f51d58e12249e78efc5132dd6d654499f5b1fdd390e46eaeca2d49b1a354a0194af551069fd5b4e6785eade242c53d9ac581a9e8620e6cc0cad1b1d6fd60e8cfcb03a60343580026583bd449c87b036c40669b69aeda5f96656f6bd7ca7af934230f0c80ea7610e836d63c4b75cb13ab54db6ed48dea2416ed3dcfb9b0ff52dab1d852360d54038133156dc06f1f25c77c9e12e1ec4c10a65bcabd7e02f9e9818853fe70b064741e6c74406f8b8b1bd249d24691310453b93603bb2dd67e5bfaeb30bec3d25120257354075c31ac6faef67634593562f31e634f99e4aac37909735c31d32ca6d8981e0a8fea5d95b01391f2070e24c90d76b114df92e7a8bb67d17e5b7039f64ab053d99e42ab7eabcdcc9419414ec0d1b6004e86a1c09697f363572913d6e63c58d4ca77f5e321c64fbab03daa7823117e2bde3968790aa6ba16e19e7214cd827160920426dc1270d5b90b5657878f8407dbc8c62e9601a760f963a7e9c5187b3c0fd85dbb81ed782e10584b440a3057a2952bd0ab4d7ca1030c0a11f4ec26e8dd9941f0d3703c39146cf0af3d491c85bc2b2a6384b810f79f82811a359610a60ea27058379f3a3ac223631b7b64170e0816224176e1d64e9e5e0103167cf2f8d483f2ed3ab45df150f37341e22b99fe70ebd1d83b49443390de20f064aeb4a5fa1e0b1f26f5f1d471d781bed5b5427825dd893206d95dcf9fd506e073920dad0f3a9104be27a9f3072533c3b3fdf4a2397a70d9d5a08bd1c0e59c7bb10c840b0101aa1fd39b10edc4395c1acf70e44e7703139e08bd0146ffbf03ebd95402a17055c6443585693ca37f0955b80381aa40e921b78b7f618cef63081c4ea118d03f23d2eb28a5353aa4fd2355e6cb728aa6e1c08989b03666b6005028360ab2b3d77d37d439bb626a4c234071942951ea00ca2a75ae0f5b144405223658dcafa42aee53ed5563724dd4949309b14b19c39c45003165624aa77df4e856b1f02c68ada4cd0ad8b113078147acffd3e89228a4eab275495c7d89895685172bb6254ba55008e49903160bdbb4bd1630cffe6ec477d8bab64460ce0e6ce98b0124a8b233a9511820c3f0a8af1e0449d4f8235b2623a6bf2b7fe59e5fcf8eee23aa19d746efcd135fad595e03b708349c66658a7fe0bc1c9fe31666460b425cc0f26711d82d5f3d4df9d0b8e4d799aad5ff67c9d0ef367a309e9ee344f00829daf7ac2e9c16baef8e80513813c63d25c5e25ef736b41db29e434a5a615d3b60bb96dc740a2c6aa714bb69ea9083577279bbff2419845329c515ecbce1dd48abb823c95e44f125b0bc8494cd52dbb035db01a7015e33464bd295265e740e79db9b3e6a520ec68d5d33eca69a15989c3a6e5e8b2668bc493585827c19e24670e5a2b8d57f7fc5b4cc1a1e0a55f2a07c7cedd4919219541e2251f2c5655cb36908653f2b35cc6ef176142aad709390c8f7024bbeba6e618934369d7765e4f611ae5332ce65ad146ce8bc179219b26f8205e9f0524e9187558fe88276a0e14ce452518c482d3faefdbc552d6a3218720501547efcb433117a7f5105e87aee848fe19bfc0e1c3e9c9da6fad27dc93700db14eb31b86026cf3cbd6a8cfa9d1e28a98d99fdc144617055ac50e6d72f8105a0893fef6bbeb40bcc004d5338d188e9d256aece41fe9ed8133a30bf3aca8ddab899c58320c0e67675729b27fc369ca1f2c85d60cba95417e672d61c492dd047a5afd3464fddb20b7d8dcf4f1c922a88246e795cee5a6ccde3f72a94dde282a3b1fb743d73277bcf24f31296b6b2c17ee19081c0092a6d31041c11bf957478353972d707702fdcd8c1f3d2c65a777ae0e822c931d4dcb05cb6e320dea4155d8503fbffb2b6332dabc8deb84314d8cad47035d53122c305795c1a83c2b83e9017eebd4d671ec7f913a8a9c039d425ac046988bb7da39011f607d03b6c3cc4b83901ad04df8daf218c265f94230a7a9134f5fbb20d40ec5e3495158d70d750fb14428783d6b0f085b2a81f1206fdaa51a272d4009d0edf529b25df327ba060d2028df8fd0b3f1ac69ebe2700414ddb71937806fc25bb22b3d4dc7ed9550fde226d0d03fe33e982d6f247a7198872ad9f398cf348044014992991f6387ffe2a6fc8de0f15eed7ddc6862b5e7ea3403855842990e09761f0427b0b6701fa244ee2fc28a82e38f8ac14d5efaf2b482433157722d70a19bc27da39ce897efea937cce2770c10dd8d3c5577b981d5bd747dfa6b25d8c74d4ee48377b9d9490466f7f9491ac7b1c9be1fbf5c01beb46f9c7c992012778a9948718d04ec34a567f04455cc5532a65383e3662b4bd166bea506292dcd6ba1a8998f4ea18af402d78ddf7bbc56a755e06a6f22b859410f1f1c3a57350157a5e35e7ee6b821252b25e44be5b1347a47cb0e6d0ab8d70f0bfceaa7875a285251872e6bef865a6064a7809457d8fa7d678b9330c6decd51cac5a88cbb6e2e32fad5f4ed3026ca3b00d97f7830fa71a1a333e1e54afe6b1fb630e60a742a50f889116a3f0edf2e16a7ff1b877abefc633595dcef9590ca3c8595d98ae94f15aabe25b091b83d259a7298dce9dce3c95518a97e34b22c7010d82de56a8a31f88926bd40103f5dbb6d3232bd76beb7a4a1b83600f6768a6e0d32b6f2b486a05affa51733aaefc9a09980ffff2c34a5ccc0c0d6626eb4b7d99c8dff100d26705e847514f9358d5f4102c68bbe05327511eb6cfbec62287560e26046bc19f251efca07058a027bceb9789677678e88cd2fe03452c891c9d445537b5536ca69eb966cb79d17803213b635a781d85e608a25d797a66eaf78d304549733d4b20461b72dc1d9436fa25e9f96140446b60a43dc3a32bf70cb08d6949ac359eedcf3d7b409d62f50af9da803cae574dc69cb6c5f06d19f2b1ea6219e1f7ea9a353c6d1eadc219e9da8bcdfce6117e8c45ce4da7cb56c4f99c075f72896912c45c57c8b62f37fe29a6da0ca0f43ee4f6782ebaeed46052531d2ab3cd45c46964df0be28da2c10a003979f6a2dfacd03ec4078dfb067be5eed13ca13c2c5ba578701d412d0218faac3da9f8573f3f4d3381ea8e65b8259fa42c63628c926d6a745353c74900c05d4d3676c7e8ef9c427a2791de9c49e7bdce1fcf5232c8d1fdecff892fc065e4553621dad1b2bd8b6bf2ba1f6789862efeb365dc9cac0b2f870a30bc371bfcc3f775efdebbf0572d0c6834da55f092e9895f49065e444dc32d5bc8f99027722d12851d80824a5d4e9d94c69e9a20aa32e64959e3aca4000625fd1d981b9d5582e7d0b467b35d09bb2e8b352d7d4d726ab7ffba3543f819b856d8af4732e4775d835bbd5255fee9b02b8cf0e84c1ff0bf3a17a4bfbe8c8383850105f587ef839e514380ea48c9bf70e03208685c9af8708c4f0866cbe071430d8580b3369fa9908b34bef27db6e810ba3b7872f4e3815c911472406424bd9a92b5531c001a48b34d0b66e7f87dc2d2aa44afb67049f52f9399a886283f0db859723350630fa3db9dbbb0c7419cb53e82aa73d111fcbe776a64f3d6c01ea52ce3899077766079e357a4b8a12a585990d37c4ce23910bd5dde882cf32f184bba8ccdedf60eedff92e1398fc7ae942e481078bd416595e09558db8a88e4df801f4e48f1d9a0c74bbaa26058b5dbb46e9db74e2000a4c543e41cde7d8756219dcd87d8b314ab14253995cbafe8368514fc49bc0ddbbfed20235d97369ffa86ccefce688895389d3bb292dd29fadc916d1f0eb5520a8dc9fded15411ea34f1b3780df704b34a38f7a3dffb08f509eb5abad3a760b85e7515981b834530e22e9ef539219f9cc9d7d6574a9d1dc762d4d99466064e5b7c0af4621712a3a04ef27eb227c07061843788d1e398dd5d0a931fd0adf2e61d4fa617c3b897b212517561d470e00af06fd2e09df7481aa863c049210832e8a7d2b4fdfc203c9302fe3365c9df82f6aebbabf8140b9e2164fd753e996df7782b7a26481cd094d7f169d8c843507e8df4485771017b29ea48399e994bcaa71b981a477e8818facc29221b0e44dcc4ae3d225113b5c6916e23f2cab60a3f6d25dfd9463ae4686bf89b350b0bc3cb66a3d16f2f69fd7c8a310ea964faefe5f9d1d77c38c57a89df1267a6b8aa79c8957369682b64fa3c41183b673f81c950bcf6c12c14c1f9a315b40acf62c44a5c84a5c7302a80d5a6082658d18ff585092cdc72ed06d8eed941d3800c0eba00c18ca949e1bb295a9921f16b7d74b8b6e36a869c56620025707afeea670bcfa68609f87a34297dd68215110847e02d70cf4538864b9a8bf94467fcc9029a14aa7bc4756e76e664efa702f375f5ec2186f0469ee740b6aa37a5c6806e749f39af4aa42579e955024467c2d180c1853c4b744998b5c89bb44bc8d0f23a943a529455d1b1c103c6d05ea5241eb7a364cfe032b7f825a71d061f0a3c447ce551981c97e72ee7448dabdee628cdd7e764ecfcee77391a3bb8b76f25eb834287d49e57ae398d79d12372ca0ec7dcead8cf6f297621a8201c053f8f05de22ddbed621f954236bbbf07bf94d41935aab1c5788f698e061b21db770b5f7388d417e0c802ad5a3baa906d850ccfa60bda23e4e84335429b74ee1c2ea0f55ad11e6bfaf5cf0ec6764f22850e5d0f7a016fc1694397ffb80811883d934220cb3d100109dc3758eaf89f553f1a1a040bf2b2783b25e4cf63397e1ddf56550ee7475e948d4442c82a6f7826441e2fd2b81e886ad80213145105377a63c9ba87c88befc9ab0838120c8013941a09515954f30498fb30f4fae5d3f4e1b98e4a816c13363470250bc28306e39c94998683020d9a870696e0195929f5f7a998157480d570c5829bcc66ab231bc5bd4db0b406407c68182c11b7c1260ef1d53808adb38613b87d20653adef9925a127f83d378d3fe5e278ff86eeaf8f8809320e15d43a550578d09c9467bae304e26a8dd38a69ad5b41aa31dd1cee76d1c89195102b9dc9451d1d630e43573d0ad466f7836c49f958d3a5fe77b864c0621a76e0c72e5b8054f1e63f0c0245cec921acebfe6ed30088a21d693e3ed9c3003823fed8462d08473c5c94ed73fff2727a47668498ba12afb2f609bb27798d00308b91f5ff45c4b0a416db2e8641d3eb8a61d1621c3190d037d16d80348a67c3837804746a19be9f5ac06f612221c1f440228175df867a9144a26539f0adf94f66f90402d0b20eb6c0a939c8458d257d37d1bb41d0f8e1cfb9abd6cc451b0f664261dfa38c5b956aa8f473beab813247993406dd497b7c5d1eeee4d0db8531ad09aefcdd46d584735e978f9cf8e5171816b3357cb0f8e01d848176306ed3b82f522c21f6c5145f4891e0b06991a1cdd453e6ed03fae626355da2c14158fe480aae822566d8ad6148360bd32a72619fb45c58dab2579ee1552570ef04d5c759058f7c6604291fb9274a762bcd7bbd38d1744a72cee5729312ea617d2e164fb537d965b88ccb52663912a63bd6241af5390f5654097e9f910e96ffd1849e6c9297b8245f74da3b16929900ba0939143b716daf9cf2a6ee27c38ea3027d524680b18b85f69e752cb343897350f87402c53c1fa504516ad5c993ceb77debff26be8419eafb49baf1c1f367b4c4adf7a89151653d28abb8624dcb87901a4321456e2a5e632ac93ac4b44ae811b51e093e157bd106a4c1c9e5bfbc2e539963c3db5229ee3520b911fc1cb32a619a8b408079df547b557d4ccba4f821989926c657865d3a8f61410af9f202c90a5af0fc66380989c4f155281778016826e403a20cb47f3baa0384ddb3de8aebdcc2438c72bdda189ea0604e9988631d706f4d85721f1ec7a8ab5fb2900a0de2403dab23f1093b1d20a26ab99d8f42e91e52c2804eaecb7407dbc533f45a962327a7ed9703d2eca918fd893927ab1d998cce26e1943b71720989aa54451162c1495cbdbf779a3cfdabaf177bd6e45688b98e0199f98c8bcba838449e82bf0b7088e6affa4a04a652380422b1fc7833cd2154c027590613ab2ac7dc89e4150d9e4933836eb03cea4e8760e8d7fe64d9861f39fcf6b57ed46f25ec456c7b5a350badc78ef3c72f6e111130da61998f05908556e2f9a75d891b2cb290832bd0799d113f0b24b56737baf6e178eb0cbb347befda62553ab330db4e433f1070cfb09da0d7454c6e6a050d7396c1fb43f911c8f200be85bfe68e41b3eb881ea083ab0d32fdc75e473a08f65a8f669777f3f2cb0b17a696205d0c45b80ea062a53efd68d272b00e1ac9110cd177808775ade8bf60758f25dde5fdfa15126dc213b699c948f7f14efd709ddb5b1a9f99817790d0fd1b18c1fed2f28354d9be7ffbce4f721d59f9fce573c823034cc13e088392c15c87d52f1ec4b6bbd3193621b205e296f75c8d36f2aa513e8ef5ab351b17c1e8cd0ba6eacbdb94f433789824567b6c1d2d5d983c1a2fcbe9ae05181795149b71fe939b1cc96b1642a23735019161fa9f7164827edca547b9377a24f8e03d9de240c2d9e64a25c2e24e6fc962ee8b314797581813e2fb0cd7bc034da3db9f94961662d4c3d85199fd3bd7df7f07939d1f53b7940bce4bd2ad3abc8d527682a30ce1e53463ed68a9ffd7d8fb19d6e89a7b5df64d7a02d6b68741a113808b5aac150a43e1454a21759a90230dc9c95b407c4c71e4fdebebd2d539376d59abef456f660579b51850db3d5562e5cd3ad48e3619359732d4893c0b3fb6c9433cd1b2d14915e90f62ab563c2795226594e6bec2cc86fbf893fd5b9ba516b334a4235555098de8b94c19f9cfdfa3b3d6691cb01860d528542b25548cb056c020a0821fb83b606029853afedf746b629da1a137efea9b97b098b295023b28b6790abfadcb686cb675a9a2bd462235c40b2da2d2deb35a31787ac0c91e555a8c45543d585210653a15bdf4df9ae7776596834106e30d3956b6ed471a4471bc8517917aabc8c57127175d3a367b4978a9ec51517a149bb9a8ff572241fe6bb8b370be4fd2de1c505ffcbd71264b74e15928b85f074c391fd041522eac331afd80bcebaf5c4c32f122be019d012d490a7b2dbf0babb774fccfa80b498dd95df68db3a4ef338b39c48fc9984ca5f4d2ccc6fdc917dcc6bd580feae6fa2bf281ebe9f80ea7532d6c036be6559e65c46c21489888b6d2ac6d2fcb43e04dd5053cfa9c05b4eca8b8bb17a34f087deed97100520e6f71f5d15930b7631ef76cca508099973c8126b3c47d4b35fd7c70f2fbade01b11ef9786f2fac2819e2db3a72a04325be73b6686093bc2246531f19e2479813ae009890feac561d83a65c693aaf73e152e01842b7db61062619733516c4f97d288515f9c4322d024b620ee1722024956696b0cf03099f00233afe9d9490485b0789f7a9738d7888c971f7a69d322cc1b643333d94684e35bea05c2d2a9ca6e6ccce3dd69f86ca37ab13563eca780c5f742284df7c49893520c1d4ab361dce0f6ca4f748f5c90d849c8e8b78cf3abd963e10e0190fdda435745f4f73da35c80ba4302be75d758e1b89a730b8e3df598409e6792afcab44b9aa7b71df9fcf494ec7b7fe571b0ecdc38a8e198dc808e5f73fd7b591e5ed84a910950acf723e414ae6f5b94a0ab662f9389b5d63dbd0fd5b87b17c8a838d9ca6b50f8563bbdb1b8d8f0f8f6cc64f220434642e0dbea52ed5af8e453b8793a30936b3d3a6eea9edb46732c25f4d8342108dab011e319fea9a2ff9af7d43338298d87cd32d9f1e8597da85f2dd80293d2c0740445b6eafe069217c0a9b8d4668469170cbb205dec47ddc2aee51627b6dc752655468fbcddcc93ed071448871b2e7fd956b33c675e7b85e4252823d960197a05b70a2ee0cd992dfe90afb499414ee8d36bfff0154830cde5eea67b1d3456c43ed5f0ddf7d2374f69cc23d2d2130e50728a54b8103c4631739179d44af046e27962ca0af2c3f2ded2eb0147dc4438180ccdbf614da192bd2c061496cdd4ee3b264d236db5ba9e78a1d1162e567e875fe2c6e169411868facbfc07e5a26d3aaba2bf10cd308661ce807f8f9e5756a30d9d9da34f92faad611f97a4cc1773b05fbff73b38465e56e384c24c1349df5a7668e3ac67efcb3f6d3aef7857ab8364292108d6cff5f801fcc5cfcba43d9a7d4f43e7d2033b175cb32ebf65ead44d4ec615158ef4f6ca528e8b6dba068c9a5d98798921afb27f1fd9eb243d148cae59b13f308c12d087851c15fa2df82419353b4b5b0793d10f45a2a881a7304d83970f42ca69e9f820429ae7f3e569106e0f29d7d45e9b8f1dd5d863b9b93eb4af2c7f7117b02cddc179932b04e628d61807cff378993cae2359d3ce935a6c45998b8b0321121ca905f13121e18209ee93e6423278a2d4a3b0c3ccb8b169c27490048388514065c3de7d555f0caa31ae3b3e354ca34225773200da0655d2a323487f47aeb8e1db97474a8c0fb8cbcc786f8452fc1ce7b0b1f1e496085fefc8c6b268dee6895752ae10c5c1bb0c9ba55bc24f0f0b81408955ba14ad8fee3b403e534b0161feef5915ff6e79e56925fb588c64628ea4f4bd462609a61ce42148314e86d4db9b2a97f8835afc6969ac8c24add7f3c24a695f323305717bf22f31a10892bd9ee823760e69e073a0a9fe361ab49bf690eaea3e01597f00cd99ec0de5c38eddd7a7bd1c6d341bcb575692a4bb17ad92d20376b77a7ed545e7b04f2977c29de6bb78f12f5bd764463b24ee6f9f2b3ae965962a2a429da89b9cbcbdb336009ee892db4f72638ba0ea7c44846235caf9a563c85c466776336243e5923c268bab7249e6cdde1cbae2d735112ebb94cff1c7d00dc8bf92d97ba4de82924c85cae09caf634f6523add3afaa1791affbbcfc05ddbd034515511dc097526243dcd1aea7e363623696d1c62ed30ec9d81adeb52cb8822c7d2d2b5b3d6211cf0df58303978e16ecd6f327e02ae5865b34e3059d20de3ef6e8fa8bd3928910cf4455545850aeaf0acda13273e4c96c8ed412fba725b7809d855941fb8a2fd2706599b5b11d0d65746659013bb77fcba900cd46af4317d23368f89b89550eb71ad8ac60e7f15c624cc9a123d10f6ce9c63c4a43202eddb1bd3bb901884392051fe7a30f78b8184a622b5e64d6a342d46f8f01a124e83c0c89aefdce5cdc02b3685de563dc838a938fa776eba1c7921602a8f5ab7ee431d2b62803163a7819e5a9b7e95df6e82133a5b01a34a02e4f9c6a6b29c846c3acfab710518fab4d53ce4a71e9cefc7224bf8cf37671f33ee14e634bb702c807bbbd47c2bb4f591f148fbe37b88b831b249dcd77aacb419c4d7632893d5543a672440dbfaca0fb3c896c37bf0a619391942bef23fc1f475e2d4571998889eb03ee5e292c4ac1fe10de533eb8eabee6924214d441ed2e341ab17a53d7434bd93bf06b44b257e7d2907a9f0be24d3aee90b29c1d3b1323185be8124338d2c727f8a8d612594a8c90c744fe2bbc54be854d4e039a2c313b0867f315669b8a5b1fd47d65b1d4295ee6a717330fb9555772cac816637bf0e691166d83566f797b80a4937d74b81863f001d14c9bbce8b16d16134ef70e45bd699c5b79d623a2b16891ed828b9fa90f87606469b93ca95e8cc1b11c0933a9369e39488657be8d9c361d05e8cc35485a18e082373b1f3c77fa946088658b461187a19aeb34c837f74f90986ae37419b3dfd2f00204765f10343c3c51fd47272973cdb90b27b766f0d90b4a0b168ffc89a46f80291361688e4d872912eb4689397e6b371a43d7d19dc35c4a3610488593e0087335cc9982414fb29fc4f05045225570925fef84148e44409bb7fe3cbc3c345b6ab9cb0957dcee81a59fa7077f6f15dfd0cfc7013844424eebdcbd4471c37f0c0675563383662b327902b0d281f340470f9403bc7e03ba6986ba8c04c0b55ef8f8716fdf56d65ae7c51dde2a47fc6e52b195bc60f3eaa15a758dede7586737bddef5368e4a445a9844e7966e65f8546e02058b1ec54105eaf3a3634b23123418a970bbea298e44c76f40c8174de3a17964bc533d841dadd36d9dc343159fc3fb400ff59141e949449bd122bf69cbfc981093a598b81c0f2219dcb84d6094337518f99346c29b6c8a165ec48f8b875b23dd4cb5b9d8c713471f269cdbd863d3f4cf85c5bcd7efaaf5ec3f1276f2e59a27f0dbb696867808ca129811ecb3e5cded287396b919a79805f0494a599df85fde84a57f277e787d40e935e6f1ade4fe9c4478059eef42d08cd245c9f1feae32f63bb8af004820c7baa4140e1bcec4d8cdfa244026ad5826827bc1c68c0fd54387204c4fad968cadbd021be1ee51947c76091b53fa5dc09cf98373528dc1ebfb4b6e286889767e77e7b100c37cb8dbbe9afae0f377276e61cd1604c3f0a3faf2aca6dfbb1637073a9d62ba5866ad9e3738418ffa88be824e9b6668a92fcb7a42d2e56e8b66918d2ae79a513f6500f125858a49aa2e4a8b36739b35fcfcb8b4d6bec90be66693f2baffa7b4aeef2a6d80c2d0474378013b02cb222ee0009ec605af2f3bade1ba3e49ffe89e2eb5de921eff6c75127f463d3bf04f003d3176a43bc16930a724ddea52b5e8458a9cabf2be126e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
