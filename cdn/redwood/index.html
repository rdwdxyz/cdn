<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a5bc9a83c7642f5137faf0976aaa033fea07a115d154678d9e725984864ce9c900624e3ce4bc91a81caec21da39652b0a4fdb6789d1af6efdb739dd7dc50ce5c9a0bddfbb1147d5766c1b48110151fb2da1d409dc6ea41fd6bdb0cfc8bfd9b3ea11e76055bfd7b673c4ba69d004e761932399b01d50d0c9502a8f84ea45fa6d149b55a5d8254d11cd9f20b126cf556587818ee52bf4bb47713c9aa940f2184011f1f15a4ab791fb2ee02314ed4fe6e0e5d0a52f532bbf8d132065223b4e7df06a2f71c6e6a69e2d628f110d99222070c24f510e7df9a107564ac5b819c5682e1a82f5a0eb73755bf8df31de18b905c4d564c85cb7b794a990a53137b3193483cf824afa12a6626ab1fb17d7c874eaf8ca916e0e356515bb7d6c482f1956fb7df4f466174113de465b046af76d531b39efc6de6531ebeae1a70fea6899f08c34fc5ba9834709a585822c49a4ca5fd838367d214edac732db43a6a24d443ee1d9a47f6a9da9fc5ffb22b19aa7e6f44a5b8b9df9bd5b7e7d8e760ce784b69a516336a24a11131d237eeeb7566497c2bc631e38e4161043265dcf548378ad3fa768f2865d4349f7a401c0239bf97c7051e6a398cd0dba9f467777c4564843a209f8f70db3dac4e1f3b773a834bd6da19ecb6b548e16d0fbe3c62f4f17eaaa4f8ac1afef653ea7825a940a4645961739ab6bc7f062f0d05deace72c813abffbd542da2a11b3bcebcd404449dc8a9a61608297dfcd342441b52511920cf42d98193cd3b0507855a1729c72f8cd31a2eb8e96531b35e8330e2ae6700099ad735cc26dcb8a0bead32415ba010f8b571a3f9da7d748a27755bc38b0738c3a8b4c64f1e43c2cff20e102eed68a5baa979cb875e95c93bbffb397d6b99a1f6beb330e29a1823bb9b5a0e4c8f8c81f70af53373244c0c2643d4ac10068f8dd196fa958ec686ee3782b183c6615da2b7f3cf4cf03421eac7f9451ed3047566ca686924c5d41a14785ca56a6547cc6856423a3ee7421b1159a659670a65bef82125c1fea33a256b62290d33beba0bd80a275b0cea6dbc37765d07b92b68be1aaee57cf10668a2199d041b7dbb04f39dcff0506b80afcd27ebd6aaa5d62970faade3b4c962941db6ba1f84f51f80d4c59ef5ed863a62968b130ca1a8e4a0182af983dc003ef2adc1f48746d0bfde89d2a52b5f45be08e26984888fb1a629e7258c8c6b8e3e29eee234941556f443a314fbb3153058fb5ae349aed7a03e9bd0da2affea469b2285d2262b82aa342e6e6e6ed71c0179fe47b118f9a3716536b13066fc4c5ca6293df585c449a3e5eae40e2ddb19b3709e3696bce5b21ebfe4c855f218016651debe29372e609acfd64481c53b13405b83ea863053c2bd1feb33ba3e86cd344b8ef432fcc0add25857c3ce93affe487977dd37bacd378f5c772065ac8b8d4b0b98516a0177eb947e9ea4e332b889cd14331fda471bf5511dbd0e810c122a8671a682add038c465ac40f7e80fa812a675e5cabc54bfa6b9036ba854efb540718bd33e47f96e42c57ca9700ec7933a9fbe9edcb37cbbd22b6a718887f53b0db20ab75843e3710c62cd7e89d840a1245d5b7bb0594dbe53c916b3be3e0d473c9828114f07c2a22a5e9c61d7fe1686d7cb76a1d4b4e87234201e87402155dbbf53f373f0a21498839177afba0db101c882fdd553fef14a38e49152ae151dc96963b06f86939818119cc3d7a6a4959c656218726ed57ba2483eb1bfc5264ec666f3aa986941158192d9260233bec93ba3162073d2232c5ceb5c3d8310b556a84b5dbbfd824708365fb51db2317ec3a4bbae7667aac5db360406df16a3d2951568210dbace160f51548b6285ab3e7727b54e5af9ab4fc59c2091e5a6b99ea440d1c301981e4c4da87096c9eb8fcfc942ea03708ac54bd91703cb385b34f487f189b2c035868bcb2a4ef312dace8f6ae70cda70e3ab73b36522d71b9d3890cd9f8a0ce88549e031bbc12c2054160d0a0c1ed738ee84c1db4cf83d6ff1880c98d3494b11382278dfbc558e20eabd31245fcbe18b64f444cd004cf8657b5410f887469402c8cdce532749076814162a66f9293b508cddd2b96246f18b175dc2a99e0a2cc58a0ae414fe5afd7c65b072aa4bf9929806673043c00da391a2d45470f14218c14856cf8c1cee4192ec4d5c88a234d21d5e51e981738a62f90fc9daf3041eb5ef801a02f2a6bb896016738ec5024dba5b12d53d4419f39b4093743804876bf0c6aad9d176355020d68cef709cc28d0cc0cb909cde6646dde966499e212a9eeb921aa555e5e4797ecd8786ab0ea2c38986615f1170ee12f66af7728811d4d49f12b5b1c193ff09db6eea32ec44da949a2c6a33c1becc45ac2cc3deba018b1a85b974f3ccbc5351086816ef9ff796c724bad2888808863a90c19c5060f17d7375079dbe87c50e97e40209440bf6edfcc7146db3dba60df478478e4925f8a31f47b5186355fdb00537e961aea9d72c5441dd409cc798ea2bff6e34d9c061a231efea21f73eb6d5dff79813914643d55346b33a8720331f7720718ac54686b8e598b1b8509f3c49bb2f5979bdcdd0e7107153421321ab7ad1587aef03038f11b049c78689e0eaf46a89892d0be33f565870bfd85eca629af79c3a17e12904024452dad7d96656d88b54e6a759bf5ea3b9cddd6d0622e93b575d9e94b5ac762a80a448e1e5f0dd73fbe4711aa5068306cdbc02cffccf9469e0be01792b57071b1481ab581abfdaa368d18f70c71ef52da75f0c2ac537b9cdab5d9af51d88e3b7cc5b714006c83f744a60b8b088921496002c80a5c6996c77cd5c84f3c41bb223396eb0ab50196cd823dcaf9a637ec2058a2c8b7b10b80270c2759b1ae46a1cf713b844240ea81a080b35f7929c5be85a15bd2b5429e03a23f0a97cb87cb8b0ca8b398c0d85333678f293dee83600ad19df56857dfdf8acfcaea59d267e5afb1c379d84067c8a9bdf2660983de1d0730df66669170ff721f555b272e5a5a1ab337a690adb1cfb70ec648949d88e46fedad9c1e24e21552907e587f7b391127dd70a939f5b236ae606ec06d4c5ea08a626ea882ccb48a250987a7da957b9f42d0be1b7f23a18ae77bf1d4880f01782913fb986f7a046d4749dfabd423e802a45b08ea41a1e8e267089d2f7509430b354420f2e60021faf1400a7c6e35c3a9804abcc563cac0079d6e4e3edc5a3ea1aea1f5e1bb65a0e705d3f6fa22ddeaee8e4ebb9994da0058b01957da011c50f77c2b460966947993e6d5fde37c87c04197be18dab7e11e16bb050b041a97534b30325db1a36b19d0a29f75aff0ebc25783e8010393b77eacdf943dc505d8a1000f6a8e964b3d4d71c289480367ed56cd1f9bde9413729eadcbc5f7ded7944f66c3c1cf67581ffacdd7dad82b6e5494609df546334906d2ea5d00c5439277cbf0746642fbf325d2c6cfe25a2a015b2f5b1c08aba1b977ebb79db0c5ceb045c3d6fc7ac7ad3e2fa4134ee957ab447cab263f1ee0d88dbf401ed5db510dca8947275ee267dc0d1925b82dcc146217bdff53c22677f8371cdcdd503a11c777a117f1e2929b8da9d0174acdf7fe4ff0a85e20fae7c1b73b5b3f55bb8743e6398af6c62d30f6952bcefebecc65eb927f38c4c3ddc685e7ebd390e811b984a228369456e5619a3ad1bae8964eb9fa9c1052c629840f35a45b5540a55a14d3271417ed965dc214138566c273b24dd9cc5828fb255a7c842ddca5c7de0982d3faf217fba6db0252f48888277c61cb1a3991254ae72572e514801f5ccdf2269cfb2e1a74c4f565dbb30d6a3c13e0f9ec5c46760a620dd85e740d2794f855ee8d6651dcb880621283a97b5c231274d117d4cfc567037a941970181e5c6aa07a8618a14190eefe9c863a9de2d1a61b9e9b1c6b5252d5f81a7e20a0e286e050829a404bb1880cfa3458bb8846e1d35ed8654ec8cd2ec6b9e76886d70ebbe0df1ed26aaf0cdd14aa4ec11323a81bceb5eb3de7035a65c0a44bed0b523a3f3afa5f63abd865531e2be2065c755c56f43341a502c863d36f83530d1b2a3740623db61ecc7191def42f1b0d122fbfc220f288b5bcca3ad4f1ab1309fe34517814bb17f1027df15e31ccb42d84cc65df00a892e3d673bad30cbdbe75aac1273b6709c10c3b5ec8790dae368eba03fa3351631b571681933ef9ab00f618fb318a35edc04facfd34e8079b4ed574e0c976a0e93170a06e3ccfdfb33f651d651e5edd91f6da6930ac8c0400962ed7258aab71fd19c3cde65ec40e35fd7b98f8965b70a796d7c71d4c7128a9615302930ed53a22cf7423d3a28f0014a7816c23321b5b7f88665898417f86d21567d1eac817bfecf3b1070543ffb342a0685a76199a0a79b466c99cf2ba357cecdad365e3fe41012531f0a0d8d42e2450b6e383ed407e3c1fe20ed9bc86453861e27e78866a01d340ce545a77b4f94eea5597e401e2e547ee63eeb3170b9154977db70fd89bf56109121f1acdedf550ea4c0473e5e80406828b8f5a6c498edc006ad970883093235533499753f0a8de6d12e2ccd845fedf6299faecfb850765fb3a2d6bd1b5653a565817404f44d67c81d52df213b618c7d20ee850b1659af8c22f5a8748821dd9acc339fe4d4560adbf334be68f434f3a2de1d2bdd2f1328f1aed495d3aba582a55b61beed5fb0d3fea115e9cd40b515ec773ffaab39e8458a9442b4c3f896503c23511809458f2d9a2335fab287f28e83b942f55cf4ef1952d051861a19e9f1e4ff772786cc7db396ca4f0f1590a6afdbf51324896d9443e932c162b6b63f4223d1063a357cff6c2007560b1e70f3218c7e21b7b5f29df6a34692cdcb522205e4606dabfefa635ba4898779dd5fcc3b6de39e3f1a2d9ed8589a8695ffa22eeb03f16aa8578e01e7e47a031524fcbf1d4f85264ef69b457cd1da50931420f9c236e96ae7d2e8e6467a0fbaeaf46a8715fa4b6740423a15bb83081c2a6b155249431662775c2d5098e272b0c0e33e46a1a8db0c418bd5baab68cf77577e477dd011b6454dffa5b6900961027522f7f51176463568a924984dacd601bf831b1894f5e6f8c692e044964e28f083ee6b6b94a2bde70989acef20c27349dbaddef4c6ca90e2047566fe0e4ea466350a963619f97d92c9bf06cb4af5017e2c037b820b597eb58844f5fe185bbbfcceb0d4ad136083f59ef0277ab1f85ba01a84d996a90ccf04a8dc6da5caf06418e1e03381b06495c08f56eea5dccf711ab0f69bac51adab724f8e2fbbce2c34c2e509e572e198dbe1603c7025ee9478dc5bf95b6e008d313a88acc3892f280981544c5b0f75a8f547aaf5ade24e86d1bd60e597324ee0ab2bf7d20703cde5e678c151b6cdd3ba1210ac5db6de53fbf867c4a47357190f0869873d1c5e7009881965773480eb1ea338e37b56f23f21cc8e351690f954d2663861a963d696f2528797cb421235f3ddafcbb102814863fc2e218dc6b8340c5a468a969bbc8b8f38914697b38bf1e65303f7d5fcac0fe20ca42be6b937e55af32ea554e3bc8c016573b1dbce84520bbf0185d47464ba2d0de5fde816bdfcfefa39d9dacf26ae916fe0c4c356a6e20d39abd2cd98994f9c522cbc7e847cb109d88cb88fe9ff10ca2a6fe6e508277f9a10ba943153db133c7f7f898e2f3e06a972603b316834ba4e2165e9bcac35124dc22cf3757c2ed9fb56712ac73d8a832c513e2cd8cfcd5924f11ce99ee50d447b77b21d6b577ac2d2553e2fbcbc8ea246abf41241bebf318b649158c7b022ce1a208a49c6494a92a18d95879a018980886b4cc87933c3c5e63fa4e51b5d1674b293238df21f8b3309d549ca4b9becbecf9ab81952bcc63a560520772ef491e34e196af83e422e6031426fef9598d179aed6520dff80b4428cc36fee4cde6e5cce7491ac6eb443c1ca9dce7de964cb33b2eea13a1c33c0052fd919642ada7bf2e9ae0fd648177f9593fb60cbddf4ac0e7bfc4b2fd7b9e469a80660f12e2d8e68d32ff91390c068241c33e5fc3ad9e225d7b7228497e48985873db2e8e9810a0cf6c942da0da9e799a0d776039c3a1b33eb48f73c75068c8397a247de6aa40363b2afbcc90f267c462ed1e266e88481d72daf805a0c31b88ed10e7818db77a37d6ee20d3f15c95e970bf63345b732415f84dc0c58c53127feb70cc03d2431bb073b4e91e3b53c2a2e09deabf5543392e1528b0e49f196566f8a5f1fc7a850d618b0217bdf87666bc24ec736d5c56055a320dfbc920265469f824da8e1a31acb9559e2e48a58fe96532134147a861b11fa747479f1b151bee7b3d7364c7764476dfa742c400cb00827297f89abbe264aa115860d9cb44c106dd5cf13c41d6c97b5287e5a414179b1d2a87606ab020245ca14f25fbf7106345bfbbb821ce030b6b027c8600af10ba2e094d7bb9fb5e1cb03d3187f28f248d00488f444b76c5289ed883b4bf67e692dcf23357b4b7973382b28f3e364162c8c09e3b9d4dce4072654a27e9a0ee28953378d70e2e8a54123c1a7374e73a2b0a9030feedd37a84a3432cb9025de1cb338b4a49df7741cfd5326f7bdc0d0c84adedb69731fafcd01c2f1851c32ecfbe4b509cd40e352609dface1552add12c01e6637092f43beb8b154805889586b4935652f5749215c5be84cef659f4d6bb80c10aa4e3818ed038b821acb47d0dd2297eb27e836b86049669b192d3012bd45c9ccf2ef6f514388bddffb113a0cfd431734ce7385633b7a96629980f58cd59e1fff10f56f4a4f1533466413da9cb8957cf6488cf6154ba68a963e52816ce701f2c511fbc3937e82f4fee2ae5986cdb30b3aaef9c331fed3ad7b4a791a2ca99755fa9fe194152a233593744ed097ec25639b66d1a385204967d0af86c78ce9600c70eea162fa853b7a44a905432e6e71db2593e145ed31dc0b12d3c3c8b452475dd041a3a2cf57db699895a2650496f386e00924810c9143d01d81fda06b1ef72d6743d4181e0b0039b78cde7b6a7f0d1ed6b6a183b9412a32ef28c5946eb75cbb9d16ff4546475d401e51cdafec01750bad47e71ed2e07e17cd01b9fe87028c8db17e927fec496769acb5f06758146e651d6d0122f1d15228b06c287989358a354e5ddd84546dc3fea1fed1ef9d89e47a885e7e024ab499ab042dd64b650bb4615472f437225fd0d1d36123f130b5a54f2f5a60416819ee4e569322f737774f625ee78570481106185a7cd17f071e030261fa1b8f4a05167ea0571bdbd16d9e7434f94d63247dcf5c6ab4690f87812cf93220e8a077728bc59738a0cdb8b800db705d7560a3fb31d4df70e6bd23842a7de0a5a3bae0f7f3315f3a52c697e9081453986f84e02f382975d8326b53cf2010d24e77adeb4b126033ef98495922d744175c930c1e4fac912e0eae1dec63c128beb8422f50972160d720ee5a69f5ea638cf3994c66721428ed1e13b3a6144d19244c02d801b5727495d797d880c2b4f0a8dcdc1cd301f0be89c0c1a7ccff6cc8f3eb8faf01a5b9dc944b915fbcbb5e328344b7ce5cbce62e45bafff8287b2f1a6a2e6aee4e6bd85c622765e3a432c466f2b12e2d5c9109915776b5bf6aaa72e26fdc3f8a60b2a82af0c89b4196944adef01b951e2b530856d63f10fce288d07a288bda5919a9644d9bdc677ae1f88f0fd986804dc779448249aa8994b4b1467dc95df5f12b212262b478e8114044815273cf2156dd6f7053fae888bd2a2e913f63b58b4eae2436950dcc1c93aa052dce6b01a8e73e35d288e5999b798403609d121de44e8aea463a04b1113f4d2517f1c1b22c4cb06aded8dfa151ff5f214de11e3365906667ce50b149baf0e29b426fb766659f38f61aa70f9f04e4a57fb7a8d0e2ec465d1162c30545019333843ac8f09f57d3df3cf5f275acf74f70b1e6806e2396192b91fb3178c39b03614e82e4f761f89f23c25a4d34c8a1d68388c956e52652dff83d5856a5afb101bb7bc1fb90c7da5fa7ffe3f21cda46abfa38e37a01d84115999ffb7794c8b3ad256f15d0463c72f4512173098bb3c8ca037ffe70715e59204f049dbded7c1d00700f011de17dfc7ab6baa123e211d678a50ce26c79ceeff69d1d7c7bf965bd0c6f3fddf85c57c2ccbb55d204723c143076c1928e060a5098fef8394f1a9cb78b0e9cd80246a550822cce7e35bb9d2d822f68c83e4767ac5b953c101267d9d3a55e6d1d0e999a1f357cc89e775569f02a6999d1edb544523f5e844d2f10a1c9529d70291232356a2bbb48dc3f35c28b0f5b488f55f2dc05c76045a6a7c1ceb68a714a1ed31ec678ffebc1a741da1abfc4b5d1fc27a608f5976045b9b02f5ceefd9b14acc38bf2e4df7dfcda56505ab547fc9a8dbc3c00dd05b513de12be241406a7dbb4b214a0fc961e6fa3578910aba5ae774381e602109b5258fb43143196710f770f8e36699ca41f9126f5281f7a8d38ff39c37266988abf08da2710c5f64fc67fa9bc88d26ef2fdca272c598f6725970b828fbe25d559530a86c3692d31b84e38d3f0e282b6b4e30ae3142067be380aa421eade74e04d7d8b3898ad5650f6cbb74e62cb47a9ceea7c517411a5af1da630c7d8dca2cc29fc1dc7a34ad453d51816dfccbefaaf00056e3df173a713efa8bf452cc7ea6a8f29460acc319afab3be491976e2027445d4a2b8964f78af1f53b713ead47dd71627c3cebefc22b20654889e8c6e4d860a5043d57557cff0dd9d030ef58c4b77ee4f96d14b2c2254fea8df88e7c6c61e2f6b278790335bbc4d796218cfccdabb5b5533f49e1a2c377e9006f2ffbd3b6bf05f50cc9184ebe9f2584add668668a13fcbbe061848113bebd08880a2bb39dca41ea593135727c24315e452ecfc84de5bd4516819ade4863bf75bb9706c4d1630e0023e4e4094cbd00ad5ff0617e147827754cc79ab7a68c9acd78d7eb1373543112fca85f920ae35218a3d76fb9b1a7ed15643117a60b5477e62c069360447244e7c1e969fcd318260e2682e4971df79106cb399f1e60c768e26531cf82f42f0a953b005b6018b462eb702c0d80c4bc2665410ef69bc4aad83023230a9e576de4f71b3849095203346f18a6e26a43045764badc01355617e6dd4627c095884c04c8845d5d7e588354606ef4bbdb81ac0f8e433142ac04bcb4dfd496563817ec03a78fb8104beecb868532df54c4725a1e7e0b0e19ffd25d51d38697b079911d3f6bded74083f91094f3382b5b04722fcd59660abc0a7844b5debd65ed55e4e82b9883464e91d34556f413fb177f6c079bc6036ed60961dc77c8cf6aebb1aeae7c870161566f3d799e9bd26f56bd5041c71e56a6be3c84cb93fb73e5b0ffc8c105fe6f04284d4eb55308213a76ff1270c9c522db18f22f2bb7ca178bad962f7329a3c47e952360685f5e053250e63f955ebbc20c0a531a0e19b726fd6b212502b51bedae435d002cfa139e769540cf1343d71c2ad62156c509840da62def9e7491ffd62d7eab2b97fefd2700cd635b530cbfe221cfe5929ffead81bf827fdda7c1d6a521f25dad0cf03131cc6e7ceb8d8d4ba6c3759731fb20e6b6498ce35742a1049ba7b70e5b14466aec3f047305b98d386f9e1e174c4b4818f7a262f71d913675d5b6ce4e3ad43879c9aa685b078ad0cf200f8642592f50d9ca09ed45e02fbc1a6bae15d1a8be2bd450a38f755663979eae837f175a04826ba3af6b75b44fa309ffcdd491525b62a759bd1709ae2197b580244b18363ab45f87aad5ee051f92903264ce3d39a22fb269745711ccf25149692e2346ca042323a5f04015b8665c0a9ddb3f1b6318a77ac4a8c5f0e071502d506efe156bfc79ccb4f6465f383913a8e9e4e0178731bc0f1a963854bfaa2834efa4714c0ac3aca9f9f10fe3a3a3e3c5771a5cb5e36bb01124f4f200a5341c7e344f7e876c1eb56997abe4c1b065a2d2c058b8e818505a40fc0c5e14f371ae7048fcf82e15bb1cb5d84bd04f7b021382493f6e4f8f32b49b89c881381bf115bc7a288aad989b16cd1eec04b2cc2b628816253408367a8d99b812eb296bcab6bb8a1e7a1f20c0112d66c41636cb37166056e7cbca755952f8eae9cc1737557734d064e801a5968368dd094877a42c9db10eb3b71aedb925c2a8b4f77520266628e43a71553e66d2b8a6a80f69e9164f0f28cfca70a5c186555aaef2c05ddd7e4ff8e462e3aaba0d24f2ccdcc49893e25f4188ce9e24ab57c29df82704df375911ecd5ac6af43ea530fd135309a9ea394ac7b1f122c1cae92298bb1df2f89049111e6e466144636367a2125acd989870f674a1f5633a482f08e806a922b55024732a286a257a5e828ed2b3169a62fc04ac184ea485697f3976a2fb97643aeda13f747c4eb6a2be8c1e294e919d6746d3b28a00659dc477cb21696e296bd990b309f89bb1424e0cb3dd746cb9f7b701c2272384178440668a762a23c2f96f53ce85104f4054b8a6fd7d26b68ecb99a3d96ec64aa324efab79610588c168f8781bb35c139a397430da4b17935cccc2649fc77d351b2650aa09f824ff4bcbb04b8547f26bc51632d917edfa727b15bc84d8e511fd6f3c27d0b6154c3a84752593f357c18b81d6ca194d1a4a1aaf965ea9c1fcc7e6787706a981e23f15eee5451a1268d78b1efa1a44c62b24846a25da0dd82a5dd4cb7dbe7d7ff9bfee8dc67ca8fa77ce21044a930e500d3c5664508695828113d9f49da223d50114541f174e3010bf65bb1681eb4f25be516104f5797d409cf0319b7b80a02aec171a626fb8d125ade46ae6824d09c8f97601cd691ff35d5150c2f4dd5f1e4269874aed17ab6945c0dd0ec3e98f869632deb26f7d443e45e03c229284e095d14a787f8f29b9929111d294b5cef3a3d0b707f80fd82e32877fb71168a22073bd6fda8b2c1231fb60eaed243ce15091838272a5cb50b0067a7fed04da70aefcce20202e2e9a1fb8f3aae0f25f5270ccb30700673e1da85a8e86339adee9ca817b41d8108cf980907c1b8f8862878807595a919609ee54ac84962b6b11d80db49ffa0182d08a7710752047e386e597219d503565ab10820a9f6eac4bdf01d6aed58610adbd5ea15006e0214cacae6d3dd66f3ba6cb63ef074d5145ee10e0c64bb0b2e0e7081dd524d1f3e3b5c99cb7180b27a52c6cce802736124f0f4c221f29196474d441d91049e9cea7b96ca8020d7cb2afd82e00e8bc81a638b56d9b17898e02e2d29a1e873961817802439d48552979076fbc592ae965a02199eb8611932378e2aa8f7a77acb9fb1c44526961fdf1e136a9606b4eeb4acbab027d1550830aeabad2ef3feb33759cc09c2b9cd97d67816171c3b0c59649d19771698771035546f10e24c408fe14f69c4941bb39e8f74593abe7c892f65e3c5f811813720462e75078832a8e4326d27e161b6a8ee5c2ebfbf547af01fe8fa661dceaf915b8fd498e0e3c39486006387f89cc6abaabb92d11fbd8bb1028d3ee68d7450cffc8a6ac3b66a6694a93fc15eb8e298572cf85875ac469382be509252e1e4e39ce046b48060d617418b0830ee87c6eeb8b4c00950988d131de07093ed0a849e895c1bf539c3ccc1ea1452b11bcd435b4b43ca76ee1e6cdb3c2d1b2ee7e9846dda57a5e628e2879d2cead9ee5432793b88f8840aad64b05df5ac409040e91901f8c2890b4f9c7d217d30f46e3b98ff941109affb100710c50b9364094b0eb9671315b55a827400f1aeb3b06197553bd7effaf722c271113f94e528a7dfd637cdd44e6d302cfa1a3224024e700bb4368ae2575612d37a284d0e047e717e39c87b137588f0deebc245bdfd6c5304202fcbe6730c832a4e3de70efd9537042c86ad53a707764b4c038f88e388f942fc57ad18de0658828e1dcaff7c1a500e455625292f9744cb8417487596a67edc4f8ec86397cb182c54675da484d464cdd545800fd9a0de8db20352feadf9cab6896e9fc6eefa0cd75c5f076ea40dc26a5965a608c3b5da785a31755a373329823a909674a4269f4ded5c8b0b857b0ae2e07095fce0bcc61cc57c892b6aedfecb8541265a643dc585de10dd30b47657040b392e8aa6cbf0c1c27fca3e60f6da3d75f944aae4c4fb02b4f0fa116d3801476975de4ff969c06e1014cc2da7e2769db03dfdd913ac4a04da08bd28bc950355bb8fd538ef15e445ff3a8c2e768103b5220f586220b946c6c007fe90a023bec36bad580f990d58a9f56788c218605fb61d28c43e31abdec20162c03c47393d3b3e249155fdbf5d1d0da1202744ec44f7807fbff840fe1adc4412aadd9ad74877677c6ecf2d44fcffb993c50d0ab1862019e14b2b46f889104740be6b2ebeea849bfaa23629faf1af532de2b483fdb8de6fbb7af1c531cb42464ab71bc06ec7e1a41204276ef53aa39ddba50584940becccd7d3c00c6c35e2ca3b64c6c8cd2336e89ce87f02e80e1483061dc0bf2c1df245fa716f8a59e1cffa0bf9dd6e808d1cae115e15ee7bec46992ca01126cdf0e567dc16e5930985dfbe3d7e5bd4be4ea0514ef5c5349254022060d2702026828f8a3cb9b83057a4370ec9ecf7e5918317c2b2fe534c33241b83c171ace4b21f10f3e4edd0b502bd67e804dcacbf4d8a13cd277cc726dc063b63a67b1dd181fdc8369e79435cbd3cdac28c3c61506debbbfc612eada0cad466bf2c9d3917cfa0f45365a4766899bd1e8a7b4bd364457d5beffef725b5c23264a07a085f6dccf2b2eff33ddbf2e960a6047767c810044b7169fd8e4c7c04f0a4036a066f5aa671d923b9149bc732285ec18e1f7a42113ca06389964460fc508c2fadc20dd5fc42604762118eb70b47b7919d7ccc4a4d0b5ea6be97de808eebeb995b0af37abfed28607b7cabe57a135ff68e44cad28776231e8387c1c236622d2d851669d63e2f5632b77a1b789a8de9da086130fd1019a92a850cd79631981d54d17a93a2dfa0a0d07e78128b9b08a36527e7bf8d73c9d8635f7e614f0c4ddb8170068526c7b0f78d00cbc51a3be0aa8ae2fab99578710afd31e03ba08a9b59bcc532559ac86d2599f74f22c328aeefb325624598079ddfc5f9061876863244fca6523293ecc644c7bd6114816237cc05c5c90af214ea9a380d6ae06f41305f419638e9caa890c8e80f2dfd96cc72de4c8fcbed46ba7abd0158c8a43310c5771325b3c8e0dc7fb29b289bb787b307c70d06d2c60093d38c12797256da9a0a956ccd7186dfcc9cdfc4e3fe1302ea3eeff3bed534342d58ea8efdd7bbe5e92c8ca28353ffe585f0fa82a1d7455962ea9e5bd3080fd24777a65ddea4592261fc070cad52088c145e31330bea55d2c090905640de0a077ba82379a0c0bba31b93e37e54a2dc3fbbe95150b89d3eb7b79fac08de058111fd6611cc5a5a1b35a1660ef322d0878beaa500c9bfad1a5946cc067df111b547f427eced971737dea6c1bddf870100bc903b2fbd3efe3f0a514dbfc0414538fed688fc822b20284a9f20e0baa15e2cef376a6b7abfd1f872bd05a2b7e7e4f18305c12d9dddaa322b8f99e4b3c7bab7b4f66471bc36e0d04169bd420ec916652974eeb17b20b57ce03d6062a9d3eb6cb3f7361e815e4f089550ca491a07b3127a0449d5663de095ba6ea2a7b5cd4463bd6dc210b1aa779422dbef3d2d3bc0cafcb51ebafdc0b0bbe97685a40e92af5186600593a8a81fb9b63f659ffc830ec8e0d4911f561da5093e6b0ff2c7ed6304b07a91c564250005fe1e07c236ec0c893a3a1434dccf35c16e58836f384533a8bfa65b614646cf3856bb85f27cac8014a46ef1728507d1dac1309965427e7f5762ad9ebfeb607dcd3c955c9efa7df0b532556f27a3c5ed6e570734956fe68425b2df3be99be1056a5b60609aca7070708a95cc015b18d94b1a76ad8a9515cc37e6669c903e5b0e5c7a396832dc0878df6ddc3655b9af823ed60ddf223912e32d7d80c6ee4b07f85ed906a4ceee49239ec8a590df35ea987e5193364b58c318c24b4970b11c7824b969902c88e98a1fcd4ff82aa6c5e4367a93303d5261c6376edbc24d5a2e8575c04bce2e6ef591647ad0c0e521cf21a20c268c32ae23aac893fa4dffe1b1cc43946c59fb5745b7252345494ab66abe3d3bd3341a38aafd7c4614d7162ca19f0a583c6fa018b6756e813c7f7d81bcdbf76e7c2fd94db1a19f2558260ca713c592b51e0f126de760ee3524a2dfa034c6034312a137c6b5aafc896578231c24980d7c048db9eb48cbc631bd5bcdb2ddeb559b87fb9bc1af8fc164ee54ed12118536610a1983364a5e61392040e0b62cf17890fc0f7e0f308d3fe3a5abb45c9fc26b57e21be4a16d03d609d5026e545e7bcae3147e1bf7be53744fbb798ed0c593e29dcae6981a6f08dcd7dcb1b8ec1e7b06dec3b74c5e1c8883c2e5bb26320401bde265b5b17efc661fb63c390595589d0dc2b486253ff6b2308319c2552445cdf7c08de6177df7163fcba7628b66f20e45c1c1496e79d654290e7d3a22d101bd58de76dceffa7373a16ada3b34931748d8595a9a5ed822a2d116c1928a2506314b9a09e997d7eca82e51a601d257bfbbf1874c18bbbf8603bd0e122a93181fcb6460f6ae1b3a979d32b486c8a7482a0d8201b45bbb8ff61f23b7ecbba131c4f144658fff5ab1098c14553f78303c9ff179271fb99273b5976f5a2e1a0b7b04922c298e337a6670da3378e64db66535bf7d51830ee2c278710b4350a229f7a9531f32ee382dc22ae4e2c439d2440f02f798f7bb11b0b891d77809892dfcc6ee199ce07d5e111ee0ee00b390cec0d6064218eb614de08dd12910b058d2a0dc32d6aaaa8e38196721da6383af904cd2216e95b98b53f6a12437a0ee981cc53a152ac42dd2a6d478cba31fb607b8a6452c30c236820cdfc01f5f70a18c6383974fc6e10a65065e8e94fab2fa17e68cbd257b8bb1367bde55b3f581534a275c23efe91ec75f90dc6869b138199d7555ec8c77a1091d232a6d4043f4c1580345c387cef096952a53e8db02194da7ad65a11d53f90c99ea506809ee6287a7ac212420afda18bbb9ff62ce22c0c5420d113a66fd7d9c13027dbff6b74ef582ec19fa858a978af3beafaadeb380400a15a8ade3261fc205eba078c300340df80eba34d0c537a6a034ab13d0f65e5043d9c0b49ebd760fc9d9aefa6155777bae046c3fa2f06c81bddb3578ece0b364476c56d0d13d49e47dd2acc6e45bd7d57e128723654ff4928d170738172b4aa488981e5feb6bb297b3ea6b30ec634042ab08eddc8a121e84dd1b062db6715588bb994e7f497fa3c1d95d66b7e1618400eeaf103d51f579e01a07ac82190d1731e7ccf08dba41bcfd237d1f4f7203a2ebb18a45cdbc7c2f5a49214e1d55b870ad051a404c97359673e3b6d4e0a6f249a3b35c1670348615f0ff59e766aff31b8706ae623ff541ede235c4b500cfbbd8e678923373cf733f5229ee7ee4b9d9f1d53eb9beef8381ec9e2dcf31f865107c0846d4e14964920809eecd7bdcb204294218bad26a947dfbdf298bbce74753d0a5b12a18ce9a1374b0b4e2bf237a069f28cb8e6d721566f5519e3904ab48877b9f08bc72492d04269869dc0b30cc0a2f371f2ec4d8de0d7da5f0b11b238a76b725dcfd51d2ba473c7ffa3778fc1fc4cfdd5eb236168b5d88631ee01838b370efb0c960fe07e226847ab19232bb820380171a177370b50ce64ecaba0d60df56c0b5ceb4298f20335a13ca67a870be4a32aaea60e9be235989e72897ff8c92677bc752b9d9c991dc7726b730188b8a1e8200ca20549ab2ce6eacf870a9565871afbe7db53afc1794ee6d99646c28bf14d4ed25fcc0332cd02e25458a1d9feb32fc1651db80830b35c9eaf908a154a3223b1ebd3f5facca2b3b91935c232e32994f55b721481dc8dc1d0a71db7b17b1f276030c87b22c26968380aed74585242a57e0ce6b1ba93df0c01519f16a6db69708e9b170b8a9e6856ff414b403e154ddcf6c58ba551229cf877e39e0be1110e8c463a2b7113c2a1ebba13cbfa5fc8cef8f3d675993f5d9908840f300fa769aee61909605fd4cc6407c787b94fd2f06462dbed8b3a89deb76ffcd7b740e9d304651a2e965945644f602bbf22488c87ab2e03e7047c4bbdc1d30f25ecd02a50be673f52e7b2dce12a6212042e32d18404671bce2ac5d1534c7f6ae506b4dfd10830eee6548a5757f0a0651d96fff3bfc1d5da810624e8d8d722556d6fb3fa421bed2c68e2ffd067c170ecb2a56b0ff46f907bfc0bc1f2033a6e38c2c7960a7c09051fc3679680cac27666d6f55c30a3f21a2217124d052eb9d18f937f90928fced17907924bbdc621b3f15c2b0b7d346b39725a14211a85a27dbd4cc03eb533836dae63edd055041b2ee5f39a027cb0b1e5bbeaf129e4874c85bc0963b82a4bcc8c9c77d9759a900a0e0cc674771a254d1398c97b435f5f80da4531bcb26901f35d0a5a3904b328b7b910e3d9c3194eb7487359d460a792425ff053a82cc86ed74054fbba122559ff35dbeab548edf5efd23bc6134907104418cef0376b9f6d7b741ce7bb64423fcd9313424ec26d348ca27ffae434cbf841942634e71ff3122de118b35bf7053c9c59bc24877ec5197074260466f4bec1a1de875d89652e5cdd2122754ed64f9dfd930dff8abfa241169ce4752aedd00fc5754133c70cf0e299a44b2f8fc0695e2b47430694f1735803aeaf18fcd2d5e4bcdfa96900c12167b5859dfefae15080b400315dfb60bbc4f442078a1cce9e5a22b6281281995bfbe6ff74a49dec70bd7c96648f9db75029d6c8d638f216347a75b8baf122b53013072346cc7f8599428c5638bfb4338c495f98eff9f926abc11f8146b023edd92eb8609e5beb13a03a94e853f690ff7d3b2270ebf3ee0ff0d5e81fa9716aa2374113cd765af6d38de9ff08439da5dbbd446ef973913080a378992e1d3570f353d632d87b05914edc0d29c7d0edd30324d76efea5a912e0ba82999b68c76dacff4264416ce86cd7f4137354bf1079dbdf97093f819aa03c967d5d1b475aecc3b5714002f591d506066083dcc997cd4b805cb000678a7696d0a39f0e98bfb6c2cda272710984888b6723469c2610976c85801d6fcd3d7464faf984afb0ef68006854c123ac37362072e968cd3c7d887808579414d826afa4be837723927b2dac612a3470e865adc162468f1fd81d55e11456dd639173d9882fd4b446f485865994fca8fa2a90a6d5741b7d4c9698b26c82d9f064884b71bb5605c9265bfc46e9f3bc6ff5d8e971b092bd5c95c2afa9cff1a794bcbb8a6a62aa81eee170006c5be7d7d1ebcac1f65d507baa9eab15734c447f38e3324b69238c5c8d15f2ae1d2b968179419ffbcfaf7da9bf1b1766b8490bfc5588abd5fde8783ea42cea9ce6ddf36b5048cd8c8411a96a032917c79932fa88dbd9df69be4b28cbaa1db61032ed96cae74602614d2a7e897d191f801c5dd949f58b14f248b008620b97faba53e134831ba92cfef38a899117484396d36d7095851b7b3c982aeacfa395e4f86e895adf825e380ed67ed39c09d35dd6adb21a29eb10ed1b29a9ef0e3ebaca38017d6e57f9a9005b0156be32177425f304811b6583550ee12585fa86649e0bbd7db1c6d5afee3db1c3cc3f655a51690bc959b9f1869d56065b5cc089d3a86aad8e58dda28758e8abb70658c85231dabde53a9a3d4895329f7cd5a2cdb7ab2cdb3257ed447aa647b0d70e3711f0939ea82974498df60e004af046204e09d8e6d63e65ab72fa48fa2b6ca60ea46bf959f936f944da9090ee66d281f6ed59278dbbe951b27fe57ead8a387d66ba3dc0f93dcf5c30f3d4651b5fc30ec359dda477cb096490ec4797db4ff10947c7c54c92b5255ae6dbd6c539acc1a45d665d373b94f92ec35c2171479acc027bd505fd554a15e6f72213b76b3a0ef22e9412a1649e0c89e84b71306b07b6e5fed91715902d8ff478762106c35eba7551fe6e488337b1c32ad6203bc5d17e9261fd1cad2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
