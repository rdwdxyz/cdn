<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fb2fb0313ffc2eb20cdd7303fee364491b06c12bfeb250c7a8428edc618fdf853406062638460c2b9e3da7a3e043b0a09a6248d9f32fd760d04a086893ca5c1f6eaf6a9a13413bca76dfa8ff2e8278c04ecbaef0f9d182168eb9bf9ae49b4d98f328337c295f64cb87886ec27c409f59800a034ca846dea2e16991909efd18a19e3f55481062f3e613a03502fdf4f05a3eeed7a9789df8eb8a3ee6b95ad9f009fbc08948743a29cf289d486a237c2bd70c871cf947c38412dc7c55b47a8a1cf982c98d2e1bd55eefca3dc0c9f8a1e768bfb7c189bd29ca3976f3fb8ccd113168d4572d612717dc3774e886bcd1545f5f88b8c13d7e48da74a9ba2fa22e3bb7031ea3d4283028f3a301de3d46c5ed9719ef2d0dcbc38b005d54ace8f4f190ea9ad195187a63f3c6ecdc9c45fdd3c6f353b444aeae182e70c9b9ee4010a1d79eb4a3592e90be2731c28b0511e8fe822f789aaf89cd9997e857168e44d3e08c0dbf44db7424178c32576e2e37c3a052f91dfc30d7c66aa28e2cdf39a8b34c12cc1d9332aacdd4b0d2ed96ddd4c14f1aae03f8b5876ae4f941825a0412cfe9a038a32e6c6262cf253eb05ab3e22afbb774c92b8776cd8337f3e978cb53a1ea506769582d960b8a6c5c77800a11f8c08fbf78998f277dd2c87d9f7cd567eff612b70ed4659e4843de4d03a4d199b1b512b35b38fa6d59f7cad6677eeddbc44b175f6f21fd02baea782fb170527c015dc585d43f338e2e0ccf946d72ce8a2b9c53305b564701486933207abe4209b92330723199b6a689c72e2114042be9423a194ccb253e4c19d9bcb0afd3e8e1c8f1a3459b79912492b203cb1d590886e311e6d53bfa9136b18edc421cfca33c5bda27f25ff575f4fb8d5281282ea7f7ca3d46189ab3945690ba9dc26870da65b6e23cbb705d7e25f3a3c01765f1cbf8cfe487f45a307dc631ecea02c7c4f8de3076050831e4e5d3d8bd2d06afc8003279529b43acdb6d89b101fbd886d88911a88e12c87861280bb70a640f9a0e8bfaf5927339b45fa886ac9e7587ec580b7459e883b929d5792fa6076aedfbbe14d4443d0c615cac7cde74e4d2007ca7d0cac38d35beaea156ed244dc0591223456917df56875ac79f550c2bb4bf7d24fcfb2ef73470a0d7787867ac68d43d09b06d69698abfcb9b9724d3f64960a38c6adbdf647e1170b0ac953441bd4db4c6028af1b589a5cf8f491cdb82dfa1ba4b0c832e61984279fd36be88c4ebd9277ca334f01834a8d65a396994b3ad3a230c1f05401e693585755f24ce7c73424ca7d1c0baa42d71798e7c75a7f09604ae7e6526064ccc725889178d2d106df8450fe0d070fb7ca4e83ed7b2fa99bc2f4817bbf6b258fe90e5d60d9605face3036ffcad336fcbb7d5b08e65eab4b5d4bc80735d00efc2c1ddca2c82659a531b3826a56fe9b7d3cd81b0052602221d38e7d20adaec2588a19885b25d33665f634e6d2c2b21cfa227bf0f134b55255fcc65606557e1a1e7b05eb48c77ec39327883541d792a30a36b2a846d2f0a8ecc59cbfbf05c1f54208e55b79d411880bc6118affddcfe1a390ee99bce91b417dc06457eb39934b427b96fe3d8ced9ddcac5a66f55378f383be28df9fe522af88ed7c23b011a6e47bf9e4e27301d562e1d49917a7fc0f9bfbbb52cc21ee898ae63ddaaf7350176b2950c45921b14457f828a2ccb593c9f6f38436f3224f312db65b3a23966af4ebff3c790fa7a9241c1dd82bc203f144365b80ca5d9fbd8e87daa27164a3d5f0b754e94fad8b2d138fac9e5066abb7b574d061d6a25af1879e4ca5e4ac34acd370078d8b456555c8dae1bf1f42b6c7c58016aa07fb7780f23dd8d6b689d3b668528db26776ae06e38cd8955b57d6a1a25228550d9806855fbeb144d3cbc8707102efbcbed589d47ee52c0040e61d1a90038388e187581d1ca337f3467f2e85db0f9db64b46b54020733d8068275d05d65911932baf083909f797d41009ec641defb9f7f8c9dc88766ba1a99e7f4b1779d2036ad5a9550b3f8a50961e15c87d38c25d515cf10df03163fcc3149c3bdcbe76dcbd4822f20c9d18d39c839c1ca465d48218d359468500849ea9882ed69b0d6f1e8d6db3089ecc70dfe6f4f49d31a480ffc84c89e140cdba91e3a478d83f99d22091ff5b6ad2efa6703c320909c89143bf2a49d08bc23b0c7bde29be8810a7af08599be2630db6d4f099ddbe82ad7f63667efcd88149063946831c5eb550b3587be48992b850bb9ed1a75da93f32c59934cb4af94234104c087535dc6f76b80cde20cc65f19e6d3422a32486e416a34a637ee9e8feebbfec69917eb6eae46735b3929f695bb7a16f6f5407a98a228dfeff589b647b87e65d9e03131a54df5d0b5c7f9687f8a0429f8c3e105915ab837522a65dea8ee66a362daa542d0976ff7982125e815233cffa48740db5f9d8fd9c8a3ff2ae8df361ca541e2852dcb17abd467e009c4f02c954226327c2a4bc70c1050e269814399f34b9f42549788f542ad6232eaf065e704806d77fa370f73d8d1454d4773c7b8c5ab99eb5f0ce50ab88f1843c8ba64d63589557af06c7c68bb2d8e7c63bb6cb95a1f52480fb9ab90b01be5c9772790431e009d9a40383dbf357bb62f517e048f4fd6ef3a8d248dbd7f725e38318f5b04388c40dfdef2fbe1dbe1bc646921e55f6462f016b7ca12b32dc2d0dee87662f0176901f11f3c3df511797d7cd27129bb72ee7e5cc644e1984f1e6d9dfd8f2f35ebcd3402b4a72290fc122fc721f76fe558196015fbc9d921193420b80db8d63ef73e779e4cf3b21ff26b25b8aa05d539f62c8f4121f26c29581f217d5e2de120357a86cc66d8e3eb92bb2887ac6b23a13f9031dad58168d9f82fe1f85049093e257d1098d87be86c42bd13bda4ae1f9cae7266c39b8d487d13baa03e15aed977a22c285b02c13e353608b408c461b0eb0285445c4fc15b531ad5e7355d4a09d400ad0e69f9b6183347756a17c9695e41a88692a21475c4ea07772ccc2091b5bd65a07e5c50fc7da6f16959fd45acef554bc686210d8df49e4e4d627e7f4fafebc0c874db9ae5ae716903cedaf640fdc3c23680c7ce4c8bc1a3b36a9c45ad55b5dbbf8627d266803d657be358ab5c27d2675eff4a02a5e6b29d4f6d7e1f3bfe1940bda9827159e8f8e27fa61673c7bb33b8ecbac1ee35f33d82fe993888892f6968865f71e4e774694accb8c05bcd04f75c19af1a3724fe4f85ae007ec4ee09e95a2d343b9b5cc35b04f7688a0fc080dea149e0e84219547558ca11f4e2a515c54b3abf4d19b7d0c76285be279c6f563771446ed8321590c5b0228da26d73cef513f324c8f3649d0655fa45f14b3c26d3e6f44f1ed6022c6d097a2ad4bb72edd0011be1f1acace8b14d2b31d221604d3fe624283c9620b954b11ff1ffa8e222262db45f7cecb2bd3cf937f371951ac22e818f34f9eed082f2bb269b9d5eae573cd016cb9c61b7c87f2132cd3813314c0ae9d021136bdfc0bfcd6daf3e8f0ecccc7ea0a1b42562eafb6665266bbf286cc7ced5722d72340fba32a2b4c9b1dce38f71f265c32d797b8c7b862ee617e0617e1ead9ca0c294eb7fdd963f6efa79783812967077e9fab26a41f91e41358b66948a0c18dc30b73b7adf7cbf23ceb8219f289f77ccc20ea68e41121cdb639bb1da49e32171582d54c8db10cafcf4f4d024e1e8a6a7be38360ec437c239b8941734af84497479758aff767babdba5175ae8d291ef3fde5426e56cab9d34e34a17e165701e0978bc2258c7fefa1a979be0d2c17b5f28e03b0f4bd2a383b8196ea1dc41bc023deba5417ee2fb177279ee782195e1d17828dc41b77e71b31e70001cba355f3b64b1c1ef3c39249fdfff3eb58259874c762a0c256ec577c3dc575cec87614ab01bc19634f7670c55a96f0cd109dc031b301d3d333a83f04fb9c1b063a3644bd593b6b6cf3f1ccb9d09b91c83ac0e251a27695b976be766dd9767063a763ca3cc5f285aaf18c4ab569f6c33d24b2c7105c99fd10a3ff8f9200004c54c7b34c26d112223065dc9c8907a4c6412276084ee325d5f2d001e8724ef793908a7a0f555bd61190cd4a07ad9dcb0c166df0b3dfe8c4c97ec444bedcaa5d3204224e95f8bf029db6d6022ed36a2f7d20f4c91cb6e567fd85a611e89ac1d402e1af58c632e062437897e95b18ce348810373a7832daeceb03d2329f2aaae05e6c72de6b9063a889a88bab9a17d11bbf39b2565394eb43243857e70fa74014decf41f6d03835664ea3aa7b7d23cc93328fac5e89e30c311a647bca835b86e3b6e80b27c867797fb6b6f4c8ac2729f53b33dc9052778474753191a566cf0fbfd18f150c1ab8bf6f406c0f7d9ef6d34db4bb02e99bee396b11b3753984a2dbcee8b09eaf5097dee47fb0c9af8ae4d4347963977505ec50ff7af99c0c4c4bd3ff69db465c9ac082c237ee8fc7d049d526653d729387d0c467596f7d101fd92473bf67c161d7886d46530dd828f57d00b9a2ca150aa22bcf23f38c23af1d2b6692b8ace9218295b723db84cca4735d913ade874e1a568781ec0aee8cc59608f239d612b6eff2db480cc90cf13ed1732e276dd0cd36d1ca1f54054e219afc8438df2e49d5b56b31f41632c00d77bdd6df8e205b95b81698eb8f59b23997603363bb0d362111279e575b6b08a8829f74a6a79dd8e8ca2751fcfcaae653688ca1c4ffc35ebd49de85be09dafad18380f7b00e0f8d29fa634d110d6e5ef0d00506794299e816a240de360655e2f4eebd5e1f13c8453d952c65fa1c77f9813fdd33a5cf2f0cec3cde24d29b9068a00d9b94f8b0b23287320dc32ff8527658a15c38b196d69b4caa52d22028fd5b6039eae51dff2f3d4c1763a223d793f4f1b94bb13d2515b3dea1586d4cf9457f6cf80a9a75f1b83e84b293d12927efe7a4ed35b7945e24827e2f3dc318574f49c0879c4851a5c4fea385ae4a84989c8747d4c4c0e5b5818e9500c063aaacc4eb870fe15109b87e6dee3f46476a0ac2c94bc603184ff92ac17dc1b29787e29ef3463ca89644d2e2296032242c45cf96ff75b0be64eaf9589d3a81daad4e7868a642bda45ed577ec580e711bdaca306299e9d702e7072bb912b1301eccdce727371d619f00de166396359207b947848417187f77b7c1eec73cbf9ee40c92d853015074754934ed04341bbd81f973f0606e4557979498884188dd782f7bdc6b666a27dc56339343459e6fc250aeb97154eae59210b469cedb194d220277ae5e02d8013a3308c4b966e261e0434220bf6a02169273d36b76bf3c858f6727706d33e6746bd8a363b291cf10490dfbac609b5ba0d9d215ca93ecc417da8cf44167b6068626bbca3a3bf67d3694915dec21866ede11cc82428d20ba44931af6c67b8ae841c165a1922b0af077062c832494ad85507e84c7a8de2d3c442118698c80ea2e58c943704c1f40912dc64a3b32c128856b00cd8d3bf19a4bcab567c4f90add17ee2f98939cbad46d1560e5456d4bca43e05d8d4e8d452de11cf2220c9def038fd5ca794166b8580cc54d83f04cf719ad25972d59ba538f3891d8e3e03a8ea7592fd7f3527998ec27341b6643b1384e22aa415e6261789ac8172f1086200e213295906d9cb3cde33af5f553a03a03f6ee2879df00f5e991af2320af56c1416b2b3076919af9a396216fd8b7051fb7a8fcb4baa6660504aa73f8e7e944b071200c430a99241cb405091dd463540d1bbd9f57493268224551d9201cbaa924258f3d5e0fbe55b5854a496edd6dcc3a3fda599111cec4f6a63af2e957f86602e25bbe2e803532c28a375f1953e24872e225eb3a9e12a311027a71493990945f8eae1db2375c5a7732bb64297a7729e1ba10be7eaf781d9b99c923e4d59f82ff181d0a63275c6180898511b4e29a23c864e215f5b1b1615497d7416c4213f1879a8a6a0cca370318a3b30be4b0aaf753bca864ff85547100cbec860775e1d924fda3926da2f9834af159f77ae507af06b680ffcdedbf390388f625377a3bd3c54b597517c00c18b2e6d124d70540a24404cb634f302ce9c4e4ce92917a1c4d126d6f34382dc5da67bc1b769b9c7aeb0718410aae6ca52b0643108759a9d9f529c12637b24cd06d445a0d151477fb33e885a899fe1a6c9d56d031706a309dee85927ce2952692b2bd92ad414185a9aa5d4a22930a825a01bb1e1b8bc3d3d82fc9c24db1c68119006f4fd4e628255f2a21d6e5988b92ac615ea7f066fcc7b5196035e233cc9b0317c912913c374fdcbb813b78aa799445ba4903df44aedae8dff433bc7def17fab17cb3bef799c5cb5e4ce2cd2dc9e4a22c531650f7b7e43cf5f35cdc471b80feb47f550239b1e7e3d23abc9b2ef93a9f95f97a5ec56e513c6a084586bf0e6dae7361fd2e27a44f6c4a22e8dd0df639de077bf95d566a0e5ac3d4206a81fb77e3b58cc776fe515e2fc83d7676ac5cc0a3bec372f1742390a0d573bf7865d42a3724696570a47b9ec0b5e8942cd3d5949e8ed3caaf5714306eef2eff19ed0fb6fffd1b1c706dd2a123b5290eb6cb9e7adbb8a72f649bc4488109e4f0cdbb04d3d18d00c071919a5e80cbd12d77a705b24759468038979ea642bf34e17b9d318c0b0d6b71e4e3521f3168b7ddb470e91a609bb38034c763633ef148592dd1cb8dbd59010e9769c72f35008f7bafd0676c3d61426ca056cb97b1e3c256f9b93e667b3c2635feadc458593ac388f7fc5a58328c3b53dd97770f59afc376b810050f966794eb1d703b658f61f1a8b38ae81c3c33f2c056314fe2800cb23e79c56f9a88c41dbe1421eece78041babb23c3e90cef7df2cfd62ebf9f145a99d590bfed1b83970b69cfa44fc93fa822a21f947b15b73addcf342a1a0e2381a51767bbd5986c6bbbad6a830880d198ca949489a3d69b7a0dc05979bceac12442fd3229847ba31778c0085ff007ff8ef2aada0271be9db5d8be9753c8a2bdc038e815997f24ae1f08f5f7ffa9a107183f81a03385e55bcdc2910d5ed36303f48a44089663b75cbae43ee478deb771d062234dfb4b9f79d57ae49b7c3763e57f19ac85cca7a6fbe4266a3ccf10985d3440194b5731d7c8d058932648930967c5f3380de9f9ef99c8710b3e07ebfcbc5063b983bfae821a8a7498b67c2a30939c1aae88a748397fc4fec2b12213e7849f5f62c95b9bbdaea7f560ad0db34b6dd828316e153598847d849de5c1a8f4355e03a67dfc8b0636ae4908ed54e22e2370183b85ce475b5f0d30dc3b079392863ec5fd8eb20561c10eaf077f56754f5e228850118d30d5082fc3529cc30c734cf5152672eaa7f3667d6d3546be578de9cff58015f6a290ead5d870d23cc8c68a9b004a1ce8ca5cb83f261af9f3e8134617cc8d04626e2e7c4fb592a8533958b881b858d796b9b83e145a29c38fc58382e76f38f40a70d36c9037de4ce0874a184569b3a88e1e8a7471c8fe0f4052dbf8dab81fa78b2d2c6590ab87d0fa6fab013433fc314bd4fd7f272c7b02beec4c779cd32ece8b1f2300a27b40cb7ae72775fc03a90974aec2def5b0517a7924235da7c5376b86767a074f1e2fbaa7ac0b41fa54ada2db4efea16044a73d8c56cb466dc534386eea465ac541412fb10dbe2629f9d71f3b1dd372b51c946606ac531fb721df89939938b123f8ce0b00b0589b31b4c5d95de60258379909baff16ddc7de1c205d9f2407f87ecf2f80ed0edd4555c9058754f4995878ab6123e34a2b6870a3222118df8f80efcd2a63c7a18074b8247034e0b2c9f8699907de4d27ea5e672016e4bfe0bfc5b4b9f5a65dab164191c744f1fd5595748f4178aa80973d4a344a92998b57ce54ff170d6c11e1d94062c82980bca8699c5922e4e9afd1b96b1377aa4d2c7b12b00912684f8ed211917a251431d8b1e8067df72fd9ddb0112a0dd146948a2bde3e3be3e60a0b38b315d99744ede9c432f6eaa4a913e09acd247abf2cc056fdf27215d0618c2383810a5d41c4a4cff7c237dbe7a9e975f348f439eb64e8f413a3809060ba979adafc2ff59ed338333ee3b2205cb9cd8ee69c4f4ec6ec2a5e24aa136eea3f15d3f8233e6cb75d83d5660c458388b2a04713d98828aef73b8147dd841eebdf82d691da88f418f14ec1876ce4e1c312d218dc0aae35014cd4eb02f740fc5a1643611174b18d9a3a61e2efe69e4ae5bc6e73c5d5426eb7a54b859d8c3f037a9f6df4ffcfadef70dddef402604b0968a49392f190f41dcc9555581f8e38fa38438ca45b1053b43c9d94d8beb469612f1f24af6198ea6ad2ac96dd7160fa1a47b2dea2b5e85433955fe5b865ac300060cfb83ffebb80ff5c8fbfd3fe51e39517702a040bdac15c16306a3b2f5266362f601425c822011d8223ef9222e69145545af31858de6fa0f816bc93ef9262cf93c8ef553b99db6accd1d72ae57273d8a16d80a89ed9c57ba133774873ac9b50cb22e4db67bbebe59939f37de90688ba24a59fe91f26d62b53736b5c572255b1036ee8dbbf22e43f45467351341f3eb656de1f19b699266fb5a6a4157521806c6c1fe60f631781c43927d62b12138d86506bc7e7e7ba52db3652733a2a9c708b511557f42e3e2fcd61def75311d2a3c4926784c8feaf448133845c36217001f983fba7c853fe439cecb6ca1b9883d53ea3926abb7fbf7b1188255def313703a5dc067d35edc3c841a6de607aac142990f0796e4d61a4946085eb36adae932e68b8b550d0b6c485db4c90e38c1be47aa7fef92d2b2c87f277d234e164783deae5c00eff0e3d01ae8d48fa617583399c3d81d36422fa19449780b67cc78dda41581af415b79e954bf309a41c4802fd18a3cce010d6f132ab507c8c95ee5941791391ee24dbd13666fa015179fda8ac55f5b1749fa93be7332c9a4bd40bfe89e692aff9e35be21925d016ae0a12842f5886761bf78e102a8e9ec8f2ae60e132b8ff8db5a28d5449f2bc770e8e18b9c61ef24c5799ea8c89e5c974da742c7dcd68f7d2f7948b949a1b9eed5c17331506549a69e426c57db2fd6bfc06621ffc855bd3bec5da1b8c2a6e90cdd064529b46a46cb686e87946a7ae915f211c050e1f992fa3b7dcca9e74a9f16e96a9dd3aeb3cb87a321ff9fb9a2146593d7478af40e9f147f2c9c5d3ce6bb893e190268d0795461df65f040f0ad81df01e3e736e4c6cadf065c8fb68ae128c939955abeaeb89586012c6ea25fd8927c0c919b5103bf3ca157f3ce9ea55660bf548f7f7defab8f6ab8636341eb219756462848d709d60f88cf30a5ed058d50f72759f992683fe1280132fd09bb07690abed7bfb06ff54e4faac3887eea8a9f0a16066dc1ea647147c2bbe29b66ba2b475bb1ba474ac23ede8ab53074492149446f8c3f000eafa72871ae9c965c562782321ad7855b73989073ff8e233dce27b7667b7321a268ff58ec6b575e5d2a76c21f73cb700183e781e45dca4da9d27449e6e050d420092d7b24e260cae2e5a1f0d3a6eafd4467813d860ffb06550fa5f8bb42f4b2ee52f54cc46f587287e65e801c1d7132eab90efe47f646b351e76d05cb3575a68add4187b105bed9e38d6abfe65b2a771e3222fc5d11611c12835be543920099bf743b51d8aaf07a09a51c8fa3d4d0592d0de160555ad5db20cbc7faf7f414d52c5be5212125a800285003b59b12ec87ad7664564f456eb065a73326f390071b9fa34379c3166cf9f9fce22c437977b09dc327291710fa3f1bafe94823a90955ee330015adf9bf85899f6e6487fdbddb9648e1697cb90aebc3aeb47b10f54138f6d5940ad8ae5e0b0fa82d4073decd84081ed893ab2376af9780fd8fe683f7b995c21491081bec2ff5574126e27b76b94aa00133a20a237d0d3f520a9cbdaf0cb241952174a04a0d767a45095ac912d5b4763063f37401a2232e6a06d993a0dd126ebd257d710cc5b4b99ee8ea266932f587cdb0a5077880e83ced9ed649fab39d83797fa5c871724b46fa699131ee4a969e1b856c7098656084691903204cb8f751c1dd2ba2029b98af76e3631ce6c5d0c316e0647179cd191a81c05f7635526e0384d2ea1b6815eee22d6f9228f98bad5e9717106ebd1a1d069cd6b9855a7503a0fa830b32f6b9497b92337ddfa5b630d6f57439f8ad984870164f1b392b23b04b6aa49eaa0272f76f7cc40fea902fdefc4e24faba426ab30e4de361e294dd3c5d918e5f9a38f8b2731f22004a7c7dd70f588492aa93a928a0b29b7d1920c17d0389d313af04f607246b0aee5cb8b45615d6885d2a34c742cc7ad56698738906b7fad14e2050701c286528bc1c07a9cd74a612a80dd5c8d0bf6612e28fe46ff0e0e5007e8269aa523a404358a2e00ede7d47b7a17bc96795f509664710013b2d81370e063ce9fdaee2a1de9dd33e686968b52e59d3bc3d9a212b84169a8b2bc18129f23db385248fcddb4463cd178feba43aa6dc80f789b620c90fafb95fe32bbcb01336c1be0fdfaa3fb6b4b4c3ebc03cb92bba635f774a0bd5931d01b6b7879376fa84589f7accad6908c78f266805b3cf660da751b1937f122b275eab08125fd0ea1874e9b30c80ec348b6cc5af01b71f3449d7f59d5f0c143d0de77a40bb2effcbdf0148f87973dbe3f78d3cd82abf128982371ac624cc7f22078bd8d0f3564cf978e7495833cec706eb37512d423b5868448292a59d95b03efd9f9dce25fb27f8f80ad3e796e158c16ec2ab1d383b8c0092204741b596a01e7475359ee210e53943a8c574b9a0825ec3bf88870ac7a1e7d6b65b3e8463db187af24d6bcd6099e8f795b282370b702c5b4e38848d13e5805b1fe5f1074b3774fd040a3f09a36ada87f15b53e04dfa7bfe3bc800ba8c05275589ea9f883eec1de0b5c624dd180e77b02de33d588e5bd18675d968453afb72b2b7da2f28e5ba8975d3ef6f1295b1c14e41284449630e3e1b985d4fd07d22603a804ca20ede86945fe26463b290111fdc53aa7481114f7d21363672bd053943f90225279124dc4a3877bb6b7e83f9534be1a5a2b2616269370fc5f4c492b658199748227f2b310c628ac290f2a19194ebe1e5d3a298616af4b202b04c6e9ec9964ccabce291593200637237e88dc23f699580549a2313a35df5287856c652a580f44f5a7e219dd1ab7f524d8c95391d591b81f613c3a864190facc9bcd93d75e1e84464ebd9c1d53dd7759de67878d52c4ec9dede532610630f57da0bea39ac0160edd00d5897db30511742aa1158088e9963882c0ea8eb73fd4035a737194333c09b2dd43c737e7d6146282e1cd98e0f9b670e1d0a1a86da961bb854ad7dec35fda84e9f31ceee99d570325b421742b0d0252e43962534249f0f72925f336980d9def4959c507d0150de09af8a26dbc6cdee07444721a1357848bd011cd0187afbf27a135ce4736988fb01c135e59332671ab1748d2a073c9d2f76aaf13a4a3f9ed03eadb48858a8a9f5fcc33117deb7dec053f1abecda970592c89e4c537460ba60a8ed2daffdca5eab9081934aba3cc3bcd85d10258ac96aeceb280abe55d7bab631d27ea0105eaeb9a1d3eccafb2b7d94a81abbb2fc23f6811b05cf30239bb6014aab7bb4b4f08e67eaa988e477ad8b26d50ea497b498f259756b8e45c94dea63215d2b2c8708f4b3f16e4a3b0d44166de38f94eebd2324be1c0525e2a7d3f2fe94a7c0884e9cd676bf4646fc6348b563c108fe74658fa433b7f8210e6136d1b94ef0162645e89c96849ddca70e967465dba8e76ddfd277e69c1664cd8d3845fe408751d09faa5dc9f7e89a373160b5a52fbea73dcab47cae1c2f1283f397c76e50d8007009fcae174da3c8698573472337be57fedc4539b7ad03ddb60ad0015ab37715e5d8c0bab8e108b840f9d91eaf0fa25cab57f35994637f7f46f82c4818d77aaf4681691ea188dbd97092ffd4fcab9af25596dae8bc5f162d0fc0dc79ebb0eb6104782d5b30c2085e7d5c84a2d41fcc1e0a2faa1a4bb3bb9060d3d8bb993b635234e491aa271e8539124fe1b0a787909507f114c1e647608e5e2981c08bef36934b5c556c8d20ad34c8398bfb618b28e1b1353839c992bb1b5b6127963fbfaed5d5070c2835eaafe6d521cfc9bf3e00d9f77b4192c95457107991e9e870db460c4fef68788f915896796bb0d6db571e3937b2304619519bf52897de46a6fde6c035c520e35dc4199003b911c78fb5fe7bcafac20b00ca32285d67c30e53ba47654c8d9aa0d405d1ef9e95f3c7074a301436b443d2d024fe0b39bcbd769f1a282cdc472028329c95fc72d588beb54c1bc6eaa0b27d749cafda7c365223722f6593fb052bdc05cce1f2cd91ff2f700e8392b95b1ee1cc5f8d915d15e63fe5311fd23d63cdad27096a5be217491f7c68126970c58e702778ac4c99c59e79481cbe26c2502755cfcec5b777f45219cd4e92ab253c2e89e83e23b69372f0b7eeccaec80f2f25c0d55c983466a754b98d98a5101cedf2ecfe13219a40007b45feca1aba9cefeff0f592021643039a0213284d4a67b1d29f8196ac1110123bc3553ad216c80f03845cdc84e8be75b6e54f59f8d24e38d7b08fe18fbec95a36e4d370c3403f7d86b3470657543238f0379d3c71380cedabfe510ee4c1c1bceebd218e1eb9f09b077a32ceb5d46187b8deec77d1ba1efb4e105cb57d7ed5e6f9c362ae725326765f534bb0ec41366afea78723c194f52d02bd5f4daec8fe0a2e85f58cf4b9135c2b894d560b0c669052cdba860d3d619f9666e43f02be208f2bdbbd46f2ca143f4fd56a58cea73df2a8b1f5a04b36637f778982c32cc6e07c7dfeb1b97c1c94d632fd0f4f8914306a00311340cc237f7e8842abe9bfb7f27d62ca4067f2156b95b9f10737dcca6a324872bd2d44bfba4872a1b2d51ab1b15ff5e5139d512f4055a51242367882c5c4f4361113934fb40f608abb366368cda4e222583cc97b1d2def6674a6bae39cc443bcee7734d0b571466719b27b821397623c5f07e256c11273eee00044af27a89597e712aa7794608bb7b77cc96a6e5d84d6859807a2681027f5cbda80ab371efbc4b5685b1c4b1bb9241d31925cc8878030517956e0acd5e2f09a08c68aa2470a5933a0b5b918c8bbdd5760e5398183376c4a77236e06680fb8fa628079fc3647f40ab0db3c6cf58a414026b50ab148961d5edce29d7db367387c83b093caa140327ae1c8d701c4beded2b453fac8bf861e80ff22210d428fc88579ba654334d3b5fe3c8a315ad075168b9f50c3261ac76d0ecbdba806416612750048d858b017bd6655048089148e363f6c08c34969a6032f2d637a104fb31adf875242aa0fd91d78019e7c35f2b8960f5fab632b13c754838fc062fef5e646c748607a676f1a6fa38691bc2dfb5c1fe6e9916501c198b385d60d828f2052ac3f0b6917ce4d336a840a41d883b7698ca0e0185ff84a03b4cba544a510938d0d4bf733fa1ff648650601b86a1a8619e9ab4cd1184c0626f007cc47ec8654c9dcb8249c16524afec6e38386edcd00196c7e54056501e78d91cb1cd899b50f256b235e11c373caa1a4f7594e2d9d8682b1e93b7c826382440be5415a40088ae0691b050f5cd396a050c5ac10f9ecd1cf5c58c45773c13770c59ea1fa2a09b4585f0bfb399a946dddcd69d9f5fdf51d0d2cc373f966dd82f4fa2ce3f572b4d5457e35731e7a970a573c31db9ae180b5bf0340dc4016b683ba1781f8415c033f8e5f2b34f3cb5f5a7933ba063dc0ac78008501e0701e2835b2f1ff8a2b10932794b0e7d89ba4c9db6c75ff415451d6b9f6b4699df86b28b3423328909178cac15c9a5eab113b0b24ef26b1ca496baa863889d548e211b79e2fc48149b7e9b71fed402e4f8991e3fa970d408ce983125de48fadd5b9fcbeb7eb05f2c0a642de5e1c9e6dd2fd42a75fcd4f397d6136606aaa455b85237a64d9c32930d0a48cbb954da8d4b6db386dc044a01a8ea3fa57efef7c74d673489efec7edc7aef30458014e90e5b834bf6db66c79bc22835e49461cfb1aa0258a8dfaa384f11279e5a87b41ba3934c42533763bcdf0210fa9f1466eabda6a37b84ef0360ca964d6456dd6f027be9338a4d632fe040e64a90a8df3641fecb52c922af93f1a5492e6755d386afe95746b9dc3f8a34ad5cba4e6ac18cf973445e1e394ea12885447ed6cc55010bdeb5956a644d6e665242b4d6292c6a037949b15aa569a3a41e2a2e361aa389deb82e19f68b26469a5b4d75965e453db55fe5e6269033b19793642f6d1873de801a354793919d997eacca7e7cfd44842f7aa124f0c6839f2f7d1a4743948b9d473c12263325913d64345d515e2d7978721dbdb16a447a8a48bdc8f07ce2190cd42fb3e06fac8eb8916bda5987ebe9b5214821d1ab1a93783e1ed369f5f2aeee18b8ff9fa5e166515bd77f3f4a081cb2fa5f1d22d4bb1944f07ebea6ef5584f8285dca53a007947887a132941b97af8ae2679269e35305aa5a7c66382132f8164435effa21664f9b6995bb71993a983d5ae50bc12c60e43865b4d43e11125fee667ddd5897b344b8e7a2b46c8ec3fc847da3fc552072040e5f4476fcbf70258235a314da25725ba7baeb36a572a965dfb3b087f6144497341a4ee3aa6c71fe8db2c85e2facf588b831464b274e1febdc3ba8a2eaea201a16bff18200d6b6f07dc0d76d88a1281054b46e64e32b9e1d1eaba1f03a12ba5bee2ea7873da9c86de5b4f2576ac764cdd6cc3207b97a168d8d6724aefd7e054ff1629492e1bb856330221fd1d6695bb0acdd4a0c38bbf5a522e649a8a2e6a8f5cdc731112e190f1aeed92d97a8aa79c1837f10341817de6b6591d86a99048a374a58dc467ed09ab3e76213bdb54b10f7bd05cb08b482f607f53d5059d6db857de8e5d614b7265414c550af092a83089b2dd84134aeed3c8f697f9834704d8e74573e6b41d26f113b89957f7e17a2e403b1e84a16c6bd550abbb06387ec779817573e6640e5e89219ef2574ae598d62fbfb71c03a47cc5618f48f4bc2bbcdaf0d17eb98c2f2b3e9328d444385609c27133b2411e8c93717fe8e251acc90541b22ff3ea27ecb0f6d5b55df653db73368cc743c6f116da7f81164ffd6ba3e1d0522adb7fa5b7054b16756d9199c0e2dfb673da860e3029456bbd6516aa81b091dbbc15b0731d7913e49ccc67c3e65c81c8d454af9b1963a8ce67eadfe344baad7ab1f7e8072aa8fa0dfd530f574d512abca1e9c5010a88853cfe45772f587047cc28b72857b02274f3d7599892920641080c382fe761831e18aba8e8c76877bfe947cb801ba6f0c331cf9304411eabcf2089a5df606fff515b84839ae5ace4410c585a157d247b090fef4216c1571ea339ffc91db03b6cace1709763662d3719d8173a84aa61fe2169e6b30951f67a8275bf8fe6e520bbb358ad149e1a3a434e4c443422cea463ea9ff6b8ca2bd9334311f32ad7e1385770d51fee404bf146a6f200c626ffe95a8972715bc083596f3b30071c405c86c5d7a67988edc48e6a8b1c1ff18dd8566777e6f18324d20f679f04f4a55d89073ea228f6ae9e5408541c7aef4272df3dbc3cd87bb94ef056f10d2eac694fe31edd49a539685fc0661c85c31091682f86a5bb86622fe3f1e3b18655362d41899f042529e19aa51e63007fa79796530f0a04d05f4009154fe22cec14a2f3737e2793d334f912e902a25683526d9af57765c55a97a77a8da80250a1b39fb8d72815652daa282e6e6b95d76824755e441f06f7c89bd591885c851af99179b6ce3d7d9f391de53c15d87a753f69ac9c1ec882f06b96252fd5254fb3259af73a5fa22d683c9a81e44bf4782a0011dd78fc51c70f9d37201bea7b25325bbff7073acfdec425767fcbf48e80d64b11b85d2e39b6f9ba2c2c988845b2ab6bc10cfd307afafc36607b9c21d063fb800503744c4c72a21ec5260fb4b364bc159592e6f3e3c7c06b01abc8702c8a27a8b324553476e07ffe300cf1b0688b4731665c65a006c71964e6d9d047d3df0479182774b566249a3168cd8e46b2a4e7f91d9db517fb6d8b9098ef27c9f26027c2a62f60d0fb19831330f46654157bf8a675fbf1841900ee232ebfd4803f4362da834eb413955cb2c7b54e64b47cf76c8d2bfd3643d6c206b25e6a884ae2bcc5bc38ba32aae6653092354fa468975a13356c41663b644a672fb4d486665e1c4ec5f16204396a73ce6dd774dac963a2a9d5a1aa1d383b0888558ee4509d23684c1bab3cb066798f058a41f3ee9fd9020f089cc863a588906231817dcb50effef019e0481b0e35dbe40bdd0c85a5ddee38c022fe455a396841c43c0fa431fe249786e978cc8a155a520f0d4fc393f5c703adea2ab0c455db563812d2ca53a98ed8dad649672cf0de66c7b7a8c230f53284b2bd5c149b601b48f3892a2ad74c2c119a8570d2f3aac576914481b40070b456facea39df31701fbb5b737904c5475b4e992a20ad974ba7f1172bc67aab80eec9b25d834544341d22e2f111392965c7ba8b64b042687d6e0cdab24c21ac9946e0853337b4c1beb4c11e6d024bcc0ef7f10fd9a7e2c6a9e1c3ec1dc41a0adfe0a27766251866359410cc71768fc13a9824c5d7201a7f819f3cb9305488a8e4b97fe6c2c6e6817b2950620ea84ef4b2ce5d2c9d4ec74b26cf6318b4f3bdc19f229a351ff4d523e2b4e3451a6efaa44de27ba9a5ad1c54f242f03b777c44ff963ae1aae6dd695125068126eadd0f2ba7ac1ad69d9818223e72d53cd2260b2cb5b8ed819a39aa4da04e4aea834ceae3766b72a77a3bed9dec2ffa349ff45fbe0b370836853b9419b7ba8c354da962d573dd81c848bfa3a079e14c2691aa34ad6b042f8e2c40fa21df11e342f1180a844d49eb155756a59eab143c8b403805874ee882381cce506698921d5d6bf28f423723283b078039e75272e1546ea644b31086046917794aa87ca2343ff8dc26c6a3314c948cbab17962f32ee4f89f3e33aa191b79fbbba284deaca7875edf62672683ef39ff34d948916ef16bc87725b1d36c9b5c64d4c34c523884a54a502f908549782ce76c07c4b5ffe585ea6cc4e23b57c14052cef0fe8640692e42e9c7ad9ef74868015885cd66865c44a194388572b7914a62d08669deb8125ac16aaa14a42872079158a957b5ebd22a93551b5f19fad9872ddcce042cde552a27452ea78de872d1a11fa7182608379bd9b55cc9c8dcf1de84b616338d40ab8ea714742d808aaf6476fe89e742e17c729855765a9e2aa001a5c2616363507112cfca2725452e463035063a7cd653775bafc593df34db1ac9248dee2991c6d8d5a9546c1a57aeaa119b56238f9b2492ec5c9ef90ed4e463e5bdada90c7081e8836480227e1d62963f50543e6b806c3a321b91ed5939ad3d11a9bcea5ca3436d920c72770bc24b12c29b21b339b4f7b5b12dfce99b093b0be4e334e202690fc8d0c5180bd1a484f590b14d8c263c34c59304289d97dacbdeab4867de4ba3a3b4d1853f62075021e3d9a920d3472a89f37c9b6fa6c9e75af50a84716ba0df2b6ffbfe69eb030e80d2725fda5b67487c316828aa715290a0b3cd7191d63c98a50f51a6d54cb0cdb2228ffbbf1dbef3c03fb5a1bae6356f6e3cbb5257eaf68ed0067ff16fed35382c0df83e05ea2408925e0c48d3124cf191a9db0605cbf130f4c968feec7b5f80541ba776542fcb208c152e405079f8fa6d26ac8d621ba130ece2b836aca5b3d600618ab214754872e7a84324f36b1c99458c8b6018cba9c212ad8593a80811d815d9ac0f1702feffe476c455706657bf3e097bb2002a2aa5ceca35f94db8d4848d8197fca6ce63887df879982d9f8dfb5de88de8ce1a152f066d4f248b536510c23b1376bd61e36a53c3c758312593107d88440e608ed9db2f33563123e86663206ca010ae6eff4e951df9f5a8822347322a4e96f547256d29a4bf4837ed672df5d76a5237ea6f70c8ec376b792dc5e55dd8f192b094","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
