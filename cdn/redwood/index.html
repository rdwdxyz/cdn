<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7f0356dd13f76bc8c492b2a26a7ee287aee3f4ae39e9cdfd2fc77a5cefe3716be94b806ced39426be3e0bc5f87ac8d841fb457cc6338d4e63ebe7e90277a571329acb9ac08fc1aa30923503aae5678392703fab0f051c35ddde8388bac5e824c1c9e04a83a889e91485273ca8d5ccaa6248e9aa9d1603043b60bbd07298fc79a24c5865865e9f3f01d67404d23b2dc6abaa1ed18cae644d27216e2ea03c0dbf8a4300f79e40309b97594f39d96a4b705f94f1eb7d2f1bf7bd9d3c74fcffd0147857de828ccee4983ed9b1600f91d5ab3fc493534fa8c79ea23da0c6573eb1296dce7015b0474960991f4049e5cf1dc3f3bbe40056278ef386ada108dc9604999abb308ffffa19939f8902fe82779c7a79b5c5efe454d3c9656889e1d9043c6be0ffb2d4487234f365226ed90e86930a5bc5c6a88144e054ae493b5fbad4a2d9d98c98dea34c0d28a1138ebcdafffcb11ae31b7130522616677f2b3f09626737a388c94fa764c94ee5809dbc3963a1d942ba5e53f6778862326df9be252dc01e40347f94aae131b159a72bba17c643291aac8c3dbe8cff61ac17ba6dc45af2c4a311c90840a1a1aa1f1566d3b863340a181257bd9d8ffcfb3abe78ee81f915859e104c61486abc3a4c98f87e6330539c68f5281d87be8aaaacbfc5de988e349cfc12241402e7d0975dcea3bbaf377fd10e55cb3aef0441700fb21bfbc3c0d36efcd288098cc58a01b865710b37536fc5b62d89bf7b437d3c31baad35bd6903d6023f43ac49830ba81da9f749dc4f8bb2a9433c331a6f6db184be0e2940964e8bd53b00f6357b8a30cc13be8074176c65f7ea1f2d63c820d319c0f58a39f4ace1541b19b1207867ec591a171df6504c11278275199bd2c1be0d4d516a770979d4cd8181ca8be59c37c6db8e396c85f0dbe70631f5806539e76f1c948ae3c327e3558de2c825770bb9456efc970503bbbb0dd98598e9f3f5081032fec75e48bc27f351a44a8eedcb71555d82aaec76ae812e01b99249b81e145901c8582b3e194bb3196eb4f95ec089cb0829f54d80c1d68eb2318fedcb3ccb2ca85cbe45666bc7abb119bef4326ffcb4f8eebc49beeb4d7730c832bb2c9acbec5b5769d43e2cd0cf28936b4ddb6699b0198427769b88634e15917bc6bce833217cf7c93102c4984c8bdf430ced5bdbe1da594f26f385432d21f7d4b4a06b9cc3fd89eafe714f29da1c653b9c9997294f4ad03798bb72519a69f854952cb17962488e93c16f4bf223776ec9d9c861d127f9e973f6accbbf28631735723d85dcdafe2c8a39005ceb76949741b3cae0134172f735d3a5aaa1e69f4e529995cd49c37b76d4b97f2e25d8abcb67c81e3e2395e3ae2c023e1868c944e616aa99eafb68cba5ba2cac980e5ba54f58606a259b68a1ad92a9261bd9dcdefc402503ae3a571ac130043f3f67fd06ef48b6095c4e86d1e27cd1324e21ccc49a6ac7c6e7016f8370138a306b0e6c77cd41c919d0fce2fb235578fc8633b7058ed922e84761d84b5d411b0e4f018844a1d3656e113349210d0d81c8b7ce1166e391380e136c52a5e56bfcf2cdb1bff0dc413cceb093fe8b81f142fe0a6c107bc59dbe6f567b11fe014ed6fc744ee9cb9083f759b98ac7c18298818e995c79b7b85d089992da7ecf916a6fe23f76188b7dc203c56bc353aa4c893d369e72e5dd0cb118d3502d6699c583d158ab0e8ec84be8e31408c3d3e301ec69827679ae300cec768061529b365159529e8ab028b08261937fc826a898d783d57259031b31cddea3ae18c4ea424153dd9c45567c0a70ce77ae4f223fe98a89170d129a2118a716abf3f2808e1cbd3e61b2eadc580b0902c4423f002596fe2f2c390a2e7fdd5b6546b6daf4ba552af3197836b8542c805d2ace82f76cbe2d86705f24e594f22655c5fd985fe1f88c58d979c7aa4d4b9ec71c7168ce58e782cf1d535bd53386a614aa25ae80ce542f09d561f183e2b40c69920f0b6dd258f3fc52dacf4eec5a058ed2201023b147e8c4abefda352b195735129b62ddd8ee4b4a932d2455e06ad814e13e403f3fb52c18e9d0e76e026ca26c2de6bbdb00ea40f802f22561e62de1361b8fcb6661f04e011d5000cbe07bcd0dc09832f65a303357402046f31e372b977d039662d58c51a3c51aa424718e6b748ee0298c27a49008d14bbaee665ab8777abea4e7b0098542d9473c298b2cc42e176827898e6392d2e84062dff5e8679e4bc640e57e1e04d4f3b326d9beb338e53a56fa81e5890b5a80f1819babae0e5efec6a6357a1972f615acd2db7469db1e283c0aaaabaa3d146678166ef53a66b69768808197195900ce412bb981247931ad4dfd14d375188c2c5f1f50a05bcf966658de91d93e9e9c255c94628fb897fa8609e8bb295bff1e858024c9fa45ea5306208a9c94e83e1886a6669ecc875d57f705fdd4a35263c27d4a0601efb8d120dfb7f099283050d1f334faf7aec3f984b96ea92a3df491317bf45705c9bac01deb3b146ca81518bfc0eda58433cf95eae908adce91604f8998325243ca5566beb58d078212622e809d97d80761c6c9c328a9b32790f717c2327f9973897257da4816ffe7eed66a91ef8a3eb7b9115d5939506d8bc605ac134ff1968810ed60bc05e5bcee5ca44d7edcabbef2268d465d16885ce78cbc0cc273403e3bdfaa7e1e957c1338c21460b61fb0ef4572f402fa11ff2f1ebae3e20c506543e574f45b209f5c2db98b54af04ae7528e74d13fcd9c2c3f2623d39143a21fc36bbf96b3b131904e0b7df8c68fada0307316e40a2185a4b82d27d0487fe592cb1c4ca7f2896cf5f8bad4f07c8f5abc733cb9da13ef245d2af350769db07670795afa613bfcaa79b2cae9bebbdc38e8829d53a016642eda85ca8aebca95d695a257ee13db8814f9304b23e24cf2242312f656896faff1ba4204345c7df4ece57ead00ceb0e03fecfdec08025ed4b69e88c518e06b9ddf857ce6ac1345fd44bb7b99fbaeb0ff4c27590b6b46c66c4dbcf69a59bb460663c07a2b582754031032cb0b22aa620a459492995e3c3f16c3ad6d662ce8c7b725c219fb183aa7a20862719bda2a1a0efc9bce05715d01f075bba882a143d328104f1b45645dd03a1db0a74ead53c9dee34c23068524cc0eeffaf0bb3175ab5f9b40ed6538556b5e778a6615d5adfcf9d0c61464ba44cdfaaf902fad0763c5d628e0664067faf362ec47a55436009f668a8d12bdfe8cbd62dc3008655516460e920d795b40ef06578c491b903d3044c6f19c4ab92c7755e508e62d165b9528d095e1d22fc16224682a6538d8d3d0345c5c9cbeed184b77220c4304b1ae9de3e923b6ac4af5e45032d22e8f20918cb6f01706c8cfa37232c0ba5988abc3856b00fa6e3d8994aa3b4a31c759b24d701567f17d7d0e3701ed041d9a9adde08ee2085a612e50868cd6e9d0d29e617ebf1cd78e0ebce79533a2f48826019526e34d1380786e1860e3e16b0689c0c499f2220ae879565b03d098bf12a71ea98d75f932c124cf3587d44db09b41307d22eca77c7b24f2bd918068fae4a5fd3fb4c8d4a5b1fba6c8f20bd0f38c60a0cbcac4fc1d98df42e6146d2525f16be58a38c758728af9f19d3aa2f99f0919c14cc9aafcaa3b0dab0af87d5c89e0c74ed25a600dbec63360c0a32255860ebf2259ffc9a859b465e4243482512975d7688d0fac71b67311af1e58b4b6cf58369327a750c73b72b8f088039b296f35dc12a50b98add7434d906f8728da892b93c8baff747558d987be12aa9d96f85990f7b7a2aecc72cb96283cfb83f0b528ef70dbfc0c3ef02dd6f8cc01f2866f81b91039638d18c9c30bb203dabf3231a394f57929376aefe86cf004bff1a02ba7b9e7d6ce9cd3ee8d24b546fc933953abb50c7041434d66dbc3b89ee673be2dbb737090d2a4da2185ffe1aa004aad483aa7a875fcdbcb04329665236014e053c2e4e28b36150ea7e29782c40ede329372369869e84ff3358660d9d148463b897f71a0e934286792f66388e7a043fc24781e6f36ef2bb4bf093b22433b465be59cca3604b135df04ee7b6bc2b136ae95476ea3bcfebeb62b56b965f0880c98bc25bb9af771a300b6547129db2cd1292a509e68839415b54e50d6871a2d186a05effae2e02a8e2ffa18549e67babb0db317cdc6b9fb799f45807d2a60989a4a2040f57b2944890172d4a68e798632fd71ac00bbf445d70a2141af83e8816c537e196f568293a05376a3c987d5303eb326b97e40b577020a693cd1da4fc48afe2ce8a6e2ef3aea38febaf4bf027f00475f89b5b358d5b566a0ae9bf318169d24c337a42480928403385484c81743de0b57652d8f2e7209c34c9eeee4f206f91ac116efb62798866bb866a8b1e276f953ef54a251f774f0db2273936d9ab278801bd517cae1870942cb88fb3e0d6a2d552f2a7e3616d7a1c8df7d27ba2dcf6539d4e09ba9caf2d60e2d83d2146468172331fb145ee332a8b9fddf1bea58c0c7b88d1592cc214e64a13192b72373d544bf0c95bf214eb84e4b2c3731e955d39ae6bfaf230b6b761d451c7e5a76705b1c947f244a311dbb3e97169b1640f2549ee5c1655146c8745cb1651320466e9794504782106cc0c463a70ab99e1121987772d3d9c89b2f0fee88df81eebc111c3bb8b4e02d1cd5614c1689fe615e3c1924eb321b2875d4758af50b9e0a2ffa90101c5c00e0b1240476c139c662eba805a3b9912e6df4601aca2d512e696ff3e80b5e1218856ce85ed50b85f7c535b76cc534b3209f524199a57c4b9d7f050275e7a80da2db5abc52ff9c449db450a5f8d83a329802099dc9d064a63d7a38e574b075bbef1bf0174bb9e0db21f4dc9247d7af7176b19f79bbdbd58318e33fde524eff06def488a80a1e5bd336a7471a6e8e11fd95d092e52139a7a53a9e774c24f678db6b44dced456b5bf5018a1ced8b8ea01ae9ab5cc5fbb1d5fa58937fcdf7850889db83701e1da16dca2925bee067d5339833d848ab242c537c6ba728f176802ee4b872a8b36acf317c71274cb734eb5d6d839660a165ead53a8ae09dc74b6b330e02804e7391cd999738ddea90e5f42d33ca76e636c585d4875cc278a297f6aa9c9cc4b09e86da359c3f5a39b303959e7cb01f4c7115d129ac7778c32cd0851b14e03bdb501d76c80201b46178b9629d1af9400970dc21a60e4e399d301e33acf0ca7e595ac91b465847aa308399627ea180d5b32034d7858bd4acbff123c6d67a7710ef0b4547425a8be63cd8440a1ebdabdcba378ab168838583257281a427e4e1e3905c198b710e518269d60b5842d27bd2df2612574b1503e826ba8ab4da45178b407077a76f0e7ec77093c84cc01df4ba3b1767a44cb273a5b727ef0b9a1a6122f5a3582f9c7fff833bb03b03303e074b9177397b6a3df59205c4c7757965c369c1d85919898dc5a6d4fabf45b1fe6f17809db71badad6669da5ce83e461f7f5cf470ae9c583bada0252fe0fa710195526c8a257c0ba4dcbb715c503996c317df61e7284ade41c13ca691a961ab92719dcf66d2e64deb110c5a571593a42709e02972ec9117118fd040c1abe55b4d369de93b5e29f0d8e4c136776eaf207527980a8c9ff362a1ec728e6d0ffe5b1801783bb16b215dd894bbe085e5f90aa4dc05a7120233f623b59a2782c1ec0ffe07457414e7039640a56ceac6482a3fda739f03c908853e6863408fa354eded4ba795f4b731f3dec938100070615938359f8568c63f64e79d58ba4183e9ece4b5656e0e3cf9987bf89706928d4ffb3deaf8882a1f7d8273fb507b8cc662de967cd8bd69ce9201ac9a9e9470df01176271ed111c268bc1259b422a70eb7c621439ab275baa61c46a9dba7ffe83cb4239546f6813d58d8315dac1bbd57e9b2db3ae022a475e1d5e156f47a8d6fdd764dc82203af231901a32f142394e55d96bd2baa8f8b29be7cc014805eeee2751a3f48cfe1879f2fbfade7af15ed27a9a87b66d9684af45e896b8e50c098f987603d1a1cd6c3081e4bcecd70ae246ef3b8f1ac18b5a022b88ad8725a39cc95a856087f999d0035a10294d6321f47916dd86e913687b7235535743f9027efaeaccfeb2c34592959b0f94f62cc55bd761d847392a856f9498cc8ff2af0eed07ebdbc8d905da4a6ce16bae51076145ddb39db1646d810c16868cf018696aaab7c92d8bed95b4e8e5cdb7b7d572e26a60c8bafbf77857bdb306360a66752c608c52f2236d43bd6670957d48fcac9bd401bba26e446f54db9b1233db130c1f134d053be5227bf6d691a0563f93f3e0baad48ca1b77c752842e269d9785ec839b5fcf3a3e807aee1e26fdb5921e561faaeec1d3ad01b9d72b21af83188f503924e4a5415fae666c8bea6e68d28b8f3f6ad06988c30c5f8dfa9ec01910fbeaae8752f171690b72b3a45e85ad2315c3e15baae986ccd114c0733e7913c48527b853a66d14db7c5c1a6718a3914a68b7e548c2e42568aa6cebfbfc6faf54e7725dbf9db63366b9993b32c6f1bc201ea968b72d98361112d8cae505473e93db613394fcbd079c0b514991722ac37c7914a98c698beea80b2a6396b9addaf8bcadca743e33dae3ecacd33bcfc0a8531f37eaa6947990108611618b8370ded34ff251746e1d89b19f11dd6abba7f233918193af15a0447b33bbb777f7cfdd1a10983aa3b5743e8d0b10eef809d9bef89cb7072c5e96d2bd7f9596b9dd7de492ba06fe37a3453b0255a3ff8fd7d0cb50199a484f7670d541060b6128527f74080cd8ae5a0a4056457c3648e80f97a22c9976cf941d6fcc994557fd0b612d3f40a636b9e3fae7d365f446c4622951894fd8ed3fbacc005cc0083b717d2c339c58ad148dd3e30dc3eda5e55e30570125abd52a36580eb097f976cee2e2b4d34be1646d283f58c423bcbb595fc991344230d09a4e49487bf9ff54ca79e78177a2c078cc0747a4f135d1f1fe9c56cded06021362d95e2da6d14898d1ba22620f5ece12166b207e4414c08de59d8ef02be7f004a5f0654d8609ad13fe151431e9594a802ebb8073987c7f412aadc619f530fb7142de5bacf52ecd39da8d7d3573d46923f772b7bdf584b5cbb4b011ac492e1a3215bfb30863f5f5333db743ea39e66e827215f0ae8c90ead46a01abb73478a514614bbda12d1003c940f17598aa7e3cbb4faf8b94f983b0e659a6e29e0f7f9c341e0da52e0cc441071a0e2e1d9d9f73416e06a1ed504de5f45cd3d52044d155c0a3bf726aa6e6f4dc0a723f2ca769e97ef6f57099c129a64864595985cc8837bd96701e69a5e3464d71ee890792edd2f23d05689272d2d6f33fcbf87ce99f65f56616a9e6824c8de2be6d07132fe9d065f860ea9800e914a5446982137b95947852a8b82f11f3d4e43aeaa39c4e6867d58471e18ddf0cc375a7cb0377e7f17cad7b1af180fc3d0a22559641fe4695460291c1ba5efedd55b2496c219693ccbc03049936e738dc09c64defde63083279cc3cbad351b475e08118df3c9280cf4f3a15f15cbe5ecb2f94596396218859696ab260e1df910c2ce5ff3a7f75eaf379f6e1ee66f7ed6e839d6ad883d5d6720580c8236997181183e4b96fc9c6547f5a4e499cae0e60301f6987e48dc63ab4ea55f4229ce18764ab146cbf43aad68742c68ec30b17d309628ad831d3a93f1ff9cdff04da6ba3d952c1a258f75ea9982c7f0f2f427e83d6634d0291e9b86618424e5af2635584558395975c5d7c3bac487742e9dff9291f7e7327e656fac9eab69985d92f1cf589b49c75dfbea5031610c56d60cad0767942137608f295865334aef658cdb8c0d84d52e3742f3b39170f645232954765f91cecbcad81a81ac6fe389e762cb01891c52e9750c6726c8c7e2e5f94773e79b14ae6ded820103c5f367078bf6967e26c205d8ecda62fc15b20b19c13d660c1c3c9d50220e0ac0405139ee604537c76a7f2882cde54b972ef40b130e826e6c129a8ae45d7cbef1f08afcb791f3ea2a11359ec4cc4fc5c110d8efed3160a7d6ac422ca2c651171bf058417048adfa666ad13be55540e2638c6fc134466d459dd611290b7a51a1f6693462939e8dfc1f5b8e10111c7b5a220767e3b471bb584b24aa9fd9ff1efe5262715be5784c81e1708b5205fa052596b188f946eeb3c75257c907fa5699d4541b0110568ff4678872a4805e47d9ee09a3935f3ce013c912288ee87296d71984c73be141aada516558ee610ab43ed2e683c81a0f76629f6639ac0fefdfcfbf6dfd9ce298d180c3e16eab64e42234ea44bbca7e701573abc14cc89d8ad6ac69d43b326b94124b238e7b28d953c09352781c304c3666b978950638bc29ecb7208fbdc445ece254cbca076e14d50e04356ca0feef809b251cf0509460ced6faa2eb6268f842b4753a38656fad773d876391a5aad4a718e68bacf9f8e6a0d5767fe86fc06a3e37464935689a25595f8a717561f597eacd42581423baf810d42dcfef548001b5405f8756c15abab96c2dde677c00b102e9808a984a967ad9c2da5c9cb32640d4b2a2d9e886031a4656ee7286cd9be5473e7cf4454ebf2c47cdd1a760b50b5bd9d050c922232ae8ffd8381bef6ceec72259b4c74ad046e31e4532f44f4b9237b1772855c1d5cf145846c7cf91c445741aee12333860d9a8f5a6f01a622577eb05b59ebbdd54b6f7fbc8b00bc9dba13db01c73289bc710f1bc06a3236339e3424e50077eb2cb5d636853e891a6306e04f5770f900142a624d4858dc6d3f6b2e309fa5f9748f95ba6e503aeb4ad587027a31c435d73be86c1577a6c5956aeb18751c3c9a5ebf5acf75709c2425636afa35802056e056eaec1d25cd22b3db7f7ac0d5eed80a92ff5fa51c0b0d868eb062a1672125933db2c6f7c805d97f597c2df584941b9db810e8e54544038a97ec1ebf66487b9e385f26ee5d43d948ae4f8d0b7a4d4dc2411835323519fda11ba81fe57eb527fc606757fbd22f89f84cef5abbb566051bc003c2937587732aa850fb0539f26e92e16eeca5db5016346d4471b4c30dcd62501479df7ca9febccdf68caf01a6ab1406f055f3b8b2f5be56bafeb239a4e9c083da237bcfdbe66693573e14b6974cdabdf905f0c4bb86dfcc685bb7c2edba37d70c48a73ed28eab808b8be221e50c1528c5b430050e5dc78966b53fda53493b83cccd0de88609da4e0d675b514907726be27fa9d4a00023c4dcb6c82e98c086afcbda6de92c20203099e49a60b35582bb84928a292a0e29a0eaa72cc76fd2f8ebb1afa8da5cae41c0bc7894370480dec81b03f47a8db6a12d7efc7351dfdce04d29320997a7f2ed1348b44de0c997199e63c41c022fbc7b3cee798c841f42fb31b63f78c6eae81c280644a761d249496e08a975f6c9b738de83bb1b5a2e42b8c9b83ecc2a45e2273ff0c4c42ce58ffa5e6a0d9cc51392b4c897a4db1935e0ac092e9b188e115f22f490a0823c87aa9966028110cb8b591cc00a197227860d68d114e2bbfce0b0f343485e6aab4e274595672fa49d4825f2402afd5a3665be91a21e89d36ef0cccf9a4fa6b6c403d486b3be21d4486896943587141ff88cf55b824e7e5dc6c04cf06151ad0f7678d48355f7374fcbd37916a8b15d165148d4b636e5625fca5889280c58f5ef75ecc912c5b300d70fd988b30ef7845ed577aff8e52ffa2739c5446a46c29a043ebff566f6af2478c0d1966a428839a2259d68ea66bd55d5868cca6ccdeb5834f6e2220f1a346e7faee5c913177460592aa82d5ff0217714a5d7e51176e68a77e4a91ffe6524ec9aa68cb87aee0e3b5bae4cc2296ed70a85427972e52e7bc8950936b8005a6ab905fc4089f7d82a3b0ceab378665d9f2d388c215863835f7ad707e870d0fa38762d6fd202072980a32b6867d15090e39bb33ebc689846391ef02e52c0c43e128df01d965d5558a7ad56b2e97b9e7473690d60e52fa6d7ee7ae47fe08bbd1ce5d06c898e76cdef0a298d0f2ccdb9fa007c03f2dedd81687e0c4e51efb3057411e763b063b5374a3df65e976203b27274da2b16d7d551d5cbcde78ce711bdf7024622f4fc8dbe28f538df50f45e3cd252463113cc4f8e60dfe4897c3f76518a70aa955971d4410bc33d398fca30472bbc046346c326a349bb27120bc687ed7e7a8ab35c8267f07930431c69bd61268fff1f305c416a95be425f6b8f9e624dae117a88e745340055c11c303405eee111e972c86439d7f5958bafd5b3ed1ff45502718e89047a2bc2fcf00ac8be572aefe68b17cf8dfc2601ed3d103780dce3861febdd69b34643332a58676edb400568f67a1c6d7d79cd684ae1b3ad550285603a10383ab98da57c865e1e7e58a73c1b6d16adbd50ced8322a56f78b2944914a277d62f4f4d8cca9e09eff4964301f890eb49e0c49b3dbf3d83dae4eaabeb1236160841e6de07d92b4a78bea42154471a5aec9e64fd61fd9051c6cc6b4b4bc4d7538ec770618ad8e5a171ddeba0146c00100e8683040bec2213d2e7a929a55606f12aa754089774ba3ddb601fb9330fcf975fb639d324420bbe5b0dbbdec195341efb69e390ad8b0f15abac696f66e8d568918d79931a84cb012b70b048408e6c649b0b08c3fd152db55e259bc95f9599488500d29e29f52d8be441ace04b114f9b078dc1987879a3a12775ed904dd79ad72ad6740560fe2e9a76cd51e28a2575ba271944c2dd378861dc8ebe8bb4319188e3e45df79eade1217a541644e3cded089094cae0d223dcfdb588f81dc9c55ab0ff2d8dcec4aee37b6b7dda6520d89f0207fe613572d387b040d36e3715ba99ab363e952813fd68ebe5a4e737f0ef3ff598ba6a0399d42136300312ed8be06e43f801b30ba8b4ad075449e8e38c8c5e5b1ba1ccbc2a858cd16ddf7cfb848b24618ae969f8b917c6ede7f24c6f16eb53d9678ccea8efa3cd77872a3b2f853a5e1bd96e9bb8afef60623e95c6244d6209b29afff21dce7be98c5068310a2649392d3f8be1d8213fd9ec5cda10b822c1794178b5c9ecd1887b120b49cce8e28c5b4760cfd67a651255ea84c78f9a41b310120d242bd643d5f707b89760a22412b06dd1bb97574e7c22dbd03ac8910007eb96087be88d669fc36dd7aa47d61d1c39afb31b3b6b8ac047982891ac43c537fd1395fb9c2b63411781568eae69eee4197614f4da245fd10965fe7f1f3289a3c59aa954e58e7fef7421a3b04e358dd5d497bdb743bad0cdc6792dcb48b47be5a901771f76a1be8d57d3aba5f33af1ece911d176d490cccc612783a29132956452c34650878135b6e44961811347a936a5a098992a538dd55970ed2666241f213b6bc1d53fdbae1d88a099c45d5c4a7791c0bdb3dff53664f0aa510ef1ca53c8dd800205fbf2dca47e68c681e67a4099de10b9aac1c276d33b95162001c78ce9a61273744087fbb5e4699367ff8da067340d029097fd06205ac58ab6d285f8f6e279b0240da0512d87ad2924a29d820dc3d05f92e69d41ffbd7cf0de6a4d5aebbd159403a507878a33e5c8671a10dbc893f3521ab733aa78456171e3c3d7271f3cc7767fb5601e6e92ef8b0e9b5fbcf0b67b945eab977596acba989c4d2ef9b7585262736ccac10f10ca6d33ad7e4fbc2cfbb9815d1c6784e4247079993262cff0f37b9bdd917725f1296c5aed655753a500924a8a6ec7e13066e8b92447b8f9103c3e57177f3609be02827f15ad58b79f1c5c241fef9cb93710c92e3531358c92afac32ac3caa58ad930cf2ebe0174a898e316d7337e43cfdb1f7c00a80a85f59b75982daef35bdd407168a5d6d59b89b152910ceaad71e65a839ab6018d84e954b8a2c7a7920ebb3795260729cd39d4233b441970a08afb0cd202b5e2ad05e311255228fa8eb8d6ef541177d468f9b8a52a38b787f54d58defd183d9e3de4ea333c4c592364f58f76733c8aafdf1717d73d480a90f6d3887b88dee81c45c280e5341046d3057989e14a23ee15b9d5aa28d52fc343a524dc4ce33e748e571e79e1c99c9c4fbe357140a0787a62b5c3cd8dedcef1b458aa1d999cfe8d3f564ff6050259ce7a36f44b85cb9aa21d6e9009383559895905e7f4ee7a8222d3c9144aa69360aa2ccc0b8ba80c2e53000a289739c6bad5c8ee4107fe78cb61c961028341f14ff97f6e4149d999dbc93c70c4db5892bebc569349515221a96d3afd6f4da5e8a6b98b94e5fc741da71593860fd0fe2fd07b64ab154a11bc3c9dcda0c315d673ed69be1c5edc27dc40da2a1885c90ddcdcf691eb6adf7081193d5061da8b33dde81584abdab486798c07af4d981052fbe0a5c84a731b898d45c08214e7b60dda641379258a7ab3f1be8854fe52c6d5dfb7b56dec49e3e7afb875d28a4ce1d792218600a8efafd516388e36d797cb28a9e499d3ee23c35da840c6106e876438734727f6782d90bc9be11a0f6b5a42dff13eca6773ab0991b3960c282dead241c0785df59947ec1585fd84d381ae42edd4e970ddf559547b2af5e0a583de7992c310f053a272910087cfb0b4379531dc12f0a454355315f4de1d3e7580962799de4141bac688ded2f1643b7a9f20805fdfef42667b531b3bc8a45e58c15b2bdcad2b38c430d8635efcca1c96814093daceca0f4c8d029933a4c8cba9bdd55adcbb66ab84cd64fa0ac29f73c1a0fff7c83812b122dababadeecb0b26725d05839c9fa812275ca80ce683b89755a915ffcc5e7a4f5172f4255c985f34aa67b486c90e36e9e8b94eface5f5c741678793526c089ef7c449ec44d5d104a5fbc88fcf83988a968834ed1f3b6e5ce2b90cf9a4c71a60b8af4e324ff1c2b8469790c351bb30363521f38dd6f14f41d8f2594718bf7544266d6aa6585c2bddb8042965f794f5e8f8db82267d7a3c51404c07c0dd1413e4d797fb875c69ce0775dc27ba3ff4ec9fc2cd44568999f0cd1b6cc042de16e89fa1b21185d8030537e871863325562429c2c0281bcfed2d51056ce71ecace3e96771f7fa1aee3e99351035dc43c352de0f4d94b48be8c7f298a60e66154d85997cb739f5f567e181d04a3441a54afc922bacc53d8a9cc62af67a6f37082389b3d91fcbca719ce7546d9d374007fe050230975ed3dbccc85a4667d4297433806450e9129e05c8a53bc4c5233d563b5b4df2f91fb12b4d1457eb46c588c905493b35c10e15fb38f5ba3a38cc09170ebc30566c1abf941d0cac0da9fd005ef9a5c8e34620b3c3ff34e469b1363968e274299250d709b2bc6a1c79659cfb734f61d26e4ef3228289e79f4acf52d0fcc2e2ec11afdfe5ac38d927900df5056c2701810d6d9213fb6863e1eed7e2f49dbd65bfde3cde9b5a14002e284a337a25e659ebe85cf32c2fec5605e73c2d67e567c2fcb4cd087da410c9d771830b37c2b5f92e6604d5bcdc38823ccda878fff9d3dc9d96d85514d5f8d51f38283c6dbc6817b1a574f9ef7a53848bc529a4e860636f7eb8200fe838b525be50657d5e7850a3ee3d627047046043d79bf6913e4541367902e410883fa48c3748da7fdb9ee49212f6f83f8ae726bb0e7fc257e41a5942a6b090792579cac4e3b7de0e5a9caa7fa055cf5c21a52dfa6d50f3c4eaa87035b5e470b41e7737cda68cd2dc5c43997cd24bd38e430bfeadd8c50a1a9972c1d630612c3294e6cba3b64c4ef04b0fc00d65cd6d8b539106888fc32be665fac91be59ad30f4f9cd77358106420f6363ef19a8e29dde853f2fa01dfa6f4f65271c0f75aa65e0a5d03f33e933e46932e7c2c67f591f205cac5083cf56712f10a020a3f13b66e521615ca989d45e19ec0f25605fd05bccc812a5cb88bc781db6fc6c7a362ccca83b463daf344d7c9773f9f7b7f251d13d36cb9088181359a32b388b7eebaeb434de02ea3df3e3ab9214a4bd82909437894ad73701a58ebe5119ef4ecec6fa0052507a92427d9847cbff9e67331bcc1d2f71c9d90e5e3ef177d489cb27ca532efb5ebd1dad70dd8f067ad1894765e2fb753f73e33dc8eaf34e1b984e00f889b099abb73f0bf23ba0623a92e91d902da7b72c4bdba49c146c3dfa5cb4e6df9072995dd360398f18f1adad4c95b6b70adb46433d62b229f0f4bd165d1ba8342c30716b2076c3edf831e603fb39d5510eb68bde0f9840e8d407f35f447ffc033f381cffac39f930b51c8e4fc0755575d637bf4775d40c4cc20d43104bd31e0d29aaa46e62209f3c88e478a4893e355c5bc19eb82dd1d8273456fe6d9626876bc614fe00e4625bfee31a73d77f83e477b123fb6a21cb8f8c16705a30a4053ddd25fea47db3f72eb9e60e6ecd6d483340dcc3c3be4984e022f40b53c16ba2b819035fcdfd971de2d9220820acdcba1de08dc288c9830d134c69de0765090c077ac1d5c7baaa6cb7811b34470af2b50858725fe0722df34c045d34b99d2d0919ff7d6b2c5a3c6dc065f7c0289a2cb5bc0b98fc1f4fa2ffa8e69d7de73d4d1879148498df94febd296707d75f200b36e4384c41030c6490c787cf1b079deb8bc4717c50507e84cabd385ab7aa35447f596d9ee12972e3e748e4bc45d5d5b93aefbc0acf70b62e7afe599e2780ee646e4dc0eeb4b1baa6ae8a539be16385d71f519b25231f88ae31780d1ea16db87f7b5b9625af6fbad44a6b3ebfc3aeefbab576ceb548784b8030c5fa7be19295dc805569e90fbbe626b7336c4e849266313786e8ae147e9dab8f7c9bfdc1e1d7b97dab4650cef2b50e22ef651a729643e8ec852fc663a8bc5594df3ee05fcc76dd389d9c36eaf596263d0d580e63a3265355dc4728e7df056cbdf33bd20231dd76fa01cebed654a655eb2f145c527f5fee865a3624ae661a716f4e049471d77fb21d45d1aaf741b88d91e5fff74f145d6c66cc61fa9b3fae0e2ba42d8e54c9d41fbe36d4d09cb55d26b0cb8840b5b6eae955b88e0565064d3a06ad5a298997d9f68aebcb85635be9b218461ebe9f230f4024a32820a5c0c93dae08b90fc57158758c2f50017b8c75736bf5ea0bc29cbbfef839a3d38bb54abf4cb3c86c24cbffe4a27480fcd80cb7e71ca72f2008718a2ca7e10541eaa769182ec1009bbec9d86903aa4202966768175754daf97c24a39b96762e246cbd1678c5d62644a46a5b19b34e227be5c1e268411ac981e1c4c3acaf4d3243f982e620a91bb60574f2ba0e94eb76c48579790058d22cf51252d8218107f8933d4738b742184a2524933e11a4f0a5eb103735ce730bb358ceb085a125edf4137cc1988a8a6fb4d86258d877ef00a2344f028a602ea3a0f7a31502823fe5e297416d7e5afcd511a8c3495611250a35071e230e51e46de5b4431c67aeebe1ec34642f2c02e2f5b683ca42f6731a1eca3c14e1f061259d1a495a7471be0c4fd75465f40cc9042ff2f6cb0f34d6e65b26d904cf45df110f04c11a89e69f313500247d21c2d6d64eeb0a739ef92cb0db9416c654caf0071d471967ba4f27c7f8064fb04833184493777690880847d25fa44958f3d2b079ffdbd84eea1b070d2e382aba0bfa1938e921ca096e66d4e83bf7406a65fc3d1b81588888aa99dc888bd66c00f638c28f495642a2a5ccb38028c539a36b0945f66b920144d85043dc3d718ff9b1f0800b01fc89cca5fa67d4627c4aae044209eb1586771c6d40d86257b0745dbced038ed3f6b881641832b33c7fec892d7123eac36f34cf6f1831375fd7dd313fea1eabbfec39a19d430783cb3f5ce5e98cf4172f048b8cecd06b41b5a454669299237352126625d2e11ab1fffe8cd1c041560802295110001eb4c0ecd172ab78e7793236ca0e259d659b28b382077a8f92ee62736192cd9054ee9a33776dfc944543c2a2cc25a23b433ac1e63660cfae043a6f459bf4b133658bd74501a00caf8d456079ecfef2a8e7043b253c617839c5f63cf4ddecce7816b6f409d3d409e748d576935ad23925e5b54ca2808b07bafd5d5c41357faf7b2341b086433a0b92cb52a709fad4e7596aee057ca086cf41ed139410df277433d77c9ab6a9f44f0be7ee8189eac04e189590dde378afe9a744621b40a1d6d319f595f115a27e9c6dde1bf1974a9be7e7ab55057f4fd3fca76248ed9593de4191f121a936299ccb37d0c8bd7f4c36fba81a80092d36a7ba0c2d2828e7c54387fbe67c1fabf5f726e16b0b05e6b6f165da13a8fff4ff616e598b22864e707b2d94c9586c739d98e3d195c7fc57df9b5488445f9fef4dfd7122f47aa786ce814da937197ebe353d7bc3ad5e541290868414f0d948532b99b4843b8b7b83f4f6e7336e5df2e13abc2e6b5849fe4cdccff866295294009f51cdc5dbaaa0f8729aa757a06b4cdf7f05166c2169a41a0ed3ebfed41b79f204aeebc0bb89ea2f0370261a33becf52bc0613d3d68eb7e9db7c4503a4e620d6aeb1fbe0fe8cff4c295623199b1975ed6ec9652faea3339b3af15a0ab9c2b3c618042a2d8d4c81a5dc9633efd3308b642093ceaa9d100d6db9594ebb4f0ac761c50402155e8dcfde0f1605def33936ce4f0e61d878361417235c54dd59655254e1b2b6ca10a83a7a6e9999cc39e52a6922979afd6684f4323516fbde5908c76faf8233d893f3c80e36b33881ee4e79ccdb67f040b3a43835f925b1b564368dbe0584be311703cfcd950ce4b758315c6d5ac21dde214aa5937e9d278ec0a4e793c9271749d39129fe575293ff2dbda9ef533d2acc5a143249e42c8f907ac66c7eb8d3843e229a6e93443ae9a3f0308ec085636fb4ca0c81a661d692f3498bf3ee792d66a2fd24d034fdaac661f80349b7c0e13a565e02b5f6b441d7a942ff3e8b6acbca2f8f692d7c9458268af3d7be75af77dd1fef56bd34c257d60897163ed5b05c7b4ec837154d72690645720ea87ea5e2580037a29cced3be5c1ef8e09c910b0a3ac5541afb9f648b9676ba99303fca0e5f4b594facd96377eae52a89d7976a92f5ba1527194a89e692f2f40e65c642fbfdf3a31c43e09541310e80d88103f7076ad63f8adfee273ac1be353d574c382069d9869f5e8b114ca97ec00db893c152bed452cdc6c1f3653b49269cc6b1e364b048dcac4e46401db479cdfa6b4ef04ba83f7601a71b8f52039bfb1955d3cf55a52097bebf6f7ebc3d5bb4f36d6d16f8033ce2a00401ed1c41d72d03d002fc1481e3f3fe5779bdc4c81fe11e739c7c5c47889a7d4a851f21d36029a3ba099748e70e2f33375c79cab8a7113e456f2f6aaa6475eee48c7a02eab889dcf608f9949303630b761c7b17a762efbcbf591c4f9ac2fa422a6ea46b39884c021930932f2bf0346196eaca2191be8c91901990fa8b0d2c67d251e3dfb41500c3653af89ce22c6b0fedf5be3b6ab7fcba4c9cc4f0af447abc05fefe417fbc642c510e73b71a99884679a7ed8af3f72a47d8adff94f0907c4230e458256f62c4727a26f00e9299c270ae74456a535aa066fecbe815b8f7812c127c4d44b7fe97690d0a48e5ac6393b050e9ff9d48e26118b48aa7f36796c57bd8c19b6b0725d83de343dc4438831dc2a1e37f9b15c508ea97b951d84a447dc55a50f6033acae4a20e5236b0fcbbaa5e8989f8c3806cd797e55be3dcc3c0122558c86dd76e641714b558753f05bc9cfec2274c9f1b37a376105f5efc6b52605f77f183ba9ac03d431c38dec6e62b8a0e65d82081f6a3426fe5fa897cf4a7538ee729163a5a5c738e65cefa6d77b7a5fa0d3c4f501ea524a54d22a5fcabe62f1a1274b7c46d662dac432c3065072063c66e57fc9aa34ccf70a268348b70668b56c14807538df7e7a6fc0aa514ff3ac4ef1c2f8baa36f603c20f2375e90294f8ce3723e00a3722ff73713e4237892eab4714e8b92edf2f10db48855b35c785b1c48ead0d2acfa21dda04cea1054a2b9eef52dd0ca731efc9ea6e66b3139905a2bd63f9fba1e71cfafb1ed19f52e9b4ab3e08918e416f533c8d656f6dcef9b69b525e862b399bc32c123b41e943247daa78d01eb16d3ddd984172235b0a5b931386d4d6d70d6f675bd58acfe7a8ad376ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
