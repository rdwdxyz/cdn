<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e26f74ddf07c869057e8725a09b12e950e29fc4a4a7389570673148be96583c0db334e2f588c24e075fa66fe8295261254c86a489753b08df6b59c36e72a0faf77950f969e8921df975bd735585f196f30efb6b1b4f4dcec8c1657feab467bb6288b7657aac7fb0ffe744b2383b4d8e3b99976666c297c38a9bd7049b194cde38e157c7d3cbf0e9da8dd538bea066dc7ab04f9f90b5e9aa8dbfe0d5e32a41d2e88d909da99ec2920444015a9a7e40b65f232884f9237ab708e71104c10b349fb2e6cf7b63230991fb2134b98091e3f14fdbd62b78d08492b6c9f19e12977f7ab11c71a8b02e680bf3b2c701ad5dd925707f785f08a2c44d9ccdc1b3b9a8cca7177eaf72ae2993745b32b21912a6def35382a9e82836e2d6cd6541524d6e3c16e3a4ab129485a75d5f67238174c070998d1f75c08c7fc5a7f0f37ad3ad0b57d397951dc2335c58deb3f32f0248daf2cb3c31f92c06e2da5944d16d1b36ea632b1bc0a8c13864580301de9eaa28c8ac47525e1b19f5faf7b0abe2a69172a92e62ebae39597e8dec4a76300d451cbe81a56d985257a20a601c78a0c21d5eff7477805fb5853bc59b43515174fb79e07ac87a4be3e5ca8dff4047f36626c85f2e8f04ece2d415ba61a042f7dbc3247d5820f9a98aaf72b547a321f96e610742cc465675b548f2296facdab936f56418a509882166c26ba651a405d99f481eaa702f4337b87f65fcd2515cdc53633a688891a30a545a1f1026d1cd92c6210f97bab91f9d5ae4ac648b30cc2d46c4748ea69b227312b5b32d6cb8e3c81fc9bce450ecada4a14e6880ca4c02264ad8aafebd232b1e38cf16e069635dcd91d392c7dad143d3bd8d82347138d946e1de5f58b3d82613af26929ffa4f84852732a9ca0cd3e78b0b2581684cf740d0ed5230667d33dd2c50510a9cc9b6c34f9f40fd259b0e6b629a4576697c5277aba909e0d6369420506b79bb7a3e61d70deda5a1a930dcce8d7c4494a7b573acfa4731d34e78cf808191c6137c6b3a66270bbe8376eeaf1bb6ba6243362c787ae380bcead74203b80354302ce9b5d4f922ded1f0402bc2ca2b832673aeb00c7e41f12d7f8a352de8441b488eb8859fc15c0153847925058e7d3bd6fccf49439adfbaaaf59328a2fe3d677354a26e56ec3563ead6fb964caff11ffb2e79a5c887df9f38d4a49b1676af9689d667c03f5b679a5c0723329a1d95c9f1fe4ca2a07042162b4766ab5d3839359eaabd88d2750858c1165e3913852ec99c5f95d27260452a1e0fc955012da53fa06fc8ba01b7cc1b6d7fb9bcdb3c27b633b7c905e63db047f68b7cc4019fdba9c0acd0d19fcf38deba5e25949bcdbda8b5bdacb3d7c1043bef67ca100caf42d2e3881cf110ae826f2c3a9cb33952a4426aea570264dd0fa641b8ab3cba9a8bf8a90fa0c6fd09318325bc996a464610ea9cb191fd4d1e81a9552fdcfee3be7d6b728579fde1cfb2bf061cd4cfc6e79dc6512077c73917984df6ce524dda5f71ae07e547413432cf55612c9f2d32164a2af792e2ca8d5a73b16a790b842feee2d040c1ed52456f53639beb5d30a19cb14e8d44131b9b3f72168ab2e07291dc31c9ea4862e07ca4d3cea2a0e763ac7beb51e49b927ff4c62864aae8543d7ed0580d3a0bf7af0215059466968cc6779bb7125f124e5081c6697347f0dce65423d678ba1cd6d9b180a634dbec2e38bf4847eee0d99f1d2f11bbf1db1146c70aaef828a211fbb4a5281b421e483a8769003003052a2a303c04f01cdab4b2c9792ad4b64d2638087dcab2a675375efafcef4708e631d3bd77144f235a1e20d51a8836c0c53aafaec0bb54c4db2ec9b595833359017f59b00d1711e955246bfe2ad1e1d057f862a8297de17b2654912491e01e4fd03cb70ce0e1a42dcd5417bfe6452b6bfc203bfe6a1c05869e031efffc0e646b66c04822d41aafccaba761e4b6a6810f35db1cef085e834d44e988e1ecc788de7c4a5b00bc5ce69630557f24021f2564acda4e29368b388c9a1fb7dfc77ba0502858f33c3089bbaa5ccd4898a6e7c24ba90028b3ccee01edc7f54eae67365cc401e050426399952f9ee37dc86add58ba3d45943d687fa423192de2d18a57e9e0b536794ba8cb353538bc3e3eff3775ad76d354153faa1dd5b17647ea21db5e0720619b1b8958a0455103e9727f69033d7c79f3db195388c050dfa78de4fd4a7b68638cc05b30975978a6fdbefda779c0818e0a7826d8ddf199de52dbbf8ee5c4b8883ae5e787235435e2be2d09a107a6517a899b2a56047914997a3e3fb03d6e38ada868a37a85609cb0e5e1c2c7949efe62a9a842273d6342ada6909b1744ad338706ffb35fecbd25df5ea849c570fd7f9bfb7c0a16abd4b4a267cc7e9d1b54c811138569c2772cd0eae1059f8cabd3fb9fd66cdc5e53ff8c7fa373622a45300f05871f0c2bfd8e6ac6e7090ef50814feb36cb0ea3095c4aa609afa2c08b8bf70543e2c90f52521380174da2d063810e329c87eb80454282e04cc7bc7f4553fb3940dc18e44027c193f0eb6826a179e99eee82956a12fdaa687e5dc0cb5040896fdec705221f6802117c6d0d3b3bccf9aa83501aff73cb176594e0ac5fabbe8a0c15e8165f9bd2d6150f2b4b9b006e866ab0313dbffbf44b04f61a73a1ab1ff241cd067770993082f41dd8797f0055763227619bbc3adab6ade86252a05dc78269ded1c207a5d8af5987e4915e42734f9473b299b4f85c7bb880bc9534b97279e4bbcaabeff874d1b737f5b5d66bbe00cab75709f0ab78a2744344b1a579af6485d8a2f2495d217bbc49d78d80d7cbf37249ee0762ab3f17b667384b640c063cde63f5b9b8be15b01f0eda072f9cf6bd5a3ef195a841a6e1dfc60b31b7a352937f7c63faaf7ff3014eed7bd3e1d6c308ac7e790f5be239a56fb3942c4c28d924ce585b7a85245e4800ab237ed7b26cd157b3543ed1dc2d6371963cb7c5966e59848d00244091c52d2fed8764dccb1ce734e4d996e3e39b164221bde0f60586254f0e559a89a2c995fbee281238f15642c6b5ff95d2616f3e44368774701a29256588c596f347ebb784085799ee36ce6c5fa5b04206cd7ab81c0eff32f434fde5dc42c923d24d09f26cc1ad905c28a9d771506971cf2bd1d78d130efc9fda214d297827d36cb3e783f95485a6c572e4d38e591b7384d966325491f2c345e5e2282ab0ed138d097538efa4921760b9b6d3e0f2f4b2fe18a0076c728ab19b09bb7be22b23b5d8c78a7c4580b2d409bf2403eb7c65c85a57ad4cd812c5e4589081540fb037f6ff769093fba04a96cd47ba8197e31dd15a0d8e2791c43191194eaaa7a601985098d45e027020cde8431491aa3831dfdf3ba8c736fb60bcde8b878d8da8a554747129e9733225e41f7266e02b9046291ef8ddb59b4b8bbf40dc1284e3f79fa8a19d3c400cb957a7412916a303b59c2c728b54d4f0f75d964245180cef292181919d273304a2b934e9a8ce5a6d7794c68f8bd0e33d1c2874ff1d7b24e7c1de497aa9bdc73556c48b3fad39101782ae6e74a559c37aa903a46145c6bfce7958bbee26264eacda38c4e1a35f239bb673ee79fa314a8559e1494d3b21590074f772b983799f97ffcd2b1fa4166457f61cad6304ccae8eca27047330c154cdc6966b5f47e6597e9b2ee231fc34f0c1049fda6044d04506c1f6fe4d352a6f793e71b45152199229d3f0bbdc65b856cfe2f1f79ade50f2b04fb316aae26001a9e002c49622f29624e8f3b84eb5ea0d67b4edc0391979f9f2138a26badc713ca25f9069ddb81ebae69310676a95c0bac21544f9af28d990397cb6287e42926cf2dd025fcce6805a6c829c8ac2e6b3b30e406af841e90299331e9e1296aaac976b61bdb6391552d537cddd72de271c7956199c1d9157f22f2f445fd17bfe55538a18881f3af9eff093f217493b55056abaafbda2b6b2e2d2cd006782c7e97f0fc9926f00c249cf267a1ccad5246f8f435d0e93659df22122d5844ef6b9780712d89037616dc5dd7cfd7a8c0be8a4b057bece1150fa2eb9805411bb47b93db7ae51307cdab2be191bd939197364cf5c04b2ba6e858546803aab1ba13efa022a430d35b898d6e782736cc15c77542f041dca026ef0157d1bb67bf39187848390222ffd1c2b73fb5aeb38b720da4c3aa1ef44be4a1a09aaca69946f526c7ef658014904fc6b34c5320b3b830d1fd7f1c8766f7642442d52e8bc546cf578dc7d737cd773ae60d14a7e97118a4f93b6e6f46e0aa88dbc8f059e12d7ad94752989e7930d98c59bcdd9c743efa1639a321ae2cfd0d7b18425dc750165815d27230865ea4c62906b5beb8c1d1a06ce1aec28b691803ed4aedf5a8a9e57d21b94019dadb76cccd02dc9ead26aa5860963b063ea1511db988ace34f6b23bd2568893f3371d4d442ec036066f49ed7a6258703276420b91576599662f2f85246ee8234832b3b594f19af980653eafc9d1da9d908fbdd7450bcf24a94aceb1a1733b0980611c02d2d9071bc7d18f0e69be8ce854a2b7e1a02da95fe13fb0e58ed20d03e6fabb6fd96b3f2b8d463ee5d9d425f41d1c57ee1f6503e33522d0dffd0b0da66da54ac455007d47c952de79d4ed0c49495a6b9186d3e19a14eb7ffe0a30e1f693dd8597a9710c5e49d0d81486e468c02ce26470a1757b3303ac7167f8f82295961987e6f7157fd8cc479f8d2c0624d4e82be8a412638803d1d507d2e6439ca2cab244906d16ac097bebc4a9a5afb75fdd495cdaf4256857ad3aa36191155fcc62b50d217b35fcc9f9dff4ee7c792714b54d299e145dd2ee4ede85ec7bc3ad515dbaf99b5d47491ed0b4995d7ea6d37e9722bc66e4f9434d847febbec9989e73a127bd90093de5d570d20572d180b0c34d11e25440aef85afdcbd542afa9f1fe8f15e73c7ac9850331e546fbb5fe856cd44d2a99bff2c2c18b5e158475b13e6d323239df31a6dca30b6896202bbabbb03b6a651bba1c45f123cf8c0ef6cdb90980c09ce460ed0bec4523814f5a4e3602babbc9eec43ea111c10a2cc3b510fae0ff3c1ce9dfdab15a9a3025364c92ee0f889c885145e726491de8416c38f2bc8521caaa3449dc4e836d4b70db3e685a860a75d9dbc6d55284c7995a4e707f55653f805a1804dbedcc0cb50bb9b2ad00fdaba545237f7acb7acd026d1b09a11751e9d6572626af5832979e1da59fe9ddcde7a251c59b740540590970ac5005e9a14863fb9a1271be8958d1140a8e53f818fb130b7eaddefbd5c6637319a3316c13c6bcd78fcaafa92ce2a7bddc19f32b3b4a5cbaf79f7fe3c29b09f01909e8d4f0393916168f8aa5b0975e035e45360bff58cfb68e1a411bbbfbb4704440c7b215ff6cfaecaf22a916980955e093e8f381c6a292de65c4e8512b7d483104ba8023d04b32f8b0935116a6e7394a13b1c976f5a5cbd11516f72315999ff2549ba0a69e4c16d7cf2be4f5aa01366ebe91a88a953ccca4c850f13f569aa97eb8e69cce507d70017a8c9bcbd72841b26f23a5970175837f42232ab621e8b217bc74d641568eb7fad8dafcd1ca2998200e0be98705a7bf4194fef66247db36ca0c016f8cc6730cd0d8c29ed11960ccc3bfa19fe8423ed915843942ce153b5142cf90fc5c8986d6f675f0b625a424df160b85a94c1e00555ec049b5e639a9db434385073feaed56852fca4b513748b98e8119d204dbfbabf28aa71831d7a9871a15f8ba611cea37edc5f678c3cfe9188a9e3944f722fd7e65a3d9d1fb5bf9a88968ceaa43ee56dce6607445245836f66097af88a1de73f478bc687184d6c4e8fde6677c372b2f8047cc59779ec0304f1b1d65e50e90e71ea125652df1450624bb601970b37fa157bf3bd16f11da016a72f1189368e9703f986c10f8fb1445c62fafa21a4b39611e3f7f3ca21bcb3bfe5724ef9fb3569d239a0509a1cfe278927b57eb44f897ecf3ff4bddf94a8bd4ad634e3db5123acff1d6a030f4607d79abc340a36fe6d1ad9dd33a193acf6bdc14f9be48f8d948053c6bc29cf74ce7326262ae27fb029330471f5a23d2861ed33d0fcc8b7b9e8c02a99afbe2ee0f3ffa36594bd45843d02136b36b642e9312339c7b1df98ca6419aeaabc487e93d349a0d87021abf19658d4ddadf1a76d49225ad3f448967772787c4fe63e6aa5314d20a4db60a39ae6bcbbe72daea7f4ce709e4d122be253eee708a694ec57dcacf3ea248cf50ead3a4eb6366ef14038aeeba1b8b7934a521314ebd66f97e51930eaafcefbb59a6fd803a48ce1b88aed4ee9d806cfd5bf8359a29c28c636745e3135ac6596b137d46512d83ac1e78b4cd026ef887a13d0576c17c65eef67de25504fe912fe67f5ac62c4da29d8ace635f25be8a68a02add492675ef9b4a03c876225da5cf8d8a547740dfc2090d766ae2e7c642bc1966861554ef9a8dca5be8a4348547ce7f20f6493c422df2ecdbbfd05819fe83377cef93bf8d064cf9da7cec0659e8dcb1307d2b534a4d43636eb424c4bfef10668e5f1c4616a683f8fe7bb173cb51006de3c525d19f7d4b403d7a4e0ae6eccdd429dd73e3b5b8b7629f8540c3cb1683ce5a88c20b5b3fa87d7e9ff7cd33713edc523847708667dc786ba1cc0db5ff7be9847389680b4c2df348693397bc0962d3f5ffa4964a8c4d3535dbc27b9e4f742b13de068a2ce34e34081e53e780799a5f88ce3da118bd34f7fa202a1744d6f71bab713d69e6f4963235eb18057033f6256fa1a8a0fe4235a5b1bbfdf9192fbf8fea5011aee8908eb1b487d7265b1c5ab1febd120c4ded460520a2032d89930cea99fdf5ccf6e3f8cf18af81424c715b14da5fc42ebb04880daec8b758c28818f2835a16e4c9bed06a2292eb958d93c4156674062594dabbcf3b0efc865da714168eda1df0561ff40e8fa54210c402b99141aac6adfa5bec5dbd5d43d4d1a9ac48109507414378cc350fc08fd63025fbad26b85e505c4d66c3be08b6469de53af48aa2b0b94ffbfed37988876289bc32253a8fc81a6f6afeb08dfad4b61af61ceb4f771097acd14f329b81a0173523b335e7d6fa3a68bf4f4581511e0d3c11d59d3510cfa605ea97a60e9080bdb9a81b4c93bda22e75d3de941ff0dbb80883aba90213019f21a88da82c3543087dddf51d0ad8ba74d75f637da0437601e6a8514a1a170788ac317f1b2438b92d74b0b3b290195090465d1753cbf1ad8990c385c15dd7f516558baacc867bbf46f9d9460dfb3c3f1245b62427ca7edb7f60966e5441cb9fc453f6c3ae4eccfec23bd4e8f65162587ba25527fd743206336ec1179cf638764707648f699a46c1b6275bd19e550a4b75e438ff9cc5c8b7336b19c4854b3e18c0eab4b1507c2195025f8e1959165d4769572da3c9370b2e8ea4e43ccc132d589f469af4da02a160fd23bf467120ef966b9ca7d50c84363e795da4c4a77778b8c6e641a71087a01d86d05c00cce7aa5f2eb9bcfb560baf851757fdff3687c7696c49c4375717801f4edbaafcbb81e8c7a76ab9d01fb08dfd873e9dde5b359244994bcd660861b289b887c536477b1bd77e692037bf5533c61478431f076d0f88804f3d3e31c9c820f4e613c9b0ed063ac727e1b5e3c67147fdf6d544c786ce47fbbaf891220fec0dc9efe829e2b419bb204b78a5efdfb889da9ae5c768905fed9ffb9fc904b1e19d7fe689d0959c7df415aa6c4a68bd692ef370e8bef1291dcff30b4e1e52732be31c3dc8fa5d6ba093557a20ac083a231cd81ff80ba418411ad2f8a3cb843e75dcbaa3779db45f99a672b6223859afbd050065280c1466ae7bad0ff74a816ed72738b5a039006e1e3429cf560814cacad0a03a985acec87e4e04d9c074e1911b785f90ff44c5d6834a54cbfea920d0668a61a300babd5afded65179955e660025ff55f544b3881fb2bb04cb8f6f1990ebeeb795685f18aaeefe320c62feb6f48c4711a41c5eda65dfb042c20a9484c3947bacaae638fd4f27225209334271aafe88b2dec20f99c44db955d3850beed8a2f2d80361769b3c50cbb66f0d40998a168885cbb7338bf1256272a32fc82d9a0d489edea26feea2985b0335c033467a68b0e056f9c2faa68cdd38eb7ff8635d78f4688a7ddb54afaee6338ffdcb5f423265b498c70dedf5d029578da40f976642ff2b0a025dbb757e3c3c0f5fa017826c62e6976ae908680f4b1f4b48bc5581217dfc5532f6502b776de166717d42a685eb4affe28959700f17560cbb065707c0da393c1c64a2f82e3ea60465e6fa6f6884aab17d588f2ac986429a8b0a8d2f46ca4935d1aacd6dddde4962f0cf1da41699053ba9d2a668a40cb745f90baeaaf49d9bc840d308e16d5afd83b0cb43c01d7b6e5ff5223f3d612f2f7af6c36797206919b7b1b0d9f1c68ccdeccebbaf9f97c16443f2d83c612effc82b28e6ef6ec3e136dab6d876b13acc4ed8e2334ab9fa8d57dfba3eb9095ef4819d5c004cfc05a1de03ca1746c2854973797dbb2e73545d114ebe06b0332e7f215f6eb94284fbd06ada5acede93c1c0536f409d6dcd808e58d27bd52b0667cfb08124e12ef529942ad90c83b239bc03d55bdc7541a9d4f89c661db654101849afed31ca64b653695d65dae83d30119b8296f2266d9b042162f3e59871fa5948268b197bbbfea840da810c5430bb6db10ec268efad0eff07df39082709503cdc8aa4c621d1269fcbd21cb7431eff4a66de094e4e8df9649cd0e8575fe04e3670c5f2ddf06a711ebbbb98ae25a6bfa103b5ce47de820b7fc18deaa8c90913717556652f6ba3527be4b823844f5d02c88c0fd7ddc161a51305456ad75fa5fe09662babecd73ae5d572ca56cc3a29a49ad112aab979032657f70909ea5a7d5fb619a9a2f4fdf20c69e340489229208081d8ddd7e77d3225cdad080b275dff7ded80482e252d6e11f72309bfff6764ae4ec226a1c039fb55ca5ce03d79bbbd2b83873c595e22e52fb36dde675085e57e28dbef6e4ad80a17c67fba67913554027c2925b69b2caf89b60cd1cd63cea6613a3bf6202ecd08ab8d1e70c611903ac812096e7bcb07e2ee53502276f098094bf1852f5144241f0bb62c01debe3bb615e958a0f4f7b0a03907b04ea67f2658a7cfafeb8ec013b3aa54ea1811ac0a51bb0acb2818a1fa9eb6cc13df1f9d45bc5570181ab01b5c88317114dace78b822091dd4eabceb64cc7b306ce24dcb2d629dcf25bd5c5d8abe27c125d85b524650353244863059a576776aef2b1bd4c6a52148ba501d01fcaf7b1b3ff17d31ac87a2fe104c0e31d24df9e2a89c65a3823bf78aed4c89d84773e5a1769a9ded043775abb72f4a683896dbc4ee600d87fb3e6fede77ca239978cb13db888df95aada75da64fb0b4c13d94f8ffbf4e8213ce3ad2ad60037cbdd7a04d2b86d0289cbd9fb64f87d20ac3cae38336dceb29c9c991a75af34c46756b4d8d47d5dbc4d96fb14d03a2508b9581f3f52b61b83611ad0de3f8009c10f989a6d46e0f6674af60387abe44f33e03716fab1fc4e28b18cabea53d6f19c062687d544e3ca1f9a8d5602d0bb178adb36928dfcf610f4180298e998700d411dfc14b84a698545c99947796ce4d2900c98e9c1fa5dbbb3d9ac93eab01c3ee8a76c8b242e399717dac1c35f28cecccc0d005e1dbec7bd6dfd0b88e3f45e7b19ea10f23f0ab091343b6ed4c6b4db834cc81f7867867b114494e0b262f573137fe9291b55fca2c71295843fd62fc20e54f23106036f870415804273dc6f996bcca0ae65e012dd43d6acafe05be2164903052d741c067a46c56f953076bb43a99b57c0e320306629bf44a0b3f9bc6671c5c4527a66e0644a92c8186f9d48fa3a3177b6bdfe97d8d4887a9da7f4ee5a49611c360525abdd8974dd7fe28099a73819a316014ee5777cada2a45e94f952cf7cb3cd56486c6c56a79063ff111d7bb854f2c83fd9a967d7fa82b5ed634921957947e04b0af513a0c1abf04c3d8b912e173396e2b6589a1c3b317af33a894e91b898ca26f4a873c658d201550bce43f43c6fbf771ceba76da6da5295a26cae7c1f20b1acbbff905552c61d7406682fbec7ca19e5cc49e558bdf0c6d4e1b7f4cf2f374fa6779ded20e36410a21a8e5f602bb8d19644dccc841c30b356c9e6d4fbbf60b4d2fd8ab06271ce0ee566e3dfa60c140e89b44c84e637e36969f269568a0c24ffc90a55b745c9e0bac5ace01b5dd90bf8b634bb4f45b34d86b03f39fc7b8616b3675549f2ebc6c6e8a73cece511e4a49139d63e85c8ecf1abe8abf5666f5e02bdbd9bb8fcf742d9044ada77e5a337a25242a9d2e2bd3977cb4b97b15be41e9413e7690925adcd44ef2743829d7139e71ba840ca1f56d5c4e23db0f2f79c3a974c18e1a43cea8d465a88f29c6580f7211e69ecd61ca0b72fd46176d6dc512620ffed054f2019626866a381a1f2a25854e8c358ff9a470f88596625124f8b8ceef27612d332046f9e718ebfebe7a73058ba70c6cace07e430e62dd4bc626f8a7f94744130b47ea57a6b5b3ccfc40b918ef0c799ea2b65d04f0ce154cf889fe479694e695b226732ceb5407dfeba7c58a34be8e4694d045204266c6677bab71c6553f720a3b95ea341bc0bc4df78f855927bb45f98495a42738b6e6f1f57dbf3ecd5a2eec032a71b779167f653aa7f6c06a066e487e9f1876f8af5d5a610c1039f678accc477681301202a1028d235acdce4e9c689997c925af848d7db01f419eddce744863ac49330815ff47308c8d45093f53677ec8005880c11264ae607dc1c67b7f847a572712d8acae229fc909be695498c495f559ba4bd4bcad81ecbd713e21b64ee5a75279a6985d833e5d3101efdedd098d1f340fb7e617056b6bd6b40df477c95ec6f7c42e8d23842825ad4f3f258cf4c8345f3fa202ca30ea47dac869e76d35ea888794eec24c6530fbd1e554e032f268695c79128e95d11050fe4be45ca1b167e7c5ada19eec800c584a578ebabb9e2e603005d28d8175f0d1c448dbe44e6e73054f4a3e1eb46d42778baeaafbf4a020aa38036a8d0c0377d80e70a8ba310d6da1bb2ab5b0acd8414caf24beb2eb42b5cefc0d798fc2cda509cf14db00b4cc9f9860931cb9de75bc7bfb015634878c101a87bcb2baf7ea56d9381c4108444288ff646d8ed3f324c4ab738d1443119c5fecbb364e7716208ced8d49946e0dd28ab307d31c2ee3ab5c23b335b66f4a6c502a134017336211c83d3e9add5d6e2abef7a5ffe858eb6bb7f520b9691cc45ff127c1f4ed0c45ba3a4731f6052e3799e79024dd8fd9ffc527af788b909d66bfc7c751995ca784487bd18c1d42b20d4db89ba068c2fe4396a02043e89407f01034f44c6a8f10f6fc4178bcda41fcb3c9fc43635e787c8416a6ee6cdb9b21ac9f0a5afaa4aab4863077fa194b0fb589b486926037f93a4707058db0dde95449eaf02c0e41a0472c44b78abe3599de1f16c979e70ae74d4b9fb4a55726e2ceee272086124f24b9a71aff71a83da1c425c0321d19c3aca20ede478e76798e23583170052ce2603b111cce4ccedb792f9d889a4c842bc1895555150cba503cbd26bf016a3b1f4b0170f98493a34d9a93fc7e7236c731d8e29acda40c9459cd1d8896711dc1b4f311efe7ace026d16fb7be33c88a586e2d0b788d969800273f8c84699558aad62e470a07762631fab1b7eec42a93b22eac7133a879e8a5ce9d9306ee03b516fa4cab9e7110f005782e0d78b5c16fb9f5d56219560c7a044d7232d6a9bfcb7561b027402623e6f9f151dabca5ba2d39484664d317ccbaee5f84f62a7b1eb4b9834a8a4ce9a1e4b3a100941e3b48b67e3a9718542cb1b6b14f3807e8a10f91836351fd04b4bb5f66fa3b623cb20e5a2e0e39e0640946b14b53c249096c4882a753133ed438b626f14052711970de5aa9bb3632bc02a903c57c5db089edc7189c006a3cbb8878104186924155c6bc65a99dde397ddf903630a492fee70889dc1aae10917c0377ed064b9e2507332770ab161080fe0317bcf46a99ad3a68152d33c4d7bccde11e4b4a24a1f40662863591461d6dcf513e00a51a7edc558e793f2650005e2b67be58eb3a2b5418e77f39d46c6d97e7886c15b9401a486c2e7b1562742057134c471478e6a543cd69b38e8e06783b143a93c2964e8fa855494ef69f7ba83852815d474e6ecb63de830437ea7fb8d35730fbdf6fd0bb4fc5bb6ce3c5690a17f9d11fbebb240610e27dd902ffe045ee13ccde06f78b218cb9d625557cbbc43ee23193ca399931cb35384f75b32dcbc2d15d090be1d6211d2b57798c05208e433c94fc68fecbefb9881ed3cd8e6777a6278af3788dfd14594b36784c89e0d04dbaf837172fce4bb0aec00d538dc7a764931dfabeb0246b2c8f84205914658b45128c9266fbc042e3a4555d7026e04d8f24a050e142ce6cd2d9a63fb1bc12cf3f87ec3669632aa699ba783765568ee5535d4be383a17db8d4132f7b8ef64bc21af40f28bca17a547d131939cddd3296319abd42bc93c8c044f6469b61d7f327f9fb2513d7a938452134c00f00e342a20a6f9d95b4c535b8f5e4a654c93be3a1268353d9cea2752925cc048cdfbbd84940788a17451ee2b1e54a9b49eca84e53894500eefce73bc18318f22476bf60f40ce20185c622c49b047e113f21935bbd363a8b49b66243539027fcb9d1e7342e219b45b1a05464f6db288d7ab978ab49e857f6b0821a85e36bf4da21c2f63e1a5dda1fb591c522eeef7bd58aff83f3e000e6da51c12c3d0fc028098eb3967d6c8b4cd1cac059bd87bdb05494dd97c09d83f3a04783db0977a8a255ad38ad09375221f70fea26e25c44f2fe1acfcdc90476ed57e42197bbad45cc35ee61c48e28d80ca9f6cf23ab3dfc9133123c15470be9961d12ca25dbe94e49bf602af30dbd0160b7dee935f51b3dca43a5436a29c9c9ac87547b2b717ae675e559919af6b3d359e89cfc1faf100d88806877cb0931b8f4dabdce43434ae839e5c23f9341946f4ccb88c5712754c473cfefa84e9b277f5c8c1ecd67ce41ac72d33dfdce952f06f6a91d22e5b7cfee680d3b89f6eb196ba247213350666482cd57eee1576a8c06c9fb803b4f088fdf1a5027b3d9dee635e550e8829dde3d1a1aaf92cc1525980777e0fee0b924c1d8fadbbcff0b84ecdec91c5d69f3664f5c23296ebf056f67850c1d4f334265613693ecac5b5cf96dc9092a8d4b31e825c1934bed6cb9835a339af5a1f38a60745bad875438879ee3078460eb4c60fccc1136244eeb599ef12802063870b7bf3869a9bbbce9cdf2ee4bbcb8c44b9f3c0d8f78cfbc9911914816e377dfb8e0bbf65e93f9ca9478d336652b12f37272002d995c5b72d896982271d3ce8f473d9cf7a4b7f206c8874d37682c8f72a2041fd984d380c1b9f9f0a5a3a1b1da0ad8516a7072cab412434f24f7e0af086c1a09ca0aa7140a81b955f458a008015aaa542e07ef3666484d6178fb917ffcf904f39c72dfe838d8bba6bbedf92eae7fe1baf955c22c9d638efae1ac80ce4e192028386a334a97aef03e0a9e58bce648a68ac6b9c2227eac73f72d43709ed14cb1357172a2e761a526578826083d0897dfb11d6952c0699689e69eda4db3bb6211747763959af07c97572eeec3388d21398bc87df5d537bfc6ed50241a0dcdc5aacdcee766d285d3a7339a913995805bc90637f6fc0aa9f86b63a93bd8f722f98547cbbd95a34b81d241b2942a9ee487c2a55a03ee1009f70fdb9caa44e78908aa748bfa3ab1d5a38640d72bf18419b0b3fcf1ba2bf1ce71020b69d460175a268810c12ae356ddbfac75aab01554aec34418cbf4a7518527a22062d4b6abdca86f5a7cfbb2bc484ede2704162dc1e19302a3b964c5ed7c2a61f3e8ab37156556447f0b90cac315d696c6414a83311e325f423304005392be0a9bc55c873a07f9a83cd6609499cd0e35c2f16edec0977e6bd3c89db55ef61f45df6e0fc9d302f218f52b547759692786f62635ecc44c5ec6babbcbf1055d4541ad366449f31337278ebaf9a058eaa2ce64682962d49035e4ea2bbfdc11788f60b4b016577fa474fca0c78dbc315491c69671da97a713318b81d49abd78fb15322b781e3e6faa4d1bec615cf40daace39e5de7e77e75599c4167cc830460bdbd8153eae4a60ed8f32825bff277c401038f8d91e580196b129d6227907ddd0ddb75fdaa3d7844ad488c0c9d218e3ff663fe65281e98d34a2f2ebf0ba2b1ec0311f67ade95f33e702881b67cb7a1b72fc02b7840dd4df3f7fb1a5e5bd7d18e5165897472d6bf00baa4b587c6d7d65c81eb51e04385fa1e271025f05bee835d4404bb4ef438be9fe1329b8408b33952209b4e222601b08dbcebdb9d13c567e584020c228893c17720ded9c98d9105d3daa33697c8507eec1426847e77346021d9b1c0d3ba54a8e4b2d046bc9fa9aceddb20281f3a0230ace8125807a62d8b8533b44043c4b81ff4a6760d6699ca35944d7a56ea749694891cd134c7faf3bf67225e1263d46b9bbd316030a06a1a7d09b165ef473e9e3b1fdd2c4596c7a99e82d7c6cb0c5d6454ca3f55e2b2909c7672994a233c9d8f71d9358cc2215b1aa94f1337b3501cbb522029bc91e38d003b7b745cfb01e0d5bbb7af838b04b5f527676fdefba6799a2f33535c9dbd946669631d199d9efa8b764655133fcde0bca8e078525f5f15ec07af3961ab93058233c9a760c02be2421c3df0a31f1f586a48d9b9bd4d32b6bcd28979d822484318476c47d9751f7764c684ae6d02ce7a06531449c22d5a812b67cb01a14796a3bad90fd308b12f0f78a4afe98b864540c2a7e8ed742947adf372a480f2952902dd6bd57c88bb0cdc5d0c3090c3387501bc05a9a7ab91dd3cbda06a6901ed5a7d332abbdcb1f2d1026ee4929861e2a4c390ae232eeb62ab1a12267279f253c9e3c34415874befee709c7feaf1e7f09c3d22bf143479e33d4a68502ca4fcddadb7f0f1a6e29d3f15e6fde4b2df694b46ca2c02165215f046938011c92113adc1b5795dd2f93c4b1a9ddcce702ef23df8c9328b2ba09bb511d9297dcd5c4701647162b060c11c2d57318da83d77d8233a9803042a74b058da2f56ae8cff36b8976336e7003b8834a2a53b271dcec1690107fddabf1a300f4c97f7327ba9923687eee09a39d9404e58a9222f8e55237fa55df41cff5be4e0a5190eccca11dac6923cd4befd65148bafe95dc8e3b5b326d82665774337479e1a7d0e2c63a9014b11c5095789e1385a4274f1044294dcb83bedea864ad03fa3fc56c332eebf01c1442e2ead3147cc5f162f72fb9d66485d1d67040dd6f45188ebf45b8a65e6bfca40450e64af41dac27b883205bd73b4f1d2e55376273c41dbe3f9ab67b315fd2ef93c78bf96be0de280bbed6fda93563982902f7394d5c77147e0a10e12e133559fb4c204d39f70b2858f9ef1867b6de9e4640d4272fedc1fab3c6f125b5bf499505d06fb7b1e3f603a1cdd79e1e2a774993f3a0baf0065f49b0ac0e3081c73ae886ab3af9c1d3eb407e266e04776bac2326a02375c9daba8e3777d92717048536084e236967b8719bae8b8899c355c08b06e3b026a7eae77f3a33cf04879a5551938eaa77e9cd220e89f18aa8cc169445b5c3a7102b4d6f2c984e1fe0ca2a466e32526aa3b361b37d936dc77c4a5c03ebdb3c6669a6cdad45c8fa236617de21eda770570a9992e7fca2ae5dbd2249dea3697e48ba9de47b8a8e9a58f5994c7c483a015cc323a1e6223ba2974591518902b2767eec7ec9dd63dab2a77ae71ed7d66e084b9c4eedfa8c2500b4dad1d37f1c39763b9385aced5a7c44a8a6eae658bb270a300a9d7ae1c3d92e3a4c96449a3f18042318eaf57b4e7ab7bd419c245869cd694e4493152ca85f099fefe089b80724211667a736eb9154e36306f282416ec9c3547ea819b6650d2415aed1c79197d4564d986cf1041fb132768d07728b2aa60bb913a7541f3682de78726ebb14ddcdac961bfc21101f281f46b5cfa61c9e98fcb54b87b0bbac5914fb731ce1b6826714ee3134efdf1912382923d50bbd754779aadce167f94916fe98afd90d3e1e0bf4b55bae6ad36e293fb108c34263ff27d8dfef797a1d12fc84b9075f8695851ca0045e3311094451ddc3b507692507ec7336aff1cb5f1736daa4c638c6daf7d7e5502eea0e4b6c9f9c8cd2b2168dcd1c254de1f282c609f295a75213cfd64492ab05f8d70b3ccbbcde25a41955e24047c63c9612ae2a1d98689e2b3e198e4b20d224ef89f144a1895dac4bfa42ef20c3e63145d2057136bfb8e2739fc8ce65a1415df4ed95d12d6832fe75c3a3901fc7f5f0faa5a4c0f4db5ed6d16a9a40bef483c20d5d95b18bbcdbd9c25c82e04f285847cee23686e8c956c21916378d1a9f9d16147f72016c855ea4592393c633f6f5a513694a7870d9e1db954c1901e93db03ff1361ea60b08a16234df7b1043e534ceb7bbac56d2b8e34ef921ddecf683fd81f711a9c078ebb7ab3a9b914f448574b289462e7965085b80df7f22d5133df37fcfe8e1814cc1b17d80c55e60842ecc24d6a89f7a09e43cf7c0e32ceca4c7a8630c358ddba60556b4f793ef571f41eb6e39c907bf7c0d63a318818aa2dd60d9936980b8331486010e1f7986941b1584923ee955aa5f03daa438c4afdda9a3e34a73710c218770cf2ae797167b80e95da767c4898a34dea6b82611ac0cf689f552e0f2ec76b748501104653ebb71d86cc1a62d6f1bd3287ca8a1e5a7a6ecf3d0add0ef109d36fe2053e7f7eb5bb6e5bfbba245f489f831aeb760f99e72c1488d2ada607d98c153093fc8eecc98b337c6017c56a84cd5061f9ccfcf4d827056f20c5a28a7e708e08c4f11c37029f8a238628ab7f03e2437436561399b72900c3f4811c2cca68c6c9b038437da91425ca9af018cd259c8b51d2a990fa0550a2c7d815f29426941640ed950a25dfc8e4fcb15d7659a922ba9c11702512225f126abb4dc0389decd7d674d979b176854a76b186b1cc4a27e3379995478eef06730ba02ea3e342ffef44666c44c069eda95d71f09c48034409ccc4edd0a5d8c203982f292502e030a081f2fbba1ee5131f7178254daa76beb9d69dca5c56526b9e6ea4f2a15f6128798f20f7341e40abc199fcb30b4d6d99a295989eb34b0b6ad5f1a5e7a924bf66700a0922652bc04d06b7aa5586dda42c472d2ce606a925050a5036767e8a58dd945a5217b676f1e0a7dcf22e0ae2bfa8736cdd37f24159de56481bc83608a507da7ef2305be9ad3b51942e38c7ba1c5471ad033e6f20668280023f75205332fee9ec55b764fb1e5cbe9611e8a804382750d1ffa7ab51b4847f5157249a202149ec25fbec82d6d677dcba2a2ebfb1530dd947a773b7d9aeba94db8a913bbf2c989c6d0894b84492ab3001907a738bf752fe1a3461dd2a4cf378efd979ff73da93710d3d55233ba85734d424bfecedc87c9720d093a0228f7b279541aea316898f37b17fb436b569f78d0ab92aa9370ec77da2bdc336b8e33c04b26698a7c00caddaf1db158febc28f418656c5b5f7dfda1dbc9461c7f9737776d6b15d04a649a41453b63bbd3e80e402ad3def0f9af1988d86f91d63407742a00859f2cadc9033084713079d14f35557c487947be3d27c51d521530ea453001c57f56963e254fcf67b0315ef5234610131c4ff0384ab410d58776f8c36262f4fdce8afeaccfa5944f4049e63d1917e7b5cafc068639cab845982d2fdaac789091b9134c1004a0042e4ac4a435b52e1a0d8f6b36508f19dd4a2a65e564ba2075c9514ba1ea3aa11ee485c057cb342dbcf83192423e36008d3a6da2d8fa0af5cc99daf485746b1f88c8f47687f4cdfd013870845fd6d27ad5ccff81e96121bf7cec59599a353dfe98b3cf33af9ccb43e2abdd3f1c810a147ac400759adc3aa6e17dfe561edfa669b3f19b3853ec91ec208cd94cbbe3e015a01a0153b39774","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
