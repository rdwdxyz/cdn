<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b88d4109cc362396e147867a4422ffa761319a00e49c9114952ec4abd5ca95a2cc62eec6f3bfe20cef297c91c419b39d666c5c406a5385a9a614bcf09131270720ba30b0a7de9b8326f278525e729fbccf75467abe0891d48bb69e0af4a2fa39781c2c6c4f67b8107978e1b271e9cf08e37214e4166e11898884fab7a290277f79d2c2205238647e4ad9f1a2ef3e385a93e9eec345b245a7bab33741f4e08074ba40b5b0564939e8379e903e4f8d2aef9f134f9256cfd0c7fd74506878566211e0308ae930638ef1e1c1ff3705a1192d5e62e1d9ae44c8bf6dcf98cdb1dd010e0424d845402f8c79fb04626b6864894c53bc56d68023105843d315700fb8525c2afd0b55df0cb136a8a0127f4307c46a45f311612c1aa88430fd198717d58b9689da83b805911ace01b8289608998dad7fbed886c766040b8cc74644381ba00c2ab1df508d346b656ce121c027e091ee0eb542c6a7382e976cb8ba697b4bc77dcabf41171a4be59e754c6ade793185a1afe744e39bb5a02c2bcffc21797259931a37a68663d0a40d9463ebf8659d38e931d75480bbc50e3b0608a2230aef1627791e0bb63e128e9f4b184cf970cf0dad9ab0533b61bb141bdb8154923521cad155bf86860a31a7611fd7360f474d838f5f3468250636cbc776448f4259d1d0da3175f469d26616e6141bb6fcd049f098cbbe684bdcecd0d01b45cfa7bb44d48a36e74f79ea983bb4b63db443e1bb71f97688a2f947ea6d8ebae40ced71e41362ac81a6339932b330d63b8c7a231de7317c3e338b36c68567c970fe8904fe6a8095ad018b3e127ed32e7a0ab54dfc4fc66bafcaaedafd06f334ed066453f3698d286ab39023c2ad02b7932c9f325c2213b3e57fd53a89a340cdffe87cf070c9b7a4e9850d5dd121ee5e07f29800ce76b7dc36f8814f3eecf8ce421cd09dbb1b2e35f50af2b44056b12d9b79cd721e63a7b85b967b8f8f70eddcc4e49da5a638efd589772e1e3334c26d72822831345ab8b29ab7d4e22792cbab93f2f513fa232bf98e2e74f372592d45b2f4af9830aacfca5370addebc5b1df050be728280d792a489dacd032a10a232e8092de5893900d3d14ac66dcd7f286235da56b41881386d511677f341c34ef6573dd981d38911342d78c48711f28612998e90994b7e706505aa5ebf878d87ae6b459b3274cc95d38a31f279a1c94e72a05f4b53ab38b926ed04cbbe385b37422ed01445f1f9ad5b52a7c0fc0f5547eaaec5d878c6862a932628fd5baae339a4a8184e72c8457340a6865f4062d16261d7cc0a60e8c015b6593f9b3211e6ae95c234b06f9a36a8f9f35dcd097058b97282fa997ff2ea4a2a537331c18170560c07da89ee46ceb1f515715f2b520e084bb678a8e5672fe68e3e992856d3ca8cacdc18012738263eb705f3cfce59bddf59baa39929368b79d2776a0a17b42f07945e04c0af4fe6c82ba0f291edfc7af66e32a7724ce427ff48bc79eecda65ee4f5bfb1165de389a8d8fb93f8d43fc636915b1aa7d07a494e1e11ae142d36af21a2bff08ea585028fc182c1d0f5e68d72a79f6b3cdfe1428bacd58f91ee99c11905c995827711e5d7de52672b9c4853c62e7f298ad8ad978641aa744bee511891f906d6758010b024eb09f958e1363082ce127336662bd49b0ceea76951f8a1208e3db3d9c158a4ddbe8dfc61ee2dc0374f6b6711e3f8f661048dc4ce8aa90f641e6a087a20ef22b6ccec27b0a6167b3da90516c0307b393ea631204076966cd9865ec8408a8f30b4dfec727e1363507ca0b4c3a9079f4b2a7cec7fd17828a3196e4447de62b6d56de8e6e1fdfbc5ab8c22b14ab4b75d2a491147fd604eed86d0a6433387180a4e3b17a15fe4866e8f1528edfa558f25775e1fa52fa67dd85c946908c144880a2b8f2c75c738b74eb8f4d0c3390e52cb5754cba97cf373a320d00c87ac4ef8942fb69a1e6634beed30f798068e1f6f4898f5dc4c833f2918055f8364112a4ab8e244c5bb6dc391a07ba851562eaf244293ec2b3190a554485a0095d9af5ec75e131e4d9e8895f3368e58a13aee1535a5db7dbea8a544e538df0e638553eaec7e153de1348c7e8f2ef4ebbb0b74360a155c6ea2f03228932e8d019140c9875e0385f8efb3e6638605cbd2ac22b97a0a7828a7e0b5549116093af12ca8b60613ee843ff11dffb0ba8a36a64df0af62810f4cb719cbafb566a0e051ab13209c4f8bd8754e6866fd20a43301f32814d68e399e22f623f4c64bb3c2d9eeaf42746be243e9426b183f0dc2c31b4bfcd4d8487b6b2d5ad84219ddb96f45020d1086fafc0e5332ae6f5398ffe67ec22d5147612e841cdb6d49e64ebb50082019a476fa375cc1abf987ddcd73a3a78d521a2c8ca09df727690c1cc1428f6547e3888abfabfead51b85be07da8c2eb141810a734a9e9bb579cec0de7b5f993844a3e4fc0e82c8ec3138f342a4b70ecf7c44c3922db49a5a843f5537a459fe1346590b910c75a2fa489cfc080bf51fc65d516f913ca2f035616243c03e3561d7bc7f3f80f4ac6a7c14def5e8e397e72cc1417e942b80b64e28f95aa6a7e3303c78319c8ea18adf62520d708ffd426ca26b4f039fe5feb8a33642581ad132c2dc15f64139268fc79ea8f3610b47723b1d6ca4fe942c699e111053d9132bd3ae95796868ea48cfdb451d83d788d9770f01bdbce06cd6a06354811bc67b30c47121785be2390575b3ac054bc7b847543bf9bc319e3f15be4fb14308fa04bff32e1ea685aa1d9576da9ee13da11bda2fce8f61a63ad54e94a41432519d4639a3d3f725c54489bd5f8892855e616107cc1f139a2fa91e8e7e6b6bd59de19e653e5521353237a3f553184c885d484685a32379cd5b47a35b79c84a0e0e309e201a1e6aefcc7908c565f2d551482a851d9e84229fa6f962f65d436843b93e2b445abbf419dafc36f2d5895bf8bf86fe322732439fbcebb1dff7a0ab2ffcf861958f1d4c1d12d35563fcb5c9f6f5d1f40c79f237b944ed3ef8fab618255f0c322a4283f5012b84423158c53c5a640a766dc7e551ea24439ead6c61a107bcfe220b24b38a26714b8eb05b63eca6cf7499eb55d47c35350beff08aad74b64f7c9b5433017b3535780c038005ae6aec8b7b9fd7335b4ffacffcc53a9f71c99c1135c475a059fcbf7bfeb23dc8f1658c3350b3d4a7c933a8220671059c68feec8ceefbf7114b3991cb6ab9587c59dfa77e8c283fe65147507e6cf63ccd17cfa559bc3d5f22698ff5757976be5724a0f3f129162182259b7f9efd69f3d06b8f301ba0cb1c919b7857128345a9753804aadaf6f845d2d9d2d5d81f3fb2bd657f978cddb8eaae1d29819d37a02d9b351d8c67ac5db65f8a50bd224aa0abe64252e4d2ca9ba8a577a3fe154aba9e65af3f9ac1f99e051908232306f8daa05e355d0bcd024ea5178d249e97a8e333e1db0f6350dc5ec4956317c1bc8e1991a616d44b5faa0c6af550a5cd996aa74e33f1550efb9dc3c8066e5682760eb4d815f3c552402e2b5ef24dc90bb2bbba85ee27b0f7e490591527beaf628521b2215ec278612d212bccd5016456ce4d164367ba59adc32ceb14e642f60f2303d00658c8aacc818d650939f0334ad5f67e16d0b5fa21fe0db4e525d774759f432ca6ae669a3ad75d92e40ce4494fa152dca20b6b7a10b1d5ce9933847af9dde73270063b989410bbc56a4f5a24996cf2832407de60b5110c03348b7d9982c04e4dd22e587939702e8e25554f77a7bdda5e91c08bb963eb2e02fc1bc9fe3ad2f7f10de02a9ec1e051838beca9c461eeaf4cbc45880b445f2ca7c85240dd6c724c8b7bd197db6fc4cf1686b1de8455534df7f7bb1bbaef83b061a1687ac9428db1c62ce53b63602c97dffe7428610d3964da1b6790eaed7002e754f16985252750864718a27eaa76074671fb09ba5b5550f579a7567b02b54c8cb376557fe56e8d1cb0397c9ff07f994ff168aa7503b907af900053253294c37c0b6c7ad5c8000dc9ed1cb01ca9d5102a9d346a0cb7bfcf109e79572d4f908344272870e6e99db1ba3b01ccfc62963afa1931827923a3267b75931f1f402c276946eef141adb60d8d7263c81385e3d24c9337b0b6e81aa4c6490258b6c032ed0e58c6f5060a4abdf5234222bed8a3bde736ca322bb7716766a1df39a5854f4fc33f2035ebf66e6fee49725093efebc1859ad154b6e012a4f5128d64a5ec608ba13f10e830ff6305248bf3118730e7d8833f85647cce3473089580aabed9e530577cac070a663f74e7646211fad00f56a5c19ac110c9b9290a1a3e63eab284d5d34899c898561fa25067f6779e148b80794ef6cc097d6b1c2f32106d5739c77e6581c75329c2af4e5daad5b328df7443be4f76ad12d100a84beb47ad42c9cf900e82168c283dd0a82734b3e9933b3e7963d36bc057b0e576915ca82eca4e2a1b672ed998558b6b1b58d1d583f62d5529fa3b168a6919ab11e337a2a8e015ed1f935d19f0917b7d972f05e1f51317a588e5e3432e47a6a097da3f961451d888975f4756a35879fbf6578888387995032f5f56e13213d01aa3ed63fea2a4eacb24b4f3e60eace5a779dbd756e12256fd833d4ad723440f45577d0b8aacf1a47b6b1593af9aba10ea545cb36de74f4c3506cc95dbffa78fff362e3760645a89f5293f64e14789a08ab15c5a4cb7882737533653ffbfaa1704cb253ea0aeb9d2ff2ec1181e4c61b19097dd0fbe2fbf866fdcbb34410e6ceb928c33361b71957b45b98644a4fc2481f529e2eaee0e9a1ffe612115863842f3ab86f9e5727df060243c177b0c87b5f3f69193f70e8b911aefc6104f1674dc750a6e53995ba069c0b1624465c6cab36be01401738ae270abc54af5a066264b535a49c5b3ccf100f3e59b2a526cce0505f75a67392dd15c78c92da1bb88f0c9565b824be3f599f35632a251d85979d5302bee03985ffe2959162128b0defea33c536453ffd86a9d2b8eb8a4aa7ccb6543f4ff9cb62bf09b163cc22a296c3d2e2b4c15bc5097eaacb49fb797f403550262a82739855348038714d2721ca5a93352fe88c4a0e8d26e6c627e378b46bab773b1db515eb2c2cae0d4d94a297e09d5ec6b34fbfdfdc2a3de60daec20c15312f989edfe26d4b1d1a499f366df15117b8c881e2b960b0a4ca137b338fd1d281bee0019a06416a5154b5d14d7421b57c6dd8b536199549c1990117c267a3230ffb4c4b22dde0b90a9b003ffac99b9b1668cb9a81b10dd1f15118473eb2337f1f5dab3ba7a64dc7817b36893125aba306a9b76f3839f8daf7edd647f64896e60571e5cb63b289b9e955df957c658781dae2fedb67285ea8eb4efc3f5ce2f2fa5b577fd06cd4fec1149da42bfaa81fda04739fb7b209a00495a216209977df8f1531915e40e468f2cd202adc52450065615350e8ec6da306c5111094d671933ccce5173be25ec75e6909b33b1636bfcbefa9f1eb47cfe81d2ca195f755d6164147c5da355b249211aa590f5457886d37044c32d39a9a3f38ea8f38f456ed79ee2b2aa4ae0b7be387b9a83d11f2b73d9acc6fd9f1b7ef87ac0ee70fe99e838f6ec5df4003073112e96b1c7925bb0f7581fbc5aa8870507c30260ca17bb471dcc7fbe435216bdd7f146b644ad2600ea163a70731ccb4add2698e959071793df656f32d48aa622e58c4694d65d6c006fe2ab0b542e49284068694c0390bce75218c74bbd028c68f756219faf3ea6ebe7d194b1df187e09e68d3d4237d6236ec0bf1e48e241c1b21eb716d353101fd49c356d1a7ce046853ea41f512a1a8bd27882968c4ce559ce8cf02623ae21bd7d9b1dfd7814d29a71df5183ddc2b8641b6e502447c2755308eeb700785ff9cda2caf616f3833c7b1cdc0aa266ffa23f3ddb20df8c4b2b4e70671de03649affa98ab912ead95564aac66cb5474bdbf5cc9b2e0316db55064ed57c3f49a44af9c3f8f23c38293851dad160a57194c6aee1547bc432f7422a3af0ba78b62d3931b73a00f949c653eee02f3afe12b991b4702660e64908b13d1cd3e25f9d1634d6bf597c9a2073edbc67fb91012b19bc63d78e1fb785f37c1aa055c05f60e743fea898338d52c947393adb4f3c03be9270baa1854f7bc8c6eaf538bd74e254ad3fb5d7942de1299079a9c5d4ca6c4dfd2ff4aa4c990e904c95dcf47a494a3606ecd19feb11c21a9c9b403f49455ba98fb6f40f52860919ed3fd9dac18c83fcb7519430b4fedc3a38401f998439ffce1b717c42a14079814a5edd3f2fb94c53a88b9aa12d6edf41cf38147a74c8d65cd6072643c40f49fa9253543277d6dfc9e83035418235affee25e9ba2cd8a2441792388cf7ea36d99b0205c9526ea9bb6cf493a63248024a7fc8303383d3c3deabfd65b8d8d022ecbf66bd60c30aaaa8e851935ae8f5980bfbfb4010e26b5e2d7164be5071c0071d5841405e945e5d7d15ca6ca97e1041f84679e37e3ba59597d6da07a78be929e4de4bafc5967761e85142d2b3d1b0b47f0303cc40526d4e094d6fdb2d0991b13d3411abbcd44022c8c48e9f49e7a097bfa75af53283bdf501215c2863c8fab7b83e9b181f53199444bdbf95b79e1d96ab003895049a848e70cfd4b19fce25a935dc092712f74c0ffbfd13d20441d1769a86f1d1c3deb686d1321a55cc1ae6d96170263755f72a1dad512b6e2a1af61a157acff0625709552ad759ce2d143ca3dfd1461678d54727b56c10148cda9393d741e6bcd8a01bb936accfa9c7cc1f5cec7558478c981176ca258243168d66f9538603cc604a48d4f1e427b3dbc7e10f843abe3646419a1e3cecf0077b772a63e523e5878e5cc6eb978f66ec7902e9a4cdbee6d9fa9beb5a1bdf8b5618a09ffd1fef68464e8f267e363092bc580dd2ece2308812d89c2530b6ed40d3fdf7f39df5ca8dd157b52d95c766bf40e7b2e142bc690bdd0970197dbe5f470311b9a34dbbd1a3122625b01c8806ebff1660565fd57d463623b0b826983e120b47c15500b82b59f16fb132f0fe430005565e416085360ade9d9ef4dad124003d4ecb8639bba24bc47d0374dbefc538126f29470103de17c43b6ca06b9a7b8a8b8bb6ed23431f040ef0ed2be72a778137d2c8e311b4e5d012c5bff43242ca22046ee44ab080754da246dc3b1d64eea6f681dffc0e88b5c35609737ba6d841823c6097175318957ed76680e5694c647162a6dbcd9fb52d75d04709da283142370a46314386e3abf635c6da12643929c6d6e486675b720f9186e24c149b654f599dcaf617f920cb4edca58db2ba07f0b698db731cbd00c1152d67c6e9b1fbb32674d87a54e3874cfdd41aa6af12ac846edd4e364899b4d3ab656bb14e94a8ff650fae3a163098bbfdbf19ba34506e3c8bc6184e5e58df32de7c438123b9254ebf235242cf65d8e5b948566fd88c9c575f188dd8bcc49a5aab740ac88e5df471bc210d9c6106c1fbc0773d159b49287d64e56bec586b82227ac27f9945f1f3b1683db11ac94f8c8a60e04f740a63811b4b3e1255e36ae21481cad37c7dcbe4abef2bdd0102843ef14d6210b72145f566087333579ce5f8e96d5e2f539bb7afb5a1c1057aa3c6af80e5556b036cc925f8158b8c44a0bf01015b827e19aff7e193d44eeea8b49bb783e3bea1f67aabecbaf36a4fdb9b8310ab8712368923f7522834de7b385e01ce8a2aeae0d760cfaf645e837d2318cde8c1feeec2ccc2431628b3c2cfeb6b6b88096a74d5b2fdc333c3b5e18b2caec6212b687655ba8159d33d2cb17b30988335d191e6b787cfb8c677b273a2a9e9c482d0768178b6335afa8d0d9a98a0bd49bfd3a9a9df5a5abd6bc94bbd3059760097dcf73740df11f70f6881292d17083005d7d5407f353bcd3b6dbc09e179dae6766da005ffad5594ba493dca4a22c93b56530cf2e797907c22a0cf8c8e92c49342aa3eef49bc60048c5d3e8cff8fda0877ab7aef061b086d3c9c334a104eddb42a9661991097e2308f3d8cf1db2d307ba2d28f0525a89f0a65ecb5d10c20e6d7de439b2f5379eea219671321dd65e0573f59229bf1606b782a120d898a4b6e21eb0296c45628fc944fb4c865600388e66772dfd9dd647b6588e9db025f44eeefacbdd32023aa8d50ba53f231e9e89d9f2600caf6cbab96ef2c8b90f1f3de27b61501d68e588f9dbce114a4252ebc2d9d5cde639eea3d572fadc85d31c7be5b9a139b6cfccd05a9824eec8d50a6715f9732d203cbf0ac7fd0e6b3a1347f42c8f68bec6ef6b3f99865d2b82086117e662e58f4b7308e14c9c050ff55c0a8c40e3dbae64fcfcf75cf0a9f0475c6ce06a5728fb927cde91ae2e967e7ce6332d1ce5aef41a23ef29b9e7a654320d8f9b012431fa1aff90338379ebcbaf171f4e6eb40cceb413d81917fae120a28045e1c00497fc63d62ed2ba3310fb7fd5023ae1019f7270a6dfe91d8297150cfc48f144bc109b1f920d27010f83990ba93a74a45d5c8c40ce4e259b0440c490fce1052c03ee45126f8fbe0447c0eddf06fa7b2162fa60590844c8f6466cf20e2d2dbd707dad9006d5428f0dbd0db98452a68392abbd185684b9519659cebccddf7357c965b733ab23de858520d8b8af9dfd53322d884e16266b4456f282e860e5d231de56e69219d7daa8a7ef3bbccbf30a4a5d5abac57f612c5c2c9a260fd071e5edebe7fca68042e591edbbd0242ebe2827ca230cb7cb504caf9ba8f89ff422aa79b331f5ee6cfe5b5ebda34ffeb4c09a943a53e60058be6bfc372e1d9be8dfcc386caf93b190ea6cbe74c83aa60605e925e49b37c2610c766b699b0deb42af0a1d8d861671c25f941e36ac5c3f23662171a607aa7269952b8c0b9d5aba66d8068ebaf5686b4c87bcebaae4831f8ff88b1bbe5663920472995fa67cc8b729e093a891c9d6d26d7a918ca2d46378cfdb1be30d724c7193780911c7b8ec31e1053873b9af65a7c8daa1046bbb1dd3c6628b5b1ac4842d961c1443f6779538c6aa873793b2c2f8ee0aa58bee44241a560e7530e53ba08e5c728b1b172f3fdfcb0c8ba1f06056b5a7e7dbf1d4c9665df8aa51310df6a72caa67a9227c6db18e78678e1631f1d2afc701d26301ce39490918fd9dd8c750ea1dfe520f9070882750b97927dcf1c680840f0c03a26f1bc9be4d0f5f8e81fd79adf5bae2f154a69c58d466498220bbd5773579e8db22caf6cb70e48c16a68fc57fcb9c9abfb2d89ca0f049ebe473d3782267854fd2828407c5d6ad096a5dfad04c31405a76a823a9224b11bec48ae1e878dc3f22ea53dd354066e1e6b60a4dd7abb52fe761864c27a878e35c8b7a48ff8f92833e1c4fc38e2a5046fda4aa37ee06de086ffc8bf7f22923a99b5942a320755af0e91e2c96206536023a2e7067941d28a4c0f709f03de5a3d0e641f64f0c79437c1d84ada913239b6858cb74d9881116028a810811b777ca445e24a3f79854605d9a5aed54e36c42d3252ba94e168a7a24f7f6132cc5260a5c57c702a939f0e2ba1ee17ed08167ef951a26a7a6491efece0069a7ee285f7896a63e78424624783b742ca64a40837d946054b1422ef19ff866df7172919c4a991f3ee38f55676f3e80bc15df5eab890ee1ffb485b81ee81122bb1574c5bad490d6bd4dc952a2169157cd41804e98f25a7d3c112b8b42daed02b1cec1c39301c4c0f491327bb7a35acb633281d7b57b825dd39992c39f8b70c61362ea5673b580bfc01337a8e81bea8d1e23698fa80594d4b0867122fc473e35a02ae94090798a8157e88f7f50a9bf5ee47b49617511a3f8c0cbf9f278e695e8aa3bf1f8aea5891923bbab2180ec02681d8c5240b76bf3d5a67881db383bbf5b99b2c1cb8d5fbd6571a40092037ca9506afcce78cfe57371b164f7b399645b6b63bfa162a743a93632e0c349eef04ffd472e30e2f9458203d589c5ed825c766c051c0a33a4c69696c8112a00814a12264b10354434decdc3442c23ffb5ed1fd36c196ece23c84b3e0f6d10935694fd3fceebce9a57d2c6e34f6ea0320b76e4da1ed7428d48166d100db5198f7b3e684da5fb6aad06d0977a66cdd83ae8a2632717945bf917599654319bb4882f278773b50fc551e644708b3c0bb319f4c914f7a1be3cc8d1d0a405baff913ff63e68131e8f7b010e4f06836acf58610d2224d98229829670db0b33a237d76a8e308c9d2e6446e14413e6c5a79599ffbdf3b265e4fd966bda6323d47949351d8b90d2a48464aef22aed228e6118e9dbae1b97edb82f68df656c9886f27512ad8b940b376d6d235da65e29e3752ebd241b2ce8e74e25dbb2be3ca963e1ad0df1bfc5b1f6394e063eefb6cccc3a2fb54b2cf6c8eff304550fddee2707b3a7b5648d3384d038754d53a4f3a23cda3f9942fe64d9e0143555202aba33a965ad9abddef78206737db7aa9d461a90a6f9649d21a1824627e9a7076092bceff047c7c5e181caae01da63e3b2132338ff648cbf50cc70fb836b98240ab98bbda0dd4e50eb2cd9b94bb7e7300b002bd6d668c69e4edad8caa4c3fb757653dff12f81c102d564a3773e9fe81eba655b4de006122d26d1f0e800baf214f1d47620c85a30c1c7dba8231fb0f837f34f816aa1b0825259a3a687a1426628521bb8b657028652a15a0961da81cee4ed386450fd3fae505cd150de54d575b4c34d1dd6f4b57892140b9683b495154c78aee2e36b6fc05a5a699ef6363854a1885da3ddae760dd555af07224fb9ee1e9b3fd6128306211bcc446f711f7226886fba93e82ffa2678e44abfe2d59315a2861e9301b39f2be892fcaa002ce4abb25cddd967af4e49a28483731ba5ac6fb8c5f286cf63639a75cbfaceca9d60bd047c88752d5bcfc433bc870979764ae56cbb3111505ca745ebcbf1582d9d48a97d629f28ce30681e4d33f143b4b998cec36b33a1271fa97f70ea63462529557667bfc7696f1634f40afe0dcf7088aa68ca6d7eb916331076b90f97ce91eeb3e8d40543aee7a862f981747316ca69aa5dc0283ee4a1d11cacafee4d37ad2eb46df37d78526c5dcd6090f4b1cf14d79e4e55a268f9481e7aa3ac425ecc9e9f0d6e4dae9709247e98d0adfa3dd1c9e0a4e020745035ad461a4a1c4181a79a35f4920dc62ce0e13e98b306e82a390ce24a614f742d3c14ae7e9d407bebc565a10746ffd4040adfe7df3272c5ec77ba2631d9f9724353c83a525aed61536b9c0532e7a30d6d62c90cbecb58b4e885e85984e63206bfbf0bf5a8320e39efed7fb2e20fca569d199e5687e1aa92a8d975f7ec38f40d2e80a80f5cce56e507b9cc49c13e9b594846daba431cd2f87662e64656eb0aea3f300028acf520c1d43f91ca4c4f45edf0b813ea0155d200d9f476bb8a55b725294782e2aa3df4e28f079c8a89c00d5c6f45f00730669b066d350a299a22d9ef815ea01cc61f9a2a56466b373667bc24e87c2af3a5b4f2fd5307862b4b53c6af5542be2d5a0a96e31fb2829594880fb4f3ddfe3b2dcf02b5a46c95420df664dd7ecd318480d27d79de216b19d5f6685f0e291e06652fe47e523e0f6ecdd6e40c73fd4a2268868f6e086f7daefca7b133924eb65e74c60bdcdd60a5b028bb8d7d2027bf30ef75adfe415c8b78386924b24f2e25d2aeeb97923794e50dff7b2092e72ee4d7cf426c1d651d1c8cc39b1946215b6fd9c3633023c27a4529319b1e6c4f59d0976afb5fd9f36c651c5d35a89f180b977c2c58ccbc3e35b8668625f2fd138a7b1976274a813639122918f5af456d1a99d7ee3e73b4ffc06c6dce1a0985f946acd78dadd54ff05de841196c3f4f5b5063930ca35eace555acc9ef85c8283b6ff62dfce1901b5d61c7c2a20cf75485aef0c6a86b1cfb33528905be1c1a9672eb10de1e30fb9c4e45102f191c92db2711c10eb68e8bcf0517211f605b407782e5930a6ec9ca7097e23919806ea36efc030a88eab3fb9bca8d41e87a0a414b114f2d2dd26dd9c56ccae45ef03c716c35153eb5751da1462759309f478abedd6c8f798097204ea9ef7c8a1cc23e7bdd0a84fc4fda829e1adb86c86666d52fae67ecd4a843c9475dca85ade3ed92e7019bd4d2f2e1dd79b8ef5f3bbccdc1b68fd6cf7495e9e9345ab5bf65b51d9cea117546506f70e4209988764e125458b4336c0f42cfc2ca77a0fbe057afd16e649256d45df3cf6c6e711058404e2c0681b5fe35bc27fece157286d6bc80d7c0596ed425ef5881fd2d54a74bf00a03a29d870601c5a0e2f24a6273ec399cdafb0ef7adeb1cb185084fb5e065a8f88c2335d70a9fad27bad7394bd3cebe7d7e9c7458175270a4a849617c2243484ae74c5a26c8a1a72639767d0afde5e88f01572fe8770d911001b276be50181fcbd50358ee1f924cb280a72f2fbd1bc935d165669e02ffee26ab10091f1e9357610eb38939f81ae87f5e86b329c355ed6d03246683494b1d7676ad5bbefaba481115c355c0ed67d8c20f7b3dcd31dd7f593a47c2bc9fd540e24fe5de4b7c556a33804155de1cdc56c39d31cc8b2de22c5f9e0c7396db58fb5aba7f811bcd36d32cbbb7df7e7d25f600f787aa6aa6e1beb78906539650e1c7d0e2b24d5cb15bc896297c0d88c577a7dac406c8a0e0f6add21e874ea25408a448cd35ae26256de55206ffc86210f3ed0b98711dd2fa899b778d72264d0d247ba5890206b9bc976ba025d4f8127d9b77a67c158320615822c000311218e3b38d9164d77026283bfc49347bf075d5ffa5ce60ef06296335709a8cebd3575dce88f109ae6c1eedc0792b06c5358423adc62f7db0c5d2d1898f2648c984fbf834414cbc433730f5b05c648440af1bac114bc856155eb853e9929237e035702880bf5db406e9b1589d1c44af56883dde9bea3743e454caf793db86b8a1574af9c03156a4d032ba71f9baeea04a6117e1fd5d1946c2be85f1a7f7ef5018ef4a9b6fcdfbd96eb5dac8755d41db3a9b00c15c8a86a1186352e6fcf56c9d08b7be7fe9d66f5b8c39fd7ff10f075611dfdedd4616dd50996dfb5696f09bcae1cdad212de81b41e0225c91f8a0078584b49f49c3f80163941cd11e5dee3f58c6c90f3a8327adcd8f41050734ed1cc1de0917ba42c4fb624ab3984d70f20e1fd0a0649236a15f3aca66bd89e738b3a83f812d670342423c71f07c284faad06e3466e2511d4c131ca6e4417f99c598471a89f94f81d829d265763d4c0bff2c35c7340f48531f60a57d493ce6aa5afb296b25d8e726648aa644c0ea013f5b0178645f4dfce1eaf24ba34b80ed681fd7a5ca7e5077b064c91d742bab35ad6d12e6c7e653f3bb32f6b3e023c27fd6678d3e455070d4513b2f84f4b70a592b300c0b4cd5926ecd55dd9ede85c316078fadf32903125fd8b580d981f912417438945037b808d1791bbc23e6184243bba3beea1d05dfd28f58c74450a1e8dd654ce4e4631e8b0f7318b973597ea32b0992820c410cf7a0408ee5b4839b1220411a47f13e92529ae9d7e208d266269fd972056ccd77cf340d1dbeff25f410433709a7ea5f4341ae30c2ea96564fbbdf0776e27009684a8518b6c10c180c74c08d42afd163b4765d2c8ac43dc62917d12a5b0cb4fb8d54d440f4a47d6d7fd259c978926d7bee79c83da456ac2ea4e3b220ddc9c36d55e63500339a4305e1e7b08185a4753ef1e5d8548b8851a1b020d32d1531bce7272ab0ef01d9b66da95e3dd0d4da50f5cfd51bd4b80111562a653e6ea7284e090670c8a81814d83beffc0d2ce72b3ce53b49982fb258af507c1e18d91e22be6b1570e5e45243b874c18e85cfcebc654a549b415a9b913261fce6401efad53097769e403ed47fda0b00df57643de9ffab6a93158bb6a2e676822b1862d115159116af0304c24f8a6373246b1b3fb99758e92d89d14d0f815aa18fa09a064b798e92836f4880cf8338946be3f5067d50a0e8c8d7724e5f7a861e7c1f376f13e950ea5fcba21e9d050d34eed526d648960e566f1c5502531de8148272a106614e33a8c34a254d422b306d480ea1c8e38f51d536103b91a0abbb8a20bc6c43fe8f63a79d3ddf1be6a91b28fb2bdb5e54bf7de5000ab9a0d7c92a60b39dd13fbf78e4adf5a68c961231cd67acf111417080bb594070adf1f4dcf333920aaea0e8dfac078b1922864fc81d128f2a3ccde7451861cf4f6d085f08862dd0a857d663dae8524f5eafb77910bbb534dc00360ed22fb4b1e025928c347d116647a7281ad55325c72eae29baec8ad14a1de8d31f6af90d8bdcb0846cfcf22781f7f3bf51774aec4830833c583ca15654d41554b1cbee50c1e5eb362c7ce3d2a818cdaf3b2f6e3558fa892ffb27cf035c912af9f8d7748463374bb31db3acc3a4d873f5d3efd52fb716e831a217daef7c7e49efb651ff85d65e9005e96904e4210df20d216c4d156f0029759c6d5033aa3a13a9880d7468ffb34276a593ef0d039ad1ba0c662457b7ad3523ff000100c8e80ac515894d3fa47b0aa92c9f47f14872d870103ec7655400d4b863e73a9b857dc18cd7e1ebfebb09cac195ee178f291d5435263fed002f4b6170883300f2bc6bf2ecaceaaafcee09f8ad5fd6d91138ad5d4253c68c8ed0217aeaf34d2227e237961a0c03e51474c4497f91e1ea1f0adae9824523329fb502a1d352e7f17441f9f455d9383e28ccb20fdfec36739e00a46d9741d7cc8d704e5f8a2953abc38a77735f54586b6d65d5cc8bd611ad3ff08acb22ea489a8026f840b46f9843cb9c42e6c315916e57d6508cbc0bb027f3bb8aa9eb0a70a89b6fd611631ed6aef5c27e99add61da6c48d0ea14fba87a363531158b14098ac927f0b7f59e38ed51dc172f21833c1a52890a80d5e4411a841991a7d61a97d9e2fa16f3b2970f7032afbbb4965c0253a6e9a0a8d284bb945fa5d2f50785528d07a43dfa583892493f2919a737d26cef73b61329654e723528f0e34a5e37a6d7704a44da4a185b493efd9be0bcfe039a1b9dcd336d319235bd7abc69cdd88147db77e62de068fb5867a0eef6d4d143cc484ba80fa795d14e5dd4b621c950893f2d56d40168a0d6f8a11c06716d232057e9c3e231f41b34d51fe5ac9949c7971acf3d700291c6378a36da93b8b6425bc514688c817feada016b6e8f2661b8b40d104a3b7c2810fe5fa55db380256ed32c7df5e26b33cf9803ef3f476778236e155ce217f719910d92e6d0949eed53c78f851c5ba8d30d03aeaab7fa4b4136319ddfe27e62ea2ca400d391c2297abf6cc0a3838669789414e6b59f3c2af2ade13561e78b3baf22c8c3310b62321e5eba6cbafcb54cf2b14d66c2aa4dff7c6b7bfbb12379a4fe2c7e47241b5daccabaff31d44762d99ef5034f69e114efcc331fe2bff8dbe0fa5431006c57552df7d0a561ed59128f201cee6511fe17cb2ded003152b6a41d9872d74818739315842f56d3cf789e5af53bcf5ea1fa9d449774712645c052abfd8e6092f9fadecf347a731b5f90fec5ce451588e8a70f64284b6109ce61f91f903aff61214c42d517b66e45d6ea8b6b1f7c92be90e38800f2eca6fb5a74466fbccf08d0101d06f7d059e4395d2fdd3fd8e656d85ffcd9b818d42fffcbf925b879b0ab0e9cec270c7e46d6f437717fe15e1bd4b45c13cc1a2527630b3de53a7274c22b00bf852bbf7c16a223c15bf35db0c712d266de6db341eeee26ab8da8deb8a23cc2e9dcc52ae1daa6dc18f81ed4c84eac41fa3fc32c4ba5c84946e679e0fee8c21edccc2d8b6c797dc3906e1ae031255392e003870aaf95b5ddb23aa996f202c970f7a5f5e0762f698195095d42f12f6331bd230644e2bbbdb42324893bc884b0b793a65063c633c190699a1023e5da40fed495ecf2bdf3e28788015324cf5c130beeed4fdf503c22b57a84adba723b38c6410b83e85919198411a46fb4d17de61a0be461a41f63bf4f7885850117c560670732190039c652bfd911db89f9978d586c8784abae69e496d649ef0538f6023279e03344e4cf19aa2e6f93272aeab3bae0bf6a24cd14f7f553959154ea08e07bc4ca992d3057854afe28e456e6bd1b418897afb62c13fd384623ab270bf3defca0dec6fb356bf5a3d8bd6770a212df8af3dc9261db7413969149965cb3f7194f52274245ed1638f608405711dd03270b671f897c36526d24f428eada29f1905b600fddf1d4e6ec05ff8d77f36fcafef0d8e581a3e5fc33e86fbf274af9cea867589e06b9469d874634f3a03ddd0ec44a7123bff7c71eaaed016d0a2cefbc9f3c1bb1ea5ca68ac1bb439fba7d4e77214df6adcfde7d12ebc99282a6714e430bb31f051700bbabd9510f1ff9045c4761a88f73c99243dd88c43f57fc9c0a69c91ad1c2a30207fcc0107369528d9e131e83e6e07a47b67a471fc8063abbc73ff5691ceb50e9e02aef8739b27a17c095208e537a3acea01c62a75ef28b2252d69404832768a623d12a0c87b77a1f8b01e4e1ac98d82650beb1a18d8b269bcac7d03beb2c3750bbde0e395bb477f49563935f2d20d94099cf7b422f3170d7f6e6c4066b2137f73215b3d9e6cf66ac2dfe68cf9251776aa2e0fead9bc7b2fa1160549036963653e7d34fc07e509095c8b695e528356b061966f0a6585ad7735f623cd6b5085cc01db6c30be06be91a125ae50281c547f4b81123becebd36f9c8f7ebe61fd2127c98f831fe99f0cee976138ae7f15005d68ac160466eb065a55e52c9861e83c0fac132c70317126cfa96d7e1d555258b6dfd4ab807d9cdbe2efda9abdfdfce8b427c1eb0ec6a688b9d48193a2f3b3c2b7d83292a990c8704151f9cc1ee81c7ef287387528b1988c4c37848237ad2f735b6141fdd4fa44b38d5dec3b3a76864aa7b032d0b84a434992956118021a5dd634fd6c3f7ce79264aaac8f1a5642dce5578763660e09e1dae521da9aaeb184d7806c14082c1efb7d397a36a6de0be5010398910040cf5a03c689db407129ddc8b979bea4c0eed0b4ef12de61548d71cf19b51afc9102803fd9f499cb2c4e0810e595b0b72abb62c8c566d00d9b9bbc41367e6ee8503023f494abd25299d8f72523e3334f5468188eb7e277aa19718529ecc706a6a6c7696091ff914b8d411de1d26891ca5307909ee782e623e6b29b50234235c18151b609cc0d957303b6ead9bdb2d8fc5c263044333e8303bb1ebcd749dc124a80fc7e490c9e0491d1717a4de721605c1b8561254145d2f1d72d727a7503fe9513ce55f71b99537594528bad9b53013c2f4501370708bf24915983e1f8cb2d78d7200c42e4579b37b7dfb47413dd6bbaf0df8f4ea3826405a15be7cbf812ab646ee27379efd6e312c38e7339f3e81e2c12f4b1022db81948d8c6440d817fc23c143c7f5e328fbfb14cae65ff7e7d4e227dcc2ec9923276d195b837b5689122de3310674cfd2551684ca07406bddb3ca407f421507664a8cd4fc55ecc558622550ec80eaf4bd3eff8d1bc55d9f72786cbe1d2ce7a6c1fae015beb18b04b68d2c307bd52ecfe3e740db28a2bd34bcf5d1ecaf7c3167b0036c4422ec8b1092c034e5bede49a1b3c30204f58085e2b85d6b55cd5c70d8331be032824018eb6c958f24d55d02544f9f93ee55e2b54c4a6752d19c8a6f1a68f13ab8d9e02949530e3ae0f44de9e0f579c4805a9530ab5ee3ab12e897f6c09e60bde85059908df648a361623dc3c5fc4c57021d7f21b069afc9476f5500cb6c6bcd415add4444d5f720921aa9cfd031b1d3ed38beccec9c3bdb865353f75ad1fa794632ec44479626187aa6ecdc1eec31b0c88e8f00eae592b1dabc7f7976f1f7eaa1d4df8bf3d1788aaa6002a224b2363a26ba0d28d5810b9315b776f67f5e4a99f9c356c428d34bce0bacfc5680d7002bf8656c3ef71e2b71f80af4d89f5da06a9dc3c96ed92a1a602ede9f79296136ad47c61340304d6d0f04e33b935a7070dc84986f2acd64009c7a44cb917a946963e86c5fe17b7cb4f303e22cfda84fa10d60d1aa5f1b3460fccd5061395bc9f4909e7f994f13f90dc6e9f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
