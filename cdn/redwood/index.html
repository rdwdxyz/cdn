<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4084ed1c38ded5afb2aa35c8d1ac8a8cdf414ee7aed033785f412014a9e5f20ce3de8a2734aa74f44a66a98ff9e221db6be43060b6246fdf3452bcffa162f4a0049dc3a6a3cc5775161ef3a18f5688b15c59bf63b28c77948880828d38f7344aee1875f7132cdd3ac7afec6b1389407c61a30b4917401dfaead18726ea65cea7f00ad460cd28f241c133d49a7e1a505a96f36ec0eecb5c2f26486c27ec4916dc0e76b777c2cf5b64c46c84b63b4bcbe699749a7c89e3bfa6b699c3189e49f98c3d94818267c4c6af7d22034e3fbdab9aae55b626177ffabccf4906958b75b348910b27bf6f7f82ee2ca1e42d031e53508b83914a1805bb4aa1f1bb939d24c65779fa8b967996ef983c402b0f7b7544dc49d0b8b8e8c5710cf80497e0bc51d554babe43f117e12ef729c8b13eb427c4cef5085dc59d0be5d4fe0ee27b02be3859355e867052096c3466755c917660ee660320d9c5af2b37827c1621ff7e6e41169307db4010f4465ad35670015e40c5e0d036c81cc8fccd6b63e0bb909bc32951a2989e04084feb343f7c4074232229a9c24bd54b74a3ec24eb56b3984eac130e47c76e97312e08b308ec429767602f42d057ab6109f8a74def4a506d656b616a614cfe41a1896827014cc628116ab36b94864636bc42b58b6fc4aeb1b08b64412b1454529642fc5d47a631151d80d76bdf42381f22a7f13a2656c643b39eacbd171ce592a0f96d09647a866bb7c20eb972dba589acae527862cbc7d0bd8aaaf8e5377c749a5328176073079797658916b0d372181b3bfffe57a2d77a902053842dbfe69f09e01c723117b9fc65e64165ecd9f4111b5764ee7340b8f50a31eeed6c7eb3fdc0a9d10718429844a801765b75a78396de7f463905ca69fcf6ae4a496cd11e29633cafba5cf2071cccb70121a644e7da741fc881fb5b11738fcba2368390143695b2bb7343152004b8cd2321706ce27c18997e116810f2eefb456d39aeb467d733558126c7ed20968ccf5f4422c467365fb8b2cd9d7e23b34cf0a96996f7cd71ee4cda9b2e80e9008a804e6b98ce2435a8727273088e050dce714a6ffcd3ac30bd77590c95dc04459bdfae4366090983096547823cfe4084e7acceb956b807145f098a5962fd060f83be774c28d99862ba1e733cd64d408ec95348728cda4c14ed3c0b525d291a2c86ac37d617992c788b3844201651ed187ba1e4d9e7f33df73718412e996c0126ad87b20019c5f998546c63c022c471f08a2ab5666ec6affd409b1212a543f1cfadbce1bc42ffc4cd789caad06427288ad1c9938b28d0656859441e76f171364335f03c4fa407f713af9abc199406f224ce8b91a27aabadd84ea3f3bb2ab88faec4e5bfc43821de8d569bf736e2b3aaba7bc57629677d5bda69f1c1d7d9ea5df95542f73d91117cfa6982c0c1c70b48e649caf4d1761b3a0be6860761110b7fabae0f8b9ffc06ee5045e5300c6dcd7cc34d92d25252df610d7cd717393efcc2ea016140dc1af26ea574f823575da60b2da01fc4fa7e983884a81d4623d94be1aba105bd69db16f5166d1ca421b8e20ecb3ea166ae3d281b2978d961a0a5fd230c0d515e1b3a2033d73232fe2068d26494753c35cea1211c9758d7f12c2f8a72df9ec6a3d6d801e461b9f90ba298e93c894936546bf195254e780eb447cd9301b7d61b0bcf9be231751ed97b59b9a2f244a8ead1aefb0d0d015697aee05f1f98dc256451f31de8e63c4b8577fbb8eab0fb9fb653a66c96ee60c1ef795c6092162d9a9ac06c2b4cf2a0bed9e8904fab8b7c598765c734d9606f7840f7e4eae3985c908ba4b34fcf97d71c7953b07370a94fea7e251c980eef1546ed0d58d4ee7bf6c3e0b8d5f87efa3c50c33d6756468ab142350fc27f06d735c1bf6541db7029b97969114c0a76e99692899c14cce15f18de12cac20ccd764011222450d0bf2c41ef5139b228207dbb34fe02b0adbcfa3fa1c6cebd4413299d86f0cd293892edebbd9b92e5be3110b6ebaef8f46bbb1b695857517deca886c9ebd1ec8ac99bb1fa055aac09ba38793bb0535cf40164d406b9cc6144487122877d0e6b6e19625107fe27c0a2fd23363f5c95efb3caac82ac8c15c0d3afca6f1c6fa00c824b81380d56706308864e2e9c5ada34487d352d3c5e569454419086e677ecc437988ae796c6a8df2f1eed4a1c23e94a95ba7c75d57a50b1a6e8720495755d65b3784a7397501b478cbcbae3cae1098fa4d060f93917256be67dbcec108ec026bffe0f85dced14cfb64a47c4324ca7e9e7730add0406df2f2d935c393d4cfd7d75229c2565402b377391ed4b760886ad221e625c9d3aff8406a523813e743cdc6617dbafc81f0ada8d827e899cf099d7b98a7a9276e7a28cf9528bd3328807528537d863489c4f3f685c17c6b243ad0cffe386989a67505f4436035b391a8756e8ffcd4ddaa524cd50752b6237b781819fef1a03294c2aaa56d14dd4e19dee34c7441198d682d4c28619886d04e97ef0b25b1a0f3cdaffc830a57cf3f216bddd4965d8315124a62389e3d26da9796d5dcadfb7f2c21a8514ffc825ab6f7e190281b687c95b778a33198729dc3acbe4184459e256b96701f3a1085638f4edd967c28dc579f6bfd324dfcf5768635969369f648e4b665f30b7637ea594c26231353d7d16019c2595ae7f64e43064c1df655d4e52aa1a317bb509a36afca224579dc2bf2d593be52b47fa7120ba046ef10166b7c7ccc9b6e2fdedd9adddb8f26e623f16f974d25501daf4183e229dcd180be617c43f911d66b214f9ff05449e2250b70e06c13cea7eb4b3fb5bf3baad06f037ab88e3a750d1389f9b99628abe7a4d79142726c16ddbacfef98076261a54056ba9184acd17d56909376c4ff823a06153eca9fb66041823c97d74f9ff7a27b8fb72b59481d4ca060bd511c727c4a9c36d3d5fdea027f6b50922283c82c45474210293e07f9368e6b677d346c2c61e96bf96fd627eb2a1d01e46d4c86759629e61463dccc88a5a20858566326d43d834d149ecb2bf266ff576282bd7f85134349f2756036bfb3797870f049b376d5c62dbe5171aa4a1f07741fe31d23512d4299937f43c5a0a6ad1fc3de4cda924ada6d14ef0f8a6609671e30eaf82f86ac3e5c0dc25467b090c1881d55931860e3f5cad9cd074ec1a9a162673942a9da65e0f868b82ab2ba1d8ee084b4f1de8b534ce2b496e982b5b389a26851d170009102119bc603a65186d692c41ab97a52eabce9bef0b0d8f47820592e2496f6f806a748a9f9cd266d7aa666dfafe3e17cd0f47fd495a4f414d620fd439c389eaa3967c23ba790637143e1c159696fec49eb315c751fffd19deead6edeee59fe7a12cbd49176b7c2c046f8edcfc85a9b1a104c281add5fb83da8c141af21243a3401a35835de29e5ab44d11e0039b4acdedcba479f1bd7f42afdd2fbb8b6903aec64c46eaa4ebcbde483f85953749b1b974a22be9e1648313f9c51b35c4522f931be5b07c98a58cf41dfb976bb117d6830a2365446919cf1a6ad30bf3e28e5762b52929c8fc548c37a644b6e78070108d861dd1ab7b9d2c23ac5fd0d811f143bca3c6d61777b43e59e4ada7f0dd100d4ae846d37c08e721050d06b9a7e85f95e544a0ae31473aa783798b4ef35b3e79debbfa4bbe35fcf768a4153ad35fbade7e97cb27cc6ff8ace3f079e5d8a93450cee2873ccb8e42b95c5cb888e345f3a8fa5ad00a9676355a2ddafcd6516c4ca87f6d3cc9be06ddda173bffcecaf8968126530efd7d2bb78cd5d0a248c151a0bc3be5b8153410200389b6cd3a919f6f9f2ff4bc74cafa8687b2f73dc9685984a86c53b618763d840fb09984229f0094c8773cb6de9eeb204ebcd61e43baaba0de90d0eae24beffa7866d0ac6875affd4164c6c2314a4f815dfae03e46080ed68940f0583e06cf48e909e083efb09c2c34b3b3e3010a94fdf3dece9b097253067c4408b3d724aaa1cef4b1905c6078263a51cc7f4bec20d4f348ea6bc6d2b6389f3b51ce79dd4181a1b05490c01e6325a2aa9f30975267d2d7fcf2af821beb8b2ebe4aa08422cdc4bffaa0a5dc03e3214a8bd3a61f2714b1cca1823ad00bce64d33a54507f65453c1d1909b70de32e283145cffc5f4c54ac8309f49bfee21baee7df180431e4423c8c918efdd60be1d4103b96f091382aafeff337041cdc39796a3f0927b3682b5258246b5dfb2a0a9a969ee2f2e65c4281d13c4cf17b28fe9e304e791c5f569218d2e58ae01e4ceb80fee37b50a6fa4f2bf6e5d2bd00e4b78cb4f1387495cb2f16ae849ef02b508c7a49fd889f1557b3a5cfbc26b71eb2ac6ad73d648153a87ac6ac6327d2895464bbf913c1db8b18d1c6da70f2268778dffb35843a33f889c9bbd24ab65b38c30e5815e1e745d225f41a7a0fab04ee1cb20e940b32fc1543b44ce65c5aa63a0710045c7361eb9889dd724b62376b9f3d541ff49f6242808f47e9be191fe8df04779bd66d6caf627c0a5666e4df4c5045ccfcd9de11e0181adaee1474907f5c72d5182a09a838840fe7cc3b33a38256298dad5368fda8fe75e057851e3f6f38272b2890fa53a3062c73a6326d77c7c3caacbe8eabec692e6405d7521df94d080338d5deb4d2a08523c045c50b062e5dc112dd6df84dbd5a376e689671adba2088fac07f6b6b3724a7e8c4739a48ce23b732f56b7cba776300da732f3ba56a53705b7f909c561ec22224714910176cbcef010bef29c72cd22f7bc7de86cc6992d2e897caa5c6ed2923b810a88072dea0436676523c5ff2553eef580be21c7b6e5b9ea92927fcdeeb52ff3972339b97ca7a770cc2a43c8e81624c3d3bd78d4a7a7679dcd1dcd1e747de716c60feefe658534fa9d0609f2bfa8e3c8cf23c8c8c3fe51f144a1631e17064a16b7bc9504e451f52184b8ecfd16af38e30cf59a13f0de954394dba2377c1770e15a78bdbdd7ed89a07f211902ba32430f1b54fd22517481e66db583813d944cdb8c896bafd14b24f9cb90330745ae98bb703226a887bb20c3e4a2f2b283e1faeaa7aef685dfeacbbcaff1afb24c42c26e7040d46cb162b989a20c7496b1a58d51f667c6ebc5f2b935bfe6b8e48c6637e4b55156aec14243f7bc23ed34553c3e346da185deadf2e8c951ed6f4e00c41cf67dcdc95279325b0ec05c60adc729b923acfdcd05c679022469154329ea72f105fe542cee7f4e254c40c20b3316281f16f2de5261b26f4f7108198c9c759a1ec928935a97f36362cf33c8c838a7699e7a36aa8b17b8da2124595c92471cf3bbbab40803ed889da58892a0ac427ca2562120c81df118d85166837c0e48d824a3455b4be869b6e88e0cd925d117fc319e62a9d98a9e3b5b9ae0c772fa4deb608e59ee9dd3973e0815dae1e3a1e013a96e70dd591016c57df552c9403de8f3c15b524898d58f609b2ca3c56fdd4e8700a5972b01088743b0715a9d8ee240824059259272db486d23e64dfdc9ecb1f186c9b534d798ee169b435ebcaa36667bb85d5944fa1de57fb23a97829d6ce75d2189b50d620d872c7bae02162d80d83b7b0b86fe97a74a8f1a9e77e35b8370515667e9ba329ac9295e2df313a6c33474df582726a2fc8091bda23c3998955fc6d9f2014a694fec66f17256367405bb1008f8ea027300ec615fec60a91a4a4724994d55329a46f8103e189f19f472e4c609e1668514c36ff54766313686539b643bf659ddb8737f42edefaa8ef536d0fee30d53db4bdf05aae0954361deed31826eecea7678c86f42cd3e76ca92b6f30ca697d0c1b672bd7d819695a82b1c522e60179092ed5939fdc10c9ac0485d81b0a68705eb8bbdc6f6f51c3e097f93dfead68c1ed064d3da60e37c95f1b6da5e616d5418d25f3964f45ae06c6d5951f4b163713ad5bc84842c50cd54fd0348b35447a50bd63206957333a8204a8d6e2b1d0d102e799903e7c97e8135f558170cbee71908ae16d39da1bb37ef92e1e128d507170a817fd97946558c8522e8bc35a9c31a89908d9bbe7ccd78314df3e0f3d6957560a61e3e5e19842adcc1b932df181a3411643540aa115e9856efb12209fdadf6d6d65466dbd13bea59ccaa4d82caacfe791fb7ccdf2c1852e8a4649821f6f26905b083745830ade450de2fbe9677e703d4f14b345dee049bdd8c0453d52d4ddfef88776b12b3bffe4794f4c09138aece62ba175ef28ef3d3b4cc513fa1b014ffe4bcb00bed01faf8fb74e8120004141d7dba540f6a2cc492ac99f9bc9e8a7e498f9105cdb48abd378704d7c63b4854b79870aa8eadcd02739faef3d7712567a8a8a5fed9561d626af5150489a0e1996b33d919f41a793366295fc7f03119c8af6f9a6f8527d3d107e99c378592a058adbda78b4be6ce94cd3fbab92b551174e2bbc9f0e396de73d1caf2ebd9948ecfda5c29569f3a3123c98ea0dae42d1173d99173759ab6bc6272b105dab662b0b2f2a53a97d8a837cde2b8c17b5638db0ce4d43bc680136368ca6dc289132f046c4833e065e4668ae9e0f6853ae47f6854ad271ec3c339e0abfbb80108fd12eb91df6b9f4241260e86411df2923182ca78d49a88ef817bd041c872a16c4b05bb9ef3b8987837ab0fa6e52fb8c0cd5b2a80ca3b202caffa9e3256b581ccaff12ea7bd27bd270db7a4d593b579d41f02cfd238ecac9b2b853a3dccf7a547a98b0806414b1ccb3aff95b11c22026ad0aa5d4089266122cdf7792f69531fe72b971e5f1769101b6ad51b0a8a61bda09c8482448a23dcbf98097344bfbadd7a2c826aec8ef0de6f94819614b040710312e565bf30b97c04625cfea23bb3ae2093f6f8e5ff45443edadae8e689885f7ccae76c52a4c7016ffbba698ffe2d771e88be1f8d909ba6968208c716f27dbdbf4f5547716593d6230f327e000f76fe00c6cb7c7052bc9438fb1042c7a34612bf9561a6c1c72147ec33e2d0331e2ed864b224f2cd536c86c50ab5ddec921bad5e51714b1360f9eb567fb7b620d62e3bd3201c7566aeea48ae7db931a89f83a1bc441bdffba91cd21b8644fdb1b2870729e40226ee82876c309016e987ae5ef004a24bb10ba43ec9c8f12bcda82e8f1331dacd4aa492b98f14d993f3cc9ca9f29198a403468fa740e018518540cfd1c45f454c3e262a1a308103fc647866b70174b4ba5b26ab88029dcbe573999bf69d091de2d675d56214f180bbfbb3eb9cfd12994929c464ec3131f3a554178481ad61769146aca5acbf8b3a9da0e6c193cac4bd9562f2ed188adde08c2597705bc240715517b0a0bb4473e016d2473def25e932e8a9694ff18688d8e3c551df8436481d33608f68e500ece35b2405fd06c6e47d65bf576b9416200576eccbc73b6726dc8bf4b81cf6df930d6f37fef0c990c0dbe55b7e9842416ae60654ebcd1b675ded19526746cb8f4c843122e79efeb0ee7a912a6fb7aef50a5cb90fc501828a1593a733ec84ab189ec2a6cadc6dad747f7513979ed50fe71a88609b32ebe7bec9c36ffcdea8cecbbc216ea717a2dd8f1d4bbfdc1193bf2518e23f49d0fb79e490fafd78fd13aee0b8fc35bf43cdd911595e6c991a9d948e73bf3fd81d1989eb0bd3f77267543a4e3cc72582a001dbb16a2a5c056c391199fd16c756f2631dda56b5d089d144213fb3bb9225bff77bb30a41675dff3009a7e8d4564cb5aa87b90c55853163d059252abe20d143e4561bcf014040ba7a70f7cd644068f4a6cb156e07e161db257fdb3b9ac10e6e8cf9a0dd9358e23dde03b5084cd7967a9c5b3a4cdfce1a519d613a109a35c624010a44866bb088bfd2cc052a0933c731a778eab162eb59415610a3b718db8e488b07e33440a12ae8977a956d4a546bdf1160f342bb0b4c3469724d1c90d59139f369a16a30938bbebab8ff95c6e6d68383741b354e020e0b545c15bb65e06db73972d89856f0e0e08681688507e8d786e846317b85a5257f594dea28a7e36445cf9fc0d240eb1531220f80c388f66743c76c497904459d2233115dfd29579cb2ccba394cf4eda2a9b6e24160a0dad474842eb28863b52b806517a26dd07b93c83be85f3f4b57fcaa8479301b7eb96f7c231f67b8ba36dcad01fe21b6b2fd06c4c23ecfd15f2c89c4c029288aadd8681a19617005eac1ca727c0c886b84e212ef95cc4ce05c28ca7c7ffae2520cec4545541b518737b790e1e9760fb2fc1d737124eddae88b4a0476b6f0a354c489ec9dfb3329ce085851e812841d8f07697c8adacc55d4e364aa7f53b439ed08271572133a0febd4de7d74ff495aaaa3c2b31b2ee755c493a8bf88a67ceeca0d282f89697bd374f06ae863504ec8757c058073fca5058920fc691367cc9ae40f641afcaf47a8b6335451a37d0f5500e552f9164544e7590ad249a79f76a43380d4e53059fa6a1ef73f57b49d8d04abc54550ffd941afb295faa9e8ca09f0697056341fb2d0aab92172683215c1b18751321336fc17bc1d95ccbef0753a91fe43a85669a120eb6502e2945b73faf111578cd73fa1b035c6e9a3444ba2d9036a6e50a1fbd6862d884d7e0929433180b07c4b907203b286143898a4ef42dfadcfe0e08584b6db5ab7566a03fb47487f20bce8229250ee0af8eeff7c8dd40aa79429dc566dccecade75087e660a1024ca3731a605c50439a2353c0abcf4cf870484dbaa8c7145320c7897147bf2a890d4a902748d4995088fccbc62f13f53bfcfdfec83112df04cb6f046f818122f437530a14f71629042a6c5f67aabb11fc8b5f4ec4ce9f5657ccc53a5b08cdeb96c962f4314d7f3d9234614772be058088c2f4514a3c4ba4b8c37cca329bf8440ae8cc62f6522d23dc0837a456fb2365028e82f90e47f20ffbb06ca30a676b3acd69174e462a0f266f9ee6ed270891c503df0762ad93c66fc2353796ae8de4f60fe9a7b6b2397b350551b67d9ab50b2bc39007977b5e5e9123deba693fbab5294d3a6cbb009c01869a4f61a5ccfd7a3aacaae43656ded00afd18f46b2e686de630c1feeaf7b41087f2ac3ca5246bf0f8af43a26a608bbb8bc0705421f501268ff814ca79b6d9a8b74de3cd49f83af40849e510cf622a2545a13428c1f2a753f4c752e5326e7bd92d152598159f4350fb6c1b7b2e475a054a9d76895f6326da24e350f191d71eb423673fd46c2bf07f7883eb55292370a6e56a921b52acc2fd55a28f2b5a71262e2669520c4d1a6fd40e189625358ddb883c0e4a1380e7d7c251f40d4440539fafab75a6cd0248788a59c5a7a2d072530e1733c7abe996c27748f8c56adcb5a9e96b09211400c7ac9b9456ec046bd7d0d305ef09e227617747f8fc97de4ddeaf1f5539122649594a1fc7dc5c68b9101770ebd1aa970998855b791fc9bd3abb8f26a035d59c10f94c41416b751ffecb79224e20255cc4f17a160927c930d4e9f56207a04f45a85c8da62bf6cb3ecd541a9f29d0cd599d13ac3f6a1cdb07f816172bbf6b83dd7d0bd9a34229e2431945ee3dedf5289a0150e05d3cfe53e119e8474740964ffb2e9ea3e93fa9d80f0a9131a3e150d95679cd1af50c3384fd538741b929d346b68085315d7b5afba62ee71301304f39bad18ff3671108b1d12e1d763a35e34fd40ef06f03c34eff4427bf735c698fbff15161a4e15ba753ff63828bfeb0abf07f116073e64d9b4b5f1f6f24012c98c020da3e3dbe9e37b677d4f3048fb06082b6576a161f7b962e801935579e60dd4af30ac22bc39fdd9d5965dd5789e92b517fd48bd772966a07211efa79aafc9d6507ca36eda493c06a9f23c2109a60432f18db6c626591abd1593b9e4aab5f9117569f3d52fd06848514bb9a88419cde2a9c965de1d461eb4571a94002f4040e1dc5c91acfcc07016bb6a3963a48c4a6b05fe8b65a5f6fdca37d3d2a1f7574958ff7e64e018cc8785d133745d9a30e3bea7ac32ffe5ea53a920854c95f0fffad09c3aa592cbf2184d6acd39ff1df08b4544c51544b38426f1cc1c6e006918939f0b945cecae3a1b940509fc4405f927309a3543887053c2c52aca0ed709f30a02b2f1db650452da1b4043550bf4bcbe1071d0e0ec75f8c08f6db498581d3fb662e6eb8d22497d7ec8bcb02c5384e7459a22590b0b184b311bd1302097ff78a3f752933c998764e24ded955bcf10737a311fecec9153f7b1d68b68458d9ffeb37ada5b352feb121decdd0810da7d55aa228e8739c3d7f2ccc7c5dc1eaf8490fed6df37d552b8c46461738ff3b6a1e2570f7871266b870a4eb3ca6f9cce749086d342b58fc0e681be7907a4455dbe13eca1f9e88f2750032c90d375ce8e1e01017adc7ebf9644d50eea47100d81d7d9530843ce5b845f9f583aa6976699c103faf308d4edc492dc570e12b2ed82fef6daeded0a2f8ebd7de68c1adfde3bb54cefe0b4fe660bb9a22237d6c0c8b40219d7c1427a526e6ddc9aab54977177a1f918f31e987c45e3f82b09ed2a4bdeca202f69ac75955ec180ec1219b5b0da93679cd6be9012b9928bce565b7089ad6e68c3a41a42ddd293e46d5d6b0ef93b7438006a521ec8c70c16013c3082ee2600e8559157fce2c3676e2b088d3c183d10117a528f1494e672d52747ea75094f96d82428d8afeb3ba371314481916ffeaf6527af234882d6b703c4e2c27c53f2a8854db52745cbd952582f390427fcce5cf55e3fa872dc8cdb4d477ad2aba6590eacd6f0aaa50858e97354fa373b3ef7614890e76f173a7c9cab6a357a6a4e77e62478409d341f6bbdfcfdbfe2914a8fbaa4620bf8c884f5d68a4376435325c966fe0683356ae223d8062145b17465707c30d109eb8f04aa06d9d0a309a716deb7fee683f946e4449b7bc52e7a9cd79581fc2fee5906846cdaeebe739ca22bfb7af0a1e9fed46082bd2819b62a57b2f657ecf22079c4c13aca177ba5521d0c5a96659c1223f47e5f417b8f993b137bc03e7e6556f56c10c9bb0439f1e94290421f8209b6d969e8e7d73705629f8375dc4af11ee9d11ece9aba0235ee1c83a08a9c728e60db20cde981264579850b9d4ac78fcd74775e7d786b0872921b265675f7bfba2869b2f449d105d72422c1ddfa21f786cd723a03ba3fc907f7859e9723471bfc5129446326633f93f8d135c6240fc1cbf2b07eb08df3c719e2c065fcdfd0f488b5adc96d9cca60754306c675aef7caa1a888a377a9edf866ff6ce5047be8c34ffac2839ff512c518726e90c201b912839e6ec63ad5898c18c1de8806f79efa22dbbeb79e7082427593431946f189aada7509a8343162f471f5f8e90f41ded572e750f9dc88f9bb2ce8c9746186601dbe2ce005d868d15fb98af5106bbaf33b0b53f7aee3dbdeee7dff8066781584a3a378d60e04141f0f8f691b6dc7e0e5b12ac7720b82fef72014e271b14a377a90c3936b99f5c28d08b098eddcc01034d404600edb1c309341432203d3e7fbd761f010c0d0fbebdc6a5d14e7c8a66a5a6ee3a328165255406d6f81f23fb5d4b772037a1984342fd6ea7c6b0599798040ad1d043d2c11e381336c8216a33d971e30c64f1cb84db31934739ebda2d6fbc5a80704915817f19aaec8d308848b958e2749c5b2c215de23eb3aedff2a1976f42dfbfd8a7619860699a559e23a939e6554475f7351171b639ab3c78348063f141892eea23383401fb2a7da7940d69e9ef26c37fd182ea6dd0b0528a00ed0cc973ddfda6356159564fffeb311db2411dfeec76510b2c2171302d5825053e2cccca2adbefe1f428dd6ea40ce12f7bde39c0043a28d6613dfafb1c7e31e447f1e0e7a8352cbade29fe781a2be947962f3a84b640317c3e03123ee8d99df8eaff08f9c73be67707be21332409e7d1c24d07276d0ecf94dc45961fcb0d15edd4fff787f81e2d49cfb04235e0f3332e467e4e646b8969596e41ce7bf464b0558205f415b29df2de3ddfc0f7dd5c9d13e2a4a352b4bc8e864ecb02664ba0209f44332d242c64db9a706b6165e28b8c3aa79f12b159b499826e0db60981d2a32121a869da96c70c7e882c7b208532fd50dfb8a2445d916518700e1e73b1f0821cbce7604d282e4f2ba57711b1ed554301f3ae0f4e9bc68ee33b2c15d76b56170f3b40e64af38243051b2de4d32741b78a023d1157586fd9f844b02465adaa65e75685d4523f516a015510dbb1e1ec0a00d5bf9ad93e8ae1770e3becf47e2d9ab9c19f0c6cecbb2ba88655690773ec5c5413c665253769b48a13ed349746b7cc3bc1bb478ebb5e8d3fb2a7ed84fe2bfeeda1231cdfbc427ad82a1a36c1a6f1f960ce23f95916bd1f7a251ff58146f9988f81037569d9be5805c129709202bd28528d93c2610acab9692f3519b4d8ee4e6973e4510301ae48c3c0edf5065276b7c55f4390f231520658af4b8cf3dcf5f481b3bdac4a2dbdc9a7ea997755c284e0ef83a2af6d54df3298c7bac4bec66ad3eeee421e5d0964870ffd9d4d4199a25a31c230ab8a250a0395afac324c0d6d37eff8523dbe38052e5642e727706cefa94bf16f06aa4bc6831e836be79f027eeb45c38bb119d08d0dd3af1898290543704d54ad49e46f47d50de59ccfb0ff26386318f5ab92218057a8aa671edbd50d185785def72ca89708d41c29d48b63f35ddc28613baccb89d022d089021889398caa001c519b33444a4b2919db8ce332cbceac3fbe764ac0876ba08bea0b05f432db0db34903b4d5a2c1e3fb48c4622953a728ed7a8c0e5c1439f153ee227bf0f18853f194fe7f0950a4ace934a0a81d101a2ad394580eaff4d3b0fbc4ef955f392fd86537cfdafc948333eab4652c4a8952bde54d47c59606d8a514f66c4dde14fbf5faa73e99c58e863011d02661abdf1be717650eede27b2e5296a4779df893e1c30fe2f66b0bc5b3d00b0151b67a784445828438cd2520ab99ac2e26ca02f24635bdd6b15f7a77b7861f52be72a935101f96c9dbb8fe5db05e6f7fd253369662b0dccc28bfb7abea65d176c6def1b00e1220f6c8230f5f89dfb24f1f022b452cf4f2d1df18b6cd297aec9093b6876530789650445c863c4cfa7942abd67bc1fc2425f3d3e20208625dfa3eadc4f5a8df87dda85fc4e6fd1d25a175728648bd7e6223c5d243d9149180d2bbdf733714df455edb990d2172dce261ad1a9686c87127bb0568a0d2fcd72c9793c209de3df41eaa5055de45778188c70e5e561d012c7ab8106c06286b0e9484bac499bed003bf42c28af61735083ff430a0d524158bf29eac6fe53bd766ed59144c567066da1218b056a377b6bc8d50bcd2cc4a2c61cddab6ed562e343b4c925cca5e035ffdeb21718aec8e089b122b393b10b2b12883a80f6cd7e519b57662df954c6706ba74bd6d9025704348524aedc1b61d51e9b73f4b6b2689c52e38d686839dfed24fea13b9f0c5aa54fd9f4fa5918e53466df305391fd2e9afe453a19d5039d6a10e139bc30498fe93e181bb1568014b35a482711436b3edf1660ac1e424f0d41404da97f701e886f80610307ffa262fae80bdf84ea6a8d577235b88bc298cd270ae62f87a7382103394dea97cb53cdca3f070ef944420946ff469000a1862e68551b535ac9190811c92ce7d9ee5bc4dcc5fcfce4a01559c675e25e8dbe1211b91f839756d2e9ef4120605359543426ceb79c6b8279f2980d3d0bbbf5fa617bf0ef7477f3113e7a06eb856a5236fcff3c8ec17c950a80e084130d519b586b8707a03a5d6e308819b86c47ef1dd9f02e41274f6a373f9d9439c575dcbaf922fb65cab4be8c09cf5fcad6ff3a5544695273f31142021bf00e123535ae8a46cc0a4cc81bad5b9d5d340350eb790ff11ab01d52e0e5c817c9c6025dc1e181df7309eb57cf7ab79d77e55d67b23c8c0658ccab4d6f3e227f917aba5ecbaf5f6b472f0c6e7286bf2f56bc7e27e6619a385a6fff72a0b90f87e132e0376eafa71b40b39ca505d7b94896a44ffc4e2c1a9f497dd5f78fff6e3bef335bed99599dba0ed4042f0c4703ac61db50f97da76391a7f0929a0a180f87cbf9932c2fb23df84d3884538ad61f5152d61f33d59d327534d80f554325dbcf70a00d52e121d57d6ea63419ceefaefc876249aaa339f8071228985b7259422e8effc76f6950117a68675d2a6875ef6143cd5ce3b83184c7c29ed79c159c3611d38ff519164a4262e2cd9ab9eaed6eca91061906f7031c193eab2634e8fbb680564731e6f00eb78aead669865d2aef861cafa4158c14bac3a3156efa14eb8d4f5e999d5cc953664eaa67332f338bc59a89f649fd513eb28a2f8e4128994418393c3738b52ef7525ba06657d51034fec9d20b60945ca23a4d23f567933351d08dfe425c30418ade1c7b41a1c8a2d40c232ee16d84bf87744137d5e54fa9ed6264ca7df86eb66e8ba9d59e3d92ce26001402916702bc5d3c831a95cd283cc57656bc346c25b80c2d0ea526b88f30340415a09f55e7c91d54e423a7f4df4069d50f5a3d81ae3a142237f4678d27c8056832c8f7a6cbf01ec70fff4dc92f021ef689a7f2c86069c82d997730ee7579af411b6d8081062dc8e455da47218312a0baa2a9dce8d6e3bcd56418e7dd91e224ccccaa3f5b38a5f29a5fa7aa406f3168f99d43b20ad8de88031cc27327544162e4766643babef7c4b90b625c1426edf5e4fc00b42a6d486ea733cba97cde05725517bebf65c0da751c45731c384ed180f01a19b4c05dd53b942826570f5b4a4bc0905ae9b8b4431f782c7e4cdb2f2e94d7a7c8e0bd80981806517ee39bdc8216b97c382e94305d2da093e1f316f5bd25be6cd52596c24fca239a6cb3911a438defb56bea5fe3399c83f9fdb822b347139aeda07819884bc2f62c5f9335bb5c3d35aef281214750ce961ae21cd14eb6d4ef0fbed0516f053c0e809331fe5d5fb4b19312095baac862b8783f4c7317f6fb5a02c1f6e2020bf0393aa7602b68621f8eed6a74aa08970505ddc6d35711b4cf5a2816271a3d52549a8ae39e37a7d4ee841c8beeb00d1ddc637c2f96e28ea297188d9eeb9b4cac8a7c8914dd1760158706f85573eebba2a4bc08751ed8f76063f37c77bb9d3a7b7ea0c5a6fbbe4d5e65d42746a3bd9b7722085f4a3eea26c5290f59428708fda08753485a0383e5f62a14f87f2767936a67a71a18b403df9e9dbec2daf201ca52bff2127c018aeac164fc440b59806ea29cc83ccef8a09ec8db3fb680c584b46c08c42a55144a36078ea9a4a9dbe5076bb95a46eb5911bb5034a9efb6ac77d2f682c5941010eb0b18d6630a26c2ae10cb5441aa7e3cbcd65c43ba9fd25098b59b743e5c238597a51c027606f20895c6c6686001e9651b460c13c8a20804c3ae765c3f6eb45c96856a0627b4aed4d68e7bae9338a02a91e8cb535c01a9ef839848d068aae5c686f7f375b13a749e59b0d1ce4730d4ee8d22b5440bc59c32db3a2fbf94bc4a1637360979b395d0cd8b32080bfd97d2efdfd25674f48f1656c68659954a93d27ad8e337bded87af212ae146142602e823255c89db7347464cdb7dfee90f3263cd5f89cf91efdf5b2c88ea88f260fc4097eb16900086150fb8cf449a37c80be9172f486499588d7cea84af573701a227d3cdf85e2f0269636eee2e5cf3bd365326ecdc0ad95559040e945ab19fe05b87ef3e4a3b08b4b86b884d941fe6adfa17148c9d41cbbf81b208ecde95e8d6c6936b7b98cd25470f0ad389a765483c03c077ba65da5e3c6d1df1252f99626b1d7e9fd9250facd90eec16546f8c398591900a2a4df682a96d22fb80c5d76921369cbbfd06c48d78c4dcaaa884444dba861bcb535991ae5d86aa5f22e655fb668308d48b7268f0da7f129361b619d6b4fb052dcc52a4c89bc2f8cb58ea19f001d09f0f021d92df88b27097c88a9f15a87f9dc34674bb5bc922fc8a7a78404279730b5614385f04c9ab178f3176d7f6de78a10f3cfc8af5ac96744cbafde43c70c35b6360ed05d9a102a7ac099a861cac8678d8c9ceb8f1951d192b692c991866e7589ac8500d882229ed983212b90eeaf0b616c7313408ee73fdf7b614c51114781e93e4ab651200f406faf4d888e9c2cf71c7075ab615db37e47ae43564f2eb5b522ed01b11c8aa330068b3ace3131bd1e2af6cce9d402387ab9800117578f5445cd0052f884f1587fa048590451f8a53eb85766f01c9c9d1eca365051ef67d2d9b52d01f0c3144435cfd02a4efa50e3f4bd46ddb706b1f3550a2ec9f228b869ef956b3ec245c28beebd55d885edbc052ae0c6fe34fb4b132a8b3cc3306e3aed6eda9c437236d80664fb14e45014de1e8cdab142f692f0c2db1675ad7a63d66e8092363a95b41f2d98df4a8f5a6b0df90e16673e45c4514291f4ab49e3cb4575b90dd8812e25fd9fd0bcc337cb713ee31ac6f9e71ff28ed7f471d5d1f411e6da2a93c7e1fe208c814abdf7166647eef62461f0d9b3993765016a7acd57340dabcf935dd524058a4c54f5b7f4703fda78cd4ce608c24ea81cd117f7eff339a9b1ab028ece7865e8f7ab1c6f6713f26b8e71496120f9304c3c10884b85c64fc5607499d971fb50ccd345c5d3977364284eebaf9655af880e94315280a6df6f45753bb213e893b7523926d39cd859d9d18217d1e4903dab8dccfb2373e3211725d2f96c83168f113f18fda5aaff164ea7780408b951a053016e2359b9a9a2bd84816befe30cf3321212507007d6534666d1f8c7f4a342ae9c45a4963b037630d7c6fae89dadf2fa6ae25ca4f6f90031e889b93fe37fab00227e5c2d35a4895dd386a12705ded81625073755c22c4f123277504e75e54d12e8a043b6633efc4f6d1114891fe7de834fdf3dc4026c08e1783b258ac90067b1168be59e37dc2bd43ff34549c6d16bc3ac44ac3d7c579e85dd79346f9733182f4ccfef03ea68a5e23a53a49052f73969a7f195cbf1c51e4d4c78b7dd0da734372c5964bec3515e3afc2e3b3d1393d95b170f23cef2fcbd5df0f2dc31514500b438139d2c73aa65926ed01414b053e1599e6501023280c401f592f3aa28d0076403fa1e23e6f7772f113443b1790bc4f92a31d3b81806018d50cd8146164d18afc44b15fec210b78eb65e1e52bf366b65286de7d18a8630cf99216e024a81fb72c9d6d17c78d216183929c61b8ab865e102b11f2f33c7221137817bc829af6f83715d72048930e6d1cb08c229216a7d7c00b2f714010023de119439a0673055a50d809ea7aa70cfed511d7ff1dfc3664d5222a97250fb95b3a7827167dd64a521b7db7e377899a2f91553661562c08351e7e7f7fdfbcb25732db901427ecb060bc842f78172a794f906c9f66263a8bf5c1b371564d97975def947c17e32cf83044adcee77bde3f24deb868ced059e4ed446bd7dfe1513750bf4ead57094314154f68b22bef88f4545d76e16c8720eb231f71a03e7e5f323cac6d8985efb9ad3e99d60567f29bb045004a6b6d896f8c9123646400b7d70797da5f127b2ae381f1c6b0b60f978e3f26cf6b59f570c0d2eea868f7b3a38814783697d1ee39576b81dd8813097d2e9dbd6e489e837d2b44c52a5065b6d9363b9519a42f1355835d4f67d67db030c7eac00a342cfeef939fb1fde128ef6c5c0bc5ea42970919eca5634b98ec3799e16394ff0d2be5c79d27dcfd9f9003b88ab381d4c3dfba25bd172a62172c4c2b06ea28008c3bf5aa1ee5774b5d97bbe256f2dea8c5e8639ab80871f1486e5bbd4e9281441c18598a9756c4325bee2224348186109423214fc12c18cbcc74c2d7ff8a7de43f5195be213964fb62ce0880caad78cf1761757d1e31503f60124984551b6d7d770290ccff80cb3a71bf2cb9a327c29119e870b54836a453fdfa4fcb509a1b724f5e3a660cf4b11725f91d7f291efc186018cc75c6f863216d036aed1807052900e0e16047f9133ec67fb53687a22d990990207370d04b95722f0280e98c024a095f96e3578ec31804872b7ae88ffdd3471122eba302bd6b3801e6e511a71346555fa7ef98b36cf207d248c2504a80a9d26fad5ed24fb08f3fa385","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
