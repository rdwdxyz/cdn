<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"657c6d17d7446fb0c57d61b961ae67f8af27136df14beb5e0d0eb5d4b3ddd950a3ac445bc7f210f3e4e50d5adbbe403159d02b36a36ab6773c88fa5742e165148ddec221766c4bd6f32cf2152c47e0e703dbaea97a27e952a219145158c50d75b188ee1fc3eb5c6823abc16cc04b38903312442e4cc71a6904372c017e5eb98340127003935bb79b8a2ac859eac62d19138127faac7f2c1cf630233d3cb181a23f18e67670a00711127584be3fdaacb07b98921ccf5d5af88fbf9c8a5aeebe55e3e37537eae4e0e2e6fcb8409211b489e672e5e089cffa91582ab9a7c3d35bd0da06f3ff0ff67d72c5e0acded603110da600d4022e873836109e736bacb71008700626a89f6c2f8bad24d10d149007c495f9a60e321ab4177eb7accab2797625405971487e66b0b454977bd2edd5eb1732e7fc89238672222e4a5959accd3c55c5b6fbc7bfd3d2d423f535161ae7c6bee059ee7c3710585b37be87a028a324ed7d81dc17407e90daa15c84450fd9bb967876efa99fb341df85f302cdfeb927d3b666b23c648c1eac11ce4a948fba4f900197918a886dbade415eb51f196486eecd2a9cd16ac550c293f2475ecf125252b4680ea5c77e5b37b1e458bda0245fb2cba639a9c07a1ac5a250356d71c42aa3c3d27cac7ef52d672466928a5bbaaa5639760e4270034b1fa87bc306d9efe6a554ddcc9627982a2cb2d738ca1b3c00b728513de1aee5af6d88ea809b25d6edf7bb16c2142a2f3f224fe3e4968871e8df7ca317ea86ca45a11ee2637bd3d68cf6e2c93613d1f71978fbca45878bec864e55bf41bddc4c42b89e967c0906bd2bf476197cb6e9537f99a90b51eec8084ed084bb35115dc746acb59bf3736a5a2e1c8f351b7b5520f2ebfa6b9589a9c6b28232b44a1360842237ee0fc9a264f8e37fce4e9e94f4df4bce79cf0cbc68d0d154fab4e880348de4f2ef3a7abf290abf4ea132278e082e1ba9782b1dd7d7f9058dbec093f780f38b5cf27e90e2a66eda0eedbe1093bdd77492ea66acd7ada703678f123365e1ef669f3c6f54a9d9a55a3703c2723615587cb8c3ee8d4c8464d1e88f930b2e3964debc259fc34253be47d1c14270eacb6f20e8e79f39c5bdfb364a001f702257662a63a67e7ba74fba91c7e221e5d7a70a11a733d0570a6a2be1e225b35bd4b409b288bdf735e6ddc1118310d88ec89ea12c161869d092a288c68b0be37e26e24372ca97cd49d9fa39ec8d12be67a2de520cd2be64196e92b8139d424169c1f588b9687f0588b6a8c4f8246c19884ce3d8450d6e050a4b608b1547076e53aece2373d8082c2431aa150076de3299fbd12a965cd2764af2586609f6d6e9a739bc51092ede3b8982539a60356c55676af5be03c1d909099caf05161c2be8c0fefb989c5e1b41676de116571c4330cf2eda33cf60b3dfac8d3e9b47f52fdafeaab045aec024ac6bc220ddfb7aa519653e76e1a8c6d9d04a6daad9ce286b9f6194f6868961ad672b1a254a7ad177cfe1469b27616ab6dadf9a475f8ce3ce8b27cffcc1a566d50e19fe54e464f86ce76bbc3297e0b9c67950626cdfdd568300340e7db5f311042088cbce1786f4818b326ed07a91feef2c4d5cf9ddb2e404664b29111259b5d41c4ad2060867da371216ba3a88163152d283f64428cc61b947609d209378b5d213d7864761f48c82945deaf1465ac4c8eb9f9b9c12c49fa1a63bea7c4abf761b0c0ecaa384df43f0e01e474130e6c6bdaa564c070b13fea89498e6071c3912cf7a83fd243d0eb0fd313220fff7a5ca22763df87c9f1e2fae6dce30064860651c4e63c41b7ecce37656734b07dd8da0270f757733253efbe926a3c4a0a039348e9b28361a73b5c2b743bf8b292784daa2b6d96115f628f2371a5ff5f5c9ada7b07dd949f123348cd6f652db04b9faef6f84486749b142369dc543ba3852767f23570973700bc59e58366fb60a17d8a866ab4499696ec424e7463d214ad0680f344cb427758d7e6f76dafe031df70bb49ace108263b745fbfad7137625695c1ac34c420a38d48e21dec77dbf7f90c3a64751a4687d9021cf9371f4f6c64f46779a6b142d4113191bc77cc7a1a4d4de852601ce13500c3b0d7b717e8e535f1eea9596afc578546d7bc8084509feb80304f54dea02d26178093f1872329a631e84ca2b9d1ab19297bc97b8e17e289e306f278e53df7bb71832f98ccc0c29ab899c38b6619de0d866542cab358f033cc5e2cb10bc4e1a3907900b3d8b19aa0f77604829af3e775a56e8ad4f7b1d7383b909263c2925289b43730888e8654eb40aad612372953bd9fd307f7134762aa0ce9c3f562fc01477d63bd7485467e6e3a41a3e05c045efe8474591a8053a9e5f14d280ff64ddeaff1bd1b9f13a0d439f52faeb4c9c70aed32ed340d1b7b597a04b4ba971997535b6b75244d25a1488a768b207fa63e448578a88aadae18000b68b2f43d811ba61530a8b31ca0f6378e381ab23f7acdf247a478c1b6b448814bc3a19aa715cd6192e8bd4f28e4b139348982b99f067662ae5e45b8d2235aed210263b88b865df0e4d6da46b149ad0d85d2ef3667db07b1c116d4c580f44103e89c79e8c7ead598227fd6a900afae0a65f907f06c2b01d2e3bd8d41d61a570129d55c945c5e7b200ed74b8850e4eab48bfcdf32f4146a1ea435754cd38ca17a5d83235be24afb9b60850b1d2950da56a54ee89f6eada2bcc24fb6e672c0df9b6138d079102f32a855655d7e4e3955127d8d94692401cd225e565378eee8a6e2ce973f91deec5cca1eca68e6c7706924f6ec24b277e96b8458a7dbb4b267df4afc93aaa7f929ce6ebd9196dd5d59f6b72bf520773f94e93e4975696d9eff1e30122fe91a64abadbe69368050f6b64952e1627c4927601d22ea7bc802bb24b73d5165c3af22fbe0ab61c3e91183bd3fdf0b0c83dee3d684a2d83f90a9f2d4e9cb201086199a4e51f5ad823dfe063907cd56f114186963acc6cabdc55a1fb6f5a5829f776c50bb35403b632dbbc10bd7936e2e8435f5ace73ffd44886ca369cd1f327284cf2022bb6b81feb1ae29765ab4076bc36d23ec6ce2ad0e8a8fda3ce9505714b3b29e69abeac358750585f25f845f788fde824355cab4416bb07b06773439bc3b5c87af265a2d304ede88fffd67b17f217c6e841f550c289d0037799ac5c4c423f31627a62b429d60fb0db50be523a54733b80aadda4085facc78c8acd822571fc483ff93229edd96d40c0330bc3e0a099e19b04f2676cc03779b0bdc05a1d049212000e5814c7b4ae149d8a21478efb5f6dc4ce094b65f4ff9b3d82de9e54857324439ca19440c42f70406f782a5aac93cadf801573b131591749c655f946144605b7b1181c2316cecf99713db65bebd51b0368754739216f828ede8856cb00812a341770b20b9d4f6c1725f17c73d98df7a69ed37587ec8635f7c71f30eb08a2ec50203cdf44abe0da413da1a057a9133a7dab0110ad1178cba4618ea9355e98f4c46401b1f57e355401467640aa6f55c49df0dcbded705e051aa5ca17a3edbae39a5fcd001e996a338aeb637b35b4d002efccc771171b73642eadfb7011dc5bab6134f1108566b0c3e677418aee0a90c77b2c8901fea254838e774e0ede0f4e131b740298f43043396b20711ff76510db235d41099267038ed114db83258d99a2e054b0b6be355039e8bb8afcc7d49775b144df26099fadc8996d285dcbd65cad79f08c59a5a4e1716efa736279d645aa95d052b7e3f363ab5c8a7cbd01deeba42903a7fb773485ef459cc7319e22a819674d46d289be1d5aec84d540470d5101198047eed12b910bc19b3a4aeec1e3c9c2232b99c8a66e8855e806f5e2684a36ff07f004e3957af59c3436ed59a8547b1518246774fc57ffc2fdb51863b0c948b3d15f54ca18eb015d5d62a244691919ed0517a42601d6dc2ddf92e46782264def9b5c6e825959279e5b51fe63262f50e83572279af2e1891749c51befd5f9b8685e0cbbc27cf54b745c08723a75327ef2cf6c63a56658e8dc49953f3b4c8109365df202aff15a1d736366c1e213c7a8382bac93e0012d3a0db6540037a201e26c18a21a08f203ff88eb2c6edc8e32a5e756c4243d244f9408d4dc6f3310876acf3c437bb568091a9294aa0059fdf2dbe85eb22b27cd596ee36b5d615eb750a380c84e3ab7451ae16e92720932bfeda876e97819416234cb5f6312063b6e80f585569e9e1fbc8e46f28f336cef261336ac201e375de0ba1777712726a543cd0d86fd4fbf17badb158a3f0d4184d95e7e94ed1444bc7d7acab49882dd55808b44f6cc091ad061f1aa1df197d3ba6b4dbe503827cf85d1a51ad3c0f22244e1a0adfa732a980e5706cb8e410aa736e1d697324da0be0e26c6987eedc1278bdab39bcda086bfd92bee14c13ef386553e367976b98f9d6d57af0cd5e4cdba580f63d057a0d301b276db299e1944567ea7008fc4d8c0d6e0e58b3cd819ff1e4ac1b04516a438a20aef7c83b1930011f68c2434578c96e378f32c7aab9cae154cbf5c96a7b3e6b7d4f47da82563e62b8183ee34bc8d4409bdaf6ec43f0d22a83215c5b9d9f0b58bba3b8b116d14a868119457ae885bbde422631a0a6b10dcc4a95460cd3998446aed76793f1a02e0a8daf13eadd8fa06ecc1f9b1b209221fd59b4595346e6b99acb807eabefa81e39668aac578d1252c7c51f682fe635314f30a49c94ced4ac866909aabb45e26a48a0b842d012b965f1ab1d526e2c57b6b0a4669b2ed81be51dcdfa8b181d5720545f1dc1fc6c70263621657bef34ec89129c44fdd05a38337d7e7180c465a49e8b7cab3cdf68d95d97281ebfd4ebacffd8f138c3d0dd0cd1c67eb6d3879542606253a1698f27a191a4b4045fa6ccc6aebf34a7fdef18a665e6af3ea53e4ed5326187bcc0a05d70ca70fcb83d545057a386c8317231cc0afcd9ead0af820a5df05a05d5826d9ca040f6db9fd27f237d9678bf3359ec59f684a0d2a87037c775de1d85dac8a5304363e7accdb84ede64d6ec68cae6819da3ec258ddf94d21ae19f8bd31791c7dc6817a04649362b35026dd6832ef4fde1fb6ca08148b51341cef261622c6934f223f69b8634fa841b7f769c744c3dba1824aeb031ca2416c8abd4af39905bcace5b9435fd4eab7fc7bab436ec74e56c226dd6d0abe6a0add1cac7cf30b696524fadea178a49bdc46cd20e2ac50dc1f43b6ef2c3acbca5c3196c3b28dbce3cc369f7e2776a58799edf16b863b5da85518f9dc24f948a28859001da8c94656a51d9ddcecb3b8822592a0b813259385de6a33ad1799cb50f48fa05350d1503961c9f4ba7df226a1ae34a99795d840c7ac89bf84e085beea97a2757b11855cddfc8219f05eb31556882b1dc569ebf87dbaa4807bba46e84a080353571d14e7fc42022e8fad1a1dcfc63f25deec1724a7015b51111299697b2e28587e0e6c11b89b8799b19131a44d2ca737162a82a922182348e45a2ee9fb54d11388150f02f68a95614afd5f203f18978e84248caae7a1b916fb18fc6717090b5bfdf05f2f9a36209d6ae269eb4de24170a86d91a469c9dff5b128fe37c655dba47ea9bcaebc7f217abb9cea1c819bd3580e3876ccb3e3cd695f1664ceba71b0d1ab2918aeaff741bd33e2683c3e09b97f885a78dd61ca22de1935c6f1bbe90f082b8c60e5b2c330a1fa523ced42354f30fa7bbf6df47b3f666f988191ee87f5e534e47a9f53c1f5c0d22a770aa842a2413bd39cd0eb271354b2664529ea986d0342003ad46dc65940337fa727ec3fb09f5418bdeef305498455ece23dbfdd5a00ca5a17691e21aa39b36d5ac79d219e0265296a64477d9fd2775ca8c46d1f3e8e6da3423d8b3189b4c2ab6dfc3296b2276ea0df464aaa7d47819dfeaa5089486ef50714f5366ab079e09c308844c7ff90b44e00dbe4787503a166667a5e40e91da82aa140f4bf7af23233eebe688988d685838b208344b13589c9ccee5fdcd0371b392f16aa6e5aae55e8c957ffd07c1736a6c219abf9daef307b3b80d74f506213a29d2854682bf91700663b28f56b2310a7434817ff8cbff729e3f16f855fc895897fd4579f6fbc33e65a5da7d3153e3c2b19f4062594c7c8e65b463154ba1d05b5369e5e5c4d2e44b2c7f07a8366e8721c3cdd41672d50a89a96d0a65ab936532ba4f7c5894968b194721b6b0329e20fab3e3649822ce7afbc23de0fd855903c169504c32d22c527fb0764c10044ad4ef1996cd8a4a457274d7b5221716b92087075db8b29810ff6f4ab1420f8867ff8ab715c17e7b319865ecac56d05ea13025c9e6a79c8b55904964e7b23148fc3863604be2539c0ca7e570d615b6bed45b7a7c7631e2603a048b4a22e0647d3ab3695d829acdf9ce7e9ba88af3e8773c72246652b05c74261233457ffcd8fc060aaab81bb5eac523178f0eb682115caf3820fd10490712812087d2777bcdb8b4126ab8bdae03cf9d71b3063f5af3ea806767f84a380ba6e37b2096258078b9cab8ed40dce865b377664b5b83ee5fa5b0125d35e7619eaa385b22c58cfa122672f654fff2cfddeca9c79a80390a861738deba992e1973b3a3ef623c11155f0cc0dfbfb77c902feb47e81bc9df2faeaeb231023440f0779920d027f2731ece880e14f36b37cf53c6efbedd22f360d8fdab5abf2a4d685fd65bc6aa86a6fbba0083363cc40a9a8d847e60944074ca6d02ba190737c6e81b78b37f4fd1210991167da40df93f8050342e45bc6179bed366d9707314e62aa41d3452a309c6b7c3b462b173158eee3da15dafa79a96ad9e4e9c82c75c39c80b557eb5cd45646229acd5c639b58aaf8bbc376ba2a8c569c073e392c389847c474b773a6fe3648782e985f40a126ca6f805e8a5109b7e8cf7c7a0bee3435074656985a91884826b9858e6b35c2b9d8ff64e91e7cc814cdb2629ab397ec37c7dc0a34dd61e692670b94f5c346a9ae1fa23de4473348a0dcc43a2ee8b51abf4c509099e744367117a731802925808f8d3f91f3533b9a1efb19308f41326a40ce70a07cb3eed7431a73e35d750454fa6c652ecb9934f2c63aa13d8d6a6546c5c32f60fb973f58fa1195cb985dd95a9819a301398efc4105781f3a9e124a8fd4ff6f3315dd2f9aa486abff155c5cf05e9fe261a0c2461bb8abbcf5e682f644df36db67219e82a5fc27dd90f56eae3244d37aaddd0fdc36047543a047501ca550e0527dee7fa6e4bd73b96247427add27b27648033fb40ffd19faa377cca41b5477d068f388529e10abb23ecedb94ed2db5e55c2c7d9bc5635f5334ce0dd1ff41c2ec3fd3f0329de9da6373864813f7524be059108675beb995735afae1f6df1f73def8dd17a955c79d56bcc43fd39868b3d9f50c7f1d2fd8244c1e055fc0e0fe765edf606c171905b2e2ea49266e0ee7a3341c77513e82400c4ef3766c9a0ed488ce87ca9aa3628f1819b9908616c65a636ca3537ba6dd6669ae8ee1ad4b151827de51eb01d009dc68170e9528ad1f0fc0346aef2d751016662f2e99030dd552f3e9145e285646fec759d4c227765179a30cd0b538fc61fa0eff644f255d89662b7bc5e64daaa11879d4b8019f5528bfe615aeba0c19e11ff12be9d6eeb5c72c0a3ae6d0da24236bad3bb66b207932c271bdea6d50c5ecf2d2b13c5c8f461d0ae53398cdb468f59fe62cdf982fb25d1722691bd781897f734194e1cb2a33b87ff581171a994c745b4df97cc740445612f3eeb07b8875fe5926232cec9b6c30beccbffe6a195528d45b57b8e0b9b407060e16158ec2938ec742c9b28e0776d5d7afb39b6c92fa460dc988ce2eae5f77074801e4bd8ada676479e503991dea2b06bb8e4ee8639772042bc5e14be0c382729eff574fa647654084527212ce8648382a39b27778fe13e9f9b668ae93506f829e1896ff206be5c3bacf200d1c1ccbe846ad810acd9339559608475a028dbbf279be1e355a143ec737078c30d297c2cf830ab19f2210c1648be4cd89269bab9a948db16fb255394fd5081323d202d465cc47e1160b6faff7ab8d01eb66d5f3f6e66b52946a507dee3994ffc1e5885510b6ac046ab21f95ca363e70bbd312c3765f78763a7c18221902bc50b802f471028f3a9c173b6adb47f6d236694ac766a42d77b18b41cd5c8e0c06a8b516a9e368547e18063d1856f9f375894bac7199d20640e22a4d0d874c44bd0a9d57ad41fbc6b37f7d3f4c98787a541fc445a47ce74200a06ff7a575fceccb6152b8918d144e263af3146f7c0f2bda52b4fade3d5b4fb4c513d0761e3473d2dd3d7bf824e3219231e3dde2dd7405cbe282a87eb0596c0221d4ea34a6192175b615639f771bfbff419a5622719a0d646ee2f49bb0f18e85df55acac105c2088ad388fe11441b9a9c0c18f9e2128b27d23993c5e2eefb67a4e6be024aaa7bde851b03ad4c0f55e4e079e41d50e419e94fcd2a90c3fd9f07e4a1b99bb311d421ee9e547a3c700df2f02db573592cc00b0fb227a0647a693add9874d8c4b00bce972517a1759e0a9ff6fa6a0b64db7bcc49ef0051bb00498bd5500695f64bab7a3f2805a653e1a68d418976f370fad949d6fb7dafea5ad7802b0fcd41ca720c3859f3537d2b9f22d2b713441dd666edb8e31500dc231cd2eb1f1c757c66318266b4dc58e4f5b00ed8bc26fcc69e8b26a0b11208dbf34a327c9631ccb18cc974b2d60b3fe915e86ec82703c7080a5169808db07b6e430de2ee3a628f0fa30de8a27df75f0b2164f5aa9d3aa1fd9167712d36937374400831b5d341f510a2e4b0b57c20a02b67f05c98e1ba328c1e772ad8139dd5f8358f2f01aeb72f1e8c1bbe874b52e63815536c36d294ce14ed215ba61d13adb6feb96adbd9ff4d6a530a1eadeb6271ea01c2ead8d82cc7c827bcf77d0f83dea1d9f3994bc33d7a285612b0265f1cdcf4750b5c13b558d87914d572e3174eb6917b231a5dc3358f9c06e7d258395dca775cc3d4179160ddf1bc8119911cf3bf66fa45e804bf340b4b385425e03605cc46cb8ade263473eb5cbdf97cd12c8b0edfbafdcaa543ddee9d0a70ff59c7adbbb57e41bf12bb6edd2ae1b99fce67b16dd0306cd15ffa3ffea5f227124622142e2ff101e3aca4c546f5bd42b43d76e0ceff0b30e8d4100c3da9d1cb033cc15c5c52bb56f6d9affd13bd2ee837e9fcea1756fd58b2bdf787c79495feb29d5ee50108e64939476f33ae7c0f3d628d891e2603a4d0cc7c54e83de48e58287cf1336dabefb51119ae2af82f7e01708504a01c69a9d1ac230ff9daef07a7ac3fc5880dc26f2154216c8df6d487bcced766195f35389c8069aef6347e2487e3b5493e89b206386d7825dba61d3142e65d930d7d37c7c1acc09b01e27fcea0d8d44951241ebef4a92bbf800eb8111ee092990fdec5ce0049940b75cbe241ea324b57dd8dd0a1a5c5ae505e38b93ab4c717f88d6ec098e16e9706c8eedcb960bbc2e3222b100937f8e6122b79d185afbad743540eea7b5a889902f347c68c92d811888a517e2150a67e7373dc53760117961f29adb03e53867e90b33c641037249d7f497e7c0833a4dbca7cb044e09544750bbbbd57b9013ac76f21d511a4806f7ac1f83972519d20ff0ac7f0e7c0612ab5cd2116a891d04e046f0fe79491d70bfe4f55cc1e7a8946ea479cb9aefc841bdbf2f731098981f154c92cc804abfdfdf27ebde4a52b16bf0c739195ab9bc3ba6c5b330aa514a4f6b43858538406efbfd2b01603d990ee03a793709e65faeb94c773683ba5a6ffc51108137bf4c52d10bc316d65c75da335f310d7514ad66b438e066da543ba99f10e8232a197d8ccf66bf8cc8f71b9db6fc996f1ea97b8c4e507d3ff4c7e99cd8c317886cbb099db58d850cf77caa7d694b6e2407016880cb4671a31a130d3f013a2a5ff59cb56e4de1442685ee5618d1e46099ec94a4ea6c699172d218260590c493ab02a7dd083b0f6a6fd8b8ada1ba42c4c785e5ac8940d2f22a85e2721cb9d2b75602276bdea626e48c3adf4831f480cee67a34e830711214b73b430d54f75c7fec766ceb3f637c1f1e64f5fedecc3285468595dd95c75a69994267ae00e74ab8e1a77caf62999152b53d8e55dba586ca842f36e17666625f82b331f45820676b42a3e4c0d9e42d2a996fffbb37a58b9974b835fb6390ed3722a21c4f256cdadc04fbb6ea1ff3e568e975df56273a8f7cbede72a96aa4505b24e824f0f6e46ae4bcbcfd7d36191b98493216ca089baf8c51c4463a99d95994594c8db48c40f430068411d5d4104a81d9faee6a1f65e0a83e6b0601f0115928f33adac538686f6a284fc3f247dd6cd3393ab5aff3a7ef00a9f622aac742646b16bf16bb561cb466e92ed40b59e3296c7263d095a53990fcd3409f58ff7d0f0dbe0fa13231036df287e85093396cf45767c9c71085fb26db4f098dca682dbe3d7de771ecb682c73b9f0d3ab1df59408aefb7cb087f7e53dca9b1f328a16b5f2183cc532567aba149131f250e9390804350902bbf32568c0cbee8da468218c216d0ae31d99b06e4ab54bbafe2d42f6b04cdf0dd6dbfc0c7d84656c61024762e3e62eabce4e0b976c9d59d488b4a72546f509f970206918042849eff7f826c051ac9ea076de22ea2dfa6f450894df43cebf942ea2111c318278b637775e79a698d3e87686b44289ef5db4b4fa5c08a763794cf1370e9b4b3715421a6ef1f8ed5c16aecff0d7c9b6e1b12256ca1e2aea5b2360935696a48c40ade2b8992ba3c577ba438748f5c03762403e98e15165376b27694694871f756043b029bcb76c84de72643318b9a46ae8e845545d3f899b373a55f0f9e189821f0f31c1205f7aeadf54b0b10fe901b52c8e7b537df3fa4698a516972df65372356df306568789670fc5448748817b135aeed1171a5752f17d33aa3fe573f86d31e6542a7b138cae88e5563fe74cab3afa1173162d126409f53fb95f09f35f83691541c259beffbc97cd5894ea06e3e2e1cc8968396a89bcb58937f210c0c09190aaa8ae57c5dd81b10c410d1fa203b25ab96fbddd5c176cc76222a90500e238a8cb45d2c1ec4dfc60573cd63038cd7f5ae8046e1c542fbc06743d4e1c6d0cdfd1ec46481c4f7785d96494f69fde29a022e7ebd263dcc8cca4906ec28316c18719304d90529eabd1df105cafb3b1bd3dce0ec1178c8655202ce3cc67425ea70a98152941f08a3df95136b9dd16725900fa4989f90858540f415e50585da839f855357dc869aebf190212fc7d2d87bb4df5104ccb17f39a82b4b976232d5a984315679ffcfccee791a96a4b9b0c4660eaf55807f94898499f6fb40c8ab6125cc7a05c0d6878d9828153805fc95d306a3cf4754ce5b9215018bba47f46e1208398dd7596db11d6341e8c721dbb5406584f2cdcdbc3c88ef629dfba8047d6e3f6fcd40b66ad0815fadf9a80a71690e57b3303b20f47bd78e6f9c03d60bb4f76652c4cc3869427f945035fbd9f7f0f9c67bacc0ce2e1106f6e52a32abe3fd0d9744ac02c0db8bba84bfda8bc0e2a5a9d0e1163a8a2ef19b9360649355473e9a4299e6bdb75060e55585e1e88492cb054dc2c488ed5ad79406caca707427939112596e9a926930e4d71865d5c32591d319527f6250beed16d01d5894dd7d85167b37f7be1200bc9d8853c7e6f43dd3a052c8a34ccae7fc7aa14c69bfd4b3198bf33423571181f687d7876b3a2b800f297d7b64109a1f70317d630dfd90c22c006b054f11753dce08514aaf8b358b5c76390e69101c06fb3f4ef79dbe0965d8577a4fad2742bd4a8b4154710b7fb60f740792590cf0b26b5d1edb817a948f667cacbc24db3af27ae9a80c1b3d053baca4b616e2c331c143b03c39e00d54df902f69090e988b14d1906ab57d94a2f956347961c6f1ccfa72e4d828615bd3fa625906b4936ffef5e200915c978539fe9a7e8d79d0db3eeae2321a29bce186d6bb758a963736cf670f7937965c3983448a9bab41637652dbc0e4cab2d2bcb13779831a5cd852f28cd1fb050418016576806b0c07a22cc533c3e6fb51d68849eaf7ac990a2c96a7ef4656098149c72e271fd2383bddd011910950a9dc9e84d8803940c861973e7b3f24019feb570f8eda6c8a4651205172c8dc83c1d8176b56ab35586c340d458a779dc778f60cc32432a1dd9a524591c1f157eaf6b79fa601a2cae30b749f729606078da217f5b198e0c9c276006ffec82d569fde3cafa5e5c5fa3643f8276b31c61da509dcd66995c6e2c60ece734115d7377c7f8e5b80ad4746bd3302f76c95b2978a18330479936838317a85b22bfef14cf400eb5be2480d2dfc87bd00e24e3247971f0acd57768e3a653ef05783ff96a947826e0d5de1c76c8285111ac9e6b01931af8748992f3c2f0c091fbb36a77ab8f2f447b1ea18b34aa35313d02ae4561f5cf6ace39d606d2122bcb67b65ecb43a25f1c9021ca5f9eeac916260bc581ef7e9cf078572f53bd6917b7390d8ec6da572394d4bdbbf30784777b1d14eb74efe30cb05420953935b04f73f03880773ce7ffe9edf25b8248298bdf927a30d0ff63b6fa1b2de1a4674b3ba042985363668b6a46330a0e78045259f54457edeae9ea0dabb7eafe9146cde4619417806b84eadb5a730a93d957d1759d40b7f71d9b547992212cf14e3185e7ad65136df0aa92bd83c661003bd94d0fdfa522bd135602ae0cab66ab00edcb6f662aa689db06e71d6e4e856aee37040b2b16e24468710a26f823804b90d3459e6d4c67c9990be58f421b3e9b871f9eb112f6bda2bde16350ab40fe87548f7fabaffdb9987edd47bcdeec71812bba2e7d3eb084fa8d17d2df606c592c99cb151b92af893bef87ef1560976500a9263466ee817911a22e6aa53c5a395d5f8076deea131cc367e3123cd7a6f7ef12715187c09328ca994c885d0f84812a32ec352f82a7f5eb904fbe39bf37e9f72c0655e2093a8f0554ec1c8edec46f6c814ca1ad60a05440dbe7e383a1c6e65965f4625fad243482444080639f87fd9a6d0ca4fb9dc4e4086d4e1b30e33a10742061b3d75c7def4ccb5740a82f87a30279e0b1ecedc14ae26b1034ed7fd9d96dd99a291d41e0b753ab87e2a3574387ff30019cccf6182035728d75a56847e9f4115ffeaea6329eb9b0065edb74741f549a043efa744976f4496e99ced7a5206b53cca82d4335de1eb68606ef39d9ac9bb95e2fcb97ea5338d29bbb1babe24d25846d463d91717f673f11393c306c42dd240c52a3c7b7245fac86115138d151f1943769589f7dad01446c67ce41c75b09fcca802dfeefe0a1399cfde073a99973b3797dd29543b1632c93d135130ae8532fc88714ea4dd326008d66f571b36f1ebfc97823a77ad77bbfc2f37ed8b27d14580b5c796040101776276e4a0c5002ab985eecc4155554916d2264f39be540920e1b814f357d4b79ade63e081678636bb2d70f8471bac51cb06b38869d845b26de53b3f7018c16de66eafe641b030255e7bc0315beb9d3c3826a4d7608432e59e190dd220aa6aea6dc6013a50c0a7a026d358b6697fc1a87d6db999d27fe3d628607596c8689c557601de2223db7cc0ba2d99bd8cbecbde97273ff962ba1e070c20d369ffb3eea7111b10b7382e705a86cda2568c474f464ba585cb8099fff9bfb0e231d289651c9a853b702e09bd00922faaff6a025be486cd2ec4cfe554cf211a5b1c0a581ca8365f621673a55ad364f9d17e1dd816673466669937319be7bfc50f12cd362258a844f070c75f89b6121d2c34bee7499763fde4329e2dfb01cf0e94f65e665dde4988598165bb4785e7c2e08fe58487367bbe19b3055cb1d4048364c1b30f9b8b71f7e5a0c655d4c46ef29e67d94410df95d2f3f14a9371713d199a9d73afa541cb6909331a6875d245519c0554c89a82d2cceb7212d2f85b898f4544db068c0c135e8b0625a9f934844a7043caf0873fd34aa02cae8dd8befa5356607cbd0abff2574ed086b366f3e02ccc961794031dcb64dd59d12cdd2d93e61f7454d1b46b1589f009111228c292855d89f3fee8ee2a9dda8ce6878da71d3cac6de649b1259ec90ee3fa5b755392c6b8bf8683d03250991d131f2020afb23e43eeb72c63bdb86230bb5beaf1ae09d715163750b7ade5a89c7ad2322ab727e32c1d638e99af501e0a6274a8c932c07b9d68d5246894f70de6e2da0638a455d71aad4aad3f6cd66f5fe2e0b690b46a21468394d32fcfc214454381f739f8baea19b52d721dadc38d9125b24753778848a4b99784ab30f3e2bc632c65c44e3498623415bfac230a23a2a89675710b5280a6baaf7ed8136cff28ca732bc9cc4fbff4dc8e4a7bd29e51e15e9e3e4265a223c126519fbbd4234799d1349795e9dc80ed2afb174de022fe9753efb6ec519098300755c968a1183acc99d1eb6750aae0652af9ecf261f3f5d003b1b4557b04561a6c51b4efc70c96bff727e13a5e3beba5814bb73c28f60500233cb76bc8ad7fe8e5e54e15c23180e2cfbbee154058ea9eb5551e491bd40eca4c6858622fe9ea7cd903c74f7f5a08096789ef29572b8fdb14a3878cbbd8d2276394e0bf2a893920856f7fab6e00e88559796d2b704689974e2905adea7a0de310344a9e8e673672569345fecb17fe2eab493868fd8519550facad6f7e92eece111a65590eef99206b11f3ed892199211a67df739d3865ea43850fbc79e22718fdb86bedce478f49abe66342d3ff86d1aa20a3f68af4a86e7d22786e5fdfe08b34d44636d11d0b29357348cc13da5461ef8fea21e60ce4cafb05115d23cc0a01298dfb4303f3cef33e8ec6ae695b4f4111f876fcfc75352d31ac2c137029d1a55bd272c654633cd70e352c2fbe3bbc71a209759d5985798d5f93df9d44b396442664066e3e83bacf2c1c62c92154a2d81185f5b0994be42a9108f1b06d4ddb9865b56a6093861b40134f835b9d20af394a2591184c939856acf221d773e5120204b36b5a4c1200ff3bec02b1dba61ce278dbabef57b5228e7c96e750c61688b052f0ec000d9ac927e9e76c1e11fb287c30e094df7a8c3bf803e08b9929d78d46edb9c9315d7efce627c8023a92509faa0bc78e261af6f60c5811e1f7b6c9a178c49ae590e0a0485b7f31fd12c91ccd9f2121f5659e727e866f511a18164cab9ba8d0ab354af6b9393189b3f1f83494914d40f1764888be9517d11c48b3b1d7cabc4d3ad1dc3b5ea498008bfdc34f2bafb8d7c1a454759d505efd9d2f14f6b92877a95147217e42620d1b6809709a37e0864fbdf7f7fa258a992ddd53ba2685145685e9e82065a2436520f5da21fd30cee16e5fed55e54c76ef8f517f6cd2e029ca75e8929aa3a1bfc373bc7d52fe8ea2aa58a6e1b7ccf2079009a13afaceb04c2c62a62f06572c2c5a838cd72e16001b47b5d14ca1c4b39485966f7bdfd100ae05e2183435b66c89803131038442f7123fd8bdae3a066574783421c697a1139761b94cc45e8bc73f0456ff52f49ceed14cc3969a702324d860dcfaa4c70b785eee7f0cc43ff9390304bbb6bc2934bf9b5174951c8c108a632374b79bd3817ee7cd03f3dedae68319db447768f36ccb2c96f16fa36fa2a807b0d48c28e9f5554b8584fe36c3742bde8e9b45f86be36049b5843e927bd15b5bf4970d08cf508ad8d8e8fb1efe89a9a8de6c65efe0dada28d302ee3d3618962b2b9fff73f059bc81f82afe491fcbf29b0cb52cb95daf7c976c3a56858590025e13c280679c4117457f0f6f27cca9de198541627bdc743071a9f7b53930ff75bed47804ed2efd6603e70e96badb98dd44807ac0cb1e190cb7f4e7b09d1ecf3bda69ebe6a7023d648d455bf16080337c9d3df799caf753494937f3c6ea4edbe8af967395833d45f993afd983d7a759adc4d010f73cee6e96105b672117aae7aad6a21f7bd0b0f26d76cab9278e533f3562f64ed53af702d619617ae38c8b386cf3e6de93111ef7095a8e766c344121f3a853ee004bb8749493682cb9c922c29cba68ed585c39e362d35742cdfc9a7239238cfeca776c443b8dbc6c37c4b2d24c407b8c5f4f131532ab4fec1d263f4efbd2d9072508b25867989ae27b7caa1319a3409d43b2daedf3bfe46eb337a369749008b33edd0068635fb509ecdb72f2c5c914c196d17c525f6a37b3d61d2e8332246650768006cbb890d634c2673499f497babb94d5b60429778a1dbaf78010698adf3d298fce3750acf11d4d9de4ef3fb6c53e50ef1edd50ca962c8113fdd81de5761bd6abe3454a6168c42dec46ff841b0e36c7564ddeb18091c03e603ac072d7623e0caf9c162276598ff2b6202fef2114287e58e56dc702002ae79cbca747680f77250f0053494f55bc9dff283b2ed30e419c89793172d8cdd8910b9a1dc1a3d0a730ce4a186957b7aeeebda859b0806506addf5c864005d82fbc3c276effb107e12deaea33ec7d612268b750141ad0332e47a44a0d8e41c304dc9786c3ee876fc40537a89f45e052c7c32a4e3c6f9cc2f7a7b889570b04da18ef5532c2688a5aa6e8b6d563fea2af2353fe7945b584b8107e869fcfdeab6342699abc79d1dd24ff9b166ffd230f9fa2ac029f53404a27cb80810a955ea00af27b36ddf6bbed45757c485e7c0540b638ec05911df2e3f5ec3a14305d99a51d1d8be6dfff0a96cc4b4b7e72a1ef1ee7b80b8fa4f60d5fa74d8ccbcf46e36696fca60b3f5c25efe9167c3786620ee36fd00a5f3223fe17ee37597abc136e6840d6a1a0627e46bb6d0ab78e7dd731588a21285f0de22791b2b28eed4e7d8681c6af9fea924c005ee62b2e9e0e6107f84abc00d29f43278d3cc46d7909eb403ecbca17e7bbd195c635a84ced8e88293078ec050a2b86f2b97d447bb03b369ea3dc8184c89aecf2567b9e2717a192cdd592cde4b7b4b9f8fc0d9f37249715968080285a4f39fb5c6af7abbaee0c598ca17ea77e965fe4a724e19c3cba90a3ec46a1b729a28ec790cf4272e6839f4713a0bf8770ea43a6c1bfabb5aa4cb93281618204fee4a986e44e8fb1f0a46aa7e95a26634e2e73746bd5c4b18f1a4eee3001646ec1bfeeb03ff436d45c5289b89d905e973915eb3d93c496febcbba92959b6f1aa07ccf085af6315777810714c0a1b7a825614f8b803d49c26de1c64d31b1b4c7e67cb7584902fdb8802305f6b39d5b3f8b1a8262ebf7675d01b21479c3da57a9763538a4c9e10e3cdc06138dacf93677f43e5f7530dd8aa288a7c3822caf6071287b9113ee09eb3d3f86f3773a0ee593b4f155a380bfe53f1bae6bd1a01cffbc3a2f6d652cab42f5fc4a916b176f46fa8a0d9ca04448a7ed750a0bf75ffc937b5ed789d17512c968c64d19fbdf71cb6b837dda4a9c26ef1c3e84cdb3fbbbdfa353dabd05ffcd0de3193e6315049554059682046dbcebf5f958cfb5b7a45d4a3761ba8b7b7cc32767aadc11b9c907b199421a9e2fe9641158684842c69e354eaa0b6fbe429439a00c9d7dc8c378624eb09727b4fd1a88b95caf8f4353919d4f861fd0f0d24b6d59fbdc0c739b4a926dd8703bf470669a98a6379429f167ca6f9e9b6763c080b8a71279a818a3a14c812a13d4f5ef1d13d62f796e1333fae2d9aeb7d3ded89e610c723ccee21ddf04ee7c37976549050e2fda1e2a8e52c661fff5c761b22dbe2b157e398c37415bb27a8e90a4ca2799d8e83d6fd0ddc61f8817a71ee22856e97d172f1adde00ef9f929e820abe8269f235b052954e820788d99b2be5999032ed6bb590c939979884c702647936933511817f5543cfa5269026d9bf82e30b263d98f072c39eaac3d0efdd8c10129c90bc71f0dc57edf20d277040d164d1871f0e2c250747d5cc01ade90f96a91369e346bedb8aa7e9280d768428fb3e66a2e9a642c31ea054e10116572dae15907971bde7317a975d52deec7a8253adccdd246a1282b83bd14e0a2e22aa1bb6ab8438cc4a523c8897275fc72e3152422009c9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
