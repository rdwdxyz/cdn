<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65f91268659983136681043b15b8ed0e4cdadeef21349fc2c20241084f4c5f68a3a9b8216dfae4975a9f650018a6679f3ad8b690be5e93be57bc4a6779be30e2e3a129c4fa23f0699c7d4de116061c8d14b16812238bbf11d3b59e0cbeaaf4c00f96140f1f498fa97375bb9b7d23968d3e1e2c2cae6a401550b63b8e680c0b4f2357292dd92e7befe9386e029e2c79670ba442a06d1bf461df4f81fd9daf22dd1cf00525b343363421216541f533c98b6c9a7a2f25f35dc35933c280ed2446c56f2eab31b79d31f29de185094c5108bf1747a026f9d512d61f2e8f8b511369863e06b2f825ad4eb7d66b09b81161431836f58cde6eab1d6352ee5ea1cd451b3c87df121590a523c3528f0d37827e9b2bff2e896c2dbbddba759205f6ac628a7fb7b8971e8e860985d12c7ea2f56e419aaec55069cd42613cdf596fcf840c6e063924a64c0ef4ca16c59b7388f6fc43abb3db6feac1e767d4ccb0d29257038ac74abf44da7359a8a619a3812351c67660a2fe151207acc69bf18ab9b5f811449c7965db82d949ca90a1e02a07ec8a7d61744b9823ede8c6bc627364d86c3e5418b1efef68c533fdacb20535704f6d0b0e1fd9a2cb115b9f56b71f2042d1e94e8be5d9c78b3a2e74535566e08c5ce2740d507bc68a9c39f952fb997b198da7f41779ad1e8afcdbaa97b3838d1027bd539389d851c30ca694a6e1c77c37692dd17e3f562d3dbcd28f5da4b8e47119d88b20cb0fa760a62f7ff650e4ad3bf707d539a93e55f2a5f477a2ea63448ef1fc8b44c8493d4411f86ecb1f885512ee1c07d529087851a3f7c40a44b5da489776f4a7a7f13bca04d52e3010727552d358f402aec215084429c189fd11f8c40061d1aa968d4c4bc78edbec5f2478d3bef149dc61bc4ba8ee281b4e7570200440cca3454781e42f0d432c9cb1a7f4f3d2892ea5d8f8f89a5775aa5b78aa4f6cc0362fa9ca86f01d8cba686df676b9d98b5393bee64d42d5bb83fa962a1756b6e29027d75b2bea7dde20e041ce2e4cd9b90d06ce4597a6f6a941643980bc960994508a35f7582c2b9ec785153a7b5941d27dd4ae04f26543b6d07c16b4c574765bc410f54829561a60370fcd4dba71fcbc243c07fa380dd6a87891f0afe663ec594839a954a48fe91481c75b6a7fc86e6a59de282374f29a036929bac1686f2279bd547d5125fa6324801f7e6d2e910fe23fd85864c7a2019e1a67d4c86a77a81dbd8d6b1a2792ec3d8e1a5282a86882f10747f59265d9a526b058eb41b3a686551daf14ebff276b57ace10d5ea97d574d2a8f53c84c8ced7ee3b865b10f395f02a0aa8c664b0568a189e8106abaf7ece4bd2885f8dccf4f1cf646b2348b7390cb6a897e646a138f69f461cfa8355b217612fb5f783b16def6ef0fdbb38905f538fd8097464647375e99c94815d2f11481bacfa21ec4887dcb6a6d471f4115401c56e4a50081d8636810eec87e6232c4cf08ce10a959ca3becf2194f7c4304e77b009fc70585e5185a7356aecfb73310ef60758bd5ecfe96db5d855fd3ee98594b0132bd241be2a33d68e5917c4cda93cd93dafdac5b783ec4133bd3d4ac9dcc2fed202b3bc1c82394efea44acb421a20ef049fb0d067024a2eeef4198442ff4b51b5dabd14b19acaeb69f09e05928b7e53d60a25826593d5fa659a265496e6f7602ae45f67647ed1ba556c80e50e13dc12d799c3d78bb90b170a2ee98e416745754d59bf8da4e319e35854e690567df63b73fd7cb7c9e9b918ca67d6b6d486f6f2cf5ef3c94a71c3d3f0c516612e9d1eb1f1f7f5ccc4af378e015665e8ed2798590f16289f5f9ac9bab964dac6b88d7b322d1af0424d1d1a9f3a13c84be313dd3f1e9afeda42b38c13b876ff4d5dc417cf22368d8b021bc529af358ab6e897f733db1f9f2e7b8c16b52a7a97ead424d1dce19dd530026755d03529554335279adb9cfbf309c4ed28733e7ff1b619af708d5f180aee8633f0eb04a39a84a3ece5bdc56789d8231982bd11593ef64f786a3b578f8688f19b788544e8c89089f7b40c4bb5def1adcc391ed61a740b8506e5996c9166f73daf1150cd1d6124a0add94a5238902c3d45cdcb1115298ca6c7162cc7d8b991ca11bca48af09f365b14cadb081dbe260b7958e55179e25c6d80b25293c24325747bdc0c334840b18f52dd4b784af2fb18d76fca693e195e1a913aa0d57bc0aad4b63a24263359e4dc4f7af6dbc1bed41934642f5058613a97a514b705f17624bb6ba74d5434084360325a8f3100d253e654f3ab4f1059e2873e65db4d5ee88e4a63b4fe3a43eb1853f54a84e0d462d5fd020ff7f0ea1c74819b1592029a00fce584909293744d4645cfe887990716fb7dbd4b8c3673cf874673d2f453db693441d29c02ff812754b8b681c4758632aec869a5dabc6c9ff7a57052fa24f2e0ca218d35794a512d68fa3307f5ac24667062103eadc895c3274205d4b7e8c0123fb875854b9f259e4186b356b9c90822098fe0bbe627e9b83d51e22b315de193bea5fc00f8b929b2b0f9ca4c373ceeb2cb6b7075154a572995bb676a7e0ac8a51510132251d406e1884a3e1bbb0ab0767ae0b34ccfd9fbb6b5125825890a791eb5eb5344cb6f83ab2b116e2e5adb7332403487fcaddf0646fc68a70a387029730b11806327b1d782539ff10d2af766fafc085327d27d0ae0c98734fec9e59b3e9f6daee755355423dc0768c2fc52e7c1c226be82e3aaefe20b6048e13d0bb5666fe208b5d749ad7849355e458f0830e9e54505886b63c586e8e4625f314551740e9e7cbb756eb34d0c3b5a1aa704c2ee69dc56eb81c816b4d3d1e82a013d4be1ac4272c9e75e3d9839773a157994158c3770830a7b999cb7b05cc66089003be38904d707c583069d6d770ed927c1cb2065279afba57bbd34760ea8ce73a80be67e79d3cb23bd026223a8480b1072f69bf9f42450e371324b999aa318b807f2de4c0d7fc5b98269a1794e5439e076fc653078c94cbf781a38fe07a743338c4f6996309d0cff6552b8156e6bf65d47a50c230a5745b284b4f6fb5be893951aa1c41da059c41f511d1696fbb4f814317e9d77b7337f4eab6a7e884000997044c6072e72f068e7d32900580c3a5590b819aa22334485f27e19403708d804cf6c1e1202bf8926293137bfbd24b4e38a611425e6d301ff28e50209151876f6b4d6e39ab0f16b81b74a4206b33ee447d54cb36b11d0a444569e149ba88642fa2bba3b749ed8e6ba963ed64b6c45361a366bdd651abdf9207701beabf9cfc6164dfb5334c65ed5ed02add63f856e83d301906f22b6d2a645e60afd31967bbe14ecd7db5910f5025a19d81d9fe2f9de0aeb73315fbd6565b0e2c8ab542e6b2f9c5240de3476b6159fd9dafcc088006cd8596ff42335e688592acafb244169afbc873046e69567dea0e52ef5422084758621481b88d8bef534ff2b13f4927f7c52568f3d2f5f1114f2f76443be80f007ce21be0c19014bcba1cb9a7e0481bf70e7daf4d194539fc43f95e3f5f623eabc948ccd71e08cf8b73a99980307b24598cbfae66c722bbd6449d1db299c4c5fcb27872223486f3e97ab4a27a67b25f69b8f89a11738ae10258db59f2b9bed3208494925a53d3933d2403faeaa985822d68a77988612037d27477edf289b065a01570631281fbcce9766ba0fc1d508b92430b9e18a96ca66ef8bd6219d5bd4d55f112894cc6e9e10c7f683d47e9e92da1663281a62d9a5b1138312dad27f4f0768f9d50ef68483f85219f14c6a4569187cfce9b700ffd14feed25082989354e21a9a2f50dab5540733b8ee71cef8672d7538f324650336e78e75d6d1fdca88c949c0be85485f561340a9529c05310e2616ffe2caa55aee7c161ed16a556b25aed8ea5086e5211145cd17a5f3c91354c987194c01d1654372b31a0dfeac121fca280dfb62c8a6798bbe2c4489ee5f827761b9e97cfd2fed8c3ecc628b862441567746ff52a625d9bd4047f6dc9dd54e55947c7c4fb4b0312cc816332f9da101fe7378365c25a0cb744da4d9cc903ffb6ce0a587aadf58415a73ba6c933975c52e6c03e7cdae391252a155c153020302d8b8e0d4a520384d7e280dd689364477e29c5c402ca7c747775c1289ecb5aece5bd386fb0b11579896c44af064dc3d37a6160a12ac522f1ae1ac4c3344838c47b376a49685f4322e4af4ba8ae8454df725a0f9caeb686c6ae1bd0e12e0195838e784ec1b688983e71b1ce58a43f0c56e9e3cbabd78e8a29fdf507418ad3ae545142b3f408485a94a6d32e9383ff2261aa4dd4a287d4ff8760100efa9b5752c1e060441ed9fdfd4c7efa271a3ba05e4166d79dba29d5ad8378112778f2dc38b022e3d471ad074aa2abc31efb3135f6b3a55d91e4653f3c9df7a7cdf0961755e5f90c5d54d9b904675125683c56ec7ced202d6ce98df07ff246be07e37cf574f9266274c23d8fd875174426143b997e451d35a687892a02564ab68875de3192090e5ec006b00f33c3dbb3239ca55b3a6c4684ba5875cf64e3096f37022cee31750c1adb8e8336a7870c603d5d140a936b2ee111653769b161da93dbf8c8743d972349113ba9c85c0f66c1864a5c7ce79211677ef872da7e6241d2d92c09ea4164f84ffb9f450f42fac274a728bd0c1ce41b7da949a9236f9c2e9efb53550c1334a239400bebcf75472c04c8979503af05bac8a98dd28fab3d7ac986082040848a53faac4ba70d447e85d9b41bbc36379e49375e677c6a6859fb216176bb132aa1fcf3726fc41560d1e3ec639b55a7c100efe5972eebf11c1d7cd7c410087a2782f67f45b6f1c709757cb6ff0c69da8e983b2a99362a96555fb62a502ff56761d7e55f980eebf0182aeb795df313508b39e5a88528a0f64afe8f78c2bee5269118e3bae660ed0fa7443647f1a02e78d081b22ecd24de48ab176add63af63ca1a9fdeaa3c855701939ab27e9ab2a97c3ad382864852b59263966b9da58547dff62d2d527bd4675fadcf22f24b1ad8d0303808740bfad9aeb5c31b91a9dbe985b5d9db5a50667dee4a00b26d663e397a8c88453ba9dfbf838926f15f87a68ec7f061ad592e843853688bf202612ab5872ab25f781d3c72d2afba786e7463414a93a1583d0c953e41dc2f7081caf5aa948855c364314876c246efc9ff90048f61fb0da4906faac64ad68b330c79a23016280c11887b2d28b43b91dfdca913fd9b1286f72f0bf45ad87a7adbce257597cb0e7058c4d56eb295437bddba083767f2b900e56fc567000cf74b09b416d7d2b28734d1f070a4613fbbddf76f11461fc1f667147371e22cf14a6a747984d369830c9d1bb5c5be027e13525a59b0c72807e27c76a8a3b63db9c1b095511821d2103b29b0a908350ff70737054cd0bf37253744da0e54c9cff3e9ccc7c671c18481a39887df8d0ffa1b6424babadcfa89da82fa250daa814701aca8619b84dbfb8176289065fdc0ee6f4d42675aa0cecad8ae4335a7243e4e9783a9ba4b8138dd7462096b8850d92dd1eecaa15a1a2d86d2fab410d55b1f692d168f6035d5706f39cb5194e8e4aa941b63c9f88258fcdc0ec60aedd40dc2a64235f22d5ad9ba3db0cd55bbc1bae810cf251c1240928a19512609ca67b8b60c59a08a87c056f5803a0de5cf3b7c0a11efa6c9fcf14f9a411894d2c254db88a6432a9900ebdf7f02bc5b3cefc7e23e9dfed28286fc7b8f39da5a768d010f472e12b9bc3b9644bcd52cd459b4e7c1d4433bbe46b42189e80df7ecdd8a6b089f39f988fb513cf6451609fb025325dd7eda71fe90a91ea622cbc31480d0ee7b3538bf7d01cd922c9c8e68565d5cb416c899117761cfef1e50a271162090a0bf17d1c881d05ed00cc09aad4d9741cb511372c367582dd4af9f0366d50b23e5c789e021751a7f53db9b942bd41347f728b8e3217d62a0dc4d5bcb7626a1c1eadb68fb2e553ea56548c18f57e27cb15aab9ea8b1d63729a4f97aba92379382135dd3b89871a6f9a8ddfc11d11451bd6ad3026e5053b063847506d9d2f8582125e7c45f2b151b49491e647235f6d96ab1a4a360b6b41ff89e14db08314d3fb7c7d65dc0a25e42f8957930bddcca3e53e24cec4cd0a219be02a9fbee15ce39ec1736663ef59b94711dbf9f2c6d4a4d7a7f0c677cedee47dbde789075e2d822afbc96a10370393e7250e77eaaa16ff98b47c0733ce1730fbb366dd343ecfe3630a7d4ef4e1e9c18d2aef2f5f4eb342c646369951f0258fefe66807c679825c94f61887b30266d1fd63d137fcd7de6a07ce9617ac90ed018a44dda4003762cfbc9100f62e427ad9d6a4f6b34d481e5918a0b6389bdedae7fd2982b4479223f0a024ed5bd3e2813a12f3219bf0c0ffeec05dc1efdc3fffcd4cbe6ba8cf84d4374d902899c851e8a2844c64b0446e8e91c195cb6e30f83ea6b7adb9975d9f63b4eaef6715a236a1b918bd9af0ff8261b3dfb1fd964885de5f603359b2b869918a6f0d0f80889a5170b8f9672d7f40a4f56be6361f4c730b02410f63ed2cb802371cc5eb578a8c0a8f49a32f044440765f6276d8979d94a4a0740d629907c15f6532833ed7557c2682916eb2a3e97dd438acbe5913e54d640a80540ca253a5dc93110cb75029e76d6819aa903ee60520b7fd507e7804af6e2a4844a62c0255bc321af07d67b58fc8f1c4796be42886710008435b8709aa9fc34c2d20ac8bab300ff856e528daa905516e60cdabfa635cd9e70077f5ab7143de6874696e46249966a886851103b025711f1083531f5e10a7afa00b2a49376e9543109dadc6a484facab0901a960835cb1625b62ef0a24f878955566f5be2f7bbe3492394ec7caac54e832da22a370ce749eef3a0544443f0d92f1b8f97807596ddcf7583529c7c37ee43e27af5b9c7fc1afd824b5b878b04a31d153041de5ce494d1e385693bfaae4b797c9009f28d00e8bc7a70747e6f754ce659afb9eb564e425fae9c7dba4a0782278894c0556f9df6547f1a8c31e13451d806581043e54ce6c0852db6ac3083d578b89787998afd9485300a35f9ac715d5d282557f39d3cc769699a054605a0558ecb5cf36139b25da19e0abfdc7a8322a519dac098c1f7850f4c43821af0b20f7bb205799455c40cfdca1afaefc2a5dba7bc3e143e6e73096f60bdb20274fb68962a7530dca626b05c3dd5345b02a5994a381265d614bb843e33f1f316ba32fd4f8cc7d8967b925adacab574954fa86fb7247ca19ff694f8c7f35dc06dec65b982eac3a11632df8465fb25c32c569784e5d42100146468f9e9a4227138fc149f24fc08bdf8858e682c1b3e5afa5f2026cf5ac39c55b0830db84d07da9e0ce10798c84e3b08bef6627975d515f17c7425646aed2dd29b15d07c34996ba281c64322ac3d1ac875018112058e6a6995895171a73b94f74eacb3a16e4cb8e369f726b431c37ecfd3c354a6a32ff968adf0a3a7ebe8f744c4698706f72dd7c07f237f5efdc293845ea4af1c51a0add19e3aaaa4a9dc58bce4ff2c845ee475c1d458c7375382ba1f7870261ae384a34d8415a9e3e42bff0bf2d69734f08ee4d68afbda52e26e0df497f63fbd408f2214f13fa91a984cdf58833343516d1eb9f7dbf786d9fecae18a439a8548e2abbe22204377a8018515041d361b919d69033c47fe26c2c5bcf8fd8610de1884417b01b769bac2345bc6760d397694984f5d2717ce189850fe27ea860121e691bc446ecd0b5182aabe2241c4483d3a42740b8e3aaa5711b0bd506da92d9c7c9248a1ef31513ed2d94cde3c16ea15ccae103409a2e65684327f2e7a42c653e232cde442c34b9628fd441c9e1babadb61e3054391159e168ac4417289afaa80123f9b8d4a98364bc655f671ace85aaf841ea7ccf207f841d9556a43fd16d491d333f77423467675af10764c25b70efb786151a50214e28a98ac947f4910567cb94a2ba8c9b31d253259758520fdb2171cd195b60701c998da8eed9195d136a9f058d6cf38a936f3411b1b9abf7088c1cfd6bd372c79b0010f07ec7142b44a90e32e8509ead747bb7074ee9a4641816ab53a1d9f68fd98a1b2075c7665aff8a00b72f8931d02883d34fb52d306337e5aeece1b2c9d7ff83cf7042c03853b00465066bd6dbf00a5570da96f8273da12a6b4f31b7a7fc57579fd17585d3f1c678a16cdd84c34e9217fd2ea42f29b6b215343f0e83d5445522b5470d0fc5e5d0494229d429be20f9b5fdc08af6ddb274e71017e2f819daf333e9de7c54ad8d472259c7a68693320d670cf2d11ed5f73e8703fb5c9cca1c85991a38745c75d3c9ad5021f43c20fe7de9c1f82ff83e0d5b1633668de3738c42bf53096b4aa99295eb05a0465b1894dedf14c161b33b9077a9bfc046558b4b8c348b0899a3ff64dff547c364157d39b2ddd7e4f6958c9a52253b4534b9aabdfd6f34cbfa8e913050ba8155cef46cfa84258e0459c0c68c9e350670bd215200fcff68e93ebc05a4950f3f4ea4331c63c4ba2d1973c0bb44e19a77dd3d8171b0bead3d768db0eaef2913254a36dc21ff92241fae8f05b32f108a5662cfa8c8160b62299e5ccd0046d3ee560839420f24e8d823392174cc8fdca8928408446596af3428ececa9d95a9b78f30781216e382025a7e22932a3e45f141bb7eec3d9d5ac5e839f6be0b7e1c50e614f69ba4d05569b48a4d9e60095fd91978f16ee4821b92f1443401b2b0fc1a3eb520b179a788a03e4732a1422532ada349cc92a540fd5e7ede9f4bfe406fc7baf13686855454bb2e5986dd9944b0f6704cca9b84f6fbba97de54534847edec0bfc45c546350db1b72944b8ce96122ba2e72bd6a210c15b70e9fd05551477eb0ba7bbc4e1bcdfb54a2a6ef9de4730475cdfb129a4c041327815b56bf071efb61b3ef46d923a7a54838e285bb6fbe3ee11912b0cec4aa856d1d447314fec1eff5c0794102f552984fa3cc815decb36f33d52de59bf1b5b3e5b0cfdf024cfe84f36ac6f18600d5aef4c52f3be9b093cc561819a99615d5704e37b14d90d310a231f8594f27d4cd6abd7f247f5db2e2cda488f6557501e368685fb1ccddffb5bd6d59cc6b6ee2a8ee00d52f9f959916b5ea4beffd5e55dc80d8fc73f62ffa1b309dff0ebc1f908360f05ccbfdd4b7f022c20b224d007512c5fc7902f36a74196ca028cc30846d1693bff6ad33408c7035ba055230fbe5eb62ac20c88031063815abf31b66432cad7f939a986df5a73f035a6dccec05fddf692f3f785dd3b04bc0ed99cf60cfb442fb5874cedda2fe78dfdfdd096392b90ddc10841b1268b12b1cc3c5980068e601fc549859e6b126fb1eb7987385fc9318e413c22c8c5b31b4fe7c405aed8dda985d46a41752f4fcc5ecf02aa52fd833072a7baa3baff2f41d66b1b69df4f3c0293a8846119d30d2a68a0ab9f79bfe635c7ec9011f76630a2a85ecddcbd5ab0656321c3171385210b2c7f9cffdc54520a4f4600012ae00cbd688096820845188147a338fbc4a2cd65b7c394f16f3f5f9fbaf0565f8122b07b56e8d6780491b238684b3c70d5c43413250afac3a3895131ece9c64d076b89d697d31d318de89cd4dc50e4ec81fbd01081282146a20881eb77b55558742ec91d6c1d7e8eb050849a615f11d3c105b2e9dfaecf8dbf5667dd3d9ad5b6deba64a5f97555a32ce85ae96d2b996aa5e1b5cca05c03638caa6b8d51e7898b71a434b41b8ba023a24a289ebc764e1430b624aed8028f3a5506ff57731bcbb3c1197461da4841596e2f81caeb6b5f62d55f1a612011ecd56d276e893e6598fe171f4ab9b148bc289af30652d8719a6064d187c010b17778c6be7448e738335bcf05fdfd637a1001178c566c70ef1eff00882ce1c47da1eed79f73d4d317168e0e18acd139c6e78874d15f65cf85e8241bae7c5aee6ba311e5cfab5c9623fb54c1b7accb8ac2047e7a4f73ab509bd521d86f5875cb5406db48633d8729fb5572ea58e57c6dc8c3d8ca2c59298ddd857e73b590a693d6800cf1c777fdc6944a79bd12ee5e2f7b40ffa60d58e592c881cb350a90b2a91e446be6cb14b46e27a15e1ae6d4cda455794c7586a4713e8ff08b7e6c78d71b5cbf833737599a54cb0f784e9b5e3da8d04b07b073ab6dd1829507ab3eb806b6db71533ec1597e7c13cb606c0a90ec33b31b9a62ffb5d9e7f8dcb4ddbddf722edde527ddb244eedf125897dd30c413e14b8ae6ceb63e231b4c9480ab22ea7cbe81d439d1ab5cefc81773f146f0749ae127c8327a1ce2204e71217045d98eb7901d0f320efc73a8f7479982a7a1c2a3d6a4add7d987d986ed803a90e6c8645fcacd0ac1342cc7f205f514eb3fdb8ba4af7924796311b14dbd2337828493a7d7c6f1969f8be30b57b9fcdb0d5ea39adc0f9dffcb69eb9724f3eda2b5060689c6001bd8386c86b437f77ec76a855a5e033678354cc92a46406c1767661a1bed15a53d4ff48d42e0b7fcec697eeabc2de37640905514b349bb946f3b31d2ca58ed068e93e67b3f5575361c1aeca06bfead684135196e28e704e25ca5770b66788943faba45a75863e6141dbe512864e48e889f3367208771b6062e26e62256eba3e4943a7673749d30e0157aea3a15a1e6516857f88d81e33f64c9d43ca1949b45d59e5f1397de4063522a3c01417b9f13a4c16bc4a0cd9a72fea41fdddb51a0e76f5d81be939e39c2bc8b5bd83b01f87ef3be6defde019ff8cbdfc5daad7be023bf99ae59f1f5003e040bdd935d133d028083508230a65c15aa0d9bfa77cbcd1b21a8be6b2678d73b56e5f76a8f8ee2aecdd960a2406eec1c7bda1972345fbeb8c5251faf5712bebc54ecd3c4b55bd108fdc7e62e7f1d07909d1094fd702e95408199d96d612dcf7726385aecf70621abbbea1648bc33f2b85451cffbbe2b7dbb98b41a157b6f409b41918314e469b80a9de45a9a63407a348ea1dca2927224721fec2df8b730ebbc2c998f8a7bfb8537df5dd4d60fdb5659911018fc836b369ba957f4087e5b1858c85b6d2dbfb59cc88ad0e012fbcacddc9000bca0fe2ca82950a0a37efd8d8caa6abb9ebd2df11f4943858eca512bbb51a2efba35c9c8e4408abb6390b540412f10c2ef8245507457db8148dcc8dbe6d0573fd13ab2da2edc410a048cbc646b43588c16f70dac17213d7ab3e604ad83cdfe58e49ef8f1fbe0b5c1032c0e920387d506cf733fc2cdd4a27f6801c4adac8b00326a229a96a1afa073a917309e4f860efa82075af4337abdab3c5af7dd0a301dd25711b1032433bdf2590102ef8aef720c0bb4efd884cc11c1e3e3b595574cdc518021f9df76ee0bdd9534966c6bdcd79ce6339e70342c36ed7180aab8f4fe5e84b99d8edbc3a420ce5ed07d7f06555df2d0a026e10725898e4bf92e70eb58b98a4d22db0675ca9df6fa0989711620e057637d6b211af1114723ea6c55effc3be30879845647fbda6507fd140e221c086a549134669ddacb15af1a3d7da8451d53dae9d2c575e4c8a3a25a0cae50d74a74142769f9a493a7d8c37e0f3134ba216a547269478386a052fa48bf19b6704652a3df8263a73497e94cdff6bba72a580841946a1a45dd2ad73a9b093f06b5d8e49fdc383aacf186341a728e444aa973d2e064d42d592baac1a9b7d6f986420bc04b58be7da1782c23e9fbed5f148764b34619847c7fe7d59af02677d5c63cdbdef3d4e129b836c819fd9e8cb96f4ab493b7747cedceb10dd793a452c7e7fd0438c22efba4ae2262851d1faefe44d7e8549ca099ff12cd0da43b5b85086068fcb8651096220b39f1e72c030b34f93aeda2a20f95dd19bcfcec6e2fbaf69e8e0bf62505d763f44a92a463003bec66a139013dcf1763efd6e802efcdb5044d33e7e6090853add7f47e89b2c600d5e5cf3ee4c53afaf32c1520337e82699903f404c09126d73ac745d03f45f04e3dc72156e5bb67031e568dbcc6bbb16612d7614cf9ce72fbc74ff99d4c8f13e0e338db1795826ee9ad2e364e57aa6ead7d736c298eeef4d05e0f44e5ff6805ea812b03260ef3d0eb204580b9ffaf68c3f2c4f4411be0c000d67b2a41a8de1be36046c483b2870e9e99872b5460c68f2103888b31ba0a3eb86535e96e93d702022e0727b4e469add20b6ce0c30420d868a177adf3bfbed3efa5db98ad60d69c720e91bf154a418d7c63cb0de3feabe3d675de10e8990662a6f48f243835d61ec4cc0e6f49b6954a7aee33f1787c25adb8b870a1c96f4d70f4f641040acb662d5e417f430d7d4b229b8c698e87195da7209b6bbdfaf451dc9e8d1af0bf3090358244fdac31e1ff6366ae5b79fd12c130c6590b733032a38b017db06ab86b4386a87be63b238221afc1256a4ccc8efa632197f55ff4a7b721050013934c8bdc1ed9b166bdd27e00c6e49abac9b63fd097517c65dacc7bb3b337d6c61a94c3ab0af43dfdbae3c1e469ce9d490e6fa3add425f2c3c5baf9e69d561b041a202a4314f6ef80bb2266781c83207ad1817c336d5a058d469e53825edd47be13820757af1a5f8a71232ed21f0acb8008fd94e1e92891122bde391daa216c5c0572b3fbe0a3833e8d4ae6fafdda8ff9e7480337371b066db4113c8376955a4728d3e189cbaa0244dcb6a4b69126b8354f66115740db888f4389cd28d0c576c04030c996fc52f06a1f8c7bf91e559320c67012895b77860ab90d7c4dd11fb6ca14b0f977b4cfc2aa95f057cd8da0081221b1f75b35e31af53f20371a6d6f232d9e2276db839906747aa49e16281d75fd0c88d54fcdcb636c66ba0a4ef020aea82ca657d691fa754c146a548aa6c5eb42c3db16b50d790c016d59825ad2945d2be5fc375878e9e2b25887a3a17f4dae948842022ef129a9b3baf503ed5de06553f6ead5283793bbbfd0aa850733d438d14da8e64424270238fe83e3c4ce05df2370d3ce4df0741f5e4f1e546f4adb8413002166c174fd94664dca69e3ca8d0079ae19e4f63659b01da390634b19f232b1510f9140c39669908f763217e52f038ec626f55aa109f8c0287177041ed0858f1a87dd00de6cd1448920c0bdea79f18cd6f1181083b6322a4caf7e652c985cef9814f15f6edcf88b7e389b4a392ecb4ae5d1e4a55cd864ef8593b91a426e5be4bd4f079b45872e832b33507ca4c45849681eed7f0b1b4b889f7be03b45168535f5929dd150e96bac13c0ab0e5afc176a7aaa6b83e20a6b77eb26d27c83b626b4c30d22fb408ddba3b94823e027b6aecbe6cfee699d4a67612e7750d2596d3c7b23914544ba44d72884a8bb305bd56002f50eb8f6dd0b36fabf5cca460f9d68d21bd5c6388b50bab67d999688380e05b5fda7fcc323e8718efca763b986f6bc3202a3a6715471cb64e0d4aef3c3b911042a88319aeba7a45e01024656b11b7dd13629f7a178bb7287614fdefd3a39bcce17ca0e18495632fdbad1b758235f075b353878cad45c5c2accf763531597986247300b571bf3b693e56c6386d0a0654931877129604e1ba680fbfa4ec784c17494a285cc89032672f1abecfbc23ab5d327e9419f5d4a963a784a4bef452aeece2d9849e1d0dd302bbf5552207f622de66896ee1d4a7cd038c99af2e5e52bd17c85b8d0b8498217f5ec847609815958d7e637a5c00f3d2aed42451ac0e571a3b5f0b505577644c6044d3ea372bed02b9f5647045e35cd4ed6e5767360e5bb4a2bef792e11746f6e070d2bbcabd464b001f458166d5880c25ffedf3eac6b5bbd00a6c2e31b34c6cc49c4d8c8dd04923dcffe3868587ee4353401fe434792c1017702ab29b17302a731115a7a268db2aaaa6e3ca3e821725c8b3a26763ecd528e255eef0ab5384def03bf0b240bb3853d6808e16c84815e59fe935bf33909263030327f0968765f6ad754af8e853368c559fb7076acc191910a9a622d10cdd0e70bc2867848e729952e1825f8fab62e0e3ae74c193e09df2a2add4cdb6b70715909089286d51cfe086189a1f60c998d1912982af6a6e321ac8285dfbb4cec43543e9233f018ce6b797cd0bc5cfdc6828f1aff77f3e1237b2fd20534e27407f536f16bb030b634e21c42659596f1c253e5296b5672b8e6f0aebdf2c1cea268134b4dd09b2ceb485daba5982a04d6e871184ebcffbd640ba47a39ac873057eef287ab2fb7f088d62b2b4641d7518a183b726f0f248b2df4c53959696e39c241d98455f51c6a693e01cd6f0ca1f54dd2bd8f42cf27278232e320afd23d3c81087450b49afc350d66e2c531bc3d2d9501b0b2cce2ee6ca7ea243e7487c171e719885d0fc386dea381d029443409de804d208402168d30567d6676a7bbfcb58283d91a8360ffeaf7ef65e36becf2ac697fd490fa66a99bc5f1741308c25691ebabd5b41ccae36b41be4ba6feb575e86b9b1592ce34b663bbf6cfbcdf67afbca9dbb5b1121dd5b74f3865312849ca7f62e2bd3729d0f7cc54574d986c29740dfa2eb9601734bf942f1dd14607ba7fffc93f06531c9472c82ff8bb5d2ed8b34554af902814c7a1f647611458b5b036df903b4913c8eeb6612c81f701e6d2cd135c43384f34408532f4d6562983ea9c9af0e263d7e393c6e1d74f52820303acda6b39c19c6892fd49d6238722b2e72a437b06d08ee0dcbcb92ae422f0977b7501a425eee1183ab28f1ec4f4bf84ea9a03b2c847ba9415fe0424512244cd6d1f75ad811fae8dcb7814c1c9e68008ff36f21847b3b405ca039e8f0487974e11d87e3abcefaf9a9dc7535613291bff13c9716046f8d098aff9156126772329fb71b38064956a6846b4489b98285fc23887935cd01a94e6f1b0764fed3e1870c23c7632270498040ea161df029f0bb2d840682ed9882671ef7303f2ee51b98547e330b510c92ee1d4cadc4211c33a190ff7513707357540f0a07dc2d5452812713336f0ccd9aa6144d094f7340bbdc0897278d1ff6ec42a8a0a09c1ab8a782126d3c00f5f4270151dcaf6b5c8ecae12f20b77056b9fb09b682b87fd9c2c52db626ec6750c690c9c288cbffcb5dbbe097546dd50b60ec7b44e1747902e416f659dc657ce24a3801b8aa6786aaae76a99dd8c33a4a3067190eb84d90734e325c751addc947a869952b605e53800d6726c95f0a36065b57d36be722f5c22fef531f40b2135c9b4adecf5dde26e19bfe8eceb41457d361e10ade9b31e20929ecef5fc005b9b1ebb4a4e705f3b954f567e25052dc542eaffb6118c32a0e32ce7a96e766a914c7b70b702b662bad5259b9786ad84e6fce27ce7e32bdb82a95c77e2990d48fd98cc968937c701df8ac5e46fe8ac75609cbe8aa17cb24c9a6f8438dfc0494f22e70b60dcdd6424a7839ac13bdbcb960f5de0842177b2362af17dfbea1f1219819d637772b0dbdfa2a72b31625812069de64a82e2bcb8badaa59b3e41e057fe12a0126e0c60d89fc8ddf656b1d6d779aebf5553db7420356017ac627aeaeae1a923ec95cb255a8868ddb48258630686b8083a4787a75152b4637eb4986a35cf1a317b2614eecb82c08ce7305f75809a7b9b933b5b13093dcca37d48cfa900e03e11bc475f89de14c9a98e63f721d894afcea89840bf24d05badb30ba685f822132f08822657cc66fefeaaf8074dd1f033eb722ff1861cdfee4767e937636e30b7b151588fdc8180e58551afc148560a2274a6d2ef26eb1fc38c1e1a900e481ee723e3a9b1242bedc6c59e4a0298d9e52f1fc334f2794b8bd334d744a92240ecc49e37f473cf8b2431ea58df827a04a3978782bb8aa790fe0f100d1e73e8dc60e678724a672d1cbe3498b0420ba96f5a34f2c42d9701ad696c55ef70f6ec6a0a8bdf91f3cc09e60dfd1d1ae65a9d248becbb80392e75c8bb0913201e7b50b103119273d160ba989e4b034b470f7a3e2ff00fc246cd02bb21ed52e2e05a88d08b9a445e42029d031a2b81fab33448a110fe1583d06855131ab3fbd5efe6ae96be29775970b329354c09a011419a4fa83787fa9793d9ab4e39948ce60c601e7df110e7883dfee92f72bcbe8baf2a7f9854b27368804935ebf6e700157b89ca9fc77d947c2e6c91a142d2700f99183f4636d340bf46225222d022d28b4e9e57cfd29c1d5936b7eb7ccec2ce9a176217dd35289b616a80e4bc1d6880fa292bed9193e7a0303e036d87a1dab7bcbd7d32515bc98469cf060d480d306b86785ae46b36dc81c6976d99dd3df9ff7a30ac3420f419074b95d8833a5030507fcfab2e60c52420a12df9e07e268a963d81f088e7c6920216bd4b08f821a5f619e372ab22ad6aead62374a89def803c6774cbd13671eba0410bbf2d3ca0ae29d0edad04566379ffffeb522b947a3863ca49a11731e2eb2988e5998c2474d7c443f84e95eb137c2149cd49f5cde90a8dbd76a3ab0cd7e581de7867e6d599ea9397c98c2c50ef1529527ba7140960eacf8ce051f16c04c5dffb1a2c3920e2eb1347e6bc0388e660a1c66dfc749f9f4ea89bdc01150fb3f9e8861fd5d1ad0a685029727fca838d85b0dc857e33bc880e6002e11ccf947e14cc534c0a71e708da8b381121638f54f69eb38963dbdd08a4c0c8a983a689c01025ff01c5bcc08ab173c37e8e5217d9c1171e3d19d5eaaebb842c49e78b7c5905bf4a240ec70b41252b79d79bc1b13ac10c876614f401d586bd5415fdb3ec143892b71c2c8cdc4db91fdde830fe78e707ff33517516e59424a864f0fca774700a80203e7adeefa34bede55deecc41d098e88bcdb8b02398762cf0360de9bb2889f88f4431a719230117e98b2649fd255cdd3fcebae829c31369fcb9192cf2d0d5a52a5a46b86b29189c7dac5247d1b52d427c9ee9eaf63cd9779f60fca5078a06edf97364cbcaebde6e96bf316338ef7d66f3ef44d172688c6e957554f0b9765cfa76c7372bc43ea5d2601d62f97162371a50b1f9a6791f59d892a88dd23b2529c782a73bb2c959f3dbe2e6a9cf17199be7964e004010a75779e664dad65e6e9770f27577902d9d22a07d6c2c880030f51b0d0be1251d866378f46496de12d77f125edc2e03fb81eb9c6b21ccc125d8217b63dad115e780b3255b43fc7ea83de3392ea11e987a8d280ce342889162d3fa67c02839ccbd85309d4d43658da8d3eb5ae3dae0307c5ea7ec94d05dd0fba95ae70b3269cecdab1f68d2b733b586c9341d0055335edbf6d9fc065127e8d306c6aed4709d5976e6aee2b08dc35eeea3015f1825e191af634f371ce67e3b0db74b5dfb13172607cf393be4871427e3bf7e0314920231f940aaa242514589b6bb96348f5e4e9b0869578dd615596d76619cd8adb0e64c28af88531695291a9420565aa918f3e3b16d2f5e3275b596bcb9bfdde42e500b251789ec9f9e594ba22a98955414a1238dde3b477358be2bd91a362d5e3d9f01769633a01708ce0460005ff2bf0d7ffd2df09f85605b7bcf6cce5a8f47e9f0ad62632835ea6d90209fa06a4bb3a3852cc13e7c508af64ba03c6d688d801a4244a910644fd2352b41621f743a64bb15dd3931d62bea7bc2d1914fbe62de434e0ea8ed4c90198da1d6cee69e59943435eda5cd50e1698fe17b54e2e855323247268a908c3a9ba3f67595ba03ca02f2654d95920c815f69e055c2e6a36668765575b371d129a458c480528a45f149dc7ca5290b12577920331edccb6b38ea303e643cb3a300b2eba56ff65c298dbbe0d9751d3e15da14fbf525c5d44f6cd23748a6fa1626fdab36b486f5de9cc4b48fd41f9c7fba102902a953d0dacb9be2ee754937d39654c1614c7986b6b40ee21311e40201ed2b85624a340ee6f4abb24dde25e3a8c0e7ba951e0e7fe0927e6da0716fc048e1931b949f5666b443b46766f31dd54997859ead37adf38c256e397bbe3b70fa4ef0cb32f3ae459e327d2fd0a8d2d2ebab2bb08e65aa10a54a5683587c12515bffd8e1e6d9704ab2eeab0f17974265656747fc04c893f8cd6465b9b2df56d485d69b487b5b9971a86fd84fb7713025fac2239769aa30079884bf1be1250408dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
