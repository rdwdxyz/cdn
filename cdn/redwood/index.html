<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dcce03374884911d988ba97ab4d28d7b6b4f67e9f988833b065764de0871c83aeff051240b41933158531d081748c83c8952105f34f7f30b17491f988522740edaf5506c1535a84298184aabf8d7aa8ceff4c56101ff186234e228c0786de0c7030641f3b7f441247716d56a15419991c59f53569ef7674d44ab636a8a4aeeba37eebfed8df9e10d1945ae0b5e0c8c35af0b7035caf7ed2cfbcb6f2926c687b518fe1f5dd429b2fc6d8851eed2ecafabaa34a4b58f01853457513f4a6e40d6870a4f490ec4074c3d91e2137ef0ba031cddbc1c6a65310244a0c83e956591974e3fc1e5f86fa155deaca895939f8bd9da7b363cbc672e538480fd3fdadc27f382b5c40f43c6d184e40b335c35c825f841b4fabdb2bc06cf650f57e0cb56c1ad395d9b159bf420a65c03a5181697bd3f2d294e3c78a6014ac9ecc0a76dea3cf836cf0f4c045a2d4e18dcdcfc79e2fd73b3e5efd6ff169ed6bac32187068de06c417c035f0127a5cc088be51e647fc59b25ef6f3805e89a9f8c2c38e4d7b1705437564d67b30d85337d466d40a1d0a9747e4c13c27d91e5f58f38acdf7ddd63146ed4c53b802d45ddde926c5b0bfde794b4eb80dffeb8fc25d8a2879ae6e5a4ede428630e882449500831c25cb97b433f60e98ce1416323fee59dcc0d589ba49a84d85407bebba10073cac0f434e0ecd3e045b30b7809a6f93b1101abfe43e32708979c62354c4d00236dbd580ee85c03306ae38dc0e8c03e65e5e03977621eddd39b310a5c73a04181c2c21cc34f07536cc857784560cc05e4ba82164bd74d5ad9f7c86fc69cf40112b0ae0b2c87dbc4e095b9af37313f62eb743c4e837e6e98e079715b6ef6f649bd75aa249b587f9a1ee64dbb05a11986e63d946ad6a27141c5bac45fc8831d373e6d9cc510c2976c9e388167259bbf474464e5a95b7212a97a3c96ef94e3b9f2faa2e1182ea2a915a087c91fb4b25163552b99b8ff5a2345cc4ff5c62eccd261e50e1270834c0ec65509cf8e0f2a089a97abce514678f6d2e42e1a36d6877a96eb4c933a14723691cfa0f21d4a54b3853be00e68ae0b21056b87150aa5e4bc9ef9da19ea44b5046dad123ee02435f7efeb0551699e239b87dbed4f2132259b06aa9b3b0f172fa82e1ddfed669d66ef14b58f10cc1a1bb158aef619c4e2cfb1817240e5d1dbea05447eb76e63bdbfd360beee578f2486442b4f706b1b364a478e4bb24b506ad01789b2efa25aef8172c21f4024f7a6030fd44a86f544c4755102d6ee4eb1a9c76b7f235c86bb5df63b3adf6f17aea062f9d3468d70b9c4b260625732e49208387ce751cd0d20ddef4692f55f538f702ea251219e2f065d8ce4212093903d76f34e3ae8ba6a70c6f582da7061949c5c60a8fb810f0a53f9859cd5d545ed1dcf6e5342b5ba4cc989744d6a6f03e1c6e2dad9becc7f90dcb9942271c071eed5ac56a719c04c73d6a21205b17add67fcf2f5ac0ad8cd030cf9ed68451cc2acfdb6ac518d024f5a5d09943927e907bd717ccd1ab9e8f29b81a49b872dfe9a9e984efd9aeb74efcb6f0910ac861ca1c39fd211df8bf04134c41113a883f01975b70c063fca25c6d63b8a011dbfc6d4d199be1c7ba9f88f3a8ed368e4a8bb177cbfc9c07248a503804ee8804e4d481f4b9e0253ba353c17d2d8ef9d5c0d30fd86e43d837e9b4140c078325a142703e69bf935a58b4f5f620682c29f09451cb7c9be381f7ddbe1d5664e9919d564a1ef04d99c333b342182ddf3ee0ea4134a796403dc3640f447f4cd83452a8d3d6cf95ae5b6dda15a242ea06a9769580f1f2b35b1c0a3fd63db52c371bb51606e00e6647cfbcfb407f785a9627e5c0309d1cefd0660d8e9640aa03075829923aa52fcbc84b44be7c808109eff14868ae3b5a88d69e54c504555543971a908c026826ac818d389d8d4469a875a583f8681a48e6c957630128618616df7d356e31fe45729d769ddc8effdc35b00110ca772ee3c6b9977e3f1779f622480f7271dafc564be792847932f6385344119c92d0f971290f908cca02beb32455616cfc8ba9928a6de63a7e5291b6b26929cda53b0ddd31dd77795810c6eacae9136eacb7102a02c25a7519a766224d2ad2aa521739311a16b2e8255cc317472b07344bf19472d67af8d592eca5261cfc3a9b4f2a7e448367721323572aac923fa18f1948b42009145756253cb06b36ebbdf9b5a45cb017e95a8fcd30d115d6dbc62a675055c9c2682203b734290b93c8c3044664d85ad2c4d56d4a0c5050f67d06aa49960ad1c78f837152e214377cde75dec9b73acee1ffe62029c5eed04d72833a98db99756c8d260f32851ce3f740ff2b1ef1df53f7d10a349b11dfeb45e689294be34ed0618d123473285fd8ebc6a927efc470e6d7de17cab13c1d47a6291e67e7eda9fd283c56758b01edf96777a0407ced701724f102ee99c3679c39ea9410be5e39c0b571d157348fb3db28c83ec2c8e778a80cfa45305d17607dd61daa175d7ce2f65352f6e99e2ce0d3d47381b4afc844fb4276caff194683e488fd4c9e028d603d72c3da288ca7ec0222f9b86e01b4cdc37483362047413b1d951dfb52a87d18daaf94605e48d338d7f05b897ebabfe6c151e2c05e707b1a2757cca144fd2dfd48a6c2c599ddd905575c362347e32be060e53f22f11547fa51c8f294cb2adc2b3978835198a60f8fb1ee983a57e5280bd1f8f80c42cfb6128a3868a7b5d4f718c2e9f80daa64675d226a3f89ef04bf692ad3086ef04b4e02b05c6b24ba8a5494419cbeff5a31a6dc35c7ed1d31e1ded3becf0ef5bb4b98c314a0c6afc3349ba9d1746c9c27fc65437be7e0d54b1dda64c14716d2127946cd16de8fc647a024670adceeaf4297a1965c9982ff12a45c2988518eaa75a4766690b744e883e7911a4a4d1bfa24cc33d0a53c9f2e77b4f3525120db25a27360ddba4edeae51f37070c3ebdb63ad6841640105218bd13328400e0e8cbc358dff5f1e215e98d5872281ac079bf9c25523c9742fa194d9eea83b9793483b19ec7bda8b1799b7727abbff87a7c882ae39238934a7dd01334a56030f507e83c65744d00b93c7a3ad59365ff3f930be7171af66c7cceefaf986f39b70a28634085d8392ba027e73e503b90832f33b11bd2c13243fa361f55230f080ab8a078d972736b37a47ff7319ea37adbd43f223a5fab4edda31b8e6068d8e09ce50dba68fd0c7434acc6f837b0a1933782b0aca6bff1b0f1e3932729f7db492a5a26ae27d4e503d584783fe8159ce6f07153021165b5f6542b2fa299436178fb9e6641afd6f8a47541a1e475158fcec13530ae602c69b340d92c4bca6e832d2fdb7229afb4411592e6cd9fe9e04c50e77ed355603ce9e63611a6557a2e0bf9c6ee93f7e48185b9887d668b03ce7cce9b7cc915b1216fc0504ea8dbb1a395c200f63e49141332b41fa294e99cde764d502c8837a56e9f7c3212f8112f654c957846bd4bc7f30c730dfca4f0c5613d6c72fd781cddcd37add03dac1ddc913fe2d97d814303e1d0bb8c1041914cbd90491a8917fbffce3dcfb5f13e796592a1d713cc6d6a628c145fed849d44aeebd32d47b39ce203f577d04e70304b995ff8fa8d03a923cb8bd0ae90a08b8e09eb338eac23b963a950e7e0d581f9e621c9f4d1d4c6f52175f8e5c69ceef14ba9da53955bf52674b96d60b2bb753143fc84ad491cb31dbb48a77641221c23600f49d5fe3de470251817b77e2935e28c30283e36e82384040b04230acfc05184a41deeaca907e3f008d5a43d6200e16dbd8db38679a3d833b627a40c026010aed747767280cfab2f2e722de1cf43199be6491c889f96b068bad936c562c7adddf187ec767c5a8081eb4a99aad7e322ae8b7891b039786fadecf55a89550b0eb92314e696484bc9c0b3fd717634e5ba2667264497d3dc5c0ccbbee64bd1cfb1f36d69b36d6f96b1a685c283a331ee31c41b46ff2137ecb77ea61f4ea3a023b1dcf2632f7926cf593c9f625dc1a00a935b75dfe6fd141771056c1f239e9ad04a3ddaee2ede78670bcb8b3723a6a65a20cdf471edd239c30a2749e1be0ccabe78a937a51030d5f56c757c3a62ce7c188d38a8536c973fbab6bc87aef969214bb8f255701f9d9858f7aa7a9292c5959b5d7219cfa3b39d54d9b8b2fa5ec75aa89bd7ade8279e301f10b7bf3182ac7a4088a5404deaa33ab61ccd700f1586a529514e5536bdd96528f80684ac82350b06f48951346a7cc9f3654b6ddc5fcbf36b439c4122054e0d0e0ba786ae6eeb7d44df787b2ec56cc05bb5b01b9ad9bb0b0b841daad156a9dde1e601f6b34f402c75c155b8ad445c79df01d41979962d9f4e6070766b6eadba99ab9c181c805015e57549d56a358072b1c532243e599589cc85a83f1909c3d2479f008fad94453b02c74201021325f00e3bf74dcc4a65eaa2cc11670b0cdf10036bc6bcbd1e208edeb992e57d2cf1016236d2dd06289e2ec4afafb6d08dbbc581168c32a5334aca9f619ccbba5577870b2ff292e5a62b04aed4e840539c942441cd887028d88ddf196e62b909fb01d4efe9ab1a2449ee9fa7c5d8a0d4a9b226ca00894a3fa9c7af6b507704bc38b2aa16ea3d849102963a8f6c5a531d9ffa886b12e15a459ecd900f213d5c58663261799856796e67ff9ab8882210b8f745952b250f61bca84b95fe26124b549a4f2df11b25eb3fb50c58fdabf8ed1f59a2a40ba7210e03b5bfd7e232012c2e96825ce63480d50ecb42fa808de3efeb32339beccfbcccc162041a138cf1bd61b2c7ffd1749ea9dd0bd127962124dd2f88722086af28cf84d09f2f7f6d9504768b48072b9843cfdb560b61df07da98c3b0df0690ac77a90c0e2ae5f38b6c56c9c61c89140b1439b468f7a2b5aad962f359e1ce8ba78ed6fc457f0c5622c4d8e15bc679ea89d455f9313cc742c546ff9717da22061ede5ec3266b9a2ef8364f7484398dc14168ecb00f6bb594e68170df6699ba4e268e0df85ea623ffb1ff62ba4eabb689fa9d558cfef2597eb61b1d33c9750251ec22721841f3b89b5694975fd11b2ec57935d36a9762735eac1f4ac569f92e075f09e46891be1d007329807602b55b9b4463f8c6b1aa53211cec5f72f7bcbd357a054273734837fca94e1e13fd1d661b2828654be8b3dd97768cd074ee5cd97cd8d54fe30144459e0dc14508758c70e728ae15acc72483962816e4a42fc6be410a3779d483b32da51b73f41dbc8ffce97680f9f73a85a0d7a61c0e300181207b7c206c8d0a1642c9ccc49e1e4286cfdafb1ee70b14698b2d6eec1397344870ae45cd6bde843e9039d8498add44da6f64ea5a2499a533dca458561a70c88a506d6aa0ed16fe9f0e4966f7be5f1fa2dfadc1b98e003affb2781387bfe5c4155e892a070aef245ecc75d7db339750033670670c3772023ea630fafbd1dbd3cf697b956be57ba97613ddd2091745d03fbc86985926e8073e657c4fa80230596b984229567efa451eff6971dde373070c71d590e60931bb5b4e080b6d074ffdcd19e6ae9a7b9e5db4a4bbf80e840c8e24f5c7d88ba82e8093d39cf83064c4a62671d72b4d225be5642409f0358e320d3b075c23d891f533ba966500119e5a4f81e06f2eff419c3c95dac44e5e4b706e94c9bbc9a2dd54c5a492fcaafc70b5303cf3688bc0bf17ebc8f60e8fdb6d65af41a4f66ed33128f7c204a279e874353e37b047bb1ae58d0fa4e4c49f2cc99d7bb3d75c3f45ac40b084f66d01fbb54021dba3032af3eba1f8febfb68663984050154ccdcc7bd57088a86a2b6a19f181f818c27373030438c55a0d4f996e2d6672fd82313561efb8b118d37d7723b3e36ec2ac503801e0830302ea7234fa4dc146c026e27d2b9bf202b53456ea3ebbe87db351745a5efab9a87ad06ec65127741409b8a3d5a5e86993334d2779d0e9084d66ef613cdc06668e8caa3c3f5ef8b481b6728dca90fd757db2d39f1f7863824eefb21d17c7c2f15ce5c5d7e19fcb39b750b7f66eb0655e0c2ec3ccb8cb695d130fdabea9dcef6cec8ddb374445dbb3abfb54f1a0de1da952d5f11a25f8c330f4d6d19733f48f77fc7deef63ce67a946b68d8cbe06a380fc73027c8b890ca9e20071d12c35883478d4bea8c75e35c5c1e84e8afc677b1640beda923a82123e0d4fb11be29ee34b3c6eeb9bc823f12b9ccaf01a536d9348e4f18a9c7c913a876350c7e0e355f44258349b746dd6e6fde78920fc2cbe9148a5f3bd7ca4d403c50d855b5ca527eef2438eae38e65d1e7346fd57a1a5b5e41a780ea984b7426131f5d34ef50f805e4ca777f0a4523dc5589cd7be33f9689e8343fd0278b39d19b40ff0e1e11e6b6673f28236e0f6da6ef5382c5d1e692beab5eeb042ab1a3977fca615ebe66b3c71b759ee2d504a893bce5ef8fc625351387bb518ebbc84ed085110987d76bc46952421a9a42b127d91a802329117226234ef8343e1fed22376abd3b4aa9bc805287d7676e2648fa98abb37b6b692eeecfcce7156368dca8cbce76505513c5bffe0f5b730879071d382da747dfdcaab3db5307a452b31d6d63023708f2b7129acbae017c1af0f0068cb2a4e7688e65f576b72bb2a08e62a38f938e957ebc48b85465233cb5f6de2411eed955e2cc71703e9b20c039eaa0c62eb4dd56d65d6ae0546d7bc7b3dbc0cf948a14117e202fb9c451caf9d93c3f4c7b688b0f50a86cfa2235e1a882c85225d8b5e6bd529f572730c5b3e7bb4aae457f77a4d88ec593753b16caa5578c2d9d1942aee17e6a2f6b9864f5cf40a9764dcd80150a5f2bbba2f81f1a287c790cd127f27f4f9da9d951e9fd20f41311e6ce42d6d3fe2ba0d2c0d06e4bb9bdb4123f824d9a762714f2e8edf32efe48deb59a6ba5975961f6ab6f5ddf388a4b5960044993053534e251f03c70fb4977957a3febb0f572f7bcf3d3c2519e904a3a5a298fe1864ab0a00b5bc715c902841e24072df588eb2f0ce0f6ca1b089ec10731e7d227af2e2f23b80b8d7816a03e9022f50c36e99e979f671baf087b80a1c99abb40f9c2e3e223b719d58aee4c908b2fcbafc68b86d106c2c7b80db37903155f5ddec4c21ce38630dc599b54435a8134d78165edd4ff0d7080996822ebaabb8afc9b404f9533325bafa641efda6080477ee2155a5042ae1c4e2751521458f69491c353fc6d6306f2fe0c224c09071ba145db36e923486cdda3cd566b8a7bcf21c9c5d415f1f42adaba9bb1aed7f1d0dde7fba1b63744da11491029d58f75e2b596463e323aab0154d135ac5a6d8eeb461344af1862002482f15d22224c70b35de746da061e094bb165b51ca8b576b2d9eeb1a0a229e372fae09e7fb625d6496a9c324883c32f1eec30c24c7d37754bc11b98526edfb0e7642cfe8155b1469eac95d519898758283693f3776fc7dbc1f936ba20844da20ac4104c7ff52df45c6ccd5d1064a8379e1d58d1335a131daf74e02cffa8ba301be2549cb5876e0dfa76b4645805cf87e3fc2dade58ce60396a8335b778478697d3449c650fd9b290940fc86b98e443defe2e74a88c1e48f2d8f0506807dd6d4d8dbced556c00ac07eb5bfe5e75469601e33dcbe79aa008052496dcffae7d83938dc8fd8ecccc24ebe5146dd08b07532189e00b3fc48fc684a955d6cab09528b3d7c3efe49870aa26e9726bfce128dda8b0aca363b5cac3685619ca3b99c370a84627523f2bd18531de90b545074b49ef989ccfc13e67010ce857a4f36d4c9322c79a3550d9e76d7bfc6619b62ba901f605613b6c204d97efd23cee507b04c75f2801d6226f23eee67e715de6e0c0d062c4d84765eade5722826edc88284f4d4b92fdfc840d095a0ec9e656bc841344614380320281a55ac785d984d1afb8c8492e6d058f86c4d26cefa3c425bf0033781edec47053c4729647865d98538dee2ff3663603c223db348b867138f147786f9e1052b0e889b825a716aa330d22c7a4d07afacb3de643c12f0851e3fb8939967d32ea9c2e98477d5f96e3624c1a45fd7ec71b8b906b21c5e0ecbe1e7f90be224870c893a7c6abb8abbb32f817225e0aaf9a6c70710109fdbcf3832b214c0441019259eecdc9848dc3f634d61ebcdd9d5548551d50873bb56d8e437014baa170b0b0754af472383e90fc7cdb2863111902df2fa396233a3b9748fb1c7ad9740d14e43b5579a837f4b758c78168e0473930b8cf3c0e32756f0a36e3ffd9c7a62c9ab9648be9b4aa1111106b07c142618ce3fcda3f4fb5ace797fc41881acb66b2e80484178db7f01329a2301f594fec034174f7bfb176c9b12d5069af1c99221532600ea1f8f270040c2842ed2f8fcbb5c7e8804b8aed085f700119e4034be0ce8890087954693dda2796ff8b7a4f547e04cc919bb676db442c5e7a5b4f35da21e7f5cea6ab4cae008c2ca80e5ae0d582a61d64c846781195eaf5a53c118a0fdc30a487e5dc3456da3d723c7bd95d13f4d7c3ead3f2d2d9c138601f879bf87f8fd4faebdd66d223145bff7fea108fb55de5aba5be50580e4d045183c67d86d3e4eae3375c7431e081e6fb2e7c96973672a0dd20a1df82318d2f209de25fe12415bd34f9f790d3f06138d3a34e7e0c23a4d00c53dcbd6eef049844df91abb5fe750555c7f60a9cafec8e4872e8338050af36ad680db3d85f9ee05dae30a6cbd856fd12625f4c2421468441f5ef1247ec910d0ca17cd304f238ab06d54d191ccced5b62bad2bdcd217cf537b005ba6eb20568302416cd0e6c0a1addc438b89d6a8447f45415aa4ea07526492f458d83d64e93207d75e6cb296822a10c7f36ca306fe38172a6f22705b978103685e9875bce8224700ddd2a764809b703b1516e6301705d90c45fe500a4d0f6014f84d0e2403002d0f50f029d2f078f9c19b7e5e85af3533a09f4ed6b8987e3144ba599ce342e7ba9e136e715eef52a5d7cecd25b5db5302fb83a1a70b318552e3e3168b69749dc5b3f65650da279d2b20fb6d5b7adc21a13de0923c41f17c674ee19bc0d3ae22f7d5baab07b81f2c845a3f571f909c6b0b21f083448cf0c0ef27969c718dedc1f668ff350e8f061346643a8019bb8b0bf92531488ad5f0f95876c7f3c886f96a1054c233d869755527113ca6f20e182982c803428a48fd2fb86f598ec17de3b9cc7fe0196cfbac42c5e82ac317ebeda50a26d0cc09fa42a716920e51ceb41ec7f1bd031e01e4941dc9371e5c3b2f331760ae6e59011070aa37aec6e0f33cdac483fe6d5fed77d5f038709e11cc726d14e6f3c6eccec393c4ac68945926bfe6cd26fb7f8edad7378776330335a9d64e3883223d730a06eac042439f4b9c75d60c6ddd958874394fcc3ae303912022486293300c46cfa4d715b6f72a5e4530786178654a5b06567572ff097dee70c964f486eef8dfe395741deddf5af1b7b9cd2e858696b093e9ae5af5373604faf5d2bd0fdc33961a45fdec17d19714e03f7d6b57f1d5063e85e9f6f6833ff26bb09d00ab9f0cd41144e616f9c3cbe7a80fb43b637a91cab5ee3f074ef04532897f36c0cb2df08b39b8ace04b5129b945e8f319b0bb7ecf57ea45278bb4dfdee9fae8764c81c9effe6476870964309c9a061cb93729169135d4c59e87f7dd1c70676a939c9e0b5c8ad8ca939dff4df73897ad4cb2b4c9898ca90d0079ccbe3edb7863c2c4706d3c199024db48040cd6ec0bccc895270c53ccd1b62c71a8416bcb7349e705a8000e11cf8fbf9de0dcb790430704ba8edbc29ad512736545f271ed82c44d837299eb236c551d7fe262f5139663faf1d1b864744322de9074c16afd4ef3a566f36af4ac6af3eca8bffce6580e45e9b856979e43cfcf8b1c0d6eda38c1f3964904cb8b97c558ca79ab24813fb7d95d125580fd4b34445527c48aec03e5fc84cc5c9941ac337935549c65f8231e398796f433fa7ca7989d9a548822eb39d5340b767bc59a412c6e30a7c8fb6f55e04a7d9a9eb732063717df80558f2bd0b4d68e869114bfa6b76502ad6946cb1e8d5f9b3cec24b5c83a9f5ffdccaf1390790c382dcbaad0fad6c13de9b4ebcbaa95eb7dbd0d50c57d3a8d4816c3ce9356ea873274f4b32fa1f6c60f74709535bd27b0fc21cca0a159177b56d0b801d8d8fe8734b9208541105373c0d946fe656debac270c43488165795cf34bf3f69583b3275e349de13250e7771e9e1c6c1304025e38973c0dbf383e16c4b72ed223f730617dcb50f5c7c774ebd21c30024df0c2ba0b18ec6e0f1d6fbf214e974ccc0f7cda4d78c720f30cb25d270a90d1de13a9b5b45028cb6fb4b113eb69ca96687f41a3ca564cd73074bbd2e900d08bddd6d86d707908e79e50b85cda65e800ee4219d74d93f02c1306214e603d68a13f795dfe675a0e3140c4d87df2754970030ec968d704672d24c1e86d77640d88796726b4f8664b6bc042e2b74f922514a997f1005a73ae2f30dc02b00f00d2a9ea6ebb27c60a21dedb2b5c692f075c74d58e72331dc9340cb8dba12b0e3d6c29f642539d7904f519a88ddaa188169a1f4a4b972a912356e646a0d15df6471e3e4b4ff05a229ca8b516b2b53c6299b0a438c47e0a944376e24ab086c2815a0c24e917d5036e619463d44537a8aa78e2fced752aead97f92f2c17410b1eb42415adea4d029576f3b3df71353eb0147f132b6deb67bcceccb81654755a9c72ac89b72f42f3f121f55511dbefa13b8bfc6c633365cf888cbd88737910f236f5247d5bf47459f879a53ce0f4c031eba09a4fc3640fa33c69bac8d07f607fc4138f33d30cb5ff5ed404e41f4cd17d04e68e537ae5503ee4c0bb60fec48223f387e65db277be14fb70373e081c249ac0544cae81b1023a585101b9a5ebb86c6c586cdb43219729a63e223a722d8f98bf4b50c0bcb0f23d5e64e823debc6e49db41fff44156cc1f98bc10271d4fe4a9ce1effeeea5f64d4ebdefa4eb703f7bc96bfec804677fdde033e0844aecacab69deabcf2e6bba90f0ad99b83cc4bff3f90e549071cf7998bfe906539e97efde85afa5ccfc317a65f84bbda688e6fbe605ec54788a6cb3094684edcf3e0287966fcecf84ca552b8ecba78354409e451e9a8b48b1111db0daa4d69d811ff7e1ebb36680daedd2b2a6cf874cb91077542748c5829c11672bc1cc8f5adb5a413905496810edbd67e4a9996e2e780971acc839ee1232efa95f6f6fb73e5400547c5b7995495be903d1f5379e9167791218e260d2c19f87f0044fcde261325702eb56c7e3a4b2b351a2de66d1da0f69a14eeb68a41e133422c6478e6ab50ebe91cfa1e696902b0edc220a692f41e73acb00eed59f909f71a8a5619aec8d081cacbc3a468c04a146f620973c4788e3582fe796cbbc96807a9e36b537e540baac5dae16e58f54e10937ccaa1d3232f893600e84f81f010bdbe8c88f9fbaee3f0112892a31e645e2becad435d6b39f2c9e62d5b5a33e673900eb763304a2b228f4cff614ed6e88dcc4454eff23a72ecc967cc63abbc5464f0e6f1ffbacc837de327e0d1b3ce3caffc005217a00671d91f15f0e2a6617a981354522bc80b51b5495f84648e9a7f9eeeb2626cfd85e003cb69e0b39f93e2f26a8c4e682c27c9aa10c48cf8d5a6316f175baf911cfadeabf2d3e72cb8379da00b83d89855a1a6ee24fe96f43681c7c75e5c2ed909b8fdc01491bbb0a0b8ffbc6896263d4b6848452f5979657e8c1bb75eefaffa0b7d18f3f978fd2c9fd700ce613ab5a327945a1ece6a311103c15f01e4cc9f53df5624c00b2c203c897930dcb49a02fcff4fea05207eec9606d2870d42f6ffd2a3993148b742a7194c35a554c94bfaea6a8dd10121f5044b34712cc7b719e2b0394c68015426b7a3f44eececf3d2bffa93de8ac03a3df97800a5860463caff1291a3dcb926d315d863d16cda99ba1c4406e7901c7f61e33b3b98b98eae6c445a7a05228b05b3969d851c1be08f51b0cbe89d6bb56ebd62863ae8cacc8997a3def2c3e02c9018a08e4b780e1332fe99124945f5ca3df21e0516b1e7d49da3e2046472ae063453ff6553c4b35fc529bb7a095b6a5bb596b98efc3d22ac1052b866ea30ce4a160403185a48ab894a4be711795087d1a4bebb0511578eb9cb8ba8018612337d1e8c743c86c879a8856614187fdc33606e61c340124baba0fbe563e6b88f88cf9c36defe3829852778249cf7adcf8ca7347e5edf94ca2b35ebbef8e6c297657180159cdfcb41a182dcdaf2988c65a8568c433ae09de11aa1ab80f5d3d77b7508217c38a2fbccb0e6f556e9cb4a075a6ed063fb1eecd32c9999fb13b23ce15d7750f5101ff43bc8f71580a1f59b2c7d55c898b1aed9e921e6cf27c0d4c6fe0124b0fd289aa8e15e3df5edafd7be5507001e3adce10f57bf1977cb617944ab0712457440e06478421428f8d5edaa8d0acdc40eb653fe1407d6ea44104fe729ffe67be4b9c92e59c06cbf4abe863a1c18ce10010c06b632cba647ca6048309dd0a523a9a899bb88305edbff2fa2747f6648e05f2216087c7a4f37b87d58c5e5df423d76e992e36a6d2b3f3702a1d8e4a8b3a7c9503f76a070f736a23a416d51c887b9b9f0ffc27abb3580082519d2cb27ece4b868b58c212c4585a576cab16388c18ad4e496a0dbeff4905826e62848c0042140d0e844598a993a306899abdd767785c781c6439fd422ec68213d2fe4ef51da996e16d595894237d6bc3c245adbeb9b0ac38cded6aa5032b5e67fc60e9175280445b2632a67db8b360bc358e6207dd43c1327d3a1144f1fdaf27c8cd234c8268a401032d85e36f6a43b86abc64104c1c714aa24a89f5b1816e1e5b8e5bcaaad569c43b61dda91e5b811c5a494cf05f3804c993eafe697436033a1719eb72c107cca70ad41c54cf49853579cd9f1fd1b85ef894900fe054e337ec0338e875d8fd4df2974eca7ca8c74fba4d5fa6681934a4e2f46587dd9c244fa9819ba51338c3d211c4724ba4d2437755db3d87cd1d1bf10df99e0a4e6f9242f4f731f298efa5e21c50b0252d34028cac754db159e7936b77606e2d2ad505377b3e42d923b89128b059ed19eade3ab1c147ef52d430cb286614e0562530d1bddf36f4379e635deca1e92e33031d2836b813cf5a8a292aadd4253be046beb506c8eab300d22cc107fc982c08c8c1204b3926840f2011c3dc6fcd93e82ad76b3f6025e0ae3df6fe4d4aec767c0540a1d2188e2d075495dcfd887f0fded3d09940d05cf369bd543dcc1ac0f0a675b78175c1394ab80dc603605440f58bd2a8c5f47b56dd6c7b42a8937d4684848f22f2c6e6b834891e2b3ef3f3a50088689d14b87a6c2e268a220eb1547c1d84d4443acd9a0f8bd88304155b4e53f3802956971bb77203bad147c0eb1514b21a8a33bd6e4ed2a129da11eee801004e7abaa524f58c5a918c2fdc85fd0b056b8cd1b3d404728b5ba24a3d0811f02bf31db78cc544f8edddc4f9e10525bb87664718143fb5b525e4af9e7296cdc09d3a21fca01673262d9ce5b0ada6fb6d97fc2490a329c419abe92f15257a4dfc6b8bb0885b9b2905915459ab71c7c6a762df48b70d40f8ae10198d8b0e35b920d5d9f87ea10023e6cc00ca692f5868e5cae43b2a90ce5d08ee3cdca1eb3603ab4756aa9dd46f8baf1b4989fd797b93cd4705f657e22f7a184bb2d90bddc808a69cd20c222360a9a63b37e13cfd857f1b0e1700ac9447449202f2057ed53f1bc799a33624120aec8fb5df423c3a13d7de36886735f89baab014bb981c60872ead5f85272f08e7c658baa5e0088b9d2df60cbabbd795bfaa521e4c647b232a01495d58433c60110d5a6314e1a906cf0f669fee11af2715d223df69366505f6c261c8b27fa815a537515c6edce06579593ed539be49eb406d45d387cd3cb5b28284a6ac74fc3ba91ca26cb6aebc67f975c4a21b003be388e83dddab170de5514fa6ed3afa16f16b727aa0779a39de99fc66246e1031812e5146187b607d77fb3c16e619e83c27f671597b2914b5ce4afc65efdb07902dbdf5c0db29e67c6b367a471558410d3b820a720d6f2a3232d4eb9f9917e8730a6f6bb3a7de9738b9c4e3b305a56e3854cb42448b4122220c5195f20525eb28de6032daf60e1438ea4715cdcba3e663754a8bbae7651eb52fe7aad2f2e4e264de5a126e9da63da4d81857ef0d239dc605cadc931fb9ed4c373d2072547f96a4d4cac1a224328c3827bbcc15182872d68abfd0a77d74744891c0c5fc2817a05f5e5c9a47f41c405689dc7a38d6c81b920e49912db2000a675a4c02bc6bb0782f97d11b00973b478493ffab19af06b463f45300f00da18fa07a12f914ae308d06bd5a45c30bf06c4359c4c4bef3c715ef6dded982755d168f4f7fa5d0de855d87c2cf3ab4aacff0013699b8afcbba2dfb15512e6a7b0e443bf03c8efea913e7c76f5a0746e5d09829b1d755b5a42f37f2bffb10649abaced0a762f567423af006ac8e40e075cf960a4dd9218bb77a4b73d1b322d7086c49d66019c9142e4f334241dd7077fe6d6271c09f57def33c645b65af3cc1f2f518d7460daea82f5dd5a6242e7591ab069c6c328574738b27bf0eccc96ea2e997dcafd8be5c450dd4f9d864e524ea58b4d07613360a56c1468737034414583bddddd8fa40ec8c9dca017273f4eeccd4ef8e04ab405260749c75be609bfad017848e4e81842d35c4993559ae62ca41471530d6bd4df8db685b587e453da52a4b0196190d635baf2c83173e15390161d3e38e48e8e4d744f143d52063e3cbb422947ee4fe1625592fa9e8de2372e34c92f59d9e8566eca9d09f9ce2d845deba2dc2d4adc43469f250fb1cdbce019d1e80c573885f6c91ec48188d9c6c0cef2c89a68c4905ca0df0199d4fe831a74498416f96b8bc6ce16faf066fc9428dfd2a1e6679a69c9ba4acc8686a3b475b22336d4c5caac4dcd1cea6c3edd2992ca296e8bb724179dc25d1b61932b3044ffa2c792ea1ce292781cab267a7aca7bb65c8832f97fab810d8130e185e989de4bf1789f3a10463ffe4f17c17284a5faea8df20d8e959a176fb78bc3047f02c8674c88bc880bf3b2168b71d818ec1f4085a4ac4dcf80e6c952322a63ecf93d37d4360174441e26c4aa5e1dbefaeba15ce77d25d73276cb1d4aab6cdc3dad806532c6b9e13487d8dcfc34f8472d87428769ead027e79629fa77d624129cc5c180e390d908698b387fc7bfd3638db34fd64cfcc89ba7f57ee0cabf6a558e9669c385a4a5c20d73eba1dd91c14cb7b5c4d9c0ef22d848ce2cf3c32ca17d608941e8697c4b36b2b0c496af8e185e35b88c5fa85ddd19bbfc7a33ffab0d806b76e1776095275ac8dc483d3fd02bddeb304b4420d9f5fd901330a1423d99b22c729428c9f7ca13dc339913e019ac1802d7a5ed90c2943d68460b2d35cdfb5d0089cf04b59d7ecf225f96bb779e877d5ddc5b6dce25f8e96fb0df103803de2713f2e180f7e47eb5c2c4541766946c4d6e439d99015f134b737ee8694e887b48d7ccf9f6f9ac5dbe7926e13f25af680fde5d74a60e35648b899709d36a1825236f6ae796f1dca7a82de7bb8d82317d930f56052dbd6bf09381a5420d22ba91bbdc02c1163270a8dc1100eee4d5be57e05d4cffe66adc430a095b22fadf09dc7ec2841497bcafc5a789bea26f1e518b70b4d7337246ef6f42e087f56b302a09612b33b0621c244f0b8d1425df863a256ad546328121a785a1b4ef2bb6038f9eae1a9e74f74c25cf29c6e5d3b11acd524699300d05ddfece9d4733a5ae2a7c4a9e3d64b10235964695499e40adf40da06551b230848f8f927ca2b109e95d80d66d3958760da6dfc4f2f8b0a67cd88451af622d856e29a5b5f0b11fea4ba98230410430c2dd20629b46a6b26507b6beb45781da39c0d0cdce454ddcf898e941be6bd7ff0f9034210420a3f10bec91b15d11f9c83193f9150d2b2c9ca06fe2345f8e1caa9b595b7d29961be8cc199881466a1ed298dfda395cae077431f9591fb920073c4a3f2a81be2a97b2deae1db87bd8e34d105b1060d86c0476cc1212eec1ccf063b7be90e4d37c9b0f34de7a8bce09d8322235f4b41c1a8775a71b9e1fbe761c0cb1c5dbd7fa75a52cf427a57f0bfe1c3d4b4540ea6c9f3ec12ae3dc6adc9275accae8aec9e2491a4911390c60cf042f41d31c331dbf00524e8198495111366b58bee8772d5fd078d2f8296dfff9ce7e87a6b18b612e2d4d000ff4184101689590609879a895cd16df7e45c7aec8801788024d65245398ba0d04d315cd7d1a3abfc47d5fe217f88ec03b801c8c2d37a0ef5f3aa61c9c1097ba9b561e3befc085aef3296c47e631132d779521700a7467870f5c9709a963e872439ca29a1d5f5288c820dffd2996e4f477f1edb19ec9d3806e67af9bed8e0faf5533dab4ec5df63ba7ade618b50ae2d5bfb25b688c692a9e49d71512bcff1f5e236169952e8a13f1555bdca4416e4cd568e4409f92304383f80446f49ed1e30ecb86ac3ffb600e45fec7c391235e45eb78a7b294621feeea3a76860fe32ceaa1157c98653bcfa1214c4e5a6bb17ecae7eaab488e9263e252d7318417e477c138834b8415b2400fdb383faf7eed82d4ae8cf65e34d49cf13fbc328bdfd5f6dca3ec624ccb2056cc54df02fa75c78d89e48a06b07f47d31dbe6825c652e93b3ffb826a5b450f5c82472ac3511580f7b8775d64de7765e60d9880d62d5c3013652622bdf2b8ecfff71c8cec938cf5d15c8256c4c41e5440b10b57e40ed4ce060c607a71b9561fb9f16c1cb3755caac996e755af2588c317cf93ee8d51604fc43f4c180773de2a0c4c3e167f0e54a88134116e35508bbfb23eb588ab83357e41586eb8cfcefca57bc20155fe3bdb0f0ffab04f08d84f94fe92a56a5d8bcc41743928e53c60d93edf54f91fb296faecee87bc7030349db58e93c62ff3ebc6a835fc60f3cae3be3e0d7f56e1f34e79497c9bf09c2bef0589f0d2ef6f2bdff31116cea14a389ae0bd5a73fe53cd7b7666926a4a7ac3c194ede1623a328ca936fe0b877d6c733165f46095b1d765e8df2b04138696c19a865016da84a6d465c896ee02f9e92560142ee1dd67529a1b0f439442193075aa0acd4430c127a1be93c2dc801d2a6e03479c1090b313639229b5c5dec94ffb1624499582a4457b30e721e0043688dba904d93d4e81b0b05da705f81683f0b9b2011126cdfe663bcdd0870af31afed47d4ffc4ac5c734088bdb928f1aed9e7510d470cc85aa85b48a53e8e70b261c8c43eb980372255320b225ac1cc04471ee6e0df55c22ef1a074e5f1954c03935fd8ec5fbd04917eded14b7411ce49d186dce143b5f5a4f17801e8cfa3128d6f62ed1c5005832727295a96236b934567a8818a16c9f2b1f18554891da55374844ae1790c399a178c2eed611e794d96f5f7c98d95d8512f5a7208dced69bfa8f8d43253f1d8a9a58d5b5d952a60de121ddfc8ca02bf460801682faaa8efc9e4051ef03fb530e560199dc56b8d7d2a750010860e1ecb7ec515d191aa4c1cf19038585f4a844b23ecff8ce652b639f6efcaec2cedcb735fa659e60e79ce675022aaf62ac835b704ae20b428a5f3be542d754175398dc07713c5eef8dfd264aff9e41be1a119e8d2cf1a532204b71c2906bb5ea9be6cdbc33bb36af5b081dc39cd461b5579f82108d8ac29fc08f95c3e5643262db75ce8675f77a1d96e6da49d7ee6d46c5db097d4ce8a4e947799025d6e0748cfa91e5dbed5b92c1bb071cb8b2c7ec674d2a514ba9736ba7573f045d25fe59eb05ae55fdb1075f87da2e1fe49db96f7ee2b0f6f0632c8537366ee0cfce4e2bb0cd4c0d92814bef135bb87b3c607d460bcae34964b82c0d24f1aef02464276a01958fb28555d31dab87ecd1335a5eab5d61731b2b41980e837852aa0f08cec808f1e13d927812a5362497cccba9ef5e901e9189bf6aea6d9bf1afd869ec7deabe7fc596173f40403f7e60d2c20b5a1d193d059b4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
