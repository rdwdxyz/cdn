<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61279ebf0356feea9aa6cc20bba517f1a68a2d500b5678d48a11cf1386deb92b8a4e93e7bf3c55b4288bf1dd7ca1c5199feb990aa65e3198827485f468e112a3dc9696cdcb5c9ca5b186e4d4d596105b9c540450577611908c34f72a4c4e30b1a8450f0ec15850acc319b50b42b90525b558ce4e79dc2c5b0243e3c8a2a421a227b5bb04d9278ff7fc4a79fa8b87b2bf4c950ca4afe018e484356377e2d342b61aca37d42ec6ff9076c2ec6d33189199fbfa19ddcfbae2fee12ae49c336cd623960d64377f20ab7855417d5888338dd37c1e107c202fe7d907ef4f9f0a2989313f71b667f7a44f2f564a5c6e557ad76a81ee4dfd3b552556592daf8ea8aefa614ed50eea82860211bab2cc5ce93d459f17274335248a417b53e828322d6d752236a24d438d8ace447173de0b0e55f8d228828f91c020a2706fdd509616c3b14511815468ccda38f546cd482b1da2427b42081dacd30b7dad181668587b553de411a9040306fda8821742595e2caf6c63eee1585a83342c5f8396204e74b5e9a4f30c385d45a440bae4995d1de2852627d2b7a43a7a957f1c005606efd569928961dda4dbc5c6a099863be7d562e54dc53fe24df4871e7e8be4228780b54087a41d2067ebfc109c417dfe547dca6c0839ffd4e6cb804f875489f7f4c7eaed8647c418fe18eda9824726d60c1bf83266606ddabfdac0b9ee8d5cc4897e4e86973b56aa4d52e7d8140dc62c0be6612cc037328b6d1bc02a5c5b6f3d13825e35d85e5726978aa580289ef6b9ded9f5330cc6c4103dde509dae3dadcaa63428d70d300654cd8f7b65491c92459de48e8adfecc84654d75a27b72ae1f952b299ee2433225a1b963d9534c504cae1ac5c056cb41d216c1c716095003e695b03fb6fa0c8d0ebbe31dc334e702e1c83357a6955febc5dec8425e663231751feec3d8ab0a4dae5b39e982ca8ce2afdb1eccfb25f0f76960806d4477167ef858d8980b3161bbc0e897f0f8b7242f066aa00cd01c6a7836d0c9604866dcd76cb159fca8f09503efcd06a6b15129e59d7414aff52aa28f36b1e7bd418f31b134520ef50868fdb17259ecc4ce5ddb8a8c18221d9bddf004190edee4bdbc81d4b922a6374d15e09444875cd054b5c755f67ad518e052e840dce42c73e143266c24b18282fb92a0210fd6334f3f86aa617ed3aaa8944129bc18548930ef194b1269d0692660d3e130257d0fbfec5a92593d586d7a72e98db70cb2d69c98053938a2d0330509e7caa1e3de10d405fab1946cb92a4811b49059d0300b20ca834ef6213afac807da8af62b738f0262137d277404d0c9b15ce92456e31dc271647dcba670d7a2f4f2d23bf4613f475da018a13602121bd57537b0fbe9d7f9509fc10929ff92f49262d49e07e3af1ea5822f26672b190c512f1e49ee7c44afa9895688a9997aec4b5574a931b8e1c7aabaf55cbb471af6aeb145929ecd473785090122eb328dd4be1e6acabbdae275930312e0e72a1c0bc5d9d48f43c18bfb55265d0f3f07995bbe41bb4218a7493f43d45c7c3ef57067f53a57ced496deb6ad9cb5480e5c622028473f60b9a8c93af550ea59c75551e0b6469d2ef5a490722b5031b52d6a0e8e4d2f5b6b627d31fc2e59b4402820d147e273eaad1443c58ea02e27b9e7d226254f7eaf852217bc22094a6c4c67a4fc514615839ef483465b048b582829bfb59303734a18f2cdc2dd4e46f62a2d2156de287c34e08e84ce34449711c289d4d171775ff170c5da8199d6df1c3479f98fa76eac85913526613c0e57927697663289328098e3fc7bc50eae868f5af7850c0e344318d49842c6c668333afb688cf8cab73ccf5dcf37192946ef81529b760f9683acc3c571570e651213bbb43904c56045c1a576b07fb51c274b31033b460e0d374f087f5f351e85f2a689c04ec905147b1ea891d7c7af036073e74fbbaa669a1c024d2127ff6a39b2be9d2a7601d9fa9eba064e4535d477db9d9c1cdd14822fb8cd58317fac266986cba88b987a89fbf99c91d084c95f2f7453ca67b95a164e0c06424b56863247807774f6cdb8d7f940764ae11b3cd37923104531c683a2d2a59184e96ca0131f0df51b3924ac704ac4b2d0418e86b2a1b44493218dc75782278645efe52963d70becf46591459de7c6626c9a8d237d706991d63b797653a17f3ec2e602838b47dbbae7de63ca99db6620bec55cac21afe8ff1a6720fd171cc1aecc1a227a6957639b67face3378498d073337f173a742d1d0f580c10c603eda53d8fe1639fa4ef88682d48e554d4b95f97f1ae0b889c25fa60ed7a3cf27a0ff21b01d28607d88de0d16ae9c18adba8c8d34675ac0baa7f59c51b93e9a7941bc3d2ef7ab4ae536a23c72c32ad5f951081507a73e34b34250ccf66495e416bcafca4b17e08bc1af6e56093e20315a11354da3016fc582e6d6ad6ed470445f8ce9d678c5bbdbeccfa821b708bfe9d9928a375c82e94394233acd77ef13d9df004734c0fcc7546c1fcfd5c31c043f1bf04c79f7fc23f2e39a03783aa832f8f84383ecbbf4911b75d58040c20645751f8edce00f9901bc1921266c486b4b423655ba182b132f55b6555210bd0d75ee3a894d6b9f802e0ed828d86a97597ca9df4faab1729914ea723739237cf5c80627b5759ac2eae64a886055b7826568e3cc1d8d546717c41a4d64c062e718723f6b74acb112add3f4a5d61f7aa5d402f82e318614e0961a7094bdb7017880c1a7b00822fccd101f348b2f668e6549620896d00121cf1965f75b6c67cf630061d032fdb5ffd2691f3ccb512bcb562953016c74dd779da466d652c589040897e4ba8b82f21f649f9ed35e94d34e7e82b5067e5f5f22b14192a91762402533afe40295aa90e9abe2d9b6c88a839cd95bcb3b7d180544c9bba201b069429015bca35d5e04b14f2353997494ac2e2c4da94b71e5d449b4e71dc9bf37f2416c91c587bc15fcd6df4e5dfd560ba917455b4d45d46e2aada4b81672286415a6c2036fd4d2c8615d8f533e06fd321b744028cea69f35e5d6f3828d258b2fae162ca9859e5725abe5f6dafbcfcc70e6822179079ad07488c36e56bf02bd168a4887390452c5879d7c5defcb02f43f10584e4b4a3f6bd15a7ea97c63056e275495c8dfccb062051c7a34346edbb43cab2dda5e67273c1f0f8d58e61759c98fe6081c2097010e62ff3bd4a6f847bc9448d7b8dee706b4c303ffa2a220a86b8a01aecb02f3b8bac89722440bed3404b5f3d488e25423bb1eda446aa4311e4edd911ba5bdf01f1ac2190887a129512ff7218826e98007681cb8f902e8ee0e8925ad95b36e88d67d6408ab5d213387a812fd9b1889d3f712e4b322ea16ab377d6f575dbf7c04e0093b7c8a27a82986425eb34ed97ff3376e4cfc85ec15ce1eb2f627e7bd02f5a9c648f982ae37befcbc24f05a5baed015ccb3abbb6eb9b9ebc0893b0ad93764aee345840ce745725058e7807718dbbd96205a233996d9b37829467a07fe3d02c4f9383952932b4c73261c96c6f78b9870294cfc5e058990eafb4fdef766a7ec919ad4716e86a049020df5d9472c6b94fa53fff3aafa594676929a0cab36e3c553e1c716ba7b711212a0cd8b3fcbcb1fa8c9227b81b505f159b9c95ef0b943bedbf22a1612b0630895db71ee819b60a3e0c8d889cf2223199af68dfbe52f593c81f3abb17aaf5643af740ea92522976e3c15b1a2ed6dc9a6cd2d1d51cc7dc4a49d27c0d84b3d46636f594f5705a0859bbe1c25ea36c2504dad1a37aa05027c04ec9b89b6ffcb22de1d33c3efe80aecbc8af097e2923c58fd65278c85fb99dedf125b347160c6151ff63b869a8ad5a7dd1f4a75505dded2478080e01b90a5f986c6eab300acdc303925ae4a9177ce82462d321f01e921980e23b06189e2d8f89c7c9fb8ce9e600a42a8d8c71a3e5b52b202436d4ed7d464d0ad80df11734da95bab8a95e85337fcc4bb62b0135f0f585f27de99c3e87a80ac6510c1ee5f95dabbf579f90957d7ab7ed3190f417f9d4f1a73d2de0c02571f463daaa16060ccb8088cd3dc88982cbd3ef0f0a227346243c2deee9754e121129325112ce74f3cb5a6c063205ef4827597c3cd8872d11d7f4c65bdff3d2350e1283581cc83502c11206c202c7014a32d65b9d5923a9400923e76ac482a482a67acbb9b32714db0e2702fd01bfd4ff4d4a1c2835287e8ee18122897ca04c2f3705ac3b2e91a1a7dda105419d8d2cec9268ddad93780d0c7eaa396667c132ae6843969975e7b3cb35b166fee026db77f3635c9f798fd92c85e1f256e3053ee2d87c039302a35c24ac1a60a845d89df6dfa92adffd75296f3eeb074524ce3a9633371643f9d725fb9b753393103ad8021c90bfe3709e7e5656bcf4dea78efb4a1677fdced78430cd9d664fd346095ce0162a1edef178902c5779f6e1989f7c37c925777dfe13aebb209d2226d904e5c64bb90a4250b7e51dda4c6063d3c30a37b84dc52398e6fee8c09b064eee66cc5ba6a63241c38487505927d65c055fbefdd3244d8b549edf188eab90423d395050ab08d3e53ec5d71b16d927ce71a6f02da0c43aae81d378fc32bd7d8e02972bc219e6204c199ba3781824af987bb92c0e8fec6cfdc95020d1cb523f3ff9a3821e788b1c54e76a116e84089d0f2ca1dff84963bcf7ffbece8d792106fad5c3c018b960dc2ff39386a34d6dc90d74dacd2c53d75f61cc428119aa81a184e658fe8ce5fc04f16feff273acf56907e616a1210144cb69b665b7361edd771b988f9a816b932a1b0cd50f3cfb5548338493214db5c4314557df34af7064c5f42dba7eb8f05a6b9648b03fbb03d8e1c72c40a96853b89358e15ab733ec708fd87a3f6210714d75b375445e06117fbefa9f35e0d980c39c935f51a5b5d07172c53e6470711dd16875c5fa97b6d4d4694d602985ca6d7313e1440a64eb28d4cf229f8d7e7d50516f823f471ae70d8bb96e0770072a45672ed9a55fcdb211bd320c7b18fb4d5e6f679005a290778342e94e65af26cb564fb7b46969691f2264cfac31cddd266b5b21b261736cd171a8cc2d1cf693074fc9141f690464dc69e33714539e59ea8bf6d908fd5bdce2208c9003fd5faef66f8cc77e1de7acf830af4105da5d486fd7099b96c06bbb61ce72c235a308efa0523bf0015eb10ef4ee8df0ec08d26420e11ace0b62ff2adb60e38ef84fad2f3c350730e0790e11db1f04c0e41d2f4ef50350823bd336094a26a58d483635196591d364ded0f2505bb62530c013d3b4b0af1c4120e4e351933180a1a18028416b722bb6ed817fc49fe5331275d72a6f67f99d2d8d692222558cc4eb7b963a0bc40605eb25546fefdfa1769adb4db74971c1b934ed9b251632a583bda9b6bcd73bb7d11d1e03db5edb313c9c66bc6054387a14430c067252b44ac83bf6f3de353d5d5df5f14fb0e14bec64bbb18333b3aff57ab71422e297da8a70bacbc64c828103b0109da50cdcb34bfd09cbd255388c7dd364668ecbdfaa05970c75530638d00684302468aa132d5673f83e9d2a66860f335cc1da03c3a72c71250252545cb74fb30c99e1ce7815c6e0adb9b60d8cd3a8d498046aec3f8e70045b4f451dd3eb1830fcfd38ef8429ecf69defe57b95ca3e9991136ddb5e3e666b0b24f4f6bfa27f0bb8576f55d7678855a5aa77d142f20569068eb9da567e41b7efbba157242d84e1171160010b65bae69d511bfb335948fdafc00a60ed778ed57045c0473281ce791a9889d4adcef630758a9340a61437aac15c0e33d4fec56b90d02666ec09b5ffcf9d70394f8c64c908eb757de40fbcabc9a0a49d2930dd6239d15e34bfe5f3f78551b59146efe4c1c404caf1de9ee26950986880b7b07d00c40072fdb59547a22cd142e45628659a8c180e191baf337a457306cc9cc61bd978326a540a70bd37eb74ab93db2c3bcbd1719bc1b29c808a14a20f14a0bba1b7063f0c8a5b8f6947ae61df2c5d6815f7feb4e636eebe10b6f7a782bbd9f996c941ffbfb8461325c2ec31c39fc5ac2ff41ae2016e5a1caea5d66e7d095c9898936d2f1462cdde48e87d1b2abaa5edfe90d9581ee00cbcef2c54c0013f7bb6e7d7c4d41279988d41aac6321342942c19b732f2b053c932aa1330e7c6317f868a2aa12acf7f9c031d4a142ef96a7258ce4ee4b2cd3c34226dc1e026d631f7efcc299f91dde889a4689a8fba9703b2d7943de753a696f54528efa119e8e6a5bf4b474f2a585bcdc459590c8625d0bf613dfe35c367a00731b921cae7e51dd803311357868f1d9f54353c8834501f398824d92358fcfc2e73846ccc8a281ecdf344c5af04d4500f0319880cf0b6b070196b4f75e9016407437a6cb4b58702116bab76e39452d585f8d19c7d74cd6738096622fcdb95634705ce725c7d27c12083e149eb0fbcd847b1142f9adfb33a2f675f90d393b123ad32904eb3c6f6126ee22202ef04a371c212e75393db8cbb3e6384d810c8518010db7c76a226d846ad7e65635b10c21b46ed3e6eacd44fa4c4640e5e206dec2628789c990b1ce368935b387e890562f84d74093038c75e70a41f94a12eeec9ea755e699edfe86c844459a03acb7345ddad692971c319cca59eb340d0c72bb90c98e4daf0c6279d7b8c04c5b70147b9a2f05983e47514368c267c9770e20b40e1d039d4db4eed2838c8a83282ca53f1803cfd9a175e643f33afa5063b7c33b5ddcca648af337c9a1fa706d3c2dd40e004f43ffdcddccb6e3cdb11bbb02f4000cbfa870e428e2215ed8446fe40487e9ec00aa189680f050c2bd923ec844f93d4be97246a5641d8ac6fe5989183fa9fd7b170b0bd106eeca01b696143e3930cc52d06225c7e8da4717aec709125530bacc3c5710fd916851d58291bbd760cf7d58fe3054de6f6aee25a4d9020727ab6fea625626abf15657f506e40eb3261a438096d851270afa5fb4cb67d007f588d699e0fa9201c5dfee897f12a8bf2e613c081888d4e8ded311e6d33c755e4bc7823ba06178060d60d0f36881147861ac98192b1bb09f52b7026edd7739e6602c6f6f376ada4857312bedc06ee6868d09e1dd38b7bbf01e961b2179228ef95c48052e4354f93014b913e7901c62ccca43b7ca79ee24caec930607b241aa2b411330cc9e32d9a8467e30b846dd23723e33fd409d26c19f9991b41bf6384950edcbc4d75b1df452b892350c99efdfddc5e7f701f6808864d7e32ef929a29c9519f02d2608f26736b5ba2e8494cd3467f5c85c0f50e1097c80a597b8d47d8468343702eac75f876378a2c9b9e9bc8bd4d80fcd719c611419ccbd345336fd48343ddee06ef35b862b627dc379805f7ecaa9edfef086aa9df6e8ef984b3db64d1ff7d64f2868f3262f76e65d0b75beba608ee6c3c6ef7a7a47d73f70cd3e8e1283a0345295237890338a678e57922d3eb6c42506921c48cf8ab1b3665e9911178124007921f8866f4ce63316484d5f486b5bb323e07542a28e018e219383cdb28dab2ee171c156018bc90c1b6db90a3f58964bb6d487f79b461aa3a79c0930c1a4dc360752825f0c52be2946e488bebc2dab60ff8b64a3b98fa1676ae3e56d82d601bb5b042e462b8d7076e7848fa8b2050edab49fbe5089a1f175db1acaea7baeca613cc3385e7b62e4754f6a403c5d32deaaa2960b38c979609c88deb3533ceff6220af93bc6041f90c4f2329d0273221abf324f1b76fe507787cdff237597059cc99057a8faa7cee0495911f9ad09f49cb60d6f91c94e815d7b5a030c6211aafa6c902c418df9a6e6b02d0e8747d5140f1ec4b56f3ef4ecf050e0829c5452c7bfeac20f24628d5da51921f5c7fc1e5fda5748257cfcc4c21d9477c4b8ab84fa5aeae1668db404f15197fa167f9b5abdc79d8400646124e6dd61d22c8588679179a4de1d69205ce03861d8c0d270a5fdc7b0338f39ca375f2b0fe19a0544630cd943d073e4bce34eb19b5db330273ffdacf11eb532bb98bdd94a70c4a37f816c66790f724391ee0cdaa656ccc1d6dc85c05d58d8e298f8e4527ae39093806cb1336bb8d0f15d5f9909a882f1304f3a8258a864504075dbf438fa5eced3b03078c59007890fca22335a4756f5d8a8f266fa942dc0271c06cd6b5571baa52da6ddc071c8f01df3ac16e16aa10ec0d10996d47dbddd9b9f495a62f81cc4fdcd917ca80b331b0d573d0e21b8e957827bf1b7dcd0d06f7a2adce3d70dda30c21c4dd52c35a0f98170cdddefd8fc8ec17b6c0a400a2f8f6a1aa026244bfa5e22ea201774b4fef6ca7bc584facd666f63e706c120cadff2621966d04368a92de0ff953c62952537b08b389c195cc25652aeccf8cdd98917c6d9d282e1ff905dcfa6a9dbe7d7c415761744da8a4b1ba5cd5faac8f46d2d8ff3a5d506a4d515d8951908807eafff97656e20da56571c9d56f2c4b7367982acce9b5badb418ad03e151e277ec9b293092692516dfd1d4ac623da8e3ee79691b21e0318ff67fc2934bdb4bb727afae99839dec57a50ab8af29bc7f6537c3a00cf2cf782431009b73d747775342afedd8b5aff32a0807027eb91850c6e26cc8dfd26b9878c94c05b760c63c2a6bf174d14e21e03af4429f2a23e381a4ad5b5bee4ab3c9ffdc0c7e3d6a226654b02266f6745ab69cb758cb3af2c30a98f81d9f66d6b6b0cec11f0634faa1a88ee61174872b513d8bd965be11746bcc9b6da3eac1b43709dae47fed552e0d1f95565f460b4e8e6e983ef7a87cd1db0fff401bb5b3b28d00b33159ff5c7ce52221544aebd639e6961a44a9b28110ffb59bf16e3c6c923d516fdd75b8e3996c5c62f76afc890cd7db2d038a599d8b3736ccb4ec113f3c2f3b99fa04ff6f2bace4a535271259d53534f6bf903e4c4830b6acba81cc4bc9a32bbf5ce84432a9d2ad8cfeffedbc9c323744034c25508469ffadbea4b7193ccea856abdb26004859bcd03ff074482eab6c89626fdbd5725dae5e6af73249bc6b06798cca6ae58561f7fda18305c3352b12e061de2e28874bbef1746d09da35f5f0a108609c06a9faa51ab2511effcf28bc69439dab9e374883fa36e528c7b5395cd80d0f573a3daf0edafa24820d0c3285649780deb0f3423652b5d15a5e16dd4bd46bcba069ccc68384bf123a87af34ab20bcd3913dcc6e5a5fac38446fca974c5283a83bffca412d7e1efcbb1c4cd5463591252e8eb54f9fbdf3034e1aa47119d9f3e551b2880afb1bea7337abc90d3c01a2b811a32a99679dbbe5b9320a91b492e065b36f0f604b5bdfa20aa40359698cf50505c6ea95008a0911d12a0b837f876b84fc4e3c2a8b5a7079291193a2a53feeb2c38d618b4050c2507d7f4b472c04c5800cc56059d41cb82dfffb16a56d19d57aedef16d86946405942d6be54d3d6c483e993948f9864120a8459512395f4291fb91fdde90313e30896c80550aa564288b1b7d379ddb41bdb6cd01a3d42c1c0ec24524cbd38d6ee5b7ca8bae7881c5c39eae253a1037bf5e061c764fa157de3252096af0f1b41471e290ebc8fc31c59fc5d955801b26f83aaa896241875ea9d51ecee77e1f46e66597b77722522a5ce31f6c3a05be59a1238a9a2e5eb9ab9c36e3c0a93c62423689d7769291075793ce99b3335759a26d711b2b98643dde3d98e2de79c36302b752ba3565c5507dce332694371c7a82846bbd5f3eda346f295bcc428b0ab20e0914ecaf2f1cbf6f11cd17d8abff36784886278459e57c73f03b21b8e1d9de8a085f3f45771045a725b39187e240c6aa55298fc48b74754b28c5eaa313a792700697b2dca47a9abef6298a72bc1bf6532b5740232ab9c54b55fbcb53ba5cd77be9d85d7657a13b083f38baca60588a05f56e8e38fe3926785706db54eb925901ccd74f9a69f21ec9d18c2752f2c24803b0f0452f2aacc5fa069da14a12526269a138fba1d9af49e5ece3f431f3375eefd4600c2b6c2b8fbfe2eada68ec74ba550a0ca994ca71bd4c92f945c69fede30eaee4c626f24b67b8991b95c6478ae72a68d3d6f16a6a6e35ae6cb30d2814ac8677ae68fc3f9f9328f3ea659a4090b84182edaa3cef82dae58687867b7c85ee1b6de178853a99754852683b11215456dc26626349a6c1a3518daaf8c8736ef09f2ccde619d1b4f50734a4b94026238d629520c48139496992c1901004f3b55d503f145c7b7002ecf49c8685b9bae9925360b947199bc51c7e155c9e5ddc5e12ddb171391f3ba32775aa599de7efaed03d64abfe0f50aeac1bcb49862454ebcad0560f97de6eeb9dcb096a014b63a07585263e17a7ce89493f161990a88efc6c0515285f1d4faf780afcacf4d3ff451e5ebd58a07dbac75f398dc4400965bcbfac1bc55ac8af3975e5a73c4c9256f9ddf55a96d05dba563dca545a063ff28f400fe5347468c5b7f36cfda63ae0d10cf767d15cc74bf6ae5eef5812d186b5ee4e7b14ad1f5b79bc7c6eaa8f826dae74b43527c36a2c3d2e54168b157b8d8b1ae19f76dc7a50eaa810ba516acef1fee6687aa633d5b56876911293a2931a9b9dd61cd46dbbd777982ba30c3e66aac2e8b9e379e7658f17aeb2a61d6e0e4afc75c0c89751ba2dfc8284172a2a1dfc1a0facdea1c3851bcd3a4929ab99aa0d2794d060b6c97239890c76ab2586737e148b6215d4ed83c2553105bcb09d91eaa2a3db7d831ae26417356b0dcc43c124ac3b3592ff8134da06bbeed366de01a95fbb8401d010bb852c465d119f4f5e7527b0b7f48ef7ed7c453e65c39b7e3e4871f788062823f701df82f91c6d76f027793b71bd25f70ee3c8439f78ff445e1cc0c603ea837a68a711686e0d567c20595eb868e729d5534dd6f8f0f85e5da2c92e968a7d725b07527b602d6e7d395a29967fa5c959af7b0ef51d85d0e4a68009945131927589c6709574fa499826dfe5fa3c728f974ea1062c35fb48895a86bc778da8996326d90d8b2e95f7056d30b7679e447edbcffa2b2965b8339462c659f121951f9086f247e0378418b412c76f5712295b9947510615873ef097821a1970d03659b377b1cb236195c0b1bcf65dd6c242c206389f16f77b194fe072edcf9a5931199470d87710b204f665a6fb1a92daf075e6ecc3a5d0859cc602fffff778c7bce6d1509485adb6c2ac8e1a240b6ee4ed2147a761abb5ce05baf9427395ec54b000f638cefe572f68f33a33d876cdd078bc834a21467c7b7cae566fcbef9461b760be273311950e4d727558ae8e7ad9be19c7293e905dbb5ba20fd82d35aaf07034c0a395636af0deb88c50ce994b73adc317e626912675d1647c47bbf1c5f564aff6610adfc71a5abe03ddb75cb16b4212c7c188440dd3bfa101a9ce2b72e2da24c8e12f17e2f72aeeed3aa4db39272fcf952f91bdeb90bc8b6ecddc294d4967fe24ce69589da9c54e6eedda1eaa9c74e0e5bdf1363d55fa832183c10e661da0ca60a4ed89ac2eb0ecca213b721ca5039c4e6ca738848424439b62d8117cc842e4f9eaebdd488c7332071d2777f190bcac12f67ec003b98abc739e1bfb0ed7e1cfcb45cf898cf1ecd4e2a7dbc1f1d6e97719f660afc41af687abf45939f6aa7271f34d865dd55aed61df95247923706b437ad5a4d14e9d93b777ba3c52cbc3349b6b20d8613de5f273c60f581f70401a826716bc9868b9449318aa7f12ea73f86fc3ed27489a04bee2026b7a5eac8610ea5ad1bf881a9d219346b356a627cea85ce43c809e079369a247308f15e0e198e6e45a04e9e3ed8591b31067c38bd3c1a9f91bf047af26c06603aec0ee35f4c8d11b690c6f2576c05317d858e121d1bf60167739fb71d3c349ad25f5c63516284de6e7ff3c47d7b33ef9b67168d5c02fe248bdda3ad5af9822df44a25026265a4a41b7b39ef5a24fff42e01413fb651a0472c90fcf1f964a7c89f551b089e52f5ef1137bdec4296f658d1223ec3328b6cff4613cc61b3b96acfe2ed0a43c4f3452e09bf2cb0968fb030c5e9be85f0c5af6118f94e6f1ac0615d33df6b94e75a11921d5aa423c160403da2295ec70e4c6dd6ee37c63cad15563fa36d6fc91cf587f3baee57a7d50300a5f5b2f637fe864737077bfa59dbcbf3d3f6d91497b76130782d839638f30c0714c3197b272c659e40510a0082d26b1b405aa14d1093d2cd317e5b7c75e10ff5f7b51b9bd0c35f76dd26ca1dacec6684ceb9991e7821db882a43e8987ea8b2c7d27ae12b1d324c7c900029ab7df1283308b9724a0bd9edaa7bcfaa7815e8bc8d61a59be2039d15f4bad17b7f92291b3039ea58fd3fb6112f89315b0958805b0378fac43c7797225d22f8ddd0f78f5a44d54d6cf56ab635fe411dcd3234c31d3c46464ddbd5305769399cbf0f18510d09c12213dbe64f8ca2db8edf2e099a9bb3336fc1f435765339341cc0e0509a679fe389a88f669e88e192624138a37f929524b3a53674c52463bdc5b70f9e34d233c60976b09fe80e3d4bf0f1936bd4a92f95fc7a8e99caaa5c5249a2cfebfa09e60c74cf9d15ccb5ada310e86cd3b18e811efb0893bc92814b4bc6aafb3297e53da22e7848db264130cac15acc4e900e36ca2c124fd921c67c8bd243cf145d9fa26e2cf2a3f6f08728f40be40c8cb5d60ee14cc0c38effdb8707d6c8e9e7dfc7957e393a1ba6dc3cb0d3444b23957d119fd44d9fca7d8c3be828b88fec41da4587d679bec336a23b417e7c8ba7640c8434baae8c10b5103248010fa97d63523636122b70fac6e51d5ca9b2f71fa761924fb63ec8f7398c2bd659f2bee2d33f543dc3099ace76eddf3482359474866878eacbb1ec7f386a3e5439a234f96cbcdc17d50e324ac56b41e64b6e5b4837742b4e6586074ae46eea92d92aef6506600f3dd0ee00d990c8f66519f08ec2ed1d73aefea6ebaee41ee6fff0c3ce84a1301018d6206dc46462ffa3635cac79a8922835629048fa93db753f8c3660401102b449ea59c91ea35f5a6ba1636ec06eb196d15f320375ad1858a33bf8fc1cf5188092c89c86e20a76bab726f373800d1fc3b3a4095f99b5452de6dea833840ee34ade56d1d93a59097bfae5b2d2effa80bf2f8fd89ef92718f744512b11105b163e3dc0c88b6b595e22dfdd960eb744aff9985e3c73dc8055a5c471cf6f44d409a854e7af94620861483bdaca55b7103d85dd3b5b3501513392e4e849dfe94c6e56a48caf368a5a905a43b2281a162b0d65aeb2b10737dc2f89f8c64b36b0da319d50d8b2e7de0d49ed89b2eb7f34cdefb24589fa3eedc27370c0b0999812acccd1854d9fd8d6ac4d455d8622383e80121c0a881feac67466c51602f2f2815655e076563b6eae788af3b523fdb48336ef6848335799894e13f7d5cc4d65f44697e6c685e3022182e3739b9a4369a55707eff025fb71119c88ead832cf7b07fa648ea3c58a5264dce0d2160a951dd2ac893a5e8adcc69138be1bfe079b4bed36fa35233e1deecd99b65f91ece39b0c8695b50e96ce0dd4c33bf6d0255b7744576b527af8f68ee4d113b8fd6ba0b2347f28c0ca6910e349835ded100eb67d0cc060153efbf004e7e19be6f60bc80c63782bbb76ae75e7c64565c263f7faec673e1784ed37d088c9878946071e6a01571397fab59d6587cce12929e5c44f90f1a5cfbed01b0615263864b07ed73e21c1aaa5cfcf9b576fbfbc032950e9c7360792b4188b5293cefd8cb04abc8765cbc6d79c176573478067ed6e742ed126bcf5dc25863416be1d135dfa85ab6dfde5074d03a4b036cbba6f056429a6034bd7df5c51dc9edb3fa1ae9a22e643dfbee03a141410f38e078b0a0fa6e83e0fb9a86a4bd092b49c2f05855c433b3173a402d1a109f625416534d0242f8bdd4a8a728803bfc01b30965a587b695942d11cf5db89036424cbae717a9e932b9a11e66a55050593197273d213dc371a613db6972af0462c449ac009e36242ceaa8720fea64d7baf8cb901d321a2a3db6eb7264b568debe1802bd0ec3a9c9f91538a25728c5b4ba30592589f2090efdcdcabf6e6493e7dcab2a9fe4191e815d4951e8c3563431dd73dac7f9d3a4087b9a5d8b197c2c6f3847be75e8cc7a3450be7ff70b97d4f58edbee54fcec18b14eac6a1560ed6cf367e92f9a9d950c61e3aebceb6ba72d5f40d1b5206acec453ad0b5953b8cecac1e3c6f7ab5ca62e83b698369cb3b55cd553cde2d032b0ff545eee190f0ca39c1af4f3e8a62967df33314a8902f5242b977f1d91217a16183bbeea1188e44662567e586e7d74c6e828dd4a39046fb23721af70cf9d8320d6bf6092fcf0e345cdbb4abf1c85d6d871d296543996fe20045855da123930b090741c10fb9fb20cbe8a3bb980bb43b0df86352ddc54e77dba1d63e269a0ae52e864a6e8eaddb76ba8cd2842cb7b03d70129d2d149b6456eb6746550b1ec3b6ea0167a28e4d12ed3078e1338964c135158f2a6cb0aa7bb9d2b869cb6d43e6fe8f7798c1f56811834f47baf1984318b96adc10406dd810b412aecda7fa9f0797a11ed875b5776157d0b495cdb1ca9f29402cb4573efc5aceaa0f4c2c1f2563b1332d44cb6fab05e400fae22d53d2ee5bc9360903aeeccc087343cd7cbf0741c61054a10bbd9066f766b52e93f981d410f4a3c6b3a261fcbfa20dc94712dc4e1c8aece55d97da62ebc6d71301bd4bea21f9018db61a05ca592d95fb43d549e1478764c7cfe0bc9c8e80e5a2180052597d5275a757f735feb2715357fa53cefe2078c27c389ac5fb4ff5582d740eda0458b938fc8e341ca2f01b17c09f2657412eb1c9b55d998775d9b5b862bc0f93896242b37adb79e9a5b3c6f2edf65a5307b248036d3d632b985ab31cb2028cb1e91a0c5710f155e1eaf0a995b5311e6685dc6cb9fda41780ec511c8b7ba7f101390e13ccf341fd3874e10971f78496e99c07d818df3485692450f2376732899b2ec8e9b5c5f04f9658aa7624c86bd3b2552ef90d9fe779b45f866b5dc13d139898a002bb1666c09fe1906d781cfef417fee345ca12d824e717a90ef641c3d7ef9acea6cd586221ed34fd62daa4bf33fb90a7f1faa82b7b7460c1b2711ef297b8896a8789ed5f0dc0f480938533ce92039a75ef75c5d4d077fcafdda7377b4ae7c515be59c58c81716afe41aed30697dddd58f3dacef40460b45b3ec8afe1cc10188a50011c21567b392e33cb989b95a5142bd629d94d9e16bc218e3ab397aaea4c90d1fa9d1b73b43faed7d1ebd44cbc67d2e05004ec67e01feb32e73ffdbc94bbff9264790ff4f9b8385bfb30178c4afd9499992a6e6c5d20238da23f59cf6d16848697df236731daa9cb37912b8b8402cd5b13674c0bc9041255488eb88c7fcf449cb51addc1ab2a27107d6b5f17a529825f3e7f1d20e110d643c400e5044ec6b687742f10758016423b364ffc90a2cbd57d45d3aeaac5a9723bf47aae937115fd2ff897c087228ae3f5276d3f74ef9da2a93ba06e2c4849b0f077ccabd7cc2ae6ebe777fdf2ae8de69c1a862f2222e1284d843d06435c7347ad6834f3feb41155b28a0340030938e5d3797bdffb75057433ad9e96eefda814c0578116800a25c4b573c207bec9ef43a97d6b4547a078e2f267d0e5699c87d37679c37e15a780615c469c664808c6eeb32e26fe0ca4ccc6dd5254b4dfb8c528b246b102b2497c70e3275984d97f27c2f235a297e42bc2b09b633856a8d650d0e7cd8525856daae61ee1d1f51ef23f77b7185db2dde9737c15f5480ff1282d773a0ca6558326f136fffd1b558b92c61f0d336ada8598e94f51429da28bb056ccc5cc894e5f1c946d7dc53289bf1cd66ddd0a21a155f9127c48e197810ec988e9535ff6631401fdcc5f91219914718bc9c5304fc2a7864e3873deac46c9b8a357378c7ec82bf84ace853b6641fc8640300abcca583f9d9d789a9a14205f051e93ad2f8e9d7ac5a95650b3148fcbf1bb6e1203079dfc711397dd1d1381bb668b20b9eef6cc5e3e27d5565a5bb688fb4a5ac0bb039dbf13a7e302f9eb13042b2db1658842589821ab4c31eed28b582498f27c0d5f47ee377aee37be16eab0e5e0e5cb9b10e95a55db5757266fb9e768dbd3ec50efdc4999878f959006084f7e81d12d7f807f1823a7ba4fbbe5ac6ec59b10f924b3ff01eeabdbdc17c75136d85c5a4b94ebf458d57d2b7ae281694e9c53b46b5bd880fe2924131b078ee9eb478a5d16e9e9dbaaebbc51e9ea7dae767ec7ecffdf06c5d183970971b9ce0cacbc970fcf910d5c499744173292d7da9906e38ef6c61906ed8e1e6b839bb7a5b2e9183f21772ffe6658fd9a64d2b22d5d1f46860acb1f270154b29752c46f690e6f0ff7083d81d120f022efc6faa762e7cca9b9c6f07f0fad896553189ec96dfdd88522929f81b0348038ae68208d0ad30c8ebe3d8be444f653268a20f907fde56b8830b73221f66fe27f29c114b8dcbf80a8788acb2c304c6cb9063733c9d2b31b17be4c6cf144f930d83c874b081248a781c25f12db4ff72895dcc3f5edce9be0fb0fed73c401d55c096f355257c537107999e253f7ad517d429772f43e2d8dc9781bdcd3c3577ff8a74681db867dad8ed67b2da8a64b6bda9e424f4b70ff722a992cadca8f57e9b036345d0a6aabb542b613aff4c41fa307b5c801949b8e77ff97e9f7ee4183bb199275701fe08a6a3faf54b547a6637644216da4024e54a6dd8dbbff6a3f72c428e9d2e6a3606afc0965382f20b16028549bab94a4afceb7495090fe1f2134f1937cf2f5a7a13a136a128a321f15f7894205c5b4d9a01ed873ee81484d71114a65b08e8fcb689908563cbb6700f3389912024b7ece10da932818cf612820e2d9f42752f6a504e06368511b18a06925cfde730dd4ea446de49434c8cc480268e6b80d249a835671c0930f125bb6b4cfc97ddfb7b1c67baa3c257eca0e53558ab480339416acc59b50798f6d0bd1b01ed799a37d1fcfe363b3f336f14e6a19d1063575003895f1510b4ef6d164e74963e502d99844077ed79e3cb2e6cfe3ac4213fecd7282e8a5863d31ebd49e232048fc9e00068bc0224a6fc2ca0d36e21fb2914110a8f7a5f8c8dd8ce54723e677c1385b7f1e29eb38b564335e8d2b5d07d99aca25b878841ea35f81e3b88234507517415c849a6324842fdec2b08d03ffe68567a15127c024a65ac61e4376473fda8f5baf8118efc50a88746ce55556667294f2f4fb3dc69c8dbe1525e5ea108572b24388e8d1078bde144ebd4c28e18681e41f3c6974028682ed96514eccd5ee2e0a861e5c6019cf62e620b5e7d7732bff9dde14aa80518a443f0086e7e06db053a33e1269785507e020c377af8badddeb07779868cd44ca3166286b35593362c58ea1a875932eecb51195862a8924e5395ab7fbb8f8e100b1e6d245af125fbaa0ea5a60cef3021b1fa15a887cfc2a14a102975b08a77c9d3fbea1dd1178a8c8a749998b71a238be570d44c40fef74412af280f33e5bcab46635bb98836ae22518d956c8a5c7d18741393fd4a4593da5e86b1f37005b5d67d203230b21ef73ccc1fe7e8c8e699e8ed610c39277e6e8565cb3b916620407bafc957a5c30d23ace8f4752fed5f6c06dac4f118d0fb1efa696d54d9774dae87b06267645ac198daa6c656e72d0e3c97d40bd0b25c34d8879709b50941836a67d2c4091d1d4c3a437e94444de24783a6060da8dbfa6f48b7e0cf3233f9c802d49257d5c21e0876a31f2916c5ff01352177b95c09ec8e63e1685d3213cd1b744f1818fa268e777f218a20bbd5e437c1d82b214e7856b600580e6dda8662c39527277232302c1f2e11e4698e853ec02eec9f77fbf4e50bb75f80bbad0e58dbf01bd72de8a4101224edd058806821e388bac5510a10abef285c47dcc78bdb47a6a65cf692c71d8656f1a87e69a4d4de83d27755e430b75b9b0dfcb49d439d2581f006c45ba26813cb499abda8c9f768c0ec90767ff79219c6d7e1367a3d1ee97078f6f77a3f94b97b85a2b1d95e1cbec3310d554fc4c699cf50f9f9090c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
