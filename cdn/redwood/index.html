<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb60a911d2a34931284530c077de8386dbd9e97f6bcd5e38ae75c12059c0fff9ea10c3f00edb963e3119746bd3aacae02c0ba1471cfc0ce0ad4a46d78fe488cc9725c9d697e47ff7cfac99bb03f5f669b41a99917e30226b1bbfce846e7cdef153c1deca14fec96d0adfd4b9e09c8da6b3dc7d096a2fad903700c7059f2f824460a2924151e4c587e0a15a68d251946042470c820d129f9980605c70461669fd7bccc30d43a1ea7edb35a1a160fca7e965f2dbbbbafca3a80f92bfe39ec44744d209b31f39adeed4ca3f63a940dea7ce55179443cf735faf4c076260209b17fa318656a4d794e02d81b4a4aea17a3516b56158c91abd7e2c3e2f6095eae0207efbee9a99139b553c63f58e3de214dbd4246ecce0c21148ee9cdce27c0564f81843936b136736c9e5c1003d2258de59037ce1a49410800094f8a5ab641619bc9fd88c3d6c681c8d951331dcc82445cf0ad6a76bc4d6cab5a87679238e21b62e0acc8e224b1e1c7c794422592607c5a845ec168224595b13d21cc7ff5acf9ce8acb988a8c34e0d8e60f22e08aecfd05ddb7920b8db5414912a15378763bda87167cee0146fb49b0da35414eeef7be4dc0307ecdb893a2c00a9f9d00701fb068152b0fcf4daf8816eab23ea8a0ed23affd64e1c547354a9626b47c6a2682d6ac1a6e5ca25e5df6107872b772d1a6be35ac773094eb12b77b2e317adbab4435ee7d289ba80330f4a4bc8439f4bf1e803208bdd0838add3d79569b25c20ef93f045bfff82be58ac18556a57b5ed45b836fb9cd29fac3733c7bcea81de18348a630ba3b6c4d45730ec67abccb485257e01c11faacd3cd3d646fbbde05a63d4c3b7d353f6ce5b546de76a99855c3494f98d505846dd6d726983eecd64f962f51626d7e7329fdb2a834745b8ea775af54e97288ad3d6808c6db4e48666921d56f316be828322215545a1fdb9e253ea90ce31128cabb2c35b428cce1f42c73adfebe8e6b3eba470fd72ea5dad749d94180a758b1a5c98a48c792ea3d359c1ae3b18bc60e5ff7d644aa00adc716e2b7fc5d47a006bb8e3da1f3e59f84f937f29fc7863de817b733e5ca251dfe7df062941db79dff207502ff6ba2df859b24112b783fb7529c2b39d3e6290ad371e05401a63763a2dd2d9bf8292fe205816781b2cd20d3d8e597adf64858e50d6a0099e67ba84fd25d2d698315ee123f6677711a21697c72f50f647f008b2912a08c380685bfd869f24e18d224eddb3859ba09b99a7185a44d4e69f1a94827bc915344447b5787851d7941310ddc511224d8c6689fac1718b881e3616589e532ca76a96680ace7cfcb30b5a15f46213fa267718196be39419a5653497c958029dd6dd4275b3d3cf40d3bfd81e51e83e91a819375833edd605ae8c83942f24bad1df51b59cac5af723fdf274d67027d0c742ca7fb243fc0b41071e67a4a9a91d7a2544b92504a536abb15e996c43c8de1bba53e0da4481156366e3da945c04111921617e9c25deee71d8c5924c211466d854654f5ed6510ff934ba3ce923db3a0c801b1a2729ede55bb9171cf7924354409f3b3a36f40d66336f9ef5f9917824f44f6c2aa2bf6f3becaeae9efbfe17183f0545f83ea00fd5f42f11c7f246869e14560a25fe4d98e84ab2a1a15bef6689d65675d44c2f1ef58cbb2dd3a59749d81968d16a5005f1fb718e588b8eda9a5fe51bf3d03403dacd4081d3d65c51099a82961ba54259240f274d16d7b2ab4dca9cb152073823b709626ed48c59b23409507c7b83bd5fbac85403e5042759b8702d9da1935adf8d0f2d06ace39c124c780ec00a0c50b9042b0a010f5f600f462a5600db6ee2fe755294a52fed459a7f745c40f34e64769fe19549caf8a576d143320ac5beac49ee7fe349e1d6f283324ca2c8edfa99678a8d05705a226d1acc0ff8f0bc7058b9bafbd86d7880c1eabe9d20b492cf7e1935399fcce44f3e0963344847cec7f9e4360a2eea71a35c9a388be946478d178410ecb6ae39efa80564187e640193c4ddc47c8e48554ecaa75a0de440f8e7ab346bc8d2be39e3c8385814764e7da8dfcb12eb0b0c7ceff81c070497654fe1b816accb6146a14185b0520129df00b5129e202ee5763741fcd1f6c683c3fe4f87b3c5f4727e2682ef56b8d3aba791b1974849028e49989f43175938048d3c872ad1fe1996024f9649590cf886f027ee728792f9eed03161eda5433fbfe9741d05577841497fcfbaf9b1bca64172e2ebd7d4fa0e7d9c797f5115aed53504ac2392d56ff4c8257c730e9007a1e7d657da9c0774c92a2feae2177581e333e0293950fe361f1572170fa687b2fc9944fa4e853aa14ca5ceb4fbbdc2ef0c9bb3d6fd8617db7a50f75c2c97d3af84e9819877789b6bc47a59639db00d2188f288472b7c35d521c87aa26312466348cb373b2f109cd52d37a69f6d49e63ab07b124c976d4858b1e835f261edeac3e5cd3f7bd96521027477df65237a83272ae06d348ada4cffce63ff1feaea25639761f9dfbd511f211563848bea07ca1a56a721d89e0532aa1141e67777cce69a5b29bd0c1d1f01449b38a205df2a458145bf784aea917fd5cdf553c359298078ff466d13fdc34035ccde2446283ffe90f913680ba28d18548fc4c832c40a3b318f1328811a4789db9c91c604f0b32a3416ef5873001498ba4e3a710ac1cf913557c29d3d102d711033c597d6ba3d9a6342599c03c14802c8e82673cee14c6687039f724e27dc96915edb66e7bcee8e3ffd94ed283c48b5fc99056db794a7011a8a05e2149a67b9ca82eb73c941c2383f8b91cc40181ab7f4d209daee9f4566202770b210cbab4141854bad31ec805484965b70f5f979dd3f520aaced6c465ff9f2b0427576b15d79ae36f3ce7b2aafba66acc971d7b96bc2cd960ce42f4b8bdb73bc9072cd3f3977b02e2d5bd863332c2a919bb6a758db10f219ae11513ab8e96f26a5990cd03dcbb87cae8f8b511f8ad013a3d2194c5a031121364c093181e0afecc760adcf8493a1945ee4a65f7ee3e8b3d07d884b41bbb4b54208fcddfc625eeeb98ada9f1a12d30c1754d1463eb3182960b7ed699e7abac8d7007f1154a6be1a8f166caabef6b36957ea6f69353740e3a1b88758aa28b6048cf81b8b56454f68fb5e2247e809e29b9c970581f8aab17f48719d12e2aef5734e7b938acbea1d14bbf1209290ab76e9a166d42e4ba1c689e2e01d833c03b6ade3623e71c93d6498a7e4268cecf6dfe8ae5cbc56928257275225097d90cbb97f7c2d167d4ca6b7f7c2ded293d8a7717aa321c28e8e76a4c555e014f47473f2603d9c062e8e114a7da87a427007d394fd196f3455dfaec70a18212199d7aab2e63f4df6584f022c0a2358a2334567c799302bfce45af251f589634745aa0433fba067d2683708ddc7b55d7db778ac039fb8a9d6dc13fcf6b1423d1240f43da226f708a85859c0aa9a404100757a28c5350a8c2145642b0d33ba5a06dc5fc2b3b4be30590a693ccf26a6b60dde394653d70cd7d4ffde2cfddc44d332ddf7068b77a9b99f4d2f90d323bfacaf83c88fc70ac4b3a0dba4121dc25956d717cad6d4caa0f5a44dc75ddb8ca17940e5aafa103f8f2623b1f8be4c9b727aacb89a181fe616a60254c41ec3f4c9756a211913dcbd1e4937f5ac40b28cd4d1ae54578756aa0109b68c5e205e37bbcaecc27b8f3ee145ce17b04a98bca8bdb782c25e17964e87f919e3c1852002e0cc118db96187482036f137b84dc5d9b18d9ed25f5be04d96d10baf4607f2919dc9b13ba5306a5037005f9b5ade2a2c89af73d16b38b34e05dc94d9f14d2bc4b8a6d93998978a3fb41b5b6877e1696803da3abde0d1aa2f2beb7fb2da060a9830dd476d5a464b14a320191906f2fece1adad669d47fdfc5713d17e5075a60eecb8d99ca5f9283ee4fea0c0c6acc58bd159fa85fed7371be7ab6d33a4dfd702dd0964c5f6b4c633c5bdf630fd4ee0be08d7d393ee34aa9b1ea4e59d941d20c9789bcbdb8a05f1266bd89d874f20a0ab934ea59d3c7ef651bd4807a69cafa138bb4542851f84554f439f09459431e92e3667503156f117ed2d8eec4db8cb71b48bbf2d7d4f034589d71aec9a15b6672b28554690ff392953ef60ab48567114909994b4fadf17399a7e8eb17091e2d3a142b3b07105983cb25e5184b414be541bdfafb505a1f74c8095a304cc9362ffdedb1ed23b1cb79bf3e1720d618bbacf517100d5592983978e30b694cab66e4b7850d1ebc05f34b7c4db26ed86902a8a5c6d035cd6e2e1247780c4d32a7cc2d83bcead00ecf4d0fd88ce310b6a109653f11716c272d3be08876f762617c2e0ae2156b36330d777b65cba48eb3af7c86ca79ac28b89202e9040bd76d3a035e39f8867a911a89e7d10afe0a9906cc9ddd101d2417ac23d9cc3789e9fd176d137619b8cd9f1abfd2b259363605440fa2074452a29e473c2262a8287725be4894a9fbee18c493a7586c6d5a13c645300ced7b21579f1a25338176782e753ca5f12c33eb189496a7413fe75e9f9918fe8d560efedc667c177d203656b918ce9bf7c6dfa50867137401a161ebecabeb1c2c775d40a8314ce415cd6da92ec0ab6a8ecb78d1ead0487119f3df28b365bd41e24b072eb254efe81c4ad8ba37d1fe8140a562ab271347024d6bec6c195f238f86a9ba5a147bf62a43a4198f8140cf79c74012a4b0ed39c563da7783055a47666dbc92706f62e78919988b67ee93721476f5562f73a874356c75eb54a5f53cdd8790bbdc7893e89503650c2a9daf124d4ed4193b7e89e41f5598102afdbbc5737de1b90182b9691da44e8fc4ccebfe71be25f8003a7a67d970a6274f463d1ae0ffb1b61374659f6cec7ad19e33f0e79e0aa2759835aca820916edd0efec3ed17e138344ae507f04b1fa83929036b9fc50ca73cf01bdfd98a8c0aa6e81f59ed3686f75788cef1e41fc5fee5efec3cfd6554d88bebe02964a777ab046783a94c9f813016cef6e37a5e6c637ac3a0fd9d4c8de8da71e0a4620c1d3b190535a55ca9f82ab9eaee11b1050d2b420b1ece27a6ebfaf475f40244e685d62b48bab315099578535178f4c6794e8d4df47cf5be39975e9838d1fa69c22f5362fae00117b544872c36c33a308c620c05e3e3dc6badd530eb3102683217c14e4f5964ebb7679ad152c54579688cbadee18637ca32ea4421194b52abe9d8730e657389a9c756c001742149838aac561caac179b4daf6474925445afb9b66b6791c705eb878c265b4c0e12fd62ae3aae4c817ec464231d7ba4a506a2eb80dbe7770d01e8a40c16c68929c1b224bf9750342b13d06c915c37b1d1eeabab7df23eff267f1aaba77acda0bbe03cfba82b7621ee53527acdc4b55bc2f5873b3b70ae513d79505ab6c07a06d24c7c8766712c69a097bd6220ce5886fbeea4e508601919243efec6d19f3241b7f1fecf2382cecc4952deeba0049194e4dc5e643851eb959e46e74140cf0170e5337f9db223ae9861a61d0f1160ba8fa0bccb96009d6e589c83c161f9918b35fef74bb835ab7f6cf52e5d49e81e17b611075055f0363c23eddfc9f1518a4a77b44b3508c85f6a6522646fa1f504bed90f43c01318f6e273597c9280aae4e186dddb6b1ad63846c95844372a1d324a552d2d888ca18d673370e6bce2210203b199c4ebe0db4bf8c1c629b04a444340da6bdb122c106fe902028bc0b8e3adef307bf6cfa3e6c7e2c54f10021367ab4c790307b8d041cf74e6cd91472829fc08d338a2378b80aaee6cd6a5e9d05f23224986c9fe34d18478c824914d7e3360833ecbe3bcd3f94044fcb139541a88cebe0be1151087ab8a97d7bb7d1613ba6c903db74f6080f28df8f8ea358c048789661ef44b5ff6f150cd2388b6518e56ff3955a681916fd307d7a809795dd9bab48187f385e3842887c410e922749bfa2752ecd89130242b8a997e61a19c36fe246b19d2b9e6969c243ac6e10029c0ae7191d35c510fcf20b2b419fed78683959d4d859d3b21c0288a3bac3ad99669fe6f7e04ba96f719d39a90a0afb89b2306edd64652d500619b7ce125694c9b1a6571ffc44c4b575ad8c9d288780c264ef708e3645a71d04f88c44c4afd32cee5f5f1027f2e41c36ea68b7420104e50a9e5a94b026fbc1ed28fd8694a9e1fd9cb3e4d9645bba878e882ead66cbdcc413b72800284e434b2a170572e2d072a4141cfdd519af60f48d50d1b082420dd1f2da25430cdaf4d44fe9e273851e96fd04099027ce3e100b00cfef07833b996fd4cd09ad6cc8b1d7f84063a96acc59d3df8f750c5e2690d85c0d338576d65b57f0950ab857ed129545cc85f2002439ce6bc9e276053faa1f251e8353f9cbbc9a032ffe28737a23202d15771231a672fcdbc59e5371e2945095a1411c36951349036745cd6afc94558f0dde05442e9b9cc68053f315cda20eac8be12143f56ea09605d1f2357fa02dd2b2df68d45f5130449031640f5ce522a7f1d065751f23d4da185979dde0d87faade5662ce0ea7574a23c51665b5ed32e27a5f1567296c0e40beb5fda930b60944ab0ba720adccc24c413ec3178501307b031f70b47193474d154a598c3017e265822453f4a5625f6889c37c7f5433265f85042caaf720fd37e217a4609bfe7102858bd30c0bb7a2a712cfe4f9d5859e345d2009d56e4222ec8dacd32f52575a95eaf0b92b51637eacc85cbeb7475301c3ec819eeb2088ccec83545c8e878128d7dc9fcbefe38ff4bd11ccce2dabc4d416d4cdf77223a2a70f634376b1416658856799a2b8f1db23027f55033ae602fc7c824ff48cceb1fb4aae10ee9d68e9309b51405b58d3b8bce46db8957b613bdd4bb2e63940ea67f89ebca6fa8f9a553a12349171d7271d2113339522cc32bcccf37c926561c0eea8719662564960ed7eb6441775f3f3dbfa13c40b4dadd54d90129e61ffc3d9de63f09809324cf39882e2e0917a8703947dd33f51cdd84c197ce0f48870e88661a18a4765a9918515c00fc5941b020300b2ffd4476cd9cd4a3511f6343b42e0e6c9a5135a255241d7c0c5501f205a7e18b2f96c4af6ef528c4220f39fc423d9eef2cf3168cf5a3fcf1bc682d1f1f6a9ed6e0dce32598873c2c86164fd4e5f0201ba848b9b9d8910c32ece421300c9ea126095477bae56fd058f98e55574122bbb1fb9b0178d1a64cde55f26817a20973ecc1dc7eaf3960f7026ce4c0e50aa94f61653536ac37d3d050ac25a1822720812507d1bf3bd36d0a4fc8f6dc77eacb3c764d1634d931df5dc1b6242e70091ebadc2f0d3bef2d64998cfcaa033d297d47e2be19a88fa933e3a21e5e28941d674ec4ca6b42a19342cfa78f13cd7740605286fa633ca0a7657cb715c9dd90241050b3cea3b486d0c70a68959cbe1be4575e9a503747bb0f37fcfdd4dcdaeb422e02c97f6eda00bb13fca2602be658b867002ba147523f464a572c199a168152ce385c779ca2846f9bd86aabf2e1254723f158e35e544d8f3caf7ae906b92a8de461f7aff4254654d639b5f697fa3045c984d00049bb11c8d4629af8c52d77b60b613c0c35bb0460fe5c3a93d03f5414db01ae2e43b60825582dee0b34e1fa8b2b816c28e3504be67432c3ef809f993ae03075a0af275a58291f9464132acc962385ab2932b5315b1622871b1fc3d7d698d826602f2902e317ec135b6db1cfef8d1536f3ad7c9e527504d5e7fcac5b96301bd7789d5d21bd744cf36bd773117144a76176229d57e1e36863e1b65e1d0c71593bdc180d77527ab68a685673d4e05c6be34148733fa68a0a4981529e172cc3c9e70648606c25d8a2a81cc64dab261c9cd06c15647ee841f2d562ba967eef0a1019eb76e823d9d2feeafed0f59a049ba072581a0e6e998f10944cdc5d9d7e4f171b431f657f9e2ca3fcd5ee9cb1c8244f166d7f666c85e77fb8bf512c45c4ca598747e90054f1c3145049ab047e05fb98964aca2d22b6126ebc60b85b6e6f3b20f5e168b735ce4a5c05e28d7e4233204cc5243d40ba06c6ecff14ae96853dd7daf3ef30593f5a9bd30ae66ba0a5e0cb22049d448795a7d39987c031776dc00ad1961de27a5e256dd97fae8a2ad191a8392b626ba3e83ac74901652a599f0c0bd864e2b443f3806b18d97fed0708337b692c646edbcbf02a8eb542434fa7b3b580d97d374f284c6f4629679ca7250603c22be855918a5c3e1a9c6db10b8ec68a49e8370398ffd178858b4ef3c80c0a5f051c228fa1065cd961293b78b15793394b31d0117a662f46129080fa5f5795cd94bbcc91d59519c7588b5e717fa874eeebe9323fbc420e90c307c0d3739939ff0f5f59da811fccdb168fe3d4d1b6f37dcfdc6ef0cc56980efab1e694dfdc8f869b6a0929e0e4b7fff7b5aa9b78b3c62e191d62608d904365566e561a36904e72a76554f8bc08da793092df35cb23e9e31b29853c2df2be1135290d8fe12e78dfde104dccf3a6e4592655c5a91ffff1abaf500f572d3e0efda1f62b2c61f7de4dad1232cb9110f18db9a8b2c12200a8b9880ba5e991fb799bd794ebfa7447ac4818eb7ece58b152b4412348ce0fc123bb9ac0478f491f44edb38c7cef873013eef4abf1f101f4419dcbf93a5e88a160ca537f00725485a97a5b254c0e9a9841eeb93ee302e1eb46979b05947589ae852e3ff9da5bba3767ab5518a13afeb678f5042eb02617da794413bd413e64983983e5455f7ed42cc8e1f44d4e25d3ba7de84b40cc8011f8176c5839841af3e364bb36b66eca83f574b221ce0007a5a4d39dfa956a2e28f692704833c5dc3c0710e367243765cf2dcf0ef6cd1ad758dfdc2c20d6458ae4569497eb28041353486eb5c7278dcb1b15b83af392bb328d0612a1de3eda2b08aa219903749f7c23851208bf5798c6e1f7cb3dad4b064751d69b6a32573cd13476c3058d78f21f3df71c81372324a21eafd38666f13ebb5f49221b8a8b48cca5cd83b03e6f8afa6386ebf89c2f73e5cc0c984981a96be75f668c6b1b2e017cd9fd7859764c1f34c48f104105c0a1ea07a1fe8e898cf215d2c572ffb71e4b8222d8e2ce4d942a9d4aa4a2637c1b5299c54b9b95b4e441bf5960ade85f24856f0238dc8143c1048ad317e27278d2a162167c9c9a3ba61a5c1e2303b1338a31b17267a143e097d6cb38434ad833d5c7d9174f327c0de0a875cc9bba95b60f11770e82c98a640807eca54de9ee2aa336fa3bed46ea98db3e65ac47e40645eabde9cdd01ce41452acaedbba4e6791c613517e849877302dc1ac7759ee58c84fa836cc67beae918c168f3812328f146173b5382c338de22dec0fbadf8a2f08ba09441ee3b799e82ac1b00dc254f48abc1f682ba61e6a83ac5b41fbd6c8d34beba7e796cdc8f9fd13196490bfee4e2161e850383a128ff8d781fb282b836b67e8285be43f00d675c784819a01b162124640e00c1402a96c66da8b3719861c00df55b980863dc17eb746e531e0829df1b82382be7c43d69c2fd9482a1757af7aacf8b657d34c9da72edf2c1184d7a3d790e916d366c5f309b9843bd38df6577690ae6303ce8fcff35c3e0091f3a57ac81fb4a46f2179921c859eec5254174995e69652e1f4bd2b54848e93c15575828204be88bd55dd0305fad2a0484ec49e14e0889d9f90c9c32e4bc9356180ad48f3e76c8ac8eb81e1254322028607f8ac2777212e096228ec2b350f59382e12a73e95a6aeea0985e1e7fe9d7464bf566b830ca291bef3e3f5941566b15b756aaa9778d405721260131f006e7668bd86561ebe5214aaab64e486dbff1ed38431c3c670f45f58804dfa26c6014056cbe8f386c1bd1783ceeecb5ae13593bc12eef83f8193a968f054a6ab4517bed01dd9e6b836cd7e30f298570f55b921369f3dad0f0220f176cb38b7a7da529b577b4ba15d411ec086f5933535d812f3a5b383a98258b9294076d8683adebb2374a370ff9fde935f9441f0cd34e1579e7016c69033cedfd4d1e187eb2d198b56dc1a91cc8647efbf6b01ef71a631160e930523a0d47d55e22af66517da2c2d61048aa29d9ba452caae18512dadbf344ecb7017960e09887edd483d6c9cb0861fad02856ddd6f8d26d2dc694ea403a724f66191f222d9d61408df71a18fbb1387f384116d8fd898c4b1fefb34d3522043cecdc4699a3db5533c977398584c69c1d5775f3b1ae64fb9e92e48642322a25406d07e7609c0e7e1c1cdd9ebffb1b63d3be89f6516830d45b7f915a4fccc270ae820db9b227a0953ab6974f4c62feee3b76928070f8b0105084fd9bdedc1f50ab337aa4686f4583a86994bc4b594aa6982262cae8c95ea83f3afe44e94999e26e2c63c465d0bd9ed1bfbdc4dc7799ee266570c27198514d5d66b81f644f8938977703d12d6ffd2fe4a93e27fb03cfedbf5234960a5ef38408837658c4f9ae2a7d8b62dd34c6ea29907aef1da769dfb3b4fd750f27d31f9e500ed6e3f2515c8687e6b3ad1c7dac607349d8ff41244d181ea9bce665093dfc1c60dd6485aeddcb29598dc41441ab0ead7397b6599a770be28c27f8a0bb4bf617c4c3e25ec3daba803ef0a5e5fa66865a1e8cf648edb5e4cf049a0735274e8c790690026fb2fa847dbbef3cef31469efd5a21994de9198138164c963ddae827d4d6bc10aa22d5b8bec6956b3910bb5d51ef6c4db2fe8aaa27d44e342aafcb2f924c1f86042fa9b0fcc4d0e0b0f8ad33de3f94311eb9a610608f1a793f7454cbcfdd0e4cd848e269496c0a8e65d089ba08a62eb31c9693919ee236e9ebd80e9943539da50f04ad2b3406db083fe4d1f570a18973a4c7022f638f548c2ffde697171723d0dbcb9cae6ecb65e18f7943cef85be8f20455cf0658ee64b940da72c467b8ba6a467ee4862b05d12a1c0493ec074738fea29e32d94881a85d49c129a06d2dfd1c91055f9ee729b1cd59cfb675cd9cf5e6e0f38afdfcb0dd0ddf58df2a7006e35243c76086fa95b375d2164f298fdeee38faec2ad2967b671504ed6259805936a6e1cbfc0c6f484a80e24a6f0685ff0dcb3cc02a4e55a3cc77d73b300bb4cbe6ff64f327bae71cf5ed2b4365a99e1263dae8ed5f0e54aefc6dafbdcf1a0566f4991cbee33d4a41d97265ea5158adbf415e3fcc366ecbed1d0383937cfe17c5ad719d0451d2d51fb93e7d504c3d5896c514b6f58bf1828418de04cbf47346da1329c19c9fd482cce9629481d9f3fd76e9c9bdeb10319822a8c4fb8bb468305f1dfb08d1aa673fbc70c9c79411677866cb6653b97d2681f16ff040dc617f5cd68e7903a29f47ef31643e02854787b9a1f84d4244fb6b3196a19521b9b193482607e7c8a686fcbfafe9da1759cd6afd9f80a042ee247bca7191da14fe11247bab89e815439b74ea102546c694d7b033416fdb78677912d1f76231b75214dea0b565b0155b0611e1a831a97734e2b0eeac3d82044d30f51c7c46e525ecbbdcd0258fc77b24e8001ade871d95ff2b23dec0a11602f13d02432f636b610c13e6df6ef5f5dfcce0097b282667f8149d3342fabc0c9b2bf322366fd1f2778b6d506b419f67b222bd9d0c3873ab0f8376c07f637fa1752d54ba99a2d8937c525ba3711bdb629c96fbb1b6ebec93ef9c47d99b5e2ef1cca2fcf25aba9d04b589e529f743be63418773ee82d7bdbb1ed6d7fad367cc9395d3bec91809f0eabd295e9e6749f1b8d29aa8d278eeb4b3f48f1d7e87e629e1c746fe1525f4e09bf38db9a30e41798e6fb2773a8de4ead966be3172554d7ba13497da30f324fe75a01b1793a49e9e7fb2810c8bf6aeaa2f513a204164edb383b996d33dfe2af711c7cdd518276bd2cb127fd2fe8443da97d9555b6bf0e06f06c673c16402c2f8e20699c36840bdbb8b9d90dc840e56e9dafcc309f5bc6d66e19733bba6e69ddc0cb613a93fea43077bb6d8a24fa4622d9c015eacac64240cf67c81d8835ebc6a11e06b3fd02c4c344897adf336c07b05242f65c21eb9a2b9a05dc1829a0ee6b99359edcc4d4314fdcb385c4bd0c7fc82a43374b8098d8b287ff75e372962eb83b1e3384502b1d3de38f97f67f987a031c3432122887131c110f75a05daa384aa3e62ca0f81f71de5d7c1e841f1a3877db9f4069b536241b98f67b1a1933882519c01076acf664edf62a66229b269f13f46979eb43a7df4bbf5866e4bfd1fe2005566bb55096c8f7d0b371fedc638011701a4933d5cee08c05d58b05147e51c44ebf3b266e7e6134072497e10c7d1795cd260e8aa5d498bbc8193cd4edb8b6188706a1472c38a7b5fb6d24c264433ff8a3cda7708ab8568d04e6a6d18a1ff57281c13d56a460c49632f21efe86589de860c33d6232ccea33220c5fbe940376111c3d0972339dd62b249738b8aea7a1bcaa17be7b8a8b5563af60687af9484d105ba9c09042852244c2b13dfaaf5021b534b96984729e0b779c42f8aa2d13294c97aa05e865803b17a06042c05d524c4ab08ac9d240afaf6114317c04bffb83e1acc493542809f300b14f80223b8a957850fad373438ef0a541a815b2b19a6e6e98e79016e25be8025c4b80f3b5828cae8a5b229eca45e930c035c65c1150671f754e3c25fbdccf9eb2dfbc9d7d08e79a9b85256b414c13982c7cea9a610e2e4bd832c54144ff8ff97ac27da6d3a83604f7144f2cfd16ef4cb6ea455f1e987821784622e2af381f466f998da75ef89dcc1edaa1c6d7b7f29e18bce0f6ca79e626f870212bb2dac2a9e18b9417189945e76b07cc1d664f14464173bafc21b483a40dcf04af499296fb7f8060b5f2b3545e3266b9cd2918871f853a2a6ee5f23c553775b89d90ab53ada07dde2e9bdd93ab032cfe4163c42a783f2cf3f8201f52b6779f23f96608e4cd7d4c3bce918f875f3b5602be3f9a038dba6aeb36ba8f205190a08abd8f0a285c014ee66c2c62dec1b8eb5da1045a81e09809b552a5226732042f1e4649a3ccf31e5d31fbc60bbfa1bbf063aaecad1ba535d4ce1f69dcaa33f4bebefd8a581f31ba14f15b9d9c3698ca3c2992f9391d4f5fb781d90bbdb944b0424dd7532e35b3b3088128eb23b9f8156e6a0f1c8057efb6f74f30cd82398d96b5ffe76066d68166820939afada4653ecff711cb87e6581b5a5d31653be33d9540bc5d95c80b334afe2704eae5436507f7d8b32b729ea0689a068aeb5aad5a2d08400c155796f823ba6cab9ca40583cbec0f927d63f0d69bf3863bb175069d56ed71c07f2742dfa04aa6575f80674100554ff15b060cd30c63922e561bf077511c16110853fce08caf993536244e9f68a234588a4cd04e382141631b021a5ff4c61f6cb9e5bf848daf258b45af246e6a3057afe18a48a3b8ad4a153c3c97b09b766468a2e0c43ac8e7dc8f57c7bec83e8c2ac9973b425f7e9869b3b479c038845fd0fadccce3bd207ba49b806f0359d32245c8188594153fc71fa5d5e98fb43a62b3133dd18b782c066a0a9d789431de55c5328210f30b2097304bce199cb017f4dc0eaa2497f20d084c19116ef8eba1190f353cb4e4a98518548a8b576317d6d96945e542c205e68e6b4b19ef4560f084899b68c2115fc73aab88dbb995eca7fe96c2ef34c4440646df5a7d7369a4aa82ba70a7fda3bb8e1f274c3ceb3494512feed78f949cb89d13208c66c11346d2e2d564265b68a7ad8bfec02a3036ac5177c6bfde0ad3c546a6b1d4eeefc387d3b982684935b49c387855ec66eee76d85b5ea11eeca2095dbdbcec63fed0f770b0f2b298a062e62c5898aaebcd9febcfdced847e6b6fda26d954f3a52d7855cc4fb961362f5da598b3cb79a3291c29413d540d6808a838254e71ec69d6cf3619d036a9fdf18ace9744d08f509caac8633800afb6edf0ab08ae4995f366193906a5bc201e29a246b1ac58d83ae529c2fb6dd2a3d6db57d28ac74c9e5ebd6cf43dd7148c854afb57bb907e8e41b35cd08d6c13d9af6a5140f8081f6387c09f38c55c5ee20e706216c7cf5fd5ccf757d27bff857d6f83f4d5099a8d555d8bc4c6d600b19d8db3d7fd7eb597a1c66100ab79d865c5bef7066a869a5f9e46b915845235638895b238618cac5eb0e21fdc808bab268808f860fa0b9e474bd6ae64a9927c5b5ce9028f706598b50d25cf3892f9d257331478d43148cc9fbf1d02adb807e5bee610a8727a5dbe965781e9e019528bbd8c2e31a80f3a32a2cfbeb21493875be8f5c2e01424ccdb36689b6e28333341501e6ad29178db15c4d1c8666051283a3966a803ec0425dd80ac9920b8138304902d4b069f02014a6cd22135ba2d1aea10f1072a75f789fe9ebec4d17b5009dfbd5790842f26a208d53d3d2fa24cf85bf6f36da6aa8d33c5bf3ef7de97614e0474d70819dbeef5964087a5c5dca7a53519efcf474d86b450fabced3c7ad68088c5f20002b7bbcf34691e36af476605afec311551345342d8129dcbece68aa2b7ed1922ad71be5af5e9be53fa824def468a99fa89d07449e46fd8b90a87cd2d556a6fc26ede56c5d647718cff1aa7a7beb046c717650ac2dac159ed028f78f57bcb835326c2aac02030af8280d70a199e9f0cdf5407e5740c287c8594070caeabef3dd3effd8c7f5494ce4435d1adab02fe8ce683e2ae59c6b71e1b86f177a3289a68f259e39a3a381ea9d5a49771a61914eb690fa69e3b5223c6f1a985effeae20e80761c1e100542826d967c2157970adfd49351f6a2b1446d744f99d6e86f43bc797748a4ddc0db202d7d1db8ca24464416606172708ef9c1754e31eb8b0044f1725acdb9f0ce820c4cb078873c71399c411f8d1012ad1c96fa0abe42b9ba150b711b72d44b444514f4d9eaa624b8af510b8bfec9c9b689b40b2c5de70f56684549507da281575ed80eef4059c10c3b994e8c639884f03e31eedada06097136eb175be9cb248ec123e0b060cdbe5658e1736d93f6bbb1f326deadfd2c8aaff84af02a91a0e474b177a88f6dd2fa5eaaedb5db8d19f122f1d734333608befee3a32ebea14b48e5dabd87d848653a902ba321cd61675f119c6f4bca4175cb73add632ae09d9bf500cf292e20b68cddefd13219ee08eb3d9a50b5945ecb29d01946ccfb05260a01870ae5a2f3bda841ea3590e327acda27878eb488017a07badd82905411f0618d8923936139ae50efd5837f3a82f7158048cd9e2caa0a43c6327fbb9cf97ceae0aeb01717f1fbd1d4a006a57a33a26334706a6229ee572a3581572df2320151e5c3774d7db7492fc34bdac1144d8945f774a76f0bdffacfdae26a820d17dd08b837573c74c41824c96eb6d299e867daaabbca033a1031d2829ab54ae15ed4115507b15c316307d92b9ad4b872ffff97068aad0c04d262e9ebcd0f801cd82c6532d9a451fd72ff2572e0dbc5605052c0363d123e667ca995e3d082fae6e80d212c04de0f453ab2a151e7376cb0dc012c6a01fa4168a6a2c9f5f559a534fe77edba874d55b60ce321282661b8c1bb8db06b6f08722f07dbafd08a0f97a7de56b9e98111b7b219d7e07f5a5b66bd4e007f06318224f5b53de4713354617a41127a42507553d2ad55e19b17d1645c08962154e992e58b919a61e91bf673e5c4ea82b21f7afb41c435ce8a173789200d7fd659482601a23d94aeca0f1d8bc2de8fdeefeaa6728a6dfa7a4c592fe696cdaa233e0ae7298ce31d7b6927dae4910c456df79108c8a0624f7edb06e3bf3af8170eda65f0e3877db64d93996463b989ec6f5205454428e2762008c3e7a8bfa6217f0cea996dd4a4fa06f04122de4a4fb15e49eae7376d0bb60d7415acda44a4a9df7c1c98094beb79daded08385bb588be85a5a26ecc7d5301700d8209f93fc287449da2429efbc09dcdd007184c63e5d6d7ff8c8534eab4ce053f45c088343069186af99edf54d38f8e99e4399d2488f1d07aa3e7782d74df5fee1db5cac756982e991904ac8a4f7df6016973256ed0987912c6f5c55e09a589dde1b9ecec47d422c0c905413c82a0b3608659efe6c1f1da4c61a9947d53d89a4a327169f1d0dc98804f1b3c7ac205e41a74fd79d7d5de16ed715b3a9b326c6d6183b2b772782e281ce9514ca7107d9d511917173b0295174d4101b45b8b0e23eca473127196f243f1a2fa8f18c79c5ecb34be9f7fc873c2aa0ea3834df8606edd9a44b7be62b3f6d4c45f8278110d8930261bd1dea0caa3d3a15e38625d3d9f71d6dee9252544ad134d97f67adede74e277930977ffe8f1f0af42321fef39d6804d000571c3241809d0f7429df211fb058f4a70fc3d69005fc582848e295f6b7ef4eca0b4a486f2bbc3a661a095c7f0de5e1b6de4fcc0e73f5a6071ab4f7f8972bcdf189e6a002e468dc1e710eeb74d46cf8a3d362ee0f274e113ba0c4fea8dee81dbc8737804da0abb24891d929f78641d773ef0dcb9b801dd13a3f924e4df53a4c5187ebda05d5522526fa259a7b86850b4ce5ebb997729e3dcfa31575176457e2f5d84a745be06ab064c865c2e86aeb9d192686901e84d3946affa16ec8019f0020d7cdc6f036b2b9f8e3e45a73d977fb7da6a1c09bd9a5b865a30d55961cd358b3e64b3054eed5fc4c36411e06b3c6ce043d11b0f8b4d7eda89a9c7d085937be1b5f228b4d42599b9f7712d855984eaaa7fab12c0bf32abefb4566161842bba8db42537627df64d45e5d309d95fd152e1f0b58339020405cedcedfa80125b9958a8fff6aeba1cbad14ed7a5633acf56aac94ae02ea0960ab31682366bc66d2f9607730ca2b84903ad309394d0ab924623cc534eee2e8666937a0eb3c981eeef1b408e129db8e6d1c7f37c645c775f9cdad1d442b9a5174fb10eb43646273ce70f46b1fc6412715314bce64731cab3e4ecfa520149965797e57fa285f8bbd82ebb61fa640c7929b60e9d065e497a52db5d2d70d1884f2f69f8a54df12d574c49ebe747d494ff8d12a3fa7770f4abe8d523c3c5a046aaff64f9644480e6de1572fc0069fe85c9f8e7cfc61ea303433020f3e31c14d5e27b1f22b3b56b74c9b22b9fc253e90de8adef45a6f4255de23a0881df021bf4bf4afa37c76e9d1fb72eb28dc49eece35e4276d7f2cd24f2d266bf1df9855715ae03a5563bb27457b70fdad59346dabb223d726c2c35d9fc78a83309304821b3caf9960bb6ddfc1a2bd1bf63a497da87c6ad103e940c0b94b46381bb51c98b2a4832425613f10f82616499fbdae55bdac8ddc33b531abe935b28920ad0953b8b456dffe749fa03530d5474a4fb59ebdfe8eed1de3e197ecf75d3d0cb697cfc74603805ecec3defc0adad1f22ed9901c6130cb77e4f1f3e62a9b3d565a5c27ac2eb79f59f27444e3570310e2099f8c2e67f525e4ebd0800490e9d821327a3f6bc574437aa46e7358ce7c37871e621f3adc779942b8bb2ac4a4e9a8a84fec2060c299163853362d9ed69884e73682cf37b9d3ab263bc088fa3478d9ca27a80ee1084730e6875ef6904807aef48ac15c6e89cfd98b089f2d9efe29aeb417fbfc9fcdc9041f8c0a1c064f9a9bef09bc4ba9d39941cf3f888d7e8f88a978864441aa8ce92c69f3049b5c9c59651fa74744db9b64dff7a15a94c4b6f470fc8138af000bbc260f097f705c5666632bd7231241ce7d811e601badadf710679b226512bafdb7b311bffb0a390e33875f73cafb8058867e0470d47f2f360d5bcac4d2a7f96a355a9a4ce41d1b51fbe377ba93fa4cb1a57c710673b05cdb314252d096e9318c744948e8bb13d6a6c051dc0c85d8046052e488e580d2811bd3aee1925fe0521be95b41000bb1a0f878f684d0bcd48e2f9f52337a78d745d65f064b83a0b4d9f8e04e6c44d09a73506c0184a7629f00ce14aae0c05bf3e3f6659b585d925ff15871b2cb748f75534be3bbefecd74fa0589659c17519cfe1bef04f13a330e1dd4a3d96a57c689e375e8238770c6000a4477f293e320510d7fba8ba8c03eb85ce3d91870396987ea895f044ac041adce7f28dba69f546b8c631cc0a9aae81b9de1eab386da012f4736681959b21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
