<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2c601276617a3944535deeb56b16c3df35c5fe28244aad91b9cf56a7e0607c0bbb1fa360ec7161f2e59b23c4425af4492871122d6844bf9f8c86cad64219342642747d98e73142449fa6ba3c6e18c08319b20c307da808c18f84c54b30ce9658c4e2d206104f1503a1ac5ea37a3fc9e650f01c392f05df6ebd51854606f4f2753dc21fcd18ac33b90c2ab6dcdb23ec687b37b9892f0c659518434ceeba594940e3b9b3202f7d4bf23f28fd31d523ae7c7190cd0ba5928bd585c47764c0184a01d5e7f3ba686e4216e883cf245ffdd8ea693593ae6985e0a18bf8fa16b5e7f352dfe0f672b8ef39960ef5cc56bbde604c95d38ab9055980a71f6aa8d96a9de30b69712129f7c3e7cf3071dea64c9bdfc05872db684dcea871abcf735e4738474fae55dbdc673aaa9b580d47cde768c04808b7163fbbbcb553cc5788b1c009a302c88cf5a7094ea82e73c86e212272c362781e910c0bc0bce56a14fcf667c46e507632bf557f3c81c7009a79d9d0acf3d0b22d90b37ea2915d6d2e5cb3041069ea9ceb47a0f7eb000c2f5a654832b77340348eb773c901851319ef428ac1065052de135a965b05786451d84954ec84ca2b7b9217bce1721b4157b28013f0dbca6bd84f2c70dec4b44d027f765159697b6704e899ca4dc4b19af3a7017d11173c099fde09b9d3fbbeb6efe00b1030dc90bf7c55edbe49a519ddf295fcf33146ce1b14364a7fbe8baf9c1dfcd25b330401689ccf22a7a8092153bc8bfabd1ec7062b232af8013f6ed135e5f792ed5165956f27b9693f94054ef2333de7b2f7d7bd3f6332fb084d25904fdcdb85d05376b811f9f8f79d7ea1cbe39d3551626e0f6a2ca7108e05c7bb6e5bb1bea3762f234bbb8560e6c579978e08822bd3d5f95e3b675d9f488d9deda90be87d674f809ba10c1f1d20af93a35c5dd06210036a80945aec3cc37d6dd8399a2fdd86b3e2617f00c9887da5e509e1863e5a7d46af40dc6fa9c093a7649faaf3e246f18e81bbe59b444e7f3dd7db132525a56681d232a4119e4bca25103de3073d87cfb35a062e64269529a93302289b2be227f4ee9e0f36b3d17bdd9ca4926b27ea6a0582e5b8a37d725ab30b04810833d5ff28f6eae1bc4f035510e56837b1f32f56b49e8d14784c93a12d7e547d06fdc5e2ad5acdba70da85eb35fabe59f322bca85c52d1bb8a7587f472f5628f14160d7ea886075d3e45e846fb7c4d1e2a3ddaa4116171b0de04d200672210c4380d051ea82f954e566d418b4220218df64875f7d78ac53a82c545057fbb3068a2fbfbfd478c679114de799af97751aac536c617a7a83524bdf3bf6d4b69d9824df0b2339603844eaf49b81e54c98d071e633253d5f8b6fd30f2c12ca1f11607f6905279ba332282552ac1a17d9d770f84289a13be1ab8120b4bb1547a35124f08b34520406773e6d4ff7ecdf8a03de3c1558c6a4cee2a81681154aa67154fbfcaf7af004ceb7e90bce5e5353fe9b7657eba82debabc7d9df52903a7639a375174583eb7ecf82328af21fc12ad3072d40403c81b205302c0e6a9845871be4354adbf1311904f06d9258c7b6c15dc9276a9028bc76bcbb2328b2c046d79087a1b1c4b691f9fd0feee8c40e79e7527f2b84d3632385a807e20900e6513dc3ee749bae9278baf71bf487a7ad4afad1902f25f6097d16444df042aaef4694eaa043174d70eaa5993c20af66f1f97351657b82075085870778f1a78832d0a2c34681e11ea7e81d1f0d5d135177debd2246f348f61f29f31928534a0ad544b1d5036a6252f9525beef4cd6ea935b44beb37cc290a0cc4569f570969d4171fbea839a60336bcc5bfdc404417645427d8f091833e54d9947a3931f4c81a78893f50fa7953c4c2952fb20160cc13cfeffd1147d1c62cab81c4dc85cdf897712b9591819235b11c247587afa3fbf8416a4606072f1644f616be4629df0a42ef0883d7fd94ac6a6d09ebf328f7fb06c6617f792162219bac39f63e8429542e762ce18d35f0e72d6aeacc1a3830b775a399117d16a96f33b3001cef2517d2a8cbfe5b5cb18ec453346ba8155fda9d9af9e98b98e894d273ec90827f66b89bdc8d7d09b4f025c41ffec3085b70c2f1a98c3ebfeb2da8b97f840395b02bed74eb6193703427452f718852f93ff3ca02c67bab563273047a11fabe8e6ce8756671618d9746ca43ca20b98fd692c9c1274698caa2f6b0857015f9b827155768cf8a528f63d41452bc357a0737b2a91d14c8af62b7278beacb53723841c86fa94941de758951e6b1d96f28c800f26171d6d8747f03c135fc758f5d76261da200ef82deef7030623a572e8775b73cafdb3becc65cacba96e296f0a59bc2649d07eb95c5404a08076a3638f3bc3824e1a0e700ad4802ba6f06a85adeb5d82b30f593c00b7a86dfcad5c958cbab895f1d4e17462e60c233e0d3274c30e8b10419db4a708c203d33dd7a4f121d2c291df3f6b3eab2b07f422d46f4d8161bde24c24185c111f162bbb4db9d05682ac311cd3b156c9ae3238fed1e41775df6d0fd83aba7b8fd930e6ea006e75f41e5a446605659c02a6a19671793a24ec3f2ff44d1e35ff9815a69bffee670aab15126b4debeb03f6f6f4ead6ba37d158b154497db7735b41d6502d1a16cf64448915fa287f8f45d9617efe149ea90c69eca3430251bf97959f20ad6e330c7175fd3101ba070080588bf27a2ee6faafd1e8c5413c47507a74f4f9b077712f24ae2b4bbb47d2ec31c00c59ab65c682fecf1eb415661ecd8ef80b8026c396e750f69c9f2bef26087a627f3977483d0dad0f4d074474f178c18d16cf7110e75aaa66d601c266bc5a202d43931fef87fcab4e475127c49f35f15d146f6939cc75d5c4e642a39a8118dfe45e96e9271a4d1c03b93f78c07682579ad00df315c5ddc1b7b82a8eee4025d4584e6ff97211ba282d4c0c6183ba5f8b7bb7d77124c34542af43945ec373ead024657090cb4e54d20aacc96f98ca9aa8ae8797cc3f8b5a347127590fc6e6768a6f159d4b05112b2a92f2bb7b3916b03e84e11287fb7e7c988fcd46b56109b0f1b29f990665a7cc34cc3a2ede331a1c137a27c7c52f88c8b87e8a92189610652d145c029d047df23b2c68ccf0ca47f53a39de770e1c908a83cb16dcba20ccdaa08523e1030820d5a40c1096e51b24ee0dd54229eb492f5bd056478904f51afd5a440f1223c0e9e04d14f6b758d43cbac1bdc52a2add6145b378e89351cdf4bf1752276116e3622f74e6af5873ede2cf48c4f3a6be239385028c005bf9113f6f5d38cec3e19c2642263dd2158105485d599c27b631b2646f807c7fef8a47784720000096d15ea23f22a5a0036852123aa9eee1bf76405e788ab9e0e14f45d650ef02fb2c7fdc3506c9c4e59ef4dbfd0e1522aedd30d52c2bde572740d3ad4fb0b92a994538341df7ddb245d664e0cda92c223ba035309e8515547e46b3d613ab6465b9c2bdbb3675e4add9223392405f6757642ae2a35bb13ef2186fced9ed1f311ddf4c5a71fe80a833a6fffa42c1cc0d394bae9f702d9a0eddbdcde6207427a0f80e7f342ce24070a584a6199d0f45f69fa11622330dda3489e8acf6c6117f3ba6a6e98d4737482083a83f885182563fc745fab6fe6b032b7802176d06941a0d77b8b58c96173dcbb7f76dc4a25b838a701f8e3828453c84d1c2ae0f3bbca7dfb8e09b12f5f4a512beae5b9d80f629683c8e158689c7b76628f617e489125bf0211d3b98776a9fd6881a6c52bca35dadae20e3589dac1d1b128227575d029d6a958bcfb58e63268eae98882b7d9d3c44a43f4a3a70815e37e86bc1878d25e8ffad65d478daf590ebc7367953d4dbc7ccbd01af3ecdcc591592e27e6ed9bbd48554e53c6cde0d27ebf17abbccbaf7159ba8d8da55b2b02fd3efbd3309862c4d751e2b0a8778cb767a57d447f1317127c6b0051a78981a665323bd482d2f27d96d9369dbd7e90471c7d3c2e9c538492172384e99e552f87ebd8c582021900eaf8c25902a89acc2878ae81ad61ce91c78e1c28b5f9231036d9c3a22af4404a1df29853b4f37563d73da5944de18a581ed294cf6c8bc12353ffeaeb3c03c5368cfb35585d58b4369310cd4355600642b041f04cd7b0957d1c664d97da16c233e1c17afb38b5f617a4146f87e0fe02a9c6eac5fa007872e059c031a1349004f9c453d0ac39f59cf8e9e345b44c0fd5a496028eeb0c02bb94dcfa9cc16656c8436e149b5d703df2ee3ab6632d9b550c11e0eb60809959b66654240d3ff25effc2db6b8e1b8a71308c1ef34434aacd39186634679cbb39edd85dfe1d86d5891c9219b729b4b8108be419c241f380ba31949218888d95dce3ea9616cde9ee75818b6d63d900809b548fcb844504b3608e5c4fe8ee89c85b0b16f759f608a1ba74f9a81503615335ef5788ff3fe755b152c6386cb1da1d734f54d7a5c8f9f9c95cd878a80ca2de31f5cdb4fcd6096315c44dcc51b722f035950868e7f390e11c06fd049eaa17d492622d9ecd202bdfe6691b27eddfa5972a8d423c669bb96ba58a903ca8761cb2c60d32063cd35c4891b10289cd9e65d1f46f110db3abd581020b7af7382cb6b9639f525d1beb0c38e82ba3e73e128aa2863576aecfc83bb11b6bc09dc1328ee3ff274fddbad0edc7237704afdbef24f3e9f8cc4c885f7e36a8ae5d962f51a16103480be82d3026a37340bc5ff7a159eb29d9c9ff303a2a33380a3b98132504cc110594773805f5add4b0e5adc809d4d9ffea09b4f6b975eba235c263b2110efbd325cc9869a6e8c5b1596ac3f22dd23dc164af66631cdd57e192f5f7351d9a3c9f2f7b540e92bdda9e2bc4495d51792f55f29dfbdd13ce42a2b0b953e65102d6989291c60735aa3bd54a30fd97ee5c689e9e84be94071ab6bf514b07b99d43b9adfb41efa2c4f03a0381b432b97247351e3e235ff52a9aff93b1f6fb6b6039c0f5674672b3e6557da7163143fa03007ef9a42986ef658d75bf0314a456f3992efb7a429711a47023a8262699ac1789a87520c6a1de3396aefbbd423674206d2aec41379cf404d39865853cf46362821d1214fff523dcdbbf3ff833a8a1c1a55931e25cd1b16c074414e94733eb6ef98ec38a93426f1ee7e7e5eb893c8a3cfcb2520d7b5ff03565cdddd83c24b6559e7a70225e45b34ddf177451464ab1d35b900f276c09408ca5ab81a6183c43af47347e139414f63acb63d341a51c8d0e0b3a0a95776e8568b8faccb4f8aa0d3381585d24f4c17dc2f24cd1303d64696b8d3426c7600495c73c28d160dedc5e7112d3c11cd5c6f3f531bdb376935dc07d30ef05d904f50257311c48d728608b8bb98551e761f152d4ad2676ad74b747c76afdfd61a0f9ce469f8644160303ce6c4301d833d44966bab17a50db09a29f91ad38578f3484d23d9a4bcc04484547706d8f07349ec7a9df1a7f5de674aca916a201a76f917ab9518367f5933f0c95a78a423f039eeea0b5bde6f59e5cc6a089f5def7b259fdefcd9a71027442d55c3d4fa37316bae24399986238b1c115ca9f168fd372a5e00e35a3f798c89b6a522907a4e43547fed8767c943aca2250b97f4c15802c51123fb985bf0fd4a85aed0350e1423fcc4102a143dbc56f4aa4c6876188a16967123a943f8f0096199d8bdaa9e7ff3a871938c8407d923abd4429b5dedb3304a0f8400f200e77678ed348b92fb0daec4d38b03401eed8d42ca589d18d19b8172a8fe6bebd31f742a83672c25168e3aa94f00353943f132b93cf1114bf3b56928fb077b19462d44bdbaf46caf74f3129e56a589fb65c81e6ef540499688e229d822363ca7b0204aeeb95848c93db871327721c71685bc64638e103c71716d9a7ec4dde4dcb0f325ee0759673070f06e68c9519cd09662a13152228ef3f830187e37d44876cbe98aa83cf784b1eddf5b5559ab8b14c3b46059701dde120eccc60d97c734225336f71711deb03ab26b448351da882795c317478a42d16c34e3c54c80cc3252ba19957aff4c1259cf7597de9dbb2c5a1600124800db8c793cbb8a752f589a2771e75f78cc41b8acdc7b8351fd4585005abbcf77b37b51e9ffe20d5cfa462454855cb4cb13cd5d077b8ddc2233d1f1f57478bc51006fed15775db67e8413dd1e2f70d4f554edfbba364cd6e563df305a78e2f8ee66592feabe8ad0e73f780dbb9658fdda45d065c93cd226ce1aaf6f4e50bb035e017ba80a3763c45665dc6e53153254c0a4d44e83305bb29998e03b33aa59b2761bc4479f23968af2afd268182b3516e9ada2443b6b8df5bc6d1c774864ab2308c379795d9b8de2034fdad07fad1386c2a9f2fb0769fd85413e585ce10e85f82efa6aa3f854c085936e74634ae5dc9d4a25214beed2b77d1d97bcefa32ae82be9857c32ed20e2ff8ca829b2adeeef18773300c1c5c7de3c252618b13701fbd38f1453bf80c103232fd166398b3d8e432272556a314f00ae4bc37fbcae918bdf6996a8cf49e241c0a2554e987c8afd59b985044508eee4ca03bc3ca0452cfb32b3798a0bb7948577e5dc40bfad7d56e02495f2928c1c5809adffb89838058fa1f081b765d81f5683d41f8981de82dbac90b9f3403054f0ab6630f3674f9c338d492240de9eac2be4fbdeb025a3762e6690edcba2b98c806f0475a19ed7c46c0d1892bbd1b1e4fde04e89598df6e8e96927257fd5f927a9de2004dd7dbce73741709e9f532e0ee4de4b11984f4808c901540bcf3da1434eeaafbc9d1ed423f60a01f7e17c40c77d8f7e20491b07d6685394b74fe78bd8c5e2759a820e8dc0d17e9dc8a074cd14e46d38cb3e95eecd915fca01044462264bc152125ad116a6183db7417a208e57a0a885d4a95319894436741b02579cf99857ee159cbf6a5a979c4e3aee2982e672fbf6632311d2ddfbf5de6d372c3eb65eb3db9491a75fc759df93dee7af4e2f065e63a376adb66363a16a6a00ba47c0b5fe892dad9a26bd669ef96605f07f2c4d972cd2640f39607624a6cae4a4341de3f875c32b0b02e0a1b36ed430bf14bb222c7973bea8713174a50d9843831475ba1dd2fe04ad9f4904d0079128cd6afff22e584b0a9d9dc8324c0bc82e0ed52a529fca2bd8a272c249311beec98a50a572c2fb3ee374204967432eea14bf5995497591e5e07e2f60539e6276ca99b16b6dc038b6e2cf86c2dd4d98bc07f97ddd5fd9b6a918172bfdb2cc305f2d98f41b7106590399de0f99f3e6c050f8cc625eb3670dda28ac4ab5da600a9b7946cfa329785599f9c21dae317579ca567405182eaeaadc452818d34060216a1162b38af28bc7a7bd3803abfb04242b6bde2a92833ec014255b3d6ada0aa9f44f3428bfffba1b13e68f3f452a7bcdbc350d6d792fc3b063388f0234a30b310b93dbf158116d7b9627f443eb95821126bad2fb7312046cfcc2f58977017fb9a7b7fcae56ef62452fe4d660cc26641997ecadcdf22c47739b7e7ec67b62a04e09b849e299046a47682a449a9d65106c08870ae88962438152a9ca4dbf24caf132d60617c1cb3d980f60c96c110ed1878186c400b1c890761c55e67b23797b7acdf398278cd3394b26bf99b7b7e0642428ea91962c2e192555718c4fd5d4c045c664c4378ec35ca00175dc1dbad6cd79d4f6bbc482acbda16d0202d7e27f249d464b11f9552fdde51a6e807b3c5ef3d8175b9d9e31739c3dc5aaca4a4429aa1a4d1b89f41f706af7682a179542040e45e3b4696c222a42040ba9bb01d2266f86b8f19698f9508f05c498aa49e7c24e7be10ccf93c5ebfa7b80d8b672a51f9b70f3a83d3c58927c01f1c3ac5e7f3683177df805246e42c9d937bd3aaebd865e8a675e490f2f9d5d7f247e397609ebaeaf563009c6de236a767387f3c9e8a7783bd6c43c0a1ea8fc22f9e5b4e4c37ab82b3cdd118aa622e373e796ef53be068e860d3c4c9f4cac4305cb8a3032127b2f22cab8d5e1c58f7b157dc774d1392c301cb0e62056f125eaf2b9e3b652a6450a288ca5b90ccf3772b689ffa617a58d7e360f09c5960ea8471634e793fa88c15fa9cdc56e3d44fc0eb170087ac5e8b60b4714edfb6b2178fc54f022dca80aa7ec6300f50251f07a15b1f6be7ba0800e8bcf4d80bbc8dc3214da97614da1d940248be53a1ea1af17ccbe594ad631b9e97efe8d4f30e14f4fa45cdda08909c0f091825a1b9fe9541bd1967cb3f8afe1cf4001525e270bb84b1ed62dcdbdc74fabb169b552566c92ba89a096820184bbcba0d0ef995b87511d5c425733e72e5691d924c128bfaba4adafc3a698a2771bff5c8ed98f9668cadcdbb2ab31191d6df32a679c6fadd9acf913310a1bb4560a532a649a9caf5726cb583ea0406dd2f41c9fbb07c7ec36ab3bbeba26fdc59a1f282c994c3858b3691c6cc7c2b85798d30b1f809f9297c4c958c564242e5a2e927169685ac2066c031fa3ab5a03f1cf0094ea109d3712a99cbeb10e80de449119c24c752ec89671ee724df3adac47578fac6ea3b15f582e30c38401f8f2369a90cbb7c3c6727b1e2ddd752f363582e9d1abf73ab0e76afee4fcf8dcba04cb7d43f8cddcfb62f3c992514c0abbee696dae0cc82e6a6789888386b8fd0e8d7447219910565870ac5f046d1939afa5ac104e223e6414533eaaf3bab58801d8d12357fa75b4140bd5ea4d700fcfb4dbd04dc5a4ac8b902f820d7f2aa52137a76aa345b30861c0cb0e17e8d578273f0b20620a0f839d2441d83e0d01c1cf0b734413edf2a326d36e8e399ab080e9104f0fdb3e0d9c681a5c84849c77cd4dfba4e550b0b8df2ef41d78dfdd54536b142acd51a0701949e1c8b22ed13d252549de65d48bd49da42c7e7f7534242babf15fcd33366984ae65484464f6ca963a85af09c7e5b50996d93e84c46a0cf74b4cb0a34d908c15913f6f0e693b1744abea732146d9cf380224ab3f7831b44940c53c6f089283053e52f4c8518fff5d6f25fa395ed240ee169fdffd4c12716f4a5bbb3e3c9f15ecfe03cce6fcf3f913ffff32584898899ba44b25cd7c07a863d6c135a777e0944066a7d240de2f5fde1dda9c2b0161e0cfb03ba5c87dc6aff9ac333808fd228572ac0079d719efa5f47bed2a873ab986e71c4e0c6c009399b18394163ebf754feddaf6a423c26958d6d6fcbe43a2cc33599ec6ca9fa42ae50f037f9aec2d6ecbba5f4941740734a83a47cf581557ea9b7f5bc1dac3adcfd2e6c9543ea415f3b9cf6261577303afb53908a21a3583f87e00365d17a4ba47119c3790b51e6d212af4505e464981e2d8d108cde2efd4fb6e70fe4c26a4b3a4e0c6b86f894091ee1af6be1d1c56b8e4e146e063ca8a53df910df69875fc942cf0a92f9a1bbeb8e5c0c6986dd72d6265ac2d50986a3dd88cf055308c478e4484e789902c528e8590809ad47eb7d15a8b5a30d279f008d900e92470a3b3d8332cc6fea38b5b686e69d6d98bf58429643883099da6fc8ff611ee11cbc13d3cfb52624c11a9cb00e37b122ae50d90ab435240596cfb1ed8993d189831b4a53282bb6278e683e8ae4deff5f1719bc9a03c51529f3e45c172e105b9b2b44f785452272d8907545057af5eb7e33d56fb3d0590b2cb0b79fadcf2cc588baa6a604a0fc2fa4cf7cd3e69197f1e267d141237d04b61b6989322795cf99241dc047c45b3a6598a1ad1fa1794042a79953e29c916777349719fc5e682eaa2a7a54f58fe8321bf6f184c7719d65f85c17ddae27cb19f4f608cc725096e8583e28db805b933f75c29fa7a813e99b51e1bf2e8a3ad351d18d7e59796646386aaf7dacdf11b0626b50420f62619409dca2c4567261de4454e4924f8c0e7c9f600bd8663417bdae9fcc24a61d9cfd13b3496162ef3fe47e792fc4cdcdbef8f6afd1349bcbcd7ccdf8956ef95afbd3936ffe86ac2138dd7c0111437fd28975bc3f89b5d63ceafcd408f1071e24c0e6441f03308f5bece44853e931dc0f6c2c409ebb3a5d8ee764bd6ac46a08b6f61de0f3dc579875d2e096a733e0d0b5f6b01e913704346343523c242a60fdc43c4b4b512d15cd0dc249ca89c614f3512a65637aab8e04da568be06d82df11344c4bf4ed406d0073af3acaec8309bed41a3223c7b943e2d8637ca35a9c4e9d257f98e2ae8c2fa879eef90ad25d10b58713c30bbf0a486d8f48d45d9bb4d40338f73d113bac77cff245f9cdef74e84a8e159d1117459758a36c98b24ee572ea2ebe2f05fdfdade02dea2d39c4e36cbf94fa61ee299eb0307ab2082a8128fa77696b8bc8a9078804de116943fbd81de3325698468258a4b3d514cacff94f9e0f0bca6ec425f48378943e933844f418123a8ac56ad66849f36c0580e4f9a4a31e61130f9f4b5425ec46e88bb8c8baaf843f2ce0cf8a79b6bf3d3bfd162717298352a676cd3e7e68bc7ed6b833decbf9620de80a8c48c54ddea74dd5733cb08994ba1a198722c8f0b3b62bc9db4d6ff6062bbdad487a58ebfb0660d122b0e09a298c1c908fe63784ed6ac4652f1207a10d520941aa0f403f260b7e9fe1321794a9d65981477208c19c919106947a29fa4ceebf9eea7529b6c8449da433bb8d6f249931dd526171420fb37d43ad49a2b8b5e9053d53c79a2ef93987f549290106ce8bf88a21e0f7d3af730d0f544d52516ed6f6f5f7897afa6204a255e0ce07d748e92af142e09c14e83b2e2c5326eff12e89fda2e853e704a9a6331bd3af3998e6e9a390565147d11fa6664b5857b4e7e432271863c00aec6e47da4eb226f67717059c803555cec220c5ccc849efbb73bcbfbaa5bb473731e90424241d732a52e2d220b6fa96bbb0523c5474362b2dd3629525c8da94bbefc44ae8119b22515a2bfe8994f556cc804a52296b7dda956790b0b63bec72875688333cf3198fbffc4817fe6d8613303f0c1bb6f6c7a711a59b1f0cd62567e13885c41b45b3397638edbf30e7ef9487ecf4e73a6391df84e630da338e0dd4db949cf7ed4d68f871727c2a171647dd0467e6ef855bec588a7e0b4d6af64cd3736709b39dfdfd950ee875a34602dd4bc1a401b10968b2c4517f68707bf10102380ce6b0210e6d30a1381b62e36c818bff29772e98e8f3dabc990bdcef9f9f5df7c6783c231a1a2b79a1a9e46100a7cddaa7a53b3c69b9e7e51803a884942532dcb48a36b59d8bf0f6a6a0b8ef5fef7e382ed97a94665e70fd5831f8812c63865cf0d7e1791be25f0f485edeb19677da14f3ffb0ca781008c6c7dede550c8dae7fe9a3ae70c686236db59e08fa4572eebf700e558633776efc15a21df47514260923c40478fef5986dbdbb19ff5e5d7aeaaf0fbfe03143fecbcf50de92244334e5be1675d5128a1d920b53dd34fd9f7e88ca571011967d77b70f083c384adba98483b2ca85dff2d0d30a9d528c34e5a6ef5010f2365615c1be396cc91d9b4b6b8279a85b64098f6b75356152e9016b82aee5cabaf324e0f533363dce45906728aac2ad4a7091f8f57a659d4c3a8e95b6c032e665a58217fdf0e3f367735cb001c0404de00f9ad79ed8e79f64d05c995ed0f47a634c515ed5d291c386b8f41185e15226f5f897d66ac376a08b5ea4b3db47bfc4a915360142fd69a41a2b620f21b39457096292574db7f940e40d1bf2f8ef39cb04149cd5b320ca786d874fe2f619a8a7b1cb1f0e6a3ca677720b3fcda647c69d4b3ef1612d2b7ee7e25a0b6db60cf16c2bc5ea115501872b0913b53f0b3a4ff32f7be91d506daeb82582b730cf61a0a64462606513d92f4a23cb1aba4f019fbba745d1cd7448768e21eefda1904b90342045480e2092fe590a80e2ae4ffaf3e2df7e96d78cf92d011d5cebdbf4b29047199f1b33900b54776f60f50ee2b87693721b66b037cfdcb2dac1fc6795a72c5a3217864a80b6ae17b95c135b7c0ba171d55ccf27f20edd3a9848d68cd3b6a05e8c556446a4cd0bf5f3ab08f2cbbb71a3416155401b55d40dd29ced147a75cc93e40bbe2289abde40618b70393098be65f9e6517d0ae2562190c31425e2eb225dbf9738ebf4de28d3ff055280c6144f039cc4ac7931903a390cf2e6b4daa72ced074847de0946ef610a9d1d7dc3e1a0640ebc848123e7f03a721ffb17dc72d3bee0ee9a326dfe8726f92164e0aba8c401753a12a845454bd0ab213644f97ff0d52f63ea765080978072aecdd162fa2658606da9802fa06f22805e1440b655e96753bac0608dd2169c4af4895afdd9987186e3070448d59a218f6f0fe803c4abe765e29a08fc6d328fae110dffdef8ec88f8dfbadaefd081a6971c332a9e9db4609ec07813745a41753301ce0cd7850bb47982baadbfdcdefed4c4a0e770b2e682309f72116f9fd579a9baaf01808820ba01f90f54e7cfe93f6bf00d60891a374d5de33c61ccd38e6aa0bfb11d33e81f9ce46d4b94db279dae579b7c8564c74de3e6ed7a32a7bc33096f9dd1a7a52a5cf5ab465ddd7291badfc03de4dda2ffbc18147e76dff2cd8cd8827dbcedae705d6d182f55640c42a96dba025ff01a9b09182714867ba2ed1fb624a4c0c9ef69e7378f922bb2511628207d6eacfdbda3217c33dae51553f94e3229d25643888e8e6f3dd4e4131420bde13ddfaf77d91c4cafcc1629251fe81c5e533d7966b576c206b9b8974f60bfeb25d86c55e7633544df2eadb3c808e5ea5f7de29b88b9230b6912a8b1ed81ca4ae0e450861c4629469c541f157ef93a30c736291d470de118cf52b1bb12c464690fe7d27164c181cfb0862a5bdbe1be038fedec293211b4a54a77cb701c45f884ba730cd7b14f746a192baf209cfa9ba6f51c75e145e182aba624a931a8cd1169a49fc69ed4e75c898207a963e5a640ec3f82ca33d94e7c812d657ed4be4c5141fe8719daf1fe3edc1b5657aae999bed2486f7836efa1d47286f5360a42a91e5750e9f8e06ff2ce5faf216d36298f1896a6898b69f5c38f74861d97d00cf1fe392595775a16b27e964e71ded967a3bb338b3b8ed25f9a9281fdca832455a9fdb6c30fd8c2d9df745f6a234bcbad4a7ada968eb9b5cd935b45b5dd337ce93e26831e22c6c5e14bc0a064081e681758876e4b388a50edb2a1473afac9635e07964c5f3f5de13397926fa05f972933ca9a9de36508f410a0e4d611afe0ddc19090a08626b8add4a61bcdeab9bf23084c006b69dd677000b1412470f3cc96d620f71fd18e732c233daa824c10072b12e8b5146d7b7e0e5cbb965ba89dfbcc3ae97ac92a3eb82c71a2380e4ddce85e8093ee7f4866b1f7dc006627b8dfb6e51261929498e35385d39df3052e23e7e0a884f0d8dceb3f16838a898b5695a327f7f4e30c86ee59191ffed5f3f399810626ec5035563b9d4d803373d910cc57bfb1efb5259c041ab03274d6ae05721db00058393724ecac27a3e7ec49aa144a5fcc7595801a79e44fcfefa2f267e235725b3936e69fd74ce917b2549c6deaa7b0ea1d60b811e2815a874514d8eb7945e103662fee6d91b0f3ee37b5042e0dcf726c19abe172f64bb3d030196d8b04c698b02579ea9dd367e9ba2bd189f7bb8df6fbe420aa7c3ba11a94069c1298c17a7259b7a99d8e35989d2d3be3ca7acb5aaebeb73f3b9f467c228f3e15b734031535149399711742ee8ab5ccc077a981921585f544545b4d03a5aebb768bbde5f38ab90a683adda641db5e72f37ddf95dc3ddee0514f266be9f49a682259ccf1dd9a4cd255a0fe0688052141504c0736e21644bd91dc34a97ea3fb6b07cbbbb0eb02f9c751e6ced32b7c631237edf7e78c843723047f4fc00a0518d99ce99a6d4225e24aa57833b327c75730dd0da83e7408f0f2167630dafe8d4a3dccd9dd3ee54c2fc83020eebabeff52687175e62d34690decf2b6f86fc11fd46f6c015c391cd9a788d7b9fe47c5bc287cc9282a861f769c1a801833901ab8e78252534853153b5b6f03e6f97d916aab4ebb273a17cdfb074fd0dfea0e4dd9e2da03efab0a1152760f2f6a6c3614374eab5d4e6bc70c3700ffda052c364e15c82bfbe38371bb31562e09811f0b29b6df286162b7db4ac6ccc301a127abfec7bc53bb81d1d7a0816942e8cf390581dd3d450458bc4ae0c6923d862a618ce2cd4704e0b6e90634502593dd378a7ed2ab9fd3f1c6b65b11a1aab99120bebbd80ae675c40be90f7d1e709673bb835f6b6547ba1fe50acdcd14e7bc5791215322de15c91b7843f07faa563e99a78d32fc323830c6dbab667729b5003c9f5b381ae847995734c5b741cf3624ca0b3a9285f483245f2752fd707c419b087190f849ba1e2f6e68641075514a3ebb689c22da1b46b8d2ca3216915358df7c6f22bf4380af5041877c4ad6636ee1f482d04c75ebaeb8d7e95bebf02994f1f50da0a0bf6198fb8550c7c4417c5556171484c0a40916d4d859f06f6255f75b380ea74dbedcecd60f58cd198381cba3cc99e1cb6d151b09aa11c599b1894aae7001c22ca35c060812b053d93298bd51c83d1b0a76d510fb702e195eaf000e1561761c0c414a003586d3900499852167d97c04bba299741df3672f0b020cc581b112ebc121c11ee298be442cbd696201495caf0f1c73744332ef7dce02ec2ebcaa65f24a1c33d30e891c5f79be6acf344e9c2aa990d874195cb789f60ffa968aa35624ec886449e7f0bd0859ba3e4a91afefa54fab15add3b929a09801aa78b4551217593aa81d7f07dc4161a4c7b0492ab53dd78a5fa1a93bafdb66df5076f1829b4fbeb0c8a7128cb39cca25908f2c731dc635c6948309f05812270c444309da706aa49c0ace15d3edc92b6c2daca0ab41f1335e68281f99b6eb5e9f4abb55a1c63fc3a43aa560eb3e83d23a076d6628fa1fda812b7082908b805882e25da57b6340368c06db90ba07a6b8d891ea36c546f9d6a392fd1151737c233b746ea0d2c6c1082bab674c07012dcea987a12b0d026ea507107f66dc02af91a19218dbf7e2ae5060664c8a7b80a3f4f691d0ef9802f9bfcf14808a9c1357625de77b6cba9585f8ffc11c051ce4f9f6fdc560b662e9a3776e37356cb4b72dff53dd56154c268b958b5fc2fd80ce399a1475377ac7e72c01fb15565fdbcb8072adbf339bc7b7ef57ed832257e7d28973ee9b3357c6fb1ff2c5b74cd7974a647481553e4060866b0ec0b7a2711add8032f758bff2644474d71cf55b075cbca7690a77ddc8431a25d8a34099d13687614d34a94be8d2e98606be0740dc240a54507ea79e3d4db2cd9a1360f50f27c3be0595ae7a49d3528113be38f0b0be2ebf0e31a7c7123943219de285fd5bfdc2cde1e7a3b1acc1c3cbbe900aee2e410ae23fc3c31ea6616dd65ab7e1b16c949866cf6b93f50905a31398fd075de7a2a517ec35a4e9764702fdb880c334974048a939e4233fe054303189a59b8af1ec67106201dcdf47ff3f036574ae1d227dcb84f3c5b23f96ffe906515b93e98e24df2e777fc01199cd8f553b6bbf068a7b657952fdba71ac6c763b2b5372a46e14a4c29d32ebd9813f9b951c081f5a95c725cb0ff70f7f7c25e2110fd886cfb55436a5cfcdd26b0672efc271e359afada402c16c3db3a2a64d4d27fa11b6573a8f4ec8b981bb03a813c7dcc45a92be6a4c473521f9f5e6b7646f745406362ff514c3d740ed4708d7bda707b56710d15094aa64761ba2654b134762f82fd571c4f76c0b372d17e4bae54762e017410c2994a0da701b0801fc3617d90a72fce3b602fb36f39394887004efcc38964f95efc363f3b234a8b2a6eaf7bf2d260baaaf601f7fa5406400a9369ef18ea87391308e16792da827e1ec6b8e0d874a98ab1ec9ccea22ff023c6a56755d27db74759ad41d18c73ff0c7bb8a87581b6278cbfcb791783919de62d94c9e6f9fca6399e92db455450afa69c0fdcfefd1c07229bb91c9bcac17e86315925d3528a1234686983f2899cde1911e1874c0997a194d465feae25219d59d0b934096dbce952520d938d1d5cb0982afd2058ed988b595473b732eb53b3a10a7a1baba07326f22935505d891cbbe854f74d82932a797209aefc1cd10a618c141594630ad79f0842224818bab49de40c6e872ec8bb4bc2ba2c11f4a070c3242376353f017a9ce207e51b664a08ce20038e4cb848409f324276da2a3178727eff36df86def96e83e47988bf54019fcd5f61d2d940587f33cfb4d6ef296a54ab8fd4ec011f1277a34bc9aeae42636d7cd58dbea4767f8b9cfff4b638fe951481b1fd28c0b20287156789d7384b075629f385d7bde20b1ebc53ed230f82da0509b40229cba4744a4b65361d116e643d366ff79fba87db15b2ea8ce7672c99cf2d048a072d6e372aa98133a40d412bcb1dcf61549a2d8c07dd0a8272fadc25c6a07226006dad43a99357acdd01fa7b4d8f109479e39659dab358b43581b249d904ea7645f8817f0dfe8bfb4ff957a7bb2cdb457c918c5fe6599316158b85aa274ef5e1b06a21dde1b3a3501bfa41248a827af3cd1ec1aa079e8d145204369204a258b1090caf5e7fd499ae6e3b3551cb5c65aa8024b958907dd3687516d401d1648f0a143e76322ea1c317b78e03b4d2c81cb99e00c8352a360113442f55a20ca530211a6ccbb39b663c2eeafc412f56c1effc85bba45580bcc0eaadea10d141ba6b454956fe1e70633572c0e3d7ad86db972f0519d01250ebd23f36b5914ca4e60e162f3bfef2c1a8e40a71c5f3356c2abd11d61881cc2037be397d18e99458b26296f22d9d41516747e63a72cdf8c5396b93a1d61e62d66eb811088346d4bf01077812949b0b2129a83de336b5a52936d554694fab37501e1198521cea33011de6755e2e645a70ee3fd295bcd94b4099b3a0c90b2e906447b1377f5437667aef85c25f09da6be0129617e60d907cdfda4f101706a2cc1caac52ec8a666b724c69d8815efb99212158339cc0354b794872e198fcfe4d37ea2c8bb56170523634710bd003560d0394212d1d350b4a242cb2321431fb2c1a05406a4597349881652487ac51815ad01581c59a52251676ef785128753ed30f9b94042f80080c2c6ef2a0a22f745ded81b2283334bfd5e2c6fdb0726c6cc49832bb3e2b2b3de69059e11921bc58040865c10da07d92cfbec4e25e2d0b4d3502c9f730927d40086c043e1cf34b6ae92c68b65418612c206ea3fc98a07a8c7326b0d357bff47ca614d6d72109ab9159b988e460f25c1c9975a8e98f7a7ccf8a40e5cfca5539be111200887d81b2f36b8790b4df7252e5aced1c86cc363c66ff59acfaac0d36789e937c8ff916366b3894d557bf7803941f90f8b87d6eb4196830ab5ffb98d10d2c4560f58ccd1e616e68ebbf6459acaa8d83b27feef842df9f33987dc36d8fee6f53a9461db1e1974cb4ac94e6331918a59508193e3d6ac1a0ff1afd52ef8218a8c1640f91fe056a90352dc54d3f9df75ac98b0cec698cc2a7510191e986edb51a1edd9ae378e4e525db7757bfc3ca957b5fe717057a5409b293e2b8774fe20f7fe635478c5786b999dc6341bd5d93d0f4f1c86c227f5caf93d6222897e254808ae98e21761d9d6779a6d4b50032e19b605603102d788f5450a551db4af4f138a1d599a01e945a896d9bfc31f676ba4ff1b019de6ad73d96939d415661e28bdf71b76ccfe8978c56eb533c525ed941730bd330a27e1d2e4893736358227288256e3f7ed6eb9c2886ca4652e1e4cd362188bbabfa0bd86c8838571e1ac29d5991fb04ffdc43ad48b7fbbe1a61ae0c528156c4750db0ef1e9e1f4b3d36fe7897ccd5a9f804cfce239a8248f6bf4599c76dd06e0555c503ad147b9a6fad7ddf38c80920beecad97d68be66780b4297e28b357b7f940b430e7ad6bf5e9f6a462e87fd0aeb00cca8411e4f3763890d36506f9eaf22bd72cf7acdd24edb085d317b917a98f390e86aaa9d74ce92375fb55042cc9f3438cdac6ed4a9cc2bbbd76d78ed19cdbe5359a0e6b989542ae7e95801ed81860b272705b5655e7b2232126d6d0809d9ae9e5721da2b760cda9ceb54284c1a575","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
