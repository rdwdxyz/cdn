<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"195652856b748f8a4e072331867b8d62c883bacf4752807f2610a86d8aa78d16ff5782b9fd34e87ab39d9d9fc1ece8caeea41cd611200ce41ed3b7cca97001580d65faffd0e06c735971880db4203e13b52b63d592561de4bac18863cb28b342d47a3d3dc6b79db04748bd16c47414fed634a8459014e787d554d4fbe8182c82e9fc371dd0219f0405a705b9193a4e37ad4ad45a9a31b5c20932d8b2bcbca940407cc8c675996c7e433f7844a56214cad52241a41b985fc69716e589e2ec29108d51a6ad7a6ad2480c8833e8d822e73223dcc5a00dd17f7939d9faae1920c78c7335ea27b5143462d1449a39ec8b12856f42ff331f883a4591dfdb7bc20531aba5342f86187b0afcfb096e9342f6c9fb560b70f834d98442ce1d4c61728de05d7ee3247b68a33a94863de1fd6820191ea76e0ff8d9330cbf2584925cc9fd925dca87049f36fb17b584ea68756de42e8e65b547319fd321c5c4ee6b9f76f36cc78bbe8810c3226dcb7de7e2b41724389b244ebf56b748f8aa14aae586708a4e6a5c29eb56f132a46bc5666bd6fe01933a592666bcb32b75fcdb94116066fb570765d445467d581cc4c5e73b8134203bee93762afacbe6a7e4400182fbc3d3d2a9feffb1f240567d806f830162837f4c33bf327de86888ee7e7996c1f0b1eb8b5ac9d722c04336297e51644974467bac775a4664cf30bd5d42220f0462b7501e3b535112d79b8621098bda99ea40c5c057f8c6202ce3ad50a9a46ee4c246e5b3d6305504ad3a0d353f3624a284f2cc4dcc7b6d86e1a239f3c18b918a0181093d8c153946037e17eaed25b1cce7e6c286669a072d696a49c90bf631b158504eab5e1e12dbb700e710487f407b9379a3c97e5c88a3da6bcbe3451084140c1823b2719f7d8d6ab504aa0c76a9da8d7302e0269986d4b6fddb40effd04cb4bb19a4c9abc88ed80934fa5d6c690491045042508825f579233f1e40e257b798c9bad979b5aac6b474549ceeca00ba49c0a1a67a92d3ff84f707532d236c779849e02e5bfb5ec45bc3c8e94ca300aefcf773bddcff3ef114d60a9e0778830e570898ac33fe51b15bb9e58150939470cc5bc88450fb54d467e53dc2ba3071bb7272b2738a0aae13ca08b7326b46534bdc1ac319c98792d9219249c5a00ba39723f8bc5267ab19d5a74a851492e035522477a188babd63d0d37df52ca0fddbe846053a939d100d2dafd6053871cdeba640b00c4bf668670761ee1f67b5c0fba54cac3be6da96a1cd3cb9447d37ffa64bf836cd7651a2c8d9a2a4146dc02ab447a54deaf71e4f2c5f0e2994708552cb03fbeac657446fde5c746bbfe4ea0dbccd60cfd69a31988e1d829b1e722edf44602fe77f8af500884b992c46ba9c002fc9e8a8e257f169b42f0179d163affc9545ddd6e63de109c666a91a41883dccc1367081df79673ca9fa1657298e917101fa9c2d0f4ee08ba7bab9f4f7d6b3bb76600044d938d1d3b5a87ccb484bdd49007d5c5d4c38d29853e61c78cb37a0d423d43979f34674360a875954b4968108b48f0f5686631bf2371f33e8968ea82127c66a9b87da338610a5b2375987ab90ac3f86d26adf67612632f815f1dff7de16937f0b41dac91c8c4654f43e1e89f268a2d80a77e1f875cc142bd535a4247ad03c2f10f884102b94f7bd99836005cfeee4f89c0d93d9efca79726d302f5824f806471be78221d7ae3235bdb8f32f238a389308f85dcd8167750cb4dc66ef275c5e97c48af418ac484226724cc6de7df648fd55dfb65ba1faff020013951e1d98603e92db518b8b5fbee0dc0af92669acd1232075cf7ae822e2cf5a20fd187c311adc92e3c14e4a30aab45873f69b62d380db6a7bc8dea54b740c0cfa7e57453bbc1d1b105fda562df33ad4ce3e78f15b959e3bcf80e438e320a51abddbf18cfa81a800e0c7b6cd3b4b87790dc1602920584972e302245abcc3563459c9b65828edd3478ce264f5051e2c6e8e55cef9efd4cbb53b588bba067e0e2e599b44f555887b0ba530d99d79695d7a1b8f8312ab2d3ebafd9d635bff84fa8ee07b177876355e22d0218a6a952d4222b2de0391c4a99fe30e4f86a5c4d07f20f1a3392b6f9ae37e93c89e9dc7a1fd8b6ad327155172068355d45085438877ce137d5829670af273edad7c488ca7436c53e04e8670bf37d6fb6bd15899b0193c14413cd7d22e46a07556f4242511699becdca12b13e7379d52a7688510f8bb7bb45db7d5bc79860e6ef811a44962fff2ab508cd39657bb23772c28e56864312fbec10b39aef27a9b7e2983a7ea8187f1dd7c8f8d95c65ae280ee5a0cae8cc9ed50dfd553ce3b7d794dcc0133a0fb2207659cf83299e6c8d217831ed93af09723448ed01728ff558e39d28addc08a576123a21caa2e4830791c323d62df765d3f60f032c1042caf6f3e028958173e3f1809dcbbf255fdb6982c0d713dd5e094169cf070d7cc14534074efd34dd9bbad606e34c45c8dfe63f14eec99d749e32a0dfe2dc11f742a8c46f87c0884a06b460495ac63efd58e1c9b79b1541f6150ea162eba36a0d22e21ca0a35dfab8878b0a0c03b005530b088829cf425a51dc81743d75235d6c73cf46944ff0b9072926b9bf4f0467916cacea605981e8427d2e81bc5956ac242f8dd0ccfaa05d538547966930b2bd6127c338d2b0c82fc92bf27ad9990b213bf1382cf86d85a6cd79a45dfae35b856ac9f007626332bdfbae513245489b42f63d2144b651f786eaa3948ab973fa9833b8b48d18255be4e2ec9a1eaaa88175b13f456e1d3477d1d1a11833a00c01721648146fc84fb0f82279f571aa34be2f2028e5a0fcc5cbcc410d22a01bab26afeec5a2a7a7d8819444f92ab942fc27494c4dc65fd8379fe159738b251a621b001be24af131492fc32ef1dd48428bf11fd6b7541c8fc74f3db35285c5929bb841e83b6a923a251361c3ccf713d67d22e3018dd5f1ac1e4e1146a162dd3bf07735e8a3006ccf9157d226aaa35efde700cb5202b052bd60e54a60e122dee29befddf35f09ae55d505e811df657029002f140009e152546000faf3b756a24cf19fc319e3e9eb1f0d6e76a2d617e23ea796a56049e48288d0fc4c3ad35d5c547d6b3c091670e2dc0129dcdc770184b872ef252e3584a37536edd900bbe2428ffe941fcbaef0fa89f113544723b00e7426050c599550addb70f949a4bb70c0800e73bc6e67c49726a730cd9d1287c80530f4fb6cbad3741444226dde76e77bb1b5987406901c3cc056e44178dc0f21a3bd4e352ba216a57a43597fd7407fb34fdcf7eec8c15c5c87ba188f9d726871bf101d9b87e21d99d6a03c59f2e9b7aaa1c7c5e61c8b71aac12924113f697720afbc7b4edeaf328786d6ec683f1a8985cc58b994cb66a79725870cace96edd928ae60ef381a7c38a30ac7ab82ab2c88e9332624ae6a1816495c8d34b8fe4806c8a28169c0815b10387d28be39ffe9bec4adc5813d7754638e5d5a01d8ddf7315aa39930c914a1a89ea38d380b96d2060992a30c1577876790561903af233b1411f93683629ab8d80ff56445726ebd2c7e547fc54d885bad34d006f18f0fcf5b1e73f784742bd521dedea5f86fa376c0536875171b79d2f1896898b7153f14aa724833015b45d07ebb204f9de4cef61f7ecaa2b28cc319bb25074c70f2dc9f1a89920ba9434a50a5ecaf44f42a48ecf6d2b3e20649aa3834310196586622c77223d33f3d2075c90a5a557ebbdcd2240f37e7c3fb5f9113ad862107beab5853078c87c52086c58e8a53840c1067f1fb5c7ea23a0540cdf55515a79fcf6554cccf72eedab04b41501ae238a7f4149105c713443843382d94c095396cc5c081a64a03b931657d0b96d3c6609eaf77615c8947a1406eec7276d3c9459e9785443b0405d677fecb444c1b242a72f5c4a89f415f38e71602fb534dab9da6763947557498abfc6f8ad3ca0bf9ce410b0eecc57b2bb23239a82ae55c9eba30575cc5edf94b526ce6902759c7dd87534f4cbfc69aa72a0cb5515ae127bed74042590d1fb7382d573f133488231d6e3e0d87e79f955e7a3dbee42c22640f1ad8cb76918e035de6ef3f288794c061b12f0fc0b8a41273f576e689645dadc57c9a227b0d2c3c0bd5a4e53f3a99f2d6daad1e4bc76bccbf3b1304d2908aebf12018723332df77679d5b3fbddb11c79cb400a016a67effa79a313e625d1547d9c91cefe594c4943986c01ebae3522624f1431ab7485aad76221ad79231eb63ec4d69a3a019a8c142d207a65960251f1447b57aa62b6e84d071f96377cb9fbbe63511f6e1cd25fed185fab066e8e487276abf61bf9df90a1235a929bd5e6b968487b3a5091ac53be8b70007ccdd07b1fa58d0f616f2b486105a92e2a19746adab4af12d88bf8ba8ca6859aa062f81a8657086b58cbe4764bc37f2b98faa51e9534c019f8e02d675a1402ebd8bab4585ead920db90fc63c3877307b8e826ab7a85eb2964404d54266f59e28e2348b537beebc8ccc8a61ce07b7e7b0755f7af086a1c6c3ea593f908f2dcf5efee4cee62c95c1efbfaa11aab77e92f787a06d91ab293ed3509dfcdc4c5e67bdf6f55cd8770007e4dfbe171a8f75218677da79000b3b8d40afdaa892b0ccde770bdf088208b5a7e14768d9701c1af5cc82c10ae43dec5c2b55d026bd443675802edc7461cc856757c0509718248475772ea8ad3f4612153e513aa1fcb51a8d4ec6544b3d95709dc64636c94042b6df18186b59c3c9eb3ff3f795d4d2b06917edd498804e1c9f5ddf7306040a85680a7bc5a3e3afd2007fe89e7d749e6037fd165eaf10068afec9093dc405a759cecae3b2d06bef5acfce24a17e9b78edaf2c792bfef30c6eae6695dbd8dc4514d1ca4516fe146621e19c9b472f3ad3b1cbc138e761e602a30226a947b84c1421cf39a8b755f400a843d720ac67097bbb3210132850ca256c8a1abc7d3751d7f6d4ecfebc6bcb44a2563b484cb0dca1d156dfd8e31fee77d6940331a237f83ec5e1a7aa634b9775ea85199eb76ffab86ec782e0c1a874499d21ae31896625e49e19e8b44cd5695b056185fa7352673fda1ae2660abdfafe1846730c827c9ae35b51ffcffb0e8e27fe320f2591b1d259066e28bc1f1547f42749bf139587175310f8f37a7c5f459151c69f462c67eb84eaf6e014e0bdf5f73d4b20492b845c9f18edd15ed17e62e142148966e863adb82f6a885381a9ea48b43e8ef621f5e4f73c4a55761c15bb41ca8608dad052fafef9c1a0bc74d879ce768f15fed077045147f5c1606eb63f627da5ba6787d2fb32d9c48ef18d71251a0857b75547c6f942408a49be40b0625a0eff88c0856567a75470517dc853591f60ad80c97478d736e23461010c36a004d8dc0bed002fb19a6930ca51a91ce6283e2ecc13775fd4abd09bb7217f6401594f03363936d551a6e9f4d43547aa7e904dba853de9c6c7d7a6223d511b1af4bad4b4580b1580d7cd9c61531d068ea4b8cfea3b39876a56d94f51b881397b0132a24dd9fba7369e4e07dfcbb71935b0e1e3b64718254fc2c0de18a3c981db34f231775a62aa0484b4b889d6aa7ccfea267446f2678168a0a7d6dbfc8674b63624abe4ad03a42fa5d021e4bf13af722fc682081e8e4963b62b31ed8055902c1f4de91f903e9c42a1d6f7b428e11ad3cbcccf8d226c15af97a8d9cfd56e04204c2f62d6f79d155a328d3cfa675e5e96a167ad2a136ca41d589cd76616e6b3feb6f9b537e95f7c059e2353abccf8c1b74a5f393475284d212670c5ea487ca99249ea4652385e44bbe0190258a4d050afe3172e7915aec887e8753e7827f25a692fd08330aa8ca38ea5fdcd201ad710ca8ac031bf7e86c2dab72800c57094066acc4eb40b828bf2efddb0a4ca6dcac253e6dc4f67d05b11b7cc5d8d04a3b31a125a5644f6d6844495bda908d14808f4ffaaffb660de8e85be3826dbaeec8949d82e75f7bac2e3757c2369a1a684a285879d051c5799c7107f526a46aafe5bfea48f5076691221f896a5d13875e251083e63d0a902814260345c688b2ee156808f64d37d08d38f961c5de99352d36a26debd58177b43fae584fd56f3562e2e34ba17ac65c19957df6cbf8de534ba7c4ba6e86e92bae452a37b067a704ea0ec808bdf466c32449036e393a45009e7df022a1338b7dcdadaa6415bd972eebf3f36f634b5995427f12fdc50a30b7b4cafae288bac416b0fc2bd61b9d4ab31c2b7d25340efe2baaca222ed6f195050c4d07c6157a461d4ae8c907ac02baeb3db16ed6517c8be755ffc454483cf5e89e653801f6ddd12f809e3cc91716c5043eb9fb188fed26fa51b1e1b584d9d3ea5f957f8dcd9abef3bbaae5a2181df56c844a9bdc464d3d979b51599ab0bb7672e63c116b2240ab3daa2ed7f5369ebfd24090e764b3ab3661b6f2386fe581db0b53316def4093f94e4b1affa8ad105801e4c311b59e1a93776ccacea56749c1af50ad0e83d69ffb51bc78155a56cfec30c4f1350f0e7ce97da4260de769f6a1151768f46c18d5ed2792bc384a2c5e756a901ecc2dc74e165a05de0efccdc4b23b3a8c06a8285255f14ce99eb8200efdd2e781494dc0a1e70a866617eed8ca35759d31859f2eb354adac1f220466898df3e8bbe4ec321929604c18c11271b39e2c284b0b80490f54aae0d074dc765ea479130ec82db04ce9f989a7ea429fd07c0056c58ac158dbe98ed77770874b034e03e17c9f8f7bfdcc548f44c4759e380f8ec5812dce77f26eecf8b9e63663f090bdf2f962fef47aa27da476f7d2118c64ccad0f2357c9211a1fda260b96c9551ba005a2bf819ea2fa0194c0da4e86bc7c304d260f0a32643dc28831fd85c0c1378c8e0e6fedb9d979e03da3b3471eb5b1abf7be12dd5c5d6b22d83ca720664b8fc14c9b45bab296117a911bc2df0ffca00f913257de3d976af609b8985c172f4538fc1d1e201fae741c7e5edea3d2a361fae30218445d774833c64429e688cb4f2a69a1af376ab5509f17531150cbd207fe4bb9d5dd548ab8d8a22d5558a97c60cdcfc7fc9551b645523620ff750e08582f6ac4e2230275335c34de13bab377bb05375d64317a6eca0ad92734a5253709bb6b344304a281ff80962ec659e04a619798edd0203d53e51a71806ea032e12997f4d69a6f1b3a4ec804b379baab75710e1707c07defa3156cdeb7f0be24c271b5a65ae072aad1e7838c4676c15f302da36d54e64ddbf7149e367833908d5c1f04766d697d6922ee3a95cd98ab5219985bfaecbb9d550b853580b8a909b85d0df4a5915bc8730bb884a8dd66396ea3e399589080ae0633f6a45ac8f154fa4cb2a751e5aa7d90b996b70d1b1279103d3d9df22e3d2a1c4e065a78ba977e4f431166a7b22000608124f089acda09da046cb3f8ef0700d67603d8ccb6a2e672f745ab447a1142375a590141cac205cdc76a207a093ea81ad92476de61d49c8d81624828081a21316a3885d71436eae2ce14c6d80011fe9f6cf9777a4b6f7ab8268798cfd127e8a312486ebe3327f2fb9621c6024b4091dcc7e7f664d9e435b984cd9bd262facd3deeee44a4fc6b0279e24579138b80cd00987caf8476bce1267e838a0bf21ccdb402ced681b3b12ea4ef33ca6a5617bf60f42d1bbc4121b511575d4b2cbc9808d3ace34355561347b48dcbab45e5f565a40a3b0feebcc6c06ca63339d9f397ec4ad6c17402164797073bea90c92fc1a1271252307082f54b756a5f1ba6526f80c68ae07992b99e240b8bb2dd62397aa05ff1d0454a9366a50b565048b02782c21577832f24ea8ae38f70387a368c73ecab75faf32d521a93a0450756f6530f3f752d60bfa1395d4cd423768fd9edb4dd5d0edfcad5627997ea92f4d0d19411aa5dc1e8448e8b02092d5ad2e0a4da689b5d6c7f0b96f1a2e91fbdd1d688af1eab8064570ec24864b7341e995910aa640db5ec465bd67830841a5f3d58ae844486284bcfc837f6513fb92c8775f0fccb34dffec6e19633150aaec7ebedef66601fb6e3846365194184d1a6a0e590e505a6b312cae1924829b2cfacd31abb2b2363edcc25085789aa77888349e6768352f564ffae657b3f052e07c8a75ba10d713d7c56e1184c911d0fc4b4db1e2924c0a02530f0c0ade206e4970385c97609c1b5dac49c9db43d17fce934c525a8c8ba9c9bd9e4ed107e5e6429ad101f9bc96cc9fb813b3055d9ade41f95fc3080bc540039c9a458c60e74aed63d911a7a48331546fdad2f32477d041bac88542f928a839fd050cb54586e995d21486afa1be107bf3acf38d47ba5b412cc4e59682bafdbc214291fccada9229c20941addba45261667756ba12975424eacaa623349088562206fe750fe287e980e33220898c8364c845a1cd448123959dc4cfa00cdd8a5c39573ea22aeb1a2af5362214700d6d159550843ac40557dd29c1dd0b3ca25f202bd751da1214919b4db6b22d101a64bc4bb49bee553cb102df4559ed2f4bc5ff9d5de1f11c8b1f2450903e89664db28b72a73835cf7dbd7daa0062a5561ba7f616d862664e7929c337efa35996a6cf53c5aad8b216d06b06e88fc7fcbed74db36bc35c937ae6f43cdb4ed2dd51a1534f8daaaabd0b53daa2b83c3f10494288f4dd8ec4f8768c92933e9d134932ebf67bdb6896e5a520e6a74212fd47c2d83ce0a0d57eb90db57d4a6f47babe366249e081f37ef147b5b70aaf98fd8875d079dbd0b2abf1c394d2277a76b6245d79a04839c633cc8f50f043690e915541fddd3dd16f92017f06cd91bfdc02f6be1151362d8bb5595ba7629cb67d6eb234ff9051b77272aea3384566c9673f2472a201783005868e2336dca98c6b8dc3d7606b1f89ef8abc154630d329deddc654c029beee06f2fccc4e3833926d38b8299fd2e5aa4a908ba3db8ad9448548ddc4187083601eaa15c356175920647d0a1a63422782f3144d1f5ac1a7cc1c6626c8baedce9f9299ca9d4ff8d2b918f1b74857f98b6881d4fa0d64d4179d179233a185514eb1569677ed94e4bcac6e479a5d07587012969994b0ecbab58440dd6738cc1f39197906956fa024aab6aee31698049dbd9c91140f07003ad43fd962ce76d9d12f23177f0829193dc4917c8961311bb76543f6a80cde78bd25fbb4f29e42a2944037376fe0b78655d7a938e9ac319dabdd72cafe77fe1b116709d094c48a71d0226d92ed2337a900e59d72f4148f183399ae23aded85bfd1742d7c5159cb9c101dadc2e81866ca8074a47f9b3c83ca797edcaae4417f5e63b739b46dfa86717ec388de9e220be8a9e1a10ecf7c41e01e2922b5bf0d5ab0e5027ee64c0fb1504528b5ee5a99ee2d39e82f5d467e488ed8c898d6d0c654b8fa18a2731fbac77a10ab4bc1d8af1ad33e009dfd1e78a23172dd1570242779f8aa18c2fefe5e9e39ed17ef9137d736431fd2cae308c213fea9f1941ab2ec1ceeb9a285ea11396b976868a08d3a3334ff0de3b85f1ca823b8857ebc5a693a1ea5b094ca1a7fe06f52f860eefe362959fbb5da1166c348a4f9187f8179a81d02d6ce0639c0a206c4c0dce8599db7b4b71fd83e02f6b0cd05fbfdb370eb9fe2bdfee7339802db2e85ce6174c1fbab60fba33bb1130d1323df2d603a47f40b9fbbc05661bf885538e3b84a9ca369e866f68c4ba62b4519b84019d3e7f246aa2531650f40bb731bf8abed10a95affd8e697376a3530c10f262dbbefedc91af6fbcb4c94e07efc0abb45499991d9399e092538adcef883809fd8796291e5e2d1e39b2232fdf47023e79976b327809b04e5aa18385c7a20c745222ee962ffe14b47f0f41ecb6fa061417b12e8c4d88b4c4dd966c1c028603b4b0b23a30ec64dca3b7e0560466e633aa54d05c98c26cc5cc07b35952b95b5d7636ea838e06e5ac93670c3f22456803149c69db2f2d58d24a2b4091279e4bd3a3310b742a2582bed1b3706c50f02e91927234a54ff5dcb2fc4fe3b638efd540fba800694268397d9fec417e9cf8d4523ae4b1c59955c3f54fb6f9eff2b727659a7291c9b4e57c746201c41be1ca5ee64df18f2b3c90f183c70b13a34182ce0b52bf39d78fb5cf8e68ae7ddae56c75b413c5637c1291cca2d82cef161ae9fc0d7084f0056fbf0718aecde0f654b4b755e4a1f9a775e6d261cff18b354a913a3a74c160b3f9d6b9d53ccb3abdf8679726644fe787caeb843d2cc2a5d4aa3bd6257638ed1efaa9886da29fad1c6a30ee81cc92310e26fecc6acf786067c531d38681400450f254951c83106b57390ce5f5f0cea7c9be38e59fb2bca1216a3ba9575a38857785149ab84b2ed36c7968b200b77e760d9d9c000f532aeeeff18f7abf488269ad799d81e940c47d71a9f63e3ba73d885d6d5097b0ce889c12349e633c5ed4a27bdbe053213e04b4f42ee914113c3f6ca2db78927bd7a3eaa2d3923c8491581649bfda7cdc85b2503aee7d8e6c3ade7e39cd8622abbc1ced1b936d438f3b6a65433996604392de895dec9c78075b96588a9d3b77a8f5b7e4e21ead403330f5f8ec23e2f70469da6c00b3042c4e0985953de959d8acd32e965fd750a98b6e825512bfc9d9696e1ef3cc6a0a9973a98725eca5fb2f89f92a1b275049ef07a90e360608c82a7a55129cbf29b1234c9f9ba9022411a94dc06a3aaff4d1ea578dcb2e4e0db632e6e6a4fd2c232c646a3757dec6a8d60d575d26b33880b8102776db0d2743131738d9c2030672807e5dc433354822e2c1a81efb4c68e844eb285836fc98679a60fefb8b783bf24c0439a9ddcece9b1741ff995a3bbadfbedec57fbc8b6cd75de7f662f60928fe44c16f050e390edee0dc75d29a251374b2f6311d14411b356ef982c577926e344ac2d6555fcfdf9591edda6f74fb411d700b15e5aa8ae70601fea365a0fdef8b73ef3b67aa39c13896072ab62ed67534503acdd9ae7dd80055a8b1f5eb55bfedd61f97dada0001fdf2cf0c9a17e4694f26795d1739caf7023811b61ae02d17feae0b406c21c863e40128f01c99e5e6548f73b04b90ed72ead62f12fa8713f7b323d2c9c06a85afc5a443e36d43e1d619c0daaeef32887e7c0629664a095861c7c1e908bf0aa7052ff24e8b15e8f68ec1145800bc372b0a9a41af444fdd2dd1a5ecb17ca9df44c79255529668f1439db5b176ce4b947550e0b41e4b48f78c5fff04b46427a57d32b466732b1fe9a3f49480bbc035ec90527b4314da93f951373aa08ab8e958a8e47663b49945239e390bc818fb520a31e4263ed543c1f5b0fbbc736089489d271004cd8dcb18148a3ec10fd0ee23a63f3da9d89e34f805700255b1a34be422f83d0995d42eda8834530c7f5adab21454dfba8c36ba489e543b30ab863398adc62544090b218d7a9d4442fc99cb6030de52bd5f5d97358d84953082432bdaa17dcf65b3e737ebc2960e6a7ebaa4a98ed15915b71884d3b4946036e52cb9c2373c97480153ac0a2ac480f79bb6f9ac344de1f56f9fb2d223b5760e73212a9bf5023d1563cef4555aa798baa940f163392e2e7d97f74bd30cfdf0853cfb8a2c878aaad71392ea25cb2936df38d9981953446f85dacdc7206e0e11e6d406d5724a9bc039573ece4445e4c70744f95d4c3e1699c389aaa2919d0ba993660d47f8e48f4514dc2e308a671f8c02fee8071ce36a3a2fd491c47f2f537fc0d73cbf6f516f7764ab1e5493c9b92a094c60199db09f86cbdd9e4611d7305f916bb6c9340a434650155598e7c2c6c707c136163730f88d168a24411dada43c1866f21432a4c5a784029d7b119027f3b4f60b27b38f9ea13da0f50e58250b0f721de04c11e0ce13072d1961b37b6715e0ee302a9f6a51f0e5541f15efbde0441edcbbd6168e6f3ed0734040e9383cfac8798428d5e26c3f6e9949e00684555f861678915610e7a8ae734439be8a7f98c104bc69ab59d5b45fe6624577604f3daf13c1f3a9cec0d179ebe500885672f7093abe84568409b71b340ecf691980cbacade00931dede9015532903e3f50cd21540e239dede5fd5265feea214f00900473763ea7b00ad5a3c08d04abc5576965e88d32bcdf28cf807548dc583cdc2af9d98201dc108bbf9d8ab3e4c68bb9c984b9f72f43da326e6b1661e848cd1bb094c767d87273f8832f55c3303a49b3ff592d4602aa5dbaa0ce425df27cf537318761cfb42887f86d9f5aae468789bfd46a1078e0e0c07c79f595c370648a55dcfad9e2d95aa5586bd1f8d22013739333772ff7469f826c0f494d1c99eda68133595167919a26b9d36fbe42b259cc7fdba48bcb473b5ca66d97b2a8992bca665d1a0c097762098da1b8a2e1bab76121da99e1ca984e65ebad3a82e1b1e553fc87a6b9ace47db3651d19acb0a7941953274b153bbc16b1229c5df4821b044b59ce815d56805d5c0d574e66a9892366a8f48c4af87d46f5c1772b33e3aad2ac6daee176af0bb74189fb0c2d67623c650d28e6361782724d7e61e1ffdefc488c005c8cc965e0abbeded4fb5b45212cd068e33c98f199e6540bde547710688196b8bd05dc32330f98ddfaba11182bbb63f984e5a80bba91bacdf6d2da1dd536ce272a87b5b5810e3977f6e7235a9719b52cc1315dae88a46022cd727f5f26d7e2c9cb993539c4702ef77172e61310a54a867bd8d4d13b0a7ee9faefcacb8e9e558dfbd2d456be81f66caa7203bbd732cc48619ea2c22ae1e21d3c21bd9cd5f7acc5502cd11ef55c6662a5f47adee0d7fea6f248e90f846fe8434376a3eaa097d7838ab1fbc6dd5df26e6ca2fd593877458995bac3349302e3e8aea32fc07dfdaf4649002932c9af3685f5d7bc5021c4fe1222bc1138ac667a033cded0d99e4afd211b3af739c896f4ec712016253155c1dc406b05cf99a658c9d28622a80d7a574b5a02d12ca1b4950a7335c4f69c30af5f538c1fece773ce53397a3e07318f57d5af527f0601bc6743c8371641bffb05a97f1d3ec0113bec16543967db39321fa8fa76eb27713f85492f39ce8932a68d49065fabcb244a38867b166efb45ebc92da8923549169e967e53ddfb6461a0d8faf19b23802d4ac959e514aae6db491091681054d7f572a64be616b4acbad49686bc18849c7d03ac2b00708468f6c7f12a30e25b357ae9c2600bc6f7753c2549b57f3e4e27d66b9f72976c51df416f87aefa9f033120eb7ce6874a51139802cb76fbce43aeb93ec2f05110a0161b3f5e975e5086f2462f076ddd5bd1187b37ed4b5974c88297833ad646fc69e790addd894d524ae0eb5848cfd4a25f4f299215bb245279800d741c8398d80aeda359b365fc173c21cdb5e8ed12b679291bf1a10b3bcd883eaf0e8fac57860b8d12e46a7cf2d0bc418c5c02902a10477fe10e48ee752796e3e4559310a237c7362cd018de86b3528d1a3f96c121a99fe1f027024269853e60672eebbc461c95f7c2544d9b7aec07b2ce4bc5dafa28112ebbd0cd790eb6cd3f26009ac8acab5680bcf67b5f3912165e8a7d3aabf5bb4f9ca19e4d8913103aef9290eb406d320e5e366c4fb4ec791d2bf89ebaf6c3e28f5cf1d02ca4b3247c413769835aad5adfc42df37f4857c7e9710aae245bf78d9b4c4bb43f7b457e49cb82ee8c24764e8857bdbba866bb505f8ab0cc2f61b7ee8de5e8bd023ba37188deab470602010abaa7f186ba3a737320521d9e837fa3f7a2861ddc4b544c824d8fee307afa26639edc0f3413bf2edb2e8ca707b77b0fbfb2b95dfae7395c6b88b35868e9b8c915f29d506398c702d4d3492274fc60de0b11f9c5118154757802b2340412d8d4ff873653ef93ee68594e0f53fde11781b66ee8f1d3167f98b0c3779e203fe4112a2fef13000516d9c77536b18a4ff8bcfb2b01c5a11be65e8eb657f703bd70706653473f12d8f3e2ed3a85f5e07c320f9967f41e9684ef18edbed71ac2d1b8fa0a1596a568a4a4a2a76a4822d78f54eb6a3506802f2fc66501edbdc3d954a0d5a96c1bb316cf2044d8cfd24b5b0f02f3b6c03a438490c4bbef8383618ac3418c33b95e9f7202b2056d93ddd67d2321776985b2dee58aa1c6cb749ea6cae2c0ffda3c7d419eea2106060e721b80ace4804fcc7699dd45c266219963ebe16ec32845e073d8850d74ef11126daf21e9921115349a3f67a385d51ae234ab007a5ba667f0849246df385afa05dae85b92baf505ac4347383c81a58c0dc727e0158a1403cc3f610349ff6bd080167a8d85e307c87e6051a308c523e06d26c3fa916e416517d86f4412a28caec46b58b86f3113e7f11e8dfddc5c108f38ed19cceeed34e17597ba31d4ac194fa858ee1c7dc7773ea4883cc536b62bacb725c794a3458106c76c6710c4eea7f2e589ff4b368eac560451481f7c83a4d6a3e0f302ea2e5f2a8036e5d95c88f2df8e1d243597a871a4ce36f9017bc4cce7e9c5570162e0b2642ec737d446721e5932854cbe1f77c9924290599acfaf2105f97c7a511bb145191fef12c1e5c0ed4c5cc68764cd85a6916aa2f240150ca9a08cb7862b6db2ff4efbe150cafc15421da4b45c0702f7a9575def82161afa46bafdf23573423a4247b87d264d487b5bd8e201711c7126c56cbeeb07e55336a56a3f8a79654325c85e29be773261d18e91f82f1c27a3a925bdaf611ad5e4fab4ae509269c7393043a12d1909a9f9f9046d2146520aa5e01e754176c5e851905f566cc10922e189c5bfb4e6f4eb7db9f8145e623d83496bce54d041ef51dd63cfcceeade210546b3eebf676ad4f6ff28b7c100783c5b68b8c5e6fcec9f01fe96b48a095d853a8e34b9441f5e5a4dbf33138a55c88400f2174615d8b1e6f5e4dccf58172217ac0ccecd509695eb744c96a5080a56f0b894f8fa28c9cba8ff33a3bbae891032401de0261dd0a12d0eb8d5f9d1c15c2832f263dcc10fbb8e150928b0ea33d5174cc71757ce711de786b68790b78200d3610013a5133e3436cd3a1d9bc321635913ed830f22214d646771fcbaa46ff26b489bb9fcd0168383b3e83789693fbfc264989eb4dac5ffc39452dd61735289e8ca72b7648771ce3207b946e7b2def6faf47eff8910a055efe50ea9569139638534508b538399a2aaee0bfe6c62038cc6e926c24925a578bf3c6541d0a1ef45e51a7198bc16bed53c45f1dfbb2b5d3855687d6f8ce1a3d3edda84af182ad71f49385bbd1af6f4921c89255ff58b126aad7f9fe4812c797d7081df2fd2eddc090676fe8955d52f0f54cb31f984736d7b2d2086e01801f0f4776ff1d94267a1351250ed10701e48573eb91ed6a593b2fbd4e8497cd6f426d4eb77ea9b3335b7f8f220a545f61817b511389990204ca187706800368e837c12786dc97bba50398a7200cd4d8ac2c3840f393581ee4f5d61e64d938190250d2e2ee7ea1807c758d29db00c6a699e7f64ff96a7511b2f187869dc8137c60b04e2d14d959ba8eca6eee0ba6ba7bd3abddf666229f4c5702988e6e294843d1bb240566f7fc513f19a7dc40b45d21765652f0f2473ce6d5332e4de5cdb0308d6130121bff622471e8d0f00ab9e1be50fa08a46a43013d56d79b1f1f38fab0e3258b36f94b43be3934447e89680cfda290885a39373010a883c313c1749a1138d307d659a88819dd32a8de75c7f6366116320b54b1356f803ca0bc8042a5cdf119b20c1f4a9d411cfd502969c013279b7e20d271d06a7ca1f29ab6f4692f604e4faceb7b4b445bd20fe8ba751ad3ee67b26b7eb49638ea4752179f6afc56fced0529d15c82687d6a044e57a43e0a6fd287b924ec53ab6c2fb77bbfa62ba2c6b66ba80d86d8f9a4dd8f8beff6cb1ef0b7a8b9d3997b1db508663f3fc04541b13f000707f9855ed80f9e87cd8bb2ebbcd81a487ab1fe80072eed362e790a89d88088d80c8ac3bfeec3f752a38eb7c6d5827a08344a02d7fdcbfd6dc673fa93fb6b4a3316129b3cba53cb58eea9fd5e0d165692a4895fedcee522a5a24407e049647bfc25c3807aef986e0528996dfe0762a471b0b8cb0025ec2a2915edca133d492c3c45e3d553e10fc5424c97ed7de408468be4237261c1801ef145fcec49461bf04e7e36e21e5c7f3f771bdaa87db8aa686d1e3ee110b219279ff1265f1b2420e9582b131f7c968d8bbafe96b056d45550b53a7226f7fecc0c3263565e853275824c76dcc3e533d5bb8595641ea6d953370df74d0174b3b591c280107690875e3e5a13afca57b0bc9245860c58874953049cfd98510045458401d4f8495133ed0153e9ce50281e48e26060cce7d2344721bdd87d228458fff407132aecffdedc7a7cdfbab22dfd11ef3185b592064f32422720a2c2c69c91c5c5302a58cbd8e8de28d6680fa7c3025d57b6d660e88b2a7b2446f05ba0925a1cb602255c1f1451aabafebd01eadba7e4fb51e2a75d09c7bada799b13f0a414ba1db3484bd74ee9bd386c72d0b74a0d768a8a81ee9c1bb50994cdc8ba27dfe83c2012083a776e503d5667ebdbe69a89b3a4bed973e2d5d26da944751ee7236966eb75df50da30e5b17208996ee0f8f8578d0fc479beddb77c7410945acedfd27c304bcd770e5b96b23584ed107df82ca92f22158e9b9ab5bd94f2e93cd5cdae136d5cfeaaf5e6f1eefa0680a3516d619f82ca8546e38a2595032c3783cba484378b7417d65ce3ba5e285e00235774816d7a91f324637a26745f757b8562e3f2664c3d235f69b4e34e899d26acb12480ac5cf3160dc51f205dd54b281bd4e5807b342c7c75b20079be71270da60583b62c42a59c7f94d2ec051d5ba1f40afd572a0d82d94555811a98eaf2082814d5a405c5d829bdae7f0997369d78a5a69e924a89123da8e9ca4ee950f2543c19430aeaa2b021823aff4de5f94fdca574e69db859711e0a7352113f66035ae31d89f2cd7c8a16a574e8d3bd85112e5a207aca83cfe1d39b99cafcc7084ca00c3bfe9d0bbfb56e775c90981a05ba7ee3a73371dd2b28d4f6fa146cde5451b684555b8f4897af123c9bcfb24ff51362c1f4c21b0eb771942dea84017e9fd7179fce4b76d6869d939c939c3fa074611451198999c462ede1ce73f0021f8cacfa1e554de182b2a3fd81f66a6777838be49160a11cf7bafb377ed22cd791eddd0ae833fa8b8db83515572ebb91afb857eed704a0ea13381f247c27828dd8021f193590cb95664967eba52924f4de05d43575225b615b436811e2aa93fc82395e107b428040a71b615ca0d95575eaa71a1f38092e0e64f6217084ab7cb465c7e3b85c6591e88ad4a6c95916021cf017e18c7bade2f6efe6dca2b2746a95add9e746228ef992b00d867125563f4f8f91ca711787612f3e4148e1bad6ef920c9888570db0268d9dc11d9d7f3b93d33bf567eb1c74de7f5400f57422f04d3ea3bf7299db10b234183bd0f9ce487b741147be6a4dc005fe6d346203d4dc01d4207da0754aca4c9e18fef363b3e71a7baf0feb17c37cdffcc6a86f76a873955741cc5e19705860d7d1413a44a1fadf4e30f57ff8bfb07dd5e9d6a3f16f50f8000892ece44e3975a27225c9d9a770554f991e474469ffcc17db600c742425555bc6a8d381d1bb159f8519f97716f7126081d3f14d5ce95b4caa7ebbd323485b8f7c34fd1b51544cd1e9b465f6722665cbea4b8459c15873dfbe2c31a6674959ba0a970df631fc808dbe9d879556e813cdafe319d9d9ac9d447ddb99bc63e950069c84c548d01c431692b6605843dd7f797b1d30eb55d829d806bd77f8b947b5ba83fff3c79994202a2f9847119f8e08127238e8a0d0d4f85253f0d9cebef8d55b50f9f68cd097484376d2a74d43bde63641ad1d3079afe373227f6f42dc5af055c01f1ff3b41c7697376cea03294763a6c210c077848779f029fff2f904601fafb2cf1a87046fa13d096a977f5319dbd459865ec6725a1f214a34bc07fbd810ed4d05551a7ad20176a6cb709f461804a01449eac549fb22fe8b71572fae3da5cff59f26dfa9d5c778413399a847570b50a3e4308e71314f52","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
