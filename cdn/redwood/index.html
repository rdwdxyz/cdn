<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb3a0de0122b82d8e74dc54533ca9137b70b28d09f30f9f6dbfde6807d5ac4fd5703a480ad36b2e286a095401913b442c19720421f732e192b8e0d94e28566b89a6ac0f434518ab8293cdef9cf72ae9d2d2dbc6eb67bbafe574d1c7ded986a564f82d25eeb217bff5b720c52200f1e67b7acfdf445f9cce3bed36a2640de2a83d766a882b943e4b74bf4db6ee7eb9da6c4f3bf46927b94ec153b458066d4e15c992a8994c2044d435dce3469c2bd11ea951d6058f74e4878332e06f468867aa28bced19bc827937713930c0ca0500f889eff22d59304d26e1ba0deb82340becc12d7e90a84ebf20c23764f3fbe752c9e078f930bb22db294db400ec3b89c8ce950265a338c1ab965bd796407f0e5d252ff654d4d60d7bb5308e3b0288ea126c2cc2923895a9004440358412fff16bf693ea4d1f60ef840218232fc8bb8b207980d60c460a24688925bc61646cc4fcc134b3467dd22ee2386477e03817e89428d372cc2f8593f80eb8bde4d515995d1bacba525be68337034b735288c3f2df2844eda70e68e0389b07c179022a340eb0bb522d7a3cbd69c57cc4ae6979f263388e2c7cf7c8571032d6533c8afab823f7162624c304f3163ce28b9b3ca5b516f6ae140e85b957902619337f40bb982a71dc2a26c4212dc1561c9560a75fed7f49aa30f90c4a306644144cfbe5423540abd329431a11f4aa144c15fbb9a7020560852ff3e1b83e56962008c5ea61771a71246c0c803120dc6200b8a04fbc5722773ef2a6384af97716be3e55ba6b869162719c0caef16d91a41e3a449beb1a1e331908c79b89c4999f4923ad16e0b650fa13fd2fb14ca44c282f517a3530d3f30ce7b4e2ea5a942a3884734db4f144b0eec3a37e9ff4b3cc5bf58ed7b31339a91b61f1af3cc13d31f9243c5bb689ed9ec020f6db0153e6bda9a760995a5aae053943dca24228c26bccd7a21430e1778d610ee8965008e54bc7a7c9e61dfee84bb1032cda5f9be302a4d90b521f40da4a0ebb6c29cf98f18336e830ef8f3cae81af0c6ec0939e6fad3f2db413ae19aa7970d854b2afa029488afddb29720d104511ab39cbc43e52870c460631d4bb97ecf7e70851a0ad8f9552b41a140c5c522f20f5a78498b7d3f05d4b9ab8d1529eebc790c6efaa4fa3c75d7897fd1ca7b2e6e7aa7a15919769f1679c185452932ea261340f71734d9533dc9e5f38a87cd52901bc551b25e0e943afb9cbb008c083b17ef44db655d15fd180514f2801d0342e0a3f8114ba2f2c493fc8b82344a50a6085fae18f713f707b5214995bfcc8de5c599d92720467ddbd61d5383fde10700047cf0d80912253cd4d55e3dbaac7397000382baccab681537bc208283ff232edee27226d0609d58aba393d00d5b72d8f5085100f12b05dc0d7bf8774670b003da049f889ea62994f0b7ffbcfeb7bd4d492f2254d2ff0acf6169dfdd67c7a09fd5d39db4464c9b5920a5db9111a419621965bc79e4ecec6df011c9b1c7212534f5ea9db3d7680ec0e4a87b8182655895ba3c9cb42fb0f1b9bdafab183b36b3c52787dde41fda5adcd6f72b9d511581b814d0f71539b07bd4bbbe108d3418340d66157c5e0da147a776bdd58f8edb088dfba408d4eb5cdebb802373969812c363e594b80bbe46106580b3a47657be723ba7b44d4b5d44a0b6ac41ab7c5087019aa8ef26f90264786b854bd389feaad42698b3cc36499c5061cd561d8fef864782a83bbb6c6ef3c0f9b08893bc05c0b38872986cf353b19e9c8bc4c61b387ce47db32a6ca991a20cd2e01074d21ea7c3693fdf399e393abe42059c4be61761cee86d5313a26d297b54accfaea3398ed93468ae1850fd2f61ebdc93b675186d223b67a6029b953be63c0c29e2ad7718f323e39037f5f36feb68e7d7713e9f417b7dfe2d5fc68451816e94bca9fba498616859441185804bb5a551b918eb99ffb8777e81b7b6331b365371cf8e6e857c6592ba5a41ddca419e3ed53f60afac93b2c66b128e53927406267a82798d482523f35ae5047d9974c624caf5f41ee5fd94faedc3f788f44d68b7f3dee87b16136eee637e1f2deb76296d89d0e069727f3e6d9fba04b78865b57700fdcbc4b625450e5dacd55514ccd11471019132d82789393cc93ecaafd7dbf4dfd76553887f7608fc3c371bf17df367ff41eed4be3a5e9d9eccd05010c3293951b7fd6c960e00221998056b456eb34641712fbc15770de2f4ad0af2067e0a325353e94a9fd5cc66dfcb406083ffaaabf385260c543820665a964a498f600630241934d36d7c36999a9b1ad26d7b99b007c8927c89cc787fbf0dd9ac0f80f8469a48c970d939cff1c7df12f608f4ece955ee09fc712c1104adcb115cb8567b12a4ac0a202ff717256704b6df9a15b42da1d9057356e473250b5a5ef7fd37e31814c016deb287a9bfad5f2322633acc1611063a6e1a6f2ff668aac666b164e75bc28d97d6bb4374a78db984c09e0089b10e15c2908d2dc861c53bb092aea18883d5c76e611dfcd6e56a1f7d974d0c77a4b19966f82c0d55d6539cfd9d915719e1b61238db1c64b62b7aafeda3e3650423b3438da9241ad9cc3afafc3420c717c3581f47dc00268f649b714116c3d0c6eeed9383ea71b25659e8630ea4c22d0f1c7115cda1d8469ffc15a23b70056a09a147daf6ed656dfc7afcc5355c575450440b53ef2ea136d3b19bad56a9eb394139dc7c90d1acca36173b82a614b63e1e63258ac89be93fbbd08d3f727c45218eca5d8ee6a579dc234777334054556ab75c3eb51e20db7bfd7b829890d37dc1ee7fe51bceb8a3abfbbe34b6e703e5f541932abbbbd2dfbcb35659dfde033fac8a67715049e9e9db72ca350a70e16f8fb424d98dc5ee371a5214dcfefb437e1f45f1f450c8ea782c87bcf115de0ad4bee10106fad0f644795686970afc6b4b8a56787e6212c8f2075eae3122e6194ff5ec6575164e4a3fbf6c31d3b7b0d50e800051922f60b50bf69e08241fff3fd43f3a1586f688af4c7ff1e757a93b5d5db885246b93702e59844ade893ff0049ea805b330555439ab4f20ac91d40520b5b2f0b2abad4dc0d7060d38bf5014c6eb07ffc68d33afb880aa2aaf44ad367f9ecf2e4195d2d5d3be4b1c3403bf778cbafabaed46f1da9ccf6a77effeb4dff3467248506d7a12fbd0775445b1a3e566e4b62ad2d993fa600514b4da6616bef7e647828c42cc612926a90ab795b9170bccbcd43e36a6c742d3a93b42403acdeaee55f54a1807b17db11d28793e26fdbd768cd80a8d624376e4c0b6a524d79acafcf576f797ec9b6bb7cb9472b48aba9cb5a45051a3ec93ea801a50ff568986f8491fd3fdbd21acfa23821653f2ec73c25ce74c5c750ad4982754ab96f02f2fe296ef46c1c960f94040c000b7e93c4003e55b914b7338252b663abf19444b1f17891ea7932c687cd077543757cd93e0440f719026e0b36250624c8f22c89b3e6d8e892f89a12bcbc85ae62f3102795420edb8642c1e9d710b241dadfffcd56ea8a46d58911ce7c69126fca4d1b2716445b62b9abec8f0ccdddfeb92f9ea584473478d11ae5eeb65dd91c28f8c8d1cc642a195c0d53173debff0258eb57e74007e91e6ffefe7508bf8cdd725bb2dea92c9b9bcfd36b409864e973faa8d98a5dbd2f37a220f452069b550c7cf73592e74f76d0a3715e244d92ca71f077308177c00e56595e69326750115f2d74a52b4d39932bea679c785d4a7b9c49d6b817adb5306a7c67d1417bd609c5c1f91107cb84df0713746102ecf234f0cc3c3f902065855250205416f52c13044861900997b98955d1d998a63bb99917743b45c6caba4338e9916d8a3fac06181f8de2aeccce2b82ad18795a618cb9d1e0ca462549e9b12c2f7796b17540327dcc3ea45b6eca2acf0e51891560dbbfb4b4d76250da9c5ef7162b1b70214668d7aeae5a93629cf4ee7f1e398d299a72b9f910a8c98dca92b5b7868a5004edee9ab45a9434d1d75963cbbe34c4e73b5dc6536f7266839ab37d32cc92bfb82451c64bb6aeadab797bde7da584f883d201d9e4628f754ade700b5e798108e8522efb017d4b797f9a237aa1c9411d9d61bf4be408ea7ceac29e17292ffe050add3d61e55d4be5acb2a1e892341526095c2d38794548bff63af98d64962c82d633998cab0f8d588a397f5f6798fe42dc0d4d3763f4f0d61277f43fe5b55d8f763fb16ec692d8c8e24386e91ccc5b3764e96da2fc28448bf09659075138d6e8daf4c90f20f22722ba0c00204f399eb0437a0c946dbe4fcbee68ae29e0521b87557a33033426e4c4cbb7a84d28b8ba8f74d96f51176a3107a28e291c38c94db90a3981874a71782cbe1cb9d536402aa14133a5d070f54cc4510b6834ea64142d633272dd722be54702476f016ad52d9f926e8370f50bd2c4c8832eecaaf3f2e01b4e37e38c060658c4776610aad406204868b30c5e1f3c83c6d2ddc8b5a3b0b29fb7a7810b2bab80393e63ce5507714f2af45930fb713f0a9155e22b99696ac82b4aa587a2a640daa02f04b331e55ed4a9a518e06b7a2d8892f03c24016cbcedad96f7435985192e96e1d3425c6267e2edde11ff9fbe35b3165f3a56afe2e91962b4a97b6e853153c421c753faf8bcc555b966cd2aca818bb09cb35a7ad2a2f9e872b50b591b8b2f47aae681c0eab9b62a1038ca3fe666b23d4875e25307cd80a30aacf39d6538531009faf9759f5afb9de2326071f53661b635943eced6efbcf8249fa9d4017a3868923298afad9cc58c633784a787135cb68ba8db212fd5e2a36d94bc1e9fd1df11cc53db57b1ec80d3cd060919ec8687c6be5a24001cebf280f484bb30374cf5346503b9093204b08dfef0bf4bc45f54bebde7cc9d1bb41e30f96abfb8c5a21e1afd157bc89e4086728b8240c122d2217f79af1fdc19c8079bbb67a17a3c5b7cbdb2ee677de6500e62957f79bf2dfafe7947be6cccbd33ae05dccda79ecd6cd44754809746d6516a06ea7fd3e5f16bb90fa8f5dbc1ed0697b0bc5df4f294e28984cc7492f9abf1772ebed0d657407b0701ae8c9d7f88c455d2b8d0f5159c92c5f04958d047416d571b57cd36cf803fe29754c0dd989e6ce4f24ba82380421521e27dffbbbd48142a954192e888de92d62a3c75266ae6a38b5fb6cfab8f3622a9ceff6cde235ac3269aac4d90d5755f2f96fdf8d7e7f5ed81c9e4be6bc742e47178d0d109d94ccc90169f2c57bd05fe41c6d9622008622fc31a2ed14439ecb755a92121c34f01d321951df537a7acdd34c8b3fa6446076bab709446ce0d14bae6a2ea2912332f9376b7f321467b802a98ed6883857328d29e3e4e157cb1b307b240366a3b70a7e02dd5f0009e08a0eac4a4cced83a2fa6cc3b9e6d0e744fcee1a000f6967d16229b7d288d53c8224477a5c8aa4034384bee0b7e4f3a98d829692eaf59a820ff529dcdf2d78f783380418896ac7920a1693adb731afb5d823a2bbbb5bc9229d45342a6270b837dd33ab1c71d1450329aac76f525e1bf9fb174d1443f46f551439de82221b900ecd17d4989099c96f2fe62072e369eeca2b2559f42832e91acc6c0c04349ee45a2b8d28d2340598b2b34c8fc2d8ffff2f7407735321987442959abd770415aeb4532aa78cae75c996b30e9760be15ac2f4fffa74ce7c911a16c4ca650872525030c536e430c8b2987e58f4a7eb027562aebbaf5f698ccc9daca784767b3501d0c625c3d2a511b860ee6604141abdecd5cde5281079526e6aa135478bc5914f488161c2d6df465cfa1b79c7486d0865509ef9bd0c462c26af6bf71081c88ebf0adbcc7ba454651ef1a511f65fabb509ca73e032979748ffa924d3cbef2bdaf94c17eb47656f875cad9f828c2dc0b314b4af20ec5984e50aaeb9e2930ad4aa2e4b4b5c952925fcb50bb09d065f49cabb68293e3086f97e88d8fd3489a0e7f62a3bca204486d2fd5a51b5dbec398152551682e8b5e62520ac3b8c1cdbea511e6541552ac6343884d6a7fdee0d5267bc5e49552c939c02e1260f046930499f3d02442834d9604b7e7291c6175c317494104c90cca620c0fc3bd45ce492095c744b01d998c69e5ba6259a51c19647499feba58d01dbad17c0324feef58275c6b306e1b0890668735419a032d9eb00dfabf2af9200834343ec1abed0ec7b26a21cceae9111a54f09a950ec48ac7d7e39f03ac05f881d6319875d61fdd9a8a3c3eda8a780fb882b92ac2841b2aa7b348d14156bba720487266a37efffb75e24147a0af8f665e9955fabf4134179bcc6457b0b9e9d66a1c1c418f4d1c213f9c7c3fd5accc25ac98bb9071f475dea8f79b59b60f463b1b3ba52813b79957184bb683526f9712d6daa715bbe35b7b7b98c54735d73eb9df1c36673ce3544e0092b579ad004f8e83cf7dd2f11a57db7350ac8bcddda930cf8e978062d8fdd99b5fcf6b66cc110e8ed17fe85a0db7bc375dee3ab0afc0b17b8ce0be16f2a34bf7f3505328ee36878c0ba9283c2a0afb098d7d0488589b0478c48c43cc82dee90e885796adedbfddb02180523c7c5ddd10d18007bcfa35ef9f1d1c6d68dc09a6ca3c1779f7600e316886d861fd3ea10b6b1de48f4a53b0d491010e3af330dbf74e57764c801338c96ead2fbc99626d6a13016f3cd95fe806325f9c0f9b9804680cc134b7078a0ff103281dcc59b33a88e59f8b808313a060bacac66d07304279cb8897630c10f3223b644c523f1be72688f2f40afceb3680d595cb9805cc2de1ec5e4cf10358e3736f581eb37bb340117083d58f84975652e6bea96b0eb2146cc85077d9b4b1ef69714f3dc2242d48776cb6da487e3daa11e4b4f6c5415835bd70e40679f6aaff3ca3f78a6532965c4642b0fcbe961ea7821b5705ba294c582dbebdb27f4c85ab4950358cf5ad76a48507fb9309eb02f0bee0ac927d43dfc91b8b0b55fc47757a24472ce8708a5164d3f909f5bae7d53b2a67059f4bd9d00b4b761fadef3c4568b7b237ba360032259ba8e62212dbd5ea8a7852ee04cc5794bd0bd5da648feaf0662b6a67942fe907233b32fd668a730c05e60a3ad3ecd05b8301e7f082e3677db35fb70be66dc3115b8812dc23aa1bec3070fb5082360eed2efc28e9e57e565b79272b14b254f201926a5cd2e36f69e6d285ccee59768f1ae744c4588e2e436ec52e63f7b3605e96d20c9619c1e25cc0fa32170ce8e49f21d35887032fbf64788aebde9851860b608c670e3858b67edf0b0d3dcfa5adc1e27fc6040697ad0091d21f5bee33765f1835926e17138664a8289dcee1e0f5bb88cdbbe4256321dc39eb223d578ad31abb872236b85d2d054e94fd6ebe8364747c05d05056d08892fa563c6658e4d502a4176907bc360c031b3b0b554ac570526ffd282396608d1e8d5d26a9eaa3f488834983a09f6811351ca6ef7085c5d8b6904df81b86f4c7a45f54b640a13577d714bf420ecb46a352b9e083778485976806c5776f5bd7b537c00b060bde9b04101def1fed657eec1516daa1de6410bd0f3da4d428cc8b90dc24ad884de81bfef36e90869ca097393d1097196abf591e2df0b07026016b3f35d31e10f02018719a3024aff6cc3e7982d98af74cdf27592fbec111e486fc5ceeb4cf4ed02ebcc0efc1e01408facd2d17aa9f8b3882e0048ae22fc2b4003fc613f397ff5cd276c19ac0c7791c43195f8594e01e06b1ae55e794407d4670760818c5be3df3f3cd9b8f172737f113764042fa8f7b5ca9dec0a7c9b53bc1bc97cff8163c0d3c9fc947949e3b628d8b440a724a2eab7df3d69e57f195d37043c00a57697fa2e47295759070eb6060f5062e68d5c4737c69ab95dd9e89b46d0b4a8d3ee45d7bc355ffa98cf7b850b664d6cde43c7cb65c34ffa32b8266f79a4c277de83b21a40075e42896a43b310d0240fbbbd33015b0335f46e6d96fa64c15ab37a8775ce3ac32fba97f58b863d8989c61e5743cf77350c3e4c78229898bb7e37d14ef7f655d8b6bdb296fa86cbf82aa4ce46ae243739c9f447e820ee5e124592144094d252629bd8c63a8fd31f52bad8b3a8115d03e082d14ffa9ebbbad1c0e0cfbf00743542068664103cc30353efba49b0ec14270b06c08830fd1dd9927fbef3a0dc34fd2583ceca26e94fd7af611321051e078f38fb2e2d7cc7d9f78fbda891d8767d0f632ccf33cb34bebf80e022ef24780424984a7a9d217c260cc3a2985a7650a2a0f04a4daa9fc3c475ed04d1e4f21962a743aaad146b06cb8c7bd7718c619df8a56c1c91d10b0ac9df68d6ecdce80b4a993296f6044b9fdfec0dfa4f8e95cf9dcd8fa137fa097d0e9ff5b81062bc201e1f00ce12742dc41480c4ddf75f87dffeead065fd1264fa9c576fb83c15e7b1a0ea046582e6847abfc6b25cc0c6f28a70a68852000f8816c069241e4a519537940533627680624af4f97f460212a920313c9ff87f2fa151b12827943e6470a54a513bda6f84b4ebbad1279ef6462acbd5d246f299e817c0bd9360c1cc83a63a94bf1e7cb70c3fa5989867e993d8d657dd12f37fae6e6f35873e89a9d40546ae17a4d4da79a2e6b90661524f1fe3731bf7236f8c29c806be13ff58db34e7161659af91aba51e02bcb706b4e4fc044ac597c96cf81d559515f55bee896016e30d52f63697bbf8ecefbbf07b17eef4d547715929d0ea604c4ef89c428ac0b13b2a8a7b4f76065f55a48fbc4732a342a773be8ae51254443dc1ae44e613dfb9808ca03a39f34272e225bc8944ff2ebf20b161573218fa1f5e94782445a0f4c86157e0fec637104f757157989317f7bcfda538359926cf034ba25cdad24ce90d9b5013935150dfc7b1f2edebb7e81dfa0125bac0e8c479bb3d5b1418af41780ca9b9d8a30e10dc95d00b8dc9e799c37009c86da75963331696127d976f463c4aa7e4d74c1243e65e5bd2ef59da52d6378f35e4f517cc0ca64008dbac58dadc2911721304d74cd0ed9d0c0f6b30a26e6e43a02447e05e5e8c473d11d3823b209e2ff4312a5613bc12721e78c52a128947d0af445745666711ff23ce560c546adde0a999c75baf56da8e8a696a735871e5eff61568aef169596961be8cfaa959d8ebbf5685ff86a781eb838efc649337c31b516d8ed5c8f7377989155daf458db569cfe046fbff552fad59150971360be3f2adf85090075ad08bce541a817e5bb5ba90234d59311834915a405635ded198135c9729f1ec0644683d383c5acce7d4bf699d52837c27a24f6d63da3d4011c233f099b4175f766844cde40161fb47aed091691156bd268c33a9f4a3a7d50a92ee3c526dd733e11e02cfa4ed2b14daa78374ad63ce67512c705de1993dabc85b1998e5914331c348c48288f03ff4f9145c441ab075809de32083ea2312b004112dd1b90f0cd36cbbfe483e8e5a0b05bf2184413a5c669f5d4510de06fb210ae9b24dcd6e1bf8cecd821e1a30412efc7a871b9def3514f3f8f38de303da3770ac45fdfb504459eac97fc737f7e42f16a012cba5af02d1a0061121c0e3b519f47f77e1ace91007983b9a41b81e4d2303adc26c4daa8a6f5227122f95f91958e272ebe2a910edc0a2a0239873c9fd66d3b7ebac578160d6046af00bf6abbf01943ef0c4658c3a96fc00a378a68e9790a2ec1018b1c85ab8b86bfc668287bfdead8f9d3afaa9d0cd2709f6d3cb6ded3b6b85b8281d92a3d430cbcd74142be8a4b8634fce4ba749076c7be4f1eed088ea16ae81e06601fbc1f92785b53ad099e950e7f2b3cbca0121b8d75956ddb526d975ce9102b0ec5106905a6406d082d949d20cb915d2351dfcc166438e5a95a06b4f61f33760d931f150c073572f71f4559a1e5bb5c6b261411c860433e3a038b19f0a34af2b516f3c5ff0ed2374795361bc692bec685edc9568bbdc88eea354b63134fa3f036e32a881e5c9a013f0974b8660a1e9538c1448ef5d7da3a3c76d49daeb540b66c2e361ea71efd911f2ba3c2bf399ceedf79a44989559e3ac38b9f66d4d84243c76d8b93749d447fa32b2faf32cf960c23788ff11e77538657bbfd715dab681e9cd2dcd9d6736c2bfbe2770a00d768dd4f3fb6556f1127c583ce811118b325d55a231ede1a8c2ab43eeacd4c8426b0a9cff511eb1bd29939c0451e74b6040b81c6960f010d6bd1e045c174be56904b630d3b17f161bbd315233d5bb26f424943378231539444a4ef5285897fd66cc7edc6a51952d9b6387654b48ba7c57651a0232e434b34c825cc6fec7de0c8819c046de8b19e38dcf5a525cd85e9be5ee571fcae56bcd851a9d5e73b3ba2e06f15d474fcac71e5ae96106afb85441d34de037267126615b0472973a2515dd127bae5a004927f7d0ec6abf3f92b568c99f01f99418d6f1fc1c553abbb098d08b16afdc1c252748dd9d09b2679f85c1f4f9dcb5d7d32a6935c576e81626ed5691a9dab7e5b7536b47cab6bfea20b033bbbe50f9a8643ebc5de6a26f1c52b39fbf35391477b3e006c580ffe13b7151b84a6172cb4b4d343e3ba911ece104b1dd7cf6d42449f3c506e75b684bd693a29de7079268aec09ffa3f0aabe24c358814982eb48a1970dbd371d5c071c99667da98c20870643792e8d709adf7e6c3b46dc4373f08a805ca8085b6379c0994cab22faddfeabf6543d9c96c8121295c410e67e73a397a184a30d4f0d6f336eea49fab204e9799381bcb9ad18edb5effb1bb006075f96f1bacb8de62226a7f2611e332b8c4e0b3c76d3818389eeb38c9fe3425380e42e9d85856b8e5ca3ae3699b91aa79ea7ed2607a338bea545c8c8393b7814aed2638440b2bbcd9ee64ce331b42e9bfc181a1687de66d38413135a92b65415c9aaf9b0b8ff54e72956e59af4b69dc0cedc28cc2825650bfc61778de250ebaa657f70933d9aed384ac7fc97178f81b472555729336386228d3b4a6a76792a5a203dd06ed77b5187a8d615b704eff364adc429d69c20ad03b74d83763b5b88ce340cde01f1cbfd1dc4638fe009ba39a7cf20da4ed77fb92ff12f0188e33b9926baff7c70ab30005efec940dba1b83835a17a6f04fe7b0ebc7291df26561838d7ceff82078a33a003dab54d7e2fb7d6c89fbe4bb53baf96df93bb63aa1ecd5ba4f9fd596419c90d9c7298700384a3a3bc92b06c04aac04eaaa23b17ea4508749cdf7937ac87a63426e7f472c70beab4d04250e1a31866d66b3a8804e1b61fa98da05f404625b0b0849d7852a30019e334c4acc74020e9d0a13b5fe46a61ac5e97121f8a5992dbb6b409418a16bba56fb52a825c72924b3072bf5a52d1702511599f5096e2880e16216459f226c0756f59b84ae3b3ce1de82ca836a6c3a37ba3671488856942b3abed0ca29ccacfa0c9d02c65f42a21833db5244e344a0de3aec054e954a5f7e83ea7846f296c489fbb46185291043a51444007ee2635d2a2150c89fee76ed042fc3bf6290de992a328ec54f1ab118263f056f614048cfe038b2209d6248196ef79884a48c7ac7963fa83d678a7731df5c972600d8728dc2726a355c8aea98770cb4b22bfec0c585108d6658ffa34a7de0e73b29a080ca98e0005c00a8eb27858e9f256662746a1a34ef96ac29f72d6d3361ef23dd74101271f4a196df092d7f943c95ee818b2ee8d9d49edc7acc73fad2178aeafaa3f6deeb070c55e34c5e0900f9e4ba02e498da948dab446f80a1b4c38a410929f83dd9778726dd73e401af0df1badb7b64752801a60cb13282394b2707d8fe9cf45e1c8f5980d591802c447d82e4975d8b84f1bfa3b30c52d94d7414b02f40bc3a5edaf1a599be5e0ceae6fcbe140abb1eb50fc2d4a42a253a894001f31713930c0847fffbdf1c3f9d52bf56aa676200ab900862ec6cf569e1c251a8af184139b53a537d0d3841adb637f6fedfc886be62601bbbe0d3a7037c5fc552f7a5e3de44c0a3b7e5e8be8abe7f8a24e6c878be0df428513603fd0a6accaea634c6252d56508cabee7c7719596fe5dc3983419edf7e66db4cdfab00496799b85799b186fd7eafa6faf280369630a911166e55ce3c7cd00b0317b16219db4ce7100eee84c8253da54ba5a099769417a04d28d76b15b6e4f15c257812eac7d71b33ea63b0671f24b64c9934ff84d729909662c6fdda5c277270e95a045fb8df09fbb60e2061f589d0b8fce6cdb580d7c082d1dcd8a0823c3deddfabea5b04c089792c2d7697a27954193df9f4ac2395db49df5d7153699c133a46b8fe2e5c18ae21cc0338b39a3f25210156135f5f564511f87a5d64df7c680c67e133b127c98dedde08951a2a808374f9c1e64b2f752aa9cf4d01c9c0489dbcdd38ef47dfb086505a7bde4cbfc4524f47ebd186f931ac545d1dd44acb625cb57ba0efc824c06f4ca6e696d7aa1be4306665557c23ddd199f34d2f6465a31ed50512d2dd4bb34c1b71fe3975af58ffdc41382e7389d6fb3c10e85d06501d9ec715089cda65f2dd5ee959ed5f0f28b0b35570a49cc728f6f0884f78141e9b477b630fc3e74888f5b93ca99ce00ccaaf79154fe6b5a4f578879299cd17aaebe7516790a5badea1f345a012e1487830b4f6977f456d49a0b4ec904e8a2ef1477a15d04dfee801802430ec58cfb1f1444e69fd565e179cf7e1fa04020d4762062f5ef33a8e5db760b320b4a341ef587cfbe7720d0fbe5239f1cf090928fa7b23b282cb9dbf07da975b8cf2c9e8aa76e7a88ce9ab3a8ac2adad4720d5bd1f6e7cf3e2d51d0983cddd2fb0763cfdb37399989d3efd12c91e6d6db90126bbb337b82e5fd5493bd22e11a02d434d835bd12246b68b8a2c91ba45effd8cc4f97dbe3421eb076720f34ac6cc7f47aaa2adff4643353be49be392bc43c2bc8a30931d8633227ea2ebe612245bdbcec67dbf41de021a6b183fcd61403879fedd735b26abf5aef3d2bbdb9db3ff373edc78159d6487b3f939fed69bd079c38c188db9c8cf43158f8526a18022cd973c4234c83e77f23a15839bde63157d6514f68cf6829622c8105f5a198162ebf1fbef9827487fedf5e499cf9a32776d1933bee3d137ede28624a00defda8af6ed4d32f5ffa620efc45cef9d588b5bdf1bbebb7e024fd0530ca0f68fd92f9bbbb15a73b6419eb5a0c556692a890fa9efb45c96971895189ccb12d468e23608cb49197088bcd9ab141375cf8702895c950ef27b70c1609cef76f8147987812689c949231479a508a7685edcc2e3a1e5c830280993a3ba49a3f203be5f706624520163377cf6f7c9dbc66ff3be0e225dbef626488f7211ff38d0ed93d830c390cca8029db781ca531ee2935b199c0474d45bdcb0d6770e26adecbb5a6173f65f90f97754a691aa2cd9c0179eba0c1a7a89a7e6e5de3e7a0b0d7a9e5bb8ac4c6f7d6b3fadc0610ac226e2fe9aa629c71c3af07abdf6ccc3a9b60a004bf793afcc926755765a576316807e40f199aad47f50ed20326b5ee78308afd6dbf032861289a4dda78e5d8a36eb04dc97b79b5a7beff43393cbe8abff6fc1dd5bc552ef3a6228f422718dd7fa5b9af04835472e7b3a28448d0b3a939bc7a78ec09fb49e0a71ce8774d86169f9f5ed8923b9bd5db5c02154a5db6b9b40fb056cfe56c59f722ceca0c26d60e551b9092904d87ad19b7cd98fb7f117821c785c8e543d92e8a52d21fe8895acc63c53ceb0f12565f2820a537bb019224a845a2afc7e0e8ce16fa5161caa4a247bee539e84af259e5a71f4e1c54280f5ae3ef741b5e86d7e0cd25b089aba447c8d74db6d6367c3f3574a04abf681adb2377bd217bd2f32f6aad3d636cf289d00b8a6c860e64eedcb6a603ce73f6e9b677f02d0c198c2dac638ee7e88bb3373c5383f3eea5655c0f39225250da83d416845b958119701048ff0a6133874b097925e3d54efa8ed7d865a804ca9d50fe40790c434de9712a00aed7895fc10dcdad89038cb719ab9fc3f2891381437293d19ead5cb192de236f76ea31ac551c934f39d42a70ccf5f89a5011f7218fd10a7b82cfb5e8dbf49ce0eea48cf257288622a00744f57043e506f8a9b29b41a199fa274681a80bfd1abc3fd43c8ca20f8984a0ab5f411adaca39b347dd2a3a575bc4f7b9f23b2201fa0857e1ea4493f9571b4ad025447a510361f63e4d99a90f41cc2eeb170a24c0a3770c0fc120f922f6a1490f34fddcc5882c46cb4657374ef6ff074c548d4a230b75457ea9b70cf1521f59975194dee3c3d71916e2a64ea00e483e5857b0986395ba6dbfd80622ff832500ce75e4b58688f97a60dc24599a11d37f8e498134ee24981166f39f5e4bcab9cdd549eb9940462affcf7e7cef41db83a173ff3be1650dfba392880a7cd6b92c0e1581ff4dde63c984bdbb38ca548ddffb1dc5f8a4e43e74931bdb672aeb2b20257a210ecb9f38ad622d6eea16b38199f361aa7d927f05cd93d1fb0001f2e2ba82cdd3e21166c6003e5b3f94affec0903f46ea0e0499ea89b563b654591643d746c5659ecd400bd60285e2af7c6f1d3da7829b4b5f24ebfce9fa98aefb8f9b6250562520457f41f4b0198c0a2fb2f0d38a7610f81b2e0403d5697888b0c2c0b994e25e7c45523548545bf1c7b8e149b624685d24ea71176f3e6e4a814769ea3f23d27edcacabbac48ffa2321a643fc172e768cbef355388c12d66342b3a4d6456be6ea790604ed2839ef2345249f274be4bcb2a0f61217483e2972351547090b0b2cac388bc56b21bfae4f12f17f4f177bf1e984b7365280e462c159dd0e2c2c1dcaeafb4bdde5a0859bb8ef6dc7824185f9d414224b2c0db7315123a147b566e7148b801b7b3cde5c7f422e68b58a1b2b51008efd7d4ad29164e7a4ca66db5190c31e69de85e7d4f6abaa8b327c31e62f377277d6b21ba442ba13dfe1ebeb47d6cc105669c0a660c4e8cec00185d7876e90ff7c638dde8f977ab6aa89797f79a9207d9232ad8881ea450e5a3403dc588ae6dbd186b42f5cd4e8ffc906aef3d5da629aa67bfa13d27e30293ab96b0bbbe42f0fa4c059c367bb44b8319b76dc2e1f16e58d2ba6989ff94657c9795877b46b1e047385061d3057a90c86f08022892518b79277a37b045bdac783265a3d792496179e2c6568c3f0c2d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
