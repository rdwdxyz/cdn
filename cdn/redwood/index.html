<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ad0c265544adb728831936b8c4a1b5cb63b300fd93392727eaa04e1adbb4d27f56078fe787a5b9d6d86fb643e6c4ef7c587748460a268434a0a0ddf42f650a34ef389854a6c69394b3ff3487a302aa7131c0478f404ced08ee8e966d383f3d1a77ef3e4c2b6dbae915925ed5a2032b26e9fd3429bb21a2f0692c14da6d2dc171dd391103884d1ee4e67014cc6a6153b795a875a1605ac00fbc1e80f52a9451c63fa6c4a8c34bd56a497d825078c46829174ccd80120815db0e9281fdaecd166703ca293a27fd4e5550f8fb377b9c3aa040bb678fa2a971a120198cc5ce6bf83f0b56946a2d515152693b1d49a2e5a3a158efa898935c11083d62715c0d491d4e5da7b8ee5e7bbf2f545c7d8a7f79c9523db44deae1c62c7eaeb04caeb8709738b79f80eec8dd1336493fe71d89ab05c733a457fcd7a3175602e2ec8e16eda80acf7fad3b1e17c540838119e5920221cf67608d9602e480f0f3f597a70e25c9cd0acbc048a78dd71ddc017ea9e024c5e04a79a9e23bca6a2a798b80c34e5a92d12b8f45c5dc4f4377ca589810cada8d4902b4d847f4e478ef97fe3602f79483f562c321b07c2407abc72b7e24a8bcfed8a78e63c8acc338e3a3b3936c194a1acf1a64b9e520e574902a952f1af5dafe36f6bf47ac7082bb95d7b5439f7a8848ae7c4ca557b84cb115cb734eb589eff491c0514c8370875af48e6314dbfa49a28f4210e5e071f2a0d76f119a72bcd851aac05cfd80b25fdb8586b291c235a6443ad1e47b90d407bd732d769d4429de3b191fcc60e816a47b1a37cab3caf4d024bc9c6e74bf51576c846c4b7309a0afbfc9aa9be2fd74c81372347224ba7be87e81f21bca9812b3d317c12da2beaa5959b95f2eb3137ccd19de430fb82bd7037b54d36eed6917615fcef1a0cd4e630d3e747ff93a69d16725e727aba71eff151eb9963acf6f66450a9ccc744b1e50c4f5119f89465cdf370391508ca6651cc4332a9670f18e15438cf3f0bb755aef420ad55a6ea8e5bb936930040deee1c98547e4c6e2ec09bb759e684190c193b0f00908567483061ce13fe811dc3c6d15199c22504a07c70c9fd6e760f0e7e1613c71c09df9dd3e6e793e4278b5212c8e6f65234d4a3ae6812b2c174489c8e03d66b74fc4d8245109141f9f75a1e0a3bfc8d7a51a2281c02700024af99b53ed2c1b2cba60ed1a95fca3635cf19fa586cd494df768d88eb09b75dfa8bf2f203592ea8b52d27938c150b551e04b3130ccf8d537e64a5cfd6a0963dff737b2e733d863619eb700f56c272a468c183026fae7cfcc9fb987c26e23e229546601b68b68e401fdbb8b9af7e14167e0e8a3a0941087d9f27fd7a4090854c42642738b97201bd279821f59026d7ce64e0102061c2b6295f79058401929617c39b934384cc80789b5af28d744bca49a2079c866074154157fccf15f2e7f6c3d84afd0d54e76476fed40f3e4f12e5b393c88a387c63f19b5e36f6109f610923aca9f5e7995dfd8236a6f04b6a39e92c036cadf9e920bfdf86366e4046856bba2cdbea9a08b1beb12634302d92142e445cf7f9a672e8881e361c4ba406edb19e1084580abc1bf99294462205e021d9a8c4b660fe1ca0fc0d93664329242cba075a105f919a63e5e60cf547c63844cf15bbd8474ee786d5d0e2cfbbcffc3ba802ef2babb99c25e6a84a8e6443983c4cc9c45b101c1387dc9e89450235c45b92d4be1349034f0d7dd63d994764195ac9a0e640ef1b62f82b753dff4dd615442eb618e17a06afe63d2e3edb8f900267e5a907ff333a88f1a34c7137b62e200205d83fe1a3b6be1d3431b313bb2cbdb368776b660c58c8c6e31fb024ab441daa3abe7cc8571460a8867abfbf1f095dcab2bfdcddb6072307f42caff01bc30b211fbc8ab572b780d34abfa776922c264fe9bf67285d827576730996eee1932196247d051e7facc4cc4c12f952b168d98efaf3598a3ad031b40c4d5485dbe4e9dbdadd018a91a611169f4e3f9b396e71a0be6b2633d72fa3e9c34c9d6eec39126293bbefc35cadce036f423694d3b51c4fcce107b9e75f826cc77e80159e7032c01a7128f3e5575a4979e38775c3daf92ab14662cd7e7665b8d2d77b231b6ec8a48b572d31c37a3d2556293be5a1e602ed2e2a1144bbc6ed7c444bd23066fe7b29925b686859e8d05fb7668fa2a7526f3377bb0a55783fa61104b7b0440408b9374fffa2edadfc5563df7b42e79254e2e34bbadf75b9819b9fa67df76742ccc92bd4e956f3b7c86a51242042a7ebb8cb15969b6716bd20a48a734cdffb31a649213191099c707e6d4780208757fb9eba552d2756b05c60080ec4db8cc091dc2961cce26b6cbe8b32c2c4925fbb448e7635b2f5d61f721cbb4a4f28912a94b4ac7d6add8943fe350023a333c9eb970518a8797dc6491bd735aabbc2058b345efe0cf88dc9685e7f7c1652db87e569d3d355456db9d34c02ba13a660baf56b77db6aa746eb41e983fa6df20a98f79a94105426653fe5a103174531ef4b67202948656845802c2be39e45daaa36005b1322c38ff154397ca4feaff9f346181426dbbf1d674000da449c58e55c3cb7dc1b39292f7dbaa114b8384f0fd5aeb90ebef12e2c3cc930624e03ecdeb19410a6b7cf12966f3c361f670714b9d7067449d00979f597de13de8116974b0f61f7fa1fb48639ab9d3c647833e167fdc1885d8543743235f9a651bc8c6059f07f41765890fb81d9d4cb290636cddc9864283eec84852152150a338328f66512b0580825a34cbece6173b94aa07b3d5903f73f75bc6bd418077cde2380686038ce369d8f59024a753c45450384b9eec75761696a177a445d0c153f3ba6fd11af6d5fdaa406ade0e2011bfd75c0db31c5a91f3b63272f75b9db91a893ac0171c69b4ce1069a647adb2cdd7b7b60cd802961dde0113d27d6d0d80e941bfd84b630c9f3248ee98442f9cae3036245c68978f213a4b928caa95026e3ecd6abe66cff5793338780d8c4c96b3416a41b076b0964c073aaecd1f1255e79b4bc8b3b539b6c3da3716d7d88ddb380ca0657b0e2eeca5be0046d4b04e8c9c18b4f44960e4c25ddec3d2ffe0b87ebfd3d7890624b7167043537ad1e6a945ee28c8fdba4c72d1ccc884fe025009348a2443ac6680935d1e9b5e6766364ff3bde6b328e522ddee72e0c27834090bcc84cf505e1ca58c65c6182b8b426cefe0067b3c12d60b724edf36f9b459506a3a220e931180729b983220d6865a2a53a915fa0c19dd1d345c78dd4ac6f044faa72388f0a014fd28cf072dcf7f88c9bd3106524891a5a87b8e84a05e91e13b6a7f47fb2c6149105cf3ede6c374bfd24c4c537b808f57118141d6a9753c879efd06849dcb805adbe593a726ef74a1a1e5f973c7616c6ba9579ea72cbfe7ee84ffc2d132c6c07e06824be1b861e6d56e0e9be2bc3cd3e0b1edce3508f3942a4d4af9df00b5ff3406d143d5f21a19444068345e96fdacef1d8bd80a60266a3bb51f07dcd213002afb3c91210a7659ddda044f81fc672061df6cc391677b841d971921630dc679af084245819e0e6c08f9e1afae3a0dc2084721479d6ac96a5a7ee350963599a74ca6e7deb0d6c0c3ae4afbe5fe177e8bfca7f4826e6296dddb1a5942e0c8f631852f9503d9f7e50852d32a494e894306d6b32074926d3a6875ac7972a105cd8dc239dc747e520d09fc8861ff26796fcafd4bace3f4f2b83d6c900bc217f6775762374028309b5c6d7a97a793ea23fdd38da27b16652af775fdcc748dd22aaff0216665a0c00b3e4e709e35b90884cd4b20fb123c9d0df08dc51c66a0b708e029968ecc652f0a48e91c9a75adf9e289c9179a07e51029e400331e6a2d0a4e873500dbe72c4876096f80edd61b220b9ba45db44238e0d085361eb756da4904d55a1047e5532afcc61db8be62a61d9b9e66a170d7a6a54e8fe58cc8c1af9cf6a7a8887eec095c61b5a26cee8a2b9da9f93cd5436b5b0dd3f4cfe949d49c33ba251edf43d35a267eebd729874923fbc1d1ad0fb6cc9450bc0e62b47810ff52f89f14f2140b12edf0ce59b56c4eb1f9ebdf04f8cee73ca89cf651341b933d4307f0e1b3ddf2e55f55f5b7b2069adf2d7b910c816a9e2e3c4cb08ec1778c7854b3a201bb8a45cb8f25d17704690c115b0fc4d1ee904fee6b2b67feff78bcffaf6c4b1afdc9db7bde6ea57673c65d5500bfda6d7ae1d6e4d58812304b4512bef1386e7d0b4bf43b605742ba0ad6a0543ed9a67107da33dfc02e67742a7ae9f25033c9e839f1d72b770f6165fc25dbb19c95c300b2cc78a106d73706d551b716fd12311ae29a865db67c236c604209a004739c60841e7467a2513e559d39659272202d203af36a9e6c0d967e3f8d9a6363c621acaefc749a9544e9fb775c1cf873f26c79becb3776067a15c9de4bf587cb12d3f8861872033dda4b193df1ceb394829081c1f7a9b7121094d1edd144cc7a27b15af85cce9b31874b670b02af81f1d0f7698103162d43e466761a077f674c79c7cb2c8456e5afcc991c318549815f0c5d4f4260b2e9ed2b19feb4c7d3ff0e24644d20a0a908ba786944bbb0e1cb01fd0db0130efbe13b4c9f1e3993158b8b2be52168056c8481d622313745c26fa61da80284360f3ab9bbe146d3b28b085b107b73862f1e9faf446be5ea15707456a171bc63d1e10db524390ac8fec75ca2eefb4742e855a0b71d64f745b68d5165860b16b14cf504874df0abd76386854a24f8d6fc37b8d13cfa35dd8a0f89b9fcfb8e9092b4872bd98b07fd16155c2e2809f3d1dca1a533a9945c6536033d0076cd278ad1f0d9642ede0c047317c8cd766bac8d7c6b3d28c607277ba59afcd4d5f7a70f9d1dcf50ad51c2f812df2ac4188355e7f761fbbcae6990b08c6257f29b4c0a633466c73570d5221d4605d399c8a69002e72a4eb698190e6780d6da0d1940e9ebe486dc85265bc810040457808cf48ca0c8a2f422877fc431346e89107a5de8a7b54ee7f087eba17d86e183782bfe93f30c32667c7850ff6a53cc31da8c87f54061e0121a462c7bce213a87764c38ca50c6c1b918855ae12740bc2c85b54700fa794c129ecf0240884ba03490925a00b42c01158ea61f30e283e95b5e92df8368d4e600c3146d6cdc80b8380b6efd6f85b5d27f616b7b16e62947a4f29640b08164d33e007d07e03aab6da4d39fea23800e95d58ea0813f293914d268d2cd0308782097e4a01c0f1659df965c5e55afe678da7e60b866cdd81244657c9038b8d0624dae9cdf943c5568a781d28d75c1b70035ec31bcce57b7f7b74e59ca3f81c6b31eb32eeb8399c7d8b4f19a2becd147108cc8976d903fb53edbdcce54e35ef8327c105d3b51b031924ffedcfbc30caef2d04b9808fd0e154f69ffb32c5a3681aaf3a64dcb5189a1abbe3e3aa6d565c8022cf722200bc7cac98c4b68f00d4eb15d5dbe8c1a189ba04e0a7682e9f142d1ceafd4f00b15a3bcd27d07b1d39ee7c45beeb9667882a7d8dfeabeb539140b0323b7420e66f3c0717c04553c10494c6614dd5fab169f7e128556f576729808051cf9905c792a512f1024f37fdfc1ca3167d5fe749165b9825f6d17942055b3f5a9454b59bdcdb26f6d18c1948b8646f81c43e72f915d9f23be589f4a9466635ce76dd5c940155588880cbdd408096b3770033bf08463e5e141057bfdcbeadcc81ee7aed0873cf396786dc25bc1b0b9aa91fc636139c3eb6555fb2a722c12590c3983fee64891bf0a0eaf805c4fbe952eb817123f586522e314e7ee229535e631bdf072a80c8b2dfaf93c4be42da905b3f2c8ecc9a51c65294831e504793bf4df38badb6f7dd05f645d90cc3f55dfa0c2fb152b7d2274f6b753c3a6dcfd69f0bf9a459223ddcb840275f6178184cf77b5d0b17f47c62e589317c29b9b8f773976f44dcf82118dcd836bc8f2ccf2ac7186ce1d2d9670956549ad9258d431694fc42765a15874d637366a1fbddd1f1b018a8e5f44b2a4315f85f970e2e1e98a981052fe68576341c740e0f9bae25e6d833d859aa7b1ff90cb1d2d6edece5c712512ed87470a94a9ef6129cdb43ed03d3d25387f7746a11c094b42ea6d806e5cbec6b1fab6ec1ff1f8e0f089f35c208fb92c153fae6fcaac2d3fb3503cfd4f0740ef09affce309b912dc59e28036e074d36d33f5c0bdb95c8d47c5e6ef0f958a3fb5201678b6866acebcf6474e6f97576fd098c645808b7283fad0e9101e453d4b766ad951a6d6f2fefc58849b927e49e49496d33857a2f4937f116ece5b16af87af2e0eacc1e776fdeffd49b9bed3f148329617ee4965f1bebc18914db4c8cba93ec0648b1319fec5cbad261c7bb79724324e234443e958a22293f4f1402c6090dc94a32180370e667874c15fdbeda226ac5a8347cc6c397302e7e862bba9a83fd1b3d3d809ea48d4dbc64bf837ccc2f6bb6e5b121e05e2276dafbb3f5aeb1c214ca470091639192c4a71af44409de76bd914e780348276f7fb5935161d8fa3f3bb12bae92fb8b944ddc6356d4c1ecc271a84d936c98b92e38c41db379ddc8a85629179c716a6429806d98ba8b4013222ec1d661ae4462cb27f3c45024ae3811fe0bf2488ff20b81fb9ef365972ec86563a7e1ae93e5c432a95ce2abb8daf33a8334fe67269099609f90cda8f60f501b360dac11fe8d4ef26bb4c2717e148701930f04ce3d0328c2fb0c2bb562b18084a7c162fd5e7ca05309480a018463038af5cb605f694a512063959a497505c51933a2659289077a0852429c4d3e2165d4784a89dd7378304edd342f4ba26da757273bc1aff719798a2978c19df13f2563ab77b6a725bc24fbf98d52b78bd3f49aa56008a4c1d33fc6439a1d9ada733768dc8b38e0ac6abde95ec92cb08f9dbd4115b3d8f2b55d10ef45f88aa5b7abc60648feb6cd710529148d892457c7f80edc7101839a9fa82e2abde7173397b14b172c9544f474c6641465b38b0f32869cd96be9c22d4fa609bd5794c61147e500383949b2e7e496202324d1d82fd73f5b878e4ed45aaaa5746e3ae994de4632fe28d2d3404fb638dc440203a9a666872bf568da3cb56792eaecfc08b0363135eb5e0f48f6c540f1befb6a985af7d3a200cc77a5b2d889e639744855fdfcb069c390d3057b38ca8546f1629c6e2381b1ec17e20b49d49191f87667148fc3ef14510ef0e56d31b98ebb050bc76b75419e1ddb74d69a5c82f7a17c1226e61d33069b213ce5570dabdf51a7e49ad816db7460cf5746a08d306ca673e71220f6dac5b9d5f610d447568eb42d9af8baa2b026679b6e1d6603f73a2c190923f53431de811daa1164000fba11017ce87797deba145e73f7fcf66d46166212edecb06eb7db0ef03f78e1ff649e4f6b12b6ffb01eac4e2e24aae14511d9a5d6b1f5a8f1c50684bfb3a7f556bf1844d6a23bea0235dc9927d7e481d7b6041fe5b545f7ab69d5f330bbbf4e0e7e56be63f0c6c9e93df59fd01d97dbb1e703e99dd790a4c572e49ea66f4e6c48db371e324310e206a108f1913a828f6917cb01e502601830c6ac834c8fc9d29557448012771f0ca3ff4102d29a647ef85cfe8f28612d2a2563bdea71b689ca51cd201ace0acea46553b57b7a17b71491309a6bfbb87f55516e2aee558af94c572d5877fad99dd5e67ab4021a0198ef4e2fd7bd9d3e34bad2571d5686ef2a51d071dac52a6f12c0e40866b3c8294d3bdf86d7f985b1920f199584b26ee4d34f93fcc67d21fc9447dc8cff069db04ce49c835c4dd1429401cba11c0241df129359027c1ede0d1015d6a78c84b153b4353204cfb37daaef00e54a78e253ccb33fd28d55fd2e2490e2f2276ef73fbe17ac4f329b092b8275b07c0cf358f75bb777031f090cffe5dd04224afabfa1dea9b6afaf49f22d8c36d76fac6415c92139f08152eab3e532716779c740449aeb117ca7680eac974e6fde307b478072c0f5b496fbffaeb1eae2af9d76e5722c596ad99077b9a8fd4b4a7befc31a78a94fa103912be19c3bb822817535df454bd0fea4986eaf79e7950961731004e72eec5495473ebcc524063a69fc33454515a4283988b7b3a9bf32fa75ea3a1dd94651bdd8bae1ae5e41551a6bfd64b557277cdcd0d96ddfa348e4b78deb7c83a4cf2c58c65f6fd525d9294470bd7ccbb65c5de488ac555603d6d00fe0abdf1e1a900f1abd8c1cc1ba11a588b41881827ddeed5f282064e65b1a0c5a6d926a5d5d5ebfdd4d7cc9ef4d0cfaa17ffa7e49c82d6fee1f6fe516289e0d0989bebfe5ebf27eee2fab8c414d0cb013cca35ef1113b5bf7a3fe54aa430bd51c859f5e51bfe3b39338b278fe9e43ade5e646080352ac98a310e4386129856a21d36ba0f4e37e33352a037945c41bfe878137b4b0f1b686120d522ba5ad7c16bceacc1349f3518cc126d6065b52279cb50ea6aea9febd121c16dd4a8bf5ad20f15622206c04b68d193a8cc2dfffd6cf14d374b20f190a7c47610b43595ae05a5df596c5f27f38640d0e5308d70f3d8647886c1dfda5e01e69b85b752074dfc18f6213ce111ae6b524b003d43d5762be4f57101dd904dd27bf377d8391502a5d6c36e541b0d7b41b9d0fc55e4ad118ee2edeee904b6ec7eb6db7a6e425d50fb6f690e02151ce29d9a30cf2ca109df8f1ca231160ed3858680a0c9a12d2ee2dc4a8ed4b76e8495e40ff3216ffd76fd9472ccc4d0c1be2a5ffef32b716145346d977efe92b3231a8f3af5591c227fbe18b334e3e2fcce12c24fbf26f98a9aee86112265c9d0a31667c827b9c151768b31ef3fda5ec98214e5222b9712c8b7896b3c1aac925f6cc6b8f4d5f5b11c562be536b9a21bbca89cdf2e837dd66170f0d9d921e3484b84137aa0c70d223b1f9c4a5fd3a9c9392a458ce701ce0b8e9faff48eedad6d7b25c51216249cb46216b073bb7ba3501401e05ca2d6eaa0ff0dfaa0fa782871a834cec280a77a2db907b3f64e42839de6517b79581057313ab54a8f009641a996fac9f63a42833ddd004b56886e8784791b2d1bd3981f9ea986e5cba7724b15afac83a43e8adf193ca822b0cfdbe8e840418dbb2ced2792109148c9f3d1a87e5a6bbf2520a63fbde5a461c774c6020b87a7e5014e09fc7593d2d310dafb6aea86016898a41ada44baddc1129de9b54fa761f53ccc3f521849831e34789e4653a43799da2d11b3e31571e6016da965bb816970d00f2e46907aa895076e3331ed5d2d915e4d9092ee2d7409653a3691ef92b7fa96e5fcc2bc1057b64b8a5d7ac7e94be43a3ae7c8deae49cc380468fcf3eda70cd8b228f3eb357479787ec6f252d7d37d6bcebb1e657ca1d8fa8563d2b40684e0ec59c399caf5fc858f2b42c3089a03f6d9d53788952ea42264367ec70961d729580a979e1c782073dfa245e9feb3fa798ccbe3b9f28aebff8362ce394284c48c8a9d66e06d261ae770bdad7be7f6296a8b35895c0d10a1778a4f28be0da54ffbdb392d6251a7d0edc9a0980ac809921045c7fc7b12c8d58eeebab0bc3b040edb4e54f7e9e6b93ca226a69cfeadfb4ec60b7642415e0f4145f57afeeb772f97588118b8317cc39c3d7031d6a705b51e6934e75f7c23e275c967fd0de74a872fca65ef8cef1cfc23c95cf6f5f1392fb642f67bf89b0bcfd2b612be3af31a72cb1fa3bb8a93eb0139807adf69ffc23858baaf14fd70737bb8ef961c68ae7de8539b3fddf4af864441d62c6f9b93b895c93aa403582ecf6899e670f065a28fe525fda7183851398d18e421fc1a4c8d79220c484ca40f08d8309a5144c7246448eed16e829c33e953fd62ad2c993b8986efec12631a52dd9d46813a776f684603388596d0fbd12864393bc712ecb9de8b2da1c70149d4e1beb0ed3dcfad2cddd1bf935f9a468a7e0acbff5bad64707d84443bbcfaf9ebe14620be2238c0a03eaba8d537206b1154cb7fefd897e7452095a14d7dfbb90c143caa940daa1ba16244255886ab53068dce3c7d596085225bf47eb9961a8470a26baad69f714d60b1d316bf83147589517f430097cab62e605baf856472084ad8e8eda064ec10cbfc75b3762802c75477e2a905c34b477e10fb53c3917326f43fb254529520ae9769340d74b3b2dafc7b2cab29631c4e33d938d7fdf33be80e2755bc4cbb3fa6087551c09bed64476ec7072c7f677595fc7fca9e6749694cf4251f10867fd425356d558250ab888fe7d583e6f87946fdcbf2e067e7bdbddbeea14c7e0146d9407968399303d311baa6654148ca29889deb00f8e254dcf7c965a8b197fc8776114cda827f96aad50f6eedbe03313c0d1d5a06ae06a35ffbf98148db20b613d05c8f2e2270b01086529e90b536ade63c2794cab199ee24e6f1c94059ca0539a6cfa7de958afff3d45f9508ec5d5b9a51ec52a3d267bf2930d6fe6551a4d6b38d29e1a35f89da3650f556c887298781e80ab758b21b32feb73da9200e188033d7b56fc55814894d4aefc94e9e6d52dbc4de77fbb6936f9366bdab242a7eb161a66e2ff421999faddf12cabcaa3996c3593420adf69acc26bda26919553ea378236640e586d397753a3934c81eaea4e9cc2fe6a9b1a5dc3c417cc8779d2f394e09648500898ca9c7739e5c30c85a764f9eb6bdd17ce6386f295b06fa21ab9d9cb81b95389ee05754ede9f2f96b6fb624d402c2cd2da1b846ff713c35dde6293b88ec0f0f8d89af7025e3a0ceb734aeac4a2afb5fe83d46ae222bb060f049b0e700fcfe4e29aa3e00371300152f527c6004314abca53c612417fd4c16437a0d474a274aae37d3655394d8fbf95516a947f1b9f8af5da6f035ffd3a23f352fd8ec6f5ee829c34e1b5ea753d44e7733b83cadbc18f96c7186f1d93a006dbd7f586620fe4e7c6bb127f9d75a3fc5aa8639ed6a6938e773350ee3376d65913d1344950ac5acd588f30348f3105547d171a9124156c142c2df22fea3d9676a8d02a4adcae157de30901192d4cc16acbd6d4b2aa33ce5b3c99329b0d79fdf916a201024e8c8c0d998a8bafbf8d6f5523355854112bb863ac9d0c9b1475d7ba6c47085f84adb3c23aab2d7f3547e799557098bf11b9bc7fb837aaef8217bf4b5e09ba7d86f98e8be56d756e9d88a724d125747afba93b2cace07dbae025e94491c5aafabb85817f2e142fdb0e63cca6a81a5f1c3777d737f19e265c2d80d702e9503c46e5965f2f13f1d95415a6bd04525856e59f6378c47bbab42cd6ea6552b522a6767d05faf27dd97e83c24b6869c2a2a9a59c45f17671db6ab2e54e303b11c9b476f28ed4ec99ed4f4ea630d053510db5c3da2f34771dc289109ef714072329469d3bfc23a17c719524e499a4c6dae5c6b4c015409bcdc7aa9c8335b4252e6ab3dfe306fdda0577f70ff72392605f33b12417ed31b792b7d3b771f7902b2ae288ec99340cf92b86a58f3dc0e1fefc873c15a9e880f359c7f3c8b208b60c09d590b6fde7ce2b16bf954d7370bba88fd73cc06ff5150515a90cafa84475823ffc90c47aeca0cfdde1f1acdac832e6d17ca985362247de1931e425cdf2c3470efb9e42210dbb6f3c70e5c1e4ac374083e8a63553bc0680078416087ac788a48c201e2d1170c5385bef6776018d86a65ff8bb1283c00791a44aeea5dbff1bd2e798a799198879405265a55161de520391ae4a427d21953655cdb9c40a750a09d12644066ceb9bab95db00112d23648db037b4d412b51a898dd5551d09ed0f923c70e9b3c82bfbfe7086f43769c0ef371ab44eb1e5fd29cc137eab9f570c942c6b5d8b6aa6bafee967826bcfffe2351e48eb58fa2ecf0d4ff451eeece95407cdd26b6158cc1789190e1b71fc127a5551f42f584d0ae0bc97e8e8f7346e54ef142f6028fdb49beaa6b0561162eb2eadbab6d7388179bd29a695495c4e76caa3b1942ff1e0fb4d0ad321ac4c570fe23d8517c8f50cd6939cce68ac9b75df373e11b98ee673dc9c1499428527a9d896d45ceaa692e4de9912d005e61356f68a01958f575e94bac34e88f8956d07e5d814e1aa81ef74945de761373567002689495f0014584a2a56b794790a7ebadc62e4a13d1a4368763ffb07248aa8373f1df98aa59fe5d770b9a1e3d58d44e232da5efbee6223f41d6ee3e3c27f78d325df12a5b0f0a63f0e9335cfa33a5ae8698a239cc0a23591dcb35dc077c379a179184f52e278e99c62f9fa5674436d5d40746f1c2ed1e7e45562c46ca8bd288420d2cf4f9609cb37d11887d1039970a9c963ca323d181680c4c50d0b6674c03e5fb2bf0f9f3769f6b04386b083016193c3edc68b42ec04268f1d85deb927689b1552e59fb753fb0570b7388bba3db90cdc2456ca26e486e1ab5c67e88b1e94a9aab0cade875ae605c6bee9656d8341323cd56aca4bc99ba5b0188531d53478b35ee88e6d6f6e610436b6c226c9673165ea158e63a00f0adfc01dcaffecba999cd7ad71896bae79f98f5048f290cc4bb8f52191bf4e1de3681faad2d82140f59a24612f601e9b12e5ca00d51689be7c2f0ae34b8e3039cb68db9dfbdf92a334530618be558b55074c6370218b3e4d5b61d8e6c9e61f9c51a769b269f0c65512f3df78fd3647e4fc04ce2f627294e6d8a3b8958aecf64c335c468cf16b01d509bd3551b2febfb89317501a0ba45670a93e81a2ec45c743fb78150323ae5f7398c1536968ad36a21978f11a990296b22dfe24af7dfebe3351e8183f9f6cd15ee0f44e14bed8a9a1a821a738da46b788ceb2dba775a3b4a2ad9b47e0e809464493643cded21e59d769085c3bf7db4574aad059942afe7f56933245b4986878bed92e0c49667d6e9a2f35a6a764d861956e4dbbc59f3cf5214789bf2c7d9171ccf932fe775a05d2ccbe184a09294eebac229f3fd0b70e8ec76c66f3b9499ddd804acd5f3df7d44fd942d67a0acba76054f882044a23f94e6d905b4dd8d6e1cdbd4e792d2acd9e5bb084c22eb91c826716c65196f7cc6ae1b6fa4cd2134c20c8699b29320e434848462fe83d4fe6030c1d0417bb1b27510ab6226d3af38f060e5d6747dc8ac87c81917c80e5ef8bada68ef1d9efb81637cf15a26ea3113068e566ab491d80966cbf1306c6c592653f9ae7d6802b4b1545fce2e49c846fe0ed20675383618063f0376c2806576244a7027e5d58a92308a8732d8038e590707804c5c5baac57b0e2e523c62f91ad66b4b0c18a9be5af9eff37b7d360c72f2de597576df8aedba8bcbd125eebf18262feecdd95ed4d0586095e735732509ecc27bd2a1de5909986c86dfbc28175e003bd2fb3ebc111d5a76a70185e52fa2d734a8f1aa453956acc7d4862740d340acfa7e8e8566bf01ff9ce6003d32462e72730f0c9eda79194c033d0e8109f606f4e438bfa03eb283e1f07ef734830d7731c4718af9eebb9931f5f116ef937965f44bc89c419cb2a4bbec577c610e6f6e92e06cc3eb00f325d77b2cef6b2976fffcae5f1e1a7c6cb196641df73341aa95a732d92d9924aeff402091b84d41e61ac9c8f01bf1df17d40717fb45e23888f399e2414df3daf7581d2acabc07e96535bac538922f1509f1c92f1c46ea835f61d7d878dbc8514ab3094bee8b7d74331dcb5472dc989f4737f926f05e362ce98f439e99c7742fb460c265a297c236231dd4cd025a97044e5733255a6701d8cff8efa0ca11194771a5044b07ef6b724931b21b2bd3215c3ab15d3b6f49fe483cb3a00a231c327a2fc492555e2959038f71b8ef834ebc1f923fe894df3a8709f366835b0ee6b6861b963d4c8b1c9213d4b4afa1182f4368b5c1f05fdf52619a2268024a8a6cbce9a3990fe685fef864b0be5513cab9b0c848b057e7af74fce99aa8fce59ab1cb6d02fc08751bd2246739bda052cb817e80b04cf446fe5db6b7c2dd247cbb41a34bdd2ec29c0233e38c616184922daf4f1cfbf18757ab789b3e02efe1bda78fd421ec784587a8846bc3632fdbbbd240f3d19fcf38679e14557eb4364ba39f27ff7c41fef6937d3404073935f4792e0af6fe4cb713a6cec9610053c8e5495f4540cc98d0e1b0bfeb74a2f4307d11817cea7a96516599282979a0670b18f0c250bb4fc5d670048218028354ed6813cd8fa0d7c1bbba066a06a0867aa7d3b0d1fe75bfd500822e4c7a48d61c1ad6b0213c8277911914201c274251097ecfb8e27a31a61c1407b4d8e180a3c622cbd26f82298e851555ad6a4bf144a6c5645fef37d82e0a3f63cc0a3c307797e863471906a31d6527bfe6677cbd0ce9396f5c8f58570e1e9e5df289e04a941ea915f2fd985bef2a6234cc534be34cfb8fd999f30eb2c4f70fae18f5f00a40302cd978aed5ceb1cb5cc4b7e110ed617887f1d833e8e3c8e197872e9ec08c7743a57d0d5125613ea0f9a5d9be1ae53b733d8388c067297474f727dea7969d5bf2671828147823ee28374425336359610356b8c280ed79c26908440099183f9f450513ff7e430fdb8db3d325780d248d9877fecc46814297bfa67f738bc55752028eae98a650eeea3149317469caa04c8b8ed17e21ca4adced77c3eb6276c5aea1de303818156b156fe8442abeb28025ac8e56bff34f2366a6c1a1c7d26fb3e9f4f622d8cc5a9de77554e4ed48c0cedf3cc781215981b459284e57987f0f5bc716dfceb91550daaeea61c77728a34350c718eb9c8c9575e4d536dbb24ed9d7358d365832a980816765b34df87e77177bc83524b890806533423af75a2a33f9d71e305d92e76ccaf232d1d81df5960afc29d38ce71cf7eec3f7ae352f378afd65fabe637f672b6dd4b9d97a5a043f583680d16cfe4f0174c060596d6c2247e6412f6d658c18da724c29ec55452eda3077015a0c039e2e2659e81cfd3655fb48e0ab502b929fd95aa560478f74d093ed2c5860cd9753de4559b27c99be67cbbf8e0ee67417637bc8f07c403bddf77da3dcb4230a26675557685dce2390a5994da3d1a6074c808c3e24ed1b8a27ae5f3a53fc1d78705ce3393b4c98c156318fcd742592bff810c8abaeb497a2f948571802b844c612d0617fd5f941f338d25d84752d002f143e1b5ea109d939f51d0bb8e7fcb3beb26d7fb5408cddacba6c8cb6fb58aadf509043b959ee05e47b5b6f1864ce374a6b31239133d2543c92926cc4aec675758c8e6e6e2f4c05624797ca41bd32a45b0431140a5f965d94e586d945543fe07f51a5a757027e363bbdb989b9a12f53cd8245990fee996f9987182ec4c29f34e60585d223244b6a2333b264207a3325182aa915470da5a9125ac70f9173282326f9fd96762ec4ef02478ee9f46e4b9c473bd5bfb4beb81e7120f5f54f15e682d5da96e5233eb72275ebed7d71ba4a22c5d880151a84e81dd81406f72273fd2b252e21884930475de8c26e7426e5781dc22e2f19b653a56dbf6d0516ee498014785c7e9a3c4dc3da59db018a97405fc0ab9669dec2c566036f23f9ba3a922a9918f779b3f0558ea33ca9592e801c12eac0b68c9799544dbea08739baa29248d3fc79bcfe8b63f81629341f557795be1718f5e607a05fffa03588cf2184592f7143efef19cb809ce8e2034da626998b566f05dae70c1d7f2b02af018bbdd7b01baeb5e746ca38d91c2b17b2a19c2705baf9d8c53309bae4f13b5d41b585d9cd6fdbaeb965ff12fc385676592b8fc19ec1ce312870a474a6b90c5c67400293ba6f650e9c58de18d3ea88b2e37dcb2b2526bec7600a739ad19ec044e6a134e154decaf57b1dda933889641f69e3658e98ea7a9cf2c5f1a248caec652d0dbf2a520e26c225315b9a14fbbeb8c0f824555fadc955bc7ee2ca9f6dc33ce6c5e03f397755f6d13b56e2cd4fe2942552505c1b45e463dfc9a88b3b477a39f76ec972e07c067a610c072bbd4ac8934c442f6adb2fba6c772697ab39371e5276afb2465f428e93a88a5b769d05cd600c6ee14e358c0616ed4bf9592f7c36e36e878a7b2477037d0973655a0fe4d7336a58da118713987343302a717cf4cc5bdfb4e867cf40696a66bea412ac3f1021ed0a8e5695155b5ffb8951513a0873a3cdeed404aad753058b9519d5d109b36a862f2b1ededdf7f397d590bce11476a3098bfc9f07d906de0ff3359bc8f00f8c67514cb21a9464c59e9fa7eaa104c7273aac00df13c493bdf71612383330f336ea9d3154726533fb87620b0b1aa3670552c9c848625debefd5d24d6f43e339905f577152b178e53b992e77d9ce24699aa7cca2205ad2e18071be16bb20a00b60062aaa9de3230e2ab4adb865e8fea358acc811553096d840a1d8d9d18cb1749d6624009a4a3f9148b4cd52f5ce540aad61a1c29ac27163eb5f9538122d56f2fa03c541ff3786edc80361ee9ea1bd1c663cb0b48db8f27ed2b518c1588029e16c215376e2664ad5472cbb72830df07c93514b43f72940cf0862e190b8678857ea4238abb2c3f772c44d375d51bb1d5686cfc2b62a5054c0ed6b3d2254449769a337d9ee947dd3a07e4f44a877bfb2d5b8a3a3e5a9882acb381b96d034ab03510c58ccabb256b16519927d4adef4f0d1d6eee2f1b0cc4df0c3cfef5752359a903d35e36ef94737fe6cde403851dd58a9713841fc4eaa6351e6b7b1cb19ecd4704fd7d468ebdf442f4f9b7e22fe07cf29fcfb5bdb284d02c1ef924dd2862944c43b38e708233ea0f66897dad7ca3a1193888f900f53d79a51680fda134ea484861dbb030947d9744640cb333a6f6867667b80f57664ea021e94ad88ec602799658a70dc633897f360ab92fd73ee0bb62527cfd1c2d0ef7801e5e3f0277ec80116d7ccd28a058d1f9a7da282ebf9c91695d3e7c6d8d4f563d3e241eb4ee9851486fb2e96a68b7a1ca886b92d9d18a39ec40d0615aa4d1c268eeddb8eab26bc35d6bd4a39e4d0dade77ff18157d07e6df011b3312a9a524af53ecfbd4d2851cec76ca27d69e525e3703aa0ccbad4f5d9c8267f734e9d4871bbffb17d8f36bc8c49b8d3798cd1c0e80b0712faec5ac19f58a623cb2f08fe338d2cd4fa03cab28e62735710bdc9874b5c208572eced4c9b4ee332346e49d7a1b8fc63a8286e5109e15c3a01eb6c033f3753141f2b78964cc404091cc94cca6534350c4e000df0f44407cd1427d4ced4708ead534269287b0bb77efd403262c880d5f9c8aa9ec09cdaf10a259be3db192c319c3cbcc457bf7eb947781b7120b981bd38a115a4ce4bbef9fd3043fb28c2d0c600c5fe069e4af12bfe499f7c7774241bbbeb1968fa18aa02917f603b9dc04218388258b0e0d3792ce20d45895b4934179f778e921c68a5d77091d3b2d50604539c6b1882c72bf31ac36defbb44f6785dd09057018b113f9c93cf35a74b2f0957482781df6bc730e2f640c16ccd5c70c057fdc848d2b89cb190f6e0de8a4e27240d5116297f63026e6d53a40eaeeec64f2ea01414c3465a4a187642cfa633a7c6d6344790ad22736766facd1ee579b6a6d9b5348964e067f714d3670b003c3a35c19f1d5652cdd9cf069a326d45f766c8285a81ba6febe21ce1e3c5cc922c867432a23dcfcb734f3f0fe8cfdd57af64900436b41e82e69df6a5ca623ded90c7243c13c6f22fedc891c3cd375c8e26e96304e5205cef41a5df291ad12448474560d49e90208f271559fedde1a5ac49c5b7faddb0ee9774acc4f24968fed679d1f22e850970f485d74ca911f9b88d18ba7121e8bee10cf8ab148bc29fb3900ac649d86bb62a490c14d5bbdd28261bea653ad1e331f9972be7bec18a099570aac65409db3ed68b0fbeeccb639c1d3717b3deece95689879940081a225b20b2b896a1cd6db5ad793b730e2ac3c2571735066371b3330f1dab4c87d82de81f4b6ecf76b8ea410c0c52a074947f47c1bbfa335dcdf2cb45bf447b98cad38089f757e1710b3f0df494500e7c409a367f15290bbdefcf20eae15600c287ffbb410fd32bbe2261c60100942b543c3bc526edc973decb46b28e6967b8978334ed3b180f57bd144e42792d43c7ca9c1d796aa2415f18bd0dbfdb0611ad4c3c77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
