<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9627a1f91cd702d887e9be4a40c4b866ce89ba52e12b43ed73e55a213325902d3666c0bc9438dc88187f53b40bf0a84ab4047d9c3b8f83eab0b7c7fdd1a167695ea154755d3e2c5852de15fb2cbac6cdb9976ca3fb4ea3a34447f732744a778f97d21b5ed3d77f0af12f0e1ff1bccbaab80b5380984d7425f0736190fae30564c64b067d8e030932491953d34b67d6e006f831344130248f4546486057e8b8cc1f6b1b84902ac91c1783febd4352528b9df50a1ec23a2be98ede46c0851e6a9c92403ad5018166b8156ecf37899ea5bf0f78bc81f58b1ec87a4e19696e7e7ab80f9abdc14d39cbc3ea73569204b9b01b4350536bc50aa80fb7888f9539696ebbb8c7d4300b7114e32d2661dbd4578dd7cbad487e9566b5864d9c2b939ef96e0bd7bf8e94a0935e09624312cf590e82c3accc31f949d36b56f3dd1af69ab22e7e81d85a43795e48e0884fa556e493159743db9b7e0f213f9efd616b17a3f0ba6425d1117821652d9e8b87052991976580bc9cc33fa0f7327c0195ff026ff44cca6766f99bbe2c982bf6ae6589abe237b50992504475e0d0a40cd00b9fc8387badbac787095dd55897c4b62763ab655f744dbec7067a89744c369dda0e0ce01b023f479cb7dc63b78d40198e8c55c7c361f2924bbf3b81c74c28dcb2ba81c5e2b9d1ef03330f306a446d8a3d7c95e979f8f8915438abf3a0c8b2c252ed3d75a9b928e4ee4121de5a8119d4f68e78dab1303e04a6f58cade97203b434526822558ea3ab58e8443bf4831626e584aa5cb9e593adc7779fc99ac723597a2b75e4cd1b2a1846c74c2dcdc1a2978cf0f3e13dd13ef0c0e151fd21bb51004c909bbe0ce080084b66d167fc0883de9d05783b26bb4e615d80783e6f6a782d118a84b8c2d0a5d12556db5af0c45c6ab49f6bece0558aed7d83f5e7a07816b6122d6a059c54fe43ba734ab569b00f2fa223bd886543978d220639c4fde7558d5d2f149d9408afd22336df77e1c64034acc19237dc5ded8b4acc0f6e52a9eeca22b93cdc6b6b7080ac592a91c420848332711b04936fa1e8c1de73a75534c00d295eedaab7952bc74382f7833ac0eb7d503b6a4963720b21418ad1ad7f8430a484d6d6d116acf73f520fa5f7a9071946d5965b3bfde590b494d04246518d6d6a7ebbca1a1502d98f7d7fb6e58457f7d4fd39b5ca9aa1bac22d7f2b03b53a2789625c1d8cabdebe73eea946a3f4426a2f1e72803a59e00cea0c4429b98bb0c1cfe480140ddd76bb810b32dae52db8d03be08a992a1d138041c4c0a930a2c0462b932c7b11ee593cdb439de3b3a27b7d17414187eb290f16372fabe40606c261fb94645667533dc123e657beb3fb9d944539c16ddd982730fc6bae338b70675b6c830215e5ebd7de2e09f72571e7a3f11d7425b4673493e8939e10cae6d3c4854bc8715e59a24f5325391869f91a50b10d79833b3fbbd1259a7aa1a1897841974bc21a3c471f48d008feb45bfae33877273a1c97633eb8fc977824a2f19bb198e4191e7e82e09689eef3bcc06ac94649ce64fea277e9f172e5cb45e76cd94815512da2fb04b8ea77ca6ac258272da20f63e16b224f9bdd84179dce4436b7cd98ea57ea26eeb3ac61a94aa28c991d52e1060fee03b01ef982f4c4c4dd870e8e8a52868e55421ac3e41356086454ae4f2df2b512fc8b1354551de6533453a92b5083ed8c9b961c5fd405920dc2b3a9c082264abf329dd5cce1810894e153c56d831fcf40506070ae498adc6bf22e1da736b4da3e0371f85e59135181d90daf1c214afdfc93de3c58732497b4d6ead40f15a41d48d17a2b892cd43a5c1271e88a378d4c8e93fb301b4b92956f8444d01211771b437973ae3b577d4d3444b79cd72ac5f843d11023f25be98082985f62e2d706b43a393912bc61992f307a8b08ccbf1a843ffa49235dcbb662530e4fa6b302ff8443de05073da690e988d96c86d6c6b43b897d105742d2acf3eac02544bea6e8dfdac1022fefe4d58e0b07d39d16638128649babd4e8def149308b851c3b34d7c34251f20e9f3dc4a6b8cd57e96f8e01eb225f2d48ed0fea527898a97ec45e5e057497b4ecc9361e8133d6a72b4a1234e47dfcafa20acf2b49c8dc465684fdb0d77adcba9056f01d988ae25c210e40cebe45040dfbfeb16c30f36295c569edda6a78e5088ce6701f1bf7502bb21ac0ec25e8051aac0e516a4a389d0fd492668865b2bdaef94e1c6a990155b9a94f4164730d77536eeab7043851c6de76bcdaf1691afcbcbc0b1a0935771ffdb6f936617c957154e6fae69c6347836129794c70f1106115ddc8158a341a99580509ddebe2ba47f996d613746c5de4e54dc4bf7860c97ad7ab57555180664a920b7f095370885ded202b51c643d1cbe95dac822ac4bde633f92143dcdaed7ab7336c2a2adf88b59193142720c043be1ffd8aa6b413fcb0cf71247baa5186fbfe5f74e7e216b8015610e6838e4242714264ad80ff750201d88dd22416342c94af17973be843920ad578cce3ed8b8aa7d4afbcae9c9e8ed588486e66bee993e9b81dcbd9b16d2d68d23b3f8bb0ec8e1f8082a4beeaad3b3e740c6543fbffa58ba3647aa827658485eff97882d6aa2388a8af8a90b00256925cea687f41b839c398dadbefe04e81c9bac592f9788c55f13557c8250d4d01fad21020842caaf40758b5ac4191fdc9ff382e12edc491480f03cdc1e895ebc91623a0f11789171663eda5fcdaf67fb7c2210ee41bbfcb20d5fe1e0b13d27fac46eb8bcb0d664c5459d5be868552bd6ef594595e176b46bcb90fd233bfdc1bf770af64ffedb0364a6c247829b1ccf19a29a866689edd4d239c9deed2ad2ee1efb80913f507672be54b6542d1e458ecbf7b1073227d06fb76f431e9408973bdf4745dbcf88fd917b1ebcb14ffd9d9ee2986d9e01996ba86bb17e3d6dd8c2534e896fa19361643d2cab5a437386b4081b6a4ef436fbf0965ced2d8cc414d13ec5f95b9a08609e4876567fa4a4baed68811b457caa5fdfbe7fa8a30250c9d67f23a1ab3d2d0ec61407ebdd3fd7d40bce3f7d4d56b80fd95dca7597df7aa0f260cd889712ed63062561040e24b6eb7d91271f06ff72d0a759ce99f33e85d6429b9bb5620dee778dcaa57386421f5194a40aa45c68e2b3ec5ae8e787c2bf19390abf431a8b1af4a86bdf738c988c708680609d4f884f96fe9d454cb827f7d40f4bc19e8268936ea5e0b9163dd82a04511b2a08df155aa17c7c3d1639b7b2d8504e004fd5203e21b44d31668c02fef0ed8a2eb314a50deba971b545b19235ecdf00744b7f0bae289f379286847afe3c8dafc1bd5e1da00743ad24b2f6b641aee7fa6fb12c8729a15e9e5920643c05741b71cee123b4577cd25e0f614cce5bce7d15631c147c3cc0dfdb5703a70536877c3a0befdfc0c753e0fe1c30253dc3a75f47b08a4c7f71f012ae7405a410be0e2fb9633b5065d145fe7c62abfd550b6253f083e14b609dc811c38bab457f1f59b0d44de417d25913ea22fc9259626fe5cd3ddee6b40adaf529c92b27cfb672e1b387e15fdbdbc2b8bf272227ef5051ce3be84567035ff78d8573f227e4c40c1c296d2388da1134d1d8a8d7ed7e67d8b060750d3f1225fe5c0cb494f25248074129dc800e6bedded829b63677d0794927f040f5165e1d896be760f8d3c5eae24d4d17296be96cefd2fbc2e963ac30ba88b6e17f14808402c527c56bc07fc370f563d97e435c1dfd2087762a4f5f24a3e0cd36a17f938f5bef45325b0f08bf00a8fe921f57a3df2a3fed243da185c56dc08b48c66cfdabc4230f524e3293424330e2e7cecd7b0d88cd0cc3c783d97b18ffa851b8eba5d19b95b9918bb7570d9545f01ee57d5ffc0942a21ec8c5240a3843f395785726bf525357ac170710d84c759f495a1deea4eabdd99ebcd639e45376585d676fa47b16efa5845e5120752ef3d9b90fc8414ceb3e55ab8cc6bc1dda77f8c14790b662c5873f5481f28722db0ba3a350366e4c7e12c7e5d2f5d4b19eb9f52d02a34c50b2a0280c30abcc864143464fba48ca6a4ede660fcf4da8a72e14b8ac3a9fcbf5f7cef672117e69741db68c3c931c52c4caf5b36d131300db21ec43f952c274bb9cfd81c61b49d8beb4b128d4a8e6a9fd29fbed05d190d72fdae764387c540163266848c5dbccb5e0a2550243f34b258b51a267de0f04040d133594ba5f9dda04b9f80ee2a3e92d283a26e9f340d5322aa1ea73a9afadc6d20bf67cd6eeaf703c7da59e0c0224e2285179431878c1fdf41c70701ef5a473c24d62217e964d0af6235b501cf205fa7b0abf1f342caf14ab07c1d4a2d20287f898f7fd6aeb3771cfe73bb88374eb3b43c5e02e50a34ff0846d9f8369effc4c6b42705cc7bdbf29a09dc7a3f2d0cae8f6e364dc490b75381ac55eaf957be23f18fceae5f9a850aead7bbaf0683addb7ba1d72ea614eb618b947e95f9f1625dbd51c44d809b4b382df03567a556e725a6047d7e7aba1fdc76ac4664b726a4e5e29b231c32b17d04df7e8d1ea5aafc439d3dce9e1f46a5ac7958f324463b8371554ff6332a5e71c7a1fc01a56cd69c38c872fc0470b518d6eedab28843b3ee350c9197ae145a26c397a5ac5025fb261f7e94a6d54d9ae7ecc9490359dfc23ede9aefa0ed5981d7fbeffeadd31c0a4f5fd643473fff2f0de2a4bb9f955a9b834a25aa55e255eaee3a895643e8b2a784ed2a8b532d2347070882cd9c8cbfbe401f2f99f15e2842d56ea00a0587dba1c227bef153ee66986e4fac1f4627bfbb1242c43a5c4669c6a3d5726a6815692886a1d612e3000ee204edabb7f2db1b69e8fe2f416e267b9f12d70e4f82c0c457bd431b088b38587360c4cdc35e5698a38a7e9f971d737784d700d12313819a8ef423ffadebd09f216e7acd60a12a719b368392273634e4944bee99b5c9a8ad43bd98538c9e1e588ef043eee7718fb63b2bbd29a0987fb30ad727ba82686d88aa059221a29a573fe5b0426ec6088f6ebf67b692abd750cf1e2dba0274e5cebecee928b75e0371f705c62cdc8b655b4e3478b012964cbde520938f4dcbe4362737edc6d8f02b6914cbb038bf09f67315f533bb5301da82f0e4b6348df7e4aa61b425ea9ff25d34a2aafca5a7d6dd1161d23d82dc82913113b5aa4eed3fa2bae772b5544346ea8e1bda89ab0fb2d5a4d1445c15df30fc68d6d976817399f924f43e493a9d06a8e6b0553b29abe68d8004fa855233996000f51ea209dbf6f133eae1d8a14e6a35c37ead0ff6ac39ce7fa0f026f65d1329bf02aa8349c30fbc5bc95708dc07643308c7a38c22dec7bf871306a07eae3da69e8caeeeae35c529092bb8eb1a77a5ffc094a5352a3c8d9609ccbcb167337ced922010d22c67238de1c2f66a0d121d5b652205533533c334d96620a3e574e86e86712b53b4908425bdb9ebd009c059e5fd9ce397140b2d2f66ffb02091a308fd6694c9947ac24d312229d8f94e2398bacec4b9eb1aeeb1427ccc8b798164722896504cef92a25c416824c8b47f0fa69cc6548969a466fe7b2da11f15063758eb0d31f60747ec95b93d16db22f32e2c9c32f3578f666a230718186a515716443e2abfce5d977253fe849856536c66d7bc47a025881c8559cdf58a34cc6e3996d6e0b8514f5f11598539f219ea0006e40a5df5ed8f76512cbd9020dda0adbb46009b98fe587ab1c6c6430154300c1fd5cd3870d8a770f645b3a6b8a2b21dc4f583e630b2f9d211698cc25bef0c3c390339fabc1121fa86bbe77044053b359e76ccd1578a55797c0d4458d1446bb101cdd45cae295c5fe52f7497ae5f2220bcb73818087f65ba0cc422aa4ca58a98cabc373aefa7680e6356d2f4fac0fcffe6341a448c505228e9580daa1008e57bdc7fde297d764ac81fcc4d712c12a78f6e52f5d56a1f90cfecb899560064a8f096c2d4c8883a9c42747e618d42bcd6c6bcd2421cbbd0322192823fe3d5d94a0dfe1824b574a5d70f1cb98358e7beeac1a34febfdfb017b2fbbe4624110c341571c2c4453288802575fbe8a786b42b480c324f82252455bc1e6ee911b335a8255d6117f091703ba06a6a6eea12005fef6c6f50d8e77970539fc067d0acd1c5069a1a06ae2bcfaca6224e325c291605b3d1b0c58f66381645d3e3f55c91dcab19f846999be23d6568670aef7311ad67339d5469dd48093ab4b9ac5c95eb9303de3dc07343a2e5e4dd7267978700fdde9fde54aa23f38cd2d11485ee0c606397de20a69cbd9f94545991f374dca1147d8158db454300ac1e36041fe7793771834a6049ae419bfb21b78081eb8003f908e84f5765d9f758a3eba42e71bb3ca1dadd74908c05b57876390d66daf3256f3610b4fb0b3beaa510ce03acc6121b330a984bdc9dfc36239fbc11507a47ce3386254ed5e493c967280b59918e205d87e71a7eef1f0749f3f9107b5c99bdc5e311e1a60edfa8a4bdaa28f748cb8659a0d04e3dc90b05ddb48439729ab121cbd2df51dc5ca3ceb43271acfcd42fa206ec7cd91208569e51fb70c16eed053ff853fa8921923040535ea2e50e3181465ae4c9bc53d0a3d4bf8e451b181672e50ebc893e81bd9e9df153f8cb3cfe5482e28366b17e41ba0082d11ccbf4ebe9137a816e429b0b195330f0e832fdc40fa98069db806181de09d6a2aefc8b2335fd6843ab4b5266fc85ab654bc0ecab868443bd63b0f6deb97b47a108b9011f4c1e966cdf5f06fdaaba65c379f75d32df27e8e1d231fb334d376ade143ae12893d42f4bafe627a4407788211877fc8adaccd0b0c8fdb6f95e18a807bc2362afc6ad9b547c9543e47a5c131532518faf89429d1568a290dd404b80ed6926db608e22a640fedb3f209f9a4e05c9570ce0c3b70204011e98b6a2964f7d2a6547c82dda2e8e8ba585f307a43a5bb4017f93568a871b911a60e749e34f4062d32d8eca74ae983bfe1e7f5422a1c535d95747cd679c7e94535da6c3ee5934be07198406a2422e0ce82173b4903a836d54a31d19e808fb677aa8fd6ca172d2c3bede01674cc912c669d27e5aaa35a46fdac316e805343d4248bd263611fb42255dd16044c094525ed837779cac6b48a7648634ad6952f06af524e30baba7da736caae686e7318eff41acc5b00bf9525b0c70792655ac8fa957fb34c2f1351c9acca4c5e22dbf3c17c2934e5f938dbcdfdc3902184162c6eddc3d1e66b3b368f0f67e9f0360a83da11d2fa2f8b0a56ade658a8470e827b53babcc333334db0f27da05939b3fa004e771a7919f9f142bf9053ab03d2b119e6f6244ba50df74a1182d15b680ba4b6e1647656436c6197894f7ace6b28d876a23896523ab62ab547d84a3d4a54c9427be6cd083ebfd7353e143664432363aaabdca476588ba96fa928e0490dab388c4b26c8083520820e5b7f720d908cb6f1b4277b9ff3aa0789b3b3bcf1d1318ba4d37049fe9087ea09362e4d9c6c5432a013fa44e4cd629b0536e38ea68816b2ab55431020c3298e7a5fbca9e83add22bda057c9233fdbf2f16c56f0fcfe43d09a9e1b7408a4cdb5ab4c9298318f02be337a01af4bd280f07b6b21178a84445fdf065ad746a0eba8cfd72a6325b3c8a8a9d23784094c7916a5318718973be4f60e3cb7168804ff25a201df434b35f35ac792d7905d79d60ef8413c7017514da4d2b0571c76c308c4eee14bda0c745a92623a16d34c1652593a89e159e5e6f10b96792c3e62e4a717f422b131c1a58a798a62786d1dadb72af7313f13060a923d87a59a35169edaa06a730788e835010da7718ee97b345b2f7a5c700e4aa3aa1ef926b6fea7eefdbd79aeee507f71eec9d5dd38a2371da98a7448dd8e657050ccd2efe2f05a3d05c77267903d3529efa5c17a321d3dd71ea6c67979d56bde7c5704c84cbabd8aa829520f95f9d745098f4db184a867ffbe8bfcb8e7eed419ae12035f9334709f5a26d9036ff702561fb01c6d0e931c81712d9812c61bfad092ccf6fe455ff2579bc60b01a7c63af24b2a26dc3576d656d1db797f40fb6a83f11443710e38f4dcb46f261a91cced81f63f0cac2f9166cc79f70b2a8271001d550ac9049d2cbc578841e333d0b92dec3f6a548b0e039258811dbde48bd772eba38701651994f43e279f538c46ed9d3b4f43fdcbb5c36248ea6b76867f76df9aae5ce823d438cdd954a50c091bdcb0a86b644e8dd0e40373e121edae04875b030907c6284595f38bbdad5869ab987bcc447aca842f4db41ee5c8d67491cbb54487c9811bfb4e722462baa76e1fc3e1abee901d195d0417cf64c79591756fdc2d2fe8e964e3f0436c1d018afdd518fa54d3c9dbe0292d4a9046ef6e22d671b4ef4fe549a0e7fab42529a634590c79ebfb94e86570522c8a12fc52b5acecf1da1359371b40731a72c46aa31d324ad5b521434c9b2d68144a0568fa6229e81c4dd4268441862329ad06fffc08f594a96ed4641167f2d2b513ed8bb2695b3db1eb5c0eed84f95205f3b8ed1211b05c617f5877a46ab2db8446ceee1edb2453df06f8a6d3d284e67796b12949b42ea6cf35afd7d29e8cac015fd5c861bdfac629668e8082c400895daedac6148117bb8ece2390da78fdf9d79e60c06e4d2ee839afaabe58a2fff8c9b46b44857acbab1edba477d798f36d8360a26d99f5f77d5cf70a27ffadfd7d9851007bb96d36ba1d270a38b1534ee1e087a2dc8d2e690fcd199689676f3bb1f56d19de2308e71b2f2225244bf8fd9158df0430330845203b601b56c9cfc66ce579194364d63969203683a3642e17be0b809a8ecc7db72ab2200d5db92cb46380fad75f684db3613515773e313ea8cbf1c3c358545e1f4283dbbc409f45cf8c599a3b6f281aad8c01485c6ab54886882ce57642f6f1c8657b45baec717b2cbb1221e75e77c9005e746eff5f9c0996cdb0d492aa551707f5848c7e8dc9dd485570b96b7cc5470f962e02bd7cef4beb77c4e64a86c461a2a8eebc5ab0fd96151219713664ed19ea8ff0835fb213f0cb03854f0543fd633af8b66e2a40d051af4ee0c346b695354d225b4a0960b3cca1635c4b469fb59340e0c58b7193ffe9e4a0fe8f152e9adcde1044ae193e4da1130beefc939dee5545937dae468c9dd0e3894611fd5da7f3d376d6eb8d1cc34f4f47e1d67fc7ebfe5212309319e17d1fe4635103eeef256bc6c62ee3c1ff6fc7e73c36da7349c06499db09b49a764530790eaf407ed0cc4a62073f2c57e343da7912d32cdaceeb96d0503496706f1849c99fb6e31ab6c0e1650737be1f94c256faff1e7e7b2aa8c879550487366f998e9bfdc0f908ce8f8ca5bcf2098189615005a5d0af78b2890323ecbbbed5919690a09a1a87d82480511a3b99ad63974bba511574c65ba0941c9455091717549dc5b33884c836da63672ed382d54910884f359b25794d1564c7b77f51260e28fc1f21f75a18cb142e9b91b110fc2a9151f89e856b1ef6fade2b6083f390621f90579bddf04b373d9fc08bd84abafa41af1302dc782e065b2ddd41271ae11611f43587793a2b066fbbd90359ec3ff4843595a0a30baf5a15f42aa95ed658e377c2c4471f454298cbfac63fe94e6e4526da7c9149ccf52f51d5d8275cc7b6e915704205dd726d7f7dc844f96ca81732805ad9bbfa35ebc700917bb84684f695245db8901410f45f5979c5956f619a55139c146d512dd6ffa72ba056d1bdcae4746f263eaf74943b6da535a9e3630ffe9821a809cdb12617f0044775b3a7ddca411e4f6256a7567c1a73a82a9d5f3f23326a9b0f0d76109a0f773394091f1f62776aab2823d0b58fe7e6b18dfcb71e933ac08cb226dbda799505c101169a214bd61ab4f8c2b81ee88a1e1baf32152a538068007bccdee1676527c81250ad7e26ca10c95df352cebb896bc4dbc06f71465912a627978cbdbec2cd24f276466172bf712debb00b040b35704c0b77119b937d44a13710ecf2414a567de482aec294ebccd3958c8253fcff5083622deb4bc5e1fe69afbe943607cf3dcc8d7d851a6fb5249fb0c23c9d28ef47bdcc0f1e9515c3775819824f88e63ddeff9b3dc2cada7e881e06022766f15a7e3bf5026d345d00a15330fdc725abee1e86d1f55ff75247f3bc96b98e500c8be382a9e48fa0924e46bbc0350c7bfb5768fc92769d21576232459c0c12afc5475612037b4ba82f3b248499d7b4672f6ec720c5ccb3a154677f973250fed44fd7a0b695f4774d0b147f7b01a699741e85da1812b8d66ce2e19ef5ec01f2247508aacc1e2330e15c5a488f50f24f664ff1957e7c847319085aebe92950c7a06093be9e462b55eb89ba0f81b66a6115a60ad906ca734a4a3e3499c79f47c2f6069418b4b7f1a31e5bc560b49dec3a992fcb1f759829dc0909236328346eb1040098ed0e38758efb937dbf2683a07a1b41eca4e494f77f367a06d13c73983196a085c295e701b8de15d23e4e9aa330ade5e0bf8a2a412382cd5c38dd00e576741d5416bc83613b8aea81bd651efb48b8090522abab135c6755e8fb56a99cb5696eeb97689d28d96e7e43e3ffd7565aaa9585694a7cdeef288b6d10d023e0d203db6c896131e73fd0d733dc2857483c364cdec78963f24a24e6c4a2f5e98e9d3366bfbebcb3344a4e97a5325c8879e1972a3d238f69f907beeeeced8cd746bc07a7f33415e216a286b44cd2c3d8b47601989dbceed8a87f629b3feb46d35ff36625de52c4e2db08e130e588cb8edf9993393f440a4cf2b49e4c2637de2697c7e1f9e423538a0d8ca063706fe1dfdddfedfff54a8004503992dbd8619638c266887f94bc89e5c62ff61c787c933324d61bbc89c8aa5804eaebe02bf41c394a4cc1326dcf0e3741d1e9f3ebd550cad535fea43cd79d827d58421bccc146c1aa73e6acda04bcc063ea2285edbf22feffbb772d1e58e417af99f8d86ccf3ce56b25472a72c83ff6ab82109378e59049b1c1b08d7e5ff0666f11b802d6194071ad5f222611be25a2d0a6247a697f7c690aaf58df1715124a6fc5d6a9929bf198b0dddd7fde124a159636753a82e2a671f907399ba7af5fe62261e12ab217b914cb66f11f6050abd19490779016e989b3e2b55de253a61b9b5760daf18301185188189cb4cacbe89c4314533718d3d1fac9e75f8a33c18906192e4e58a6d012fb4d409e543557f778db89a117811bcc2bfb9910deda01d403cadc076cb3a55ab015aa31c8521604545eaac01a0ecb079ebeebc968a7fe5630d3122695175ba8dec2e2f4dd1de12434347d8d21148cefc2570b4992078962e9f99075db81e015ed1ffad38b62da6a8c7fc2e20e1678fad4f2c4af9743ca7dc9b4bd95fb0853ed33f611739920f4a9f7178c923bbadc08958562286077757f82e35bf389fe455cef22ae0cb394cca6d1805647263e8fac63b17ca5a58c7d8deec90adb4064a58fe0e58cd5cba572c979bd6f98b4f40779413ac022f75d4f46beadc12db3089bde275471f73653cb7dff9187d1ef8c9d6f3cc997a65f1bc9ba663a19430ce5fc3e04db37df855cea0658e312924a530028b919783475d7475eb57116d999b0cfe54f512a8c6bac43883162265354f576ea1dc9bf504f7518f6333307bee74c4455e807d9e30b1089aea412627d7b0651e5f414fdfb86d8de524085acb4f6795d0df3dc4e1c07fcf34a862406af0ef906718465fd744af19dac9dca2e224674f82328ef1213f9c6f0c0405ef9448af942e1c5d42ab3890dd7b91e3e9a0c5b939ce51ebd5480b3cfff49dedae2a0ab908a9cc01031cbca25157920412392e129f4c29f1e7ced9fa0fbe51c77cebfdc308bc8978e7ed621f73a16d21a45b6c55c97f67c4f2fdedffcd71d87d9be5d0edd6d25012e25881fd5bf9306227e0d159fd41093e21fed3e91b443fb470dbf9cc82e366ae10c00b05bcfeae476dff751b00407dcb6e12ae424221d2b205aaa84205e14edf1ec895ae202443c18de71193421a940ca0c4dcfb7180b8b7d3f4117953b8114a89b1d464449f800cd75d648516d8db5e27bce06a874baa8ac54c3202b1c5aca95aca08625f467472b7c6a49253725d4c7c3e9a3489c35f57790132343329eb9fe6aa6e0f7c95938f47cf944cac8fee3f667de482ffb86e39dc940465037f642bc2ed257f55d67f662bee11b49fee2bd3efdfb67ee992c0d29811ee14542854c38e2c8d0d398ea8f87d8851d8be6ba7241f208c40d8c15cf33c60c6798ab173585a0e32277390d23f05f4373464cb27073241d60b6bf865bcaaf24cb0578ed5efb761fb597e97dfa66017bd09da7a043003435768c874f3bee1eea3b0a23a1d5dff3e1ef6131412f4a881030560bd4a55d849360b4f40ac054fd7537d3469397b78b021b6c986a02c5483252e9f7b40642eca580931815994d9ba8516a17d32d0f270582c3a3466499735608ec4df896518a7b1e7e24cf86f11e1a0e600b451246092290496ae93ea1f330dabdc30b721bfa7f9e14c7a861a46586364265cbb74aa0679816fbce788e56f7439de1826a9eb80609bedfb921c400ec3001e7c45355a38ba489873e2ac3442a8b50b99054b1506791c92fb9eba31b33f67c410354c9ec5a0bb5746a8074742c74a8fff9f72d75aa8853cd84461198668ff02387caa14a4b7dfb74b1c3eeda7dec6a2a3a8169c0b5051484dc0edc2250639922a04ad25c681ffa82275c11205d0a46aa39c9f0266038ef3202434af13d192ccdee8816396c40066dc4e960926691168f597b2f5149a734ce27e20bae11a9b24170412388e819a0ad683577e1b9224216c23ae52870a6e1eb9e6b883c7079046f0e3236a53fbae6bf0d78070e68f74bc4a51b00ddcb4eff0c5b84580a7a3f31e21fdffa8b30aacd3efa4b64b1db2600e2e6f14b64ff34d5d176fabb582ee884e1fb2ad56003aae32407a75981ce7bcd65af71729720008dda75c082afa7804bb114b4522c76862ada498dffebc883bc0b5b03cb9be496ef903c691f9f209cdb737ffcc7eb42c48a581611e27a4b3a766280dc8ed2fc05baaf55bd5bed5f34f1ba93c59fad51d3a7c59eca6919f98517fbd51440adb643a628c7b7d33bb463e09af12e13dad962d17bc8291c084a49d5383f5694f31ba91b6a59d19e8ec03a2a52f85cc1ec06906f2921c6df160ed620942e8e29f727e7b1d424280c6d2bfbb64e9e3dca7235753196a64ed0828e52dab5b6aee0c836f10e2a4d3685dd0abf320dcc30bdc716f6a9731a5c6ed808a812478775a1b193008bc6b7eb6bbcc9c288976fc6c9bc815e4aa22360df42ec81157ae6d8d2be5918727bc52b3986f8fd21e96f1207467b0777d8d0326f4aa44f0797e00a4189bf5a9b6159d1951817f26db8794130e391ffcd8743a9176197b1f95dc7eef6d3cdcafb1ba648677873b345ec6fd8b7dc61e6c5c534ae7faa20cffda77e55d8fee926b1b30d7b9dda927ad6ad2f061346b78688f5c3ec2d958b668cc4c86134e882820dba80394e228cb06c5dc7f726755fe40c9a45b5374c2fee81ae17b8c5c4687e3205e5962de69c70364cb94cf60eed19716924a21733f10e8f0f474d27611418890011cf03ae6f0a5e0321093776c1f7acf273647653af91637a3eda604bfed85729196e86cf0b3b8e388132c8706bf90c177ae6cae74c6905677e84873d20961074b096331338c8db6adb1103f9a3e983dadc9baab062e6960f603877196b0c41b9019c540eca59e4fc08e1e1b7b00b5874ad01c9f0b9a83ecb80eb639502838c746c6327c55f980d5b28b98e6afc9a861f6c86eee7d14c3e7cffa6460274e2d91c77b8b0701c7b26929aaa2afc4747bc095b3d4e036ed79d7e43e58ef1af851b982750a949288ee06c5e9b199c8ca7308ce24aaa4cb13adf3cb9376f1dce7c0c7830e8b326162a74acedc97a930c371e081cb7866bf3d0ce204a7ddcefe3f49c0268afb971a8bacb46edd089d3df48f50ab9e998219664ea7d2fd3857f78d6d5a465a6f50a21fc4f26686d78be6c35d720a46f6cafddac0a8b5855fec40b81b20110c1cd383c5cca614df3020fd963795d4bedd56be5954703dc02568bbb95861e2d05bedfbcda648d059bbb93359e3caa866af4b7fac1fec964c4b7bfffa9f4c101dc45a893e5f95c73d5249ef61c5d2c8df4dd000bf430ecfff223fddd6f725dcb98feba8a3bc5a4e58eea68bf26d0a441b9e9365d6cbc4c3200e75e14da2b76c5b873b7e89ec7ba297fed8f5c637578663d1ab798012ff57a8f054f6222c10516c86680bd0dc9c45b12582a5f804129bc9500163d07909b1a4743dce026b87c9469b87de929efe2a579afda93a2dc622aa7cf3a4f8a453f6d30c5a2f4588d9c3846d6babf009ce45c9f7de0aecf69273912a17dee1cb6370e06e1aebe5c8ced40d50d67ead6dcad24d52aef37a7c8cc880621b4450ef0e58c3917ac6704d700403736614cb3ffd9907cefcb135629ca6926fc949803672d984e21541ad7f916871a782e88d87e20446720f0c4f050c43cfd22ea4a95995a96e72cc74833532013c8ca693051d898f547046222db3a4cb340b17ceac0d41d7a719aa22e13d073cdcd3e3d4b5accb92019d54f290a8f735ac447ae773fe03353bc5537f294c430629abb08cb26eee813b63189bddbf6519fb81fbc6231435071f6e814da300881223b4eebb0fa6bece7f8d5371190df8402cba66a6db9426230d5ce85eede54eaf15ed4566200de48a5cee633d90d9535a4b6b2232a9700d71116a14bebbdf5dcb8cddb551fd06d77cce72e1c509fe6472f1b04c3787c95754171d0d6682868c76e21e27b21f06e6c4515ad8be32c3f69ae9f2fa7a6df71b605f99ab8fbf42b654b3555bc6d2bd3de561378ead5c755337ad5b68d44000e28aa6a6aa559733666c1a382be12bc304b909597a1e238d364f8fb8e69c36bae2cbc739af2f2bd0e9e3b7d875443352d335f0716820278edf1d331c70abbbbd775e626e9db3f1615838e114d8cbc11a711471004101c8b554e69c37286825f412862aff03821282039a8f228b257b1439e212c70c735d970f8c0c888a4a95486623fae578e00a8384ddfde3e1b022964926a271b0b819ce6567131d912191758462e9c668dbc0b31304db2cedafaca92f361e5bfa15926e1551794b0d0ca06acd2a8d1c93b8ef7e7703a0d4691e6f9ed2d7e6f4de7e3161c8afe42785b660becece9f0bcf429c7f990a118f24fe7b364d1808c75cd8bae9bde729a95ba978dd82730040c166b90ef50e29c281f806d47d11c3bc10a9713fccbea1be68ee79ff6be50a723ae4cf55987164c5f49722af60639cdcc333d23aa988c3646e0688c62ccdbc261af4e21600c02bca717e4029bba8de5b85c0ebffe9427f482232711c55a6e661c05596aee172f188ad4d74e431e6160a5cb2ac16a4c4080078de2ba074c4a082d26b3c146e1646242b02b0090cc99cf76d7e63df5d9890adef37aef20fafcdd0056da31e9d88928091611057c1c880c865c9499814c192fc586f3aed9edf19adb84612823e51d1efbb709b986dc45f8ff4974930499c28f118e1cfd19599a89239f3757a2bb05cd2d7a243c1e56a8001f4ffdcf65efc664def60d1c0e76dcf96658c71e55cef2a07316663f2f432bef21e6739f0f490c43959e7fa0db8d06ee5325f0dafc99adcdcabd4b86d8b1e29f441e11b671e1459f3e94a8e22e749cfb3ffabb643ef6ae82d52e03c8ab323caaca405a9e0eb1fd1d732fa3260ea4ef10f371c2047c0dd081e78c4ad40fc101544f8f108d5e79fbd1ed1f9650bb01eb09bf42d4a5add0550192ece0d187ee261f7bed8f6e51196c9db5f4d4c2c5697f14faeacac4e75b81545e95ca7af60af47afeaa6c83969f04c32cbbcb5f9f2cf5d1a80217dc519eea388495ecccc6113bd377a95f7fc50eb584a025a9da7016559047eae596eca870fd2fc61d04a71294f23bca61ffb6c45fbc6e52be91d18dc2e2c1e82fd4aeffc3f81f772859a625c4d53541b95f36e486adba879e800e3f7bfd591c12fa1c81658b92235a0233ee01eac42a6b1f474354ed531145870411215c4b02146eca54633a102f02688022d48c79d13aeb0130ffdf8a231019924d897f0cc7fe4ef9a8d85898f88dd509478738303250e050f8b2f64a0781ed642e5383e8ee20c1fcfbb4df562cc9f3a27a3edcad18dbf242d48b580ab0a793ce1b1d59a28368203deaf57c285a32aa857f04154eeb976d5e5cb5c6e96f801bad73a2b0a9b3ec15c8b21f2a16955fa5f97c7cdf2ae5070446e1311d6801e34644d7bd6c1c15823a5d1d4815a9527ce9c5777afdec366116b3d34b387490552b2ffc22b3fc75fea1831584cd7f464f85042030b457b0902c423063c747cba80ef57a0fdabdf8be8d7db303c811065fdac8bdcd35dc5e644fd84948306faedec133d1d26107bfbc63398e8a446076680408cbcf1d068ac5c16266d80373f5dd8579bbd860a65df0d4805184a6e15f8f22d5e7b727c613b75d10842e290faf998cc413d399e0ccf037b2f5167cb5523f76785a41ae9f042dcbbba69b1e637e5ca83d7fe1bd0008a5fd706dbcb5ecb2a996c39767d6dc8b67ede9cfcd46bd346a9ad0b45304684e6b16afddf0a4264c04571c783fc8a2ad12ab4f05461c6e3090558272721638a53a06ca8232566c1852e65601572d80a8ec04982aed88badbf0f9d03a6fba9da0b693e84904ec4bd1616ba37e5a70ae06bc3b6e8cae20ac5964f8a85d8e6fc0f434c201bc6f335e77fe944fa92ad92cde32b10de3b557d65b7571f150c6b5de06866ec700dfdc12c6be1bc4a7e9e6c9b80939186b3934152c7684abb550a9404f2b3488acc98c6b64daacc8013c573659d1918fef7ef67b5e90f2bdcb9a6fa8616bea9e3f0e7da873e00565cfeeb8a261a1979fb55aea1cdc52be239100321087d65284607911ce9db5dc34c7a6d697b3140f0dc16d21c2e9443712ffc9b6fc02a7ebf6321de13c8c1294d5ca63b4bb3c1569674d8732a49e3e3679653f8a32d00fdd672e51d59b648935e6e66995c62fc07338a4af5723fd7a84ca734a55ba0a14fa57ec1f21c8e6bff96d30a6e937fc758662837479e6b7c8da84f0832637c3e366f9c622e7b640a956e56113b377210a509ce69934a9fc53ebbee280e7f0b1cb4f85eab9a01ed22b2ce5a6c09e1bf515791d981f32dc5518b2aa8c1f8fd8a52d4495936876c9c3b1ec3e3d37d5a9e8de4180ab17ecda73f467f921b16a98b7279d50e34eac549cd86dda55a1eb6bc258a1182afae3d214f500ff997accb8182f91639e6646750f612d927619645b619318c1fcc23cbdd6889d984438afb371e917ee356ed3dfa0bfc6999750efa96ab17de469476364485abbed9681a898ac5858a26bd00a843ff26f2093b9b71a98a27ca0573fe688151b13617aae4ebcb3587c473e3f92f457f50fde70e3020399c75a80cd01f1ed84f20469797d15e0f806daa04802613b030f23a577a52cf8d48e68b0361b5f84653e41a216719d2257d9a4e9b7b1224d2b84300c688b3c966dceb6c9450c3ae5f4b1a8e13966641d2375c09909f34bdd2fcc45a1b2d3c393c391e73f9367d75662fdc8e70f3cb2ba33d0aee10a730377a59e6f5de25d6c73f712664649e7296f8ab16fd392b2d6f336fc44e135fd1a2f2c5e97459df05c7d212868876e23dd1d6c13885e2d411c3acb0d8c4ce95fd4865ed96aa5cf8fcc77eadcf2bcdae8e9d56eb48996b143c76c23aa00833b0f00607560ddf2a499554c44347dbc2cf0ba5956fcb8aa6c484c251fd0d6ffaf0f3ab99ba4bf8a72c771e443d91a7b75669e89911cc65f48e85461b2afcad14a738e911b3154802f1fdfed2b5a9e341173913d4e618d93d43112141ded6d5222abb342015972ccd4e67acaf240ef508f3c016f6d5931dfa0e638fd5728c99731528c622156fa28ea2df925a99473c01a6a31d3dcd823e86fff04e3bee4ea4f73fa941aa99847e6981f3b3e37105a3016c3e3ba06936289","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
