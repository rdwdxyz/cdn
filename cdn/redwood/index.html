<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16b533f1dacedd69892ce7441f649c440ea86584efdb9c90c48f815dfa8a0ccc736e8195cdcee11203f2ecb78c478c6c2ffffaddbd11edd4dcc303aff389b5c93bb42e719e74c6884f8a8caf65ab34a05869555b39a4deae63bde6f148d8da3c6ec93a8fbcac10b92b0043fb363af95150177d3bc0004003739053c37410c6ae17645a3ffb7c73f9f4f0bf725ba38841f7c7174a4098a3dc2835508da14369b8dbf7177167403e80e0734b9c0e0c7e7deaefac59db72d3f3d1ff21fb55e11ca2d89d816bd299f06775febc9db13ad04513b4de28824bcf8a6a2f499f01cfc01471714d70a3b0de29fe182413d5c69e038f07e5f8e71ce71edad04a0f4cdc4a62b7b5414044d19118c2442cacdb358f69825ab1800cf6121bcd09470713172a4d93144de72ed4eec6411b12f1990a9fd1b5972259fd1fea9dd70f56e2f70a15d0beae5e1ccd26eab8db54d9bede646a4318ad285c12b861a48460d393750642e5160fa87161ebbe2cce1862383593387e1bb7dbcdd286271fc206ef04683e79e55a1e1c709a2dcd2e29a52a3f47afadcdb83a5a4446c9a89b4ef96f01568b3b44b729f59438d6ca5abf016c6b41d4a10db82520180341c47e6d914ac67319ec429e13c3e25f7c925335064e88cfd7774fda5de7652968cb75ab763ebb56394892a7aac50b62a493468d05fac2a57728eac597821bd56c53b4425b048f6f69836b66ee802fd7a1dfedbcf6407d6c9d654b7d5afafb32a7481f551bc0ee425888a3c51edffc5ad553be13346a201e906ca9b6289b62a438eabf12342687e625a0e44932865b32a618e7a8773da7df0af1f5b418d17ce531c35ba4579a5a5fc30f2e7365b1a3d9bccf579cccac3832030da9787efa830c967ab3f697ce32a5cc847ed4c89db84dcdd1471d2ea9e90e9e96fd1c946762b73197394eebdebbcf8e7f7afdc04741565df810f4e0affc14f1141d5c5bcc0ef045e789b4313ad57c96618fbc42539ee201ddf94f1928d916b21e699bbd88192d3576996b22892b49c79088a59655b3d786b80d1affaa3bc140d10a61fbcaf225ec6d03949c73d2d26a724af0aee75ad8ecd50d775ed43638da9c52155a11870116aa6406f050d08ff0edc7f612a43c71531003f6549a87ac69888d2d332f4f0a00e4ffd8304992d53e5d4a2de34aa8974143bbb59ebe50b27b69e31635dacb540b66e7ef82a21137fb5bc1e40fbd4f72448f2c140a26641cb336d1f3b9dfe3e4335c7802727bb8b82c0897435282dba8937264eabb99923e6cc6d852fd58f543e3d074b294f93e5a9428e3daa08d67bda3b9dffd300dba200835a42e4eecfe4f105518b579304d2a8c1f8b56079a9ef3e148adff4c8aa668006aa5301f57926e627fca732ce0adc0c419293763836fd359b82410d68b60320d2e7764292c39d56e7563a1b812295671cf8ad2729767bf7d281e282d50c00af0b947a8095cf13960145d46755be091fa2f6cb746b015d3e3e0d4f82cbf40a7b75c3972f81f0a661169a24ec639ab7dcc2ae246b994ed8693bd7d8247b99976064032653b5b92d3ae740e25523b6269d3a800f2251816cd317cea3e1cd6d0576a894f58e1d33841a17301393ecbe721510ca390bf788ac130e967bd1899df9057f70f8784d1e26b2960ff032bf1c07c68545cfcdac4771b0e83a9bb4dd1f111609dbd7f1ab7b28a3237f3860486dfb8ac5f8cba53287e2edeb8b98b15cfc7ccb3a4caa2f4966380788942f3eb11cabe2fa5e52b6647db975d49459beb746988fc0e755dc4f34972487b8890231ada0f5edfa6de942d1a8caead86bf7a970de7fed47c09e26a7543e72f63842a8edd251c9d6519f87b10700c3fb02f6d75c81551a6d82d611ea99678d8c21ed9c18ce3d5a7e4e4092d75db3ad64cf873dc095746255d8622317142ce8da4344b26f59492688c67fd37163b068ce0cc42004b86cba3bc6af8c1268b74dbdeb48e0bf8e12da7915076ff5b565e45c190ba7bdeda81af41ef7711d70bdb5cd93c48460a01a7585731afcd95361f36434f8c77a6e48fd9ab8ae6d391265596d49f0ba788f6bb0c543e9bdd2e75e985a303289721a01c54060313f80b4c1267fe34d8f02a5ef4e77bbe0ed404976eff2dffa31db4f427f0dd7c4d6338e1da20af3478175d1d749ec35c95c660dec5a5a65d0cd52ad990604fe0bfa5ff3d5151513bf9200bfaea1e10cae4bb76d5f0377f0980a70ee34f88221208e7b765a543a1338eabfd83a91bda094f697e3d0bef6fe5a98651c4024c92d2e4f989450b12285614960004b39c957ad24e2727124f358aa2924c3477851a72dc3c0520e73570829c7bf7b8e80ff275b495fb7fce7a319d77959683c77644ef05f8482a8a162045f469fdcbb1e6868e1bfc11877c05e95e4d2dc27fd85c2e235644bc1e030170c03a16282dcd99fc5a0a8dfd4dd20b1f3889ed1f731af2f3123f2761992daf689dc9d0a1676ab3e9f1ddcafe370ee64c24c876fd64a87956f94f36b18a8d8fe98005f86ed07cc5d39ab446d649cb208d35b2b845403b04a3dcac63b05e78ab9fa5778a0b0c3efa7e66a134f075b802e25745e4a16679620fb4b62d380448285efb5967770efaabbad8a8ab437db63e500efd0ec1cdfbeed20afe9c65497d695380eb1c8d99fbc42ad4ce04f7e5d45a10a4f5540c3e9620e6075ac3e62c9dcb489ecbef86a01aacba0b28de4f1d0da61862da3189af9c26b05bc9bb9d0f1c48a08abf194e870cdd19e150bdbc4c5666f591151124f04e35990f98c2e82c3d47f938ba0dd162208b4636046e1d31d8e5a10e51b616d911cc063331a0bb4f5c2e73896daa180a584802eeef4a90547937ddd7ff083081491cfe37b4e6b68069e55d3470a391cfd825763c1870dea80a817a3c3db04e3c2f1aa9e303a71ff935e0e604d5367fc09716118007fdeee8f7d70a9a85407ee5089aa17bad7a715c3a921f010d011d8b77ad8e4ae603bfbeee26f6e6648b6239ef9c3706023ffceb8420bde53b45e4294c8dac85b99f8456e3898dc613ab4601761c62b8bc20c2d6e2cbd6ca6e3b5d38fa250b9c3d141c58f003d370bb15cd514263ecb1c895084b98261641462dc94c984ab6e449436d15376835dc5cdbc5ee0f099b9cce7f94759acb4ea2e2e7bde8c349aebfd7589ce937ee9eceb5af8d8ffcbb9583a1bb7f132c5ece66580fc6d4eabecceb2372fceccb72b0a43af499af88065867aee790082b006b6866a13c986b09df201e24306ffc853fc6409ef089eaf8d6c63dab9ccc6ef7ff04baab6a710959838c32b9dee7c7723ec0db0379ea6a5679173e34d00279cd0caacc3ad4cb719a056bed18a3b44128a6f9224cdb69194a9995cdc4ed2649d3ba937cc1f96ec00490f569cd5d385bd03fab25cd2e0474588f84d7409b5046164a90cd4a9b0f413d4b5a7796ee8cbfdcbc5863542a1602528010a5a6483f7e5cb82d6cbce4a9477f2aa8f0c2b494a447fa28d31a70d3ebde024cc6f7685efa589f8c4962706318070208dab494543ff27c8f5960b3e41e8d04c513823766432aa7a5ea02687eab30d6702f21c612f363ed39ae5bb901b6ed7c66488c7e1a84bcfcb05fb4ac9d1814361e42190d6f60f76e27f70164af9b47baa27a11b4df340ecd80dcc3495064c45e990cea14ea41859d4553d42c44e9ada856900b0b5a412ab183e1edf507e4e1d0846750c50d856f1f3e13a2b22a67fc90eec16078567c7877a07e973b692cd4c6423603d522ee9a9d2d87ed0f94f8dd8341ee6ca64e2287f7cae325e26157e6fdc93dfe2a144407a7f00a705adc6a4fc820929814b631eb883dd73efead4f35783a49766e940fe7fcb122f5eb6845e16103fddfc1202ee187b8be8a31b6cc3e9b43205d6c17bbda41ce7d42d44ad5f1401bda1167e8878e6ff43acf2d186a83591bd7ad7af672700dfdcb7f89844b6011d8f1a6b70b0c4236ed007373edb346821fab55e6f6ae1dfaf59307122b394f6bdf537b30b64576edf9ab36e74a4098d6b68689ca20fedf49f9f567adf76b6881827b9fe4ba1dd3cd345be774ba0a0dc09d3d383e193c65b64d3ea3bfb9dc4069ce57946a7a7007d058c472cf44cc8b4cdbc37ad0a42598dd143cb19ae96c9787b6beef4c0bbc4c4a309943c098e7d466a41dc922ac9f987aafcc7c08afda78541cf05959e32f9a896742c535f1a1730f12745af3558aff75d3f71ba468d462fef244c156194a5275c1e75d36d9d251bafcc48f1248a15c4c686c67b217121756fcdda7b658abe93786fd5a721884f70294308fd3d0baa1cf13d2ab8142d68f962ff09cacf2fbe599acd40e339b7656e5e95648771aa37c5deecf2e0ace7db7d0ae7728717d4f9703a3066249d141b391831cbfdb223276a304d03ca5fe3a4b38f19222907814ce3a1697f9f81fd3840236142e833dc944b4d84583fb1b2835e4c22f3a80997fd93bdff4c9df1f06407820dda2df79dcaddddaae1a0995992b639e748d84b4ef060adb53a71e1392492c7e9f383e91e44eda31efefc87c63347e08045e40cbddef41903cd504fa009e29911dfd12be2b8896edf2f9d9a0702711240e3211bf76a85cf7271e7916e974eefa1c19df3e127e7a03747cf9e48b7eec7daf80aec0dd894e86839caf7a080e896802f9a6ea4d84da6479e9963cce7b9028023a031ce187489a6d630037b773febdee8f7cd1f2f60c9b2a908e989f510cb5eb370245a1d832338914692ed36cea26b76c368875ded464cdd8ae8451fa8ac06532777c7fbe6369856464a6267e7d6bcfa9e24fac849b772bae60111e4bf95a884ec1697ba252dde1b7232f7e59c8b1b412e8d7cd80b182d04382d995c319a45eee8ff487330f450229d4e76114392eb9ada5be8e6d65a1a0d2f3893bf1962dd99cb0ac87a80320f4f0307aee7d8456870b6d196ee59113f485e1b3d62e49af03bc4cbef890dcb8fed8ede67a503e4bcb7cfd858824f79e953fca734aec4da9a9baa32e0e05ae222f58f1164c56b6cd5b9ae0525e1e7bd7f03be64e65239f8fc51151b981803675678fd221e9b0189c117a19933eab74aa71c81fabe3071fc2972795d98349f7fe871a79b413308d13c6ac117c48be7f43a99fa2a016d8bc751a8707be932c4d1ba706803d8c7d60c4cdef8a57cf1c09b165ff625c0cf716f8a5192b63369929e9b9571a842cf4c20c2c9cc718e93ff56e96f378afe7110d220b0721473312ab78d1ed9693f598e28a4c8c8c5299c1c44f47aa48e38c14a0b6e33b2896868367d5b749ff32a9240bc4d0335effffc4a548dfbc5773b75339bee080f9a2dfb7f9ba1e076ad0fbfb2ecbca8c86206ce8bb7bcf54fc8c20cf9f0740241e3fc076a69add1a43a072793987b61657fecbfcf7c37be2f5df4403d424706a3c9327c8f4419a88b78a77d0b414909b2740a326f1eea9526be0add39bd042f1cdb7bca598762747b0b7afad6f29f697fdee1d76ee0125c71d562322541dd7ec951d7157264d337015cf77546599f6f6121724e97dbed7f662f99f54f8f40ac4eb34c8bd64a23eecafb1d75b6e0761f5b426238f5e2169bc10567974697cd5c3e0c14bc6ec2aff3fa92d8d94b6fc085feee6c11443ebf2436772497476c2b2290591ef9fbce7b53b62a4c527612556ce05c24a256ac75b8b1e0678b82befca2f5d18ea123da542866f8b7aeb563a2e03e805388b005eb59b7b2d238c85458db201f9afdb76cdf7e8bf25ac8308b3bf5597cc8bca7357e2f85be3d8fc6cefe2c523310ca31970c0249a398587177e79bddf7f7e0938ec6991c185572797c4d6c4c8668dc3289cec6989107b71396102716f8a51f04b8d92e019ba3f5a273e82ed2fbe0a3cb55231c1a6ea1e9d20762aee3772c09756cb6eeaae2bad4b34a5d70b943cc45b793faf00bc81e207bfd56ace384003f5ff406aa20395b5026ab22984a123dad196bd53e3528a35025939689eb77a5aac18d0b7b9e7c8aca7cd4d25798c8774d2832095986436d97fce5b6ed928331a035eb75af77f83293ba9ddeda74997041ea3f8fccaf3662b2af87a9f376022fc80b235220cc557806e6b4fdb729b5e7e947cca77985819ec1b33ae67a36b2ea5b0dd9daf6818ebc6181760235d175c9c9aa14ac8394eef48afe043617d288523e03506dfcb40011021b330040752faa8b3f92c132800558ab7d7527b081737235e8375dec4ffd02da251a31cb540753ca3f7c1238373c9f425a4bed5dda8471e478b704c672021397668fe5ea5593051eda0c214215368fa52f13230ca484bb495df0ce2cf5e1635b17afb835cc12c29f073b427c3c3ab5bb213c66ba5faf655ab04f5814a218ded9ad27f31a1951e42c236006f35447851b23d5dad31468c6ac759279a38e3d56a72aa87f52a587e722a905902c6423718bdc1aa5850336b16e97eea8737e567640dadabdc1eba1cbe6946ed178738662cb8136323517bb80a7a991d6e4767fbb3dfefc32d8c6eb9f829c357d2e1bcda3f477b7c24fa90e8e04b264eaa22ec8648c4118b4a22716ce5143cf373babaf7516be647bfb1309d6cb23054be34377b7533bcb3f7c492a7344e3d837d2ce8ab5523bab396d3a739fab67f65a2b56a7e8621675aad37218bf2cb22da24ca4be3ae6aae7ab248babfc2e380f0b5e4f19ee0a79ffe257a44b2dd02091d16c5c369623c9eb1771d290003a4374cc9e04bacb188f833dd5de905a0ea1c19453b30a32af6b945546bbaff6ddb540addae0ebb1b8189971e8089cf58c76e7766e53dc2afdd120839dee54379e2023517297497bd81517b16acd479404caa8b8372a6dec67a837ed93ef9f32aa6321f3ce3fe7b4cf71c7543b160f7447bd3478eac13e1421f443c8e49d626672c96e2aad36ad423d44046dfac355715b734b33ac3003f84959272ccc924b0e417627d9725ead43b5a70896804ed8018f8258f7751f90f025d375f1c6dced3a6877ce8f8ec0f334c48b533cb009082cc5944279c9e42974983e1683e4697c6d8fe83badd19fca406cbf244fd937b87e073ca0068b58aacbc423dc265be3c79a51e395b99ba19c08b2ef4b1bc0cc89dbaada784bbbb9608a1e4fdc2d99276c599efac41bdcbae6a66dabb6337f825e786351a03aff36e4b6ce74d2548ab01d3daa2983026b28ab0641b9420ede3b6865004ed389e5ffe8f533afc47f49f978470eb5c2d7fff74bf7dff0da1ccd48b0a88d9219318845cb33e08b339f3fa3d94d61412c2e4e2f97a54f24de77abda8794075c3999cee2676efdf5091d03b824586dae5ccf6e39d65294f7200826d36c8e416255d8313880ca459d7f7c7e5d17dea8a594818a7147a97c68aa2702b035ef0dd66a4a94b41a29241f8354264ec983758e61b2eba60e8d8a0331498850224d06c99cabe3ee3216cbbc4a3e30d1fa3d33d3d6d7f5cb7f8b49606c20405b5775d12568f3b29f48d9f7a87c1e6f256cbc621ba7188c03d6e0f3e4c8541729279b70d250b99ffeae0282e54d688977dc6f7e6141638f4c9d54cb2821e744cf4a9935e595a86193c441add59434849694e3cb870f6b0a9571e838d05313c6a53fada8b7fa326bc297d0746be49c8a0d048ebca2be0f9db2dac110fbe6a3ee02e3f33d04eaa79b1e34a18950705ddb1335b95dc1b510f9b7fa7fba1fd6ad8036bc6cd5c31e875e70350235e33c5e6b396928551d108b481bdfba946061c8f81efdfb3786be8fc5c7f497705b062a5e460635f14622c61f1b5ff473bdc43b56f32984c268ca29707acf0533f0c329bc0f659c07c7a03fec4b2deac9a34fe9cd0e0ebbd4f18f8c706d7303df2adcb9f465da19486deb73dbbac03e402b9f722fb871f9522cda952ad8f947efbe2dcae7d12b23a9290ebd22404b1fc88c5eb8f1605f8913c02b1c2052313cf8cdd7a8232dcf7b45aeea247c6d2e7eef607bb7bd44ed966d73763c8dcfcd0dbedca0986dcf407ffd0c990faf462e5cafad942c95f99582e012d819f7d659431120f5844ae87a3552d3a695a9baf679874868a4bf5af959402cd359d7f12150e0d90678f373bb21683249d45fb49b546e20705a2618d62e9f8f004b8601c1a3d30a209f378b8439fb8918e00dff1866d8da7fa3fb6b21af5266490e0bf208a1d018997ef15de3d27c09ef6a8f492a3fdc88f75ce72464c284ce370827a61cb212c3b2a63e7a639a6996400a502f0a36ddf8d003b2ea481b1d5d5ca5d1c7ee9e0a4c52fda9b8c066491be7254e3f7d49ff63ba822afbffd18f8531750687951a8c264729af9b3e161c83e98492d0c63f116717de5fdc9b25e18798b1224c7522eb8e3cad933c8a9275520d825ea6e519ce6cff62b61974db34856a5f42e60acf9a44a5b98e2e705fdadbe18b99c358029e6cd49798cd8a7af8648241772024696fed4c56f41a2e4d509701e605fb0f095d05ac4e92bba48798d20b2aa889c700e681dd04d26531e984e3ea8ff373c065dac2747e4511b93ec41c8b220c5bd6ea4541db947629a7132b9f8f6c7b43457074cfca9db3abfb3b22ac88ebb2f33cd78f0ef5fcc0630fce498dca4efa4b271880bdc5963cf18b11d4395ba1ac540f422f3e3817ea12fdc6f0fad914dbf6ca8f369e9433806d1202c287ac14b10f8b5a0752456082f8d5f07140c9cbd9a1c1744ada7064b295e3d7c16854c2b1baf3169fa2eb627753377762edf13289f451b703abada8c72fe6f17b8156366fd00f70ffc63cc29dd5198aa80a7a39adff538de4c9837ef32a666e2686b9d35ccb7c5f15a4f4d1d330aae3dcd7a0ade09725bd40730d84ed6b2f10ca6b3c68196a7119af2c6432f940252fa9182027c83828210ee92218bdb69c08cc9dd22a21838bb3e0022959ab298c24cb487f9d72e32aadfa43240c1708b58f2492e1520e8aa9590fbf764b7f6d9ebf7166dcfde09f336aac404df3c66462b20fa619bf44d136b4fdc5e3a5f92275259a4a9d64bb13f4521dbc84f116d929db0ba2e3b7819f6ea40d319c185d8967fa792d76a54fe27d80586d02b6211fa960a99e02f02d67dbfcb69773777b654e7f06c8b9f04c5952d6fdd7f14741bc9fc7dfa4b28f5a7062d8fe49d7d324bcd03d4cb1981e5fb14b92678bb9f7e34bca44da5c28445412582e2656266be7f7a208570dd9f5ac87d0a431a3f6fa54a92aee733c5b72c7af4b02642522889960fb54cd39c9a91da868a062afac62c2009169387d691b46e2812d215eb1a78687064864106704ad8374e228e1676b8385b2bbc301e7f3d86fc607e9cb38e355bb3feaa95da3dcbe55ca2d690738637693d9e0af52d23f72f4d6b3bcbbc55ee92ea2842ec82b385eac4617478d43596e732f1da88f6a8d089f68f83538e56f53b593c441323ba8c86a52aa34583f9a68d42dda30e241035b637ec4fb9008663819a6f735bd0bf30d26ef8da17367a5d328b05f7be46702e38623004717c94d5956865f6262105801cc5f13ebe061394755f5944f5cec13aa79322c68d3eda6ecbc7c047e44ab77cdd3f8485bb41b3ddaed3933f9901f1ec50154ee87725d4bff258726aa14de3a40fe4f5be3a04180d0febedef19d458de11cfd98c2e12a75a658583ff09047faedebdea6d720487867f2b5207f8893ccd9a693f5dec1bf8f991200fb42d075a89050ec383e58196a7cc8e34646207c2418da448226066f0d34d7b02f95f7585e5cee33ab11250024dc1174ac590680ab3718636fe9f64f05d4dc250adc261901fac6f23b02340953b85c078043857601d8521489dc274fb43fb287fe9b43cd8b3eb85fa0dfa1184bba94d4de2ea28ff7781c1fbd58f6fc55938b4b93eb2be268be2f096a13a6eafcea3af27f429f7a0424a8d917ea50219be1d64d4151c397736af07ca0cd79ddc6ed22e9cd5066b5af3cdaf57fb30068ec8b21c4d1b4f9dec90888e42cae78982af6e532aae686b97e86fe7118add37a601ca5404222b1f956281167065857c7e528f1346eb19b3424af5b536bd11c1db1f843c4c30e0c3f5b87b867044ae95b5ddc0f4049aa10a804eb322d66ed89be63b383f4eb6bab1258bc6c66509f7eb14f20761d625d4af5bfd7b43eebfcf3242e7b9e09955ac372f12cc844188a5327f0baf0ee81119aa2587876ba38779fcca06e3044f2bd7a1573ed70b31a99225f023a3339ecb5530d6ab2f55304fd05ae26e4fe4d91b587809fb7152a1055e9a01f5a1a912335fd630d1251e1ba1ecc41e04f2d58e48fcf1d61ec39846856d8bb824e583ccb061d967b8e3a062a60f73373f264bbd75e415b447f30de0962408a8e0cbae936c482f5109a19a8cdbd33947a06fd4c60f600b8a9753ee0bcc48a1016e110c31a02382a9e155d716e028a07c3358fe11d4bda7ebbab4dd8885d2a61f0e8c31dd5d33d6d73b589442e3ceccf4198e5bc182f369b34df8cdafe1034d87a2c7a5cb2b2abe31f9b3b8907e73a020332fcc9dcee6f0de92f18ce130cdea1a766c666cc1ae310e553728257933a64c5e0c0561dd30d67b9abdb2b442b12f5f61e94165a94256cd60398e305286b01e8e0bd8db9e204a025c1a720a946c205214f4bc26f08aaca07c69b9dbc974710439365c316cae90b1938775027fc39917d7074e5a72fc57b8ca0a68fe11dbd135510bb167f019c551b60b5f3e8522b78b553b04c01c7ad64c2b550a6b0187576c9fd83d7d77397f8a432ad569646b8f4385f3115564368eafd84424858648d76e3ba0d2c7b77a1bf66c9ad1ef3f0ee70bc14812ca243e28eb5eddd924d4f8d02dc00d84fa248417c62b02a36de432bcb1db4e976d6d8e42f5a5d4ccf3aba25000f234e5520cc6e4f40d9f21d368712d1f17e8f3f7668fb3d7397898b69041ed1cddbe7817b86f2ed8a0eb747b5de03501eb46cd448868e131c12525200af1ea42bde6c7182a697fe5f592bd25195f37a7f38ee67f7267ec232469d33869565d75f85604858105932c3f32d7561c0c74e8638516622aaa47b606607668a21850ea68c8ca1bff95a59f4bb8e766147494d1e5f5a903318621422b6aa0148085ed87a43f998c7f9825c56940b55980c87b11c68c345c4dc9468084e1c1544cc1c8becd68c1813c8a563ce30927a7efc0c925dc530cf656a47b455b2ed72388334fca7ac4cb5bc5d652249e226c7dbeeb972ee5ab1c674fdb5ecde1fa44992a2f43f5abaf084002a9b1beeedcd9d7e53651dd6de41a90049df27b9c04ad2412a309f7b039a6211e21f438e427da0ba6eabad765664d1c2933de65daf49bf533c7ef6a1ae9e0c9deb6018308a4ec0a7202b35ea9b36ba21d5ddedeb45f1184252de4429c3477c8e0422a2d160d8b6fdb0e55039d5198836346167024312eaaa9989f47d45958b33ba34a3c8c3b5a80385e96115cfe413169884512e68daf3676fd76f0dd9ddc2620763c78f26c9b10e009cbbdf8a2a885076c7d6099bcdd579cedc6f0ec54d40bb5a4ec15e19debfa779f4184b0143ed4aacc88aa6224a90d90ca9ca30d94df58767e91618eec92aa3c391e678ce86caa15df54fbc5154bfd833524a1d1b4e0677e758f97db5c9d34d0cb4cde761f9088f1f7d9e507bf5ddc64444c8634fdca9c80b3dcf3e26f2af1a500d9d190f1ba9b916758e6de22d0e4838771dc0613f2b32060c4757ed363717592289d9a358d0d91c775dc5db42b5dfc84ee8ed49856474a422c976c0dc1f81ff127a6be585322e6a23d0eebe883e070e1798f139811570e55d3d38eb7ffad10ebb2abc1d74581ea9dd84096ba0bdc8c23174ac6e83e6a8689b603c946e05555a6a98ebbb504686488621183f7e1d8e5370334edd2f8c9a27b57dbd4044cbf551b016976bf4cd4f810cac9cc9e0a15829ed69b4884e24bb5c0ff21f8b6da93c5fa9785736cc5a649b80a32315c62af2f6680906f822a903e78954417b3b82ff6cf57a786f73d0ca2e2732d45741e12921c6da2acf84715292f453d787ff3b931635ea1f048d3c55c2df24c6786b8b9a5c9eea9919b2bf48ebf28c31aa84d9bfafa33ffa5f2959eb32b5952725b6001c9f9ecf02546f38eec548fdd2081b38117c8e257924385f6156f83d11ba142b332e1c7e7cbecf992813d11643c46f1bb1d9b30a969398f60a034e6f0ce3f2081cf57551c2ba722092843c3b4bf27c23af0e9cc0e3c56115f153fa594073021cee09791dcb7a05963a1f23cf22d5c455b866b994189d80b4e0b540698bd2eccecbc3c89b1dec74bd629109a41846ead4c4a44241c864b43f35bc406e705c3597375c20e50f4d2e0c70b4d8e68952b6a8e5e6414961d008eb5d84512b477b570aa0ae8331ae7a3e1488179c36104870bddeb28e60b7cfe38795674b7e1c0c0d6163cf98f0b6187e8ed316e75be12b58bd202b67fef6da9222ee94cc26c7c38829767b3ab79b8955417f6e9f7d94f5b6f7381a5b5b5adea8d16fbd930cab69a082bbf9c13a0bdf1839c09c33f02237704384afe19d66d9d850f9450700c6eb0f3c024bef17ec2c27f4517bb2c0725c2de554f1c99c90d2ce81cc36e92e3fc30a9b22f3dba4346241bbe85e3d57162c6568f389460eae4ffc602138ee179eca251800fb629851cfd6131924dee15f2ef08c6db7ec36f1614b32820e36761c74798f38668c05280ff256fca98ac9d7f3852261e34743c1c99cc16177bc45ea9ddd10cacaef399d03c7a092ce4291635a6b8e35bfab2c73e45e321ff3f0160e48d7cd7e1522a98f96eaec6cb153c13452867fa0daee85ea10cb0572d6ec246dd074e84ee2f88e6043f90362827ae5b626b5152eff3ce4c7e2a224c1e8fab58cb791d3e1ad545ae2f426b34a3d3f7343e71f7288519d728ec4b634bb7e6d3163b574d3ecf65fb018500708d53c9211835f088701dce1d81aaa68e247f14c6aaed3aceffc8130efaca836b81d07bdfc538be366046cb7edb983b2c1c7023fd8d2130c7a0b92ff41a771591c87f75a2ba8d7dcd88bf906cad833cb8d621f185914ae79c58b0b8479d2e80f246651d39b6e0a455b11bc39306a292f8617bb22f2a9e23a2796ef406a2bbef111f649b5a639479d39aa5fbbb4163526e08803b20a93042b16c0e62902942f580c9429f0cc400fff9ffdfed25f3ffe2af686550e96b0d791e33e4599d26c099e1142724dadb39bf7acbb156dfee4d881f95ace5061e2fb05d2d0783fed8d9ffda0e2d2a456315321b72672adac124514b7aa259c236c28df18c054688d1a8e5a0542b35b3ca586aa82a90e0d3473f1efff788d10541f520e52cf3b2ba2f547d3becd474afc0b5d07c455e5b9adbfc25ac66e3e668093c3a267cf4640005423eb8fa27460ec2ff0aa092cb87b6a0f7c30cb4a952454372902df3e69546125062df683294bcaf4afa1d5a483619d2ed86518881a3bc117edb3585a368c18a3cf57cb900c0df67d740c65f8222b0b646a2ec4766aff965761e7f4b3e592b65389ac6dd41e728f633331792d05eb5cea298bed6eb7600227c39459e6ae59359c32e3c8978da605ab17895103a00997d7486248e3a1cc82df8dd42ea17e3bf49b9dc44528f7d1262d337e08585737314fd4d23359cb100660385613283a416f8daaa2be3c8d14e55e1abf961dad19102b6b1814da62aaaaffbbbe8d3bdacad2449a120e3187d20bb7c9d5330455c2513347aacab4ebfce8fc40f0e2a5885825260a1fd9f5afa6a2781aa98d4f1b7251a6443341128878d160cb931bdc8a01973cc08081da6fb2b42e09c1fff7dcaf1ccf25c7b754ed4d38a26109079e153bd2e633ccb680cc30b9b61138f459082376c2e6f89afd7cc5e013674dfa956b011d11e77dac1d2f6322269a4e34353fdbb36b98825268a6fd9982981caf9c181302fce2a30af3965746616b12cc794a1f073b7f37088592bfc9fac6b0bc96fad3d2f5f8b4ab825edf56864fb86f6fa447f8302c7c27d25027bec6796bf8a6c78902b8deb386a7819eef815de3ffeffc87f7dd1b3a4800b44b80ae5d29dae0ef2dba77c40e9b7dc2aa5d1a1f346f2ab9f23c457b4178384ebc2a2dd8ea680e47cdc1d52f9f249ff18f2ead7b1ca49662e1ef88cfbcab842620316d0f55ee4ad6abf599917dbc6ab47bf2c65149584bfa45aa0344276b271eb954976a7127aa17ece8c155d0b1ff355fd3189ed3671394f752e1ae34a77511cb386bcad6579cdcf27d08d00c9ac6abdea148b97438b7a3d1f155ddfd0af5823240d80151fc098118119a8b788848fb83657ef811b10702787543429de57d08e1ea640156e5af00f451d06ab07f4e2d0f4a0ad9822afa5b7065810ea95957bc36c8cd14581c22a736285b0d8f27263215a8106626e488f52ebfa7ee1a40166dd62808e4e124255af87d12077b02353b676f187ba7b7b021f0b0c2aa2988f6f5298f5535775e0748522bd3052a8e0016e5187631377434b1bf7465b4a62a1d63edaa9a3aa9d423908a2505798bd93e3727dc2ef329accdb822292aa19fbe212440eb320323886a96c4a3c9448b32eadb6f58e0f86d4defcf92879c67081e9e8b0874d32be2f2587d6a478b0f60f39cd26a96fd840f70cdaa35daa1f2c87fd0ebf2cb3904dbb06e1f52bd0347be86ec927d38f7504b56169028545b41ef331cba76afa208a90803d21b3e3ded53cd822604953358a4c6db2edb03e84d9520593e37acaa55d3889f4fa2e6798391ad8dc7f7db41fa29ed3360d18b5cfcc6bbea8bf654b22773dc4a8730b1fe18022296330e40bc07be06dccc7866a239bce61f4fa546ecc618888d1859c41f16a60476a414205502ceadd8b269930ed8f942d97680dd8fbad32e985a66d6a47aec22b7f9b8d273390a721d0dcf463a4a92b4614f342374fccd71617ac58897c2424e0cb028cdaa244dcadb3f8074c048e57ef9a90ad90948616943a2deb315fcc8b98d33c999648c658ac371258707902ecdf56e6491decf34fd2bb4fa4ef18831c3f64d117d2ffb55c5b287c7371453a7bea3461ea8b4e0724c9da7a1316b456dd6c1d081a575c1360d98f8902072230f0c86556b8a1805778831c7551bb44624621aafc2d28d7cd72ec37c9f7be5dffe006b8635181da1fbaa94833e4e690d9e04b7f4e292ba768a68accf92997f99bfe79f189d1f7e58ef12f5360ef02554715f9134c153b255b5585019b3dca385a3acef072a70fef22a09f914d57b9e06025ca2b14fea7b584b43b3f1107be40a3d94f38b2b31d7b8404364d7ee441b7e13182a395f1682c00e2b8856e7712ebe8b677a850c83ea9f3f6fee6f129f12e5f6dc8cfce4049245b2cedc3a400038dc99859021fdd85abaff2bde766ff902274d1398b953c2e24fa1b5b5470778db9c7581c5daa35add2bf94b6a62023cad60baef3dd556aad2c9e4b6ffd45d9482ee63ebcf331474eb5e62bf1c6141d14ce809b2cfb07831a47a49fb6eaad2975992b850f7d474fe844b9e3cb1d65b9940cae34e4f7cef99523a71c6f9a55a28a5cbe7aacd7524b71a4fe2850dc375095d7a0388581822183e07e39cff8a305ddc0b9ed7cd3926b4d87c4f761d0c0caa7661dbc3294d14fd8721c90720d75ed79771020ea7eefd001231463c317523957a644a692abdb3e689eeaeaed4f4500ac549be78756ec322d9757dcea8a655ed064bd4b8001fd2eeef3956b0f956e65c28182ca9d149d2eb492f9203849c16c6f18ff7c68748cced4b9bdc455255f18d44994ee2337d1adc777469f58a5b3ed553b4e652cf26743b08b19c64a8df7578164bcf5c0aa88967332453d351bac73b334d597f1e95a29fa53c63a6293accc8362826eff10f986590b972c4ce2f9a3b11f9172debe5a65eebc0fae8ed6fd47f516c7f29f542ff3c2e853070d4b663a337bd169947e723d8c982a3a35b220cc3ebef8c1ecb5dc5c337074ac1bc3f8bb9c0af29c7dbb1f71da453968b8aca1a79f8085fd842493b23f8046896a9a93298d1b06613188beb3456b70fb9f13a7024cc5c34f3161fd73fe84fed75a4c65ac79df7b9829eab356d8bd6205834fdc6eb0da8c8f02ab0580338771d66a4afddf3ee7848de8a97dcc460c3e14539d0bacfd48a6a4456335bb880dac6528b15ab7dfb5e2680d0c91457408e5a1fabba251606331131f33b8eb6ac493b9b7149bbe6f0512a339a6d6d24c3e3facaa209fd4b1db4fa090ff5d6cdfcecc6a2b00e187fe334c4967e1cba29aea27733366259df31b240faad00c10f62064fbd1b7d5f598c105e7e56ad5ba9c70e4ad7b705cdfdb9481a0e6ec58ddf8b732d16e5f88ee77ed754a6b7d5bbf131fcd9410052523f459dd5932323dac0f6743448fbe23602c3502d5b3ac512e74834fcbc87985a2f2b64a1b4505ff430847048c33f017a24683e427cf9a47fbebf8955394f3afd0385ff1c64c723bd76406d50148e75ebb2769092c34d0ef38bdb048f3527f4ec899d4bcda1408a7655ef1e014bdd7b93e6b4982b526aead10bc1d8b47ee62e070d026f2f5371e5b2340feff15b9d6c5e1a28996e6fc383bb3412b9bd3d6ffc73d4315068539bf73ea6063469d89bb68e74e6a501ae8f444379ead0fb7cbff799d0cc738f551eb9f5cbb3ff08eb8fc23fc7b4bf0f2687ee54510566db2799793a02c791717d8617857a32735970dabf301f1af9d6b5c8e548062e4ce7489d7cd69034d231c8c8bd1714043b9568239f4cfe2b27ebb18dc1a88e617b8ac8c07f8fcb45ff98b6718da92bb9bf2939f2e102866b76225c25c9f7f61bf8efa5d30d6f2d01db01240dccb2bf59f304d4e42bf6b6aee6f83321a99ab74f1957b26d3e5dc911d0c38124fb811cddb1bd86bb1ca958632d3c1cde8f901ce1477c70cc6e4017b1f774057184f7bad3c52817bc3974d612b978e1e5bfa5fb503031f6ed76bbd2aede89a97185289a75781c2cc2ee339a382b6d38125acc6bba76cff686fc10cf1c5309d5ae086faef2d48178720c57dae60125ea19c8006f3fa4e310659b5896585d81e7cd90ecdc2f8252b7145bfd872b0e92e2e5bc17593629cc39187ac729cf30d91b973a7f881f052e2256829fa56d8f231516f8114932075065b5e5daadc5a6dcb830ca8c9864836cd5fad0fe284a1d1c7dcedc3f24883b3dc8eb8431db20d52f4d151cdfad79bd1254a6c7641064c23a88f88f9676b87467895892fbc1c19c9eb081300236c3d1a6084ebe51172dbfd988a3906ade31d8fb57c5ec380b7c279d687f645a2f0351ee5f70cd1e86da0ad614939176a03bf783fb02475dac37dd9244d29dce0461d40dcb137e23e16898c6d08fc4c1b7bf79dd16c019f245d303d060d51e835f832a2596c427bb61c6d6b70bb58ef309770d832970a9dcbd17f2a2fb5c0facfaf8ac091b965b46e157a22806c1cf9ed7b9f112924f13ac0121e9140c36757fcdfb6eea28f2e5e38c1bfc4044e682aeae9a89a600dc15dc845487fe683d691b6809db813c56f90d29f876101403c7a9a8bf2bc25fa4bb1b83091533474a10f34e9b37d3af9f3fab6e880c68f9e6369e5266620c0624fd2f84eec087ecbae4ecccf20f6533a8a449f07ce6df31f5fc37f91a71e89b78168fc24a27442e209ddc1899768b57479114cb137e6b687924954fc31276dc2f9a43f7772b188a2baa5260d6e9a7e741b63677dc5deeddc89a8c3b34f2bbaf7e0f4e56e0dd52097d3ffee406e079feca7282bd832b53a568ead1aa8e752d2286812f8f5c7066f3fc9a62f23d13eb3d5dcdc355adcbb18ffb652b4e0e0d62b1fb1992b6fe60986277ff087473839ccbf85f17deb049f9c3cd3057a4438662aa3045dd43ef482caae6e2210acb9da92da10268604283ac4ebb8c5585b797dd74cca11d8faa231f7b3c13b5300079dd7623d0fa29b6127738aa5f418bb4d7106a51bab1a499524aeb31ecc62d48f714d18ec9e21d0be69d7274f0a21521d8ca4877cd2fd1f723278359a2d944996871ae7232308e7c2f3f7f00647c626fc55a23011b859570a282a2a52fc108e62ec3c29448090e2913da8098314bd89139490ba5cf5e8933d3a9cb8876fa90a3a8b06eaad0e0c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
