<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc69f0cf43298ca9b06c5b77d896e4fc6cdbacdd06994fffe55da5ddf835fe4ce71a8275f20ee257698df77631dfad047965b23d9a3fb7bc3178382e2ab4c7d82f2130fb6bba4a8aa5201383540e7da38680d4d1814c70231895c58a34a0320f7ec3b3e25f0b4e097209fa2ab6269bcb7a5270ab9009b0622f3aa6453c1860651ced0fe74609be988eaa14c81f48afd0f6cc38a6cad09d26afe2b86bfe9b51275566fc724e512751839d69935cfd96ffd2584d0c17c8de4a578c1d55d93063fb4bba8f71e49fd3f3e152de4a9c4c46fc8ca855020260f2005be0ef16243dde4ac0d2ff13e815fa94ac02e2b034df27abd2f8e76d6e97a5786a161ebf5131fb5aa6e9423ab5e209cdeae4122b2738123e3de09ae64c225285a08968f7a7d90d170e969045ae8e9ca2c031f881efe911f9a943698f0e4851db92c135a3cad76ef3a03b945ac4179215e216043accca4283258776736352275c1a04a07d88552088a1d997dc95da19763d44aa900821c7a9f895262a75668921f76309d4eaef34f9bff6b366ac4157f489f89ef8d75853f001b73d485339ebb09c315063136abf58485e205759c89058fadeb742a112a4d82edc94bedd90112db685d794530fa0fb91418e55d5e38f5800d5e270e30208f0d917a1d0d67b6505f9cd7fc3bcc4482a7e6c8401b63371c41551648387dd41368e11d3861dba9b6a8385cf763068bf8a5e71fcd545348c7363bc1fb5e08daed187ac5484f5e9bf5ba856182e0ad406cd62f8386ff1a5aaad67746560f47340aac1ac1d059e0442c081cf7d5dac67fd540e907ead674e84dc5d44676976e71fc9f262ae9f0c58996825c28c1baabbcf9c6aa859380a8587f32efd34498cffae04038a5fc17c0d788f64c2c715b763beca623fba603c4aeaf28c6479661fd1280d50f8caa6dac922afb1e362a6bb182503e23e857a244aefc0c8b76f960b057d221b1d6d142e2c1d24a50c6b9fb0794aba6036646cf0785d971a59536d3d1ecdac80646c5f0d4e0fb142b5cc10e143fe7279e10f29fb7ff659982fb5cfe46aad2261156ae59aec3cbfd781aca455bcd046e3a8718d59cbffeecd75d7045adaae7b002a40ec816ff0baec70251cdf9149023562ae656a3192f094d8e6c59038eb2cf6fcd4d9800357ee909cfcad0fb84fe64ed97024a2ba914856b76172bb52a3435d2f0884518d05c74f4a43b5d2badee8f449a15aa525e596d12d22875c15da36358843395b8206b3ebc2e1e4cf5b4d37726897eca045a60a4fe6d98d8e5a744ea80cd578861bf07b500868372b2727580d866125f3c70b107aec7e7dd9833b651893454b6565835be9f93c0e5cb5e92a6f8dbd9f937b0beb768b6ed1004463d8040d68bf008c2553e8401013f2a5584f6926b82c1dfc5c2147ba0283304c15aed42171d7c65ef28d797551e3c0155cab538e27914a87bbc01234c293dd336b49c5ce7e271c0c2d450981865d455e9584abfa76b7976aa7109e04bb5a284121a7fa50e983290f15e441db288d69b41f3bb042b6d34c29116377712c5edb8b976df98199495773e3cdb3ed95255d8da2534186f031ff94ea0c5894539126e05473df4a2732d441eff2670a7e196287c0b2721814e010da7c632b6fc931c4fdc4f362b30bb4636e9f92844f1c1f34d99eb00486c60b61beeb78e2904edf5e9a58d1822c3d6bda5fdb730efdd07aac2b3962b0768a755af56f9d10438620ebd78a8d717c48e82f15e2b7baa405d53a1d56590551fb9fe6edaee504aff70ef4ccc78bd9b1fc73e42600b7fc3b85e286a87866c11d36af6f9f4227a15f4fc45612df748278ea9e60f6a26146e94c2337b99e1b6b8ea512f3d1e8e8bd91140dfc50512793a883806da78c2e9c92e28c741e75c37a7b9f3367ce6a4405a2dfc37e84ca86e06a58e894514cd93686d52651c708aaadaf922b77aeea972654ed6e740202ca4abab71e296c7b9da2b77782d1b8ce226388283d4e0223ed8da1a35f40bc1f8173862eaf6d45ab498e714dea16d040777cecad41510eb0786f6f721f5d329c3b42267aa018ce85730f116af1dbc1ece78148c0d99d1d4857c3c431fe443d50c9b59637e49e759f66e8188dc812cbf0186b852b2ca7ea9f8459225440766eac1e29e464ce7126ddadeb830eee0cf3f2f508a2ab2b0e651653969aa674f76af37664e652dbf6b68befebc85988a3f08759b0678ffeac79b27b6f912f177c606bd1d20d5cf6cc7d720497d3d848a96f68c6e1c5fb4737bba9ce61e1d902f8231563c5b0045a19f098ab92550de50eb8243d9f817e5c9849b91257ef5b87e187e8590ff3e35471b6173828544539bb69f41797ee803fda21c0d21ab01da3cba26f620f0f0962b6928ce75defd067549948e38230d77ed44b847bf5bdb3096306e8ad97ba8d1fd148e04505104128f3895418c587afe02ffc3ed164206493f6ed0a0f6e8fcaae501f712f7e00676e771b97d2918f1d5a76a546f8bfa484a41b3089e5a105e9a3f63a5ea54ad97b24c928cb3739892799622e12f2b6967752d59f7c03a081b2f609fa4976b754ac09670fa3b6f97f9e932854d177d839b5e1ea100690fa8482d08c273f46f50d18ef2f8f346844c8da21f891b09e27cb7544b69f1470300c3a96c9fd87787bb5e5f3fa5a8b35e5dda161253b46cc5815f08aabc01e71486324e1551567cd17ed59fe2b99ad3b94e684c807a8c4e1330b685b311b69078ca2db47a54acffaac5f06900b6576c2b5a7a0e631f32cd26cd3eb173cc79fe0ac714135c943eb1c50ee02fb63e1aa5332324617f6024f96f8e1fc1a935cf85e24131c0c4907b31f59671022ff9cf4640d31132c682efd6e5c2bc6c67f7ee9ca9bdab77cdba57092b62011e413a6af5896766dec9fb17b0564c8b4525cd248232bce92fa01ba9b26eb51c91616b0c08d74aaed1b7e23a8235fd542970c4becb93341226dfb6cf56338c1553e73e5e41211294f21850f48926f2abfae7ce7899c8517ded18a10f5d633ad17b115714fa6e97735a58b5c3e2d075b86df507c6f45a5107c1be76e4dd474474ccfbaf507c7b8c756bddc2d0909460e48db800742861e8cb550dea615273f8595e6f676159c25cbc13618e0e71738663896e568f0dcda9ed6c8027bbd1298ef03d03423e32393497085d2a1b8516aca3511dad159ce7fafc26982e726d0a2297323a220405364386e5dfb4acd7a3b794e19b19be2a8666c077f8e28a072d64f125e0d0cbccc041618d5d29441584784c295541046df7c6b1c8091024bf4eaef2bff3c5958d60516980d12590fdb87361e141e0cc0f68d5118da16acab0d5d548ec39f856b4b62bc2d3ce414df369cdb94addc06ca522b8828a80984876c9aa28b5751d121e187b8f217f4780a4fe41cfa6929e59d93f70f27596f0cd04399bbd7b99bd1f9e27e1af055491c91b04a5db6fa76e7bc514bd555f70ef7f93fa8d3e5864ab4c78ac2b0592c5559efaa547bf927fa2c88e003b59287e66e6c5f9a0b53058652479cbc29a85bb017a375de72c0df3d362fb5640328d5b8f861ec8d3ee37f20e0d678ec9b87f07f1ec53272458e0de8a5e3c038db807940bffd4f13bbbcd5b77dad1d617513c9d7b411f0db6b01f12fc80334a4e6419de02217712a42554c635cb690343d1d59a4bc5dac5988e06aa989658d49b5c03dc0249ea4db482c6f15304177c95c2262a735e6887f74adefcd36b77e4e153948c9a54c7610db77fbcca19dbafc2ecf641b050849a06e3a2ec748f1aa60ccc70e69726026645e4ba6d5cb67ccf2c8311a56fc5aac3809244cabd5ae7a066f42152f13d3d6b12fcc6138d69824c1a6d141a9d28aff6f3e1894e0feda5b7f87e8624128707928a25aa378142d4afa3deb4a38aafb09c2e3432b1f25cfe19f6094073937dd77f80280cbb64b6942a3b619cd6ad2bb134155efe5d925c4853b80f41d1e65c44269f32f34ba806914797d7a7dc6e882da5245050641cfcae60273ea98d7a0f3d03368a98ef398489d1c41a53c402f856ba0fc89c8073f78a72d477a28d065119da7d941e996beccee2db35f2ace7d35ea5d1d83d605e096b51e7fea4165b076df52d3a7972eebb03514b3f63ea211378a57912017575fb426a07612e9f390eb6176438007acec4d796a01daacc6fffeee8ef253e5e96b20be0c9104ee31db1d8d82a2ae8ca82e13e88dab75a9ad0e259e59fe61ea2682df0564476605274c69eeb0d4389d44ac101cde297e20c4c95cc5e9d5c09f084cdbddff071b13be8077b36b7cc0837831a664fd774c90359275454e9d2629ae1087e9ffc8f6c21a846c84b026eac37c3640e6815a70ac18bc7259cf18f8aed15854d609872d907ea4e430e66c642fb63191139870c3985d84382a1af413b351ee8e26e7875a6014733027c342a4be1c3d3e8734c3d8d04573efaeb709d124ecfa2621f041d9fcb0e0b7f174e0ecc1649c0f74198a8d2ddee7040d3405b69d69a716f73d8f69840eed6ca82ba34a3b0f3d30bc1c759588681eae06c28d46b8f986a2566bf9bd9c434eace5b0210e220bac37397a77074f49940f2c66300042f4988873e86a8917e6c54eb2e75c8e1197b399b25d0cd5b6a1f057aecc6cb165eea037cd0ebfc3273456466e40d721234cfb0b60e8cf863a838c1a2903dda43b5fe8192f0deb47ca324e776c2c4360216e3cc41de040af24aab5f98e9e23f7696c01bc4f72be9eeb14c2274b688822112c80820af770e8b2c1294c47bb9fc8b6ddbdb8eae3f0b111e8f194e65cd439081e4279e81e55dd06b064a46cb39676e5d2dc9cc0e58c28cf91b5f9085178db8e4adac7e87b7f2a32b7bb2862310f64125d70d95a1e1006d493f435e576e5fd8156ed3ade29b015f8a7a8cc19691e8751d7d069a33c93986bc3bdce7266daa246d3c514ad55f6fd4c3854383756a90e72db0e63f981cdea268a511ed418176987caf90b07aacb7ef5563268b1e43e8297242c51e06a8be619feaf36b36a07092b1df4415f4c458c57f20338c3ffc528c90597255dd01b3d22a2dd15236014669784f582989ac92ffad4452c37e242ba1b5b480c29bb9b6bd5959e47a036c3c2c181e3c1deb6880d636c138bfc14e4d5037100e029daa5b32b4cdaa9fcf2a4188c75fc7213736aae34819f1df89ceb7b4d9c8f01ceeaa297aa59182d1aab7ea5dcf875904956e22c33931af826695c1f9d89374e31531d56059237ba170a000dba00ea07b71b7c9e14d3b95793c87cc3acf77c1d28ba71fc50c71e872d83bcb9095938acf59957c87af90043648a1ee4c0db58a511808dc1044ee657de45b28e5c8e7f99b993c08fa7ab1f1b2f9ccc46b1f3754830c8a0a0a106f91b7c34f7dbdeef936e36f7555b8ac33d82f1822f4d2f17d34aa0a74021168f32b8f5b22d59ace9d70ea9f80cfea460a09fec2cd4e688472bb1cad1cc86e481b782b4fc0e639606970559d3c16607e2c8e63b8d16b871f2043185a586bc0b46e04c8a63c8d90f583d5ecb7e7c2d24bfc28db6498cdb921377faf6b5c60117d0757ad3e476d5d4af9c4b759fa111be8dad6bd5f36d78212be27e75b122df62bc93bdacadabe47774004ad00716abb2d24faa2da13811e246309e61fb554a4d0979587b1f58b47b38d8c33a9c2e0e22372ce58bb62b7d64ea7e5c89d3f29a0173d232b142369bef8d38de69e1bf2a08699a159bdb65c430b897297a6bfbf18c36abfc75736de649067662c849e3ad4458b6a74fceb6417d0e957abf11254f48b878fe839bc78968b8e4e4fe8863e88cf134a7d7d0c9eabdd3e230a80445143f27876f628b390e7434e301cc913175883cccc50c782a0e00417f8e8d8ac64cbfbf8d621f7eec5c2b607629295d58cf5fc039a3890323866efe21539dbd1e3e1b5c5b0e7701ca6bca2aa2bb1e029a73e1c22e5ae6bf17b091cbe3203ae217ac58e9e6da48b46fa306113922e48ff75311312f6402762aa2dcad4173e8f4b9aa2e430c36297bfa0a7f4b530271cc6fe5715a197e29f88e40a9eadb11a21f8cb1b52f67d7c75e46f63f4755e07c62ee8fe1826e808cdfbe60fc5fbb5655f191a9d19583eb0c8c6f2d1161c58c04bb241ff154456680d6c364d419555d478e62e8a24397ee090f552d004cf232c7642a3cbd7eba4539c3cb5cfba547a5abfd2aa241cd3b06264710c2d86f9ea5d8bea2af830af78beb02f06055f71670eff76d6c8a31cdd0b803cafe14d7543b9cafe774ce35a1cd59d3d102fcc70b405960d431e8e0ab3e70da67f585202013241ff7c84a38e340c7ebf755a29b70bf9313f62cae694783abd11da0dd032c1b629a9194768f054f644b01e38929c19739613ecd2d87ec66011f46461c9af151e2c48197c1f6f8354379bfc2a7b642225290cdd6ae5a98371115a8949fe15a0f268180da595fb8df8232845812f725da43bf350c6a5f9b42280ade0e126a11ec2d1d80b6a1847372862285198b4f3ffb73d286a5b4d438a48bb8694531f535e7262e6bfc3491530aee29be56af943c50019a75436e4b01229b4322edcad5d5c93c2910d5ce7739f238e698d5f63dc112c0faa5105e434dbdddb3ced25a02cfca0b9723f394a133656c8176149285970ca20aeaa63d4f9bb66ed3d84434864ca3f1d0f65dd9ffae4b1af7fb4a3d165b398eb180147ca5740643737ccc9f81572ca5228fbde32025947fb7feca3fc238642b026af45194a1b7c501fccdc9b0ac8e1b09b8ace01394b2eba228a2d11d094d572de291a0bb0cc48c640dbe5a92523623650d6ab05bd28293f788a050914ac709c7c489a7e2117a105f9c076ff48748d00f89628e3498d2cadcfa0663e612a4325d13cfe675339e95d8e4bddc68f963d8df72d39afe0d89fd46873f34295e148ff4d2f38523c9dea2566fdcea9eea928f680124128fe80be1b1fa23f9321758c6484198924a90a7666f9f085b0fdb6a91896ce4643ab0650e1238fbad1f651190caf8ca5950ef0a1f38e5048df20c48a6aa1f35957be8cffc79c77a2d974b553821e1f4336a11d073b2768c3058a94466a60d5497e8fac52a530c285508c337715f2a49532f3c5ba9e9072a5f4c15328f186b78974cd9478c702cf01815f5a40f6a74842009d7894400ccb862bd3f9bfa8fe1758efbcfbe2d7aa0a619b41598461b65cab658b969c23243c13f554946f3da3c588fc1996876aaf19c3691d33ad576fafe1b76d0cc798980ddebc582684058ddfe4498d46dbae1f7fe464039cefb1a66db08efd0029e670f0e7db117348010bdf8a780221d4df34efb503795ffcf3166be7842aa46b5e73356dd88c8aa102d22879921754058a797960dafa1f8a321a73066b733b67d86f702d06a1488fb574a62aa68790f7924fc5e246ad290fac9b0c65fafe3621eef97c277366df6577f97c03511d9f98565610acdb7fa21d236ceb157fffcec31904ba148a7098f6b3d4d778cbfbacbd75e7ee0ae1e89df90d07ab90dcca244ee4bab9463187a49962f78afdd1706028dec0dfbed5ad74a2201ece9fb345204c31defded15a05056b2b122de24d7964b4b4048ce80ddd379338d87cbd986af061a2893dcab1bcbbc2790a8edbe50a2fcacab199939e058b80e186a39282211e964832955156f5a245cbb5a09735b0b8859ed0d864c9ef08646ff8a21e85b5559b15dafdcd287cb9d213039cc30e0f0611285a85e1b66591919ffaaa8882af7cbe2d3db00ec6ff8f218983c884fd65aa5cb5537eeac6b040cd9531019bd41b104c5dec52a32da8bbca96d6dc27ec9670e7d3476dcebec4ce9c9fe4e289babe9ee71a4f578a23fcba3d9d52bdd61487c45038c38fd7f59bf2ceafe7809f16b4f3001e7a4180c9ab5ebf1b25a721dd09fd18e6bd616f61b9b50cd4068ad80e14952f1df410b4b1dbf401b4defccb8c463be06afeefdcfbf650b44142729d4c69905d78aff44cbc38c8f558bc8411a8cb011e246fc630d0b7b6fcbd48cf57f348ab9c48d5d626d764ecd93c4d302078f87400f49d43484c84ce6e95d143bd06623ec8ba0d7efdf2d378b70ab447b7ea8713ec8bc258448628e78789ce9462e742a398c6fdda733a61266526e2c1c49f6ca9d83b590d2a924aa25695b02a798ce31e062c5f8de07f979763a57a78e0f24ae4c8c3ca83bd99a588c7f382dc0f4c76b3498af4d5a3b68f6620cfc25e3965f9a83685938117a9dc144aea3a61e097979bc42ed4140502ddb3e3668d21e21d1dc9563b95ad9fa7fa8e3e94b166fbdc8799c015273f459be5cf9ff3a0390d02420793cf2127e580b91ac17b55719363fc29376a0dda5eefd6e800e9b7af4f5afa5b3558aa16fdaa66ace3622ee84c0c1fbce1fe6e3fe30260a67940f38f420c24203969138917f25e7422ca8c2e94c3cb110001217790254fe2bc9089faf6a026b2f44bbe6c8ac475ff8ebc5dbc85ad5bc1b474fd0ec7330045e11fe4a8af94ce40ffdff2dbe7bf67ee074d23d52f14ebc39a6101a55c032373e9cc6ce90a96c2f5d1c348af00b5f27bb976de580d55f1235fedcce139c1b77c25901740fc1b0398b9dbe069b2cd966b34f73ed135c855a53e473a518f8b066935256d140154a88c68a062ad7f271760b49dbea9ebf1a2c52ad6ff90316b6d82b1edcd1bcda931907f0c3b75c4e5c5be0e706cae005de781449fe699fadbd6655e6e7b6f3ce94ff46119067f32d95141daf88df21ea01fb53c118f071517ff15770394ff4e595143350085db28513565da4afff903215c9c005041a26c03c116726a01b1461ae5410bff587311790bfb7edaa38ca73cda00747886fa102cc8e2e367e1f9620e6ba34e111279b0a8b50681ab0d2bfb48d1cbc7675db3045542fb09c80d21b3c3a9928c8781bba39578b1779e30ee8434f1ea380fb1b9d8532899bfddb00b053565f194f0f41d39bee2b2d433061f3a82d61afc62191cf1602e79f349c2733cf9e4fe0bf880c40a2afc2325fc1c9a66e8e084b3432ce8a085e117f27781081f636566117cbe699d587b81b5dba4009854b6f8d96bea19d41b4e05ac11a4d38dc92a67ed692aca0ed6dceef5f10c4bc6ba6ca4015f7ab323948cbe059dc6196e0dcbffff335aa15b13b55fb93fe4d9eb92b69662c0b2cdd30787a0c5d2528a9d47c08e98e9dff64b51484a55bcc15cebe4d3aeba9cda2eb9f03145c77be66a39002380df048d7c212d9064aed140b0885a27750c87d59247ed1dcf51cb760388c50004941b0402060673b080c9c47ddb346116bec90bf5df286280eae26c1f67f8ea6c0150853d2b3da702963c4329ece5217a00ee8a8e49ee80d10d11c04bd056c86567d464f9ec0a44c916996e9571d1b9252f87bd8a5c184b170bc0e340011873a296fafcba8cf16a63b23925203c0b506bcc69fce0321ebaff34e5e1d594e1bec41182eb4ba5733bfe8f85cefbce9eece341c2f726df84bc777e7aaf113c175794a03fed7b94c9d9cc67a6ee7e6f06d423aa668a550507047b535f695197494788f4f2302c4e9b90fef3494fa25498ee1d65720e16d126af62405dbbd12d6ed73a7a458573922e3ccff838100a1732866a7b72d86f38acccba7e960e355e1e1ad88f08211010b24f7b6b55575ee4e55112dc13c759546bf5465bf98eafd4c74b73b109d74337f9b2e7c6e6689a2cc02a507ee32b95f0554596e73fc26574485ac4c267e0d9ae10aac5c32d208696fa0bc9cba96b600a62e1b83ca64f935b225241142e180edca5c773ea08617095cb0e90384df1b07f1e0295a7a93c76acc7f081a86336e1481d11973bfaa5da39fc079608b22dd38c8208ac811d3cb2aae87d123811ed0c00a65dde65077d36ace43f251f09ca1eba321df2d5208fb247b8cf12fee13fed78f345afc83b1f0f6c5e7c4c8b5f7cdea69b7ebd561375d126788e9e218b0e1636d719de08d7cdbd0cc5723b41619eee3f02048ef7f02b21e9bfb8b6afa25472d502bdb2636579008044789927002ef1673666d1ed812c6c4057c546863911bd5a7ba3608ce69ef475292281e86892d2845535329477992af57b79edc0d8ba93e1c5267a12b9b1ce2dad48dea56730537777a1912226c593f13bd6f89a5514999f1c8d53204e2a49989cc94e7d965bc1b04e7db069102008718db450745f7da75303b18763cbe6d47c4d1857944cd80301b8031183483653679cb7d178c2c0d7f42ef4603b1ffb1daff9be9d8cd4ff5f99f4a64604d1e0386377c9476d90939784ea0e979b46de96801e0cbd532bed30c6cd2d60b363ac934e89eeff4435a5a4444c745885cf281f96f5471edd1037dc918bb4b3b86ccf54b61bc8392306dafbadaf69cfc8defb8448a5f6900a87ffc9fd54191e91bc2f3bd4a6839af04aeece55311256286de5777d899ea2ae4a766bbc395c52a814cc3cf2ab942d08020b055486436f31e6651103f92135d538692766d805dbf5a559d2a8e9d4f8848dce8215a0efac68e1b192d65e143cb459b8c69ef55258f34e02d7daea119ff5497c48ddaac43bd31096340bca8df273593164f54ac0d30af7ee4f3c56ba961ca02ff512ef56828b4add94b74caf4fe69f1dab8ef8574f94a3bf07567602a347ee91d02bf35f0dd6da462b9803313ef2217cb003bd4127d23c1606370d6de1a285d030922eeadc9ea7a741693523972afafae7cae46d747cba373ff0d09a76a5a651dee23b21e5fd16ffb863ba86813810c6958754dc8870ad13e08e52ba0139ca4c7de60f4cd449afccb2e66d0a4098e450bf15b7ef95df7172eccecc99cc7c0168572040579928677cb152c48235cfd2e5cade1440725a9a4f19c14364f4e64f1a5022992f3b1eb5091bb68bc9efa53f628eadc6d1c5333ce9e341fc75d991e93c5933bb190c6d508b4accde451d08c2661c45737f7dd0a5bb172cb255f863cd798ce745543c7112d1e040adf15392a60c8aab76fd62b6a189f228b1ff26680290e7423964b416465539b6a53f1ea0d4ccbebb60f447d8ba5a67e781927099c7e003d1b1b3bca9c6eca9b1b8f7d923d45b67facf6a7e3e53fbc76e0aa404d13b7b1856c76baac766abbe87e98f41489b7dedcaad18d425524ec20b150fa312a6d65858d4437231aea280d6b26b8582553fcb45f2377ecd7cf770b7c4443d26a6cc833ddc1dcf890bfbd2325d7821c610b3edd322c0efeaece22b711be9d573f6e94b0cc39f73d45d807421fe9c41010f59486185477ecd5158657aa6e285fe6543c298c93955baae5ff04821c97d0501edaa4127147a8c49aebc4f8e7e4325e58b37c350d7a0852329892051e42b6cf24c2e0829af07dc3be644da58fd51e65c82d2998c6dc22fd4b0a3158ce41c925495dcada892883adc9955c9d7f2faa431d85138ea2b0fc41eb1048eccc9244d52dd22e4e0768f41cb0d4f5a38d2ae9453ec45af96d29618e2c01aa5da7184f0e89bf5c68d400316914afdd548ecea2ab4f476949e3b9a9e7b3891f421c1c3e0f4044ae2d1da4f9372d595b61bfa207a26328403f1b8b801ff209ba2c213fc011854f3074b64fb7352e8124e796fbca899d4c660beeecfaca1da9c427264bdf4a38842259607409cd29db8770294f73f98c041f14f8e7b545e3d43c0066f9332fe0bca899843b4f7377c7d9dcf96404d7ab2972655f958de6f2074ff3b0bb60419813b86b281eba5f73d23b6c92419675e7bf48b1120395ecc090ba852b0ec4b84cb65557faba98270604bf238e548a3f6fd53ab08f53e2ba8ea941d05c775fc7de77fac7605d7bec1689e45932554b72848f213f1b0ef4a75a85aa40237c83714a7eb6e60eda2e92c37b91569d09969cf39c9e7daf01e9e2c7ced29c3fbc1dcc2bd86f625e3f936a6c05ce3bcc517df32090f8875d477c0222a1f94b8ca0259fca3f8db72426b895bd66aba5639e5a2b8aa3049f26b4f95e68a428b6e639ae9522b54d397f5b3edba8930fa68aae0d555c703e86328311aefbd568230499be0ae59248182701f65dc28e9c10c047611ec29e9731818580edb40646c6b60f1d35fe81643ccb6303fdaae03e44a103642559023298361b37a74bee50c9d20d962f738f19498f22ceafc94991133c2617cd3a948bc21ab2974ea32d5a4b51837069dba60a3711fc31fc254ca50732f612aa165a3bcdde6d09d4a4ec77abe063608d239067f824b4028b41a8fad89581db8f8ffe720ac86404721ee063c2a3cef3958cc13d3c09c4825c05f19ee5155e39afd5239045749cabb4d089752a61ac908fff8c4d1c2dc230ff0546039d8c31a9c1f5b1304ee9629c38f54b0356e3aa705d49079813e70685cca0ad85d8b70c45d7df5571766073b07f05e50ff73bffc10438533fd0a3b2aa3d8d2f8cb1b9a683973851db8a3224c97d39a2faa6f76992433e04b6f5a9eaa0ae2895394585ff19b936f918c62fca967886f8bacf1b828ef44889c469c86b57566be2305865522d7ea549c31d9a62097e7828a4a17cac23babaad3385cab226c675938dc8458962331e9403f48359e46006633b1f28b6628722241bf23f926f65b0b8a616e112535ea0b13badec382c4fe9e4f2ff193ea0c48fe3ffbbb65718ba86d0ac8b9a09b37986517c6fb1457bb8082db230a78e8724369daeab7e2d354869c3aa50646d496b2f9e89e93a8b5d66ef5049c82b01225a2272030b7cc0edf8361897afb65513181c1d51207c41c8f2d0d936aec153bea58c2d260af849ec9a69c1bb9924df9432aec147819779b26a2e3f25ea4f0c30163ad064a5d36623b6033b5ed983271cd3896de6879e3e11aba299e40349eb495d42608c7f83df590d7d81c616e7179fdc19f73ddb21e776ab87b3a4f6101fa735576ad9ba1fd4d214daa4a0f52e34708f2b7e3d3bbbe146b8bece66150393f816e8b6f145aed5e45942467dda4f3195f5619e3ae904d69307ecaa16897eba179ad8a7f850e464c5b36fe5d426bd1ff14e24249067418e5bcdd18ad7bc3d4d48de4dfe08dd3a51614e06024a1c2878f6861516a451df2c42f012e30e3ccded2e95531dad442572dc4ccf29bf34214c0c9c2d756e66899ea76c81ccc2bb6ef58537774785b94e2416ef29dccf30e74efb40bf25558a008ba2dca390a5064e934045a13da48faef606bbc67dea359f92ae275717e7d34364e0242c77f40b365795b50d8ec4dbad1894e93a3ed67129d15c065d796b798ff07c93e3b5d9cf81853c9df7faa6a446af486a659d1829c3184d92e1a1f81011c854ee7e1f715fb7efb1218f4c978979b0aac222f305df799b2b51b7998256bd3fac1f1cc0f5926d3ef52b1f7196cfa3560d1f29c11a7951f6b96680ffec2a9536778e65efdaed2c1ab5c276acc188f761c50e526db172c20792e122bc65487c2d1fc1e84281c5878be6b1b936d1d5c93a383f8e78a4071740d73619098842def8a134fbe1bb2a718036d30b6215dc04803db530df9a453e990c9cca147b6b1b8f961beef0093b32f398ae4b1bed498c4bab1c60120210ec6bfbbb095d1148cb10dfeebf171a776fe2b518f553ca3a257c96240a0c506685bb5578d5f9fb5787577dd3119f5e0cb26e56a1dc0f1a2cb4387e9a653cc6f2eee4817e10285369fdecb62712875f1af9e1e8748c00c243000cea2678df25fb033782c1826d61a31cfad28f62b83c79f79dd45790ffedf2c8ddb994da2680909066e10c7248ffccf8545dcee3a704f8da82d77d361302100b4647501e9d2731282be9581afb33bcfb2aba802f50ea361b47686ed874cca467d99ba30e59ee51d3869812afd02812eaba68eaef862116bd67d0aa92db53c2905451419cd2a2d042ad45ba91c9a3f48fc713c0d40a0e42e55e73d6f73abed92d7add383a63d3ce68516ee7ad4e91d03e7dba9867693e4e611fac90c8b15bf93f336062885a63dbd8476d45dbe8efd1ad355338306067ae461b84a1d1bf4b29ab4b635eeff053ad0cfbf0124a8b5bdfced2f624db9600d4cfd1b4360647058899a43184d502418e36ef68209a249424e2fbd1eae3a7f92f24a3357561badc0f3eed5aa6539d10462da9729c8bab2d8ae23dc27531e39de8076501a06ac103d8ef82eed51e06ff680b435912df0317b337ebf0b6b0a90841f96de3fd9fb2d271a63a4064ff4463563dbaf4ee36be02da3fd70272307c4d8247d750a52ec55ff8d7f28e5913449085879fda38a023f3a5d186b6ad12f2e4c74069751774375724d088b525c276da860b16fd0baaa0a8dbb3064c87b84ceb05f2b374c4c8e0bc3ab4cd00572879dcd0313793ac29d7ed91540a3383be4f8a71bcadc590c3f7ec06d2083e846dc2475963e294001e5beb63434a799df97551ea9788fd8ab63466d177ca92d4c8a2528d8198b68fb6fa7ed89721fd6be9dd1942706ec9db1c68564d76aabe09a658c0abc5795f865b2698230e4e89414d58442a9dcf92e5a96a867bc8f5522f9eeaf823ac0c6209fc765db0c5d32d31c559d2080743ea9d516642253104b43fcd8484c8900d3d17bb12c4b577001047558d5236dbad65ebe155b6edef90d8f27cb8b5f50e6ce9fa845982f50c620148056ea4bde2ed43042a544f77c8ad11f8e68082bef83fd1037f2f4c93acb27f751d8a3876c046db2ee809faecd4e84c39219f4b057f1ca11b16206a0f77ed7982edd085d5d5f7b2190f5c3bc3fdbd3e2227a9a20b1c307cc651a91efb36020150cd918ab61ac39fbca3135ed94cb2bbea68b964bbff406d1dcba417ce69c768dfd1b5b78b04bfb90fba545580be85478bc485d872a332736d7f9511594db7ae6c959648af2f1d273d44752610fe00ac5f5b52f1153e09eeab303bebd88e17636035940a2f0ab2a6d8013e80ec103d5aefaa400db0f011ea0f5a70b5c3f71baf4635bd860f81e39d86c3ee431a06f41a2c653874a8f601d03fd29474e3dd98edae6f0b7dc4eacae04263146b5f8691fc79c997360ec3cd07a0e0f41e6650c03df041bceaeb6ba6662ff404143dc4952b1472da7c31bb07cf96fa11510964fbbb50d31265d2c4fed845e74a251370da49c59571d36ff6679a920b28f71516a722a70045445ee723232253deb09b3429758ef0b79f364b264ae66033f6f04c4a3845accae43c63537025b2ff014d886dd4aafa872f0a8d770aa10cb85ec5892cc0c5d121f622c0a595654d972ff012aefd0d952bd583179559428c7e0afaa9db6fb0f0d21452600c9aa430975f2b50804c4ee8983c828f5d7b336d3dc2c5072fe136ac9d60b62bfe1f3d1a9b5e7e57fb937cc8ebc83afce2d559ca244fedfe067e3483777646acb58c0e8d883d1afa25bae66d1f4aed51c53091b5a2d5d68e06fce6b21cfefba49661739650f8ec41912c7347c7496627bff6b0aad818225684fccb7ad744929b6ceab2c3124c97cad558eeaaafc7029f8cda2364c42f1946a57c561daba673ee7c2ce233addff46f15028bd525749fbf95f48c63adf31c61ddd69cfa204cc04a9c45319eae1996b44bc45e81234a7506ed16b38c8d28766ed6acf153092b32bb8d57a263bdc5dc2999d03420a1cc604c03c61a5b77fff7f9afe9924aba46d60755ab02d31fd51e7d718fd0f1a311dda344cded1ae1a1a491ff25aa1ec9b3385df9243e8bb1cb0044bda53aed652b6b4caaff9610f4c23a972625e8003f4f30b2c7c90db20f43e700d6501f84b306389628dc059f2cc56439b522a45968649ecaf7599e7fba489d552a3269fb0e5b11f6f86a521c2c5d2761764416327f3e9a0a7a5c79c2b97940202ea62a5732a677f61962440d59b694ca3cca6aa90f18811570243f27931a987a3b58a332f4ef91b3b196e258762af4b8120989d0a13a35b3f202e0cf83f0ac6642c20c3de7a72cca1d996e4e3b66d0cd56b75cce810512a6bafad3655418d0f95286b9f8c49ee3cd3918a99b1a2959e45169f8523495d33520f265ef5a6e919ac1de78c7c64c786e7364aa63a6649bef5df7cbd3f3798fa6844d23f4c06b3567ad33f54333c3e2a6d1d2df5adf93e5d6a703f4f09dac0e0dfe515b07ee630a22a5b2e3909bf82425b91105aa466a5ad279a6b1b18d12150d3a0e589240b3a31072037befff9628cc08d5a1dbd54c3e061f99db5640e990acb4ac018cb9f785ca4c88c831585f413aa27ae229744e31bf12da3785097a820bb641b2dd633a4a6458a80ee7b74593cbe57efa125fd83d11e0b01ea25cc81f0af59d0945092bb1c38725e5b586f26721eb0b5f79cc0aebd1df7bfe210e47390a5995342710dfade01bb5b1a06d7bacc59379ab4e0438d59245d5d04d047527b16d22f6564880e5e988761063c922ce0f9b1af334905a0926fc6e0ff2c11b3cab4412ba73aa0468529c6d95c8089b99fde58ca27ca711bfceb6d2abc82bbcb9a6646f35d67d07758f589b43bd4118fed0ad4db55de9dd2a24c72b6b5a1511f9388061be2f76d19d413c880770c11ecc72d83bb6539e8ba4fa5dfe648816326e230ded131cbf09e7434795ce67980ab176f17585c684eb3c075d92dfcc8362d217d5faef0b8c313313df2b795fb3550254f0aa4287060ad6173292135787729e422fee32c9912f8f1be1f41d2c54482817c792bdde9226d49f4978a503e5400b5f32a3dde030b9c8d400ea7d7bdeb7f8b1f4ee236e5b1f7a035c5dfaca487e3e1cf3086fa158c30589bba081b2d0b3419434e4030bf3eb9e08fc0b01bd7bbcd14ea75df918cf084efad33b7ab0c52e61c5325a059170ee497b8ad69bb7b76cb762a61ebbb97a209dfa6c064404aea9644406ae6508d1b2f18661c150e97cf6ace54f3d87ff76b4c41e9e30fc020bb6737a0b73eb944abff3c91513d240e6e4e89d269d7ff3db7dfa708b1df74d626c00c440cd75a2699b0649b8505e423aed167477046ce8f7155dd8b0d23e0ef3b846461c18d5a85f4253c5076e657731cc463567b0719f5f2b49264047aa2057a5bcdef5a6791fdf87b22937c59524c29035618fd342f2ad75fdfd44075444232e1b8b130884398db163d8300b23acb096e4396840214d4afce2e4cbd208d8b6e95f9ee0565f6e8357a7d1c87868c412b40d68ec3eb9622622d6313f56385378b9ceaba266b34b732c3c67bc0c1592d819f4f780eee90f261d2f4b3a87f881627b741bdb3171af9dfb097a65859d049e026b5267a56973edba061fedb4c1f2a022694382d724ef0bf05082f15bf92442a83011563bdc7975ca0495616bfec88fbcc0f1b627bb480203f7328480e3c432e37f5285189f2ac949668e28d61ae866893dbbbca5b074f1194705e2eb4e5b1d7f4dfb523032c90b5be1d41319e15d4ea93b7fc0ff1e012b145c8ab33a93cfe0feec26e66cae85ce7f26fe23c7279cc652f4763e39b68d3d5d08204ad90e041090c1f2bd24aeae434549b9115f4e2554398efba7f46973d6d1af35a35fc53f4ec1de695b63eeb1d42a2ba8e3043e499134df9448d15a338f89c9934feeb0c6b5cc093ec5675a59cb8fbe14bf359aa24ae647fdd2bd72d6bcdbda5879b3539acdb671568ede37cbe76171dc3d90a968c0562d1e34c4e424ff439b71fc6a7ebe096f130338f2988434983b6398a46e1171e0d1852317a5529b405ed6e97f66bea8e0a0d0f02695d54d9a5f9d3579d1457608e871a193abab11cfa7cac5f9df0089bff64344737dc75666cb016e905b60ff70c272e55da709f83256ddde843d347b7711076050f4e5ff89d05481539232ef1846172429f9228c2c2a026bbd67f599046e235ef53c1a1cf0a99aff877bed7856b90c9592c85c01a6d4256d35926ef549132cd248fcd661d8daafdc81d41ce9fa1f693ba405f2099bdb195991d3fbb5a1812ea07749f90d251fff7c702adaad34efababdbb6f01b9d3ff0dba92eb5b8adfdbf076d9acbbcd02472fed0f138bc90ee13c9f9cf4c5f190ceb381261d74a774004d56f0055817160f8757433dc5fc9bdf1916621c680ccc587bdcdb183e3986cb09d81ffe1aa4ad1ed070d49459299b5aba425f428789b8f9522b033f7771285b9dcdf0327157ccd5a6acf6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
