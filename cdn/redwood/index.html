<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a748cf55a2983c7b3f3bb8f93a8dfdfff7f40418e57982fe2619c0dcd98c114a857aedf35dc39e163354ec31633a35230c3b9c9505ff8d953bf2cc48405b7874f5c083343e047d6384339ec7f8adf90bcb01e73a69f8d57f461d093aeaf5f14ecabc2e38b96c5579e5d1e8aa750d37fcd76de43ae3758c87bedd203c0876ec4ec7ec122551cf5284341afea455dcbe6d4a1dc795caba7b38102f86eef99ce6081998f87df4c6e865be12b96b295a8a10fcd26042c6aa80cb5fcc0fa93cd9ac5affad8ef974baa941f49f9667a5306deb3555be46c672d6cb4b10def057e1f2d4b76861b231c0617ae66a1cbb6dcaa12b8ab45cb7af1d39336c60232e97918ab7719c636e925dc4325056ab5fdb3f4ad26a37a28d324de78e5b0044509443da5cd1f66b72d23026b6f50448b956b4c57435b862be112f7892d01899129fc1692a930bc2f025a947a7a0101a8997918d6639a06b0e42bd57d237e32dff8f20f2278ad9456e94e22025c7db2c518966a84289a5b7c8c3d8a3836338dedc218583a4d69c65e587ec3123e37a8b1e73ae8350567b290186ff56ba11c33efe6d49c6487d24848bd50639c960dfef1886febf7b4c088e9939930a6aa81feeec317e4977952d637b24ce5d53b3f82879c0d7e0f538a458e8c92643acc5596ca88e7b08bb790a46aced9146de2893b850839c1fe2b73e9de29097a87722d3961aa51056abb0b9d2b71ec56487d144ccda74948901a166a94b52f4315dc30e88a67de3d264f152e3c8073fac053debeff840031ec85af6173a3235c79bbdec5dfc08a3fd18ac97ca402743455e614610522ec72f3d9d40770d2d05f03c5daa0e00de9513aeb45878b2dbddb9b9602a7ff058b2fff087186ae1534d3151dc8c1177f60bc391ea6b969d3296245fc7fec9c2b33c758e1cd068ce54401b03d7410a98ec167d22d89941434add27df91976b96600a78c507620c44729213959ba5aac83a91e104e30c68ca72ba20ae0b1dcc197f1d7dd31f60ddfa4f0cad5a9486cc568f5736a2d10070e2a43ab4df7e32377fe51cdeefd2639cf596bb3c90f25679210196a79409f98e4e9360ed28743122228ea822cc048f1f20bbb8aeea074b54eef7a0e3ef7f7ef7a9875fe4a0fe147fa193e9997d3c2d52c86ef02f4e82ded80664ccddc65a98f4254518876389883025952f6b494114bb300dc4bb1d30b63db0ee552c12d4f185064e92a3ce2e7f19251cbd578fa14cbd7cfa7610ffbf27dc12fb00866b547d6a9cabb5e6cb677fe42822d129f6de6783892bf4520a49858b02aebff8cbda2ac52847a655c8deeb2807dbe9438d63456c9a7865608173f88934179231f632574d477329af5ad16f668f66029751df18d2fcd1ac7231c39a03f9e16080b266a75a09e71c2a9cec8640cd625474040d46ca5f0db2642e541397314feea4a09439a229992c001f49a5a5c840a6e05731ec051777e25ec2d05afc57366bcf0795200048f1dee1565c0332739ba6d249c6f70723b44b49bd8714eb4b5bb8213542a204d2f11150c4fa15bce61c5f7d6e17813c9382aab329b42546c838a0ba5a3341c5d017766e1d4b7ad352b44995bcaad8cd21bad0f391e0ed756ebc9e4becbdf70d9aa06362bba334084c4c25b5edafb6a67bf56ec7d860d8b3d7d0188ef0d14210b035eff365f6f2375b7f8aa91f1f7e2beaa7bdd8e5c378432a0eb26f96bde93c5f5b5c60dc8bf16bf99da46b6ff2f65e55f436045065d8773f71af56349e230319064d054bd9edbc931f476f633b0c670fd736fe132e11dd00bf579ee25ea4eda622460f706a7ec4179e5ddcfc48b6a2eb8055e31cf699096b34c6b10147ffcc1355e99c0e6d183ce669caf89b71d52928165bad918135716145654b1279666ea5080ce3045ddc962c41dce6ea4ec439b857db6e20caca342d66b44b0f10b3eaf87424fedb8970628f985b52b940de58e14f23d9d6cc149b18f48ab53c2d7a23418659a2026b42c0e160bed65e86b63269930996e7db70f4e47f063373569d6157ff60ea46212734ac8e10c0e99053e0a3ea9c415788618c346e55099a37fb64eeb7dff4aed8f1a4bcc8f2ed2aa2e71187fff799b0cddb2b207cf6beca65c07240315bb18f89984003ad732de52d1a0d87fafc4554c93c7fa49f2cc414415d2956d0b4ffb3939d889e91c428af74c253654057cb11564c6e0c090348ec756d50b8516b872f90d66ab8039a66ec494f305c7d76660dbd097d54972eb59359d05de6ca8837a5737831305c93abbf6ccaf11d2e1d41fa8b55345a88896c75faf978fd2134e881d98d52986b04c73120e77bf1aff2fa0cc40d1516dec5a466b7bceed0c1cbc02cd408b1788dd48fcaae1d7cd4598fb12bc2fc80af13cafe8ac61f2be01d3c48245dea3dfad0594d28c355178180f790c3aebf2c953e7b83c501e137ebd85f7f6e25e6a09a85a8820851d3dd5a420c972e025c89ad5352fef2856323af2b69b0b370b5ad10d4deefd90ddf967ff6ef83e03f80405b3d77a04d40ddafe157698940040b9164bdedb1c87b1d12c5697327a09b4f412e159d300c0411176c796d0f60f41160dc780d39f706d21424201f6aaa7f2af92441362bb06bf7a641422fc55e65a149197e5f7703efee34f1898a3cbb431a93f4aa43b30acf0c9438829023961c5da66d9b44277b4646f0ebc825bc4933dacc17c078ef043396930aaa2472ec24e69e7878575ecfd91a40532c7ef175d13e65db26b776682456d6d6d233189055ead8fdfabfed1dcc0cd7c515c37030883af550c282addde29b7f5a3060a205679a974dfc522fdfcb4764e5f4542a95d7f157ce53a54e89d8d407444c43ff8b3a6e2d23b457b860bf82c0da7b79a7261a72ffff2eda3c617b0a3c774260ea2e78915b46742e37bbb9d2ae954c2f16deb2a1e41f1991297185ec699ffdcb98999d61993be2880d2da1afee12b302ff781dcaee6c5eee5b34a2361b793c62e3783ca49467eeef2653f78f94576f9d2e14c70368403e64038a16ded77d7148ab9395f79480c21cf825d90bc223e8ef74ddd18ba354c901ab63d72f5133ef342928b90e0a220fd882d6640d38ebfe1d4788ee74b4cf30a9432dde1aac2d665689f3849eb7e0f0de06b79abc153a64feac2d5736729b1a365e316a64fb2018ee5c352b2e79a5ab4d58466c19aca40b67cd32406bd85846be2926c7bd2d421a4efa84738697e6740c5570fede74e8465da62c35a8c766bf6ade2d6e2d16a230d2140ab6227a76e1afb852bed006c18d0e79135627a9f4a000caed57d2b5389c7a538b2dc7ea786b79ca85a75b38c7753f73c57677badf90eb1e0faac34b224424b0915aed6ef60abb54bd3a4e438b38da97e6a5e66aed3ef81accdc6de1b8658d14df4014ef727fb27e931776d828e43544943b7d0c1c0e320b6e3df1f3d633503fd33e8c8e3263530e95e5b3c365b3d5c1d33971fadd56dc057296c8cebe7929ef0e6e77980d6cde01c31fa8f3f12b473281221677d3da8691a7e3861af00d729c022717a822c41cc0aef9de52b9c0a612628dab9b85bdf5cae245da8de29a839cca4f39f18be5069b19cb190e6d7596b79936d91abbedac279f6410454fccb992e8917aa6d555549491f38b5509c7db6c6496d205833efaed2a4e143f1148c5977f4638ff679199da6029fa7cb90bae7ae1483d025aced4592bd6d83b21009ae60008dd33b40ec8e41903fd285f21473b0dcca5ce27e1b872438775453f4d225630305235103fe0c75c75c2dbaaec5d582f4c8ab86e94571e2f2a8a573c78becdf1f90c2dd3434a64ebe1f3f655d1eee7d92e149944c1c65a1cc6dd6414753ccaa144cd3fc3f882fdef712a76283e0d5d7653c0022957e19f2ea9db518b449d1dc869281ff3fc0897d38a36e567375d9445088a816300cb217093e2a72f2ca77ee8d1873c444f936844c58a6844cc32f8bf14ccb7257409c9b227e068e1bce19df488f95c02c8ca9e1cc79513e5f9d12e7d7bcea9902605995aa2a4874b2ef941e06596a0c1849081cc27720119f4a892fab88a2cb7bef10c81e8856733f07e0df1aa8038c66e379ab97d663773c761c16b88ef55000cdda95348ff9604e233cbc56874c50cd6e6f096ebe2a6dfc1043f6bd9944c3f7f2366aaff1759a330933f7fdfcd4c7b59b4f0d63c513a1841869feb3d208d57af4f7a2f79b08459f941773123ded417fe433e02739c7ce66d4cd60ce395cf6ef2a021d976cba6bae09c3d23dec2e4acfde9ea7e7d8110a391376d7557407b483755e34449515f235bc7bf748a5c12be1a5c0eb10e7290d9b732bba15b19da1983b74fa139b17edd962e652f4abbe440e0a6514c7f9eb7cfa34ffb34621d2cd567ddb1505580d8e4e5c62381fbf6f195e2f6fa0966485664659c15d267db482691c238fbd77a3d2f3c04070fd7f91db8199fdaf73c0c5f574202cf3dcad5cf0ba4362fed268bd1503d0aa6820abd3a8f395cef8366cc09e844041d8b13afea3466a3f53da9fd4b5be9de2ab6100b581bf0267e0b33d1622ae5d9cf4e940c3324786488f2186d6407c40551f87a19e965d428102fbee5571070c0832a092ea60c45bcd5337ed9805362ecee90d01dc7a94834b7b8d9da2c4574db68bc5deb851bdcaef9fd54e517caa62df881d3b8ae22dc080d50baf9347792f2b461d745bf255b323eed3b0409bcb4283b316a7358177ebb6fe27a09a74a4e697a128062818c7ecb1e436dce3061a5a010ac799f2f81e1a269ab76868b0d336058a58885ff108c620b463bf41275139ee80ceea135fed75476b25deae6bcbc3abcb1a5a7f276e445d0bb7cb08d9fef48b991b47bc616619572ae9494672e24eff4b2036e0b1d5dbb4236c6552a431f10ea76471240b5369e7e7474657a4c31157078ccb2b8172df7bde54d9242b916b177acaef10e4fb6198d049a8b2ca3c3647fb413c03792d87881590e03831841208b0739e6cff251103e8f29c9a47f0e60e197c1c4fb0ef152031e888e08b9bb321f5b85db8a932cee7dd8925760938d74179fd7068a3d74b800e39813486aa15a71b93cecea4e250b68e31f5fd52614a0c8b1c26ac6164cf32823fcce3cedb6a5b53507a9a7b28da96c32869625b267871e02440e88ce43df31f67d3e979b05cbbf83efe70992f7b98627b463ce3140be2a7d39ce622945c3396ebc5b784ac0e34555a295926c46ce2754cf8a63dfd0372091cf1e6fe40adc3ac834d5d5dc67f4bb75a84c9689d0439d3944466a28aeda6032f303f3e193ca282093b1e0e28fb5926d6b0c0c4ed66366011337dfe7113509821db38f4a7f291a936ea6079011b7a1b9068d4952ad380b054838abb43ff0f714d6ea7de54796c1504dcb16f72dbd157a7c2aa21a5cdc3eeab7abac258ec9f68dfaf614c72ce14793be7a97b22905332107973b5ba2870b428936e798cd098297e63d1cdb884df90f0b2bed1e2f8e27a720a65e3b0d10251c267fc6dfe14ab30aeda3e8752a15dac317b65bf4ab02bbe1c659945e7947b9b9b51bdc2795ef31b4d6a3d11f4b7bc1a6b62da6e7fdd9c062b314742161cc2f40498607b1bc99b95899524bb80b463b366cae700634125b9eaa2c151bd1697b26faaca9d73a32f81481731ffcf0ee489223c463b0e9a8242792b44c85390562c7a0f56d582009551e49f096d13b23b57b68c6f765248b74fe42a266480559bb701597316369e044de2a86d7a34e8027c8063b26cf5f23e61a476c35d40c5ecc9403b1c727ac8c4592041ff71d15469e6cfd6df1d7559bcd2c455c06464827984b301a5fdbf1a7e586f48e9e0384d4d5927644bdd88140d22e2c5de0fed0e5634367b1e509dd2fc6e85f69442785a67f5371460789a71d43a302b8d64d3987e91361ef4fb55eb5ad1aa07fa16fe76a845df3ae0410df2c0a754008d33418a0f3af7d62d219984584ce395e32852ac7ea32d3d176eb1b934d395441d7477af4cdf3688d7117c7e6a5bcfc80e3337e0784f89d757d1d10382af3f098f66dcbc602b2226eeaf1279bec5ba0f0e570bb5eb9eb4608a8e15a488e83f043aee853a57982fbf5b326966e2f7608d0b0a8cc6d6b0d8ce600b7d1ff7fe82a83e362720df5c4c3b7b5fd06691863b84888a53423769371245c51fbcb91a030d346997e5338d5fbc3bb85f4c54f1e0e5e0d3116d4a427c74f05ff23bd0129a780fb1799fa4e83f7404d2b45fc74ea7f307892ac56935a0c63b06d091005ebdac36784f5e1943364dd0c69aad16031da5fc6a7f39c1317382c5e87a6442d477b77d10c4979b7986fa9e05d00905526cd96105a70870beecb121ea63c9793f3e4fbb220706455a5f136a67b87c35b0746ec116ca6c1b3982cb0b7b9deebe42101703f2ef1ba8648be22360fa227b6f260030ef54df44a37a4f700f7c68d896869c68a1cb1931890fba6d5a888996bb5cb60648d420196818364e703dc400a030863076b7dc3fb617802ec19e2124f270ffc68692c0dcc264f982ee6a75ff206dab8b543a9bf3f682d556f4d8ae87e879fef7d3b2619f05b3ba574e97b5f5a019e9fb20318b9c505dd285388151f44e5cb339b13fb8fadf7067c6e3f38a993754b4c6b0b0df342d11d2dca37d7df1703e2347ed31cf6769c1f24bf1e55090114e71f1faaabd7b84665a312e4265f2c9c2cdaef73a4771128ea91b403043312d97e39aa53a1feb31c9f3a74ef355dbb5f5e7317b36419dc510e6d8cb86799824e556f4363c1c0421c265394a21441840f92bfb97e3c8047a38cdb54b108e51742d0bff7b9752143b751254c5c2a6478ddfea32ea0a220bd7cdca887f28758eb04987cf78377f7ba314085c83c1510e893c1a675057ab22da5e22bb2ad6ec2b5e582eef44b642e975141c06e1cdeef4e79320a587412a952ccff0b4128c36d9c274b9c5c585ddf0300714cda4fbfd8cb717c4817fcb6545a7648dd7441d85355e4525fb7fef0d8eb9332a699d6666c0d32efb0771402914491ff9dff00ac77bbf3c33b6612a89918a9c95e73d222cf1d4f53780a8537465e6d1ec17aac2c620a83e4d573f497c300e73d4167e71c62f679e4b884b129fa1b31785a484ad28abd0468f69c2332ccbbe1e5be8cb11c1472e53b249800389e0fe30f7de224252002c32c3ec308bb0b24624bd4846da659e4a7a010237081466f680a382b619f87eb7cbfe5908e2a0b1e2fb67c00a15710f12a62488a911729efb83d3d2db2a48632778c255b93cfdd2e7d1e617e7461a5244d5a115807b9a17ea68129b2ca71d254b24a8009879176c668dfb82d37ce0410a357688f8caf733c50660ae1ffd7f663e95e7c9da688b263e68fe8124aa933c7d269ec933239c01abd30d522f56885a4fab04773c07a52924dde30546885610b558f2dd426a0ee5bd3fa5f062168dae869c42738b8aa7e1fe07d8739dd77bd07bf0dd76739bb50130ceab10315cbc8eed315cada2c60127c86c3d2b7c778569430eed4d73eab46925d6d706fc61efbdae337ee4c0ef6fed9143007cc56dc71d402d950cd5dacab6bf2f75362d6a725b011538a93f3a920593714db6e4fa27425491e11ebcb2339b714aa088cdc96d8be86ac8c483eb53004f5d03c5b80cbde7fded7b9f3589581e17f18fd543453d694fe53d963923572608b3c999222d511f523af652d7c91b98bf7c053ddd746f3445e90a27dd46b300b4f9268ab58a9ed414b56d072fcdd1c8e85280054e70501783919c532a3499d31f5b7ff19c3a60c16f816e164140bdb3baf0aa217185f69c28431ce897a3ec9404fae85bf181d31a3e6922c1332b7f6fdc2617d96fed0abf5a6d7544fe398d52dfaade435faec2dc801f8b1dda863eed5d37ff3df16fd56e8973c76c44c60e9453fc55b088ca2315630080214209c730bf693a8140008d55e70703298e1b1c61ea210c41662d5f375671cd4be6f5ca241dee435fa50aad10ac87b2ce673bec6c967b9a88fed2def78f5e3383ee10d4edbdfd1cdf4442a0c224779d5414b7f8e250e5de810b3983d4f623cd6293a96321920ccb9c42ede0454397610e1b7a421c4f4bfb0b5d7cd169e9d8d64b42633cc685652044fbc2a6ac8203bee0f603a9e3c6f5fc4ec69ed63862145475152c64677b22ad47b7d438ddabfe1345346e4a3562cf11dd14786bfbc348a859c0376b1703778da9d862528d5b812caa3c05c4d17cffb8d62e3d5dcff27b4b4d33cd50e6f8ca632ba8c055c4105baa4be3d2029d18c49c0805289402a13842a855869f1a77ce57f5621e5b3e9ff0dc91191d92d52f09985490bce6191006088c11e74d969a72321b46c8909331c646b9ca15692a10a4f0122e31221061f5aad49ccdc04bd77ab42e2ae68bbca506780f1261446a513d0b1569db270c0e5f94df3541fbacfb4cb146b2dbcccef1edf32c289c7171262a1b2a92b637c3073d11728f887d07c72974e6d8388f1e06ba61a0aa1d2121969bb2b6d1869138b3c7b2dc280ae307d2a28c971df4c97803f7e5528e91c32082b1041903a14fd6c5346a0facdc2eccc8f31994e608ca935c24d5f4a6cbde40bcd220a506162702bc710c0ee71a58bdfb637491462b1911bc2a72b955e78cf98c7e4dee0fe53b3bfcb37aed1d170762a4a34075fb0b5eda277f9f66140904e5a7a30ca563cf6652645e7395a8abe93a9766d59c7b21e3befb232841cb5d62c67458ecbb4198942c07b35fb305ea047d94031ff337301fc74fb9ceba7301f0a3939dc5dae9c29fce332f4e9763b83ea247632250c5b506edd25ccb681b25fba2bacd0e5fb5911031f2290e772b38a236067174448becd6972d38d06530f23cbec1ca7c5829c2501865a114d69b19713e9713212424c4638be68a54a87767eac598bc94b4a3b9599d8fb13ac7d63fe1c4d8d7d0dbe6706ee7d54396eb1ed1edf65aa87ace5d6321673fb909f78b7c00a549dc4493ed5781afed0a21faee826b780ef331c2058b93858030b25aa009c1874610404673d62b4fb4ebcb97c8e4a789332c56f5798b39739cea76bf84f52c13b5cfadf980b320af4b69941fb1bd821d8ea7a3d6984280cf3d4d5f460172997b08228ec2a5d39d38403aa07ba4a288539b1bfc36af3594b57d005b5e0a2de355e9969695b722c8a62dfe5af40c3646c648980cc840e72d17a98bf4a6251b4fda26453dd721eddd1f6778ccec4a6d67d80e8dbdb734d84938123b5c97c69f4729ae9a3bb370537db01cd890beec40314eb2b3b3b31e48669699177d2493796940fdd2fe28dae17fdd047077fe3a0c791f4acb8d03bfea5551bd97614f66b669d00b09a8af9fa8df0e88ceaa696db88c452955f8734c6c7a51ba3e0c85e3d106111d70288ea921fbd5d848cb53e807f899fbabd3e065385241df4bb72017ac5c1704dcb68712109e538ffafa33c9cbe205895ed44ecc6b749b025395548eca79e0eec767092a2b8acdfba05d037adef6b7460b9a59d1c5e671bf7ca82697989d8188d072fb973f64e1ef073fafdb13b8d98114b071f1ebdaea847222d0175313f0455c59214169dda385ab5108daad8fbfcc2d33ef30752777dad3659ad16524d175feee0d998eafd2b79a0599f1a037692e4dcb4f576bc491a14431674f8e3a799aca50504539be9523599c3117e2bada473965648736111cd6f3d9ae6221ed7cdaf990eefada08c24b772ebd3fed48ebaaf78ae8ecd55bb77adb9cb6b0d24916988187f8cc1eb13386f7af5521d37235c89b3f35e415e25b909ded3f0320e2dfdd7f2d975d62823e06c5892311f0f41305343588f9464a400ec76303b3e7bc756af63aeaaca8272b355623d5064fba477063e6651bf69768ea0d0d1ab09e060d645cd0d6576e84de1991dc2942b3ccf2c09918b3b53405b6a0a41603ac97da4787d087a4952947bdad56d3926a2b79710f1335796dd71d1ab06d02ced574b01c2b1438d2b68c3d42c89487275bbe576e1b5af6a9d26879500cecdf63a318e01dbd19b69769e14f4822e27e0669cfd516339e847835018bd3dc909b30e4dd937438fc04364d7814db5cb1733d2576882154ec6801518994c7f614fec6dad60c9b1889ca6f008c3e60b8391abc1160fa13e5a1f769d0c31b6a32b68f7cd3a83b1cfbff45700e37bca44af1fcb97d7bb9fb84ca7ab1b7f6d1a176a11b64146f199cb4774bccb697fba990ac8ef4f605286a5370b5a6619dd3401b56b70e148d0c31dfbe454311fa9aec75befd6b4a2345a4a1ba325d20b2a2b9097085bc826132f3baaa5c9d3378ca9c61f7f93dcbb80e320c2b8ffd38fd7b81678f3229e78a88ea8eca2f9b3245da559edd74c21415b50b977c4f4eb3cd084c937c11ce0ea92d968a329c00dc15254e4403ca17f2b94578da0400ca916c1e8a62a50b7ea06cc2ee1332ad8a15e30a018d829fc72e7f9cab01b0ecad4a53e9c6b549276fda63eb110e3a4b48de44277fcc4c7d85387f653b07108444dd229c831cd121eb7560485f1e0e8e54c8fc2f29b2b8c988f55b816c5001534fcf2ad87975866c907626f5e1370698ccfe5ac3f3d3a6db872ea35855e8483468e23c77c5d46e614125f19829041c1a381d0053099ff3577d0cba584738a05bea7a69a91fe92efea29df63e1d50f15c0121ad8ab475dede197d0efcca35e7e91697415ce813db07af4eb2422195fafcc993d01bf37da5cba5ab25a2b42cd9647ffcd5bf9caba3347a7aadb3149913586830f7c974f6ff5b82a5db963599c647f14a939d6045f974951c96d40a7a815074065cc1058a80eb21875f4553b65fe3cdb3d099b0994679850dba2b4a0c3928ea48374135669fca51803274018c997338bf50ee332406a9b96c0574ef37b5d26d014846002372d9c537840c224717231b86e42ef0503fa732043bef26781d8b6c175553acf0345eabe593f2797df0fe23ceb2d77db61504136378cd4d6c6eb4d790eac1273a0241f6db88dc90a1368842907d1e63c39621a3cfaf58e84969c1bd33ba0e9722ffd7e2c08e53cd85f6cca95ab9dcd6ebb23b5f9309375995c903e936c25e8297267aa8397702dbeee4c475dd12618e23e29e8f51e776b0e1002927a97c1b3e3c1345dddce5ea11d67e0bbf5d5d73fff452ed12fd581c4b83428dd91f8a81207a9e3b69dc084d53c22c49842d26f6c0654ce2fd7074b05efd9e248466a68796e2f1fb21850e7add483158e2ccc00cafca6cd5dedd3d086b8fa39aa1e20035ad087842cc94b6f4be797a51354eac40938709dc0d7396b36f77bc9fb136fabee39905f3bcf8ea11bc0a84aca2ad46c85d947db80f435aab1ea05cc5d277b4c46aac61cf4ad538383567599eedfa2c08a6af703dfac48077632390819b0a62daeb6a86c76238babcd36064e2d5e41c957ca5630b54c4b382583531c9b3811f7518b8377b9cad7c0661d0b6693812845af6856a4e72feb958bcfc131afa90e0b0446f2854bb051cc8244643bf9eb66cf27b23e577c8a2969a5d826f422b54aac5c72b13dc3c8cd92249dd5f5363072c49f6f8368ff0543650708f33b4cc3d09f43fac3227b1488db001444d966cb0d84d0d43362fa2ea3a77bc8ea041072420e6301204d8816c9c2240419d9ec992902bf18241100ed04192ac30f3ccfc4f3d69a057a8126aab98033364b7ed7a94e784546b687f518d2f5115ca73e3651afba7cb39a62fa070650118b3adb30fab33d94de7124e9cd02547eea09d75aa942b5e819d58c7b52e19592cedd4509b0d6096196e25f27cd2be081d67e32ff4d688b7fdb23b5ecd137b190446d4a1b8b30fe627f2b90c34f73bd78a7e92e512ad755e7cfed97ec8727eb2a3539eaf73ca41863e6aed39f29906b4fe7b71914b8ae9fd7d8ee4d48c71eb7effd0914b3a999c0b54e327130e9a7b186b65452aa88240030c7936558b157d6cfa2081681fe2e02be603f6609213c22df5df6365f1282c1ad7f336db9170dc0183ab0f8562bfbb5dad3b2b92c4ae4f3ac2bb6c2b73283020c5f98c65bdf33b0b742fe1604403a91b22225931a3c7b478391149528cb02f0059ec60d6c7ecddf9ed743f22b9dc2a79ac7cbe0d88b0471acee6ef0ea3a96bcecb6ab06993d48162576135e034b7a738dfa48ebad0f75cacff7f4f2bf00136ea9314ff11e63450d1b675d65ff42137113d09ce48087acac1fc88fedc0d31dd79616a71918321ab22b7fa919a2d4d94b99c65e3f5ec5a6f8480c8b1962f82422ed3e0d16c13d4d9f9e1d35054ba94cc0debc3937c455abdadd5e3a41d5ebcd737c69be18756242ba9071032ffeb66d015e80ae6cb0920076ce1529ea6a921af9082b97b9c63dd93fc9bf1b9604e62dc2518ffad18e8194f34dc7d3091c5baa5cb5282fac61de64bad2e6c08fcb0fca486fec798874895a6f5d5913fa6ab4f7a198484a85c5aad0bd382113929c766925b6d593624e2c30ba489c2f3f42da957364a7f098c3996f2bb08dffd464eb4981472a4deda3c3aa70560dcd726d25d1eb4244f53b0d37e53aae1279266abf79cb8fa0fdbd70167d8745560e0ba348bdd91f8a89bc8715f390709ac4022681fa8242d53df47f832ad28e57cedd076352d244c2b5f636e5339e847f56d47086d7a3a2f3bc0d079c1d1a7762607e94ee3ecdda17265791df563a5e086fd5a20241c29b28bd6c91dd1062432b5995277eeac8aa918a018a722f4856076474fb243c167f69556fff1ee2ea51c8f0291ba053a30cb277dda64f900e8fed19282d83d03fda5e4e5e7c63abbeca81d946ab9f9daf1dc7e7c6e2c37943a21c3d151524f69bbe634c6c218c9335ac1b8c98d43205f7ee537c724f73936f58278b6afd2eb33402052511439bc3a9336bd16f0b2d8bf9c0e48c7619b192c1f4fb677e2d4aed0a48c446e9edee9386640d4cc981decd9206275127339b56b512b52014f057302090e3ae9ff484866b42d39c0d4d870e144bad5cedcb433c45617856285cc750f3dc556d8ed7272119ab39655dc496ed33a9fe022251c3bf9ae9b103eb7fc6669e5b7dc0ffb442a183544354e544c69f2ba544bb85623c9a0b1ec98d87d95f171a303e6da066801a254044cdf0ce2925e4d2c4d77745ff2d324568d34ccbdcf9a1bc50aeaeabc7e405b4ceb259605001df19ef11f83526760ba739551f39c9de17cb2f8ff652bbe9bcda623a97a19983e80fe4f0791582d4ba69e926f3394ae2c61c398005364886331bf7f376b8d421cd4bfce302d89748fc09c022f2b4825a1416c26888dc42b31949f9ec6884de474c2364720258a42c6583b0583d11c27bb056a7db63cbb7f9c7d69a7c86f765945ebe21e2c03e112de2dbc95295cc950505031e8bdc5169d0660032a8f60715a12db1bac9ab01345b299e48466f9fd6dde6f225ef26f7779d23ed561150190582493328bb5b416029ed563ec362f83539be8f8be3c285aede4c65ba9a6dba6603717c04e84b3b6d105b5ac1b78b80a5e79fec637fcde415e96d47e95d94953d689bae702d5037ab3598be920171b14083dfe856846bc685ec22a4de5f4c3a6545ee8d1d960084d0d790b6c1ca5114ceca3b6fe1ef1ce4c22a401009817edb11110d5934ddc8e189c7daf555e6fe2d39a058c85762de5c9f15616d8181c2cb0e86dd99a5933fdf8b024c08537cea2ad18119439a51fbd318a7dbc5f85955d15786c69ddc2d52e05f0384ef5e2b78d13a9b35a25e02a27c4f85b97dc793525f703c8a77ae3a52eb21f4007c98557b0191fc9f4d17b8c8333c45d0a279a7f11c4ef0590a2a366d2b6de86ae6b0833d9a2ce4aa3eb20a0dc87e2847b540b288bec6e4cdef19bf1e2848f2fd5a468bd1905ed0e59d724b00b34d5a43b4ff7e6c63b7587a1f8fb23b5de7cbbbada44ea50a24ed47091a663701efcedb717fdba4e62eabe61148107cf61fe45bc156a3ebf7f310e3f03683ea95a37845999f7a8b40d3b2880e82a195c05d7ed55d103e3c7ca973189dd6f32958c8820bfb8ff8c9367d9e62dd020d20bf10263683d9b20d03b59335dfe911dfd78426dea819725758c1f83c691fa685af8608d19ad4719190bd99bed445974f9063412a91a46530716495e0c8f5351f581f191438260464380caaab4da92cb99fbc1316f7a9ebbeee2b2c505f7884ffabe705804d6c63db1b27935d42e59617469a5fab90976d0d542c1077894e665175602a82f83c37b13e02728c3d5ec27155f63d752de5fb436ed678ef6b5b61d5df2c4e291e1db30e4ffefb209edd7e3565128c90b639f6918277a75fdcbe0d6adc77c94249f0dcbd7001d4870fffb46828666e1cc37d0ee97b5f3131ddb5cab49ceac407407736a4cb295f0cc24508ea3f6b122e39dbfbb67932cadbb18b264ec13e626ff2662e59474d30b088a5a1c3ebb7b11974d7ed69b0898102497fa4d1d4df2aea09ff62f73c9dce2711de3e5393f2816ae6f5ef69d0fd075a71df7de35ea3582e971d49831cc47ad85f410d32b86608f95f15854b162986fa035a456d0fc1f91a9f9a66b30b36ea0af2e51f86e9e0697766332f8696e137529a3177d483fe53be6b775023bead56da12455136c2dde0c7b0f0d2400a8e9158d326e9678ae903622db4ab948c72bc374ca77065a9b1d6e2fe51160443a8b8ba77ed457a725ffbfcd3e01005ec92c1b4062822c59a1ae4917ca279d8850944df430784ebb9b2be5de05da6435709a5eaa467bccf1b9ecd4b044b1a1466ee087cd0dc1b4aec29eadd138dd2f58e727ddb469c0e0f34496a3f8bceb86bf617cdf40b77f7de8b3c545257ca28fc4583c698590f1cb1bc735a9995a110c0b2fc1f3cd64833cb80f4ad0599a66f6d6d82b86f5e2d6ec057f8ba691b61a6678b18265874cea1ded65d057f0edbd63e744117b8892245454c752c8beea76ae58025b59afefc93b95ef3bdd65dd388f0c754a5323b40a21116319d6e9e002b2bee316d31d0ae31c7cf65b001eae6bb1d2fdec5dafc2cc1f87ce86aacc3bf2e049236eea987a5d1657764b7ef0c2c897402a2eb7ed4f85cf2b6dcf659e0734e72e61f61b4aee62fc0a3100e4c9d72e3a44021945f89d4b1c8526c5894531cfe00b2427aa5b117901af100bee82566ce9ee3f59e512c9f0547ac0a8858b7331be91908b351880663f2ec961353885d0eaec76a4e00f59214877cc724b0122c97395172c75097d28ddb398596e7dc1cd1f89efa3c03e23a10e5565856d6737c6de67c649720b1dfb07f463bc9f4f94b2d621682d5377f60e249bfc60a27b8ce7229c70b1cabfec9c2b6f82707574ce5a2b069deddd5a2cc053bbcc037008b9a731aeac34324914470c8ee2d49f88d19a94293144d7d6d5cd2ec2048f56ba4ca26b3c8c5ee3bc5a6d69e7ed53e38f95f424bed7c90598631f4874e9ec59a2dda0b55d91aa7e1634a8b5bdcad99f5b2629326ae37ca9a62aa577b1c8bdb8499056ad02267a5838a364734edefba16817109d97d143e272e2bf6ad86c07caf33a12520e1055b935045168355b9cf9a863ad3cde275d38c248748e4b3fa5fe55380ef4549e8cdeffc5f091710c494fe579932543e2f60f53ba72a8c6a4b3d50b9bc52f361eb1b1475e9f3b2bdf1d460a66a2875f36ef8362b716fbcfddad1765ab3f527532159c5563f327c1923b6a969928568ba34ffb05c41117ba6ca7fa006de4a4f0f85ecf3dd9963724ec0f1c00ed282895a89fc73b1883b150cca55517edb7ad612beebf1da8c97493cb0c0fcb9e38fd9003b7a582b91245cc0cb3135f5006c88c4a49acd000cd57e2ec1d7d6d3fd5abc8908c3f572a550c2aa51e03f57ea8569a182ede182c88a8131cc4e01e14b3aedc1a5006cd3299846e50ab7960d43eb93093d86be8b0e60ffa77b3b95b3319c1b847188916aa95aee8f578e48615c1808aa006a9b04fa61b69674e7c69f799b51b93b1873e8299597511560bab206118c74965f504fe85caf57acea8e48a34ec13f663844fefcaa7067b3058dd3c9bf2823cb118118046477aec323b9f1602c4ff7605ab8ff69a945f90dab3d01e67ce138aa64e7d64571d9de3ce8c6f779297260c57800f57d01f32be1eeaad6e397cb81ec160459d589ba52d6fce93f89a2a47d4fd4d3292438d1e0f797f860f36c315f63b41fc830434807cbecc8f00b439817a5c0aafcbf1afd37038abcd844d5571332403d7ec0941ddeeedb8f999e8e0625ae793f9dfc7f12e39f9de83613b90f21bd2d941af0fd1f349c49aa177571ac776e2019ebed8517eea2766b1fddda6a2ed8d7984830da64189bb7e70698f1cc066f9790d9524ef8fd0b82718fbef8612975017d526941e6b63bc21165e8a8be590fc0e2258cccd62a3ba113927402912ba650d4b7672d71fd64ae1dd84ab4492772b9c69f63e2c3f832cbdfc3ee96e8c82be9b224036f293fe4d01b8ffc98c37ef26c2bac86e042887a2d74ab01ba02997dd8c3c8988ed71a9524e7c7d062d736472f28a59da66a7c9f5e5e20cea83836307dd90a772cd6ada5becf3dfbf5b056ec8fa22f5ecbe0190c8ebfd01c4e557bdbf9f241e1823d26cf95fe8c2a17c4efebcfc60d92a44479f802d6378aaddbc56689e2035e752638300ac90e3ff50ecab36b05e12d4cd5ab954a701a653fcf1478efa7a03dc4a53bd8e44a18e1f3ffdda8835a71a2118c5427790cb3325d1bddbb6748ae7555de1721b299d6c5901f50a412b0a5ec78fbf66da60db59807ff420421c14e9d5212ba31db7798115881dbc25c306a01c734e046c6e945d87b877a9bf41b5461fae15e2259baf17558ff8d106eaf54034bfd36c5529820d3619e5ee52501f9299b60478bd414e147e14c9701b2641cad4edea4e1891d1b19a99fc8232b66256d0720b5be3bc0dc984dd6bf372b1fb2aa4afd95425ab82f0780dc0449bcdc70254209b3b19456b7616fe1116d3c2ce4498ac8b1a9c21ad78f27666199a196070d0de614b0bf333dda02581d8408c54fb9b892799940f71583f57e0f710fbec5ea52f58f3ef03aefb54364f7a8c5ab01c16c130bb4cbdcd923f2e04bd7cadb4a3f6ada672cdf87a4f64bc61a78dcc618e8e58173d982e4371561d39b9eee8da3f0d54aa7e93a5e94254bf781bb0e100d59371be527a0fc6518a9c2f4c7ab92b7e1e31b7673121cfbe1fac1ed02c8a65f9449a8642e59209e6e032fbfb2f40948843b654ebdce368d520b9fdeaa8044ce3d3b60a91be09d1b45a120e21c6465ab7c77d463897f067dc67ef11dd84ae5b0f895282fe390552906e1d8af7659180625528457f96f97be11556716d3384ec54812c680f04cb2c8b382ac5685c6b053d5fb4b435dc0feb4a1c23c0dd10604656e6f98c165003a032ce4a167e0fdf989372b236f1fa4a06d672121c7e5abe8ba6e7acd4684c1cd0609d8b2c48889d03a0dbbd650916d658b78deaced55f546da5b374a99c30d05e20a472d6d17a3081f1884ed2e94baf495518d55e26d08843a670af233f4634c2e4b83e88a6cdc0e10a17ca9a478e78b6d2cca09d2591a0560d62f7b4f2963c93b2df7f385a0e3ba1214d6c6c7bb63390686bc34aed137c3a1792d9d6a1beb7ef31afbf1cf8de65d11f11700e062b66bf0058a6828640b1c87f8c0d459df94ea3552b793db2bc5a29524edd5ab7326337bd1f45a1ba2a1e2755ff906a3814e92a5a8c788d1bc04338612bfe7db1afd9c0dbf5e0f617a513fd294e48255fb4423d16cec916dd963ad8c20d74102c18893fb1ab8fb02b3e657a9177657505a8b28d97263fe694867590e68c877b7041ae1de142e6a1c10e344c995da14590c4d71e31b60a6d47dbc639e053ea34cbcd8f724152bb06f11052d3d62b156776ad256c4bfa6481bddb0a4905018116a80d8ccbbfb9840dd29041f08f5ddd0011a095f6d83146bf05ea64c74b195b7e3d11a914dd48c9b7a16b545dfa0d188fe62638729ea8c28f39c97ed1c28b6a8c31217d1168292425be8ba71e765ee1f0d97791eea0f50efa26f3dc08f6582a0bb40ed8abdf23b6b324a38abb8f812abe338356d705e6d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
