<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8985938b58cf97d6a58a1857cd1e0d317479867c17c77c36ee899ba4c9c05db47170f9ca2a1168d9784c41704e67017cc1a56c2a548b68977c92a5aa5f37fe1e949e1e7de190ad584bf370d2c14cb645c9a9b663bd58f8be6b5c00caf6add1044f03fc63f4ef1664e6b9382ff4c638fbe1b0951d92ed3d9fa7f08faccdad51f7a08ef02a39dccad93ae4e7d6043dbd7f24799120b6eb82a0357d1b41c53864a8a600d6c1f632918d498b26f14fca560fbc4863e80f187433c8efbc9ba12854af962607b32a2ac1b4b06148388d31e01be0b7e240b382db042cd4bebd0611fe109c2fbd17844dd864d70599d7203d1788c449a14679b4028779355b6ceaffe4e3cef8b2f66cfc0fc8678834e92e03764b3c171301692a210c56a0536ea38271ed2b7acbd83b2774f8406ca3feecb9b9d6f247c88129bfe8125a1337aba080b1b881aee5a5a79f6d154a9fc64e2f0f3adecf7830482c56474e9d30c7a06012a90ba1fe23d3529fb3d874d7e52557a9e3f867be44d26e141e7b6e9203d836ade7037cad34d25c3be5d1a0cfd6b7c70bf316ce3627bb52dc46bb6d1bb093833f6a1abaa98dab5b0bf2eabb4afdc55f0ea5643231a9fd469955beae4c486f9b08b70df20242c2c76f74ff023cd99a051b2fc66180b01fb2c4eed7c92358c6f8c3cdb472aa99ed1bfd1dbfc37f66b5652758a100dc7849ed4cc9d381a01a8a0212ff3684feb112a14f08051fed9145bfa82b7dc1e2f2b535ede2354b0654213b3f7f78ce00d564331c2588134ccb327d52a78df1264ec1238a468c13aea2f50b0014f074e4887f07c326d008c61f86fced0847aa4931656a078b46ec1398c154ae847d7d5027c37394483e175fd8c14e78659f90104b154c5b236017787a8746e0b528487a6a5f8a5d90566e487c20a97ed91ee4b3a592244a49ef4429b55052baf6b76834675620a31e487266333cb39e61fbef3e4381e6eee1ad1dcf2bbc8e378c504da6d72297f79abd04964466148165a6434fd348c5b8e19f87d3326d9d37e73f29102474cbf4e702c8a5fd18d6c0e92cb5ebc5248fe2070104e8e8b60bd3690efeb1f20c9b760fb6ff59a3ec5b62f0b2096b3b41d1873a8df6971152ec654fc60851aef19d42f0447083c241f8a4ce55e440daa5808adf1b7d191e2ad2ac1a1492288d663c6f73cf28cdf73893161b78494b4062a1605875b3772820b8b0f2141e999e574a2a9fc407e89a965a9d71c28877dadb805994d8a7d3e9468e4d8b86ee239c5052064c5968ca06657bc347fc3a00c8a5c5070ec8423dfe0d42938f4265170411c717443d2f11ec50089ae15dafbbe70ef706efeba41381947a9ceb0cb98650f2ff01efdbeef9e70beb39981586d6e39067a11eeacd7a4a9e8f7894cebb29e0235880f3364fd8bdaf35a1fdd11315e2c8a300d00514588a7e274f4e0125e0bcb462ff4396ff7c1602f80e673517bc4c123857a05fca10c521d4708336331a145a9a56281af35641d14b901d7b27a4843b64b1581624de791366dc7828e774daa8cb311cd2cde549950c0e67334707d052ea8432ffa5d1348ff63e727579229c923601375e8981a056fdb4bc1e969b39fa025fca791dc64960394130591658453f68e27b11b8835689ee0a176b554098bc27e55dd0e8a903d1ed2ff3b365af6e09bc7901e1e1bb8bdada8fa299f6c12a082e4d134455621439c2624b7e3cd8649cc85605c2522f4c365a0d87a5efb741b45eef2dfbf3eb5c0493ec590595ae6048fb41da0541015f618ab6f391180f63154903f6819080e23f614f308372e6813e90a515c6e0786d6b5db8b4044748df8d978599f97dddbb011246eaa18d9d48c7b4a93e79cd7b7436a5cc6e0133474a81b86b4d69d1d14c46df20bc2527b7e9102cc4f408e106f28f8e02310c83039fd9c3538d0f811e1397f3e2895e14e76d93120fb8e4fafc242a524c3b819a9cc343aa31b6562168dcdbe5030fb0b970076f6d7c85f3fa6a12e955cae7a58b57cb7956169d9c31ceb4aec2f536e2384d29ac29959756fb2a28dca43de4d7223dba0f6fe5adc5bdc360bb1665b8a151ee3cdc5185bd38bcda16bc140e4d464212bebd0a336338acb07311a20ac5e63d1e33d2a300e096c492c872c77464c5e325d071b98651fb117f7bc12c4e0276cc617d41391d2b1750615967c71b1e434deaf60fe03e257654d43b6e48602d8ce0e147a7a49c7e936962aef391c3cf324e9e8b08e93079e1ef756fbc35df3445f601e82a2099e3cd6d2522a60259bf7b12c61cfc7cb4cb9d13f703044246404152fcfd82153611fa537987058f0e1e5762b97adab2d9740edcd42fd02ea828ac48a89f46d715758aa51a0c3ddab262bd1998ccaeb3c0cec76860ef6ab959f0ee140f9237248ab956606a4bc5abdd64b17ca5575f5bed5707189c74892b3534dc4ab030b8260f10db7013b5dd1575e7f8021edf6ec9b1ca309fab4c0132e91fb60368e2171533c309f53dcd630407a5202c53e53f7dac9063e99612f524c5be7a1b2fb2b53d0c2aa3c06985798282602155ef97f558c3be20a3ca76314f4e85ed6ee57a90e767017aa4e2def9b1f580371b1245b949bd75e5f5e8b74416b487979c396f8fbba2073c46633ba708ac3b0dd0c0c5b3bc3ec07d524de5a0d0c0e981c5a6af3c07159eda194e3b6196b8f7c7a524db9ece596536d9bacc7f1369f612447727eced35be6dafb0ae1df788210c30905c40f39e4884b56b4b711127a555504a5b8d9d0802eb3a6cae33baa8e43f40c4a67b4e88eb0b102b8cc8618b9847d7bdfafb32043a343f6e6273b2c979d3e37b9b7568eda4c49dffa86821f830a2b57269b6523c4f3c7c566f6cfab856087bd5e927781f0138bcc508847fad8c9909dc1f5ef8637895d014e776495ad4b1624ef9900e65b8d3619f8faf87ce991b813ca21365e3f74ff15a91f68bab5880e518403cf0f21c083f08ffd18470f126ced8fe810d8e6fc70ec43efb8fc59242f4e838a75c2d3862255761b991a0ac773a0d37878ab0d0e9f6a8a8210b150a0f474094ce97a93cb8eb7272a18d5e83304cbebac60de6789feece3f91c04d1283108d30ec22aa039eba7ca96d389e6338d3fabc57a25285b2e1dc387765523bffed2381546205c623e4738f5113250ed053d5bdf0a716f9d4879949a91862f58750dcce417990e4be9aabd868a76d5b7b66a8cf0931f63b40b55efe66cca688fb1d1c594cbc8181e15e3dd5fafcb94203a60d3d56bb0ece2fe1bf9422420d946f7475876065d8bab1e8ea399b70c2318212d83075b9a1f1344f9a27ac82ec46fe8e8e42c440a654355b63c4b404c068aefcd0d498aef5f4ca74bf79276f756b8ef8a6f5f9ada14d6c5c3e87d9c90a3e65ec95ba63e6ba9c6031cb079650030731282802ab014018a27347aa0745481770747ed53caddafa8761225ef5ff814f00909cb96dc4d0d98bfa4d590d64434915f09a1cb749f60236d524a34e87cfb11fd65e2d63b01f67d49475896ce7c6521fe219e92b029561fc6d2347b8e264feee185851a50e121ee6a9b4de44909235a930617b1df287a03d618a9a0a72adc0a28b99f995e66557dac94efdb58c4f27d29cbf993de498679b957060d6084dc33595bd89839ec7fb004d94070188b10a853fbba8824622a56608c2778dab6bc324c2d144e3d60b83c112b221a0814244189025aee696981f228357418f85e15bb6f61c9ed1abcf0bb90212f7f341f387d4d477aff67362bd790f5e558497e62ed22a485346bbb47a348e739a1d855d20f0b8f1310dc50711f189711cb12d925931e713bf0d9ec19a21f501dc3256efe333e12155cbf77b0f36634c017148f0543edb63817bc20b53e2ab6dffa476c2e7d70d2b88c61f8d79021cdffac43e9b05de0cd0981fff4d85298dc8cee36fe19f786d2896929e2e74c420ce280d180a30e9b817aa477312ea7265927d339cda14e9c26675567389706345ff85d734e73f39f410dc500892f8ea93fb770cbb17f8a944ab09980369b2c5e2972327d896b9fb84d042c0228897f265f76906192dd571fdc60c369cee451e972b694039857dcea000de5c95596cddfdcb8d3d59259e9ec561482d64fcf14dca3d8d41dabc4c1754292a56036f4c6b07ecd20275cf443e9db147fe92f512ea45b6e87d2d0ce8ae41368ded5de6d0bc6054bf84c2c63bbcbcc2f4b26750e51ee9dbfe4978967b6a190ddb780246eb39b35861bbbad6a5e58e467b6a285e6c07680f71d842a7a9c8131bbb3e149e949219433f7ff4935b7bf822f58c42944c9b74c0f947fb44b0c82e8a9c6d3e8329a22df95ed2b423756f717cbb24c100164239091e2dbe2ff912f17794807f3e2f02d4dcc67f43702395e82a10aa558c9ff5a44729f2348c740b3559308207323578fe7cbabc56e7a064d092e98c0adc1049a43d99c9712773be1c52cbaf9aad163cb8cf8c84f99456f7bd909b1613d39318c3bf555b5d046464c994b6905e7ed6b6a0d014590643020bc9d8190c83f84211a2e8425099969782ab4d64e906b3c1d8319443283ff53e87ceb70b57dd2b23f4eeab43601b1bddd5260effe231a16e9387d7c650d6f969c85e928c3f3c6792533d1fc3107a7c89c1501cf6602681542d48da8cd33b44a3c9021043790c18372994653da4c3d39e357b650dbe0b6ce62aeee177257b62ce65520c67e9892c6bdf0c3c730ad4c8d2248d810f8533ae37f74170474843adff8064b366fc3841bd3571489b0edbeacf50c0c8b76b35986789a33b70b2421afc1864cc86316888ddc06a4d7d725fce253515551fa672591e97740627ad42d4b48ca7fbde24a234e6f95c4093d906a21512646d0718fa5d347343ba397ff90e484576c29fb23ea87c047f38dd7f72d72a6a88b597fc6b15a4a93791a2ee424d5a9dfc869bddc53fee63827645d8b52de23b0bb5e11754879225e65b24d8af615e82d6169b86b7322e9421e17d9168c264d4209f026e14fe8fb90a51dcea4cbc1e1c20e72b5876b636373aca27a5bd33ff34303f5f3c78cd47240301fba343e0385a36d5e5d1062e29660e4a21e8a8ceaf660336559baa5a117d21651ecc3731ff9c6f2c6c579af35222e912ceea0ce27ff443b38a0e02743c6dd0c1d32f2ba25282a32b21c806303ede79f5425879350349405b0eb25c4e03c4be5b459065a919f48daf7509248469be46f715e66c710036d38413f56f8c55d02390b83567db04f1b5ad0782f74c0b85e0bfbb2906a0fa12631fbb15d619e19039fcabc73b8cca43238c48d3e20d1c5f79e2a9b31815ff73dcd2de1da344b83497f8092156f9f3cb490359fd74b37ee5dbefe90798636250dce02b37cc616f8886c9b2902ee39218f23fde75b4ac68fdc5462bc58aba421b5a9f89127bdb2e8e4a30b382e966a55b5c079a84e6105db809d28b977094fac4ea65de1554c9402cdadd43687dca04040c2bd933edd2b142d838b12cfffb9d2cf3834cef51993b532cb61a76d809b0e8092a47db19edf6e9179fed1f4015094b6fef0d2f878d15f19d7af70f3bb58eca38b2b91d4c0885c013f9cd7ea1d961a9fb142a7827b562b3b2b9f5210da2620e148c1f0b396616466eac044ebfee7371dbf75d137d3ab7c835fa0d0bd2f51de0ef1f277a4f8acb2b9aa969623d3232e7c41a8e1b669d9badf54f2f39c0de15f4cbdb898d4476b08baa6a162d9a7c2613f0e9bca8de131aacd806819695d23421f1715499f553bfa8c909068dc18d4aacd79a71bf37571aa0e8c7243a1b6a31084f0f1d4808077db654b21efec991dd393e9e36c9ac6cc2084ac291688ced3badcaf488a28cb6490b055c6b9dd7e783c96df71309fc085f37635950f275119602319e533e4332fbc1acf74501044c1cb95a0459ba7b21d16dbbadb0d633ed516d8adc96219afad2ec86305b53d500cc1b47c372297a9afca1f1fe81fc6e7e7d0c3344ee0627e5c048c7d0a253ba4b4cc618d6018bec96622e44f3ec426408da722de920116376c8c045cfe313bac606cb4523cc17cc3e151138bcc848f0b29b90850ae9f5e8ba336c56925f75d236ff7fb8c79ce5e84d0c89282ab8f96586f0d56a11173ddc2eefb905c17e7d9ee76910e76d0097b68923924c1dfbc0abb37f6e30ce9fa305fca859521169ca6f3e7632da2629ae63c6fe1061f4e0cc19385470fb5e35f9254689be12e5a3ef9767ccac907229cec6e7175868f7101c92a08dd90478deb79ebd1e09546d91170316efb3c4d41d54e5da148f500f6039a40abc77c482a091742c1887c1c176d633049e93faa076b8e607bafdb3a5a8a4f40766bb2ddb12fc5732607d804d92da253dd2ac62f8fda7abd6a2eaa85fbadfa5372bef27a242e1372835a2c0f73b4f200ae61a0d9e5a05dd934bbc6038e968a882a231a84e085575c7b958fef7c17bffa09e5ee182d5b99fcb6572e0fd771cbe57c1cb1692f856f74edb58753fa1cdc3e1cba7f0ca84045ca7834c61fc43e494c8b490ee8ebb5a101f9028a3acc6353d641c3c39967233840baf5c2717c2e75e024d4a1a0e8c277c6c842deee750597d07c7ac32847c8d102280ae928bb031e56d803ec323106f85b0f7d006dda01a674c5bd84af0a094f4f17ee0f403d22aa2feb8224709868d08e95c214e40867c371857b02229cebaf435d93fe52d30ccfc0b422c510c302a015d4d1fec64c9acf88828fa19dc0d693710b99eeeea853fd6c350c489d1e4170bd4f187ab37753d56c539644cc432aac5833a79b065df5fd5e49273b63b77379cf5ca5ac26a6c8022dd7c9086ee09d567bf71953fcd8a4dc1cf8805e9ba13e8a1f7ba798afe16d6bce61e1fb09230a6a23b14e42f50e9531ccb5aa3dcf9ffa942ea8c791dad3b28a10ded6bae6c920299ca7f47029f5acccbace61f467ae010e77131717801f5eb666105a9f88b2cc03874a8e09c8866015f479e40ed5c4e872e8be6a7d66e84623657bcda9ac254a34c36fa374442c618e30c65f9dc31babdae87883fa3d61a91115409cf59d2b8695300443bdbfd2f76373991e11f8de7b9d30ec570e9c28e15c7b65e82e7df24ef9715f36278717f0867d48cff25660b9df50f31a3902ed410990f56e491d8815fff8431362ab79cccf31951071f2c236c7820c81574766a4a31b9e84e9365365b43d03f0fe621a92ce60ad6946a90040eabe232b96d29e3b8514175348abfc05c7aa7c5b30a8ae77b54e2ad2cbc699426802c5f5208251705f8b2279967a724c45dc19ef3d1862ad3cf2bf415c9c982b1a05dac99992a4e16b9179a36c1f02f434fbd30df0fd29708957d2c2fb1afc46cbb4c584ff28d4cce18d86706d1ac863a493fe6e73c51224688dc80a4587136760deea84c7d521da3d1112a6007630a928e18cfc4bfa2b5b6491c0a6e6a4b1530f516cccb87dc24e3b1837a8d95ca02f8f0332c430042d45072a25cfe8cc9bb29273b47a4f0aae6116eed85b8a7de3807f1550a4fb7a43b5c794ebf930b65af45ac61fc354d55e37a000c002bf48fb614e707a0d9b93f3158aaadd7b9651ea58a1f84202aaaea7f38a9b94e6035cc898bae62491b072fc73f4edc8e93e080c63db2852b14eca7494cbdfcc811635862d87f133b336ac1e6150ee4e05eda5f89ea9477873594193eba414f3df401c42fff1b1ddd65f79b61df2ee735eb2b83b6de7373a486b5282a588b41756c6c0660bd78bf9b402be499c6d039385ff09d13db749b10870ff81bc6d0a9345a6a3c6397ac181bdf34cafbbd56f2736f7a295c9453e41fb8fce8f649e7114259df324122cb59e11745b0aee09959d8739773e11253ae3f7e8166b4f76ae0f71fc9fa347368f5145e42106c954af7f4e031aff954e178d615d33bcea02eefc029a2703625758b8885e514209bcebc68a6d9afd60534106466ce0db2424ead65492d620c843f77ab9a5832334e860b402647f4ab80fdf433edf85caeb9489ab3bccdae437445cc051cf218a2a6b97a2e8afe60389317887bddbdb1df740c9a1b8edfc933d1fa0e9a482ed470b76172168d520105e09851cbd72171accb98404b54e2800b32e5630e9a720fe2a66b1ecb2b5c0ca45323f578de154ff2c95ac42bbdeb971ed9e2a4c013d77e76dd9d3040af511de4944d41b0885a03925ad6c3c8c4b9fbcf6580db2a4554be26efe44c66bd69542fc6f9081ff0c3f6cf4591a03debefc37722cfda9f67399883968cba2d6293ac159882241e62ffca46e84cd0d7274152dc2200cac9348503edc73bd535d36ff36a55ec6f2de36b637de1623d6d7f32e6aa0a47e28811c5dd4be6bb979bcc7d3bca85fb1280a33d00631d7cfa2e413fae3987a466f7b4932c268a2fadbc89abddc9777ddf39c04cebe039a219f38c2865bf68e2b6a1d89d78cbadd0b76df866f20b424192e66ed8d9156ccee3daafed0ffb2854842dd6beb5b14c1487f649076b31245ec25e07dcf4ba698a34910067393a49ec7888c559c734ba95dab9f39f8b0d477dfa7058831ef6322defa41585f1150fe06893e822211335d7f63a951109f39b9aa2621add59c5cb611334cc2963741c3bd4ae8bf719d746fdb49e1a24ba8e057e096ea112a4f36913a488728f94fbd296ec5252e005c60b0ba7ca85a5b1b3d78df26f78ca297e096004aed538f29e625ce2cadfc4a120dea1ed6df2d9982e0ffc78333de92587ee2d3689a25b9f11748eead2893360a6634998999baf4705fd765e848021cf57c99c94746d9453eb579ea57ffa0bd5dff34d1180fae669c6b158547180f0a007ddbeeb3bbe7be53877bdaefbfb01d1e48e32c77f6254c9e0c07a6ba0d09cd215c66b13b0db56c750ea6a37a0363c88f65b9085061f561354ab77a6a2bc922fad7423ea54e3bc6f499546fc53500c302b4f7c0bd61ce92132d31f5c961b3c20510a1defb7674634bae8e619dfa07520b1cf3f7484bd68fd3ab7dad6d350c75da3423c5d6f8bb559c0017c26787905117ddbeb67e619cfc094b92c809b810eb5e52dc2b236471ae81ca759f87f2d93b6e47725c1452d384cc1f4c5b78be78f801cb5c1760ea04a3083d7082f6e77e1330d6942f1fbf16288c317f6968fd83663923424e11bf2820dddc0fbab0c5a0f8cd57e9172efd5e3e52a4b64e21afb440dc24197cd2a5ce38b8cc55a732ebeaafebe3fb4a3b0f130a2b2c703c04d37fa240f91fad8f46b1c44223f20daf5ead72d11519e6eea34289329216f53cde6d24c894311a8afa3ee9440c993f93414d3259b1f29cc268c95609509599243e3a9fcb58e70eff9cdf7e7417244d1022c7cbbd094178a8abbff77b4ee5387babd60aeeb85741bcbbbe1aeffd48c1cf4b635b68a228fc4f87c3879ff18392a7db701244fc93c7edbf16b79dda4ed7d12aa98b490bbcfccfd6011f1e6057aa3ae28a836f0e616279e8c8baf04a4a38f2f0cf867dbdc941608bf84353349c69548e51b7dea38adb93a56f8a5882a7beff098c59306f97d66b49afaa07902d8f7b261b73ddcabb740ab363d405ab945fbfffc6487d2bec01f23d9cd202c25bc9ff295e7baec0d36680a95a6be2cd4c64c2bc7516023dc8ed7fb93ffc60bcf0f4ae3e340f791fdf95276278ef3cd0e2a228eadadae9dbc62e29245f108b932cc14effb57b12ad8adb0080db86da27435b563b2d462d70527a5a8b97b9eb82562a4c38d0572e53e4290ce46af1ff82cb3761b8ab7b8ed69a6920c9f75aafaccfd10536635d7fc9c18225d0066adecc7ccd02258c95b340dfae5ede29e0a4d98075efa4f5c48782459352bce04ad6be2b00e3273dfed462480f39ea6fc3387898e82758e9b6d9be20eb65c25440acfa4c84bcc8b6f4317f673879e6022ea2719912a30cc81cca565dcd752b401199c648f5309fedf925c31b05b0fcc21aba654dfca7f2a559693d027158c7000c7aa7f863ec8cae475d0f9c79886a81d33b32f77ceb307259370c536eabb5ddeb2d0aab0c95b11242810715d55fe376377a8baeea55b3e53a13b283e8bfb05869320c6e94fb38c49bfd703803b9fae47d6f447ed6509020412140eb99d9133a54392ac749a8e1a7bf18a9aa94c6659e1b786fd610da15672ea3106d46d8e0d67ef945e522783f83e278855768bcf9617723962383b0c73af47b15d13a85f7040ef6493112e98ea0c2096ef66a391f3622226e100481e63332fa0d9e9fd7c2f01a7947929fce5ba2a971fa9843ddf153890da73761fa1b3a355597e72e63b34da31d259b8a6d9bd9f2f8ea6b4f5d60aeb3dd9b8bc6aa6a74d19782c9db4feec8a21b875a13829fa435cf77b89b5cc785262b371ecd258db7434ff7249878a07dfab91ffe2396f4b7c360b569eeefb5bc31bfba58378d1d80be103844234d8d861eae2ef5bcd3102ad940d632396b7a5fd60b456841d4fd6034078790eb63ef9806c9e93792c41d16ead05d99d63f60027f45b7116a9c301b0324c66b81abfcbdcf73ebb862208bcef0bf984657f90a3d8ac7faa52c19bf072373dfe67db648636daaa9f91d78be08b4204845138f5503402cea3d0666360fc84af645f0080e7164f1fe97877ae020da8e1b98f45cc205a58aa9849c513672b417ff68aba123c31679c919f80d251c4b370335786f87885458694a1145457fdf4388dec6ed9b38c21ef7d4fc7b92dd798c4b2cb2606f7865827a16b4a7899a7063976eb6965ce5a547a0977526b556cc3a371bf3dfa251722e37e3568f2ed1b00d3140269a21f31805188894c41f7f6544b24167bc517a620a34e6769cf000c311357a8b1fb75627fc47aa0ead3c0e36a5876edfea79eb0c201f5d8a7af3944739d0109e96a44b486e8814ee1c1ebbfb59622ec7816ce73844df1ffd3da8d8c08c945be6dd2df29e82a34b39483065e3b9536f985322973102f5a3e437d343af83c9cb596f12249a2dc8739f8243fa13b15531746526dcaaeb77bff9f13f8d8f946b4de5f6ae1963354bbbb408dde9c9a004bf1ecd35819d50654b1d07ac38ee9bc3659a7982f256b19c409e4cb831b375898cf728f92ebbb6d0365aabcfc11e9bf94610fc46fd6eb0c4ff5a8ee7c9439845d9a50c1cb509591dec5fdc7d977d3a81a150f9a821ed8fa63733b0e059ab3014b0213c0b4b108e4a23060c2d63e6d3d287583193ab3ed0614d0cb46a5c4c1a4cde585ec5edb5a4e5cb62bab7e6db68a75b8fcdbbcc175ca85bae524251d8fd252929169a4434ddbd954ba82bc8a4453e36577e09b9db311feae76c5e1dff9d0ef5af0735ffb613d6713ceeebedf3346af06110e9c3fa7c4bbbdf680d679bf081e35e7c48c7c75cd732f0e1275e8702e5a63cd88c653682e3a96a2d08a219147ebe22160575544a40cc583bee785388acbbd89e9e1f59540f053db873962e912d4d855529f0a3eb89acafe77ae3a5f2ba3323a2eaf8b15a2775b9006e7e546cc54f9e13a8a5f958cf50c39a3091a1ec72d01f4b5da4f6b0956685210a0a961ce8c5c8b1a45bf28df24e2c01820698460245144acd6a249329b5e4b63d26205b024874abe93632d7d1a831945f2f2f9666e4fc155abdac83d2040f671fb3f68f3deb583b63033ae083e0c0925f1b3f0e83741def7290bc46c949ef39463cb1755edc947045b5b89d4e72da28b2651fb74c6fe5fa0096c1952ba2d50a4b483a9de000b81c73c59c9f3cae4d1b6113d4bba1530a33964ef9d7448a7264f9ad16d074ec19830cd14b1570e3eddfe27fe4f441e13fdb33780b7019bb458a3e09d508562963ae7df3bd3fc9ea030a73af06f8517aacd42e0a33f8a14d8b68cd9665f3a8d56b941a4bd454cd5fb638adf6b4a8021bab24bca0ffbf5e196ece6726397cbebdf24596eb4fccc3c122abdfd29105969949eaff92710a302633d2aafaea7f3c36faf785134b98b9b7b7943e94ab04d4544da7d378f0e11eae0b9fe3dc7136ca37b65814e43fa2d98c320d964b52554c80d83e0db06067450d1fb28260df08c9f6950af9d9cc73b7cf9c038bd1759af43d4fdd227fe5b85cbf7e1c0309835e9c8c0be4909a6aa3466975f1062043ce6093726a22737e83a25410678aa121bf809caf1a70e0f7152c998e698ddce83507152e860c8c0d99b59d3e6a2add4ccc560c526a203f8c467b089de6d904cde2f372e10f82a40ee12163b69f79e020282e006a16f3c75a16434b404c7023d35affd213ecf8a873c556ff7a18f526f1cc5eb510e27fe07a17bd8459de9df8b082d121745f248a060f2ecea6c38a0e7c3221a26a1faf5a65c14be87dd81bb677c07d736f364456315561307dcc65bf6f6d89afc5e767ac3f67b10375244b0c9859d2d47a39a475b66398fb2052f74c90c16f1a351d35952fb4b8d6ca0011f2e2b34f26f429d6e5c173f4972a481689d788f2e7cbf943d03fc9de282ce5771ba4b898863388e1fa582706595b275ee6339584b3640044ea10590eee9f0b9388823623a032643f71037f5aad9bbb7b6841de5650d382cc098927b4a5e218f749d45b595c24377861b4ef6a900ac0580363849ccd999a4d9a659b0b97a4cb3a0adaf4f121f2a7914d510a67ac60fd7f1d200e550d23c98deb94ef031f70c630cce3572fb7263399f85236923ea842eabd8506a5951a4a82e07e4dddb4a31d902e0b72a57dbf4f3b6427bf933da4680e72f7f60fce77516b91aa046f8a85211c214a4879bd54cffe27ee24f7bb448f015f1983aa695d1b7215bd6512e49a24d3fc342af0e82cd09519ab622b35f6c426af7cbc7894398da6a3de3ebfac9a5100f3e9cc7ec9f7ca1109ae2198bff5d5879275ed18cfd2290ef3bebe4130fc67a11c582262c2375fd1ba6b3864af0931ec50ebdee0cccdb621aacc859892baab2c82d8ddaf07a5aa30d3ca921fa603922ffe9fa6d3efaab88ad51d594a4717ca558d182a2f75201f75fceb80a2d8996f73e3ac22cf51d3b251e1bf0229f080630044e7094a5e39f1a3154577394998145553c4d8465972e5e04e25e2265fb6f39268d711c010150d4ab1b9d72b468485be69d9aa650110e4f159bf1f80f009e93f4d15d6a8f7e240ecce55d9881c91a627c7906621614424261aa128f8bc2f45ffb215808670a637befeec5b94ff42ad30afc8d1e7c9f79e62c413225d734d33de49e8cb43de4ae54d92f4a2ef88b7871b459bbf17a6918138affb4d356652a14363d3bb6a6eaebd9fd41126308eb8a165efc77d8be384d00b6afc0a5bc467c11a9dedad12ddca4a5adbb03cd14db0bb38b875deee68ff826e53d8ca23e893d016c7aa9ca17bc286416a080613e9c0317083b41d26124ea5f554b9c35ad5990f57d5ea6ae454ea41cf016caa5dc5b37d61d6c64860c49bce3ce6b5ac71e9dfef8e766c28005070273fabe9ee7af576a39a27f5e33c1723291a6f2531e09c0bc9e8347ccbf09d58adacaee9e1fe74f0ac199f846ac03de97ab4e174fe1775b0091ec1b033d67832c99e56af1e1cf39ac7a8b6517c6115a99331f34bc48056f03712d90f67d9aa6a62636bbb20c70bf1f7ab45f652657d851521a647d1302f115ffa316e649270f03f86d4197dac19f085d0248e0e53065a145c52046f26e712c02b8805606a8035cb348e4c812dd0c872e253f8f8e7d54251fe1fef19f9f7ff7ab46643a11c024004258766afbf5f246f0cd6afa6a900d21e47c2e8c49a002b8b48c1f5f9d055d418db7e9b3d48e1cd91ea9a305875f23f8be5a1b27c51f8b797ec1ea638d3e9dee4898d98c3b40cdcee4e88bd2bd208dd6ab22374b96cad4db7920b9324f7a6f8ce7c29f539a03a05431ee47aca55df53af5612d1af9c98279c59ef34f03764ddb57f01f464599febf767804b7af671e2a739b3d54debb3117c6a5165fc43c61c608e2b77b00062ee64a2bb584001872287e9c816e08efeae5fc3de81643117db27fd415a010c5e59ceca41d5467fda2a112e153c6179c6cee9e63c2538c2a0e0e6744bf2c86f206445571dff57d86a106ca33da21b09062377d1831ed2cb8c0d04e2852c1059c1a14bf8709e616c411f8e92ff324f294eb1eee41324aee8d71f7b80f6b6d39c4f7a55ef1bdba1cd6b6def60e7d9a0295aeccb7977b755a5d90a7f81eef76d3b3942ebe7f1ed3fcc698547e865bdaf09a8b306055a61275941ea87e95d44628f63833da93e58f113d97e128c74d1889d016e90c0e70e437e1b7678ea22ce5df6084037b8a33e05508e90db130f18aaa15ccedb11a2e13d8c436b4d9f3fdd67cc2632e03b9fca8213a2357250d4deaa829f9c9382d1fbb294c2c4a3688f0e27b6c8e769e95784482c8545ad1c979e05b353b30b8fe69aacbcd85496f8181915bd1646ba90d8888374a30f152222514740152c0dc9606e584b5153e669138b4c2664913f0a57162aa6295993f63daccce84969b3c6efb8f3a46cbec34b134f5f2bf552c9b568360e3051767ae07e6940f66127a07a5cfc50b6200b2bd491858a66661d2484be6328bd401131e815644b6bb5e4eddc571e0de8662f2e2939ec7b539076171f5718673d52c3e7403ac691835baa3eb9e08050c318667010ff334dcb577dc6916998fba22a372a81a1c4a0e253a8c305d9c6c60f4a83a7798dc3e9ef085f130c193d4905db59df9d7fd879ab3fdd17ac48d6f76cf8315e525d2524eba426717928deb2c53382a8efb9e0713ae4dabd5ffda3a8f6de405cbab2b608f0ab4a9a814a8cedbbf117caec88068fe029f9c4ba0248b37023e7ca6255104f6377d3238fd0622327f531d288856ef9fe4a6a8cb826b0d4c2faff33af7b8f939a52edc1ecbc1ac2ecc0b5f1c657d57f7a4c5a3cb8413febd23c9079ccae0f9575827079ceb67674c5d1779db76533e738bc97d2e52959efc3dd202cca7e60c9158bdbd399c734fa54515cf850c97f18046f36c2c9bb809b622a9331debd880f522ed8f3c11bc606e606c38de38277c45ba89be7f6b7fe88121c5ac34d7199eba674a4b75f5760745797194a3152feb4b0c1c2d244b4eefa906c8fdb2e167390bba24b99081afa0b101bf2af0e6ed6662a733aa77738acdd31d7128a0d36bc3e4229765e63c1553c22ded3675abc474780b2336c7166bb795c2f480c10e3951d2285854b8a042fd2b93e794f27e645056c81b53a7f87ff39173b73d851bea0921b1a9a4dba40c47eaa7ac06a0f08f3cb619ac41019de82efe58b8571b4febdf73aa0490bb5e44ffed8ce11a29996f92a436b8a64c703879878a7c49ccbd8428842e1878a50e10645a312e3b0b2a5abbc572baae20dfc867e6bc3339b58f88167ca07eb478e54efc8d0ccdffcab7c030bfd12720bd99c45efcb4de8fdb02e205ae97ca744231cfa1bbc5815b3d3ffedd618b05a2b8e545d656d5f2798fd5d01645a10410b0c95cf1df02da034a4ff32e62c6541cbfc42868d44763141a29b88c6883c3345fedc63c624f19baec3a8467e901ffcb0dbc576bd2c4a896b469aa59c491ad8425f65c51cab9d473f8e451b2fbfd14e150e8f0bc8087547c7170fb8cf263935a73e95e6da601f5e200be2f77dd014251091099e19f06169f9bd65b93eb3b168a40b30b2a5e33ee75bc6f5d2d05fbfe870fce7435866fc7fa06f76322098e37bfa45bde9d8d6296c5a6d91be21b0efa6a7ed60a7a27a9893a062063d45995978a7cbab6a26b1ca0a00b8e714de9e3b9cd283b16a80e9bd5c0bd45a94b883924773b081808a3651889856999182e468f2fa886e6cb76250993fd2eaca20f92c64f123805d759e2f22a5caa6d249130968699d1e1ba7c4af0ab47f395ff0d51c638a096a845059c6f27574692eba09199a175e0b61c72968fe0a9d09802af86362842d403240d6518a4086eb504a9b1c2b3cf9e570b492baeb2c8583b3c0f0c356acb89eef514b209e57caa48b4f992ef5eeec029ef54c69358f5c274a31c628408d966f3e1adf5140b861f80f5aebf2c54130b74390fefd1c69993b02f466a5146044d69712a5faedfc005d4df02841b477b43e9f98aa23db9a85ac7d204738484063dfb1fb58231d8df86c349c91d3dd40e4693f36ea131c1519589359d943b128255acd45ebd7b664b4fc3c242b084fc7458dc4547199ce89220150620a1c4020fcea2fc629bc057da32538950809e035bb91649d06d32321fcb6c5a012249f3e99f1e71096cdf6203e4f042d5a16ff721b86695b816b28f74fe1ae9ff1d6cdbc18dcc905ca3891b1a802fccf255cfb3cd44c11ffcda5750d7d2c63d5998cdd5b460f8cd4c524ddc34b0a687499ea89424d8ab5df5cd78bd1bcf25db8c7681bf18291763e8218a54a75929c9b083425d846bf65ce12c1aa241b42c22bbae97b5f82db125fe1ced8b0a53cb517922ebc44e4f543c6dd7994e2726bca84821a428a9860e27778e177c2d2d90d3b7bc525567f9ea60b8f178d9332f63869f7275c25c0792fee8070ec5f5e60864034a7cdafe216a777c7e44676862a6fc9a0e696472e6936a6df0f8caf0814da5eb9cd5f52d1b17e9f40e55310895a016ee09c00cf259aceefc46f58d19094f55b8b2a404facc27403d1047fd6af9052eb8c580b5763e28d4e572e0ba329f1d5f298c3d6602000b96023e6ee22577b01b3c65d6c3ad6ef712fbd56840d9f2565aec13753b825a2d1fdfb1c1f83fc7771b7f6c8a1f194541a5a1625c16c44dee6b3f9ada68a9bf14e0d5b006ae14fd02e19d311cada6ec52b7a09ff6340a4459cca22c292b85b3186fa06c7c6c81e878add46bc5e32efa6dc491e9530e5a742900c225f553f68c6bcc1df08b4619ff7e35a730b421d7c9ac288271f1f6fda91516c9757be841564b528ee017c44edbcccbc5bb8ba3269255304e979ac3e4daac3e58d96b5cf7ce08c8378f522dd3cc1969216ab76f9d318d88524dec6071f12b06345534b7dc1e7bed95a2c09aac15289ec97c4590d1f2f70cbc7bd5d69ac01ad867968fe736b4b50ba12bb7c9c3d43d3b4963760b01a884c21592591c32a0b71db1e1b593b5dbddb9722cee2c3e77e94416d611264e28365cdf94676da34e30bac9590add29be9376a7f5892869b373b91e2eff231129e05a56dad53225b0347134c8024b2fb938b11a5da9255dbe77567505bd959828f026dfceb7ce4c724432313e9b61a50ac18f9836fed158ef0b182d6efd09807db118b6aacb4206615724a07fd78b81b309bc5dd853166e457f915b704de203d516639e0d070a4ff1692cd6a3f16a6c81434b74dca5f5c1bb6dc781066f979e25f523b3fced8d140c6a9fbc8f974e6983c237d641464295d9a8715d585f1c6c08af194ee96c956c9c77106b29e5aafc65298463d01c939e75e3557bc2c2a4500f37cd54b553802adb61b589daa702d4df1accf632476d033497a59b60f12e188479f9eec1b6c5110dff5e3c92435fc7932fb282d5a9909da9f132959d848999d48a3941267c0d062d57852ee9649ae9c60c1e2ef8c9b9749f1dcee5c1757003d46201ccd97d8e051db92ea813e58198289a2085b9dfed732277e9d441bd5c2b46acd497f44b1acb6424964e11e65b54281bc08202cd29c631582d34e614f8c27fdb786aa98cda8ddaa3b59157645dcdab0d13d38d23ffd1f5a1bb2282fef6cf288c52e6ca7b0e1032a49cb7d0f449ac6448ba6f31bd38fe72525f3df05461a47b50ea856df88f0442fde46fba15b071e9dbacdf1da568d2de2ec7deab64ade57510ea55b7f5f80b8bb5177f49e3ad8b09db86693e78d0bed4a40b56d4552fa553ed5914da8b8fd0cb827312afc3caf7ba1b334d40c624ea25d952829b270f0fc564957a596263ecbcc5abdcf7a252caeb169356854cc1cf53655ed2398065ead690e7e357767275cf049eccd14c4d9c15f11eacf8cd7d007ffb31fa87c8697e0009ea932be382b9b1565be19b57f3c3deff1507c1a99a0296a6eb6c3711014f9bed6e187b5ba7f5f1cce52ff5bbd12f762522e1281ab5b9fca09b3007da282ab6c2c994dd076f6870157fb062d7c1eecae9adfd0100d922e8c37322ebd00fdd710e03365d2f16d8e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
