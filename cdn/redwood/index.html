<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16cf73894c080edb415fa5a455fcc41ff168cdd4c0a91fceff5f3f43454c9996b5b3702a5b27570ddd15b3803825176ea15274857b9895d68699e8f19bd011a19ff89c7462562d742d7f24339dfe51017d05531d5ded4ddca10e2bc6b9a14d44662df1b3390cd2147b0f32655232495a89e2efa7dae88b9a16e14b50a8ee93d0de28f1df84f175881a458c460c598834bd1659e924f6c25ea9d1c01256ad1d45c37110d4dab61e9d92afccfde59a2708100d710485953c00f00dcb589e93a02727d16a34827965041a8cbd2c91b07f6706b9fb650bce4548bdfd31621ed13968ebdd3b7ce3e1d6b9d79f6ded2b1cc0375e67fdfc9100c4163bfdea1e05b7460d8fc50192b1423315a1b2dbe409f62866869db23ca3602e07ef693b60cb57374b33c92b1c97f92cb7160509f879c20f2726cd809430ab0a0191fd60ea8285af71564ec1af578943cf1a1c041ccb3c91d61cb9f738a418820ffc281a2e92125aa1397f7d2ff97b0ebc8ced0cc73708825d5f13d2ac529c483c58981d33361d7ef9a667a1e0fac79b9acff7c623393d9539bacbdd8ee2719099bbcb2e0e827356f3473f960bcb60046257d57bd2ea046855903e9bae83df558990d0c83fdc9dc52acd20808fc9de5a96c8b959132fa5c89a6a6019eb7c2c0208d12f20cfca90ec4de9a429fd3bcc2e73100e43eb63e68041699365bd8f5988dbef40c5567413436959af9f4f232291c52a8458c88ba802f1718679a05ed11ccdcbd4a1a0fd8ce86b293ca9bdf749fc427a70d9eb12dfa99ca526150e14c5d2bdc54fda4cff3bdf7b1f52f6a405f370788e1615d897d94dc9dbc6f4fb2d86bb2b6d602bd630183a7acea51b10d4f8092e21602eaea7dab72ae0c5ce806a242b761798d231551636102f942af62a66800348be6e5b2364d9a78d3f89f25bdae1105b72bd7bc4dda43ecf48f39e301dbe1506eef1b92ad4a9cfe5ecfc1301ed84e28416ddbd53ff5d9a00437df6af5f0610bde10398377dd5ba89786715f4819eced5bdf3df69a3968d204a107ab907d060c4b17231e70ad5dd9251aa0f524146f783fbcec45b20c399c3193b3d1c2860b847e668c3080198359abc0318e4bb75ca38aa3df83e45d6975973f4e508dbf1fae0e0f140d26dda67878e87b329f2d5d3cb4b331ed2dd728c5abcd0db67aa7ec1b8a23bb04bf286cacb90df6fc40adb0d48fdbdaa086d85ce08aa20291a2efb1824f9ec417661a29c7c4ce0dff869be56a9acf882a666e4a5302b830dc40542e0d967ac6d6628c149ed69e48ac34334a1354c4a0eb62b6b98399d2bea2c7767b9c246b2ba9ed119fbff9cc55e90d212c67617a9684210459853b8706fdb208d1e08928be76f48f47725de75dd07b4a6baca46168997d83bc0f6bc985389547903581c9c1fd6f0e11a946e82689a6022873e77584539832e267d26af5dbade6b9a963151e3a0abf425f6d1e0a3fdb6bc6d7fabb08dc5202fece641d539f833de7afada7294b9708107115dbdff68efa1c9214074bdff573e8861f0e65998bf37c7af179974a75ca3a5428f08cefbec9c42c09907acb7f425e060f75ba43613518581f31e36a1efade3e7ccc4272969c7096fc52488072549170f4ca652798e0a35f6cf648a3c20a91d4939be3904b651d5a0537cb678eeed323985e3354f37c161ccb00097d3f60d8cfdc7ba34668f9a1e09b56e9bfd7b25d94cde72ec2c2b3febe17a716e08aa98d0f1cdb70e87a989e6054558e65067c299c33741f64f511c1e8293c2416f11401e4acfbb8c4c60be0e0cb5217b532fff3e71e25dfdf7d6de9496ef6f63f610e5dc0eb21b2eb140ef96197547cbb92075580cc052338b46e61d17f59672ddd08d12d21cc2a061a1a626acf8766cb65e11c735f2bad902f53831c5defc8c619da90e36280e477526e2caeee345f6ea369a7100253cf676784bb1a994a7f65172503b6dc796626f1c06dedbd96b5aa2e7b6a4c6646e7be9cf9e08bd8be21df93c1ffdce20893f8d202d48dc41c6cb796cba8244f635384218603dfab439e467aed672585abd44eb06ecf61ab99c66a9566dc3da464e929cb6f66def4fc8545672d2c22bc6981eae7a465c4558d4e0eb0e9be756bcfe44736893ba47926d536b1830c30df0ea10095a19bf12f774efa79d991de89608001afba896aa1d01aa728f3d56cd92ba6c8765d1652848ff56d5651b47b86a44a65a155892255a95def5e399cb1434bcdc3cf08c3110355cf84aacd1190203f3ea9623db4d881cc9c1a5bf4bd1767f17754e50169f2386420de14a18ab481a207a2c403ea17eb828736b824f1735bbd7777fdaeedcc87f90282a47213abe59d79664a51122c2dab1c34e0d7c27dfe69e8a335392664d27973c1007d5f9f8012edea19ccf883591a928bf55739d2636c0d93b76fb2b2f7a6f187c75fa6072278bb7a821939cf61db093945566e351e5b8ecd859b209cc816fcff1903259595756fe3a617ec641f7c473c410f757b0a82d406bbc8b6ea3f637b71c9896b8fea7676e8a2818e13ce14dd3bdf15f8c75c7ca14b00287580995f9f3e7ff07a96944218fa05220d754a628c5dd75adfd2f68db97dfea5f154736a3916db8c2fe68107f63326964d0222c8cdfbdff16213fe04c75b02e4f9a6ecf0bf2b2ec043fbf79579f7218060723369267755dbbcc40c74565a651a02f45ff13ce6b3891fb681a476843ed637a4c762c8e68db05fda4025e43ab11f9795d648f7af6653e2948668dd71ccbc3d0c2a405dedf3b6ea2509d4ef942a42053827401e1768b052e3cb0587d877da507f2bd3194e051030c1a769318f4582f92c9df6aa9ab3b822c131b8646386353a5899f3b8c0c12b01994c39f3337c21cc1d46bbc36c833b0cb968052b3e566a081cc0e3406de0b862277d781d1ae1cafaf68dd6b604449d0d5a7ae065d851482064fd769b9c852bfa06b0e567de4af808b348710b1be9cff05d53c1cbbe16b59d893a443187189bb2dfef5480e72f3ac8f805fff0ae19832cc23d9d984081b0937c064e8d435fafb0df5df45530084316442dc2ec156a2c71026ed69c81f3fdc9f4225ff258d4d3f60304c7cb9f69a6a96b80b2dee03b159c301fa3e62bfbfd4f84b20d5e420fe2bf80c634b5af0a6469953400efff05913fc95f5823d41eee02853773597bfa3d28261ce204ed6833f6bc630b95dc229d504b931ab2d66a762a8cbf415df71655e86e4b975f4210dbc8de75aa3d3d8e568d06d23e24be517e6b3cf0276f35af0adaf50b772fb8041f1047edad7ab1a4e8b2217ffe21a070ac8b0d572992676f19e22a38990be494543d2ff26dad616b83f570cdb1df07bba96ab8e89ece42efed843da49d4a90ff74dbba115726caad8882896dc45afd904c3c0a7a0d78be5c898bd3fbe2d89a0334bf5326029b3f6081f40cf60030a147871dfcfdc9a3f1023243e40381df0baa6d222bb912a5917eab7dfa46ec1e105f1ec3ca6e0aa7d73aeb6637c751b257583c7a07a740b8e4d5576341742e7e010570631883de9a588d5d2cc194470044b6a28650c5f4a2206a579014894ccd81b8dd4f7896e3ab0c31a28313954c550c5ce131cfbb78885d426d0a174d07cd601f756dcb9e3aee96db1ea73308bba86128e14a60d428e7e4d6d0ecd039989909754b8cc8e365224be88838e6384d78e6ad97580884d99a1e1abc72a49d3337b4cd6d1bfaf13e527d59da23e39e081f1d5389a494c5418c67e47013e85c56658322fb5cfc45d5e3b13c5f9a04476d076e09bda84130dad7a228235b5ec015744b38aeb0342cc689f554355800e0daedc5ad3dbba368e65ac49495e19969f62dd864d53a131dbfaf7ffd6d04c6381dcf097a8fd305c385732e144f81d8994e86f8559ff69824390194449e3b2797bdce60cfff824a9c312e055270ca8776ff37e69724b7368ad5957b8a4c001e6c4968e77ff3d6355815e48a2e3e577968a7aa0f71477b8e70f0185e030ed1d9e0d565a001ee3c7470c3149ad6e3e22cd4bdd3ff6d7e4dd18d554fc1c89a8db4c63839f04212bde180cbcfce0f5e57f2530e90dfdf209931881c8db8f7236926866ef4a77d1e2c1fcb662ef6fe0c7c694513a2ec88f9a0855c0d1df9cc717b257630bd4f0df8dd53af97356a6bcab51ca91e3f4b02bb592371b50005af8783faccdd8422b5ad59fa967acf7b5147658b3282ac70d516e2f3afe99e54c42bef0675c15c192972ae5efb586ed3eaa3daf13c7220266e8960022adf7c4a8fcfa336c67e011a96fb4a6c9c8ef99b39f99192a20cd82f6c093458244d8248ef90c060acb0ecb0f235fe84c4c1d836ed0750b7a445f4304895f16591bd1db3142888ad7e1f29fa54c9be77d73c105f05268ad028f757239b48e92426c598536d369148bddefb3382e2aaaef87dc89fd22abbd78ad5b6cfe61fcc9308dd7126ead11e2472a2e2d7f5fa918ee4e9dd1ca92443070f2646b30fd99a68f198dd5abbfe37d5c57aa609dfadb6161f538762cf328b994a6ec5dbd34dbe50551d5ca13d57e9af7f28aaf04ffea96b6becbb140db6c70badc4771b909ca21c387fba1a8bd8630f46284732e10ecf0e501a8f40888a19a8a3b9459c7ef1c5227fae811a12edd19cdf4441eafd276dd4ee6a90cc1447c74bb5be0a7e8a33ca97f306c33571c69cb21fe4cb9f60c89871821614be57859963837f0d42ef4564ff1b4d023dfbce4e6adfc979bc6361f781672e44faa446c90569cf68825bc2fd83d5d43d0e8d284f570388f19d37e9d3c14a7d655aedbb0c33e50031ec911b9d39c089e7d0d6d34302d219cecc07211f590ae320d441c8a48c229feace27265e58f3cfa6598f21bcdf3b595858f63337e4f6c311fe3b7693162c48f3fc3f8e3152704c29abe8eb95b51be31cb8a4147786228fcd2d415c63f06793d1fd8d2ab75877ed1b38f45fadd710f4303e0aaf12fd8f29ae9120a8becb90cf372dd5d57f1e4f9cbe69ae082a6ae2de6959a243f37d4b9b9630172d389bbd486c39c5663d3061082281970f66fc309e7b78e6a781ac25ca67a873ad649f8ae0cf9c5edd034d5fe3cf56a1b647a168cf1324dade86e87c040b477e8755af80753a2938b68ed0f4c9f4436e3fd5b306a2ca7351525d0670ec0416e9774984f284b7f434c62803a61ac59ba63d587de9a80746afe53f32332ed5874ce0286cc159f74b9e120200bb2d77bdc904a91bfa3b753fea99492cde845a7ad34e7025f0a974193b02c4c7312c9673a581ad350a8d4f23b6eda8de45a9ddf600fbd2227facaa953a63b763eced66ea481d51b0358942a908a724028a932a1bde72daf0ef41292a3aacdd9975e3bd3b09df28bc40ec13828b4b84352822a54dc40a11cf2c15bb120175f967018657c16e547f360de1181f401d9577259180775cdf802f2e7036c9c58b69b46d70812a7f3671d74058095b4b244a0923473a9bc593102737856f22452f28d0dbdf6902f2dd47fb06146788e9eac154167bc6cc888518adf007ab3746d467a678239e5387374888d9fa199213e8422faa6372153a65262daa2368732b71bb6a0c034dcafd28fb829b4f9cd2effeb4ad7531b11c4f58ae4378999867bc066ec6a2830eac0668b3dab16c8ea84eb73c3771d6b88efdd9a4ec9a24187bc51ad375ebae6140d6656fd30acdf0b434e52d3d97b789e693afbcc2931d8cc38308a13144d29d250b23f808009748dfa13b9bbf18fd10bb1961dbe47f9561f1afb6b8961a1fe9f8ff274e701eba0706139cc23dccb44ae57eed9def6fe761c566e939fb96589ed27fc4e6fa58f852417b59f27b0037718cba4f53cf82713a0d6e1c5455498a778a740b82c697c17c216a5e43ee0e92b491d7608695ba42e82447cf162d87e028221587eb4e46fb26d92e99420fa0a631927ded023d4d6055edd198e6b06eb3478eeeb19c41cb143f1f2eef2f64f918efeadedbbe4f8a9bdf9f20919ebda6b8a5189d302aa7822085338a642c149721956f936f4bddf6fb5a5edf6b5de0958bfa2249055b8656635709d3de6a902d60603a32d49375dec4097faf8f6ef6cd15e0abd86f9594f94faf2ba92cce0705ed44d04d25a8ced781eb68fa5f1ef9707236144df392f0d780bbe2aaa740d9bf07c03093d83bbb89a1e5ea68d42f39265e233e4941f7a0ce2bbdabb35ad56b17e36fde24f4ed9815eadf066e7e3153d0ebc1d92e378124b7af86b89371fceb08dd0952383f55d19758ddec0f76d1ae4b277681ca5ffc44b80c4491219ca5597ef3bd5fadf17a176db9ab1018e22172f5ac618aefa18ccdddf0d6cafe9d36cd9b3506d2dc15f433ff071c342fba6fd7aec0c11ff9c2f59692281051b7f7ab27ac2b79c88edb63acffe576deab89f089fe9d57027ea8495c1f6ff0fa542b65579dd1c2d27a9e042e2afd0f70775c08602cfe817b959814ce7d49f383263b6813fcf0c99bac00621a8d47ad3644c211570684a5aa38a5c533fc3e7bb53d14791ac35dde2d9b770c93ead2610ebf61a0fe1c2a3e059941905a2c401fe3e5a2eed960ac4ba4238cfe5712a05e4ce20f165fb7ad9aa9aced8ade15dc566a87a581a3477ffce7b59b22f97f5920e631e0d01737af8a3a63c40cef0787b28f5736da41195e9c06dc9c0d704f8708eef6de59db263710598a625c99767e1224d8d79c73b16f3f190af37872985188998be450d0f5d0db7f364aeddb8e0dcf50f12459a4010de9a87987b7f1e8527c9f1ff6f00adaa736ee4499d3aacd978381f02b3367f75a24c3e68317400875198e622a319dab6e976c6f0b600117a106232d2af5d471f65d6d7cb4a0c1439e2d9193def63434c00faaf3935fb123620a54d192685200cdd4b16bdabf476f42ad9a264448312ac8c687a55368d545f7016feb913edaccdf60ef8ba76eafd2c65460bdedbb81c97e2653ff4d28f0bcde7183689a0c907d1a98671c4aeb3b7eddec1a3dc699ac7b9a3bc34240970f1e0a5fd10b1002d6c893e389fcb883a3020cd90c8b1948c151e060670dcf0d0ccee859202cb1558499b0bd0eb02612a0d45082f261800a804a16957fd44eaeb2c0b25b4d11c5e4d35b1dc6298c5d81ed49d28a0e5847c68197153760d691309fbfefc5987413015eb06d8a1a0e04362fbd0e7a6f3772fc73bee78d19028f6fb2979d7e3355a37d1858466038a30243723b1504fef17f15f8cd299c1aa5b74086d1ea84ce990dca57d113e300e296a1700abe12262ff501fe1240e11d473e088e3bc0cfee7baac70e6644a09890992fc7fcd33ada4b6f46a5a37150a47cc60fa32dbdcfd902afe98e3bd126913a7d691156232f0c21ef823a9e400c6567d0b06bc7bbb42694033978e93c16209910f67882d7b0476657c238991f4e80f86db4080ce57f75c7bad0c481829e4cee158cd442ab89b807f3307bdaf0512c7f95dd694581805b5b26d2fc22c1a1d6d74c6eb382e9d58c274dcd4860f89a5d1ee0494d1d3b2cf1048c1d3498873a14b307d15a33fec095b57473216470c73533b4432d0bbdc8f2070de0338a33e5723b298440ddff5d202034222bf74919d463692920d3c0f4b213f4180f8b64e122fdb6c65624d29dfc4294342cc5b260b43c89cff4f770c487c56de7df1698897dbd8bf70b84f98910964d4d5439c03708f8862e24db6e9174f6c67414663c403a991c332a1828c0702de90959d2b1397e1d4f1245cedceb0187a812cfa27baa1b1a706380b3709eb464beb9da54e887b7be9854b44785754d3f8cf2033ca69875866cdb4dd2d26885b48d06ce6ca9d71865be812f8f6bbe6f9754d710fd8d0749b6f229fc929d6ce1e2bd69c9b846f6923276a0b0f1b89fef4b805aae79337a18d0b3529f82d2eab92ec2c55ba83bb1f98716910aedc6546ae75edf1d3f11f22a2e8d226ce58af7c84b66c5071acfab2cc66d6761d9316b477b150b57f67826612756a766d57312a0727736dfd67a57fb65b7f61439859d55499a6402d6141d997035bd418ed92e6845dec1dca804cb51f8b5675679f77422e1671e39dc883061f1568da19627dc4e13fb4667df364e2356769f61849bb49679083d3ff79d84dbde3a7548d6afcdafa01576f16712bf20958304e9a8769101e8313fce18f82b508199ac3709844920e8bb10c17eb6f5473204bbc5013526fcc494ea13e3cf178be7018219b50c5554013d44d4b39a56c0f961d0b3a5ecd5ba01a4f88e43173ce75b01a933b8b2d13e19a6b06825a8e2ad78521ff2f9bac9cbfb42f19311a1aa5d1607a46368598f9ba3cdfad96a6148be04a1a2a2be89377dbb50f07cc931677320a6b1fa5ba5f16d9ec7e2edfe9fc328878d113e05fa76de7fa448f66465f082b08f43fda0acaf0df94a3c742cd35468b17e76d200a47d9af4d4ee1f2027937389c01c861a2fd74b7b6005d820560f36b5e0b5a41dc5d66bc76807989a50db0a5654c9fd12042b682f9414b58caa534b773b36db6e1e660d69208f37a46b40552445e8049741a52dfb266a8b9a8c8a4cd09511906d04f82374959f0305a06a059f5694ff4322167a343fd0bd49638a7a447e7a5b61b36fb55936bfd56011963387742d8552c891583e24241232d2077010b4eb4508d6d01e6e162e9e5bdc4143ed2644a27ad5e1b139a40f0005c728be66a7eb47a79ced3d4faf742770df87d62a9dbcc88cc56a13aa12a601451ee3a1614a1895f6e93ec19268e6e082044ff1be38d46ee140b7cfe6f19e52f1923bec39480827639b306e41209b3818ff0ec6284e82f59bd5eeed06203def62de12aaa9f1e9a4d5602ea2c7a4a84bc06aceaff01bb6c2ce0a71b8814387bb8706af5a517ed3f6a34594d573b6e950910fa6e9e53cf3ad314e24cfd74b0f4916edf0721b8345305fdad8bacd403c734a34bba1823cc9b7288b4c04b7a353dc6088c452f3af4c6574f30d4fc0600768b2fd6ddd699c0ba9e34335ae54ffb0b5e792f793c488dc47e9cf906e5870427208cbbbb0724a109f4bffc40e389a1963a8d2aeeb5921f2a2d4b903d8bb26ed6d117b5ebc5a20b689622db50ed43782fcdd9454386f9729f49076e03fe70f1846d25a244d36f6c5eabe99cd398e310bb14ed096c175a65804cb7eef90a353c74119577c919e9ddcf40030b838f33dc011a83c8a54be37f628871cc8433b9f96d003d9856d3da79c4912b4794ebd3278f44b671a9099f5e15b7cb30afefe16c32f9aa6503a3d47d89f9a52144fe78271cd344d3192891eaea2dfb07740e161bbabc95b394fa2d70b09e099b64f0024266ca3ce3df5c160d5b7b0c3b5a985ddc13e963b140979e0ee9e21893ffffc3fc7349b68b8c6caa587ff6ec5564fa93e1ef59948099f1b641a2c8a74088dc50f1272303063a8b22e165c74408d8c31e1ef15195cc71a2a42c7c3ea41cd7b401a288817ebbfb11e6377ff59c4ffc4240641116f6a92b1dc27be1ac5578cec2578b4fb0cce0513609e26de1b29bb8e061b4dbcd596efba2407bdaeab553d5bb93eb70343f595aa143ae605bbe492a9d56b17062244553f4bb1a25edbeb849a7f50ca0edcaae1fd7784b993b77390dc2f4b35b24ca5a030abd714e0a7cbd1060631730e4bc0da747a765ab3cbf6786bd346db44f54f4532c8e95e4350cd931deb4d0718f96e3fce1aece65f068824ceee865b1fd90142e7dce2fe5decfb30375ac2673019b4711f1ff2c3c8534860a2f35774c007b12ae12f49f619cd1a7ff17f94b87de60fe2d1034c07e493487b7bf20e16dfcbe68f37cb3122ca575d57a27a713849f0cdb4fc63bc292de0f93c2b89f464e79413023018594f621d4a4132eb17e8a0ffacef3e2cf51dab50edd14ec0464207f9647b9d558b00cfd597f9521359d9fac6249c618840af1f757b9b4da60961f8cb76fdd9048154cd0c3201de1f0d50387a2318368a17c8a1b1268249f5938189d5f6488facffce23b3ff77e33d6ef6e966248c2b220a6676453064b59206680b4db27d0cf692e971bc7e6d1680ab5a705b46b5ce75620de9f3f8c3698f5a1c380679e8cadb852ce3bf5ea5329f09c6d4703f61988d049dc83d6ae48fd33b9726a28d9b9cb43147521f9a3015e2373aa61638f6a5e974deff7062e61e309f7ac36c9ff0c3e7e9e106d0f300b34500d979204ec38b81606259c5c208cc6e9f652e2974576d32692e6b65ea351e46ed801dbef2f5fa997123bc38a0000ff262238141266c1cf388199b576f528cdead68d97c247ead592c089ae6d3a8e4a6bbcaea1a1bb215aa99915c18a9fddfeb08152aed3af7a363b3855e0dd2fad80653434d017f5897ace8f625f3afd79fd03bf4426f51d44de12bd29e2c965fb8da10a98ba659ed1293fb8897131751f5ac7345fc64bb035c0367526223bfc6ecbbc8e8afcc77a89674951cc563d38ee852f62615978e3e63c71d942f2d5e2ed3cda26714fdc9af8e1a78fff79614df3aeca58f690abdf8607244b613fe6c491faabfa7279670a1394569904c8daffdc40d77b16c005ee3e71a7bf7deee7fb4bd5fb467057dfac9bf2b85291dedd73091c09bc9314e00c74aaa433ac5e2032e78916561fb604244b963db45744b79825a6326e9216d788c6ab39acbb727361a1f868abfbb53eef7a769bf15ca61aaea1a4d83a77d703a87bd71697881642cfa4359e523f90871a5320a2f91fa961f5bc66595781eae745923b38026f5180269182c617faa04bda50b7045aae2ac288a9eb4df810614ad55781f9783f5170ef825ff0afecfae064638862849b80a1e0b40be03a414b82db2640ed3190467f7182bdd0a16c2f6489cefe66b68a61fd9634a078b00eb5632219d78eab42d4864cb22586357d5a4393ce001810642f4de4eb9e1e469f9927391fedceae097e45432c9e76210609ddc634fb797a56289ce7b2e95050a38bc4dbd9268e8549b3da7d40b0fdbacd31d74d0496607d0a7bf085734da34b64b07ea8fde2320d2b6ab849f6e5a82f3175ae4197298b0f81fee70eecbd4827c924c146dd9d035c6a138f7712cd09d4cbe97ccf8e1597cc05b44637bfdd6cbdb8ed1b0b11596b6b9c94408aeaf3c3b32e3731d4d8256b31f8708d428f672015877120a00795512f90fc47933a85334851b02147859529084271e8418f087d530a35eb65b5954826dd74bd4686e95a32df993ec72c613f6fee27a5b2f59d4f841e8c3f2a8fc3dabdf2ad45c543ee37ba06c4c7e050531117c32f3dcfafe358dbeb6f0827be30c38d6a065ff75661ced1e7801b8dce4e1e5cc419fb150634532d72a6c2a31091dadc3d9858ca7961b979001b0f220ce16705034e5ae65d147a9b6e3ddcfc48432554a1d50364b8fbf321f2610d54932c72a0bd1d9e2efa43c4f688fdd713c410e983e15989f134e7ef614af671a83be6b5ba771eac54029e850fe7e356530ae9bc3d581550d3063155d939cf6af14ab9a8afb260aa78388b49de94c9568b0d1fa0cf3f699d5c5b1ac3c7d8d33a91cdf8ebb593bf0cfd6088ba9bebe583050198e265a46c620a75a647bb161d274bb952772094b838e7b81e231ec50c944c8068b5ddc576ef4361f49eb70391800327c2f0e9f0fa2217289f72fe65e86e7f37bc2b4b3ba9c36d610742872e8e5e1df61c432bf74d94d6276079a373c43cdccfd14ea91195b5377d5f1389d1eb50cb2b52999a4da3f1974385c34dbdd99554d80326a86fe049967a9650bb0762195af6405d31e2c5675d2f44f9787825c366f12b291757fa4421ffdd3e94c27d5604115ef83513c0b76225857711daca2152a0b1a923c6e013576d800b27841fe6c79b736d394c51f391e84d07a31b764d404ad68004031eaa82510e372097fc2395e11262f2dd4ad96aa8c83a6f54a89645c3332487d8f7647dd00a888a34671415ee345e26ec2bce5fc399e599c90d00a40f2e3e60b89e8bb8ddffaf996baa2802fb278c064cdb4d804b0e44c33bc473dfc050fabbc07c705a4df5aa8bccc060bf3b34b5c9932f6039a9a1e14c2cc1a0aa696130d162bd894415e66fcd7987aa6b8f3738315c60e4d33aa437a8bc4fcb3fd8bb60843d7e94f5ec7c72aeedd0d87e79eab01bf4e385dedc1087ebcc69239385401836fa3e6dfb82ff61cb6931edf68aa4d91fa166a70be11ad31444bcf0595896a96a00ec832ce10dac3c588777dbf45a2b0c389b28b5457963b1a928d2de4589931553de730ffa9c0c0bbe68b0269511b129fcbfb876c461492e0bc47f56fd2f8ccdd7750195ff1722b195c67764189b49d396723389d4b6a00bc46331210f5e4ee34a29279638b00343ac4aede7add5b8c123d042db397e6bb29bf2fa5e627abf9da0da5a1345d07c0a9692d1f254c5c1201c5c8847fb067cc438a42ef9ab45c4d7ecf175d671a47700e8a2438783cd5a40a90d93ba7758c37725db5931201a18450a02ffdbcd235b76b177bfcd943c449397b1607cd47c61833694bc9aec6fd6f2aef04cc8c266bafbb71255ac18ada7a867768d3f97ef8db1ec71d48a95d57d8fb1d370067a115fc637a689c9212ccda3c94e9d4c81bd89cea871ec3ccb52f821d31e1fdd8b542f6c35564e7b146da57b5866ce28025046755919476e73fe689f6511b322b947790b3e1f322d41039fa2017ce6f4f067d0eab95533eb60ca0717196cf94e910764f2b45b42b8fd13f6c69c2382cda9189883d0adce34ed3764b119d1fe9b234c6fc8a283bde9918812495608698e7d91a9bd67e13ba32da11f0d955e7d429f391979446ce22c06e8064fe8296e3e4b9169466a195888bb8073b8105e06e80bc17d3b0ae79e130a92c7a0a97845144fcb6aee15cc6ae0617a540ee90a46e2911da7fe456694d3f641debded738e567804066dadd42ceae9b7f0780ab1fa9fb9395b0c9482e7655be348a5275be19925b88d3494198bb8ccfb3b34873cbe27e52865ecd7324541b33e5e1b21f3a31a05ed6f9c936420c4cb8e8569c5835f5cbc79f25e801afebdd9a3b2b1a7143a14691d1e751d8db4def86f1577e7376d75613a995075170a79378ae5d576ce018c783d3e3afd08509c656cc1e6f155050aa1bc11758c659ea3f97aa1e6cf27949dc177f68d59511157c2546859025b76c35d509dc701e1c760a33e626cd37cce555cfe18c89f43ca18b17a8a3e7b737d5438cc715c23be89bb83164882cab345798666f46e25ba219708cbaa1cec979831a47d1b9c8694d1305661cf1f50d6c28cbe0bcc24d2f6ec18ed0a07535c1ec9605a3afe13833ec49bc9f9de92930234473af854c289c6256cd65e243b30caf61714e6b2a5d55a84b62048ba4c66284d9cb7c7eb6f46f60210952ed58016182fc4a097b92df31980655df44f9c4e59e00218fb344cdb8ad7016df0fa36b8df44a68e9b47e7c9eea178ce4c721f5bc2336d3898eda04d4d02a311b4104320d3036565204d6419981b79d5457711df045240b397e90a838e4897ff6bfe478684565f385e31a89d005a73036ecb3b0a97b2d11ecb254db840783e0fa6276c9630ae89b6b1a4d26f37cd8af380d66034a18246185de2721f27ee9ee85e09a294beb7c01cb25134efee7f2a0c6b62edef590b22e7d2a319598967990a73ae1fc3b9f6452cfa64029a724068d4cee8f4c311d12831d685f27fd255753802c064c664adc3bca5526a4021162e9ce0521613a3b77521df0133875f8c1b23553e0c6f5ccc60f7bb52c2fbf6a89f50054d3a7bf794a8e9da0a305f3893deed276b7c940374f609279e8ca781639ee24c8fa9dbfd9d40d103f3982810feab339ff6f1e87ed1fc0cf5ac1825ae22a697b3bf38c8fb3d6bbbc54ce83c87d7a72460d9e4bbdbd32db374bb9c177bcaaa3402f131627256d3099d4e52ef49705de8fcd939c22e1362bf9c9e9f76cfdeabd223dd32ae5fb4de2a26e9dc8175ea61b3d44df0ee78d0d6ecb17e58eb46cc0074afd5b490f32c367004516773e111a142445619e439a59b174bf95215fcbc09b301d4782af03262d5f7f380c6f5860d0e72464f5af8f45a4e47edc8195677c9e6e58a0d125089d30e00f9bdc58233ff397e4fa65f742a3f5f3eefe1fa983313358aadf37945da88654f5f7c525e232188ba832383c5cd378efda4970ddb68f6cff5bf1e0fdcce3f83558ed3b1a27ba209fa408801f904226ab129dbd1d7c0f3e9c31ba7c8c415ae353889487756b5fb6a01739a04e8f5dcc5017125e96efc075774b525c47c95b6975c6feadfaa05e4a10070de6eff220f33ef514deaa21411f4388fee29dd24dea39f73e8b81671108e3db4cccc9b2bd31325d1cadf27221cbe5bc1c88a442d52ce6b5c5a14f78cda69d6203c81da65dc716d935c3d7abdcb8a08640c8e68df1456f40880abd25cdf6970d574b39ffcfb00b22244da65f0d449eeec720c669f4c9c83c6a7cf1aab700300fbf256faeb8ad6f26b8f99f686d5bb22a015b92b1ef1cee11b148c4f9985d11392acdbae1f4393358d0904a7e9c2817fcc6a0663ff970c927e76b5e434b63dc3bbf606a08cbbe521b5c847059836fd389a805df4d845222b8889a2a83019b4f608797653021a429466e9557b1a20b7a6ccbd131c6a03551bcac709082b642d2c4f08e2888b5b7f38663bc5a8265e81cf9a49693c9d6625ee255868a148f9066b06e47a8ee4f00d0475ca4e2328c1743b99b5a4ec84a4f27bd981b04693203b5af904f698558e7ca9e84b6be3b3843ccb2fddf58583b87614b3ca00f3ccf044a8ba37cefc81fa5f4b66f95d9fd6a192ade1b457213464b9d98748524fa119cde5e3d58a30ba4f70e86a1ec38adfd4b4ae0bdfab45d9e7b36969a780f8aa483787f0b916593308cac5edf0ec8cca29069d6e65122adae573447b23dc5fc3fb0dbb0b6823a05a4d5243167a7266f94049ff166f690f32a1cb118b8a1c9e073eea34888956123e31353194f5cfc3c1a2a93478f2a9e635a908d524e4d0cbc854fad1cbed4e811bec6ea649d62ada6c400d34751eb49f67eb6877312423082bf7058f6f42e98c7128ce5303c98e05c91d9e111be54e3c792c6c08a427369cbb89243ece3dba07b930e67569a792c0ed447cc4968348f46f3811fdc3f39379759d568f00fc679909f32b035f771483ad4d9df91eed0a5a0caaee08e2f05686bd6b67b8914a43aecc33beb5a0f396af178095df2c4a616a413add2e8062224edf0132ec07704991b8e56fe30acb058fddf3259d54a5456d66a16dc41152ba4ccf4945ea59566c5d9983dca4f17ff39496c82817c591278388ef48e58ea2b0eca536d774e87643964dd4c9cb3d7e66a6280a6b0380ba7203bf744a02042874869556aa74ad29c92dee95046e9d91d181696b05142f9e9701637a2769264b47de3abd5d908a8c0dc2859e0d821f6a3c4c2c934d413b7e8a0d58c08291c2299310fbd61ad631d6abad6a48d89edf8f376405b8f51d430b84220a7ec92056486c403c986d35cf901746c5fe0a286b83e3448bf2bee537b0ec6e1e3126e8328734188e39dca676e37f53e7309c9dd212affc40daa78943c0b278ef3ecdfacc3effcbab74163bfeb3cd67100af052143ce182a74d789d9f59241520008427fa6f22c0736277a99c800b437b34cea48049818372630d4b0f6e5dd06925bba6c0aad62587b71bd250cf42a117a5ff8b54f09ba71edd7d698e509b694f97918f4ecbe16aa8922c0519ef163d61f39e70694ef3325eded15cff040278fb020386da7dfe37cd0347bc1a506b5e45c7494d70365a8bae659b2388fa9498dfe1095fcf32ad620ac9c06e69abda7eed2d8507b2ea57f6d8539d2f0dbc96f747e90c089f692b9cd49bf88b4170c82c651eedc079751614860a51839f963277c899df2e979749ecb10daab17553b60f432e442e299b566809bc4c1a1e034561bc1ed428201daf8f39b2d2dfc77df7c2e4d39c501abc918e3d8b009c17cd541c567d5ce2e48bad6204df56fbf62b4f7ad2767a31a9e46472952a65bcf216433bad7ea9701272ae8f5ae4d12661eb97387129deb37557f7dedc6277881c079a606cb069f5eb60fe8f112cd24762adb3748e98e330a9dd45efcc23040442a59e208f7df6baf369a62df2df4ddd0e3c0ba9668ad8e0f460d0d280bce9683f8a771000734abbd315a8dcb7dabebfc0875be0fb9a3d112bc703b69601b749c7fba229cd128d6329453e5a687ad96d23de260821e117b9e111cf58fc493511411e4a68e24daf428bd799f1dc375e3dcd723ebb67b4de1d792d6d77d4bbc8a9915c5a5bddc45e767066d333b7a9bf059c45faf23b60635987dec4e7ba691d92fccdbb03dfce8712185b5f5498594f1049284135214b37491182df6aab82f0b69ad081f70495987f5cc1adaace5a529a5a03b9f8f13b4d2417ba1e2e2f816db19956cf383b0f8989b6ca63fdbfce6d0ab2ad9e64cd3094517c4d7cd3909a274cc0bb85c425e284f03cce0aaa28b92b00f3037b11e34f52839c14744138c10ac4a221f8415f8bdb169326634f86098ea15b11df66d3f8636b5fb317f6d531adcc6dc4b2bd78636848193f5ae9ad4148f954de578bb2ecdceb0329a8cfbea62d3dd1007a839f79733e98e77b3e2e4cb848398a45454bd34ad06d264fee3b0a63556b852091caee1f79893d3c67fed62909264294cd8b543946ca1ae86854b9230e043ac60b8115b074dd0d8778abff8d3667a1411e7c99809d14a434a6b1d922b0a39770019a9699614acf482eee81c897ca14a89b2d11bebfa3cb865ac8ba471483bd4fd76bf5e589fdc92ebcce4115d1c06d69ffe3c8e293f1d0a893c38d9bf1991c4fba42e4ca3ddf3307196fec382d51b3f73cd8f9684825b10844e9aa5a543abb4ff1d66164b8e60ae2b53a96c5dd2a773b5526ca5af541b82708a6dbe4187670b5f0267f9db69fad06f755630da2d62cff555989a53d0131c87384405af7bd7fda2469af65792b83cf03241e74773287ca03763426bc924db45d0a7242090c9a34ed3ff7534ee8fdc6a149ab90ddf17236ee2bc166749f6feefed18c861cc6c73f8ad47e74a9b7622ac1940af9d2b423f29d1990968780d51010f994af3d1d8ab8c3b0842afaaecfe53416c5775701ecae472215162b1190a89dd2f796055433bc839a5717012a955914677c19438a500db37961ba25ddd3924baa473d9e683dc0782746a0eeb11b5a589e89782fc28b01ed4f6c9f976af31ffa93099acaa748932b12589fa42a6f2d878b2411c8e9fdbf5e230cb30f348042edae6677bd32b0fed0962007b980df0f939708e116441073046f7fea3552274024da04a66ad38867d2db4b0294664ce4e380325670a823f7d668139ae3ac220657479599808e491eda79dcaea643d1af68f7cfaf7abea59863dfa12b762abaefb58c1098d8b4cc835c69cc6ff1ef9c5061e21344ec4d8213aa6ce1bc7d63634f67110190981deddc5652aeaddd8dbf9f98b9a21ff19aad274a5d47e820b24b23c5e2b0514c02e6db872d79b01c4f84298ad7c51b3b6e89a1f0c47d69a9207d128d411730ae4551cc46b9150e0281304f926910f7f98db3230351bcde1e9f07a2f31c7c4930e87085bc07d6a0f23c6f11bf6e35086b1c27f1e1793136054f9e18b867abd62f9edfb0f81d370da08fc0c1b4b5fa25fff58a7c4377949827cc50eb5553862377d508ada73c747ece5009ec9330ed57bdb8b9f3a30c2317c2c9ea8cdd07aba4c6b8062bf4188c6592e6082975f82bd1dd31ef66aa80b3548445eeebac443589967c7311e25b1aa3f4696b9909a9bc247d1b6f557a8b7bae6960128d48ffbf1058941b140b7d76a27dac58ccead9068fcf8817f4135c1df1d8fce600b07394a3b30ee26c731905f016fd231eeda282ed26758212afd85b4b024dbd29c8b4b3e2b0ade365b19a6dd7ba97038afa61e3fc452be7ff8eaa11064ccd24eeea022121f573aa4a95511762bd7732e281d421c9a5e73a332bf8ebf92d5397ec193943b5c76cab16f561e57f2c1a6900c06d9b36807cb8e7ddeca947558b00f237facad0c13bbd0a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
