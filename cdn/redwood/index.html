<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64beffd52bf4c6132c88bdb96a7d45ba3683de8888ce875e37f364ed546563c93f3916fe10c31c9e79226f501ba67976b64965c4c7851cea890573dbd570050ae6a80a5df99ad1e645411725833e661bc2ce684681fd6f1ae48aaf7fd914f2803803aa4b7b750398d6907277f8f917c3a34301896c6a7e4e0fc2ae0eb0f3e8d5f0a6f4fbf5e965dc7e4d9a51f51568f31ac0bc0f56b937fa9098256879393c46bbef447047d31a4d04e82e58ad44516be508c80e927952d4729a97eba4124ec6cc5ed9b79ef17dd6abdfa885b252fa813cbb9f84fc48119ac7785c694f7aae863c7f08fcae39bcdb9f7972f29f4d6941cc79badf5e6253a43ed1187434d39306777f666a58ac6990f75766ec6d4628dd4f8c4042aa6f258c9a224cc3f04fe7f5bf88a746a301ffdfa1d23573ee7483aa3609fc9a58a399e77a169950471aa9de4c6f385b81e30daa2b1ee5b8a699eb35da8de0077f50d683f7a60fa9130b824a6371d9f68a579a59ff707e43908108c2e6538bd4f72ffabc22847010b8d9a905e52436937fce2a1fb41ef12001247951fe1eeccfb56c56803221aecd7ed662d6839f53fe2cc95fa1fa9bfebac2c81ceb4fe5bd3262e57f84d40eee1dbf4c8e5e588925564b165d9f996eb059900f02ae1908a45a69500f39e4f145f2f4a40f2d3cd44407c1bab7cfe50f896e59263abb58a47cb68bd1f4a62d4db27a2924491fd1e38a9ce7d2931248a16ed89e66845f3c9415f9682cc270ba328fae15ad2b0b3bdaaf6161a22d2b07961c1d70168d9468682998398d703f65b7c18df48c4ee1a2791cd43557bb4940e9ce2f3f7e73f07f71896a0d6f8ada3b9ad25168116d39b22b8e36285827643a745169278a354325d65a4b7cbc010ee4da704307cabc6ee8d53d77734474c6ea8913b0ea677e642fc230545c48b2d7e0a8f6ec0bfe41123689a544376f2dc4aa9f7e676b4c670e3c44d2c6b464b4eb319f0080ac4554c1c1e35ef47f9704ab5f8081a30593d6320b12591926fdeb3dd28b379c34dd1d798c58b3b00fba185a60544ebfb31b507d4bcea6b3656f13160ff0786f89f1154045aa2fc018d0e6b6fb84934887fd9af0033be14c594effd3f056a88a45a3e710bed6695e90ce61410d6ad2d29e436bcef7dcfbf246b9914884f175d484b0f55927887ed8e07625e7f84b0abefa92989709b7cd4349d86750ee8eaf0c4c7e216821ed724df5206d81085a8c8c72d3111ce7a847130e40b55441d5f635426cd0b4a07ad01e9038de85707332de647fd53744e00f17fa20b8d72dcdeea962cae2da9d2bffab73f8eea6f21325287dc807fc077b281b62a060fb44178baf7b34186e12bca741a6c64b6c28290a5f7c46231beed61ec205da7504c198f9986b8a0ab0a0ca94a7f5e5904b49a4187619e2556f77e3d397d6a7449de70d15ffd52ea28682b399a9dac32ca1beb9f62e29ad21b2ae355a3bdeda613ccb78436fb90825bfa9b63d003829f33f0d1361babdcb5fa692a596840e835d104ec9645930165acd32555728f51d2bf677f49f1e018879fa1d86fe866eb053ff867fb61a74e6a190d2183585473a5dab30b181dc474ebb806d6beedbc6d81a9c092f226338dd5f8a1bc38742fd85cc7f442c46e54d95bf49012aa3668bdf9ad5574bd1d2717131a423408fd284ab7744df88e52255325bf16f669499e5faf9971c3f211a140772a225398c5972dfab1e660ec7f18d6d96bf0be3690a8536c54d9a6fde2b349787e76df11b093fe51db2c1c685f6858ef2a361b042a2aa73cdec37fc8a76070bca7f70db390e7d5aa644b48747233f8b93426069292079d6ea8a658ae34fa03a8734a332a82a9efb298012afe0cac74b138703afbc1e4f74e23f3ae51c2855454f22077799888548126c431d77612812cc585dc9d2448918eaac8b9401cefd78a8e1f5d96177259c9379c930978ecb6efcb381c13f3434a7306a0397b8e148e06b37d8bdf94257b72bdbe7ec1aeeb91ad07a563d563912e9305642bd44a848e832ec3ce66a34d501f1dd590ea25074ad2ed5f540e77d1515ed41a4c4bd1e1f63bec12fdbaef54de606d24fe92770b932b9849d1b9617e431b00d5789f85df3f100fdcbeb9dc5da0a0341050c14e9ea902eb022fad967797e0e13ab9933139e87b0dbcac1270ff33bb6be0261080c320bd4029b355a7d1f8a73e74bf12e9d98d2fd0f1a289cc73e32a43760aa6c13731c012f9a423353a159bb8ca56125a75d90cbb9d10b69a2158bd24608c7d58fcdd9e1dd1f815c71ecf6541f7ec1293b830f6c78dd9e75d6b2916b290b6427b2058584e054a816e63fe67f07e9296d8d3b7700dbe5528251c68de8ca1291193a0b2bde8e4bcba6f39abeb100ad95d59d23c44d2ab07b6f02d331e6c9cce8cbe822b2f647a044f57a135f0d48d1afc9e77845a1af548f036b035908da8ba8110beab9ceb6e17b381dd8097c7cb616dfd778615ef20d3bafef5a730799e02a62b46dd0996c2f500d6a75bea5aba34e9891fb4c1b4287669f910d1dfe627742a4a2088652f40f7f0442268044154c484ce400ba2a407248360f0af810ecd4ee491fb65c4c622e9215ac31c1d14d334ae8f0a4794f7747d0db5596f7afbfa26617b94aaeeb681f4424fd48a8281c55837fae7e1aee839835c777b8c61409a307bf9350be31efc9101549c54ae0f3a16d486fbd657245ebfd52cec8f2f21fe39c7a7b203b468adef0af59a565429a16fe585b9e6a445ff66d1d777129deffca65edeca0eb05fd38b1c70c4f40fe980765eef78e1e03f91f0fe7dd80637b5b009560b81f538cb8dce1ea99db02ba6a1c88fdedac3ca04b9f45fe0f34f72ce33e61ceeac7dfbc6c877cfc09a19d2a93730bea5d7789db6fe945cf350857c4f15faf07fe7b47600e147859bd4248a6141ec343c831e8671500e809d357f1e07fcb95a63444a88b5fe4d97ec1cc1b50e219d275ab87dbbdf4f7135c494d47c6f34c92b1357f1c340b4a7d9299dfe594a5ebaf2edc5567c6797c2bb16000ed6e60388bd61c07ece6dfca7ac616d667c31d7161440967d961227e161710b04eb17375637cadacb02cff3454bfefa2d66bacb742cd2c6eace3c366dedcc6ea081b8de5a8b90ba975b82a0b9895d3a9cb31eee5b5f51f64aaeb6270082037406ed65cdfe7c91f5c1d49c2c7c3017551779965fb95e35525fdc728d98cecab52e5b976b5d5a6ad32bc2e0ca60fb25d6b7df432b5a71142c97d771889387840e68c8aa57dba3676016c111b9ca52041cdbe57df6f05f57e5b91d2ff4c9af7aef0cda7376dab30d0929d3430a43b413420cc0ffed74cf29d5d896a469626d459945303175d0db6f9c506baddca09b27eb4f8a99f4c20abf5620afc639c7a35f1ea3676e7b4234abc4ae3f5bb3e9feffba24beb12e0c19eb58cb2f44bd71476de5645f0c79a19673611e886ef09b0310002f4314a0090649a81f7ffca880c7bea8654fa8f114fa5f8434727ed148682a3ac8c8d16ff0e7353f9edd5659ea1512ea5b590d5d93c57047ba34fb3a8a525138da858539302f65d33258c8a9efc2f69d5754e664b7f05c14b0a07fbfda8d36a5351b74254bbd45b484c69268f267b0291a22e4fd3626fd5247d464ce3dd744ad5e94e45b435a05e1dbc96c45ee679e32a6330b93067c17c1e3150e5218f24486b033aeb5d96ce83bd11df9f7e73e4b51db90a9f0f352fd0e51b0b0e796e283b56820fa5c6df5fa39fbdb16ac5f8225277ac0cae550bf36a925c7edb0c7550efd94f1cf76bb08c5d465649ccac554484590bd7a9c0f64f09822bd7e41f1a55cbf3361d7e289301ef0a46f4c1d9ac6911be7b82fc240d6f0b882234497b21279fb430d1d2902671ee4728297f63b5a9ea0506b8f5205a9df7843230f71698349407b0629cbfbc964dd5519dc326853a45fd50b549a92e3b9204c5e8fe02ad22e2098b06534fc46b72c98a07a15610d0695829a61812a92a684b9a92576dab1505f8c3cc36a098c99d90b26ac636835bfe770a0c41c5907b5f96be54c26aa9b3eef6fb75843189fc3ae88d2f623932e893c843c30e25b0710499c56261dde7401a5401681c5cac95575bd90887c445e57cbbdf3bee3ca3713541a065bf7e690ba5e2c7220ad4e634bee4ad7b5585581319bbf87c8e822855a0ee6c5c79f8a1315c6cb4987a50e47e898248468540c4ea8c1a858537175abaf94a4f7518af04db051fd72971cc5991b67323b64eaae862e50cb20b23b07bf6c24a83a555a703cd81c562d43d01c2c1bf3d3d0a857841afc9ebe8345ca1e5832bd752de211832fb05e3cd7106130ac4cea4d7fdf5f3e16ed4d925f12457d3f672fcc9e27fca62bc78c47534265404f35402f1ea08b9e074714bfb0a3366c0ed398def8d034208bdd59d0017115962a5904835fa1be873df52023a68bc3db34796767aa157abfc6f2b8c7f91d68310eb7ef76bffe4562728363e23c9130aab4890368bb642c237bad1931cbda01e6661200796c70ceec916670ac5adc1ed4e4b5fdfb1d0b752b01c3f3f36b4378321b0e01a92154e82a5867647a40b1a3195a3c099522a88ad78765533496aedbf136ee589f12bb23c6249335f3f2bf76de33aa8a81067755befef5f40b091431b768b00d3ed9ec0e73eadf5b460482138d88055c58de82c1a3bcaec949f4d6be773cfe3db07341386ce51d44e9796a44a6a4979daa89ebfb768370dcf590def9322a16ac51b033909070c3440479ce890141261e4c8f27997ccd003812eb151a0f3bbb3a829913946229dd9729116d2efc9832d31afc0e08bc7819b86b612a44ee31965ca679dc21edc906457e55485114310228d8125794c92471dab0ddba8a6ce2d44d82ed9b1d885002fde3782ebebd752d50348f833accfeb9e0cc6105cb7217798e66d99eef8c25c38899ef54f52d2a5c80732c3bd5ca3ddfd917280da02e7a2919fcb9677314820b226e6888e6be94423bb1a88ca0e47f40297a2316d8517bf48da5a5b704871615f17af8e839ac07a63a07c7be352a4840e32df916a1662bc31ab93a28c951ecce843be22324d647dfb2c98fc960a879410b5cf9bdd259f509ae0117d58e24c13d24a90a81212fc3011778a0185bda9a7ad9796cd46f764970becfd5d0eac61932f8b66a05b70e686551ed633a4657f1d456aef4da3d3679fe64148f79b7cc33e03de82a8516be0cafb3f365c6e8622a2f3bbf632ddb74a93b5d7a49081ff7164c083d5e366cfb474de002c3b965ccc7fe1236a7e58154cfb159ba67ae551b103945041230444dd63c67c88c491ed78c9bb0354fb3dda819e7c42506775a4e00c123f62be6646fa1bd5d81c8b835431a45842fde9b1fd439ca7a44e2a7f8ef77cae08b745e291a124f00555a432a84adc085f7de1911406be3a7498c314451ab2251908a15594e43ef3e05f6869f293335aaad6b9c01355d3f0b0dccbabe9688e5e8f49162183fe49e5ac5b9461883e8868a53a62c32269fe20322cc418795fef97a48cc2138f84c55bc522bc921ced69d4970226e7c86f9d8887a45f028f7867c86822fff881aa945873347a5120f980992d6cb9dee2d2c98c60231df412a97fc271b37f814c91bc86abb3492d92c57741863d956655069e4863778df9476cfc995d27e29d3e12614ddc703505421746ab22afdae4a4c6532ceae6fd00687ef3bf23f08a837211909e62bd1845a784edcfa4c068b7a9c57bd858e2e517893a081c99c527e3c1be93b258f3b2d0eff0f4f3f112aff4f0138511f4408bea915cc2148a659802f21f3e0659792aa8b0eed8c8232307fce3d7725dabc45e2b5865c0e3beae202a0038b3c432f6d9ae79d1714b388fbe7eac7795525c3ae280bb31f0ddbb764c6fb66b06b4082ed7e53f56cbe4401cdb3766fa54711b256878273258189a1ab4a2b5a8ebbcd4b15f3d9d9db8e58e0d92ad9177f58d2e71b59638a2cb0811983ac1993a7c992ed69420a537a7d42a582fb19d3f34c3a14a6cbe13f174dd78c1a66581b0c328bb3de334b5aa1ff8a792b0862a359f7a2c2b721646d2a9eb81713bc4dc6a6f7c2b396407208885bbf4a668a17efd8619ddc327f696da87f0bf8346e79721a846d29fd0ed2f489aaef51821588129b55a91fdc56be79dc17e86af2bfd459717d9ca01fd994436957da958e9fe7fa5a23bc354b7e8819acdd973b67c58fc44be05677d36b313168d613815a8068da2cab35114406266ecc356c6d0788ee0fe2d078c68cfcca3fd267cfd4abdd55a18437cf5e9b871a82c34c83a1a30400595dd1b75fd5ebde1ebf1dc36aa642c7e65947a6a8b67576e4906231c0cbf5a4741e750caaeaac11111985b99e5e0f806bc3a4eeb0509f8983ee75aaef5662869f60281972c97213fea94983a435cbeccc9bb24ae7a9579ca355d817f79aa5444fccd35da55446e42ae00951da0f814db316c0a2f9b99e53b3546f3b49c3a6030d5b0cf4b24b39f333b8d9b3a3c3b5916ec9220c190c4a6292e44c84e9b3f20fd214ab2385a3eed4799d4d65fd8145368f823f149d3d830787a0c9a6298c0527dc9a9031e8126d8bbf6b2681a880044227a3eb0e745aed324bc8081292725dc71d97a411f3e96803565c57e821b3fa8b80ea83a1b623b5e97af76756b8c2c8edf9101a689bc7ae43e8b8b2d6ccfab0da7158b3a592e5c6442a3bf164bf952b91460c9e50dc067de39c6bd0731e6e0fcf5efb473a62172ce36869eb0683cb748e4cbfb48f726e67a2c368b161fbdbca2d8b2299bdfce77de740ec2814c92a9c1f7ab16a1fccc958d5b758b0dfdea8e8c5d3d74ccf564ab64da612702328464ac5cc60f1f42622b83d54f00db67d392ec756e39c6da48e7634f98782d6882b5f1592378f6e788cef417195246b3c1e581e70d12d351ab373c41a1f962614578943404eb2b43814e0bdbaae62378f5a61a594d0ded40620c430b4fccc8c98dad7f848031bcb475cfb5580ed8ba16fed9cd8f765819104025098f5937012650ff198408bf66a9deb707dc427515edfd76438f50b9340aa3e9a5ecf4de0791af6fcdc4f8e6e415c7910cb6b1af386054f09bfa11921ce7895b035f2d9ff620fb1f3859a6f6dd8603d3505cb9c0e6527a1e616ac5dfc5751b2bb959a6f6f2d70cc219671948e4fa9c19a079d828c6871e72f847d4496326535f692af3cd9ccbbbc43ca130c4640189638eceb66a580c4f4dfa6770c968d9dbd7380fb43272099754229da3269529a9acf3d5f77ecdb30c93d1a5ce956bd538cfc27a26b19cc572987c3a73975509aa45a0d14fe77c668dbc499a2382b2708c74fc7793daf1f1cfe596399b06f938178a5cc90d53385a325ee81519c1468bda6c37a0e7490343250187b30fa5fe321f2e9a1548f5abc0399974a725d3f5c5d177699c9c02438ff0df272e2e358ebd9d895a626d08cf7e7fa740313c0f3649df17283ba2f9eef7d147b34103b9ef87e157936efe4f136b2348c1dacbaf6d5619f63b81b54a13a092d66a8b6e2e40d1d595152c8f969f0dbd62a52e4f3103811aa3f3224e79f2f837b872b8a386827271435586ae64765f7f12dc433d68b236ed15748d1e3a57ef48fe5992609efb9a1552095ceab43e40f504d9458e534729579bba729161703972c193617e5a2975a9b4b96b12a176ba212c0417201ac4428934df76ffe470f5abcd58ee97ce5eda1958a224137931e2c734f1be7a22a8efa0aa06790033aeb1284c149c0a8a715182fb0258b2ca5ba768e9f2b0f240d70d526c76ddcf162af7d2b3cd41b31ea6be619b20b5a5909382acfadc11ec961019b890ee1f6f494c73e49941c52282c9fca49ae485d6f896dd85990ff31fa0f4c9e6a04677ec8454e1e1bd4aecbbb2b4eb1cc0411c5049e690d719b6c0c39b6ff1ce35e4dd40b7cdf2fef9e9704d34f75e0de3888c6aee4deec7f8e30b9c247ed6f4f0d81455bd55fec40b08b6e0bcb2b445e706ccd80679d09c659413694f6bdcb31732c96b7df4fac3d9cac11673fd9fa27faf20ba22d8a93b55524e978471814cf1f4d3cd73b83fad64136a93ebf4e3c43a7db8e533b195d71fd188bf1da59f25a42e6857ff3f5199772e06b519636a2602cfc6f189a4e07fb7751337ca07f8b05548f498ea563c964427f7442968cad0db27dae27d65fab950a377447f12a3526cd600652518fe5d7b8e061db96d7df64fee5a7c3b8d8bb718f1018dd34d5bace343fbc1c26e6dda5d911684552362b1b8df3e95acccbdf24304a493843deebfd3b467163048e12639f504c03876d61163e4562f3018d7ffe84595bbdc1c1b0ecb7eaf9e597734be02bb2b319adc356feda1b6ae9ea97b63b430a5e3c6ce3ac7a39be981a0e3042b44b5b31d35633ebab0e7c031f5eedf88587404fb9e337a9bdcaba230b69d859193379833b8c50ee419fef4d4a8d0c1ec15c0eccf387b3d70c651b583fedd86bf986ec2fc665d41ccf354a11c1f79346782444ee5d2f2eb964d3c3afc550f78ae32f1817286857c9a475b987ce024dc2b4f5c3e61b86552dab6196a30f386c7e82cf8fa1cc52384b6a13be87557819185fb9147b86d60832acc117c162f79456e570f3efeff5eaff6ba26c076f10372341c34ffe577667a2cdc1a00b033b0c17a228132162a5b49eb608faef77b203e60b08480dfe58a99c36c295c26c92cde1cb595249449ff72000cf7d70ac5913242612375ccb55184283a616119af505d562535ecf7e050e4b3bc57e642c9b87941e561052d00ed540f3a0ff943e78a3d4c1ebff13ef760b670838554e33fc09ff64467ed41c9030b696e08a92c30b69efe07240bf8a42fa2315620a9725ae40947d5636c4a63a4792b64e0555b2a488174b6c740c9cdfd26a940ea47f02a3c7ec112baddcabbc5218271ee2fae01991dca4a49c18210adf1e0dc07b2380ce81b70e1e60faea3c0522f8bf540464b2f424d94e4c0b5658b783a3bf8dc547476d9eaed7374f58e085404caae1115860841417995cbf86723ed12adbb27fd4e49a73e3fc9dc1d3ce557ac2b78884b3970e15a662ad0d8085e3a1d89fee0cc15d9a5def6071b336c3d9c2ad1acec8de28d1da515cd16d9f3dde128c5b5a129b1ac69eec35ff58d63527e9ac2ded62afc112a1de92a51a4337c34112fe39e8d4e78257c2576685b73ced82d4e6c78e10b8ca6a3c63d499bfbee91479d78732ebf6a755e0f9e77b64468deab64dab77c18602288d5232b4129462631f4e5a46fd62ba2c7b1f9b35ba2f7deafde0ecb964687864abc92d9a76c6c74222674edf235da38a146f1bccc2b7caf098730b49cc2dfa9cd288ca7940aecd97fa91aab332298f0c2a0492e700bea7ae36a80b6326c574e04aefd1bff9f346f0577586e41193ecccebe4f7e2d4a91c8fe7ae0e84e4343f30158c55c0a99a9774fffeee419b257ef3820bbcd1b0cd3420285f58dacf1175a7f7e9d54c9e2c00b72ba1ee47f2b8ee47ddaaea3169142ac77443ec4bac0d3f68595745dedd49d26fb649b8f72cf6d1dfb605f168f7869d3e24389120e3c0f7539d50f4169a8190af8757ee5aab2f0af297c45b2030db0ebf23989704fbc52490741f0f6442f4a89bce8939e4aad7426f66a74ed689cfb9708f76e68f8be6fc87b1417bd9d8235a2f2eb8e2250e9b1546b8cc5b3a8c19fcac9e07445ba53fcae7c994df37317d7618b7824ba8fcd288fa77029bccb527f38a966b36e0ecd369ca063349d97f2f72c7117ad4e0345dd40b7595b7004b5332a738346e7e216aa2bae244b248b8eec9a8dfc3288883cd5dbe44722679e02e81cd71138872c84d731701471db7dbd41676769a2d7eebaee868bdd0912fc773a82bdfb44480a8b0b5f0d13d2976f0ddceb4a3314d56edfe8941d54f4c875c11f0497deb05892c22641f3579d567e70abfc981303b505642c417e2ffeef9ca2033f6f3a410b315fbe7f08aa2915c5b8cc19fa4e3a8f6c50fdb0d27edcab212e94ee9171e12a141289e2d768e2d0c82a6be29c2feb5ee5d6c4374dc43806a08ee25a77c490eba1f519bafe152cef1e45d640e8c2933a0ea05e2ea829c5107845c333744868618f6298ff126655bb3a04af3a695a4eff85cf19378c822016b1a21d92910d1ad9a65254f8aa0bcf218abfb5df5c27a2d9e6708778b1e78e1a60ad3fa76558fa703a59761c3a2111382de12b56376b9638e6c81db76c6bcb8f65bd5c3cc312fe537169496e85e8eb2ac17a98a5c46ae3220683f2b85d89f5d60d1f8aee1f9b6c53ec553caf82003cb535b9571e9ee16d271b53ecbd4b358daadac078d70d491b2ec5dfdc27f40e56a7bbae0b08a37f4e6ee952dc76f690dc5dce315d77fa82bde2dad751b760fbfa5752d20fb012096bff6b003d1777ede51869a38cba6964822273995db85c47cbccf0f943d837d204fea00a5a81aa113274a2756fa33b51b0c45f87275e6504f8d323209dd7bfb6685462ccf855636f6301e4edf790e45ddee92edc582a9c079b3497eecb86fe34fe18cbe50ea44988c069e895b0dcac39c218757f3ea298de5a6799832af0e570fae24da6f6d32d8b224836d420ffb2e91b1b22ab3c1d0ca0b7e747b532cf7e6354d643c3ed5aca91b2cf5aa07b10db64f423452eb144d8795c148aef0aed35205c6037855638453096612e0706fa1b94e02864d1cc087428c47ff06d5d82fe5dd54a360a927152b7d06b88670b44ed2e71a9f65d60eee1759508b3fd2baa2c9e16a301ab10c1f99802854e808b9f895e8a0e98cf43bdba84a59b2fb2b1a4815ef9faa79c2954f838f35c1f16ce8bc3989b3e482bb1c76e64bd3a006d31474ee50c6cd57544b741404ebec3bcead11b8d2fd8de4fa2518c54515993fbdda025eb517156658809e3f2a4da5eed5742c73b51a8bb290a0aa3048612e5fc2fdc3a111450d85982f578a1c5cae88a1f6be5e732d602c69cf86af04e503256c3d2c242f45c428ff3de8ef320260bea3ab753438acc965c4e1d1c295a2923da38bb80e3fe182566085d01e754b80d71d78d652b71f4bbaadcfeba1a432cc28e561469415787d98c039eee78bd96b26be6f5dcd7f7599a6c6e36cdf36581b34ebf091bee5c765b2ddf9e8bf508daaaf874f7c3c479879519b8fb3006d7240ff1e301661732390757d9a43e65fc0c0edc1677592f15b52639a08c22eed66a08c3f4c9f9bc943a8679b2c0edb63d8e720cc908c1091bfc2077b4b0a5141f07fb698d7fbcf9cd1fe3665d790160ba9b2ee5e121d766c0528ef3724622af04d44c65292a76e8976c7ccf0349211825b064ce98e56a3161778cafcebdae67f3bcee76cd0ae293c536fb96e95107c26a14c5089c230b5c9c6a2bb0a77a8648560569b90871d0d242756b4253382138b00df6f6136e1277146d924cdf8a20f74d430f7807c9ba0a69010f7250f57aca4fc14e1f1a2d3d90159d9c249c25949eab4fb7891bf2762b5bf0c603fe7934476f3f8b288430531a9023042d410bd40cb9b05dcde3e271a9271edffce55e8625094dbfc85ec87871892aab4b6fc820b7ffa6674149ee3501f23ee95504fdce216122e37baf3f00f9f243b6ce61824a58ace14116e0a4007fd54a0a06ec37b83f816599e4a2bf52e16c73721421f73fda869d06235c15a26cee614b7d9f5a208c8723d044ad772d99b649f8111df7dd773b4b4ac41a5e53ff0196bdd4faea309d544366add15cb66d27c42fa91d8bd30a645551b559d22e80cec68ddbc38fec80c0100d59a523e0d9dc09a08c97872ff9092ef4cf66df96716d1fceb4eb3c542d85321a37177fc1051eafc41e1e268257a04d05c8c6295eb62b7b9af1fd305e03c671a5eff4318d62be323830038eed3b2369172367dfda39cd158903e61e667fd2645ba3c87aa2263041a7a29a057c433e0ee63147b0655c209b622131028df1c7e8bcb10503a8bd8964dee27995ac6e5115833496007f2a66bb5067e5a31aeb7d2bf1d02275b34600a55bde183bf7bbe7c7586e480c94d649e9bb1b6b4c7213125693283e0980cd3a82edfad1075954ed1765be62f89b33c3a77990af33a034582c8bcc520e99c403971611b6a66a6dafa6a1622d0b2ee88e173cf71108555b432cecdf8e398353bac938c87648df80132517c561dc7fcab20e146a8cc9dd4e03fba04de69f03c2e74554c4a6921428ab61c87dbd9d63591d51b764d560da11cb11ff1741d90a43c37455149b6239e7da7c640209d65ec4b86f3e92839211d3ae8c0a398534dc494ee34dd15fa71abaa45339c3c0e6c24da32f9f308754bc3e8b0aeac27e620f2b9d59800c742027dbd05ea98b4b9c971b4e57d310030000b74cc97b519747a94b46f55c7433f8f1c60927f41292cc75a59cf6bf6cd86e1fcbe06f18f6bdd6b1c9a02619b60e870f4994435c58912cedc1df6737f72a1ac4743b11b638c8fa450ca32e0ff66b6d721c80d67a449e567472c4478fa09227d8a96355a42a06ec53101e67d6ca11cf4a277d924a344c14abc88015896e6f8aeb3531f7aec0c491218fc6eebb8c3ba5cc06e2b5877de76004bc9d2253c7a2bc53817815018c3d0a65cc6a09d8ee80d9c86237900c0cd45896cc2bff586fce4f7dcfd81c1ac88b3417fbd0f0e1560a214082e50412f9711af065711d7516a4f4b10e140ed28927579fd9a9541076d4b398d109126932f70ad5e3cc2acfa51541e1485946d045e4ca80ed35a3986438c49f990afa6eda4a358c09bca2c2d5d6cf401970c6e8b60bf6f79fc5ac08c93aa190b80fbbd4bb48ffc7ce9eb0bd2c85832eb3608c7ae172b2486012f11b3ef8014d49bbdfe7be4b1bd1b7e496c64c3b223637479c58ea2ea2cf4d1bcf56af127ac4c85ce014e82bb73b3c752f40e84e76d478d847cde09dd78e414978d8c1a234a0893b4f8b35363d55328cab9a3566cbec1f0528e354e492f628bf7d3086d21d09082fc0cafae519ad55f7fdfae862d8520b43a9c228367d79887c69e3cd69a633bbe18f8560ce3864220ad00370d15ede1709a73b18824a9a65cf4102c1235736e76f9b14d412c922bddc6fc7e81d7e146fbec81ae0c5a45e4f9917feedd578b8cd77b2cd14d937105f9d254f36705865cf5607eaba0f6157be3b378a5c42ac20146af2bf604e06494ece4a473c0c858f30ff9bfaf9baef1dc2517271c3422be438f497a3549ebb65313f1711b4054927c0ed04e76a1747aa05c2e3bff608f358456f76a4a6a9cf8680893458d67bac5f1d3d09e93c805e995d1b60aec925a3575c71fab03fc67430b0e7c7235fa9095249dea42fb56dcf1454fd4f9adbb7e0e4f629f6cfebb43dee6d3036059d0f1c074e7f335617ad81463cbeffdd8aad8842f23a85a37a93bafa7ffb1a5c2bcddbc1e972ac3ff538e6712f6c04284b86624cba138145d6d7dccad0d57411a5f7568cdc78b0fa650c1e5829dda62c240da20acb61ade9b6822d47cff99b5bfe43c84be0aeeab104dd1f834712d420238033af6966df7b0e29aa906440dd421a4650aaafdca89addfec0faf66d0dabd79535853649ebb89fcab8a5ddda24f4485a86a7f008fa9410bd24b25e8c71d6461e2c2814401508bb8cd14112a192c2ff2c8dd60fb9e180995164bee11ec40a4353b29ac82d06e0067937004ab4c6c1725dd21477974a200f38fb7b81142d6d0b734f35c1a7562efad59f9e7c880122958617fdb2d6a71fa2f2722edef96a3154628b4a01beb58f85552052c446ec54a7d9cc348ef22ea487b507d4d1b41b994827afd82ac2b0908f5b82a5896ee6d1cefe798d09d0564285ccd5fd4001433fbba9d8d9c2507dcc2b8f63b4a89302de8667e5b99a6ddcfe4cae9b624e71579063728196b6fd59ad184fe3508560b6d8553054f875417e261f6cde23ce3604281fd72a5fa5469a6cdf90a0c34ae4a85e6227ef598b559b280ec351bb0b721f0421bf87661beae38a44660250d91ffcc1cb38a8e045d71f266b0a990f1fe67db6ce517404f1f3ff004c9cc9a4cec7c108bd97089db6980f44d357668614bf3e24f70381548a493851fa2b447cfb86a17ec90034ce83b8dce7a7bf00e50ae91f1e389f3ab2cdc8832382860359001a9cbc1894c16050515959a757e945fd5f2e5b9639fd16dd9c4b83d4d387cc9c7a95703da237711954cc7f0d6ac1f8567a95f682ca469c4a1fec1f58a85d3f081740e18ae253cbe3ec1f932375701e33290e965103d8c32a8cab541a3f0c3500bad35bde88a5e5e785828be4f73236f4a675b656f09c5daff6a44d2bc723cba767d9006562dd4d848d4dbf6cbc649154eb74a7e5e8672fc2b50faee0f165bff9dfdccc2cb84e9a712fd8b41fd49402430f354bcc8903f3040ce00d22e3ef5feff83f760fc276720c22953c11482c975607d8ce0fe26e9807b0a98ba46006d2434932972fc17ce3442d94cef379edff05419e7d161dd116eec92ed3bff18ce32eed15f53d982cae8c5fc0b104d6d892d0fe67413dd631fd214f9e31cf5ca80c55eee7c765cd347670cf81bbb9859832a13dd747446ef00794594a9b5507d02ad839a270dac11a2dde7622363cf51ae82376099fc74c2f5bb587b0afb03f451d857df3b50d55621f60ac9e9709fdbd3a9f4ffd23550efd30465a7826c444963e9faaaaca356033b7d49fd6274d0d386a44e870446cab695daf058498d00f0b2af98665c85449e78edb11214c32a3978e8d151d52675a1902a0484f9268c0ea872c6856eef1fbcd5a1aa0461baa42892aabe3e2c17e9a6f627c4d85b2108de252e01ffcedd5d2b19921dcba12320119c8510a0d82de708f6ad67952c22c93db1a463d6090aabb16012e8071d3c6d37721f44e043c30bffcf2af18641f774a2b7cfcbba999b11ba25246dfaa0726c49503641bcdc72af90d58d5dfcb0c04072fce39505907bc530e336602b7fae0cc14867e5d63343d0c09758ec1c23a0291b4253eb2392c2d698588c43782b1a055f20c70f6b5bb4c75d6a31c6fda476b95e1ff9709ef91281eacb1d9143ae6d5bb025e7a1659679076c422a10cfbfd2e29078a8232645cb24c21b698a268ef49fcc7785ee5d50a1251d19d99cc85282c9cd2031df192da9588666d12e6481710e8f90c5ac9b4ce2cab5a352f66295deb68a56a90f0f00c248cf9d38e5c99dfbfc9b4aabf7ffc3bc13fbdbfac0651e8276aad73c04440bd07d0d11121cd5050b114a1bd1c84f81949b3835871cef84aebaf16cdf2b7567b124db22c53f31e7918bbfbdf7cd553ad1eed99deae1b67d1ac5badb8a77e3f28d06a4aedfd66df376b767a522b7fe3d85bd3658927b9dc995c39fb24aa7c75e0a189649f62468f3356edff7dec3ddffd3a4d1f4ece65aaa6adf8c88fba53ee625ec29b71863f3f5147b9a3e3a693c5c4f34c52508893526f8ba06e88cb98e43515fe2eccd878f3135497ac06622453dbd03baea81a69bb8019c655534c1216a1ec347582e015f7b12101746fde821ef409466dcf03d744e8b031c798d08e23f578ead4163f0823c34160d028a4a5d44eafb0db865619f5d111f38bd85a6a6c0ca8fe53e5fe1e0fac209859114577abc1a397604db3d76289bc8a4cf2b4861c08d78a418f29c3b027b88f7d642f062697c5247ef321ed9f398321c122c2af8e591c08aae5e998aa41e2c4d9ec47a7ddbcc6f704bab85b335919d94b27d4bb47c4eea8c25c738d9531621b1070b8ab480f2c505827f837e1c854b0b00497951280fac49a9d58aba6aca9fecb5142c09bbff9996b99dcfaa044bd6fcc7da851d384d64f8f2f84aec5dd10d6c92b0251ef33e965668a440fc6343d17f9721f605e061951e487b5ab6055cbe9323b9d2a851ed2bc377e551977895bf125fcb341f19dae5a8f3e1dfad18dc0f0bcd2f9e1288c21dfd90889228f242fd8312ebedf196cc64887716781b98938e8510a585f048b9a0d4ccb5cf814664161dbd9dbf0bf31e0a51ac93a5c28131452d0aeec741a0e2af8f5eca2814ad237780024f4e6538afbfa0fc718e4d7534eb3d044a272c1ea199176ce56535c7c86fc170f6acc21351f4032c6577051bb68beedfb5325fbcb54aa65526735c810b26c842c2aa9bfa0401d360008ff306e2572ad8c33989369cdc408706efe4c0066293c5f585a37ca911333ab58d2c919aa2f398cb8a21f81793d3697201c5cc33f35bae56c749316a44fdf7f90f6409d0e2f020158df2d9e8bd85588a1cefb81ca2c840e9aee544fc882ed58f07a7477fbeae4904be6bae181b0ac45014d860b390056daee1ab1e216b8589e9f84160bc6b6824fe7d5b7c6252fd73b141ab783c28a3dce0f2b10ae3698e9bb5480a6982a1299cdd4530690e0a9e5109cee4d497a9b97e689c49cd013ad6da50080f1abcd00ba1c70d5cdafd029cb3fcc2424a3c0b662f0bad8f341f461e1cf0ad40d4a8ec27cb39093112501660219218d4bb611e95c4a5295270cb6fa9b735faaa5dae0f3dce9409797a0705886ff7f68063e420ecc95c360489cf411045b1a4537a8e501c600b062958d459b3b76b7288a620364a0c9e3e96cb9d94943cd66db212185c3c48c971147597b70ab9510486d5453245f55220d1d41f0ddc3230d5485e19b24e8f8952da464fe2843b9eb0d3d7b923317269bc72f72260721e0fec0735cce4931e698aadf045eb3a6607ae88f1592b434630df2a18847d89fd8106c766f0f7bf231121ede11865a9758ef973a8b6faade6e8cd7d78ecad7d8bbdac98564eacb6cd3523844d32884c3aeaa46ec5890fe8d65b037331fae84b6237e6b8a9928778e2bf413b40194a445ac0067996b2a5a394d86b90b49de77ad1c6d5ee4c533f0226f01bcfdb20bf1c05d459a78c0d2efcbbc31519d17f7237979c5a22e3c726c05ae7ad3017b356818505d2b1a4b2da821a01bd6c08a0f33b5c2c48b8c070eda46df5201b5add295b313c43d85c7adc0ae939ead8f9f8e4b22c5c4cd61051bd52112508bf5eab73ce197a4ee2be4d9853238c4356a8a066ab7032e9c9ea151b44a7ef5c65daae03cb35a097f56c31d222d66b46d0ef025721c470e3fbac8e06bc7bf482c8af6a5a4d84f961dc9b8fcdd4161c6a1cfafb5d804263d320c1f10fd00d98d2b2573057d095dbac02b2a23997c4be395aecb8fcfdb3758603f8b31edec628bdfa229ada26c138f7c0fe46c0d87cf96b703877b331d1cd436947b41b7e5f08f21140638674400019445cc21394e20c4357108a560f3ae4352635913b8f1201fb325274d00035c1a2126af703878d3977a2a083cef747ffc0548e033c31aec3d4dc677fa721a4581d5b3dce5309b46016cc57bf329d3aa00480dcb86876aa95807a3fb2957d859811c4fee551bb6b6bdc11a289ed24bfedd1eb09073165a5ebebf206baad7f7b9a628bff5834dab16667313b2df42cf5d761c6b50415f0e43b79efaf53a8072d8f0994e920976501ee6b1ec355b47b865c00fda3d8c589c7862f2d2894c4cdf970e8641e9fa002f7e885e4c2623284422528c2f48edf8cf469dddec5c20e6999d79c61b44c947823dddf3602f3a540656b79a97490a492de7acc7259119de659f491a5a841a65e860f8b30f8e536c4783981053221f0a809aa731477958ca624b5fa3a25f548d1f89eaf08097abe870f91dc22126ba2512b9b3b523431646701255263ad964878e0da02717519ed3abe4d39d04eabe9851be77787ead760e82a090dd52c0990a88a23cb8869a6734346405ae747c14024f443d97c66f453c0a5be37869870d8643819ef98decd9a95e678503cde33810396ab0e1a4e34ab8e8c9e0db60e1956dbb4b577b8caa8ddad0f28e63431b88faa90852a3b4c162219c1103122746d0c51846e3249aacf6c952cbefc47642eaa0e78da1853f60a3db65d0b821c9b608fed16b6b2f7c69ab5111a6cc2849943305130775c0387ef7ce58221ea0bd2b136539e28f9846528b54d9b76e2d22fa3642732dd03efdf386a2b7e7f6fc1833e5eac5311f8a98d60c585821db8daad64330bfa36a3d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
