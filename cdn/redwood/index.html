<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46c97cceb3caccc60146b487b53824ba823d399bfd7191730463855d21585c9b1a9b5850f833a0b735ce19498f00e898cb5c931378b7fb6c180eb56254ad1eb4e9cb17602612c0533a6b1105b803f45974746300644fdba7f7d2b20254032b8962da9f58a50171597f580463757e4010922580475453610d1a41580b1569e23712303f6839af0808795a0afe3c1eefa547fcb8a7e01906575aff12707264633ce41f83ee0ebae4504f6950451b4aa6978ed4e268b303de5c4847259a06e864e6d761ef885fa8b17b01e796ff50527c48f6b62dc804da87c85c3269f275a4611064901fcb34e272d1959d267f6e88d91e895e4387e8bd28c64cf63f339a238fa794e272a232c806ddd89bbcbf58114f8bf390261c8afb7e0ab0e633d215e2c16cf7500d0405b77249b61e2543ba44d8f32032f62fe5306a19237833b3ab9d159607f0cb037cb0bdd26790076e154e820df15cf2c3cb0e22c8b9715235c7cb3053fabdd0e2156439b863d92f72544064f09e16ece4fa5d32bef7257cdeb908637e9788e1aeb97c7a8cc0a08ba1e6b6ca5a0299c12bd28fa0d812b1a33c9cf706ac921ab90bea28dae883de8159b36665cc8bd07fb12a0a125995f8cd42d4dc377c40ed95103d85f9aab3acccf5fee0965d9de156baf489cc625e0b21c6dfb0716cfff7f92df13e9415b951f1d42d77901a2f0d290521764fb7ae9d6a6f533890ca1f06f1ae3146e7df997fb83e5c3e687b9b144270bf18447bd432acd1054d7b1dc57578795a533ac7c979db6174ad8a91a41a5ad4a0ed47429ea7675ea836cfce6a96534561814fd8780aaea5e42c1f86cab1a405b97d60676086a3a4980408bc87266534d069ecd42776e9bfbb5957bf11db5b062318563fdda0d673876764868f05de865687700f73091df613a21d6b372bde2c9820cc866786c6e9349ec420bec5e34825baa155c3ac40958323c7a4e3675bf9d8cdcc635c9d2edf90aaae0bd58d7b2f94b1169115ced6026ff5894b3f05126144535480886e358b9173a3b3450ba9821ef060bb33b685e2fc94acc740682aeefa18f442d58dff9cae34e36af2ea7f6d27e024b94bb38d8cda3fe16dd29f5159d453e445796dd7f8cd55777751b8caea4ff92ffc455c1c00389e6d3f0ccc9b7a459788aa18630670a6c7d6ab1cf8ea77c99cfb6e7058e252619c507d8cdc1d93b698f4ebca9922d027069347fbba8aeaf43c00ab435da1af388ee03aa8a388ca04fe86ecccc4574612508dc2d17bb560042fa1c056bff687416bea5bf249ae366e773ef2a3faa16dc1808ff3c073a6f53dac2aac4650c1521633ca88cb31e62f3ddc37f682cc10a107b1d586c10abff1dbcc17c21dd4f1b512a32fd1f1315ffe327251e514890d8d3436d2fbc51d0c8b189995249def263a0fe5a5fee1e1d6f5750630eb279ea6331f3c66a4557376da159c2affc573ead0552c1a1562b7807e7e732e391e32d64d5e1d21ea8bd77d20e4ac7ca5f4fec09f2eece7be2674e0a1424b31b71d884a109fb0703f662c3c36b948a8c6066df950d6776296b571f49dd8c7a8548df5843bca3a5ab369c795a7716f7af1113efa1477acd591820f61ba4b2ca2e72e83bf8e0d1f29ca1659c5332b424a1a453d5acc9982cedc09ae1b26c04c7fb80f90c69480dc4e68360b7819fa3399f83b814c210c7864b97be2bbc1087bfe92fe271b34b0b37557be64980fe5493e533fa3e1bb41a3b7dfefd5b406f838d1402b28b2dee1beefa3836f903ceb11d334e01130195d92d0e5683587e6f4878fa90e388206f815f93d60f663f293d6dec693ffd0010d6971a252f0eeaa54958819da347a5c6e6f5e0b94e411630ee00bd13bf59bb7e095b74c208e2fd2c301636afc0d268a6c9e0ba5ed37f51475abd3afca995201e014091f67a8545a7481d05119eee6525d55ccc3432e93b08d6b6de99bb62e4587c8e4b889090b1b7248eaf269da9a8614166c80899615bcfcc8ec34a1e0e79e3a161a70647551776bda1201291d5398ecdcc3ef51da986c1610637c1b3dc3f1a9b646292a3027033144ab1d154408a5d60a15c13d66cc8e2d81153d2de8cf9306d44bb9cccd2955d7dae26d87b2ff6edfcb2fb25b0b449db0754fd09f9e139441d5cb9c2a8a514853b5566ba3a26a67c237135800cdd04afc46064c6e9d2b61f0e4eb844b68868656008256bc48378ec480261ff6604008e606bddcc4f709f2698348f88ea7c98de0491b2c3f416f7c9205340842aab9e9252786be04b27c199a88576e3ffe1b11d887f0e21a5fab3a9becf08e71eb48181a31b3897a2ce4f72b62474b9bfc68c59bd44693ac5659599377c2e7be19794609c5fa028dd29d7277b5ade54e038f7d4104f53f7b01ac704052375c2f3a8c412a589ff2db75c8ac3e9878cc3b3b81daaf9af813f74b186a19ed3d0fcc381d3341558d03f5d651ca7e6e3b6bb4c1a0df609d214e86d9f67bbabd6051757d59a5fce77d27cebe48937a93670a385d9283425161855667d335302a6c7cb6a88b343f919f52de35043fcf44a04397976fece0581526207d810fb26fe7e7015bf788132be461f98ebb52bfbef3feefcf7460136dd2498a8b879d21a2c2b4fefabd23eb19443b4dfd5a381ad9a7874937c8b733f3e2a62d4cdad62718939526e47ff1a781c1f09cfa70c0205e01e5e403c5a80faa9f31ab136d1628fedf618a7f4fafadde5ee90b8e30dd166a5b6af05712c7d23ce80463882c49ee9a47d0a5ae46158981db848b34adb42ebb308740bba03f129f962f414d2456ae5c44282c1166c4b804489b94e2514f1d57174e19aa3b454a1f6438bfddb2f0897e9053b2d92a9602967bd397f69e647d28059003b76b750f1cc446b19c2c4d3867d3d6594a79afae6a762fde9c47abae4a0e57d99ee957a44799f2eb9557e97f94b4fab950eb9f6fe4489ff566fd42d22239774c7e2304a73a39b921e3dca9e15529d9101bc0eda73be4643ebb03e12bcecc62cb90504a4b4eade55da9ce3aa92c15a561d6436a1687f5c098c7267f894852b8fe4c5b2d8b5d934a3b07b7058d6dea90515bddccbfdcf2077731df80efd68c593a05663c15c6e29bd29cf21f610625c24ed339359d4f15d90836f4046bdd16a2113581e7f255c14ab7ce20693a5c6a4f2be95b0a69f30c96527cd4f45beec55970f82f33076c6a74a26b5fd81359471d4be9d4df370ab08faf76378eee972255f9520c3d1fbf4c6d5e1e64ecc1e1abd2ad225df2ea56279ce28a03f18df3405385c04ef33961b37ea2af5c3248fdb82e3a04c2cde6990f2b8b87f99eaf6c3cf031d2dd6c1b1a2f23c6291f8b9afb39148163ee91175584cca598cf99fb303baec091bc18d35314c195c6f1367e4b8c07d0212018144aa3246cbe57bd0937af7ad3e64dcabd0ed2fdeb8a6677c70bb119b2b6658b9443c1f9e2209bed6a35743669f788e7e020a4a3604c5dec35c2dc900d0084516f3ed8f938219032b6facd5ed8b0b54b566aba23de09d2f7350d161c787ce4d9f26ec56b1b1a5f6222d0d3aceb66d9dcf75edc4ad35f99c12a1b3eb4fa5d36294a8b0ccef8d4a02e2519e658e8694f3f62aee7c607d3985064ad4b302ae02edb16bb6fde45e9d0731bfd10986cba83f0fa72a103702204d11ae8500a3731462d9622769ae4a97d45ffd5f86ca86a4e809d6d380b74d4f3aee9fa88befd8284a1697b31075cc0ca6051f01e4cd41ab834a80c5c85689ff71b507ee868534ba2b7d47cbdcfea6a2eb6e13bfffdaf5bc3c3e61993aed7fe7b4fe83a2a6e247b3a4e6309602bf4d46a6e4a81a9da0bb482f924d4a238ad2029c76dfeb9fab904be502468008a75bf9066877c24c2cda624060f87b2797cf46fe3377f1fb9e83e2bbff3dfa5a8e61e5415db754a03fe4e7fa301f9ddd0f7f5e2cb67f6bf2c0aa94fbb969a0d534668a441f1a2fdfeb3a741904783f10f68ed58bdf36dc6684b2e54423629ea7629a7b7753bb6558890402e9eeb00e3aa0de040354ade77c95e638a1e99600b03748862fe15c9b519ff0f9a1baaae74b7dd0c02a8676e0834e0b4c1950b7559d311ba32af2c97f0ac97266d10e20ae82e1ee1c2108be0abed8c9e4e3c7f937ed8c87191f225c3fb29840ba6a465026af64b7107985ffa7171e16c47eb28ab62a3af0153ecf952bbb030ffda0ad024510c8bf2185e7ebea7f47c109afa723add9657587003564f01fdc2cc5b3dda3de6a7d73ef62d1081af14fba0a06556f2dd379bfbe617a55378bb1fc29b2c601111dc1fd58fda599043954b5b72117bb4c3efa8fe86ebf893845d0e97b193d898a1042b0cb0365a394d63c6644e56453d0299211e3debb9dd1927e8e10fb3f14cc045af6c7e50607a3a18f21f8f4104f43d2eeeeb8e7d9905ff8ab6bcf7c4273a50d9ed6aab0b7cf28d7aa0b3d2647fc968ecc14525d4e6e8ecdffc3c680b847844fc8895d0e20b2561ce5b64508eb1c20bc2d3ae1e6a57308194e96bd7f132d697a29b288666f78756c7a6ea2f3d7fb55dc67682f12e6a18643e4cd383758fd7eef22ae94065f775b03e56ebeb176b76289b9a2b34b0b2f22aaa7fdb751bc3d106bfad6687058d30adfbc49bc1dd2c6cff62151a4e5074b5777db11c87c3580fcc813ecf48234eb067ff112cb5c18f6c8e75f457e80cc824fc49893a379db17d6940f7bccd89b81ec57a44e1a5bcfaf7b8ecfdea5b60d2340fa45da467cd936151a244f360367460f167f8e59374d26f4e69098afcb2122c9db7c7c957d6e9e089dd5d2c8a3170bef0508209d992249ace340d2a5335b6105fab7798d70283106d2dfdfb82c276ae490b329a341dc36f66da47df4feffe2b9c2360d675b054cecb7e240a8c482c95b31133a4ad7d520f4208b083b147aa2ebde9ae3223101aa0f66ebc20ed46a198592a53d88e54c0fe8d00bb7bc854e95a2427c722e480275c6e67b9f79b53d87e25ca5346769ac6382e51c5fb8dcfe4556669dbfb48ce0552524e9ee793239d3009a847319616caae9284631b794420013f15a10586df5be59ad891bab58c3afd7ff32cab8635a9c44af614683df8b99596d4913fca9e8fcb6a91ece30125e298dd7c3066e4f56e63a4150f6b68b3141056b1d66532a7044259ecb21dfaae77f1e058a9e7523c5f976e1e05fe121a97062f6e03c54fe9a072575169b7da219db90cd647981ac70ec334f71aea29a49b0c66efc170466d4c15a0ab8cf602e9800e91868b9cc84d40d3693e8db1500346f43933980c9def7f15c8a9c6a9d04d61617b8dd048f9d4519621ed198b3280c5f8e8665c8411a6a0e5dec9c1f801b0309ba7178ff79ff9548ba7751e4083b016baf5fc24b223b771c75c9520add4505431d51b6e24db79282302c598370b13d045c522974e6a5b92c82443e5633fb520eeac4b32e8859b9b97722ced528f12939db7c24cc3bde51057158ceb99bb43857bfb8248157238bdcc6530bfee70bb8e126c57d288a4432378926823648295defe5b07c853c908d42c64010f60998b92dcf01535469e3d15c1b8058526946e05af86be417f30124c8ca23be7cda9c4fb2968dcd01800683530de0a9c3b74d2f2399ee4919626d3ed4c8700588dead9e0d9f687d7e11dc3eeebe321ee5f83307f2830fbfefba9062030b53376a91b7f3e59c4ed76b1dfa575be80be2b135a4dafd2165f6a678686aa3326ace46ddcfb9067a1bb7f74c228c7524003c4143630cbca02d2e9f1f9db6c5e6abe8f1037a789cbf6f5ed429482d86e7050341b766ac9e4d8753d81adeadd253d12636fc15a2976429991a82afffa3fe0ee60092912c3d83fda827c6754934996744b5744d6ae1b85d9c3d65a649133bec9b9c80ec39606e721c13a60b283aab9b304c2973de2114fddf144a653aaf77dbb720908bb9c3269ea5dd391d82f5368b89653c7c9c0ff6e06d65d8b4a62778150a1fc8fe44618c5169702ef66b658884ffb1c15ced9b56861fa432ed3db7330e303bd10d107de699995c4b745068802052390e2add57348ff0cd7e098a341af09e29e54cdf2eb9c9a15dc7787ea6449e566714308b4b5b8f1e68752c04dcdf62abb12118f8b00b47f53de8256d9d414e3c102471a59c392e13633d82f9cb36c807cadb2bc5fe5d9c873e2dd1b4424ac3c70cc6097c8158e52ddab1e84ce3d4ed4e1486856b0d02145b66ef95f2999c096f3cd89580ef32d374b675aa63d474eaa1ace96ef47ef4030e2fea5d3e3fd71b3a8639c442ad6596330aaebfdbcf22fb409932691c3d0812cf4d9010fbc4c646f79ac741535654a0f8079e3445a60d30dc89a19460f9b1f3af50e1227846f7efa5d082e9f396121e719e07c64bc97867246ef3242ce0eb388c318c8e8fe35499ded0217980a341aa2b3e1e3c1a495ff9b0bf38af78270a768d61afe9d175d824e5cd0335d2390e1929f0c6d56660e93dccffb2920cadacfaffd3fafbdb59f4c71769fb2cce7a5c29c5e517ae8c8ece26e0f93246e92981a4dcbe72c499cd90b6cd3721643d26ac5b88577e57ef3f28aea7b80d7728c54c10b3174b72e2fd169a5f5b7965805be3e7f965e7988537671fc8b63bf70039167de3c28bb997d2314c6aefb26e7a95e9b98b48d7b7fd0eed5976b5f6561d594d648ef9d66752fc5784ddf16343ab86a79f6270f83cfd7235e509bff04d4633627342c9d598735b2933ef4b1419bc68be642cc41a83c7a248c79023292ca1b19c93c77aca33c288210d1bf20b7731a3a7f0e36095b5b4e1e76c9bc6f315ec037a14ae96e7e5b967a2bd6a41e1358363e79ff2e1b0c419e5bc22ed1cf1ff54e9d8dc3c917fd8259f949695e32a44853530f52ed708f40bc6ae85db849161b7438bc9e2ab4141103a59bdd1f337e9e68889e18130f45938bbaa532e610598b0916ebe0453c82765e6e5302a7134081331d041c39bd200abbace2bbbf0755abbe2a9f35cd33b1b6164fc73ccda5e20c9de2b579fca278523d6e8f9bf32ad788e493b24d76643660a45eee983d73d4b32e821b00b33198aed96549cadd0e230f3d9528e4f4419e23c95d84e0c85d85fb1f8a0ffa7f5722a77e4269854a687207ae4a4b4bdebca673f9ad8f34d1a1ad70856cc9c81672bf417c5d878a12de459effeb69c7f906d0f49d32030cc3243fd3dac638227e89982b093ccc9e9de630bfce88c8396a8427f777702c41843aedf116141748d27e3b3aee91498a5dad19fd51c4205bb8f905aa49e78d48cd7cb7590d5f13868187b668b1d6ad171167aa5b9d499608e7f5c37b3cf9d908016878d12ad3f052a2d04804c41a5c68ee273000754b30263263757d6302777712fb3b20612286b3e984a1278523b0e810ddee4731b61e9fc56c26e88d7cd332dfbf9cecce28c3956ce282b9f467f01324f7686fea20b442329221e15354b70b4a750f0ee385cf57ab4f7400eaedf3ccd34f5c0620e4079c9db47a84a84e2ea0c5e54360ac14a3712be1383e1305b60abe538bb62e5c85fa34f0bb21a8bbe00142e03ddbe2b3b71a9e5df4dc2ff8f269f1ba7a4d64239f7718b66adbf39304ffd1c01d6b259bc4273f2054ef7a1fe6f6afd356d7a2aff9755cb65640fd9d3982a6673522b166545b6fbcc79dc45fff04e42c7764db02a14248e46499338772e56243128a57c8f455ebf5d288bad2ead393c40b57f62715af3d46090d7f8007b016704a2a5548edbc79bc9aee99f08ace08f9dc58b88805d8eef61451d4d22d3aeaafcda8630e7c0475b333308449f0cdce1a3e52a65f2984308c0213a4511e26f6c957ff5895127f1259820e2afaa13f6b8c7a3b742fd33ab04781cd23a163e3d71541baab680724e39e163046fd93608d3079154d5e8db14a78c737610ad30cafbb9105633a2221a5f3df2ddd82769028cbccfefdeaa50284b1365c536488ccc1454c00ecb60879d4d5d658bff673bb794acd892f5b196256115d2ddf045394d7270d9069c51dd31edb34ef2975673970aec61cb4f2445551b24f98240c4d2749fdbb3cca637847d752569c42d4276bebcded0e140b3792d817dad9766262a92be8ebb20d4ebf74d085e4424e3b654f99494880255d0946a209d8d25d5fa678c3827a8e9c7af19a133dbfb7dd8ebac552e69b05dc4fb87067a02a8206117e190972a8d61955b67c46e9aa375ec529792a9050f5f13b0960a4dd3738c8659339a89ae1fc0097218eedb2ef0b1fe4ba41ab6d7dff090a0d73d92b940d2188f429a34aaf8dfca1956d49820949d6e6196cde88cc39417bbd9f7a866371d926c7faf1ff17f500cde37ec2015dce04484ff11eaa48a1d3d09ee8e44d85711323eccb3709d8454df9f6932e926d5c5ad110961655c676f4f652600af70682b44f165741b2655092ffdc12108b32252675753f5ecb3f62c62e81566748f5de60f70a6f2e0e8bd58803321028b8598db46a418369fc3f2db7b6b8373818655dcb9a2e2d84eb25cad230e96cc2101b6bb5907260aba4a915172bbbaebeee9da1263bb8c569ec501faf6e09d6c3fb4f54d704f0fc99fe01b58efcf8904b6e61efcce023cadd64a0d1eab4863b44bcd0de89003e1a5975d95e7efa384b483a06022ae579409fa6dc0e65e871f93c50d61c6755a4cced6d353970cbda6b63c5ff3d93c0b55dbd9eda08e4cb2160c8876863a56ae80a3c765e908952b16cd2153464aad1e940253ea144a1ae7f247d94fa8169aa4ea0cd978efcd6f93aff79966f76c70c32bb05512d238fe0e0cd02e3919fab1334a422e84e08dccf4b369b42c0ae23e3e8e7c4d983de202397390121888c083ad98a9e007774de7b014c00fd1dcc7ebe509faa42596d703409fd929da99f2af7f58bf90ba9ee688507adf6c8a6b2654a571418b0daeeb3496635cd4bb0865a2dacb5ba75c9d360a8e90d4484bb7fc0009ca934b1f4b161d59ef45166a290cd8a3599c25d0bd38e4c512946548c1d49387067b53994b188a1fc4fef02b4a797318f06fd93eb5c107c5f5c2cf75e569124cbedbb5654b43805cfde49ac25409dec4752969be70b4e2970052e31cf9cd6447a5c80b4a9cb8de642a03f4989241514e5c8636f33dabda3c95cca2220d37428f827625970e3dcce6784f48e247865a8087b1fa4adb81dc189bdcaf437e74998e4a12853dbbdac4acb513e1bb9821ba0bbbb40c0cd942bcb9bb50dd55121e5a8a3b5e4946beb04553c3f57ec22589c82b2a2cddb75898045710adc35c813aac1c864613390027cb275b42cfcb73d18b38a60d69bb2f9eb5535cdb8068c784cafac6a96ea9ad3e2913cb9eda71c6d347a038f927e5fea1c8152138a6f70e3507b2d9858e19b0a036db97ac7907a32f9d94c1ed420415bc639c4415fabacc51c67083be38967c3e11e6c620f3122fa38901e81b86e0d8d6b2286a6422d486282d8f06664cef7a9a63c7b2b6c5c2fe0ce963543f804a7855dfb8b1d0cab1f1457dc5e12b4263e039fb12e3ad5bce1ff3f4ba2dcb9008028dd746503c8bd0fe6a03989c1b19061ad9d146b0312bfd681b349fc889cdb04bef622fdaddfdb57c31387bd7af27a195ef3dc2beac27dc6ee8238fc311ab9f02895c3af39d2b493cd66c0dd97aee3672aee041ecec9eceeb9e143cc4a74bdc3e351387dcbc61cccea15a8d624428c1172f436c1b9a958792a04d5f4b2a3cf8c059d0f00f67fc8dd9270d6e2884fbdabb8d9121ab9bc98a74bebc99affa1657cf7d291a55499ee5194ae7c141562aa99b7bfd14ebd1f05f27716edb6a774c9abe1a3f02cfd3ab63fbde2a33c890da53341bf5b226076f513ee20482e701d1ef8400abe2273a572f9c0d2c509ec657574f84db60f85e5c62bf322950339b86c2e5f5bd10ac0a9f286899228cbcd016fe88b67ade84c402e8f49e94e2130186a10598505394d651b883301ba9b3e50c0b69d44bf6fdae6ea300e6a6645444c7a9b42c0bc9e8ff04099d981a93c757f4ef4c4e7624d1ec383cd8467bbdb6c48db90d74f0fb5ed00f427dc6e6935087a17022ba0937c508786b38a3f93e48c0d0cdb4ba6f9943cfa27e35bcf55e8e7dcbd6fc8f303547a58adcb8256df473aeed803724b3d0a3e994faaffdeadfc01b0e9b8e54f39632fc5e7e7b14bfeac7bad44205b594f7feee509d913cd42129a318090e581487640f5778f2952c9b68c44ecf53efd07be839f5fd24097f29d0a684d45766338f0283e0cdbd50661387c435cec61a694d9549ca99dec605dea8ec33057d3de9b49a33b0e9174c448da17c6cfe712ddfd579ab0f23809840873e323216c007524e841c3a1713e61f276d5bbf0a66bd0ded217675cd7ab39e09492c42c9d4d6192f1d79a5c70042875eaa48631a1396fbd4f73d0984cdb177f30fce87fc9f7b38f04ef9f906573e91b5239ddf0b5bdccda2ce4511d1e95851121961e4b7daa5b4525d7538b38c9704a7eef1cca310c83cbc56487b78cb0803ff0794d874cabde4ce03fa3aaf6893a96d3604b3c9eaa43d02b3ab676d6272769967aa1b38085e7f04da2656139e523b0faeb1b787e309ac241fdc052d90ad6f7a738704c34be60c490b31d1e0e825eb5fe6359b419816005abbd2d181348cd257fed31743c0e7617857ef8837552436059e67ce4496b7b310a0e9a51eded8aa221344142d9dc072e4cb834e787913af37eb7ba93f8fbc27a8a977a0ea8b58163535d670d8ecd372d3c7dca8bf4eb120b25d78a10e999c7b580f8bae8588f80d67f5969b3942d531315357fa9945ffd6b3bf90d7bf2b00e1369c651d9af46dbf3b84ae79feae9c011cb3f8cf3238449da66b0aaa510e8a1a34e4bb3524ca72bec82c246bfe4a12b995a13627e19bee4090ab6339b0ec00c484052ba70e3060ea8b6282c5f62e545677d82c96f37ec403ca62b578de31282bdd96e30224e915bab1358bdd52099c181b00ce71fb41a3cdb15129f2c59bbfdda24b3b023b0383d807b00f8cb43a79c59df3b6dc8c43023c908527e19642fce9fb8464739b0344372bcc3ad91bba622e67d0552434dce87d90cf37702d1be0bdec0faf253358ca0cecff536ae1fc536c1da407807df6461ee58357e64966f935260bf3d2678c289546f8b6f40c747f987589e92218a231339e97ce1d6c30354faced8a48c38807c6b41172d4be592112825a391aa0b04c1df9428f17d0b9ec27d8638d25acf44fd08e97cdd9dfbfa4e1847f05e63f8c6b3f9ec3c130cd9cf09a88a26fcf982934639e0a367cd3249487f983c2ce522893f9a88338a7e264804eda5a46589ed7901dc7936d26847446b1a6aa265e9704e9d080d368a10300ce33a267328a961422fe9bada75173020cb138892948f1a2ec3d022d4d874f68baebec6121408b8a72fb97581f9e6e03934ae83d2deda2bcdc77a1fcbf568b11e60af6d8a8e753ad2a820e59d384015979edc8fbc3e6ad862e0fdac73a75423b5acee0ec520a356bb4eb9bef0ce00d24e1fc1ade9597f64f8b757289e88108e74c5e4b67f6546ca5e864fafee06b7656ebe58ecc5892883f234a99686d9addc4b7e2add9241b62a1fc393b526a3ea9131a126ed48110968a7dd2f257149c84516290d61b0dac8268ab2ed5acb8f3693f570fdf27fd2ff7cd51eb34e62e36dc684c634d30fbcb8f739130f5d876544855cbf37bbb2ec4f01ca13109b6d53b373cb874c7ae769239af2b69e07628463aef5a910e7b105d0149a42c5251448460b59765f109190fd76f2536f97fc0e7c223bbf541b92566fed6f7d74e437d1972b921251f3eee1614bf5bb978342a6dfe0797ed1473ee930c8c09430e81577df16a0abf6c3c11054432f94da44cf6e1b430796654a7b6f4f59677fe0337edadc715618f019aa506b0c922e4390a61072d39eb11b8f784dc1169b4dfd74953a78351d8b57d0debcbc2db3d091d5fd76338e4647a894f0fd5ece6f44ae8c6bf525e85858a07fd757fc67ab5746e1911e546d4bbaaa1f291fed7cc7ea08e6663f87e159bb097d5580281e3fc7bec359d339cff98a0cc658afcb12a6c5e7cd993c7919df68823098a3469d052a670c711f47f2cb3b67759d1f90dccdce2c0dfec51ae040ce73aecd602a5be8ca06e6717a3caf11f3a40b02a65d214fb7f698ff9465ecf882b076632b249ea0b580414fcd59422e4d65bdfd58e4527e48f1b72fba0d07130aba8441dac7ca9157a98ba139303d932da5155ce032527d5cd9ab113d24d97d05318ec77226158aa6b377c225f1bd746ec54946d4c9f844046add3f021924aa55e3d6a0be755921f5bff435bd5c5070453b0cbab6e5ef797922af752e5ee6364e388f5c64cef0526eb470559affcc25188efdc1eb83a096f7411fc07556b5e79068b36256bb5ac9775acb756bddbd45f9c5a7ae50f09b7dbeb644e264cf68a891da3f7437cb68988c138850a4ce6b10b554d03a0a55bc544fa19984c7b38e6b9a1a556ea0747d8e7a794ec06d35ae5956ee1895c41251ef5467c780b4eec3c4fa6912f1ef787ebb1dad168fed6950a6241492b03a139e5244cd2f99d2e6a10ee767174be997bb409bedf7bd3354662c0b840a6f980fbc04d2cb54c81595c2c07fe00d93e424f2ebf3e876397cbc58ea27919f330b67cf27279e6656ee4a00403d58a67a50332172a24b6a15518fb3590a2c757f1ec329b4253ba7da400cbf975027e9186235ceff995b53ef980d02cf99b37bf7fdab290f6ce0fe32d59c927f8815ecdf5d4a0d82abc20500b1e616f0926511f950e257d44952cba02404e135b3075c0093cc38f86e47bfadf4796fc08837be0d2986b1cb186cbb550c4aeb8371f76bd7b0a91487e5c547f10c684376c21267c183644e6f7c532533b1984b8a1630552804ee222e5d2202b5b30efd20db5149b0466227d8ba7fca767c179147d91a06c2404e00c921c93775b81301891d6492184cb0c55a3331e1bf6e0191e3c5b2b1acb29ae91cf2a7417a0b7a35bf32a6fce06e93bd26a23fcf64c629718c1a202843240939f0d11f1edd93237c41aca3fb171bad78a2449be2f69b943c7ae3ca3bdacc5128779d06c773a922b15ec87ddf45f709807df8176c044fcf32dc8242db9d6f318b65082204d7e44e1536c579bb798e873af07c9b353c8beba4ae1def2b53718b8f85ad85dae0a1a8c4e27d15fee3606f68991798a4c25a3ec276b24d32d8b66cce9c9ab9dd1fe848fde93518e23d6b85fde2f00501a0e524cd7e5d8686ba43495491c095cfa8334cfcbf2abbbf7068a01e6cb9f3dee00a1d0666bab1e1d0c19e695ad14d822a3e5ed7393c7c5937bf64ddb381f7074e02381f0004b1e67cbb577b4a43bf05320f7498d2cdd3209e0509f38c083ee1a97c24ef515a70384c10da499b675fbc58090f96303bd8bfb3467de23e2603da348e683d8f86e5b3471e4bc5231789fa12e7e9c40dfec53fb76f14ff2e5343084ce2d8f5d97e3cf46fed1881a0ce2fd5b142ec185071af39a8ccc34ffc6ce2c59be530c7aa16b92ae9e59e3ee4b6cab88b717584f823af466eadc3a2db4d19062cff53635088e34e175d36e94ed7cb5dfbe5f46993d70464090f9a591d44cbf86a5a06a65c5238ff1a4ba5f3b3fcbda8cc4cc059c173771fb3d8faaab2d29a74ca23348b59b11c5711707f5fde798d8325543e32d58dce1e79486b3b5386c329874a622e323eeb1cc9d598687ec4cfa6c61b861dd7ce3286e5f7400dca638c0bc57193b77a67d71c94641b159abbeacb79b613b881ca69d6669b5d7ca1f6a52b1547237a6e8dff65917d86d48c66ac9cb2719895672ee4f846d4c06b2515b0fff41fcc74007807ceadd7e8630c9321f60b38a7f42788aa490799a15d3ab7eac18f0dba055c762e4504ff28d8e0af544afd92ef931f1fb23ba86bf75ea6f07a1c361c26ff6b9bf97cddefa8389f11379749af1b6714c8a7d1b9bfab4a5b0dd284425691b3436d09f895fddfe4db89484a59b6931348b84675203a3b5d99ce847e6b2d7ba2fa89415529185d9aaf06fe08e8213ce3650d8bf69ac6db929e98a1c1b7bd82957bb589386e552547fd2a7ce33fb053e637ff30465baa63fa29c8d504f5fa07c3720c09b9716320a35fecb106d5ac68458f713290a4b14fae4bcc5f0bc36aa6e8792c814e5e88343409dc226e9ae1bdcf9a2ff963bb326847fa7aa1f205fef191d4990d62551a7ce97691d82f52ca71e56c8f1edb48adf3112ad9c46c39a87da19a3f632657c08d34230b38ba3891b18290bcfa0f23b9baff19b3ea7c2494c57c9fde3c0b5e7708ea4fec4c1f0f4e474ed3bfd4619bbd4d59034fb6d075bdc60dc861d016deb139acb0b84169fe89dc9c6d9b67b23d12fec86bd95b531afd863c403f6c4b2b890d26a28242cc98df6936de243c931d9d78d484fdf04e4238c9c9809da2b5fcaf0d614339d5b9f7ec09dbd0fc8ff3f576c807fd6db318c4ae029ef0cfb7fca83fa10a4caa6bc9df7a94c43844aa0f419b8af3146cf52b7a7a22a7811e94e6c8ae90e5eb93a290f858916ac9fefba37ef8f3290588505a27e789eacc93e59175da34d818ea022e862835a48060b60953d78dbea3f5e932ae413e9d19d5114175e43c9b301606d6195ab73f4573020be917a6b49210d1e8af65233adcaa7d270b9822053fd3066fa1d809d421e0bf57d31f8bfcd1982e09965fa110b53f0e6d5d39cb4fcb270da87b84156db0c33e9f65db9b2d419a888a4cc709f3547b34388b8536156f69c0c017897c4e861ee814885249dc3d530708b2a76746b14ca7d76f129ea499c6e5dd39d5427506302a643b8da2348447ffa5b6491c341e5794412a924254d86a08874942262919966ffc8d5db5cbe96794790512bb086967007480237bd316ebcec3192b6116c52a837ae5d39beb652c98250bfc4f8af9c1876866b407cfa7ff21d0c8ff1bee4520f3d28e0828386452e437cb22302b01e4fdef332d1baf9875b6e2d64d12f965d7b5ae81a4b0668112dfcf66aa11693227114768df5f91620c13be50b5ff17d632651749a24a633f851a303ba99c8307551c474d8620a31d54c4c062664f81d0aaf0b63282ea4beebd5d760d01d87fe09f4a708cc23e981aa6317c74c70663bf3b31714c884dedd26cee2d86b31bac9f92c4247b01d4d84250193e170f8b51499408386ffd9a00316ce5259b58a955d9ce9af87c68c671dee128e0225a6a8e3175570a53d0fea9b5bf9c0f20db0b6b417d27208a40dddb9d225321be78495e6827c6c30222747282597478c8d3c832262b26a0f8e8872a1ae7b2a0b9f3425a50c62a3ba764cbea9ec778b7ef3d138769e09be795979152596eba0ee8674443ce40e2dbb62fa8cf47a41ef42e2e031b58b9a926c893b193d624395c9afa32fcc32382fb66c18027a4342b207eff1c7c3875a43f782fa5b4cafdece1e459503fddbc56a5cebbabbaa25e875ffb80866e43d06d7c335d8f928f060f8e4c2642b1be8dba22a687a33406ab1cdb500aac5e1528327a69ddfb4054ff153a89c0f6da8f4227b2d254b0897c60ecdd4f6013c06e37b4e1e67590767abfb5a3ead50c00ecf45e96a71cdb55d783c57ed1c9f3e69ba50c61f813030472229fd5b6de23e242a0b0952ca3aefe711beea455662716a8ab2429fa14ac6017dc51b2e550feb4c1edf6e2b1ed0570052437da00e40b07c092afad99c206f39c0384a04eb3b266e8028eecad58cae67a0873368d32b00612de9e17a9ade63c642af6c7e141e43a6c7ae33b6551bf5fe9b57cf6e881ccac48deaa5064df627a42ec026121831103012ae582a663f0227c6239c896bba710929ecb29693abe41e730ce90691c16df67a77a2229062c95c492bdc867ab6e3b4277ad0827108138b453dfd2b63eec06d286f8ab191dec810f060e558b7417e340056f860c5dd277bccec61cd1a95fa69bcef083073960152709921a796e736bed161b53964023a06642d4c9947c40b9690d72cedc5ad13408a383638594a23bad811fa9cc3afa4792f9a5f948ea10852c15d091848cbe0a3b99110ea4d02720d9f2277666017ca1fbc47da8c530f10b243d7dee3bc5b08a02e500497ee61b2060a38b94c5c5b2798eac2f495a4a635c06cf86540d45e6007013fe654188385fb7b901bed43783fc1aa677f4589b237fd6445276133e0c2357274fa4d09943c155e3c574ff97b2ac44a013179899ae2d85f136cff0263e23ec11603872048a776c06a7cf97bef46f903b5983c14042ce7c2ee6f456185b77c6d32d07f65c0c2ebf0504adedc358a1bd68e6b5c4c093ba7433fafbce641264c668afd0b25853f390581ee7065254a04a1c48bc68caa932b81fb03ddeabbc3ad5467a772c690f69cda3760a8a34520ff9e0341983e004118acfde161586c528bd216b62fabfa6e292a957003257f761dbc7d6bd6c731051732e62e290e7304ec747ec6588e7ac659e52c5891294b6871f392ad19a74444e9caba11b1b8c4cc40f1b9c87371d2708ca8fc453f533243926f12374a281a87c89c00bd470a15a09a331ec6df95bcb8e4db9632fd4d885ffda6716e3946f26abeced04ad60d927600420e8475f12d25cf46b48d50cc1b1dd85ad339a8ec37d8350da5cf2185f5d3ab0d5d54405ca40c8b9ca99cc779573c9ab9a8f36224affb7cd9f91a8c4951324b57f07cfdee64356fd246cb946a0f436097fce2819f3819eb349e0fccfb1121a4195ed6f51df69d39c01bdde06ea335623357770bc86efccaae49e95c7549c4e5921a5384372032afde4770eca776687ac23ed9df518da6a07ca7a54efdba8ff94f7e368caf98976358caf789dda46415cba1604099f64bc760310e4b052c033b78233409564c7a305db10e8a00e99971fb2ddb204fc5f7149a511984ded1458279c1ffccb925ffe03fdbbbaf2f1930dc65be83bb9a950f2da943768d384e07bee295f47907563b2e20b4e64a1218f90e8f98552ffc1995afdd4f21cea99e64c093386854b9c7fafd826a3c4eefda2257ea90d29095b2e0b75ae77f115aa3491c1fbe52954728cfd8e1843342f2a0217ef0cd19d803f6bb5d36e2a6d30c973a221590cd79587f87687a8cb76aa9efa27ee81b1fae99ad6ce0fd4a1198ccf40aed31593c8f813e86a0228bd43b91e3af99237b74e506d99167cf146d32ed9c6ac1a53ba9f3af4bb7a5967e0f61c59a628c87161fc84f61c93479022333f67286b97c9604a6adea54a53b871257d8d228a07a1ec01cf19531fde2960caf7a57398e85d8cc3b59b6a8dff79dc9add7b39d8ae569c7c846475c835079b38a6c3909f39f7366566406a2d652d19ce113d0c9d15c1cf1e054ae64d85d11adcf5418dbb360df2f5e83fd05cc1d315511cbea2270598749a132d9bd7b18bb65cc3ec098c8cf8f95ef16664e18f5cdc83ccd50ddb8d96f58324698200f5e400ed83515630d927375979c7355aeb7ef4fea7c6a29cb0490f193e21915403d6b72eb02a318171a5a9e8d6dd4f2c0e9c801e65fe888aae94e536bfd538017685fa9e0715a6c04b9999a31e164b2f7cfb5bd15a263914eb27f4ee52b92bb1a31571a003ac199c75ee89f3407846423c7b99e05fc4bf669f8943b686a8bd072494296bb7252765b0b58936bf7fd10282ec0991299ac48107d232aed99641175e624fdaf4dd98ab20019a426e934fd569969a8b62ffadcf1802399232b0c56ca062d0c28e09dac038af3ea16c2a26c08dae63dcdbd72c539e49944d13b974d5acfe5d969ac9af799cc75779bece435d414ffae3414cc52bfec19e96061270ecf05ac73edb83f53b805b7d0481eab5d928052e0a7e10fb4b2f9f2826342d0529df7c2d413fc49b85bb3cc3778ae0bdf2ce97d3109c66a38d2efe5e8fe8f78d63a5d0213a446c02e2f9e4e0e666d0f3ee181576a21a6a2ee5d34769af4c74f066657f52e7dfd0606be46421263765f65366ddabc9e5bf3693ec0f9a4b677553e269006450167339a56972fcf690184034476199d50338d4574a4aad7e4a8b1ce32330a2e41be7abc056315053419bdfeb28e8d73066","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
