<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"07d92a30648cb832dca893ebc648d9a83dbc804bfe6affdfc380be70e512b7615d6e2de1fb579fa92097bd72408ba41495e673fd8f6d917bec351d85b6d18f3cd1969cb8dd12db519711abe8ea49f2127e8b0f35069168d06e5fa72076318cc0af81ad67b911102fa88e7404fed358231e756fd2fa347f51deba40c958e35c273bd172572c79c928ae73c2d56a5f8f052073bdb8ba811bc2f1ab637058a7d4fc209aaa3f9ce7fcd28b6dce3db5a5646fb70472adf1cac8aade827c176d398234d93dec5e23d8f4c5f3e7ed8dea24dfdf635c30125602911e8c2c10de4492602b8c9c05355b359f1fc16921d5523aed52478b4cb0e15ddaae3028a402af070af76d6ba917e4d88c58da3d450c9d9c0b4246e16ac08a88b88f06b52a8969d79220edc8c1825a78cc12ffd943321855539ea1f57274883c1b111edfb616165c9f29f9c69816553bd45c00bd74b16363414de35c9a39024a10743b0d9020a332ce5198c3270451f8ef1e1ba4e043f0e2e1dd7871794c1b09be31299053b4f78af77428fb9b8e75438313e396504ad5b67b795e56715a232abc9d8a366e254311048c6aeabd09ea688fffcc40f5f843d6b25b8ae4713e7813389f7ec10be7ce55b4e15b402bffbd4bfc6a084e740d887ac5899d3b6021d0688a78eb4b12f7b857d1b9641b99b0b5a5310cd5968dc7a3b29fb6ce293c3d8219a02b3eb164676643c53272300226b58fe66e2e7677cab8fa869d5965534747b542f541e1db422e71cf9213347e771b26daddfbc156bff43c623a192ce646dafd0b3f53298911cc0cd5419b5b03594c8de58276b854f64c77fd7963ca72f14052d1529ccd66b5ddc436a02a271b5cf569abb4c52753ddd8efe422b6d5003c2683f8cfbd24eff718445d908aca7bc513f1618b1c96c72c44e31fa99a34e08309e331c35e397f70f55dd094b9fecf934a6458eae2e9610ee3f37bc413f8fb1320c5a58b3a06f296c3be708ddfc50720116e7b3ec45f34547f8067e4aad38a43a5354f5a89103d7dc848e5c507a3fc777055bb05117142cbee07b06a648124e4f9a571c5cea536b7c756147261ff0706a43c9177e9cf41cf3b92821ac3fefff11a63bb0be12d02aa6036d8c2b0daddb7eeea53e8068ccde02503ed002dc29d31d34c0e974fa943043f1e8c6b28529d4d0059b8fa8ec3b1d015eef48f156a61b1a2ea662dbd4c77eced18e3fa24eb9b2cc2b4a4f68c750f2b62e205175bd7152a8d8f9372c9bfe3472834ca319864e03099913995dc34908042aaa8ba194356686af22409ec041aa02223d1c9bf2ffb990dca3feda07e53ee2b98bc93b1999e68fc7977e6c354d0aa3bfd70bc7d6f190da4e7fa0e51bafee4b8521581ea432257cb1d6250dd20763038561c8fe0282f6788d64b8d3eeaaefd0b396d1b4f18e9e5f07ecf19ff9df22f38c3ee15e302e1c81b1dd04801bfc1ef492cc299191d1c27d6b706e6b3a96fc109cf4ac39ee9196fa358264c2bef28cbb47b60772d5cd9fe308b5a7489c559c22bd318f7a17c05f51e4c4181fe789520697c9d698c6eabe90a8ab71b3356b81b66e63dfd84893dd9a93e18d8fef5641fa1ba72f6426dded37f34ea1c67fc9cec12a73eb683cc2b5a1b81472de47d7e024e7db7074853e19f3fa348d42748432a3228ec16b0eed59e8319cb667cd680a83cf70d1f4c1d298f7328c503c6e9fbc21f2c7578b72dbd1eea8163524b9c98b91dd1c0ed08c27863e46009943ecc0652a298c036c6ff40a8e9f0c303942cfc3ad503a869d6da8a48e1c0e05f8570bb403bed82c1cdd22a764b10394a77e3f9ebb0095b1cae61f29ab9bd2a2371f6df346d6661490cca81c564cd38f06801714b07544e42ddcc58fb26e2ad1178a69ea4194b1f1423e6f7f50506b6ca14a95825c204071fdf903e07336c41c7792b6f1d597f8dd264be1953b2827fcff7fbd63493ea2916e36421144fe3f2f7dd5f8a50c8bd38edf71a39ce9a8301ecc724a201b1fbad5c9111233aa8f67e4f32e9c9711fb5a89b5955a47e5f38faaea2eb95f214bdf27ab743be5ca026ab0cfdd3f7bcf977606ea4b7c03c172688470cbb4f48a05095bd68ad7ed1209a7a11df5f2bce21cfb9a29228fea364fa63b683b8c3962c483026de8c9c1dd9952c996e274d4eba9db57f70b1ab15e4bb233a047048bb6f64f0f81c915054a692801a7e8b00128f1c229ef0c3a1e42ae29291ceb99b499e0f1e70730b55e2c33728992b176ab3de64b6ed4d475dbb367afab93bcd290d7ae2b1489d183dded53ff19c490b6d7f0d8ba295920edf167d0f0265afd3012dc2b585b4625f897655b8e6b4437c808b2323d858fb8303c5dfd8414c003fcec40c8d948aa3ef268c02132154ef4245788dcfe5ed97e2ef23c72044a6787de8bece94caa7db62c21a2691c141fafeb3b01857b4b02385085e4d985c615ae531b5ee17d64c84d3dcc546242d106e006543b9304cadd0162240ceb552b2b543ea7856ac860039d047a36bc148ac64aff2d3177c713ca87a5b7c37fd2dfbc81429a1853169f391896437d8ea658cb919efd8b0266497d19879ce62fb770aa8633235ef6ad7f398183fa1f1ff04a37e8d08a237e59ca41b14ca12484323e2f50a41f636cc82f434fef01fcdd1f9d12330f2192238a7d2f146614df8a39c584920e31a94fe2dd4b0b387d154e4bd210cf4338437d0cca2e7c25bfbea052d90d1a88547e123773b88558fc326dc4c9745f3b8db98e90451e746fd0877167317d0824c596842bb3549f17eb4cc4fa40326a93afa48f8249a8d1638e688474f62e62558fe7f0e43fa29cf0a437029820b87d744536f24658b00885dfb39299ff36b7a286814a25fde5c555c83d5c803e72aa375d66311001ba404b65d79964d2b966adaab1e098f768fb911ae3b1c47a5346d5634f91ce863e2c78003b2a85528b4e19137fd1d52e940b8c49b758199e006a9c021460adc43390362cda2563a6c4db612faf3a1ef762644f8a95f985ed26907279ba5338d05417bdaef548bd4976619bec022223e9547fa794d92ebb4b20ea9f2608073189eb58c9e1a83196cbce8f6b0f2b3602b4040f741b2103161e6637089df77ba03704308f6a692b249e3be921a11c8a252130dc03934edd98102920b634abf59fb5ee0838c71075ad7d370ab7dcad3b4b4fc527a06874194b3ca5708310ac2fb19d1bd7a49215c29a2733a1b38c4769cd9fd2047ef16768b3bcd3f03e1c7ee49fa0341da2ceed7c49f7a80878db949bdbe90ffb9b2177f825d5ad1c22be543ed8fe9a3f22311ff387709cd28f9304df6873b5244a1c70032f4b35ca31727a87aedd6456777b1e1c6b84c923aaf3317d07113eb7b0495e8e47611962cf5b4479a66b205c7691d735c30a62cde200d30ad93d1828191fb1a6dabae39a6a44388de675ecccb9994d4b10ac76d4990c1f2bbe1cdc58cecf24e9661ddf575922802cca3b0bcb027cbc39360960ce3e08309c78e5c19cb2cae7322b0a59e34448667e2bbca5f6a956d596baee4ec51653edfd21ab93a0d38c6400ea51f89dc0ec0224f8efa25f2025db607f8178616ab6f684cff0f4b640183af1487f48fe3643245fdf34e019116803b9d2697512df36815caeda3f332ed221474826590dc42580969ec2d20a7fb14be21e6530ef009d29c986847380dc837d15838563aade3a5bab1d9dc1f7bd290e7acea1155396cc950b68015d6c09df8cff61c5a589ac22bd98b0f8d2aaf51c4f5f2b5d6de6b6ab33b33666847f98b6a81d95db2af5fcde813fcf049b3a2b9a5ec20359d6d7982558cbb529ec680b0ed502df2b31b3d116ee64e42a2db20132350da85ba0e0c6f2d2e7adcf589dbbbee9d3b1aeb8b3ab063553d6644f35b351c08c117e59c12531907e26fff33c2e5c7df962515e39bbe7ba9c74574d1afb762b58019a2aecd8caeeca8ce1e7168aebf3a39dc26123b08b43962fa3f10f8b1566180b0e6467f80cdd06ee49939705c56e53d144199092b7871240604612ec12a83e53aaefa8e81286456e7a7619a98c19318b07c60a5f2aa5e892bdb28d6e3b3329ae311593be85eed5952413a7b7ff99ab9cc22815998f0ea15c594d320771e64c4f2ce0855e611c86dc41e45f34c9350b043ba96eab1150e72b21507261fc7bbe1fe540a12d91c5c224a620c430a6760e44a194c588099bc45e88d6229576b72e7cfa43c155d360c526d382c31b7a7beadf11e2cd514784764506f69b862ec4a27c8093372bf8fee6e466f984ac9f5ef8e9d0f8ae2a5d504dd0b239fbbcc1d0c689ae2389c8dd742f1ac8131c48d9c1bc0a256cf2ae2c7c87ea757566e990f0a4243abd84a0f70023696a15aa8a87f2ed7cd2d279e599c6f719d87bfc844f43414328b18da10de2d1663210142e86571ebd148ce5119ba5d0324698d036963c8fcce2fd9c68833608700b6268f659fec8c89568e2c7f5bece03df6cd343457d086ca22ad59548b8cf67855029185c7b57aeb144035f5c9e98bfeca441d23dc78d86d192d8831e36c51875f7c0cb0aa3a63687387452ab510db87135b30eef070c3699d381061118840a1abcbae24e5c8f7a56874c551d2f0fed1248fe6d3136d3745aec50e22c771dbfef695d673d2d737ce3080bbdf6b4e828681fdd2fe0de1363400939b5732423305320b542f602ce3730811d0e2b3ca11a8db87356c4be800fae57589f8ecbf329eb0455591f307030379496af927695a772bfa96a2b536c69cbe49637d01be8d074d31b28ecd67900bd8406b93e5dbc678e181b90edc8657d98379f63fc0a065fb2b6e3d2d52e98f05275507f4a25fe26442b8850ba798fbefa85056f2c15b240064692fada3f790c8f23736bd865a1229fc058f98b79bcc8aba3cb8222c8c939f8c8e0569dec1236abbf992889f4c99a374fd39cee4e83ea6070f95b0af0c13b45186911698977cc33a1624f1bb3d60f082840d02a332cc4e8092a8ffe6ebfeecf9be3d5dccb0f62542dda040f9c0045d7b33386eaaf5349e9cb63720589bcbc24d97b4f4d55f17a5938d2f27cdd835a0fa488ec783fe4d37b598e39132e1e60b1490c98f98459f81419f70d83830123b34d7fc289570d6aa983a266a71c82ee9d14e0f10f4641f874ac64d892304097e80dea8de47ecbb7078f6747dce7c3d368f7222d336b1657680aa269973652eb35fe93495b9c008b3ad9acb3a16187a0a9c71df733925fa1bd00ff63aa57da033dd23562a015930249b6f82fdcafe0da19229f7cf77069b8d0f13cbd086bf2ce358b32d48f42c049d1a7da8f3f189d49bc5f686f9fee28be63a5c6a4a2c646f2bfe4a84f9f10aaea643f329dc319c7a599b7c1e9925e96e8ad7b39e7f0bcb85c3d21097723de6e6bf3848666b6655993f931dd0cd47b330e3aef3a75637a792c887a6fe675d82493b15c96f82cd49d719d6471b0b66636c9bfb12e73cb4e9c2ffeb1933a25717de6009dffda05358ef0ac14ca25128cde3c30dc06e355ffc2144cf1666323f19eed99282dfa1744131426344c81aef06b8189b295b7e053ac008441e0f75751cdcb63a3b314e14cb836de5118c0350ae93d43e77edce52cdbe1e70f6e123fd1294035e3d2abdbd8673793819ebcdf2cb3e1711ed1d6cc0a09cb07118e62ca1261369a4cf5d64aedb46857a6c30cbbf0b6a76654040545891860f1002b4e373bff106ca2b3d7aab39de62951184bd562fe931f365021b7b83b7936fd75293cb79fbb49e9ddd25d7c2088b15bdb254b8c5d3431cdbb42a89a76ed9d45c36833940f7e6aa1421f9dc394246f7ab5e0146bc21049b47b76ae0437485dec1fce6ce1cc0215ac7ee3a75f1c1e9c632047fdbeecc516e1d8b28f46e4987caca09c1bf027d6a78501343b815a758d80c2d8ccfab1f3dbf3612cfc235ce9c0f8a7f758e72ad99c9c110c26ed35671f77c726b952d2a6f1de895f81a4a7e5f11333afcc3c9ecc7198d088b647dfbea809eafebe81a92cdcfc8bf79578bf09399fec96a07649ece8b1f5957ac2c928d4f2f21e4d96f37b937dcac241d55f8bc61787619b35af3ce46328340214781c9554bac60dd1d617e511e1526178bd680cdcfdbb3cfa2912525dc76d66ad36658f81018c1f9cd0f429ecacad18b00d21c20aa90b7ceb6bd65c15603a94919bc8fd3477da67efd344583150e5e6289e7d9f14ac13244c1b6e841dbd4fdac1574e056aecc72ebe794b4b86597444f3e05c65e631a7ffaa7cff5f49c83db6dc0b2cf7d183adfb204f2ad526c7acdb6043856e00239c95129f3380750272f3770c8e52b75f7000a310aee6f94017979a701004e2e30244a9ed4cc59360e65a8cb94f6209f821f85da5246bfded31073ba77d95df11a718ce6e8ef373c9338e9e95957d85c166850c91ae6aff0b2585e680cf8e1a05a19444bde5306d56edc67ade459099fbe50cebc845162ddd620d0cc14ca92780cf6015d954aa00a6fa33cc0c7880f51d5eba0252c911c8de87005fa2688786cc6ac77ed52a5446fa9389b7e05e5df0d985a4fc6a794815f17154db2d24e32cb040ef44e59d95541c144eb2944a2fd8b34fa0059258a8907411f45a2fd3c12d20f5d6b6dcdcc738cbc79478a0a270c679a03bec649581731ff15052a84910e5df037cf0e3862390b799a6793f0e8ef47c43bc5db4538966fb0c8f78254ba2df26acfe2bbffcafa4eebb01c520a4bc9854f92b25f7335735a02917dbe62b23cac5caf5455a145ce0a699f8e1ede88e060ed077980206147dd4aa3a03a4ba0993402270851e36e40837a59f3bdf9afc12cdf659e5f98f44e395802af9d24969340cd1873ad413baae371aeefbe6d153f0855e5c3a358fa46282df9caf2859dedc5f240c9306de126adcabf645294b972796ce8a8614c2f86de0a70adc4e2c980c9a7667151ca5312c54b26a7b1a9b70be55c8e9eee79d66fbbf4b098a008078e19f27c74d0a24edd06081dbdf705903ca4cd01bcc03346ff6aae30e5775083b0aa10a69b789254589b2988088f392e97c13efcf4b39130e635cde4673c0ff702cf95eb2d6737a8494da312ca0f0f47e79582ef852bf177d2bb25e1792acb00b68f760a70157ff23370e79c8e32320837eb410d8a26a4cc1b71e0a2de0df9293d60970d35b6fe25e56b811d7a1d0cb0a45a1919e0316e8ce8f98af0bf277dd6570a4e5e0b69ee18ac646a52321ede4bf9afce402c230b6d8af47c784fb1bfdee7a166f73e8c27bd04b75ff28cc501f4d08db066601d4ab5443014718395009b81245c2bdb5a44a54785bace83db7eef7bf44826ca228c553d3fe050ae812b85b75ef7edd29602f4bc820ffe800fe1529bdf2cd8967dcdae8197e1fedc588d03fd6122a9660889a2b67d08ed113918fc3cbe3a0fe051b76e206933c0fd2fcb641e0d0fdfe389928e67d09c013402ff1699b8e122d8782b92bb87bd33acb1f3525191958d3424f1ea98c7add84b961540db7fde3ef68bd949c0781593d7946c4ddc0d80ceccacf2940d264ae9f85d2f5ad2ccd4a526a16e8be08e26f0764dcfddb1ca7fbd725ee6353442d7969b9d23d10a193c9afd1aa4644e20aca17fe89e183a468da9745194cda747dd11a9cd52329137a95b0a86ea81f4dda80b2c324a99da767c260fb32bb96cc7da6dfa4f87e24a95fd30288d483177d0806df7097594f3d911905785a68ff14cc35d648cc3315cd0cf02b4c83669eb317744b1b9fd2fe2389be8d1925df09b95eb8e80f15274c440477ef13178dcc8f876dd31b48c5646949ac14ecfc18b58e5e5e4dc64c888d09efbcba657d18b21e8eff0b6d5d3b74dc98bdef48dda5ce8cf1a451e40136eee734275c00d59abe00cf3c415b1df077ad12f802348051a45782176780b3ce7c133069ffcda7b5817c2545645f82d33dbac9106480ad8a87001064ed4e18746a156efb5e5df09fea92619c2507b8225aa4e80e29c17906921e6a74427312f93b30f2a99e8bf9d0ff0275ffb73a49a51e09d9ea155a7f8940deb27a397111b676c4d5cc02735e9c4889090cd2e78be135cef81119e8cda489985cb3ccf2d2be8a64a67655c8898dcf3280c4000540ac77e83b2600fd989d41912a5baf8772ca74070716fc9603b86e76d824a77e0cec5073717f2865d58971c77d5ea333ff2912f5ce959509b0c7487079b64f4ffe3576a7123193b3641b47c561308d557537a51482a6cba3d48a748eef2fd4e66a4129f8e8ab59ed59c3738d687de34cda3eadbb299b8906a7a462ddf49cc7be5f91a5079babff716b33afc4d62fdd2f6a781c99b0c2d34951617eca086ba459ecd834a9101c4ff1560f43dc8ea9b4aad936687153949d552506e24946283a2e575653771c39083ccc39eed0d938b07106be602b72306bd4b966488272976c3d986586a63372206f11cc08e6b1e7962f09062b48e777fc8d7c87a07b2358fb6d39952a3bb8b0240878d9ce562fc1157d07445fa28c495fba47525612443fc7eea9abeb5f4a5d2b746f3ed1a8659bdb8fed3599ef4cdf6405e1a52168f4a7307a9ea9d9a14021433ac19bab01d7ea489ff61694ec9963d757864240e297e7aad7c81f9f94023c04f6b498e3a647d2020bcec7bbbab40da6d67af0b31ca2bd7c6be0e350d500605e4fdac2f50f9eced77abe831947ce3865caa296666dd24568481a669e8301b1a4439e623d9a2ef4bd9f3e32e4ea37adcf9a0b3364d22437d3e4c6b0f9fbf5d3518a0b84633f6849c3fd3a52ccfa7a32a15545d19bf6379bd135cf94cb67cee9f1305bcc859d5d8aaeb53b9fba0e92623a9058b37bdc8575b665889845bd0df4a42181c3f50d35d5e30928a4d0833ab16349c6e10c863071ba0ceea1fc77791d3bff0bcc2c0ffc4abb09238ff2bf7edf268207224febc147bebf3aa3e1f248fede5d571a4ed6c278fc32cf2aca6529968920128783ca58c462218d1fa9ee0c8240df0775c1e548976a0664ecda844bae6f56a17612a1fef77bdb2dad67c1a9d7b17b7a6116b4cb372823a27b6a065c82909da2f77c3a39cb3dfd4eb2ac8543af38b529db7c6da43143752672d5d49be7319a2df251afda9bc04f0abfae18563ae4a6c16715b61804e4453971e465f6c4be2fffa2615959f30a14fb88fc50eaf34383606db9bf80a4089a47d2b325583e923243263f45b05b12d1bc9c9920bfca61df0c3b8dbc3511fdcfc878357e6a50bec2e910fd63ea3cf2b6211e340fec1aebae7eaa4fab5043c330eddbbc73b0d3f01218599c2fa3427c6333d9cb042d4eb4536ce3e6d7875326d7be37e199d3ac3e52eaa8bb8db4130c6fa49b8fa735de5d3bf74a7303bae740b21efefdba54b335b5aa529a4d64aad69f2f940b9952722373c1fdf1f6efd43ce4933d8fac07ef680ab831b87a17a0379c1ee07df985b691fec35ddb43f5dd65b3d3bc593f7763b41b150b04425136e83d5725aa948e91b557ce23c77ca11ac23790abd46c62322927cd8b1ab38d3020651ddf8de2760fb7911a4312c4e39ba333bfb64f0ad6e436b68f31dafa3daeb1a5a1bc14ae20db49f8796e76f626ff00368051562eed0868b56579e3aa4c5ced12f5982684fb73fbb9c9cf61bcd55574b60d38b877019d41cc9d077382097dd81de97ebf1231324bb84ae210aea97291ee79a1167fbdfe404776db446982e46736f083263d74ee6c84edfe9b5114b3ffa9cc71db6382245db6652f25fe42f9f09db4d1da449d8b84808669995b33b13e69c0cec2767c385476609df089b4f0c0af63bbd49d9469d2faf127244c3250622cfc876468eb0f5a415e9acffb3608400dba342437a3c9678924683e96815144d1d7f3c494d505e82ad362f57d6f945cfd02d31ef6752fc68909b19912c1807e39a5a7584fd06ce80c4731d484bc1150f9248294bc97a94b1d283c1236c07c151e555445cb8a1eec76b851ca784bfa37ad59e7fa0ef2fb1a084474f977f4e0fb7e94ae4823c792426361a041979c64b86efa38453466efbecc071f24f0ed58c4167c686fb116a804aba4e531c11a327a3fa6ba41b019ce34ee582273471c2a2dec698afa2d0b80ee83f4bdc92202c2e14130ba3b3ebb7397d9092642b94139cab56798c06deb602141f2050c1b334fbd808f8d01da8e5519f70fb041c60bd9801374e617ef7d1428f38b0669297c9a582d4c851fedcea624f293e16f23e7826cb9dbed35ab03a3e349d98b1b631134315ac62c873feeb8ac6994db5c3accf6d5fd486c21b9cd871777fd8c274d26eb6b34df1a0e87ca10414cbb0c5b2ce13999f03160d4a57c3349d3a7e24af4f7f1664f9e26d6a8697ac4421223100b190212903a021bff26986347d91d003e60836853c3a711767456c1601812632afdf478fca07226e0cdd708a54f980e76694a02f64575eb62c69b32c41ed8d295bf10504ba65b6da0841c000d345750c297013a1431997f9f8c98e29842755dfbee65b33ee913088d60b37211dbce5a543da719afff895d7a929daad85231cc01738eb85bbdac729d230cc79e21ef58fcdb25a3816b641afb7d8ed74ef321776e9718be561a7dea6dd4155a93af76b2948f58f1ac2113ddda7ebd1c4b11ce2ca0b55ae5cff121f8acecf4bc42beefa1a8519df72d5746383da52412171b5da103daf6b18fc64332303ea4a844de6a6cc6822f4fdecdde56ee98e859d411a4e2af2d3f6377af204803842ae438135e6be3be77ad39bc41553b07555d58c027563a1c7d4bd3bcfe01c6e8dd27f69b3e2e45785a77115b4693fed9f540117e291ce6697239c9687c3cd6797043d134ac924941d170f8050477ae96a1e875b9ecc14edc82024e1ef3ec87df9d4a98602eac0ccf4c50dda03aba77ce80a8ab4968d3387940276c061eb9ced112d8ff8d8c942fb912020ac59a3a9969781decee86358a441aa0b2112c4ee58af48aa099d5e3748f49eeaf65c6ac001cb91cb0fa51e83a3389b76c4eee8f88375a68b6d37a35dff5118108ef27507b77b67b351d29443aef56e4e961fc6e71b3110e8fe85a3bf3972cecd07762dd6b218afa0fb81bedc088f87cb25a6e5c67be2e6da0959a2baeb25c534d658119fcbfb147139605567d717f1bea724eb4aca61410877f441add8f92d4586bf63f3c4f39c29b9167793fe6aa8cc2aa824f93074f6e75677851373417ca96e632280ca1d35fc13001460de5255e81c8ef0068a19f2137fab55c2b665e92126bc11ffd57e6b30887b3360ef250e11c9fafdc4c2573aa58ed6ad26d4663bb494c92296832ce4bedc147fcd66b5f5a2317c7339baa154db300a4a1976b52813706cfb9f7bd96636b32769594df763abe1607f370e7cc39ac0a5a11e825241de0d114bfbcfda005a9bf06b39e31a718239f1717b81bb74853771fd18e08d1dd0a3e0ed2db73ec8b4041904f042c98033902a0f129b771328ef1d973fd881e1119d734039f654686b67587913ad164eb4f334c7e400cdde2d3a78d5eeb2384c4bef5f7ad89619ebdfef58582c1486f4e1b579ead920e27413eedc74009de872a1999fea494f4707bf1dbacb130b446c15a5c4a472bf6671c860a2e668fa7cc31c7e51366c5ee2ed8b52509673cc421dfcb8d61baeef7b9e767bae9f4c88abd0e0f332a0c4bbc40527cf4613a94b20184dea5e8c49f6b8689387bd290e0f20f25c0255f070919f3d3b997dc235def66bc7ac948d4d7b994cf7a7671bee473fb00ca29ed7ba310a47857a062f90ebbcb50d5754fc3440e69c8c2eb1509955f637847cd072177b2c3d546ffad49d663ebb4fd48a4fef4c48a6304eb52d503a5722e4382726b6f993a3769d463f0b9496a6a18a7740befc248d73821c988308c3ddf8fcfd96bdb73e252435a224e35bfd476239f4a7b1f6654a88790d0d04d6969bdb56b17cf49d9d854dc6b97048cac1525630025520d732a5473930d97fc550ee8760765e9288778ff464d0a06e98965bcda28d5e135093dbdb7682709d49b179fa8018b9e3558dafb772f5e2c83e0db9d94ab238adf432f29e05d4a6ece808c4fa89f4a30ae6eee2422a982928dab5809f910085d781bbe3128500b0f72899ec2500e2db13859d0f0a8a7dbb2b0f7a3ea39c6fb2c2f8f78fcdb9e7387526256acb26f0fc814481dfe835ae86accf997cc56230ded1b5e6abdd1f3291f17dabc9d9c6dda159c26271811ee53a9e2f471f5de412c9ebf8ea2a0a5f3cef323e75ed314d649aca1f7b4a3dee4dd7dd468a5ff60dcc79f0df92750b598729f4d1d8a651ed50332ed59abf6b83bf059d58cfd3af9712c050ec4c545f94e416f191d779f27484fb466a1c5230a68792ef3066e03871fad32221d5090cbb008fd81a69777fe795d79640ee3c067d57aa4621fe5e2027b92bd206dfdcf4e9f1405f4ffdca1633042f974711b3db1c351b08d3a8859b4c85c7c90e9b947c95b86c70ce7bb0cce5bbc2fa865663227b82ea62ddcfb096f4cb03f9cfbcbcb55a5c67f906dc67f89f37582649c9e1e4a41c94482c99890a8e7db4ea28a5d2f7841072ae8807c09cbc99ebee5e08aae11b53f0f3ce725c5c7ffbe0cb832872d4d6a280684bb6a0edd8c1dd7647d21c8c4d629671c59dc43689b51549eba97583ae2e068346fc6f14460b457869e9cf83bd79df2d35f4d8d805cfaa39b253d0302d5203e4eedeb7359708d33b5092a71b1077f5f79abfe085e897880b8dd1b56c03b03fb1cb6cc61ca4ad631dda424fa10f0980eeae648df80d815ef3c48ff244ba34a0fd000838f9b2c062436129b91a83970105c40b588f664287557c217ec5eb0ba84dd9cb997a321e16249344d831fbccd1a0071b8f1c08fd35a845dc726faaedac17fd6de688b4627bcd29489523624e9743b0d2d74a6ff4cb04749119f1e6ff231c10e893f8acc3a9477b1a557b51f5869993d7a2a66c150630871b5407c166165d196677d7e68fe169491dcd38d1871bff8aead01fd06cca6d04efcfdcc251730473eb6490285e82bc867cf6b144b77a47196e7b28381a80acc76559d1372b8027aa515f61869e0af18f10570801b6863d3bb6aeda2209750efa4682d983450167e60b02ecf84bf23cf7ccc5352d0cf624193e5e3b17ad2aa2163af1f89dc371bd6a9434a02c05f00a6e7759cfc9f0df68a55675f1139e706a0641f33af89ee4d35d530d2948d8be35ae7159ddf11231d6e02565a4b3c6b82cfa1bb8a96671a4ffbadbd397e942e0b2012ddb063fe7587edfc5aaba026e6c1f9b69bb695d0d39c37f4ec96b2b3d53c0c91a110a8041bccb670ee7cc8f7d495fba8eafe9584cf2dacbb4a9f94f647e8c90cc73cdc8d9a8d10e9d2242437e6e01dba9ee54cf1bae5fde69ba143207507d7d15857dd71a7b791ee09c744263914ba88f8c7a9bf1f28e8d72344cb589d21e1e25b785ee4fab7831b1f9f2514ddd64dc0df7b0da8cf7572c1cc659b17ea0d12e8eec28ba9604920f9b60bb68510820840e43fd4845b7c035fd8c6f2bd40ee5930d8e97fc0946b731413b7cc41ee4b005f0391c7381bb850d5a162558b77535715899a17daef96ea625e6f7dc8ca5a0e6766111ff12a7e0e845176b34ba8e7155c23b173d665c327ce98db6f1020eaedcfbcf7ed281f7930f76f0b1972200735f62ec4e569742a1c037d0db609adde667a04a94c8d2b9de245764c4600c665726432e841172e59d9b8877f9abbab9b0cd21950dbf0a91861fd0bb6deb1c022741e89aaaa039604f6316f1a4a16eb2e2199c3f61876627f1775556668f453668a1ea6c34994afcba0bad375a5751b8f32eca9f675d49ec9f7b38365369ddba6610d5338878a0f9c590c732da160a08350601f184d6792dee676b30248e2dd224ff27bf24469dacd1fbc1556e85ec60c173e695a8d8f5d5b3bf9ae7f6ae6c0c71c6041355f09b4af346692a6d308a7debc06f3010d17d3a94cb48088d26cb20ab29586f0776fe4df96d69af519f1d34bd941fa1d8ffcbde2d1a6e7a213fd09adda76f8a3609e750bef2439b066b417ed6d027da5833e14905c76dd511b3a5462891fdcc7aac001cc9e9c9cd603598afece933a921ea4bfeefe9cbb6d976591be8662ea2198c06123aa1276d049807df7255432091523b1682fa61492d9d57b7cbb8d323d0a92254bb32f62f64f5bc32aed6c9fe2064771f77bce6c5f5a7b2805c1433fd50961d57f7eb58c6373734335a158f9e15cc5c4a5d9eba23bf0f90e10cbada5ef03f43dc7972d80648290379ca4a9f0e6748b10213a111715e3ea0403562517e7fdd43d6d9702edda60eb11fc0d6fe372f386f2b9cb4daf5e606ba4fa5e82a6717566791d005033c0472ca25c637415b53286eaee9bcff97b058f39c14178274a7d6c47e4b000e4f382dad2795e487180222c6be7b2674717dce5443ce686eacb4ec47e9bbffc9af6e994872b5c46aed383c86a8cb2d44019f817cb5b9f84ab2804bbe22ec9c931c31ae7dbc846a6b05e15d018c3f0d6eebdc6f4169281f73cd5d979d5fa0835ddd2d89ec854cd6ccf34d9efc5cf148329ecc0751d7268ad5c99808511ae60a6123cf4373ea42c551e2aac9277fbb78fb5786c48a7d75d38761d1ea7381293f811af1e6025aee9b4960f0c0807732a4fc57e933d713318cfbbc1e2627d00f48eb99ceff79921a6ef433658d6c28abf8a96b05b614b80ab113bd2ff4c69796177d9b01651258d7777f3de7aeee1eb059d9864b5e21b4388206ae9f229b98ef0ca9fa366aa42ac0ac08b9f2daa83a02e552410158eebd07836e9d6d564e039ea56ee9e622c70e68fdb3c4dcf17cf2af8e557eebb380de2cc63588faefe69e12e2846fb308d7763688aaddc5ed2925e82dc6f0325652d4290558bb859743ec4cd093522abf6c16e239191c5957f9e97dc963e7a6639699dbbf0da5fe3af9ce12d2c6f3db5ddd870b847f33c8775bb03304c4ce03269963c20e12b9d793e639a6d03417dd2c184d5eda979bb930b6aedfc6276dfdf5036b0dbe41ceb068001fb03e22d7c1594516d143911f2282e1165a236c839feac91eae22880379e31ffc27a3eba85651bb369defeb20bc5a6c722d771c7d982c15e763d09e5e88f13299ce668b05bd1b79f8fdc3eeec504bb440de9c62fc6b38b124fe39b89fb3aa629ae4805ec3b73226554c382664e7be1a373a302b4e4501bdf5536478f0001d2c2c45c299647ad0b60fc0e1064cbf0ad98405ff8136ad1303208fec8b8b7f9eacc92cd38f6e1742eb87638696a30734d76a3f1e2bc7e08e7cd2798a5f6cbe03c07db678e716a367f49fb1bc5cc7bde3a3f1446be93ce7bf8fae55bad53609caad6a26e0e42aaaed8432c09b01bf7a08268431b21006caa54ff8d35668bf65ac5293031dba5276f271e0347f5a88bb03b163059962faec32763ddbbe3af411fa708381e065ef74ae73dbf05d2888ebdf13b616b08f4c236c9b6cbca766e929b35d5297e5d471d536e938439bbda0437240198d5e861c4bfbe50a4041b4861cdac0d127459e7a9b9cdee68b5789f9264204aa574e5e7597987e91ddea64cd9d9e74467c01240fa51113dfc61eb8cd010809e3e583ad640772b59b362409a3ece04ac0c8daa236ade47355fe55087c816065026ced04d6ddf332fc8b9c209a84769ee237e4f717995e1245b957a5f92a67086c5d398af238a48cb8c167cfc5c7dd1d38160189f42be8bf86dc143642902181135e19930887eb4035b6f0485a8e37ec69e16b5dd25cd9d05ec76d245ed11988cc64d90c3b7c1913237c1318199ac54ee4f00aac79f2ba64f485f629e2e8b0f1c6c825dfe7106532d80198168e463672a5209dcc37c9a50375ff693f8846f25684cbdeb261a8851cd142af3fd9a641c0b16fb2d4d2da17a64c6be7d16fafc28ee739fa0ae9810ab7a68763c44d895ed16bdfa5cf7e3e72ccd6f9ec45950cb08e14bfc0b9470c0f6dd41d1789ddc31edfcdbd4c27bd13fc129e07dd2dc043862d6df473489b7665b4a63176430b8146864b893caf9c4e4b66100ac0113c1b15c2e98488f4d1852ea150f3d39cd64a406e6254bba617159d84896dd9352c5e111a2c0a6e562d51da48c1236799892b1424b43c65d9cea00935853f442414268b5fb15f1d6449a73195e66f26e90bafebc1ac0ca9f23300d06b5527be85a21a5e0d249b56728e1e7f16244c8778e422eb3bddc91ed20f9a221c73e39bc91cf0ace6493ecc20324207f28905122f9790053d8ffb348f27dc6af920edc6f77e6965b5bbb110e62bcc19278a95ec826240f64089fc15353cf6c8a501cb28ef19ee23bbe7daf79e85868a4c4a35aa79ffd8c69db88bea87d0ca60c9bd5085b8ecf5648debca3ba50b6feb1f059d2770dcc4dfa962e56ca532cdf8bbee9f6107e9ba0a213d7eb94c06ae3b94e7aea2399f3f6ecea9b5afdce4e2ae25d3f347e308c00a1d75490ad8c83e2d05b51381685afdfd2ef1d5066ff2b598805430d722d5ef7f5a7351b4c6236288131cc484e0b2d6d3cbad33f4aba5070cd227c275452b253af5c27b05cf13701b45ad185cabfe2c954770ed70c9376d4604572eda527803c22dea552dde21d3be06d02b8e93b08c947397b13f4ba84e1813f2af1aa7c14f7a29f496fe4c0e90f790ec055a7f53e71de6a63e60f6fea5048e6efbe55462697a466fd46b507ca3dbf9c5ecc0dc0758c6acab89e89fef4538b0fe76fd3215b0c1e6200c18b9640a6626bdcc2bd9550a61c37f61fae34cb8b6e4e4987bd9701f7d24fe0ebd6ad6ad8bd0ec351f6fe6508798211f0dda1b366fe3f33d58bf0336bc41fc9afa135d4250829174945488f8ff5b055781d530a3a01be201274b3526929e0fcee4695de14e80b2d5cd85be464f6ecf52857c3d9ecce2011d053dbc97553b12c8f6226768db1d7e65bbe30b02267b3c0e6c8c417d88d174ada413729d2329ddb23d844d22c04f236551ab5caa5669471f5be412c1698962e43b595bb97ee4e0553f698de475e33da7e982c862418ffcb95412321dd55b1d026967fbe964fe3a528c8d9026cb27efa0399c8ba7944350b167d5280d09b2ee128485b6cb195d229bf3a80c28c57c6e1628b0414c473493b699b3eb6ad09b6bc4cb1259957012a2d8b7ce9d01f6e68dcc52ccdb1ceb5e2fe29129b2ff8a6a3aa656101c5e7e2de58712b93554308b2a91e4ba3fb4e9b36fdcdf049ee5e963a85841206de629a8553847d964c50d1441babd8c3242cd17ea0695caa9edd167904bfb7179cac9d9ed86121fb89756806065ef013e4a52392e83573f7a07058579bb482b203adff178c32cdc20938edc7b58d30f751af5fca06f75c4783e1375723ab477e77e025eb48764d7644fd1afcaa009b7440ff658bc3b7639d93ae58c9dc56f846fb5bff04b7dbfa6b647252169411ec77cda12aa34b843fb2eadd257d6af91d9ae8085920aa4fe769e45251e7df4f94191fc87d62ad4d91dd3519c8df45555158e276042bd814d695fbd54c7220d2a4caa65cea3c70e2d2f20479384060678eb434376b3c02308b373fe385466243de0620f324cf81849795f1cfad413c4245c03e631559a526a033e82c5a6ee856e2fd11f1f95420eabe75a7a9bc121a192c2b108caee15517f4f816239c88c55c22a72f5bdef993c7c1d353e1d196caa53ce03ee90fab8f63b4f8f4d1919cd5f2fc15b536ab26ef378cbdad34c9190e371ccd2e5f08e663e727ff0207d0e66d48a89d7b1f7fbfb0b54172c1cbf7c1e192fd920530fddd243e742faa81ab1700808f00096ab4c7c4d95b660c2ac78ab1e3412d549aa5f3982bb3a2445233b397db1b3080fc55dc920e817bf05811772926208b48382dbdf6466f000c3f9f3ddadcbfd8103c0dbf46a8126ea4ac6e5456e7f73341d7362e994468a9a1b07f9bbaca003bb3efb0103ce9e6fe429bac7d577efed4cdea280e8bee9b82527e23c2a38a7a80c39cfdb2b8db5c263746480ae7664b392ca2ae8310cbe46482b81ef0818df84edcef6bd25a21898b657101954ea528462f9ce7d06bb09ab117746b789a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
