<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a5ffbc7d3cacf2a9f4ba14df3186c946e7cce1dd9e36e37a9e81dbdf0eb3aa7f78e28c2b1757e04ee38220210369383b1096d419cf2276f93f29a4a1fba909ad2cd9f83f500dbbe5edf9656602b6514cc3ca2754dc7568ae3f81224568a611f6b7f32af7b4195a980c4bb4d79c991010992b95e1669d639ec2d08ba8b0102922be522bf990e775d27bfc66b868c16ed33259875adc6a54649d1092f82721aef04e123c2ead79b2c6968c5c41f299e6dbdfc9ff84184f2d01d9760591250bcb17c7da73a5ac296fe84df4ee3bcf7ebf25cfd48e65b62159115dc08646cd6b43208ac840d027ac999a4e54b4b0d33886a2796d1cce51ec32890c41edad6c688e2e32363e0ec4eb1de730ce88f6e2e2f936aa484e896eb2543cdb5df07e06b616f2eed92c4a8bba70ca39a86ec31e6b03a37bc6bec3326e600a6beb9eb3cce95d9e7473959d5eb59ab646398679e54cc2479b58f40bb4234d197cf1c16268dc6282805558c568c1fd44a56ebf148acd44235450f9e194e1c4460436d4b3235743cc4ffb9a7a8b9d4ff574c300425bdc2a0e55fe932dd084fd006e5e2557008ed90d949a024665477d12dc6a7a48a832448a11502963ffc60fe5ff5b958e61063c0eb89cbd2f8e5a29a30ca95c418e8d93830c384b8e340531b525c94024c0234b740a51bf17d04e6bec2308f36148aa5e8e5f2da7aaa8ce64b525a05be6baa13477aa7941882ee33b6f1f5f5242cbb1593cbe2972ac45147a0cf447565cee07d741c3653021f7b23129af3b096d32737b5cb6e4cab0b48cf978ed1266f225c9ed58623bbba0ae510520efbddb7106ccc912e2d1b90bc252dc053b0a461a08281dc91d2a0010e8d80833c5d0d5eedb690ac254ee58fb74da5fd177528fe8a7cf1c353711de04edf08c06f7123d64d26c341d1dfccf274a2188ec66e4c629f524c059a2db0aedc0921a6bc97f4724ecc1091ff07a57f5d60c6d23c576ce03ce39d81643af250f0211ac4ea0bf90a73e6ee3ec35a48a31725880a060f0e0ae4fe45c7194338b88f5ed7bc79bd16f0a6850288e0254940f1920c5732d670beac628955bc329348ac179d25e890e9a30dbeae791abd971356e03d663a9d7ea16b5a701e673ae47466569ea9200163490568b04482fa15ba25b9a1d548ae1faf65d543158678a25c4df9e8a697804727ee352eeacf6b820fecab43aa2f134c5514f70f83a7e694555542b6d0d9a4a2974d6082e6dbee1817486d738ae774102cbe8772c38d716ebdedfa88d5e9b8836b250e16e4e24996a75bd5a0da5707c07007c8bc30067a9e18e0922ce2b132ae3850bfe161c57ccfc2cf12315b2162d7ee649ae59e8cba3665674f77a486ea3c23b02a2a9921ae5a44130b502e195c471a23c96f3ec727ea22da8ce28e4bfd5c3f29551d4b42c4ed3967f8d88110f14a06a36fe500fff75cfe5c910166954d2ddd1841fe90a8772e16c586f58727e70f69b5b08b545ae2a3ce12561bac5d6ff343e6254d6b020cb2318aea7421c4d7926df46c8a14ce090e5eeca73623e5e1f44fade9abe9224790ca92be951e7af680f18e3901ec76feaaabe9f46e229850afe6286a0a5b190c42cab6a4180ae7814d4721788e931b3a248604082651c346ffc7d46adfd24a1070be59f5de7fe763b944de78bb9281a84f17390e6b4d917a54f12d2bfe8a803a1eb5f58c79b9c1d1cd5dd66cc238fd0206c3f15fe64635f73a42dc3e059a97b7a02616f18297f086357ba38a2c731d4722c9bb0ff6fe4be5e5d44094b5aebdd0974d7c02b4dd31ec13f789260ecbed9feb7daf29145dcb67c529321eacc9389ce5e089e73fefa12d88c135eb48afe628f6f4599544b189ca213bbd0b08ad264bc093bf21c964c42fd42c245c6856943c7bcc566d7710d36a2b4ef6617bf2d872f8f88b1a858fba9e450a985c8beb3016476daf19bc416014e0e1ce8e09da18284ca3b7e5e54672904b44d298032b51dfc6ff72666217913c0814ea36e2081e27a0bfb7c72250d09e2a58f5cce4c6a953adcc9f92b3fd6242ecbe5c19e5351d16f307faa93e75d02e5b44d0c43a2c687b9ac03aba6f8bb7af2e75798c129b842f4c8f6420ffedb8fb0715a0e2671273e1f675dde87adc854a016c4e971fdd6ecde6c89b3d7e7a6e8c20f2eb40b8d2f8eaf6d00c757eee5de0667d6114a5a83b543b273df2609a2b80f74c83bba3f3be9ac2539e03b2cecd2a64f5dca62d18b0693709f531b0de639c2c204d7e4b4440d782e2121485055a61001b44fe4fd9c02503408bcd49649641928d1aa8ec87f9829bc7f98837b9c9fbef3f82a1f46117a09b1ea03a0d59d670dcad220a048f4247be7ac2fc3402f716655f341cbbe7bfbde9d270fc0b360a63dd6b2eb10f1fa448586799cbb88ea486e858aa67a82c010dea9d3eeab668397c22eadae1e97bb4693c5f91b8aebc8171f2d08a487abb5aab39713a45a54459a629d30353cc49150ebba95800146e6513323b01f7330b1712d58c666e6b54f1761232104f298dc134fdf6614ff056cd4676d106bdcdceffa24e6d196713c3067fae7377b48dcc2753e5e61c51eeac3aae1b01d601de202b857068d4f704fea75293058767e65c074dab4e353f3097afbbdbf94551cf6d84920d9c7dea15d0d0b504c7b67ced341d2b6f76486f71c81b096c2c9d583a7768898240434e158cc0d8d97943ed6e79c7bb0915d2a2c2885ed394600e2e801c9690f13205bdd14b839294c4ff08fae458b831ffb73f859682419486a1acf5e4ef1bff40db1238263ab7665a303d088874c19723642e08265132d9cb9a32fda542c46cfa6d801ab93eef0c3b65ee79146939f0225c81cc59f5792cdf184459a018275026818b65f7a28d10ec4cb0214a4f1933e1e52d99be5b1f58a916fe2214b190484f9276bd970c05fe25efadc58fd1926e94f875611efefbc9af8eaa3b5c8d920d634ab0823c4c56e163159fc3b3c42f00b6064e78c01eb253d011c41ca6b270b566abf6fa4016b96c116c50dc6eb160bf405effd08d7b855c3d9d0cfc6c4ae6599455e42c0b3b5484220efc7e2e70bb6aacb51488f17c263111f678ee61e6fea29acc78cee46fe79620dcee5d89bed0790f53d9b2a32f0b1fef16684a3c7c84a12efa5fdf92d4ecc671057b8cd665d916d3fe56864b623d4173ca25de1f70d035cad9f3b30f0cbf41afdfcaeb1aca00b727ce3f8a4b466ef02cb528affe76cfb2da08b4e6524a9a46edca3d933bef720c10d052cdc6878ceca7df17fad2a572e440d7ce66cbf79f5f5046504c68b7801d73c1eed381cf745bce74c2cf95219a07eef556626ae1bc34fa0e27c644d30dd13ed794c1ff505d82b3d24a7d1a19d898a7ae3dfc6d5cd47e7739d6e3b71c1c9b69d493410b8d03cca4c0fcf706ff906188286c2cec33731e1c2828b2ae1aa8d92e6395307eaf251baf7e12f188a1b532f0f494c394d554f6c6f314532a7f87820f2a540b7e0773831aeb38f11cb4e8bf8d1b06040713221327ddebac6232ba60990de0e8a424a8fc15b9953187c4b30d04cba33ca50ab9d1b19f7f7992022ed9a161dde55ae3dc08c773819c1e1717c91c9aee6d4c0e624f382ca928a4326a2703e3b63836ed66a2208818f0b89678b5e6661435ff27a700f475adb18ab5ac7d84165cdbbaa5c1da062f47faed65c3c270bfc8ebf7ce2ae2c25dd6e4e0055c2548d75f8b828240f976c2e13af345158d084f512f6cfed7e54a27b5434e5f0e011d7ed4b19cacf9382b84c2f6f907c637bf57f044f8b414285422c5d685b5eafe4bbc9a2637fcd814ab6dcef2796887346569fb280395a3742ea7c798defe4440427cd09ec43b92339cce80044b5b8720170e9526837c498aa18a7843c519dfcaa9b89ec7834a74b202bf2ee446bba93954750ef08926498bb530d59252e124c998a67ed5ddc091904228ea9b9cccca035ca4bf633e56410fad12e2053e1f7214eb5d8de8b702179ea5641681c2c1e86ede87a0748cac83fbeb5f271e173302eb3195b9baa0b28d4ec41e94878ad6d7d13ec3b4c399ca7d8af6a77207af3866e3f460a5b09857453ccff7cdc508d1b43c1c92a3a5246f411d4743275856b1bb297bee95634636ea13597912fcbee13f8ca9129643cc5565c9b030cd539f13de9a657b689d9ae8e86bd4b8f8d328f4d287762ad140387b258132c37acdb1d24d89dd7664513891232e66c4f30983d3bc4e7abd7b3659db6ccdb0d78f74e43b59dfc9f76d51558a01e5f18d5d89edba8204f28ca422b75d5e0e31a316be96022dd41145aa1bcc00a89774ec8c810e7f9a8c881317cf05f67a958bbd19591f036791cb4bae94766d5009ddab753308a73c041f9e28535700f7dc2b8f3c8ba0b0828f8da66e6a244c3e6afef193c58263868a1863b6b26afd8a0b69d1a28c2f94629f59ecbf6684bcd4cd167f6d3f9f1d2baf72d52f191ae9c18148feb08f218efe0af66906f94f271d88a30745e3a5936659da66040656d04a09c33e39451a258f2ac693382539bf568ea69ef72485e21c3b7e5ee2fab3835f7dd4dd028415b90cb7c73584b2c42517218447cc3d441a49830e0bb25f870bce48ec4b964dd6692c1f3599a763fa0befe19378e0f304a3ba8cf9162940bc2ae50d6ee49ed8ce223c598cb684b98a2c2b80af99e4abf648bfc7305ceda3ee0aef4a59af4415c309e126257c256f65911f5cbc244b8b2649df1d8922677b6ece5e0caf283e12c7588f9724fb81cbce6e6dc22236889c061b57394226b8e7e853d5a64e1e0b5ba30c364dce483c7d11395df1b39e2e4617eed5d4b3a55ba76841196605035c6bd8505429729020b66c8a9df823d87667292df73400ed83bec8c64b5b233376641cec014294c2315f48a2e6e7d20de89c1d9b40408463461402bd05d71279515a8b75fea7ef12264af06ccbba4e67e50c946d87a4ef928d048d987bd9b80716c1949b170c374e91f650c9e300bbdcedf79e38e9f148612a98384d6aaaed92395ecadce746351b7132220c4f6a89e80bb5a7a08752f9a6ae07f6caae0404f1efe93260f3097bf42b86db9f6ea5542baf7fb091544add121fc59edaa928dbc41f6fc30ca01f96c4fae1d2a640b612eca27eaca61c856a0c8b3d0bdac50e7d7dbb8fc67e0d06800fab764ce3d52bbff6107ffabba0a852e51c68e3b722db8fa3b5cb7dd2efdb84259972a24f97b87c42b9c3e2959f238c8dd06c5030f3a843a5d0df874234bc20bbb431d8ea0abc86b9256a74d29effec2a77cefa9ffa5ca6e8755212d4e3976add237ec07ec126749377d5e8c70d460d40a3017238722bb9c065a6d20d8797bea561e5fe1c89b4dc0c2c711750549ff5c46c45d3f1eccbb64c06fc6c8a968f81be810df304b201ac4f65a0548c1dd26762df432a2adc13966bf70433b482f0b090222c51299c21e61b240fbff7a673adc6e602b3773534e053a46a2185e991b79fe3fc5a1ba8f5eb3016742dd33afa5d14d41d68f1c72558eb45bb7b9830db15101024751a0ba4182f9b5f62906f28e44aa5c653b91f843d87ef2b9efed689b0ae95666dc7546578216b6d611ddfb29ff5b975e2b162f8b421842022ca5ef569980d202fc1a3d47a7245185df47ca65e2d4798d44d36af5fc98190ba13c10dfaa3e1603fda7414f08d35243fb13848d5eed85c4d03450c89cb725667e6adf6ea5dca22f16891911e60761e64b0c5e00949188351be3cf5d9bcea6202f5107af2c4da7d80bdfcb62041e0bdeeb5bf5639ec7c36b2dcf3e0557bc53335ca8f26788002525c3a366f3fbce6935694e3882a313f72db58e3214386688674caba9651cbd04594d7deb04de09cac967f0cf95e904e262d25234c8ba3156db7e6a44516ba307b698d5088fa36be5f0391c1d10354885c0823e8569f78a7980f26aa0e26c06510e40e91d3eb5e65321dd274c0ac61f6308b196f8b1c77c1abd15623c661b9745b4927ad742919883e3fe7cd955c1d0e85101768b3502993ac5e924aa0bde5ed2f24a73fdf9b8f3469502995d6d4f4c1dccaa526a7ad7c8ed419a8cc03aeab424f3d778fff0dbc22130849f9f5bf8efa30fd50775f3cc6f529a134075cb187867f997cea8f2700463e0b60e11198721c276e49d6c62b7f0225d6b968e6743e6192aab56b872f03e2841a59cc979afbb06ddced968697483fe2295ec98327e283ad2898dfc3d2dd85306dbe8e6168ec14271587b82905c8ed9c22c3db6543e88b9f90a5ae0c734dea562d3dced5d145ab5507c7683b62324cf199a2d2bbc280b4a3f36abe0acaded65a5baf7ef4a1cd7cd38118551ba160d890d115c49c05f1c49f3a004450d12c4ca497c4c36e90578ee91e26684dd8c1fd0bbd13da8e6a22f32165da1ce656cc373a2c61e74c0f989b3c1df7c30b32726b1d4a2c31dd5cbf981d8fd65207fd23c80a07dae1504d0b6a5df6a2321b7a1c966e2d0392ff1b90a75bb8f4763cd52581bc2fa2368fe486f4b3c0d686703e4184cfd340d800a8c739baac101629005813e0edb03383aac8b773259437528a75641b8bbb24d3379ebf6fdea706598595c51ce005ac7cdd09039c252c368fcd2fdd05fcb67d996d7c0e0f2c85e03f9d276b271ab811020db0f43ed68da7730b7a9bbf52a7f042e7cc968592eebab5beebb7da039c22d39852d7a8281fbc5e2972c83eae4662f647a402e44e7bae64368c6ef777aaf77863995e2764d2717f508952e177fcf59f44baaf30464ede0c428a38997391d3778d2ab1ffe96980affc9b579e10f3b1096ce80560656faa9df319910c90173ca862f867e458b10bd90f87a4b1725be55a059a987a9afec374295c80531b1bdc225614ecc4306e8eaadc68b7dd6f93c1260f72c70427e392a4a7c02976e620c8f762b87d9b5be164a024abcca144ff30251cb39353457cc80a2145c49aee3210bc3f8646759607e3fb9dcd36f40df3a9919d2416f0e8e1f788bfcf5c6f90d438229d4f92cbdd9d3771f9e25786f0a13d0b2b6683733430f3b359b3ba5f9dac6cf3938a498e6831cae81fa442b23d5a75d6dba580a13a639b4f7769c7066a5914ab2f19bd7191a5c0c19eb574b4e77ff138c43541b98d8f209f67979ca1f0096075382eacaa7f7e99513db67d7da43c717bf6c75a66ad9837904e704bd434b9cb4d437b5905d3bf786542cf4a38d2671050a4f8180aa4b9db2cb2353f188fc9e26016ae18a830143ee3dde0664aa6e168ad52f18598f88c63fc9811008f1d4b684258c1a84e8d233b916c8a79bc50e3fd14f05579b809343233ab6455d3d9c0f287c1a03f1ec28127a4d0358a3aa0a5b99458d08463046b17c3b99323c3cc2c2ae091b480d9b5b090a68869d0986ac6c0eeab946c6ee90f25a0669d83847d5045b47921f8fa1fe3b210fce8adfdd742b2e65e4af759d8f98d90f0bb8056480c17e1f880fb81d549adeaaf9ab45093f77a003e7a7b10c588f4eb0230d00bf79c61a273c04d9b785bd57fe9d675904b2a194e60d99a7df4f3731ca4d3cbcb11bc48ed4e0a5faab74dc6a4113a28dc34558f0381983c2a990a335d065adccf829ecdfd1922bdc11613c4ceea61441d37dd6275cba65be9db523a88af73a04f26a71fbdfd4d4ec4d5385b081feb909f8eedfe709c8f9368d1466bf6006e4ff512e607891a5f1908afad120d3f6cad6e01d8da9b11b597ce4bb9e931ece8be6cd3cd72621cdb65ceea0cf65544d866c6908de8b004e668486fcce82d2032f15790c9ac767e9b731294d0d059fcc14b48e0ba9df39b37f6d1eb0a36a345581bac3cc53c0ad1beda32dbfdd25a6c97b63805282637bba12126889803972a606400fb510d86a8f0f424295313bb370fd211358594e928d076c8627808fa98d180a98b03c9799bf53aba7162f8f43c12711839b64a3c37351fb42099ac5d56824f3b7ca748444b1c79e7284efe66630327d201779f6dd2374a63f66f0b5ff7dd73ccbbad8835749be10154ea8752b5b9de1079ab3710ee564d704443d6d8a5aa3ef1bf11473035aa2c3cce13a93cf9e234401d93273ee076053d9145d0f120272d3ff55973eaa90a9522cc46c8aa6f4ab0b7b686578e45aee7e21e95e21cdb69b3aa25ac9ce4087b72cf7ff67fe6bcf504290feb44f24c9f064607397e39eeb9563200fc2248ccc6af452842fd68a4f20d1505ac2e6a1dedc5b096f7dd485770f6421ee2678509da12008908fed5f83893f3e7b724dfba3144e570159e20e987fe0c39159bb9591e5069ccba6c5f0527c36298d09520f3bab3f872649b6beb44bd8837e6635d2ed5d5ba4a40dfa153f4155bd241bb05cc250790577ce487fdd6836d1978f2fac492c7260f89a362669717ccabab48ea272dd9a2e0c4f495ef7ad35f565c182a92280dd9d34e125d33e063defe76bce37fc0350852cce7cfdbe4b6e4be7f27d15f92c9a29951d11879b3ab3a3b27151429fa9eb6e5f8e43ed118a30d544f9ec1001a8a9b37761d5760a2da996a8688528859a2aae6d75ecd050f8a95545b67f6763eb33eaa21ef6483377703237c69f993cc0d874aae9ab92083646847f7c3f050513106a4e49ef43219a859a1e77d3e4b8a66976d31d2afb0546fccd573bd64bfa8b983bdf3332f83d5a972ebe19300951be120f316a6abf89a53ffbe65e7089ba9334ebe68eed3c5640da557af25182d27cd69c6ba28e111b1c724abbd40d242c4d6d1255f1da6be1442f13c79aa0b25100c2f3a2d364279990c84aa3c009f5bd07ac0534c9e63f5dc955c3661285c6c6fdcf45d3ea4fb4871c6183a8e7871ab0a390c9f47041abb5d509ffa5071d961ff8c7bcb30268dfbeb0a3ca9aa7f4b3dc62bf2650263e804650f43416c561c399a126fb3a96de07ed799aaa4797d8a1d0d731c3e33e9efc6747f61590b1441a696286973d4ee5a701e30e72d44edbc54ae0f2fd4cc91e300e44c5d2b682869ed943ec91a108df81cdb2b2c81b03e427ef641bbbef05aa38da4213760ded37164d9f7c7b625812fd3c0bd7a7d16511f04523dcc4c9db5e5195e43a1707749cb92777232d76a2b994aeb0c8a9e450895966e7d308e6705d951c3704177fb7f5f1cebbf216c857e44e86b1d5ee287590bd0b5d7728f2fbba9042cba44acd05cba1b9cf9e641587589010633148bce5bc8b48056d08f2955ea46a9e2525d633691ba875abe155d0b7bf5214189ec9b316b20f21cd0b1a08ea99f27f3a2a4ea08caa02f39d843a19757155dc1ab3a2cc45f91ac4a411d67a3069a94b80bfc749fdaaf0cc032a547b03c1cdd1c07b9758dd21a1947ad13eb0f59f07fe4b908f8851389ae046548953aa88533f4a104f3e92f68cc748ab5e84798a30354800aa8e80d2f5c1277e12891f9a978a7114817ca6feb8a4f4c1b44c7ff957c18c4a0e4cce0805c47517b0034c7849e54b0f54a3664d4fad18b02e865d0a48a654dbae81174fc291ea5316216b37c209cba23212d50a87096fbf2283a4aacb913b86bdbecfa6c666409285f75f959f52a5874afadc3be843429cd0f94953a04f469788c9e3b946af76b547fa0a1d2b52603d55c3fd96191adc5536459e95fb10f4d33b72a618e564734ec74ddaed0b6dd8fbcfbbd30cbe512f139cf86e251d883d387b0133faba96578074967e357bc7f48027283d89d404379ae50bd164cc7c28f95996f29ec4e2097876bed48dd8d30f7d521a905e7c44a8529eae021703abd6c781507b7054e34f8d54d318c91711eb92188ef87e212b761e34003f5b15547582d70403314bb2d97fbb77732265f3c2165569bfb7e33261b7287330a620484a7185fa4a7b92009e32da6e8cbce75dbcec077bd203c630211f3e5ffb2f701e00965c803a6d5a721a96101571aa70f359c8d815dac8b09383b504e212d180a648757a4f68ba107045fd814a8ef10b86ff80df76e1ca343cc2a3536ad1cf48601c9921114c6a5653bbd7e5ff521f01f77ecab66cc1ab5e9e3266e90dbe6d202e7c46e95a89b6aba6804a4ac1cd489a1088d14033d065bf972e96b56023ec4599b77bc87eebf2b5b358bdca12233c69297277a3f2c21c5b85d7ce716b7f7e07aaffc9084a0a6a636ab79daece58bd4de8c85a5a2a3a306599f1e8643355644c61d1ef693660454a30ab04f0e4b5a37e78f1d349274d917ac96996b6a5f3ad157d6a60033dd07aa5916ef708be31a8068fd325cf647dfb5ef57cb4312b6edc91f7252ba495cc1919075f6cede23aa874a29447398105a4e09e009ff9da1ac0f4a92b66f2f564160ff5aa175de3228375c1f5ed2a7c0ebaef6ee20715cbc0c1584570a11fb88658fa5c46de9816da56de3526cd16d512859570a18560e06ac9abec975417fcc6b2d423cb93e33987f04c460e0dca5766bc6f041709f2aac729e4fef664e0327b1884530a6355290291309a23ef723d023d31c3bbb99d0326b87aa79bb9db2b9dea4abd4dab77c8e48f96ade383884fac62194e3b9c85b9f43f05c56dbbc8c0dec7f51da2f06433e867adf12f036d281b8f631c6bc1615d1a35e3b9f9316bc60f4aeab479216137519b48eb0e8f650fd541014d85ff63d7745fefc14aa332b00923908f25b51f9714004a7c23ac73eb259034d402240f434fc124b1aebc7711189ed34ae5ecb8449357daef3f559e65c2a8fc38727ba8a3c2b1cde0cb78111323da62ff18b481ddbe0ba3c7aee9c312d09a0755ce3ab947fcfe9b3aadfa125e590040da80cdf298c55230568fd03aed5c1d3c8f4e2827175baff1c86585da448b8044c88bacd7f72014559123185cc95183f7a9be9bd667ab30bdae1361c4e1ce45afc148ec4da4eb9b38dccdf3d22ea11004ba755d0b662a7eaf86d18cac33175b747dadd0da7e8c74b65fb5f0163684c9ae1fb186c237e057a70a370d2e91ab0330ba0df5556ea2856c5459915abf091f59244dfc32f570b6434c34df503bab44ae48539deff55251147e7c31fe04b402d9367ecc5eb258738ad3ab2a4fdd0dae7e5a180a035a614f01160868a29b72e147b7d0f434b7538606abade166de12ffc83168320e5eeb17bc73cdf794e64639d80f9ed807b24da658c0c02413a407d02340a9cbd1bd210568ab3ba43d553b80d1e31171d2cb6f8c3781812d8fc500a999edd836c74b50837c3c0fc65e3951fdf61dd469958db9912966bf7aefa2e499d4d20deec2ebd8b05065943577a611c5a72f82ba39959d2b7cc19ddcf5bd12f9c22afa169fa7f256d02a927a3152193a36cebd3be85b0336894ae945ab293b07a7b6ac5011e22baa7349cbcff54ec6d83436b1d37dcb286e9d8ec5453674d3a08c78437870c21b4246c817713aac9e42655dd53b570d37ce6f4ac3960cf28a49d8da68b7409d678d42cb8d39aed50835304986431ced0f8890fcb7c6f38368870778f4e317e1a22884329ebf1e99db3e90ad6285e726242f317e82bec04ca4c560c5ade0d79db543e89df081bd16eb5064620d7bb1fbe62945ceb1e31632d768a5c8d5f4a8815c3d5d312838f382fd89ee89ae1a94a79077bbec93a72b16764890eed1079c995ba738e1b730f4a01e1385e942e9e19e711be73b9e540c8235a91b3968c9d26a50731240d37c4a24c741bae6952d4adbed5b111cb84901de936120f6fd5620a5e30b945074f26d515a5f38332c0e329e2501b6609044de106ce7d27b32bede49945cf68fcf23da21a974f3b6334f7a4de2a003e18a744bdac824401681ad081e55e973c5fac9bd2820f37c488d80c54bf1f7c2568dcabbf3b305b3d7409cca9a2bc1739bfc79507efecb27e6fec2bc7bfc22f331b3556ff36a7e7f87b702ce5351210c2ce1097bcbebf918880c938fcc86d0792c9bba91f9a09361332cab1c0e20eb9576129c0cafbf7998731e196d57bed946fbba1a7f593d39c9124218cddddd59bb4b0f62e25431186f20b954f5e8eb017da939bdbf417738aa01bd4a02ae7909f6dcec807417c0de134979355dec7cbff11a4403510c290dfde209f43bfdfea7c2f13f1ebecd06c21fdb4da8975a9cb45b40584ba4c9ece5f321e4e8c247686c69610021bfafecafdca4256b960ab39e140f1d053879eb7bb80d7c8eedc898678b85dd69371d6cee5a2c0d7b46db8515bca3b1eeb61788558d9a4cc41d7bec9c6ac1e46acf82133d93903fc0ad0b5efe9513465e8886e5a614897eefe874208644b7eb26d451ae093d1e314d1d7e6b77a171c4390102cb3e8820aaeba228675552397681c006ba98974072759c0a95c864cb17ffd37f9fb04afd54208171448f5f16d03f8945a07ed396c0c5038a8169a64bbe1a1dbe2c4d8b8c9a05c8218dc34adef0642add7a32a5f9f26a95a330d0c4a44c99f19510c325db3219711efb86db53301c7f74171f4b388455ae74cbffe81760b7cc3457f3dda0563d8975e490d58147c48d10e07b3d1322defc70c81e7254d839cb4e7d8a4cf6f1a784c6492b90c6dab2f5c7e0b12507ee992faea5408f6ff9caa261182f9d7d509bf3d557d18a11beab42a4d2b7c505d33ba63f0a7709f03e0decc7a09e872e0b173b8d5e61d486419111b4d44f616e73548a26999c0e7da03b800cfd7f9eb12969a6eca1f624b15c7d1e8680ea3e2f8cdda74c46a002e9536ccf69e0360453dd99c852d6bb06cce54da792fad255aa24b7f2d87252efb57206f81c2b63201a41eb0598363371d1eadbffbee90510c27c4983d2b9edbb8c7e7198aa460223f3579c1e30b4eb97e73d43a1373ed88a257e6821bd6a91a1c297443ee3325492b2627da0e2579e4c1960a5af68aa210bf11ca70058ccab3df5aacabf2fbad82fb79b4f10b8b07b4f8dd47c0ca8ed3fec522b2da1a8a68a43bdff911807813906816a62193290859ffe0feea5d3c1a29dab05ddfbf05b675731b7fc7e8881cbb3795f22c23b8ae2c1809e16d72f3dfbb0e9deb916b5f614ce8933ef3734ecebb00bf3a3143356124a6efde149737d307a5512e873228e17bbee0bfe24f7e8cd3559154bec68da46100ec8b4cdae3b7365ef8c253c9943b68045bb1dd5ec5071c745d15b28599e911400a67ad2cc7262f1522ea29ed91e53f03e71f7835bc78ef79b400be994ec293b25af93d4b2780a107fe5834a774b47acbecb24e7884c9b068c13ea747e0889e1499a7237705670b4910d8b14e54456b3861c09282a7d559c353ab246d15cb86d8d8b153cc289acacec747d546139619d55f7074de74da26135e6fc8266e25aa1a455f0c1b4fb8fb27066f3398f9dc4d9b706ad9df2e4f242c13c01783c5aeeba67b8d1d5161cfc5f651c46493a222d7b26df484998d5e3d1af4e4bd5915866949091dac52d08621b2a5fa0730a2a4c150650ad1ce76babcd28648a05c8377e6b51ef57754a2e1ea8153526a134898b267282c5eb65792d890b8fa50ac5ba1bf95dfdc8cdf3751e04911e1d4b2084e0fcb462d0e7257276f832610c5b9053282bc525384f9aca996743b6b0b1d6cd4849e7f3e4cd60ee2b9e779255fdc18846f3cdf8eecb888d8e5fef8fb959cb5b69e979cc864fb0edb3109939297fc29e947d340a4a689a5ba2a15ceba66b41f896d7d714376fc4775f9278bb651d5e8440c57143b51104723878d9dba9684b6c0b54c0f2d98779d66cc82fae7a3206c802c2a88e651ccd2521d2b7090034492ec1e55e819d43a445e71f975fc7282923449374cc48458e0190a9bc4ebe3f0d88d023dc8e816e5f245404118d245db17166f91f0a82646ee45b044e4c299374377ef3c3dbb0ad624e0a45525da621df11f2dda171f87538cae64a7867944d43a190376b061b1bc217d791d14cb1576d00bb4dc7553e2141f0634eeddd3ea3c2cf6c5a8ec60f9a56fe275f792197cc26fc0991342e598b2e8b8315c9301c0c62ae6ef9ca61c7ddfdf9f6f0482b728bbf4c3631698a307c6336422794fc98220363cba150cfc2189fb1d668dc24b4611e04948e92ecaf33613c09f7fd40017ebb45871fdd6a2ac14110e2341eae9ebb370db82f602d925314afafcfa4c577b4019edd368332768319840e602f0b38c72d5b9de6b6b68d46c138ca623801cc148e4fde74cb4c1c1ced8cd7b281abc0a056483800ee631b3f931db2968244efcedd9524eab6cd44fefe833e0f0ca1657885db92bd63bdfd40d31a63f86a4501dda0c07f0fc1976b81af2da01e92ea47541ebb36ac26ff742ac5d18ac35db080caef91e9f51ea6b18a9294262c6a502ac3cc499bcf3d0c4bf3c50343c1bd06d84d11c28aab84c5c48ebe894c832ea2a24bbe78668324e51ce1750f9feef01beec683c6088ea1a0329be35f20a061957f21ee31afbd8eb163b1f132ea0c4430c28d2e0b8b51a91ea8e23c93ad0830e327fab251111ccecdc08c9b7cb171f6ee559fea4c48f31496fb67066f6a0bd2269c93e16625054fe3969323cb9553e5b9961d2ef2f6f4eccae01d3a8b575055b2515482464c44ecc4514d52ebe1b6e119fa1e7e535cfff9ad8fefe69b16c2c2c5ab3c703d54d79bda3a84f53441ffcd880a9ed8c74d01ae48e89125e38c113854b5d216b0357eb78ed20800d47b07f812becc199c3c7bfdb354684d9d4f5a9dff1c5df6ccf94eab4f01204b23908f12ffc55e4a5218622c609e7b6f7cbf622357ad430ca3197ab17b97c6ba7727c5f9546a345418d3d5293de69631f32c1291d3eae43a1d74504f89affe1d62e4ecae409ef5784552caee064fca993562c35d97eed90d1a3009ace8bedd40aebb323ade6f8e1d17919a415b713dce9e9c89737fc25f0de03f2d2926460d444be6ed972f636368e4c1c9edbf389e087c48307a63b914d268fbb4218008d40ca4c284c613614ff7671c657442f68a9d0c8dbb67b0d22d4f9fc6e7092a6647defa619f672715a7f3adb78cd398af97ce7a5462f03082dd7c8c93607f98fe6db7521f0c80734491bac4f9740b831d7e81634d9af3d32d849571b211643721a71384a1b17471603b27c7a22c504e8f9e7498927de1854999f400bea836aa92a5d467ef8452ec8bd424e8a69a3908b7beef1999979f619852898193e7ddf61b2861338d2d83eabdcdec2f1cb561a58da1545fddd2e3e2502fc0cb21f1adfd10347ae4f7733a3519ba2f712c34c2516259bae32c18cf743004f602832103424bcae0db2d50b40930e4439447dd0328698584dd0c93f06cfc6d2a724522fe5f190c6526b5782d6a5c2ef9405d91734242b3508a6daab51808105be3ecd11b184a06d15802b466f6cf831774efa05c855c241b10b58f969507cbc05ea21f44c861c59a087833226a072b0ca253927b7bc8ac2e03449e5c2e73c03277fcef9cdbc3fc3b08d75302134409551ab4c986f73986e4b2d796c173b44f192e4ad6a4e38ebdda29accad32677e382e38fdddd5cd89c665172adb1edec24bd2bddeb6d64117caa5f2a93a4dff7f80333ef9e8cfa0fc0e3ae1e1560990f14dc10dffdaebcd264660bc08f27dff95a3b997d9edcea488deb7a31999223ad6c12ce7a2c2f4cf392c701cd8120de3be3842c8851cda6762f76478da2cc888e67730e1c3aba2a6890d55fd0186186a63757db5808d30eb9c811355c1af4066f4f81e5f40d042dc24a311258e66d264589383a7aed2376b9629f634b1baa0402b14076526b6d28359f0aae965b730bab3f9395b199f6764931c1f8cca7a75755be61c3221c8fc2c03d7706e57e0d3550944cdea2b1dfab9bfefec620b29fd4d9c3f2b7dd634221bbbf75314f638a718d2376d4020cba727cdb3c4b02bc5654cd9b80bf1d993c1f48797953d8564ec0738d8563894db047ccc04d84289509dea6dd2a22997c50a36be15e5861e4fe0747633d139491c17e69f78d5b8a0320c3045e0588cd1eb25346cb3ad8bd0d79cd9f655c38c60e5ff15323be023fddd49d4dfa0432c2470b6a34eec0b8035d0fe3e2ee459326451d1cdaaa0e57b6d7eb58a6c5fe9cac423cab81b31494ec9254cfe046cba1354b9361091ea3f8e5eee66e853dbbc7c73825a6e0ab5eccfddf917d424133ad0ccee9a182edff762f9a6ae3e6aaba97950c1262c0b6b8a5dda5461565616b89bc3e82a6da595cc6312fd70fa6509fbb9484b5436b0dd48f60df412bcfe1864de3959f9623b90ea7c1d722da92688a045ffef17113b570b1aad77b825eb0de87150118d5f21aa9619c835cb2d03bfcde8f23f791c8051c3ce3793fbcad0c502a775bc861628bec1773926b704a24f4c46bac369b01736c5035dce1000aa80b24e15bddae6bd187957537f0e9dd57aba2bb2a02fa59ec08a99647f160fc34b8c3ae1b4e41a340e319cc4f6f4961065d3f3193fdbb884a5fa64681e97dbde9ac8c93b68115f78fdb72e8e34f4e50cd0de75c42fe3d688bfb2e5ed12c4e181603968ba62716b5e5d1cc6b683bac3c1487f135a9d2f9c0d9b9c999a7b5ab4dfe53ed7128662ce753b020ecbc5ca102ded1b86823c0a204be03baef21dbcf83feda41791cea152ef267377a41be6e06b4df26c7083a90a6d06cba7eaff0848c10fc68b8f1c8d854528a12fe9c9efcaca2c1f0ccf2a6cb7c5ed4a63b6b103465c1dc85c830867c4d5d2a3b3a716641122594b6bce54f3a47b0dc19f62711240b6d06ed2036f18c6091aacc85c80b3dc8615983563269167d756fe2847cac771856689d5e1bef9e6a38e32279629e3367e0b59ffeda747285ecc91aff86016ed61df759a12412589f97bb671172e9db86da0af26d5ac9534c3e14e5829a1cb1bbe28316c41e9a711b8827c73786ba425feb421a8594cda0a0cadba19ebf9b8a5a31a2836d9ee3fff326f7a24946615a2469ab235df7955fa241a724a29c28a09ec4ad18625db4c0a7ca4cd4937887a54a377681a2190cdfd7a7a229c1f008923332249b77e74c25d0543887bc03579afd1e2728574b848d79f7affa85f93fd128b68ee32ba43976facc99881a31e3ec09047497852ce2b1b9336034f20d451763b2af39ec22f82fc1c121cd3ae838752df743144ddeed3881d08c8b2b8959cb3494c481cf01bbd4a0dcb4c09ed209aa619cfc11eb4c6baa20343c717439e5f4154c50a6cace3fa3745501e13be9818f0be938f8e336d52c88d20a578b90304db601c2d7cdac953981f4643092798d2b333ae881339c7116630700a9ef23bcdbdde1662e3ec650e8fe2846fae222cb1fbe80f650e827d4ac6f97fa3cf32fe19dd5e2dca398b7723f7c0a813de8f9f7b8ec3d1f3353ce6a248afe7b0c96d5b5cb94b4049d7c5c249d654b3b8581210fb1dab8c8869aafe24b771c7eb89cb21a0d00024b13d03fde54ae55729e399f9993cc5dd8cfec6ec728116a3e4c64867f3114f8d6e6eb5dec2c719c40f96125739e29c3903d3f94ec4f6b7e44ed50eb037e90a929630d50f68c4fc0fabdd056059b66d07da1f0bc23ad4c3abca8f95ced2dfa04ae4f1f8e193ab204379b353a4785fa46e2bbb83eaf7430a02daac8213dc4c001ae100660b632fd503e4b5486f85cbbb1a499b4c44aa0e97fc10a4d548f5792583421d149747a6156c783825845639178feaf573c885a947fe679a8c593154a767b1f27e28771fa003c5cdd706fadb84baf6a6ad6acd597f361875257b267997235793afad348fd82d8b0643e2b3dcf8862c472143c71dde7fcefc0f1385aef81144e0377b32b2b10475b1243eeec4e18b1db240a8875587d281ed2c5dea17a3cff2188c8b739e7e286f247e52c800bc83121db85d0d73d9d81fd1b8bc3e7cc9cf1c24472ab6c543c112b9774cb5b62c5db2a03a09b1a96c9ffd76c8a4f62dbdc6b4f741f00a1355337be0d7f2f8fd7a31d14569c6362aa9b83b6a031b88cfa92374955f38ca915f81564334842fdf2414e96b3213b0dfa311586b07514bb53dc5ee626d445fc2b34eeb3b42ef2d1c3442b5abdc47969792b9eaa40c627d7aad7711d1a7ae1565078c7971bb01a4a0de586e36cba65883ea5c4a278f887f5bf65a22f3f933cbcce92923cb7630a0d40d92cf1fc3733b7088cf3f8bc2d5f846c43e24796810a31ef85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
