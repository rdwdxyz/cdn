<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3f2cdee5aaf364d5ab7523a1827ec0674a7957d8933ae43b44f382b12cd4c2cc769853e22c5c36896a013add4288758dc46b57bd372f43f6e26018cc08865067de49e2ecd06664990c59bc0f869d3f2e441d3e5589828878ec091566a8e300f3fc1f4627137a79149d77e336eb7232108672fbf5e9ceef6d10286cb82b96d7ff868bcc72de07dbd90868c3c88658b322df22427dde2a012906b4edb44def0428ea39d0b6b82e3ab0d7c79704e081f06c4f81d4e3b93e05cce5782c50e5b9c8f050a7c643edc8917cecfacb85217e1ef0867b159ef05d2eba8184fed9bd732e5be69196d91ffd5847a147b1a6256951d6bcc7caee7398a0edc2234cda3a4a425fcdf2fe9e06eafd83ea6a356f974c0b4ac046e9c38dfe7db5f2435af6062dabf6959a869554df565f61656ee654dad1c5b1a4c10df68a69b652990ea1a312ca75c27e0d35a96f9e7f13f886b5965173fa739c7b69bbcb119134cd424cd51382907167b6a795ff09c0ad0d3ef9e69e19c1cc3659296f15ac37d344f4b3512350189f385ea93cc52e4afc96cc6354021644193657d3774473daca7c0a10e9fec40809d593f00ed9adef8ce55e6ba5ecc25a3272005b97881db08816fbd800346d2c5a55f23a6df1e80e3edd7099c9349db0d3387933fd2f8d84afcf781ef835053791f946fbd0bc26ed66157f4991f6c8eacb22bcb83d5ce714568cf9a87dec88258ab887b9a039de5a03f2c732c54f1e5ee4b1873bb2de77c7b9e6729404c155f5b97eba9b72845b75303c28eaad861b72edd9039c2cde1f6ad1dbfde8c89c9b09aefee73e08c36d777a074ac3d58464b7e2308f0dcdd026ce74ffc7942c2805a6ebb0ab2b0d919d461ee8fb98d4dc1b6d1bcd1ac26e546d209b6948059b51b007318d5349c8717c14f2e196efde98803fea6c6cf948dc486b6f9d58717dc2ed9f1ecdc349cda531d7a24a935616f544dc29240181900da0fef7f4ed9712584920ad53f7095ad3ac5d8b88f9b8fd2892dcd2400a70d5437cf5326d410123beed31611bb235e6088fadf0e1070f7f79a187c16326ced7f131642f835c47274b71f5e89bb9f9b4c4b41591d14174f95efd94f268f5c96d39cf94867a08102c8e4b61c5716a478ac69ca231a462af7a2ff103716f4d8864b19dd073e245afff91ff3c894429896fcee131a07dd4a05d1492db24ba4cd25004b89992e1f3d15631dd418e9c2a34e0f7cc8e4bccafdcd8175fc9d949272db3349a355f294a003076fafa54ab8ee0c1c0bb1590a39bcebe3ab51092b49e3114967630b116088f7b5c38ed3f278dea17a5d2f3a1a54baf1bacd4936ed0b11cf46d11996683b81c3a2fa82da74ac3ddd4b69ce8fc95ef0f3c82e87d70490cae8185d73ba6b5187fc4a918e28a72ded7ff5409aa34e9e65be4e5f94b41d1946259017975c398eb68077741b1f909b5eb8320fac521ee59a527e06e6246875dd61c8a45e1f604a3d5018be50038a66a4c35811ca4f5d49c60040462eaf4ad5973fb82b4949f826293326971f1de40800aa9e7572fa186f0c8d81ba1065493cdeb23e537d9d812f99db66354118a0a0b384acf1b1c4f9dbe04e3c5ba8e6bf4f18aa117483eab3a2f3ccaec47bd56d8b82ec2b3db5f3b9d70094a7c7ba853b6a2095d2efff098da70d650bc07e0f15249b2c389f5e5b82383992793e39fb0d1618af518cc0d7321479ed9e4dae54e92d496b70dd0b3c28eb88422d8e106328667c72ba965688da22104ba6e268070a6f489a0de155ce30d3cfdbf14cc53f730640cc8a87c0ab096247aed699eb554ffe9f11b337aa9a97a738d76dd7620f21ecfd1c8a4c965077db3022113a71abcec57c3ef32881bacfc18dc4148e2b335eb85c492ee033fa88e04e01b0bdac4036d0d85aeb094b7332218efa9cdabb6e855703e6442dc5b827767b0abf8c96963d686bd209ef77b57ddc20d83fbe93ad7357d05895f6fbb45c90e8083c76c010c09e7f62d2149feb4726345799a2e3109e2e4abb799880e3a73fb862d7cd4bb9ad8c78551158b8def7b4d99b7a46968daa6d07395b852b2678e15bbef3598a890a4ab60cad3bcb6663df92a0341d6cf16b537c47bbcb4a7e945e119cb90904e1bc616fe1611af0ba058241abe1921809cca49e07e0452755c6db9456d9d44dd56155d43d326a5ec4076d9efbe1d73fd575898e17115987ed4465881f6b5a80ac8a0198477dcfb6c1687c4990996fff790a19a6b7525da5fa9c6da8353db05d26cbda66aa822aa468c1f10bb5c476a25ba441d50f71b517548bc863ec4fcfc43fcb4f94c22d45776ce009ec8bd443f14e4a50ea368ecb7230f5e552a6c3036424ae80ec3802f6d2031a3c9def8093b3493dafaf03708c37f3f48d72b4c49d48366d27ecc1ad29cee199df228c157f1e06ba6e530d001d12f17f55137356df75c834edf690c15d1a967e8f0377fbcf303b1c34004d01245654399ccc10789b731ccddb21b8f47f1bb6ef099aae7f1bc434684abd39d67f4bedb82eca2773a50c6d74d684690806f2272f43b1aa0014b33a047e56c21aa3934b4c5ad36913b2b360084cf8ab5a7258c920bbc1c2353a4a3cdbb7427fa4a4057ea44939bda8ce122fec65f706ee665cbd0fae611e25e0960d421fc1e1ffe71125e94a8453ac17ec7c7dcc847e6c0cb74ef6107341c9692ab6b0433c018e132c14f1b898bdf977b9a7d81d51b70e7ee6d2191f6857410cb4607149ee28f7480ebd69d49bf2a2bd453bf325b75077471c3a5e9df6f9bcc10cb87884677807b8f2d0545fc9e69a7094f73729d3275a4f5ef752a11d1034b52970ad2fe1f61535e8776c067fc2d3e6ccfea5e1c96ed6974ec57704079df4a13454fea8b17d925bfa4413cd8d78a28deffc27781c0e6d32081bc6f479ef472f284a62a15805f8cdb76ba316ecbe52ca886ca62989cf388cafdcfa2780c7e69edf596bbd5c67f09947a95992b1ef5c1786920278b4fd4380d9ed76634c0aece4c1c71bfb655f676c834c511ff7b8c2a594d07ab550b453a2bd4b50a641df6d39c3465e1a895ec18784c7c90a5866f9bfb51750949cdb8f0fee7d15f7262037d5daa105547e37d2a2c95045e300184e675f2db8318f89d17cbded7fb36a8bd740ffbb4ef6e25fc451af855b7834dadb1536ad2643b4650e02385543de10afc6ce2ef101110689c9385f29fc5163280334d22e66cadd9c5cf8c338d94c759e0a16d2fc110bd783724d7afbc8df4aa59950b8aaa965977c873b86c4b62f9c5af7b100de5b03c018ec26e130281e2382221235aebc87fbaf69afbcc8f516d86b2ca9c5fc0c516cd4153cf4790d0e600e79d6ac8eb05fc03dd35a0190560a71c1aed9e67ea8ef0dc8bdf340315588bd7bfd7a0c9e04f4eee25b79698034e8c3f6147b8e296cca458907abdcd9bdd9df0fcdfbc8c06d3e0574304099affd2c53aa20ada128ed7b2bdfa2bd60ab164516f7cd24278fe0990746afb1b5ea87b32f43836b001300b17ae06e6dc56b0f662093697c2865cc7d2ad10fba333077267189b00339225aef54bf32da130678b80a0921ecf9342ab1eb3a4c9e75d87240809f441a3f9c033bd250d9d2bae9e10e08b3f2a5528ea8de141585950b2377d2431d55d147030594bfea2d13c3997b8890b34d840f4bc23c50d53cf812b410069bb5b4f98debe083ca2746ab8e4d7a5c003dc725101d0d584fc33f798e0c1d79cad8761dbd7326c766c012e4629f56c1a89b2adc7dde5ee0136b58cdc6db6cc36c983eb4c96c563ea84b2ce7ead6223c1d7b2fd9c66ebcbf8c4861b2850e0fc5b281f342c11aa4a59f4d36efa397ff17d3093ed7e9a673668e95fa293e5ef17f36d9980caeb4e8ab1c57c78a8ab45c360eb02271b2d262236257522c5a8dfc71a4387e6fa4b391da95a306352f42fdaba21e85654952964d184660afc5393bb5e37a4c0cfecaed34458180acf56ade4827794559a32195b053c655a3aaf65b712f085055a0fea7a7792ee214da7c59fad35e07d403fa17be581fe94ae997c2b7838e487e434e9f04ae2675b72f3730aef24588f1b377f807b769cb9178e86287ca30f0a3f5b0618ca215e06f4ebb6ced8937d7897459790caf86430d13c0134079520df99096bee6a5e0f3df658a76b6a3499ebb00a987424101259282006c7ed52e1fb2f479e6f2571739a238e1751e3eb1319933e40c60320ed5623949a656ca6e5866941325b59ba2c005084755804e4cf9e4059022acc7cd815f6912a64eab48de02e037e042a86e9734102220bcbd13e4cd2ecb455b6c7fccc009fe938a1dff2a651b5f0c01c6a801ce4c5e9c1c15f9453740f213247a570a12fbc6fe2294347ae0d7ff72475f1cab9bd02222e60f037d7bd9d82642acc0c6db38967241e94cbce78b46edc0cf47d90406b97268b33e8ce4581acbfb9dd674d38fb056d30f001d6b240badb47059b8e31b237aa59f1cd9608de8be43d15bdb24862e9d0065fa90720056719dac3dee23af6df98ce8efc914b73412eeb2b4f34480dde10ff5389a3164b048860e9166112223f98707165bde8cf37f9d62e41c077ea9d32f54b25bb511930240eb5554421bb3096e1960a2641d054ad0c7a25dc5b0e768676e98f6c40ed641c37d2b359e5420b3335504f2d361ee0b2af62d6665686748b67dc9d359af18794f31dc8909d097f7fb9df6c3bec5a1c762bc6c5b75d961647f07ac53cbadb39a3b3f93df9d21bd99b94212c698ff49e69796c2eca119fb5f96f7150ee79659e07bb69ea3cdd8207796658616306fe85bc52052a386e30cbb7e17fbcf889217b62561afc5fdb9e36b28a880929b85ac03086fc07cc3fc9d4097c9d7c7c902f6f3e6fd84f53270d77d314a28d9a49e502a87a54c9457c1d76b26998f6847158237420a871e6db37035084bc7f0d707b0cf0306e5e7271f4488fcb805d48d2d5654ff29d76873588fb32aa8dfe1385246f1573b3b7e44bf24b4927102cee47b1d6f0fd70ab19ed027ce6dc0dc8389a048166ea78ebbf30bb3f58bb776c2670a8e216c353606e7d3e4f960fc25674d3e372aace2ed2e229b204215915cf770ee58e4762bf776dc2b7de18eda21b75a8c383a1bea18374e55dac243033dec11b04c3a82e3262bfa1effdd88ebb301f8829dac471773216dc84daf2a3ba1adaa0ba9282a1860a773452b6e7e65291418e778a32dad9111a721806af801dcfa53737574783ce464a58d5c3eac1df4d841aafddbfaa8a758381e0c0b757833ce5fd7a57063ab528336912b9a0c87e939789e600dd0b2374130def5633acd69ccbb399d1cfde6a5c1735807f07f2510ac639840b9f425f48693ef3d1155410fd5e7c64255cb10ee9da8ff132ff8b066d32458833db2a2daab7da826f9ab44f64db6b4f734bddf845598a10ba0471f1d3588e1f4b564f660865834a288ba657c6cad07718b85e97008286de55e57bbc8dd21637f978dd064b147a582a66f8da8816c84636102a451aa6a4d50fb0b155ded564b9de6c24739ea2a3264ca2411d478669983746a4d69180a9f3643685da883b81382f3d6796cf4526482597a70d0f6cc9e8e93874471a63d411415f9396f4e039d90aa4c72eafe9a8c50ae789aac13c1d0c993931643064aed845cf10aebf8405af4b0e7c72c3e07a43c18a32ce2b4d880da248cdee485736b02d3782b3c8810171d13112b18274982a5a04c38655e5b16839594662c723c0e71477b7f903d029d1eac6271c3a4d84e90a7de5e32ab524360d57a7220b93e290097bb1aacce55a8a1de785df70363ba63d819b62afe5329dde240ebd1cfb55f02311ba58a13de5fbdd33c608e470b15cdff592acb925bf6cd57acf03a49f9c98c033604e1b3caee5f4b6d3d43a586c1bec7e0bd93a45630d91743119aac451c19395e1da2b3707b20ca10e8f89e144e90f2a9b2354e397cb4c07a4907f2ae3284e42e7b900cbef069bacfed13a3ef44e78ec7c19e9429a1460301437b046df82023f0f4c3bd2187a6b143fe770e4a67079a0f4954a4fd423fa6c4f4b56083a6cb98f2a97dab6f45cb3b3be64a6be6f54b780f6a4562f71c07dbf73abddb1f7260fb4336f5cb1020fc815a5781fbc8b4009c42396c359ff9b5e12c21fed3b00122dd4d89c42d7b4e851c23c4d0f2855158c84277ba6b3728f7fe9a5ff7e8a78285314eff23e61913c19e52786d31f71d7df882b32330365e3867a883d32643d69ccab7facc4d4f56dfb0a9ff13bb3d95a1ab3f564e900d9036ff0c485e92b11684659c94f68da9635fe4018748a281049c24d81858c5dbaa8e7ef6ac2aa2a79052f83dc5ae579678e9a1fb3288911c5060fdbf3deee997c97a02d7bb6095c84628c290328488eec1366e3c82a04f080d3f58324314566c925aa64a89fadc49bb45edccf91d1380ae81aa06884a679ccd3c75c53c14a29d27396264f7aee1b15c50df17dddc68a8894fc8f48cb668980dba88632b94ca30b4bd6b0c109cf688bbb5e227ffadd54c325cd6598c599f5f3695bf2e8c34c84c3a0dd92f0478d0f3510db7dce5759a9f43800fdec1012388a9a08fa3f9205fb711973f1dc4c29944167fd723ae0d919a3cc13a2576a913efcfab5a0bb7f656cc0132a16ad442f8848d2e6b137614a6bd69a0a2049a2a6b75e7aa21954585a9e802d290fffd7c9b604651671ddbed8165b3cce659c785d2e4d36a521129803f20b862c9252b3a28cca51dcf933cdbc90f192096b222f3c610ff5ddacb2e270c52acc856e3220930699ca3e00f10e942c27a5d424bd9dfe174b014fabe2826e6d7d7f668d707708e85065daf8e9440d3dd8f9fafd0c3ad1f405945cc7617db237a71ac6ca6e4dac906e85ef0c4d79a95ae4faf9f8398a4c9249445c51d636b537118106dbbd115604b1df6b440f426abd73cb5b4bb081bb13d8826dfa05464a3c57e6b5b2f6383d9d5979cfb61935877f4479e20bfdfdfead11f2a8628e5e8711b753d337ab2ddf5a856ecb4a1eb92b370e7eaf3c6cc997f77e6f74130b4b8756aa43f70e360e6da8f7e330d0e4c8103df563d6c83928ec13b04a061bb9cdcce1a61f9fab600b4549b80c76ba754a9f42cb43c119d04b5aca865cc1dede174c0ce1ac7f3e9b136d7e86863bed5cb955474e6cf7411b173e7040f6e917d430bdf997e2e352f2967c7bd68508547955764926a09219c431e855a52adcac199393f339348146b1eda6111fd442f9b27c1d46e2a71314480d73f7fba92fbc12e97b9eee70bf457e31052d88467bf5f6b1f9a8f3d9b65e1b8070290a5207a0c4c84653c47957cf0a9a353ea0ad4ce0b4297dd182ad89dd3fb930ac8fdb3cc5c6352ff1fd3eed861cbc2c5a17f107d6d1ed8082d2a041a1bfacc60396f176a52357915df9a2a2e8e0c155a99708914011e183bf59b6738d0f45f986dedf14fd4ecc80fd63112829d6e72b23dbfcf272e8c228d195c83010234ba7b3ffda664936236c7945260022875f1ca046c50b8acf014b5e8f3d5b681a38396d9a25669c507b3866ffd614ea332727c546e933ced656d7df5fef0af739dbd8b8c1f7e22a94f0231f8c49e0a6c76c075b235d2228c337800c2d14dd76d82400905c860f539f514e66543425e4ca73d34bc1f10fdbb35c9e3088e5763073889eb8c80b503750e5e5a37c2efe24bd6e6c6dbb6f952bd9d3f2ef09bc766f8a4ada789c40e8cc33e69e421f469b47f8947a47ee7ce3c021beec0113172022d0ef66c2b74e06915ba568ecb8c515d7531f19dc1553037b3da90845d677d83d79135fdac1fa8c396cfd3f3f8d382c17ecbeb5b9049c49c9d83163c83851e7040a5268cd603e79e0e6f667cf0a180d1a1abed960e22c6cbcb85fb92cd48153baee9abbefd2ad9d99d958d690b5bf5001929ec727c1d39428e14c661c1b0e3d7ae5c721e11200931332e018f92dfb68030bebc96e6e0d6c1d28803b921bb2180323a4ba934506bef34d779f5c0473ea2cb1a16e8a22ebf5e804846fd444d7688f1da8df1e45b6ec575cfe7e2d8c7dbe21de74e29d81e81e2bd8b11c33a1dcd843b412829cea9953a9dccd6a633e6a664ec8acf8280d9df8d654840a40f7d9ac7e32c4b4cd9c8896b129c921a67a577b5ad487f28bd0503dd82a952038a44b0859a608046ae23059c694c792faaf7f0e58360b861f49e76166ac30631c19c843ffd21f8a82bbd50326eea65fc5895a41a734c23f256d22b1af459c5ad0e0129bdc5e20d210144ea8c744a3796d39b3ae4dd74d4fd6205aea3acc9ada6544d599dbc27f9db8a76f92c9cab4b7f55d299c537c86e9138c5f447da1e1ab99b3bd65c6c383890c7456068d2acd6f7752d21336aa573cfe0e90948f2c3f123a7a620ab48e11494d03043278a08cec6957ea21ef7a1aed59baf53775f839096c1312513bd756a01fc3864a3a46cb527a91b24a9039e5ad5ab98e305842ebdf052ef6d2b104ced142e785cd405809ff27655927f529053e1ad3f3f73b8647db7c68c556ff08cc48c18d8816134a3867850f6446a674f5fbecd80c2b51f503a0dd756783a255b243f25520163f9263d7b61f1ddfb7fea582f981da09a2aa1c078462215694de9bd5ab5ae896cb855b434cab5c336f71dee2f37945cc2d7b84fca344102bc09f0244c02f3bf27c29d7d958dac2ebb6fe61edca7a111a7f26a8956e607a6838dbc0d279623e8541344c66342b061326deff880b9e352dc247627a90aafc48425a3972c78217b15be3e5769f601c79d7e6113e336e07f0bea1911b5179d1aaf4d869b7083af7a52f99ee994128f48a6dc2d06e88cd6201803fe3955b8fba99b885badc370df89183d9d4af95e473e4f15d62cea6f6d9c5600aa251d944f2dd554226be58750a6f9a15d54ac42bccdb0e0913e90401d16d2165b9a19df45f0dc014bbc59726364b85a2b8b33af7b5d8637df82820c1e7be9dcfdea493eb2135f340107f2abb94144c07c887786f5356e31fef128dc10e8c308bc427c71d3133b7bf4afd2f3f3201bfc6cce89095d35e45a17c8c4182e9952a3a0bc5c1581a0177cbc7bd4e9b198805f61a1f0fd62062ef56560525e5c8042f56627324bfa048991e2f3d6126bccdb90ab8dadaa7ebf033e7368b97b377cda2288191aa566a1ea3c5803cb5d8caa5228abd9bb6d92a11a2d3c44b201d8d9c2370fabb419eb2bd824999a99e31813db885546a752d6fb69209cfcd52078cb470b895b7d8dc3977287eca2aad40bd3290203b95e5a015e3717bb8302f8ecfc35a80fd6ac1f256097be0cabca48a3718f1111fd66b17097a99dc895fbfcb32ee507672fcd3877e4f49e5543582a6149b376a8f78c530d0568d38be16ccda1aa0779d39c70e469b37886436047ada0abf4282aa57123ff8cd64ff85c2c4d349b4afbf330559736b3a1085a58392cabebfe5d97aaf99ddf10d1e5a04761bcd2b87883ea0c7b7528e40b1b5e5c0ab705743aa89b8cf65856780788f3c2e3c43cd413b9991e6e7b3f52aa97e287ddf746d1b043fad1c80b879029eb708303edf8fbb6f09e7880dd7a1e606f1cf38612ed6c0b2f610065e579619db23058d88de93b010e8e882792ff01715215c1ac77dd51058260ff0315db9315e32d3c143534e2ad0d2f2cf6ad18e9492896f895b7ff4780b1bb9b63ff2c40925c7b7e3b23020c5b084cda0abaaeb711652f9e8e8bdb94708ceb2358b08287a31646328ff2c235d7506164579b9c7015b5210cce2ac1276227db4b7225a61fb47a593179704ae54303caff51dd45a18ead7b7638b67ec35d0b2e8384910ed2bafe90ae4d6af01d45822afea2cc1082c5dd212a4fb882f3db32b455f08e8467c903ccc19d8fb4619fea8ad1e081400fc09d04051187b1207157f401ed4a301b1b865c3e0d415b3b912f1ac3989bee75b90eb18aa2530b794e591be2a0bd79f8dd02454b30dd78fefcada9e3b3cace7f6ae48a18c9fa91acbe510f379e32e1fa959213f4e701401d4d4a86f5290e33f2cbeefcca7e03ec605f25b73f7bac836af286b87832af3cfe8c2cbd2badc2e7b5b8d237205749c5d7c5fdcc6ff6bcb64ce299264f79740f1ff1309401550c63a94609729f2d7032003c29824474935ad3cf01feee47850ea850a536ea71dc77f3d624158875cbe79d3666929875b18fcd0e6ac062fc74a0299affaff8e3bbe2f38456c92719eb0413c19744dc94d14603b0f66886f55aaeead880da0a8a40fd0f832785ac35a9e1d11c8cf7d9f927865dc5258e6cafe77d7dd28a33aabe0e8a5ab0eaca19d008a1d8bd4a6015af04caf78939890d6c3768d50ab1907b2e6c74cc07aa875b5231edb1a5482b01139345377b2804775e762d45c31da5c14aea733d514910f9c13df5f3329ed6c85f9c746f89aa7d2d96c37b6d39ca4bd047aaf0a16193dac575c4306aaa272dc0abf0c38c7119157ff532d4546e9db51fd0b072785a3e183966dfe395c4c02c3722cca0d45d3581d02fb9e2f3252a45ede9c9b025b5c768ab46b3ab931902be79b80b13c6e9247dba7376f79435c5762464ebbab453a801a05efc54ec37761a71bf14dbd3fdbe3133a37171d8034ba33a506cbbe97e0ccb37575a0f06bdecde9d7b57501ada068c6ecd38f9ca57526b00bb2d96b15c588030a07796795e1f2fc2ba7ebb6ea081e7653e65a908c3ed1276f09e2c27fa32301d7baf62ed0412fa37d4cc1009bc6b39a96bbc6993c456f0ac5a03e28238ddf9f3459eb7cab809ea232a8dc2cc478d3ab4f60fc55cafca788b19981064692a9a0d88deeb4b098c6ce410620ca114cba87a6536a9fe74a7d4c0c04c3b284af15bc8e6bdcc71ae73a530bfe3c03f9b315fcf5461d7acc28906c3030c5a45ac8dd631fa104b52f2bcbdbd5f887b8c4e96300397200f670190c051628766cb446098f574ecb401d54f44d3145e2f0380b234d31b2e69ddea728811cd3328edfefd3b9ed5ec352a3a5760388dba07463bd5b711f497ee8fc0fe83528f825de2daecdcf2c9971b05ef543175a38cecdb2fa846fd9572c7daf8d9e17afa97a21f62d87ed74bd003a7f93f246b2104b43ea29dfb4ad58cc0603f78a4107e8d7ee94acd10a70b95a4e5bbf0b57ee86d0a05d0793535519f7de758ae46ba930aae3c4f6beba9e5b742aced884b8db0344abece98a33b2519ac3589fbe1236397c96dcf254ec52a34086c42fb47d6d19bc9aaa27a7cd7d97931a1e23c1b79b2c992ddd7f737c592f8c4a9c958c07488f88738733fcb3f3b288c7090f3a83c417b31def1d9e4b25e88da2d2029dc4ab12fd50a2881be915f690d79b948fcb850d0b37abfabe09a43e9c04d38ff64f1e7f8cb9bf3e85d0a6f879e9a68f2e80c9a0c096c09f621af992697f081861fc911b216e5cf10a8ff170e9710db1d6fbc880aeeb4da323ec6f431075f44f2abc2a5b131eaf14e5985aaa3bfc10e42a2fb59ac9284e4d5ce767d71814c7bf6ff0b995e169eab617c346c0cae49a791ee2aa32345bafb1b999b030b28839167fd0a51814edcf8eb2f653677a0e033b7af9ba8b9e7a1a60acaf381e91fca7eca001da2825cc1e0079dc16128a76206cd678556fbb8116df0d368d003464a4075e95b6f5ce7bf884621aec04f4a5c2009da49e51c7adf42058cc5ba351e414458fecf249685addf445142ef7c3ef23b32b699f905d9cefa5b6b234b36e0188e2c1c3aacb43ac163cdb60e983f110344bb8a44e283eb220005f94a1a5cb6e72f8b14610d8270936c516ada69ebe94c98992e14c78b4d0a96e6040af76e74a1ffa4dbf42b6d80bb7204b7017360cf16c48fd30e0d1ed996c7f4052d5092ea4e6d9ff4c316a747cc174780a2274f189cceb3d443c2cd732e18783787187b6ce834b11c7a82bc0c51cd3fbb7434b20f4276375eb8a081685e9b28b35dfe2e3243b66c98c6b0f9c23a4df6da4f2dde4354155910855428ce34e893d2f0f3064e3d3fc3850f1ec1c7e88c5fc63a642a3e7e5b487ee8b92d2540d0a78bebf8bbb7c0421199578b8c8ead4d3c8047e08ea5d2e95606354aaf85541c3cd8806085543dc19eb5bdd31f1ce802f38097d8c6434384c1ad5f9b3be4314c4de11b2a1e5beebe631d7bd46ce35d764e4c69a1a645d04a4cf064d9043686c3e97dcbe90b54d9880f51f20893bd8663fe9d2b8ba3a2eb3eddfdfa931b99b68d01b7157ae41d381137cae395b4bbb4916919f147af22e8841ed880e275e39f072d350e2a661358e6b91f25731490414f0e5b6366a15af3141f490fd0b0faa0243fe0d3e1dfc7d638e234f913810b01e0e75ea16b961e62bdf3ef0fa0103ea26a8e302ae4e0086b0091dfa033b031429a41ad44bbd9eae3d95ee7a5e139478675d0f469d8084b649d13c6f1795bbc77aede39bcf84b2cd7882f79874beeb24103b5abfc63507519dfc4f3c271ccc9a976373d65850057f42200b7f492b32d4ad117c6229ccf0d434a0c73528bf12cae5d525eeaa86e6e2e2c76157c5aaefcb1b9c1a41204ca3b6221fccf33035b69a2085fefaa5311d2b461181edcc9e0f8b8b843dacba9bcb564a202e70ccfe094fcfd143290bd8831e4898cfb81ebd041d20a1f639572785c37f9ec7be8e81a727a1cf5f49ca795f26a03aea491cda40b33220fd650d45e109e87813e5ad01f109a73f23dda79abfa055cfdf73c8c09ef7d1f896fdf7afa67cb7ca266ed229029b6a29572e0a021ea54e73ba795104609998b9c282c6752fc53c91c8378336a4f708a717a145247a86eee73e031a91f8cd093f986f69d584ad2a60b0f7fbd1f634245d957052e7d7f777579763de539104971f9352588517393f6c00516da5c0660f6ad2d1204bef7f8bf9eff0ee2cfa864262b04fdd5dcdf32a007258b6ede022f2af9bd5ba95290051403c61b3dc39a88920d63f9215f9a72948aa078773662c870460635857eba90dc1e94a11f6fc062f359df2458667172bb0652031e1078d939b4ec628abe1ac59e42bcb519b598b0894943d480a8ab79e9bd81904a6332a1e4f59be225b5da21c99db1a3b83d8ed47c76111fdf486ceb0c41d948956066a7eec9187a32c5d97b8c954bdcef6c0d76aba1dc498fb257feb1ec6c50bc9b07a882ef29373031f5418ee37ac167ddbb9c9b50f63665dfc37109b6f294b0f80f9c749d849f1d6fa304800f6a3c28f8fe4185b794e210660f315b32a4313614cefa5a4fb11260f0dbc8d9ad3f90b3333ba34b4cc16b2743195573e491cfc67ad61d38666061c980967fead523c879fe9be92c7d6691bc18dd5f82f75a8a8644bce1c5eb1661128457f58e5225938823849935552d63b630b1aa9df304a2035b458bc2aeee2d8e16324ac1654a1595c1940f65e0421e4ec3517a16cef9d001052c1e0acb40fd0a47715ef2c5a3e29ee384ed203fef5d9117b7a8e5bf264819b6bddee9492eaa4a12e2dfb873b8d9e3f9181901469a07ce01feb4b7b3f91f40c47b4ad3baa87727c5ab82389019effd111023a540091580613bb8656cbaf4f07a1df22c29f12b00ec5b07bff1d0e134771f9679146d83b0c8641bd2ba0e2dc8afe733c4090472cb75ffbff4f7ea646acd909ca001a37c30c838ed7861ecce057cb6881c7deb49dc7033256f31a32fabb488b0d76151693a32b6bd6dc42b8d639f012ad282bbac0a5a683088d1dc4fcece743c2528c478d951fc244ba74d1b01794db3d0d68ac4d79f6abd460e8efcc8e23d6c77a5973da486a0868700805cd1c5c7274f10fd7c74f14887c03abb6202f0b9db13779cc21ba258c1634ebd4c0384b6f3d41776a6c58ce713c89707c57ccff53af0191f84b3a26fdacf3fa125e073a213cc36529ba8c4b05700c42746354e89ddc0dc59decbda4f74d962219677d11f976af8a0d659279e5666554404589c480a8fa07cca58a027daf6fc85f75a981fd9af25635468a65c1286c61ca90b5e1a7aa79ffef26228d8b1c7654864d03641098140381c72b78d6352f104b2decb3f01bc1e931590a6827c0d8f2f93b8e2996ec2a3a1a79bcc0aa59e5ac1ed412e0f37ea31bff2196b179aeb4900aad4a0d7a2da2eeeda17bd657e6312cc9a7d4c302d78e33a27faaea4dbb6981f9bcf496ef6eee9743434b27181b4f590a197d9e17c604b53b86b6185f64d9f9bc74fedda90cbd5f7f7ab34b3bf11971cefdebf2c1d62c7ab6c262da7d7964b92024b7ce88e802e7b1d08f5814c4f28cef69605271c864875af915e0e717efa92b922b441b4f75d568c0fe5bc68147e6f31130f2bc61dce1fdd0b3e79d4d53e58cfa9ad1146deb6bef4826c7e6f5c584547c0c0f8169fd8d9beaa116e63fc544cfe3505d31180754c1b544737b3f43ac2ceaeb779585457c9a19ae20911dcffe56a45e3322660371fe1d39730d2acf47b6d30ca632ac5e9a5b8438f9da865fe3548aa1a6802910ac02736b8db7413be3e4e8a1b54235e54eeda9e1f880fa9fd238127c30418c08fd6786d2634d57b7de3bb103cbfab5eeb5e8abf4419823c2da51192b85b0100eda9007e3a748acbd9279a23cb140164b62824195c455b9f3c19fd53e7543ac3d9729345368b7cb0622d06cbba867432fa07c160daa58c4f04b80dab3f88f16a6bf5a4f8ea65d7e811fc2c3b9f78213f0f192a66154830f0f0a7eb55b5877b5e748d17110ecd5736c5c81f0f8874a0dbc6d6a24915ad2b0b53e3cb8bed3c47db4052fe239f365bb516ce79e08fb307cfed2bb5aedede0f5df18c9d52ca56133d40ed859dfd58794a0fa0d70c042fc63458fa49c52b9a2ba954cc32cd825681989772cf21875e938d45cf287817455ef412c24c56497c7a296de82d3a89542b5a847c1bf64cbcb4b243b4a0bddb21f19178359e980525b3da3ff027a82140d125b3ea9b6c9e25eb3efcef4c87cc85c761ee5ae749fd57cceb075b8d70fa48be8933336d71eea1132254ad67dccfd59b17b597d87e86228169b0e7234416559fda6975fb4946f5bea029c643cd7ebb15bed7f4451cc33df45dff627e430b95f90eb0c68f97ab794b77b9a7b493c1bbeb2e00b8b6c1ebcb4380a93e6eff8da0338b2243a3a6dd1ce035848f6ae29895cc9cbfdd54a7c9228a7ce61e55e1ea7f443b97456db4c24c0d25d927c309cda7de4db5cd29adeac12336e223a85a03b70099e7482b93ebf480e879ca69abf20b1b7e1f8d5606db86714ee56667277812810d355b4f32b5728c13f5daf9cc14a7d87ea5b50dca41b94d6f7c365728f67b4b8b874b8d55743a47e29ad9e91fc6f02cf32567e88bbfc9d5f3c12a0d310d289e491ff7286d33c4c4d4ceea85fe8e181b25e51bdf996cd7879d983a54d117333dd59b9f8294c95c0695e27e7452db929564f5e509cc34b0bda3557fea07ff7294f78258ece7acd24900a33f76f4b425130ce1d63c016561996346eeea459313cf9498e0a14eef98a69529033fd1ce3747378553396f141da449c0f38b31241be8fda198be189f8a0543a57715b426a9a724f3515e7380f459811976811ed674162d044fb81def92683450e92029f1f9a2d37685f347841385b6e48538df2c831429452de9289df0a71d295d6f04d8ced6bd3b4f3bf55e0d447617dda51178bc1734191158400aa94d0d23cca0e06dcf74d5bc84f03a4e9f9b78c2df51f04e1b5eebfe21ed9f3e4258f55b7fbd7c2a2dc6adf9b78aa7a49c3bab6a56c07e622f95fd50868924b28a7efde631132551645bfcfde9a79f67ea0a9cd044ecc601a6750078490c22a867b1f428441d39b0f227ccad84a5b8fb8a84309f316d0e433041ede9b75548afd171e4666fa05fb47a56336109908429fe4fcedd20a1afe10188110fef5c9abb252c276f51fab48c879ca794cedbd53e553cad4f18afeb1e918cdb9b1c7ca63a73ee1eef28e6ad0d510692d4df72b7e6c5438907b7772210531c0794b56dc9ff86802fa3b732fbc8f61acc1c3477b4882132d442a8fbb54b8ac594f3f5c19e994910a0c65f1191191a9f9eed92c7bce071af1c796624fbdffabe4dc78501af90ad2e47fb4255bcedc9c6e774168c409c9b8971101885f55035ad9dac91e7e9e8f30472a794d2903306e6aefcb69db941c6e4dd0c7552a350831a42305181a9378cb711429e31a9faa8a1c04a87b5b533ced4358bbd34c75da2d821176b5d9e399bcf8f31de6896e607a82ee661001e33dc45b7b94375fe88e991083b72344bc40242a51326819b9f9750555155d12c0492d2ddb6fd531ee41c4cebcadfe3c0b798d1810f7116a0742c9b2f033be61c2d8b4dc256e6a5774772cb1e53e0866a886a3c023a7d508fbb5da6e52a3561984f195f996317aad97dd3872c4e12f7c094eef0f0956ef8f8c71d2aa0538c7121a301d1ab2207d19ea6672ef8f01161c0d448d3544574e32e39ec76686faa2d31af9bc001e11e59f0316cd58f07fdc49cb94b1b5a61d65dbec70947a0b4cbb816819407040901dd2864f364eb9fe5fa39bae64ea39acb0be1d7a35a18b1229d29e19b1fff80213db57210f0ded32b3873a7f0f214c757966020241be336d105a765d15081ac647b07acee321d1f9f4a4df4390520cb02ee67609fbb8ccb739990bc23819b91db80cdd56936d235985f923f372c4cdcf3798507dced8214693fd9f92542daee66a487a4512af9c32c7f50c7f5c149fa6d7db781fbaa9f32b44c959a864eb9142502804166ba4d735864431c2f6633ea9e469bf8e63b950227ac03995da61ce6bb528a9bea0dd97a357cd1c7922422851efa18912a3179f17bdde13ae99b97093b28092312009c4c5e1612d5e096bf1d0503a60ffb42c5d66003976771e69c9866228580e6e39fd5d0e319896cd1b8c243342e32a77be5c2af7da31e9bce723c75be7cbcd10363391c4f88d51a6fb278a2e3b8fbfb0375c629f09033b6f55b846fcdc33c40606d49c52bdc6329defb792cc1c47774443f800fcade718b9770ff24547ee3627805cea785505c3913c60fe14deb3ab667509c04aff7e2a4d6e12dbbaf10d3f524b591a5edcdab986e1151c7552c7a4c707cac060a52837c86f84506f804e7fde0aba645bd6ecdc9c116556c039f836f7f65f8c60d27752db9e07fe343a6df3a978f2b24556b87fe33b53d0b92136ae778257f100db13c570379c89da2fba6f60b1150dcb5e2d23bf51170aeb8cf0a915967ec751e9b967a1f9ed02a1c10e3c7fdca829c8eea424e3a67fb8e83cbeae17b67c4f3aeb7ef134bcc9caf94085c410dcdd66efd5fe2bc281d593584687b747b46dd5e9bcc64f61bbe63b8bc28e3b6a547c30997457c4bc49c33a809acbf2812067250fd075a5ed9de07c0e2fd2e3a6c5123fc0250ecbe30c6897e901e36932ae2803ebe790183287496ee2544cc8bc6b7175c9fa69035546e3552bdd54c8b6c1a291ad2d50946c72218ab2d8e32a361e6923edccb3141de8606f397127e6c52bcd0bcf2ac9c0b58269153447e5b65faf4b55b88b602e899be571d5207e30e4ad0e2917d7e6a844f59d5f07105b66e1e6c81b35785320a79305ff0db9090e6771208a43a8beed5477ef6de3bfab3fb2bb172c56a66fc859a448a4e9e6a0c0e2ecad525dcc4af978daa16e1045acff17142bd21bc2b7f09d7f49948c5069fa5fb068222f21004b61e5388034c2f6fb808a66d8b3316d80872afb0ea2b276f5a9d0a5518c1b53a4e772e6c26241bb2136f74a21caa19ab8d8c93b6207faccc3d65b06160cd2b888e5909bc44872e0c7153d3d57b86f82da25f2227235c480ce4fdd856d0193c63d5add70ec6d01c15b964d325c6018bf7f8e871590a7123e24fc7c134cfa3f317d766049a10820a93437a96cb04d199ad1c8c4446fca7cc68a76bbe12f4081479a121f84cac703df8b9f7fb8117c8058ae6d4f81b011630e45e74d3bee6d0e4fbfb77c8fc2b5629376cabe26c9bb0a921679195e697e8772cbda0b526b588323df71dc1369306b8a859f75d577285f1db338ea0ad7cf30aacf50fb2b67fc1f04429280002cb423c42318764bf16553d9e7d48d1fff09ff2fc00","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
