<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43d0436d5c15adb823ba62467c54c2ef4be82ce0a854a7166a63f5f209cfc8c407b3c37f632368600dd6ca1d29e439b1c01ac35cc67f5d34c716d6e03021df84e4aee47561c8d59ea38d0704ef474bfd125d882160e273b0500ecf46713183f72f9e3fbc6139bdfa344318107d12d0e5724b7727b607a02563bdb5c6f110937e02293a6b62296d1f6d0f5389b51a31d4daafbd57a2d8d3752a5bf9cd946ca57c62ee584276a2c30d86b15fc655c40e3b54ba6e9ec830e43a11ebb5515d03ca297ecd61739c6c6e061371a99a6e4fbe0da938212eab20b4636db89860bfbfe86e05ecf91a06bf50bab05cf1d7a2bd9867b0d7154bb8e65698c254f16518e6e19dbd03dddcb8ebf9ea2521da5ed6647362bf6ad5ca7a026061f6381538357490e3dbc42172f86cb7f5a8c3535be8fee994d5240bc1aee4a77edf759bc0b718480cb7d7e29c9a9cfad3b8070a29756bd5ee66422168260bf76af6b129c6736ea910b8c491542c7d29947c39fe5a907137b2362a4c47eafc919dfd6a981e3a9874fa8d899046f36cf5369ee16b5eeca27ce8dfe9da73a6b1500617b1ce3713a409456afa74b7d020ee765dcd7b3385d92bf4a138941a20ce177c3b8669df240b3fc381cda71812413c5ff5c5439d7cb3c53278dc331f7a38dcd989509e84d3d2c27c82646ffc7779ac856799d8251e5d29f9fd34f2cc520c5644a4b9f66cdbd3cc4196681814fb94a3073bf36b115c600b3304c6cd642e74ce228f03504d103a25fdaa3a6e50eae0f0087036bcc14dbbc02476d0e1088a0dc7b593a21f9159bafd1f3a4a4c58de050e23ac8b27307520299c246e91e1721e66b53f81c943f9cc613534e043e7c4a528638321791e3f1bab4d30b28293913170f22dbc751dfa9b8a4c33f1d4f7680667b16ffa833b09db22c8830da3feb47ce822e290fba4e69cf1108bd0ac7577c318d37559a35933b25c654600d7a2e76aa3ac9fd7ae2f77633aca13544463c0dbf2b343d0a4fc102907d1b8a4e8f0036dd8a58e2e27ece1c300b12bea6c4d9b28f5287b28fddd4122eed768f7b8641c1c064d25dacb801d91afda3b6eadfcf94b2b434baddc76beda96faad2cf2ae411f29a5dd2bb6cb4dd45ad30c1b57b678901a6ad983a9dcb501eaefbe97cc1d3d8bfec2192fd28709f1d91bedbdf7fe7b2667c41bb7725e57c433419a0f8926870d6eca927f0c32c8a4aea9d3a84b06d1ef156c73b220a58dd6c0843b78166611ce69567879d7e4f013b6f8a86fcd2a7e80db66a9fea4e9e22ef65bee13300e47dd5f0e8f76965935502937d3a8653e446f834dd71469faff53b5f04a567d35241ba46c83f72b268e140457dea63f45ed1c069eeb4c437f503f6fb6c179b2d5b3ea976d6d932aac3849ceac5cca762cfd4ff16011a80cab08ccdc0ae3dead7608e06f7f3cd16302c0cd35afd87800830632949af4e65a0678f5c1c6916273bf325347950bd8dc5e79ba9aa355cc1d01ec0c832a39cbb9bf1aa0270d4ba3f51428f3a9b0cd5434ce77193c8154bdec6ac72572883bea2ec0791f58927b0034a751d1df05aa292b7ad5342ea965633e1d89f3acc4a09e5a043d95f46e324dc4d8a49a5a9a01989985c3d1400e0392adb43f5dbc3762831e00028f7a7310c4af392ad40865bfd121664b958f8127ea7de583e66fcde0cc2c2ceede7fef4691296ee421699b282a84bb4624e83a6cb92573026c78f462717dab31dce90ef06c22b23fbe2e4e39560b6b1489eb68871f08a46587fa178b511db554bef05f88e90bae298b2ec445d1743dbad29a269d9b9745a0cc8d8ed5326657cad4543c32fb1397b7967b1f3c542ba78cb3395bde415a20f4726274d77a1e17788c3845f040b2066048c341eecba1b0fe4151f97b81fc55b4213eebeabde577dd1d7663ee3f3491f4c45a5f57069048440388b683b646e2d6acdc105ac12ba09b2205d8a9666c9ad4c366b1e6583d9c1622452972e114bfaa498d012b6c3f4bbbe9d492c657e0af4d81fd831ff721ceba9f5c65a83a8c926d743e9086cbcc56a3f8c73cb9b8902d1d4e7b8e7a54e26276b08e3a903a2c1ef74f2b0ca62e8cdaaadeb49fab8b09c0f08674d77c9a64472295581c18f0277c08095a1339e2171ea7fe9e435c56ce7707200adb61a223a8d79da3720fcf97bfb7f91e21c54ab87addad962b6272668574fd298ea049a7afdd65567a849ec7267207f1215940e801f19e73dc291db2d9942f639c2d0c0c1e732558a729a36913c03ebffab3f38606f60419d400c9f95086e9148ae1c915ec27e30006e15719214969c936eba2bb60defcd40a90057f44ac911e7f0633fddc3ef255ce839026fce26f4f8fa1295faf560be43be5ae33330acdfbaada014943ae0c9b74a32331cde84bf8fa63c1124e6c573c0844f68615671f829ae081fd5bfeb4bf5c7eed81b92253d6e2485642eb4655b068fd7d7a29bcde7bb4f6d94a147f3d851f5f6dfd021643be033aadb4bedb896f0e85757cb958b4327af60f86f5479ba75fa32c275225e427fab894524008d3ca603083c41964a1715e2ee421306f44c8a81f8c22b47fd12aa728c4f6a19c90b539fd3ef825f412e06e00ca1330ea1f0746d81375ece5fcee20e9c4cc4a658c168608dcc385593a929397de376e7b583e50e194c1ff6dad693f9dfee9cd28d88d4023101019d1d325225e23a58b0c28f0487894d31514b3ae92a9e267aecf292281fa9921626546aaa6de25f5e5d2a234af3602dcf01bad7373983805a6c65966d2c35fb6ffc794fcb8030cd8ea99556ec1f91b2cd24048c0fb7241ae56e5f102db380781301faf86aa966f8bf7aeb67f87083cb79e9597cfb34814ff9f9df03c152d5f4766c7f5ca39d8ec5e7ab2cf3a37ab4d7c68843cb874be16bcdc25d872f12a9cddc69819ac7374c9372b571df18f83a518775c3049a4779d5c757e706409aeed1195de34fa8e96bb9a8cc4cc239d39e4602e8e8149f3d9117054902ba095844c69e1e68a876f565370d2829671fa28dcb57e18dc7cf2aa29440cdd770d23fd4704c6a902f44d2127d18929da2654392fe88fbdb37acff8ec7c8d39499db638175bb80464bce6d930579ccc7f8b013d0b1cf7a7fef2c4259ef11541425b99afe192afdb1bb00a9649531f235a69117d86df2e56c719772495f80e089404f510fdc6b17b276f22c3747490dee254bcb67dae99e6fefeabd735fc03806cb7e85e80343429fbd69cf81e4832a06f2ce60ec4aa946d88d0c8f70e0c9dda4504938b14470a88c4394667bc78900c2c117d25ef15ec13506c3848f69b982c1a779c850ca6744725a5b21b9d3b7fb8a9a2a253beacfd4f4e8b62df7a0a15e4d825f59494fd3eef8cefc543e11880a31bc6c1564c6df3811a4a37c882155a9f941a511b69fba8c64b8b1a15f3834c16f2c19502ff716f5e9ba16d9a18548dcc2b19d2c13249c3269502aa3b90f8d7e40845acbcc3c03be48c228d5ac7d6034a8bdfea114cb43dc5f28a53b86f2274006e41a527a61780fd99ca6cadba67114eec58dc1e8abe5f905ef8cd9f01b71d02843b85ce72ab0aa21c27f30a5a8e5422fffd3ddb8decdb5cc749016dd28f4c586a5dcddb0835a6efaf7929a2f743fab5b103667e2af8416c794649ae9c7aa47044f8d16e74165107328edc62cd02966e6c25e3c7c4e2202a0a921869d3d152cc2fef405ae7bf1d7cb3a2ca52e496c0edc4facf6133af3d7d30cf2caf0d87ebc8f55f7f9ee539d1a8f5b3fb744918ad3032b3efc2f1844a9bf84e426084531c0462c2a52dcbf48558e4179c546a848f969f162ec51bea6d5e09e704cb28f808733ffd234bb4f25667449552bedffd33887ebad97be1292c917e5be053edd7373fef61d7398e7dd12315a9453257a4bf5a290d2ec9b4e8142749476cbb285114d5a4c052c6d489ed79268090208f49bd84ffc9b5456ea50b63ed139e67860547b7704d04485b41f8c5d4494afe73b503e5ab21df69b5f991c8ecaa25274312bafc072968c36c1871f4482083a4dee3dde870f1baef989762a93d8328e01bb1bfd733a3bb865ad606a33304639945ebc093bdf62ca98eefef5b329f6ac1b3960531ed95b064cc37fe17093f1b54dcba6a4bde169e9719aa020a69cc8d90e66909b702a5537a23202bbcf06994a1d7ef628b96ec941a1b5fb7ce5d6fcd4a09b7c34336c2c5360f80246dcaab7fff6ab88788ae7394760a4278fc4185824f78d2d25f3412f9a4338d45c483efcfcbe65ab6b569450d8e3be984afe0070b7321cc40fe8b08099d1562aa69fe4140bb944a75096d9746a417aae76b8276107a7469310357cfae4daaaa41e61998fab28e087b9fcd28e53bbdd89630b07ce9d6c6a7dcb0a652f91f902653198cef4e6cc2287e5ea1fece484e621e7db299ec4d39ab1f4d905ecbaf7da088583551f700be61cbcec74a742d67ba7db27f5458114346ec1a8fc07cac305b2129a93fd0641faa27137d41029f01b729516d105d30efec03e8f272f3a01f14c826c426874b042ca83c54a282bc0dfee3491c2a8f603cf72764b040a4b1cbfce8e761c26b0a411e1cd4637669d7425dbf7dc58d1da77edcf96520a5fd41e68dc0ad0ce345ed54730513c8cbd59ca2ab9a6f070b01fab1be466da694b61c9b63e6534bae21cc56d388cf067881086d3dd872b7c7fb8d9d8aae205d338013c594d375eaf740a05da171348cbc63c43e36e046ca422bb2869d48fa2958ba818676ec88032b43177aa9380dc05b64d8a26c861d75b1b543963594bfe7ad2e679749814d10df4b6043ba44d16591a40f5729a52030e0c6546fdf93a25f181adc030f55e5207a04b4df10403cbf8ea3a47b1195868a15f32e97f3dd3cd40684b9bc3319331510dc104a5a1d46075554f73f2b85f8997925dcac127b96229e9d180577c850e9a332eb14174253dbdd0d124020ffaf3f4caa8208645ac6fc0cc43f39b7654a8f548e8fd2b97678c95ec3fb0f325e3b2832ab2713fb6653783b75435ceffff5ed5830432cbb2244c8468cd72695466f8a1e8daf8778eb20910942735ec8e1447d651878e505571c43d5f3aea088ddac240b981bd030a6713354b99d5836db0b9197114ecff48c8801f6199a09d4205acd1b04826d9d8dd77158c6d543cac275302a51fb2942ddf7014ce24bcbe4f2a6cad84e4096fea9767486e4fcc19b510cb9d93753dc79b7e7dffc23edb4d723a3164f28aab89d01c1efddc977f3bb6dc5fd67ad61094c16b4a2c7b7c00c40cab0d071045113934cfbeff4f4fb559bf7ad459414c918e2624bd290bccb8f424b61e65456977c70698c92433b890d1bd20e3fb1674c26218068eb4083ad489c85e53e0a8922873ebb66be985224500282b8e0e7be53f3baac8edcf30bc22d4e95fb55807c4613ed88ad168631fa584074851351624a64609c350a1679609c60d0ecdce438998336c881a36ecc54914339950b85849699abc02e7a66606226f940309a0879cdd44bb413f45a277503edc1304f08790eb7404bd5e93b6b340df7b976d25c728d4d9963729f8da825d2ffb80156fed6b0ebae9b4e70ed20220c1018730945fc4f423122c7195ce634fc197525e81cb16bd7ab4c58d31e0ac1a6020331f0a043565851faa0d0741c16ce8f603dee58fce6c3d818a018e280aed7e4f5b3529b5a0c9aa6f3dcd6204d161785d506c6558b18b7a267fce9450c493586fd7684c6d22bcbd1e5366d431ec644e07d1a1a3409891e04dcbd37db7963b35ad7805e65e363444cf27451c786b071f6dcc693d2307f17f81adb0040caf5dba63809f1e191d3e02f3dab797f5f306cf543a7ae998fe4f26de93249f1687f93cd9a1172ef5cec3158aa709b8b68c6762f5b0413e5f4648a7cebce92017c93b61438fa677b698a98a2b06a936d014c89820d6a3ca04361aa8bc796a05f814ade10a8042c195b93bcd4611a893d5e34e6ef85b7f6edbb78577fd9d0e12d658245f0f77d843c9f7aaec3ddda7d2367d3e9662a8be9f09ff2831b335c88bc8e425a8b9d1708cebb60a314e92780042953a8d37f4a4650e65036b125a2c59eeb495f253ce5dfb07404bc6ee542371cc2bf9d804775eb27f584aae9a12a7e1abd32ee1fcacd8691e7269542ce9246071f04b017a5845b99828cda89eb9b1434e4b68f7cf5893383723d3b4205d2e2bbf6c3ea0620f12b0ea75c89fb86fc7d7d74fe0c2ceb296c5ff38a10aea129c25659d4d2ffdcecc7c87b0af7eec5b19fd7815e928a8e9ee63071e6c08401812a7c97d2bc77e6ae341757f32c76015cce6dcc389452e99113d548402f6565aa8bdfbe1de4e08f236a4cfda032b8c63890c94f2a820e5d7b3a8a598e7027becc8147587f6616d3cb69211bc60798667b4d61f9633dabee7a363fd576a935b98eb4e954151b126ed9f731fbb72534fcb5dfc9ecb92489ef63d835749047333af3f9a8bbe4e5d3e1983d4c5fc589827b19a7c1473104c38dfb0ed361a381359c6562c8076316d86fed6ea7c1abc7576b71ebda6ce06809db3e233e5f7fe104e3086519c17cc6846b8d7e736fdc0f46ed0c76a5a1f2f58ddab3bda3a538b2a2a1809136019b297b8c46f7389c78d1f9a61021c385875639c3d0facb3976c686818497883a86950d3a5404c1aa18cf394d8dc0248b9cbb98eaa7ad502377f04c5955a1cfb16ee47e2615cff3921eaf9b6b29fd585de7ede4fe7cb1efb7f85f35871553ef98896e5a472e544fb42d30a77557fa4d0851c0eba4f0693a290a4dc802830dc840044eb93ae166831220b7afac84edfe6f89bcd5df78181b408ee0c5cdc3fe10efb9c21f74a8f22ff556a4fed034c37678b6a126bc6c83abc083b6dfbe77d285e9f5770be749efac145603bae174775b5b5276902b62b4cfcccf07089feebae6b6476875a6945bd50b56305fd90baa8e17cc0f56da0711472961b896bdfb4780814f374fbe9f29c451de87487116e5f9077eae374572f5d5fe8cac869651ed83c83687ff7723e8c72beae2a51ca5615eea72ccaf81279c90b9ebafd89093503d9ade68884f96361e791f99783401aef9a2513b791dbd228d247aa160f83829eafb7d9ee16fbb733b731b323e0209050808749ee8f22f7075a591c737566208aa11bc7a3480e39cbcd06c6478cca395c2dce8619985882eaf914f3f019d85908c10dbef2c57c8788fef6e7a32475cf976e03000fdf36c2bf290223005b5dedb09fd3e148dacff95389998bf4f8ac0be6767b9b2336f9227fe6cd26a0c38df69b06db86f6b4c971fa1409ec37b54c1ec07b9b2fd2844eed955380085d023d14bf4fbd430bae0a9d1d6230eb244cf78a14ceca9441dc2cacbbc2d9cdb2fc77630acdf6fa21a9346f78a988ad9f2e45ee81a910ba045e694c4acb0820975e0a81db363c58659066172c64e3297b9196f61d000dd3a7c32eb85c7fa2147f325db143b8c0cc162fc231007c877721f15ea4071b9f1d9fd14af5d50627603c427feb86c16d8e8829303403a9430765f65427658a9078aefc2aa9de0b643b25b9d4f2e12c50fec1d493d3b530f544f23647a5864baa78abc52a143f31069f8858c4d37c6f68799586598f6a41a2cf5a02f270bfaae11a2d89b877b28727ced733ed37e7ef52640c7c6a9700b2b12f3a5e11ada3ddd769fcf6c713e645063a37387c0891b2f03030839acdd4ba41ae6f34e9b826cc82ab27586c8b7b0651daf1f4e4f72bf4d5792a33652b1581db0b39112469f3d6427cc42d36919e78e8bc6b5f8f95668bb4c9829b2e90f8699f6e4bd02924d74b332f91ed8a5e1ad22367b65c2b0bf5e80a4c65af7807b6887f50a882e09995c45ea9efe43f1f3bd0b87243de06e1f5aed5b4b45e3e2c21e770e4c74a5310bcf92cd5a5b1497d5789cf399a2345bd79abca4d36b2ae20ac661b3527b2eb4a8f36bddb17cc0548f6c61bc05bd543c30ff6e4bfbb6588d672b8482be8723025cc4412e87a1f38e57be5c71ce94690951aa97f72518d0bd29dae643fb558b040519f43522ad867d5d9720fbfb1db1836af3d338b0e0dc6082cdd20ee38a2210213c1ae7df92ae1045dba0fc88366dd354119bf8ba6dfcd33664bdc9fa47e92a0a5c4cdc5b513ab39900158a76d98f8376f255a1a7390e914fbf05d8cba47bae824e3705b6a9d117358719ddf744328baa74ebcb99c778c9f2e9d3df7b38da0beefb6b22bda519f4cd9443930a4c404f6df98aefb9d3b0e451b6a697e7fe5a8858d40595c761d42511325a773a18d49510d37711c062d9fb56a0d382b6b2e6b1fc99a1677844ecd7464f032f52c18b1d5d6236db03389eff9cac8ccd3ea9749d5e76f39d4da9aee54e6a1d247aca009803dfa4c10bf68c9097c30c337ac589415d539750ecebf17488a084ae48ed1a3e58fb9b2efba149913b4fb5a591544abc78a314d7d25dcddaeee9bd2593463261b86f2462de8101bb581042b7bd4dd227c668a95d64483ff1b1dc171d08ae244d8076963793eef5cb60082c7ecb0e018d3d7484c38d6811aa8d411af7072a0c5df3a4d1cb5c962f8209640383eb1515081ef12f3687996bdd69d7d33d483640b106a629b107297b5c3204ad03a3659c9c6283fda70e9067f53ba7ad613a9633dcbe011a2ed304eb70694367ca5c690d7c68582326f4a0406838a14e610a351c9a8568ef1202de4fbfeb815c3f94cb1f26204b7384fe7e3a9867afab85051eea34943bd13079d34896fa5a561cf6f402e0ea88de14b340d375e54e64016aba4356a7a817635341a6e280ac7a6cb8b88bc5fd5f7d9e3a2b7b8b54cd8474c247e1df123b485e3ae3c920122f3029afe41f77c0dc6229f4b3a7c4cc0708e4a326be081e6915e5518d63fc475f6d833f62f28b7ab60021a939bfc87bccfa07f55b09ce5f40c78482d76de43b099cea8ae23540dbcbdccc24f098379a9277f773b820ecedcee3f5115f513a03b41cbcf31ee0e53f9cc778cc4a6dee67d76b88d2b6dbaed9686361153bea020f86f8796f0950f7f1e13605d63888ab8e6b3f176a83037a8219e73efc2137f297e2d5f05c082774d2e071243cda1a17604fc90bf5caf670230dc7d8ca8bf89d76431bb917bfc2784ee85f391228650a5ea864877ea894a45cecbeb965fc5292987bffa0a40b496528c664b37f9755b7d9750d9b0fcef09d8fd8e276a5316912c513c29fb4b6610cb3d0b8c4b819665e13e61a9328d209d6434fd4c98f124e9d85e6fee97d249865e7d56d5aae00be0636d657a72b0e150cd522fd746f732b2f4dc65453cb2c31ef6630ff050a9d0f015492ed6e84e06eb0cb5fec833db902f17b01c4e86a8901aff4971c84092c536a4871626e88fdddc7d2813e84eec11ee5bfa689bec4565879d862e6fdf6271a9a6cc506c486475bba9b52b9ab355d859f16b5790cc8e694243689b2f1e6884657aff598964d348abc1b69c1a41e0ae16413a99a15194351baf1e5e132a1fb62c8fab3070691e30e9b7857fb0243d65bbf0d615f8609b21614fa4cf6cdaa7c5e21bed118850764156ebf3bdd913adadf2e65bf5c58f832db76528b4437b8cb1c7a07c94c14e9468ab87b2c10c9040901bed51cd819bbfa37401b692f51fe746f9c8b1f4b3731e6919de7f7496b71539dc3781cfdfa4ccd1218e4bdb1f35cdb4b172a73a458f26a709a341c85bce3243f118c54ba08093610491efea56160c6f9e8d246f91f9c4acad20c544c4f49aeb506275bcd5749ee61ed29a84aaadb1e499d2a90b43c1ca2866a15624aaa9fa8988588b231e40dbb4514713da3765f16b6c3a1b076c07921eed2e9243bca80e8dfdd06d01d69dca3cd759e127aef37e717be896edf0608b5390a2dfed320417eb14e00d0c0edbf4ef65b216b3d7a7ab79922bcdd6e918c4161c4893c5bd1b89495dc1bb39fbf221a87abea26e09e2cba743e2945419efe7e057b0538c9d3b07197df68318a1b0eb14af8a728fe9f6f544056cfaefd0b17d1a1512f7dee9d9620a8f0fc9818da377c351b845d4024bb56921cdb2adfb40512c1e6756275c622c055aeff2797ba5434d3e7f16fcbd2f40d722e59b1ab306d04c446ff57577fba124f18cc6de8ed47fc8bd22a6d02157b1584c27e150f3e21b90c8d200b9ef2ce7ce1076e5bfdbf6fce50b2fc7f99afa802c98c936b4a0e1de84ebcfd19b4918e804e0d39ca8375c93ae0c50a5f3d02847cc45585bd8f895b5d563e01db74fabb54dadfd6ffc4d214de8099da8989c73beac685b55cc8bdc37ad93447624bb0a917cbaedec439db3e43cb972cd643f1f4e9b0506deb54a2a27b22d3e4bd7d89a822738a06f598d1088067b37654b67ca707b4ba2f566e4f33c7592a50d067f03de7670f429429fe337645fb313e8c2cc57e71317ec0dbc467d563fa6f5ac0c9ad80ce8684f2c5a51bc31b4ef2456fdb7e88f68c0e78c0192c1868cd5e1772ee479632315d6d4a4afa7ed738de9e3fd3ff49efa883be89d69e84267b103b556806faaf6be19ccc090a65818ade49c0384afa70f7052d809ba462047cb046b0a7ee9865da3762ab646200c215ef09a04b47a24f983764000a7c02e6a463662864826f97608ddef88ef30fdb21dde713679f5d240085ba97ee7bb9901ed1dc59212f39663613be8ce91ed76a8780c9c1e655d19dbd62c41fa5cb6411bb8beaf37621a8c03ba9c1de4e228c0534f5165a4cc8571907f7eecdfba14c2b014b540c16c00a51eed9aa6398b9864d98e72c37e4e0577816bc1dc4a45dda7bca710e29008241616af63d2ade93539dbe1d3b519f80252304d63806bd393e5db07e0a8e1b247dc01934c193c7940a1302982999d4ccfbb3b5c5e5f398722f3f4757b51322c8fce50a52f36465e15cfdb976ff3ba13541b81fcd504b6894d6997442820b74b2e3c743986191d0634976858f38e87fb8dcab49a06da83653f16827dbad6dca1e6d354d41b6f25f025c057052c022038db0dcb9f72f695349dfc4a9c27482b70d36b1a2eeac711f054d3d1531cb9370504b510aaa52fd5cb98c602f06d0135fd7ad320c370750f0f40f83ac6b32b19be05b703d777a169d6c627d9b5f21bd2a11cc4c3b5c572f4190ec11f5603ff4e69d609eb77e91e69c708ddccfc439db84097433c03ab0d1dace49f0ced4bb4ead283c2767cc183e6cb339a96a4f638d16f0d456c6ab130eb35ebc80fba5ff9db4167cc333e85b840d827f1020b84d5cad340f6183bc827402505c0f519e4ccd9f7b3ed582b16e459c6489f3d2536d14dc17e52c15e0c000c6716d561e2eb0ccacf7181b4a629293544c8ad644275868e36c864f2cb0b83f989fb1c96d60bf58a4fa86b2a41b8d4c0742713a79878acf6e360e3a82209ff24a73f64656edd1586efc282a60e6f6bb81bd5a34b87adbf20ba50f16347d70e908cb9a81279a21feac46b0527cea1b7d4c5c1af75a4e038213b981fab0082d8e7b67414eeb29facd5cbbec921293050e286ad633c575b89c095653f33d48e968468a2775aa2ca0dea6362bcc0b8c8eddc4669a8212abb1a5bd3758f67e1b853f77dab96bb3d3691bb12462c4dafd43eda7376c1bbceb6ab764add573cafab91989cc68e54810a3210499291a98b5d5534cbcdc0f4a9c26f473e6f6371c0557ebae6ec52b2293272c0845baa3a51453b400bbc972948db62d93a80c1b2a27bf7f6fae5f9fb1a6f13332f5c898bb1348299c0430f0bf0d2e89d34aacd98e523614866f6d35ce56256d8443225b385d05bfb7f7043cd08abdab87d7081c0ef3f81cd2f7e6b9487718f64c4177ed152f99e0ecfc6e54aac81bc740c2e5cde0da2a494ea5bdaed4a741b9fd2843a0ddfa213f6a7d86bd7a77d607ae25b10bebbb409ec05a2a7ea236fd0117c035d465727d17df8d0a284cde871f76d863546c6a0167e56ed9585524600689ea74c81793d9686d985ca4ab488aabde3ea53076b6754a284c673a33da69ac73131de66e2a60f3a149346594cbede5515419aef195a74c3dc0ae5be870df1bc4876adcffc73bd84646ef3ea009163d3eeec76761b795b8a015a3f51ff41fc7da4ebd5faba478a4490196c99cbd1fd2170631de65403f27de767e61550a235143a2e22561eb4200bae3ce7ec188148d40344c282c5680817c74b4f0d217da54a1f9d867c84bce8aa2ecfa7c344563408997928fbb281fce9839e7288a737297426482b21c6bc99776b936de4abfdb078908908c83d07069f7224843c2f038e1a3319e96dfc4cd0b06d31147b1b534ff2cc046c9b4f755f60e1f8ca5e51c84984f9c6e0d33607655e7a2c8c86b23996e709aced4cacfe3e443c5af8a38f80493c8cc1a8244dfabc9e6e59642c65e2fa8c921333a168ccd885abfb9455709de8d8d11319d46819ba4ec7282c4884cab333d4fdc6e6598be8f664cd3fd108c45ea9a2f4085f4908fd6fca969276f383455b3159a38dc66e69661ce73bc2bb993f2c7bb2b34a56720b822edb1bf7706e64f00e43a984de3579cb8f70dcfa6715d44dbf26a03490067c033fe926badf0ce0d733a7e8d42c31d7eaea8adff082c48628569252be4469865f0d97da24b478652ae3410536477047c0b1ce6e294c51fd8049241ffeee990f00f0aa3f6a55262e1e5aa0e4d7bb6f06401b587a51c67524720ae840fafdf722db7a8c9e42d10d053314c09b5d1e99c1fae6aee1cc5db2c2f90180ce7f03ccf0c09dc0a4071d40a907f0911ed86e2bee5f33257138ac752f8f908a7d45357ab543dd5399fbe273850a0e452d30f9abd09bf4f892fe1dbf73457d517ea7a59d1f98ca3ba26a123dfd6de838af7bcbb05dde0275b0b0c09cbdb8b5731d0f025529cafd05a035df2c94b0e24c2ee0a4d9988e4ba1807744afc729ca0c484f71ee19e8d9e68fd0ed44e0fbc0f6197190b78e5323c22c3502f9702968d7e4adb265ffb88c684e5e096d0948aaf754507da08f3f90f7223cc7fa07e7f5e463b926b609da6201d4e8597f0f532c9928a4bd94a7d7a3ddf093fc4ad5887e16f6fb36df9e927b6ea27be9a05f770f1b2a9f90b41d70f20456f25ffb69f78cd6309fe50a5b2b3330025640b347ca935cc93e401b4a5b6f9e1b282e78bf6ad467c3c475f19e31c003708a54757fe9feb4af330f1f489b06ca4a8e45d8dac250c704ca17c5647a5a331d08feaab64b64193683111289cc9614bc03b4c26e00e719d69ecb8f228caf1e6e41ab9c215a2b67202ae291c56d15eb7f8b09e3dda8c7c86bc0c5234ff6b86097e7a2b7ae165671fe2361e07434056c8335eca493f6efc2391e41eadf7c094f9107aff1ae8f1495bc5b64f5d7b853384257ca935972e3ff1caa2f93d8ad0414635c7a3b2fb8abb0a672a11bf2f0b025c547697a7fa2d249d982a19e3fad38ad1142181b58eced821bdb2f2c7dc5a54ae47d67797263d7b14a20660474063d4823cf71aedc72dd382dca93210399bc99eba97ef1464cabc6a703be69fc199540ba7e4b5142b22fe878b4a4be2335609387ad323ee2c7cf3be374a009ca14740d5cdbee5f00ae0ba0603e14f471f33f6a89f41dc6d8455eb50b68b432dd158ec34fa7831693af75bcb57d3a96529373de5a30d1c675164e9085564e71f050ad09ab9bcbff93a05c0148ee0bd8d38d5558695331293eeed47a5567906d6d04cc86c85d7736aaa1c4cafcfda5770d0683065cd452cb3e80ffd0dec2aa51b593ab9b11e6c933535374d458fabf32ed4f88122005a660a46062d961e2536bffda7a92fecc0ec46d48c875df5f8e7c7ddb5cb0288267afd4a1bcca94060540ae4684b4db69fdcdf56fb115b5519201b44e9cc0cc1747c8721d988f114e0ceac36d0e339188b62648c2a399f4bd0ae43abf724464f0b53a43d0dc0a35832b9b4bef4225e1ee735fd8d6a1a6e818c27047193f57a75927db6278957907eb23eeff0fbe86d81b16e1213f98d91cf82d6bdc726c96343d6ff2942ff4ac37d93ff113cbd2e33067651966dfaf72f3f78c45896799d70aa4277ad833e1af74fb7a298f1de3028be7961c719a18a7c6337b791a681104f637caa45acc4384e23d275e91e34c84975c09a815194e89598e308d313fc2e704b47c46acdce8bdbaa1bd8505fa5d180c025985757b2d7d87a98cf4405be10321e81bb3a5240365ebadee480f11bc1496d6d0b2b30cdad40f51c9770ddf784defac26aa2cfaae2b3fba9b26fcb94e136ebc6fefb21fac044b0525111275aca8b111be6addce5b717ceb561f87be752dd13374881942a4f888c2ecc01c2b590f187d32e6f79d40d7351e7c27ab2b6f69f5f8fa8d9e88f3267d519f88798e9d84c5e0c1dd604369a3828a228af6f71f2e4e4e0345603525f72ae767aea3078e651c82f08794843113e71c520b279cb0225ab33bf9d74c587529a2609cfe956520a2ceddfe8c36dcd6d3cf2ac83d2eb4db43af089aba6816df3cb2622d5d2cd569bc7ecd0804028124ccb3fde0d9bf7ecc410757f8da4987daa417d7798cd743e9cab2b0148897abaa4881dbee32f0dea7c6c150674714829c34aedd260339ee4105b482dcb320c73f050ad501a71c683ac6667ad19b36a2b8c0e21ef67f70d40c4d850806e37c94245b8bba57bcd12a000fe536d578c332f5b3c0fc84499f35a19e923e7a6e4b75e9271e66d4619ece5b73a2fd072d1b5d19160983d7a538a0af8be00da51a91d8dde3b3387b8f9e29f7782ba41ad300ad233c33e1f90392080e5e431b5d766cfe7082356c9f84994ea0e2a07b99ca0da889d9d7fe87561ad834f93d656d2aa28eaf2e5729b2f448a15ff58cc3086d1cb6f3afb57fe0fef73e32bea07f5dea80905e4200e0944406e4b6707394e31f1cb7abc5ef3ec6267719b32b2333622ffddfc80a34f08a4927b464d4ec64a16e1023a331cdc235a17c5515a819e562e0233ac595247a9150bd60c8cd4384296e091d4fbd62d32d5ac76498e217d60291723474f535f0c6cecc787ca46006d5be757a9204b5afa5991501b90107d63c54ee46e7a8ef0d15282ad9eea0e6c6277d913cbe85d39090a4c9b036ba7b66f8ada9a536637fda285482fe0d8754a717438868caae554abac44037abb9ec74197b41dce7fed380d9db0d1ec442e244df766faf5f011c6b9a0cbe7d81f7c05fb82cae251d79f3ece7c781580f65468080103ba03c96fb804941427f08ba3db97c39657da9f7f1f557011b9ccbd5398e68d0f17ec62035445a3ac89c36985f7aaffd8a24172f08650abc78798cb85449827b5dc3fe17fef27f0be10fe521336eb77b531559780523a41a95e683e13e8d579915ef83802891368a33c28939094b28d8677b48afa41b39a57b2db835023d7c67a9fdb259ebae94604be05542396cf8c829a38ae097041339420df5e596d27e51fe502fed5d420fd9ac8f9b35ea915923f2f9dc3202d482587e15d035a39466eeff1c0fbb6f7f7ca970669217b75e1762f0fbf8bbd3ca52d9fb9163c32791294937276ef46871da78c5b5fc235453cc5d818ab2c0957da8dcc207032652317700b246dd0fb1104bc4c42a51f54df60ad1d6baa59049c9c0c24a8d63f5d8de5e783dd5fa903f66445e0d592b37c51f039b0774b0a3bee228e53415076fe4aff3083bfdd842856c6a0724312dded8cfc12d7d0ea7833c712d3250fdc5047a7a9ff5aed9ccb80bb1e3dd00120621b5302868f070f995338dba63d47d48fa56b9a2d080490d7c92a780e3d0862032a2f1fee0478614e82a705a33eab0e4c347e01278e4407cdd03a43570444284559621c3487dd5d0a5267ef50c0c6a732d4fd4349b40d81c6203bc94d6366eb6829d5c826a42a0d9becfb17749cf2e56aa4fc47a52110a3e2a2da28caea9c5d4d5d5e0d6473e4fc497a951029f5ff4cacc186b5322decaec1b6e0a627d7ffda276f1a842b6fe704e057c4d42f065910cbb30e4a58f9f3049c4d0bead6e272e10fdd1c221bb0a63b9714fd6d6e1b9cac8317638cc9464488c16cfd0cdc534b9f1f7877f5a5d856af742a5b32178dcc26c763748798b067efd854e56a923566a32d4be948126a26f8edf83c8271a375f6158ca88354e284dcedc0a7302fe5f5948fa606e77961f17885978af4fa6ffc890f9acc40bc269bdedc154d76e93fd2f6d7f430198e21bed27b63a46be933cb6029f85a5e7ef00ffc50ac2daec557548c7a6fddc7bacc939536c4cb66ed17eac28705228fdbfdd8257d6a62927bca866222a4bfaad4bfeace16ba1b29f8979b44aada5c6e1529b08dda197dea47bc607c76357ed9aea409bcb3b340ee9a64f95178d82d1a8e0e57acb439d5be7389bba866c6e52b8b091c5e9ebd7fc9699bd983efcec6836558e44433fbc6155f89466d648beece7715936dc0bf4adbbeff67ef33319e46c41f3bfbfd226383c4c5da18431b51b21fe74fc450539bf0d4f4a9cb2d32736f957168e6a941179d463f112d0f272a98a34629b08bd6ed328974376852b4ceef9cf598bc00925707df392f4ed9c55686b2e6f6d5986d10ce66cb2a94d2a1e3bb0fc938a2a0cf77e9f8fe680f04cb903fd8d02f9eee97f3b307e3f17c80d6d06db031470ced0520e8bf9fb7255df6af9e4e27d34e6d9671d9906e1c4ddda77aa1e7629a443fb98e696fefb7168b999be3b512ecfbc55538e9871639ebdf07aa255f9c49f32f14f1773043384ed0a7e1fa0af3f361079b145b0d78f0208dc8277f4e7afe96f39d9138f8b73e0b8d03e3572a8fc424bf15ba83631b0685d1f9ea4112864d16c9257ff3c0d7a195efc6082568dc95c153b867304e394530768b69a96fbe5abdd2ae2e5c374675dda1ca9b09eb6b08ff6c995d00c5a208632adacb987aed781c308259b172077bd91ff38708ba9b3a64cac7d67f6c962915526f5627ae14414eeadbf275757a59d44adbbaa87f0979d0858bbb25bc29ec288ae8ad9ce838c6eb60b1300d4e66d4bb818a4d7f37f1b99c73611e9d3cef2c1ea5d5929ed136129d4ac31eb33eae60fd4cfd47d2d494a163fe871cb3f1f27735b00a1db23846cb3aaceb7eb5de0c2fa70718ecd08333fe724bd698bce627ac2979d2821912bd59a86166b9da69509698dee5405fcb4d74187a47c7407fd49dfd37a8c7b849ec3a5e1d011392f6fbcf50d442606a73d5f259c51167c058ceb05bc3262e94a7c5a08accee868bb1f85fd096f1e61717ff3e1d22aeead6fbbaa93905c53cb975f9c051ad1a6a39efc3a7e06add3e4ea2e404a21d8ca0c9c6ba721ab8fd17c4b6d2a6fe6d676f80f851c665e1669ddae089c9669a964e84f0cc0473f86511f39d45aaab94e8d531e34a61b42b1a1fb12ae22221debce0fe26d7945cbe9d64c6c11a5cd11cbf45bc2def08256d371f8aaaf20036121b65756eb5dfc059514d69d2db723857b9120175b9d4fcf311bbe2fe676648aaff85991e554b49c5ae846baf5caff5867b4066d0a5f7ea2dcce40326d343822ecf139089f4e48b71dfb8240688e4dc0d477a5a1a8f249cd7fa7b426cc92dfd308040b118cf907b542e08f3712950628cc36f0d156e4685d41c31f3046fe3611e381c277f68651932a522060d1a287994b8c4df2c65b0b41a14dfeebbc169efdaaf6509a301ab990b425fe612d2d9f1f9269970bf170d4293c1846ecfca3614a6c8ee3ce5f4f40e4601ce7018de2ca67db706b8448aa9db2fa28b6b335422ba55b3bd1d0d8f0105bf9f96f61e88fed42940c7c7dda978f2a18ffb7b1f2910afa6fd0edeef91591bf41d127bf5b5ebf2395b4f48c3e0e0b46f40e9faab7cb56700d2d531369e2b5c7561d574f69a785ee5e03dda856c732ccf9665bdbee3317461c77fb93d3bc2063c5258f06ca8aac59b4998a21d7f80fe740654a024d1fb070dd5817b59095c88e4e67aedc69daca7d53565e20c5a576a7836b688841053c07d40f48b80ef65fdb672f5da67610ed09392fcb377df6c6a0ef0afdd1b604596c06749c0886becdefa9319f6b938c511e5c3b1583b47e902900111996932057d2f0667a3aa68bada3a15501cb7e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
