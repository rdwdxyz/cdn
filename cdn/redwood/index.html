<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9e9829051a16f10f45e078b8066f630c06b090652f9c71466a481c5b45e97a7815bcfcd423761970eb4237b10807f714aaf26cb545d693b73661eaa0c7132d6225711bbcd23f306ea15c9013092e15332bcd9dc3b893176690d87b4febe8e57eae12f678a90ca4f9ca290eac246b8781a9022d57a8ffc312f059b332e47e66b0cefa305fe2edb2c4091ca41a80f066309bb69ba886a9bd54e234407205cec0f4dbcd095025ee609a05e56699e990f2d75a7a58013a4eb6ea2b2aa528e1db55cfae612ec96cb22b674b493b67532433d974bac7d75e64b379e8a1a9c3cc25fcf83d80260e02db380745679594dc70f424b0db9d4661d7d7baf4e551be918bce418a692b27991c2daa7917a9c89284c1af4cca702606934250f2ae32d24413c32c7488731d568d9c2d1244cc76c42db733fae0a46b079b626b1f6b8d74e163d496b2b140b3d337be33222b1b4f45d2db2855b07f75b2388cd943bc08223fc5a7a9bda563655a7ee37f35e9411256e1cc7dde944c2476a8479db111c8582cc7ef1ac18f6030557f3c57cbf6f83a8eaf03b7a7b3aa716b3383884591437e4b12652a93f2b7e47df06fc75aab083717e601dd49f2ebe79e0ae955739edb7c9259bca3978b1ba9e932b545b1ad8426e70196b1a5c03ea62c70c82ff416dab653ae6879b1abc030c62cc58e5ebcb44bc5bf280538244eb869c16d11944bc81ed684f9022741112a2b5302d054758b94ac38c1fb5a014de398fd0a68adb535515ea111ec32cc159d583e3354081e9ac4e7b3d10bceafccbe0d7b31dd2c1184fd575320fff2f3a79fa1a1661cc09705739330ce0cec51a1b2ffecb141fa387c4b5ec31a1fa6e828bb81147cf29157d19730fc86477e9ce75f898c597658407cbd9c393957165f537b6d4400a0c5922c1d2b9744d2e8e601fd581334a33fe405109e4641d2188efd0b7e835b56d87b9f757cc1e36d9e19319b2bfb62a21941c8e3680b7cdeecd46c196213055993c844db7a47833af2ab96519addb6c2450d8bd033f8c8d400b049572e7dd4e4a49299fdd6a90ea183b26a7062107354e23a0196e84206e9c14c0d6c800752a41a725dcbaa1ee187c60f77ba49bc9b11c1f7a561e5bdfd3cfe1cd7d8f77d728c8c0e9594313c7df85f5b3bb94955bacb9b46022c4cca8bc0b1b3f56595979a89346fa6d39b2b0069d8e37c116aecdd712bedf429af19bed5c722a9ee4abc29b0df09334f8250aec86680566648747631b733e296d03ec44f293827e1f65360fce14860213d57387431f838cb3b8a86ea4c790dd94d8a7a9042982317e1457627f3a14454d08e81b79d3f7b69c2bf346c707dca733cc6afa51f320f7aab6460720784d4e98750bd2d5b3a9e7976f042d94e0b251a3a40487e5b1672a2a03a13870d83f3ba3b6a8ccf1d0d722c823fe692dd22801e7b14be76a8b011773b2db70ec23f496764e66a8f5913ee68629af1d96b28277ece3d2a3c6a373e02f8d53058a4279b2f2c8d5892489bb2b271da637c5a43afaa6039cd41f069be2347958a694b1df40458a29f951b4cf241d5b80317832b03cb63d01f6fbe169c1a3d578bce74773781e3db299199dad213c670c1df4d90f3a2a2c87d754ccc33464a3427e5f73720ef79db1587296a65fea220e7f37c6e75a404a473aa594e144ed9627a135fcf9fd7e83fb55cc55a82401c6346b6f511144cfc6a8eca635e147df1f123af5ea42750a522ad6cfec2fcd758d649cc817fe44b3d6fdb9a63174c7b77709325fc877e68285d5aa78fb10c220726d823ed7b9c92d10809e48fe5868145342e05fa07bd205d7447660e7af0a4eb5ba2c66e0f4ffed8d5eddcbaa3ff2f86cdcbe516832727ecfa95e1e8077b544ae2b6a80881461d5d144e30d3170764db074355239534cfb655af20a55ef9338d3ee987771aa89b4356e5867a8ef578550c48bf136d7601d68fc988b288dd72a3e9f4c101e96420adc1f36cf1a1050cd15501695469128702863af707382a889d287e48940af83b6af2fe403c2ee19e76f81757999146a5b1b2d83229857d8bc095f615d6fb8b11f11f1277e153ba21eef00defc665550306bb9cd573a025c8a89d7ddebf60d1548bf2c40c00b431c8e24fb61543fe4dfd3ffb73fe60854f422258ea78279cd24d4a91ba4494ffec1ed968e27ae9ce9726a11ec4b796eb94e39af5cd9300353a5f3907403addb177d637ca09e025b91cc42b3434136d77902d88777f6f5fb492fa43b76d43c14ad1d916053d3b9c50383e8fbad783134e497927b256f313802829928e773cc3378e640368f27b1044c2ce80e102655ccf2a2f136ee602d47ab02bbb650c31bb84ab9b2cb1a04f9cc2d0a629d0cb2bb69f0a0505bdb2e90f29689eb20fba42bfdfaa26776b677b048d09db61a6d3072e2abb012ef43d8474e0927c00e049a52842ed465c1d8d6b406d4d2b2e2fc7dfc459669252ee4ad91022b3e93e7b96bbb45fdf0b0f76f5589b7be5fd16bb54396e3261b0cc5d3589a405ec4c7e6ef5d9429882fe5a8a27eec6a0fc3949219d4466e122ff2875bd34ee070067020527d5f3da7bba74f22e58459580a44dc72e4914aa575660c21582050efaa48e8b5966753ddcf98451a84eef8ccef475eec5e4abaf835be9744a2ad3910debb4cf698da0b4f22ae187f4762473022fa789f3523764e509bf55f828236802a2f472e20350f07895f378eb619087e6638a9ab8a0988bec1399a093b7986d71c5fbf350da948873ae4a92738e76b514dd73445cb91992f92e2dbadd5166b0f32f93f95dea7404cf1d6b4c61a474e4f902d30a38d96ca38df7271c43c9a5ac48488f4dd4c2ed4e2cf5d0812753eb2ac724ad6571adbe67330c41dc6784fbed95048b56cd644ea6abed5fb0ebc3e25910ca2eabee9990a72b681ed7773a72c182460d5feea5d48f0bbb5be9fb1c40d979f3fc3cb4b023efacf8b3521c9a4478ac9fa7a18f01de3dd7b4f0a043c2735becf301dcfdf9e2cd410fb279933a4c7bdc294272cc6116fbef2a58538326305d218ad969b95cc1d58e58b5f3cd00776fa3342b6ae72a473659992e51806e898fe4ff57c992abd101e6a662162ae0fd209fe3f10ce195ae14f13835f5bbb4592fdffbff6f6b90b14c51b0d445d0b54c196bbc2c84434dfa644fa6415f18994b3afd8886560a75fabfd032ce882446a61477d0cba37df7a237a968d785cae75d0ee40ed44e68db8d06d283d4ee6338a193c54121bf20736a013c3cd276cc8414ad602c15ee294c27ea271b1bcf3eae59f02adbc3c4959c494f7fbc1dd731ecb075ad3ea203850fd083e6c34408bec75794c473e99b7d7522c423f4da19ecf1cfd5df78c2cc765b085e47a12608efa1b85f6a3b1f90404e2d32331c691f4de42c10998b32a67082c5769b673175dee702766c4914991ee3b1f6f1ea0a60b091ca3f4fa2a607977f29a6d34051289bab605588aca6afca821910802d632ab1900ca7e3b50f8a8dd0c4b305368821f93874bb61672f1c6297940c8cd281677c99be076ad7582c362f6f7e4613667f8b2a881b590401140b71af8b72e4f692656b4059f6734628fee3e4069549da0d9db2bd7c36306135199bf4be04b434878e052b31c6f4ad7f06f47eea0fb512ced5c80c44b8d6d475ad14ad13875d13d0af40f86c9642e8ed6250b29b3b548f0fc7cc95ee105e7398c0b0bf4dfc367192cf3600321d363821276393598f145f52b7e091f43ab52efdc3fd141d46c1e9e1b9186226fd054b8f7d96f8178e6dffa9f422e42c63639e2c400c1faa6a8b486c77befbdc32f1a1037d7eb31cbda291ef9e0a35924d159a00761078d9b8fdda46acd0036fbead1f496f23397b2b587dc633d91a90249df834ad173dbfdee7e40dc07918927bc931edda45c7afa3a17057e50cc5aef26a12687bc7027921cac913f14e681b00c876de39eb359e3a09d695ffad05f3c2a9072a6b5de6918866be99ca21d73910d4bdf259603871fafb4c19006a874d1ead76770383800a36861a10497ba6d103f9461db9a1f678150ea5343b213daf42ade4e7daa62f983d943acd221f25a78962e8f4fffbc147dfa538fc7f6644355ef01d47b498d7c88b3086d3719f8a288d0f24309eab89c04652961b566bc53aa134038e95e5923a306b075819e8d8545b0ee4b1d18b91455f1bf5f119e340b170a22eb07bb3bef519025b6a4a08cd477997c082dd071494772f6a1fe9722e4fc98e6a8f976428d75292429768a88286fe1b9cbcffdc30ae49679eb6ab28b2c5cf2f185dbe25c6a972850dda660267e05da7437c6972af308411c50da0e127427b101c52bf00490fce30438640c30326b758e10cfd10d0c2575b65267c4ec520176914c2d524e8550ea963179f8013d2044940e7d8404eb5b5fbdab2333d6454566d9c64e659beb069d1a86d1bf50d22eb4a1fec056d4ca8dc09f4b15c0e16f48b5cd5502b7464f6020903aa9c708377cf36342179e563857360bfee76b40da60ef6f384d21a24022f15b64f2591a8e5875398b3931ceae19af72b5f9455bf23c48a9a041a8d118fd8379177af2b37bb071ad06d00699dfe2c28283d5ed47c220d750bc02adb85fd19291be056aba4877a14243874063a909812a66f6f9bddc1d793612fd0bcaa936bf1816591bc2cd2f81480654dec0d4ff93afde1d1d2cb432b6a632bfe05a97858ca2d2fd24b5823714ab68a053cedfa169694b300fbbb1d1a1ab961175cbfa6f187f8bbc8420de1ee9c1bd7105d47720f8e051521a4239cd81d8b3957ed6eb4f7ce8373c352c437d799e87a2d174144ebdcbf1c3221ba227bbb1a72c078229f496c8fe2e09b2a4765cf125c5780893b06b28f1b9961a7e748a423e33d1c1e406b4c7a99658ca68edad46ce1c892f75f1d15eff09bad1ccdd61743eb463edc83c97f8d7f2e4e4cc7b29fe03ade0465deaff8a67f71541e6d15b1c44afd0b4594cd6c2797e3a8f3e4dc3b86cf41e7a698ec4f8d01c5201d97d34747c45e1f95c12fa1e9f5c2c2d3a37b624f01870e1fe7295e36eebc33bbac55043037f5da5d9581572bbd308b44e0f31d12104134741ea8365433fea70ea7395804c3a0836d7cca7f7d256c32063f56bf26088e235e4366c4d08f54ded08e0bf89ee1ce53d094e7e8d0afea91a5622085c724d38f035aa839cccd558a072223964e34ff48dcf407af86f59cebd52d3f10279ea8af1286f2acdd677551e632edd964065d12b8f245ec844b52a73837da0d88a59e9eabb188c0c170eb65e041b530a577bfd01aaf01c02dac09c2328a223aeaeb22f60406eae971ad37d31ee02e207a14def94d092bc0596147681e8dc962477cd08d5f5db2d3403065c44ebac09b722667a2aae28f485da90c361d22c047bd943bf8748529eb42b32771b56be4466ff87a9b0c4b157842ba5cafc169273eacd5f0ae0ac83ebaca16e0cf04ecba5e54af8327397cca499079c0f7553009323528e54fd2ec602086bd20306234673bbdf788c8653090ee8e05edec0e264b21d001471ae66f7082883af19dc88d297db98ada3165735a5fe176654a2c14db2b0a552b5be4b9f77aafffd2dc98503a80c801ed1e41efdaa3538b4745029b9acb1022ccf033c5a14f807ac42ffc19fed51021eb2b0acbfb546394bd8de9fab35b4bec08e423eaa58bc6fc214e4ea074a848db4f401a72893c83eab58bc0ac7efb0910b7af03f6df2cd223676c6c6d0e558ecfe488323a032d2e0c74c41bc65d5cfb3eb93e4b410120d3fd15c91c7d0ba55f32d32d052b4969dd12f437e6db8c29b0f14fd41d2eeadb06f7a527db0979d3a64539f739dfba588a46fc1adb184e2f38442e942de09b61af474976d5dae68316963d0c6a37d4e09ed8b3a59f8859978931deb4b6dda1759fa28f297787cba23e4c7b09f4e8674286ec767d8df97b5f00b9d7d5af7882feaf802680ba3e6f9e906f5c17cc49101430aca780fc5b4ec3c0317130fdddf4e161ad755a9271f705eab1e8bdb03da17b4efe5a5fa2aff4e9ab862a5b83d8e8134688c03651639cdded042abcd810b8b2e0a6bcb152454bfd05a95af4db4d8acaba4d661870b839da85426782bf96c02d87814ea405dbebc7cd3b1b142fa6f88d00d5bee516424e6ca294fc4e441aac3278bf895b1f9f291437ef4ed6e928563fd3c8ae179c3ae3c1818868a19b7b727243e48adbd22b0531b5324fdead9b01d6bdc07ca86bcbbd063d73497abacfa7a6263a2325327598b363acd917ede156a6d2a7f76c1d7a2581da48f03276ec7bbb014316a8be58fff14ad979e378d8b18ed3fad9e2299d36099154256f12f699fb8f8af5ee90a61cf6e0809e1ee85938cbffaf0a7988f1e95cd25b88a3ab3a25bb30ecb355eedd0743686ca00226ff393ec7e4f4234b4c44bf3407672e53e196c9d46fde544c5f6f301ea7ac92342e366d0073e68268f327c0eb750de6f79160f54abec6b1937e62fc619f3bbf7884bc034464ab454d6107d7c7feedfb55094a912f7fbf566db0f4590525cf5d20d89581402f995db82457a583c85ae229d5f43cad816530d487b0d8ccba2a1c25f0e9d92b55997dc5e56e7997fe3c9823521486d3e55ef85c3abe30ef9bdf6805d41603fc736578ab5a018d725347d5932e796d17f7336357ee3f2ffc7f57e4a519c92c7618b6857e6c0380674b2c2ffdef4ad93f35822968f618eccc7f07db97d775e68c5fd928837ecc5e99f4a73245e1d9cb043e36f26d2c96e6d879c84551a864eb2db54fa177787ec37a35373fd1893164db82ae72a305e63a2d674e1eef50b787be64c1c5ffd9459a301b02df1efc7b7fc378d09363fd1c7c1bbb499171080de236c31f031918eade96489d72112b8bf3b54c3c35cdb23d7dc7da8bcee6da8c88a76775a51a2956896fa4eed1d5b9eb194d5429e0ec317cb95e3b212c2a91911de3e00fb2bea25a5d4b916bc9e87120fcfbe2c7a61a1a1b7ae4cef17d00a91fb9fdd9051c23b6c2b008022fbcc8e463d28394ab7cb1676b43171ce95b143ad636b01c69e7b8092e16b1d726a0ecc9ceaf67db4560d4d7217e51daff9ccab6d2ee66098064c252fb70569fde51b6f85969c38462d1b476d36b11505880a6f5c20d6a9fa2fce7a24aab498865a8b9d32292ad59dc19e4b0cdd24639d9ff7dcdd8d9ccbe2ac4f5526b6c3a63ca0d7ab6f0514229560bdecd2bda50b2c72666ebe7ff75b7e3c473253079dfe0b7a5524f8c34aa27ef2ebec054bf8436f04f188a970cccf494d9914891a9388787f5c5698825c0dc736a03815363892b055fe368d5b33705d2a3ae72ca5db04888ab9b2ac3053e9c9bf19e91c3010daabf48759a4bd769d95a060bedf92be178732255eefbaa3b5e6a71ae7b089350824116d6ab58170aefd10821c7af023da9d4b036601e0314d3e81a2fd4eacf44b41e4c3f264f93f98174aa9ace38098d835c69c6f867f76e13d48c3a89404a6490f0bc1f2bc435592458f98737d5d68f887074b002dc4f4a103359840bc48a851bc48f29fa81b1c826289508867522be5ff2316311a91163ebc6afa731ceee6b8038086865c71e80ba83ac54c9e27818459d2f171e3eefb38676f3b12007aae2f14b6fcabcf10e4a6f746e9654f0d57e3659155da9b9b4f5f31724f50535b95f0e889fc9729ffa8d846ef610f3384b96acf1a0180d1e211403d2252e52eed826f987ea212dd4953c5e5c08e2d314809c8965b9ff2d4651d8805da7bd1c3aa051c8cb02d76a3098bddc9b2d30fe0ae3673b4cc42c14b827093cec83c88f94c727b78810db598cd38c2e155b398bf6e6130cd4b6789223fb5c3798ff7796013b8da94bb1523e44da74d885c121b0c6c485a197c6e1ecc794bf104a6a4e72e2af2b7a78cffbfed0774ade97a842c9af08405f5d5e2ee07464249be438015b2cb76bdeb2b57865a5f9855e2b491a3b0f21f554e318d197d90232622cbc4b6f4cccf93ca017276c5a0ee9e35e148af441abfee27a80efee794fddfebbb0a8703c76cefb5f37c80717d5e1a2d05ee425f88c5d0661ed4bcdf048d3018f409afcabc5e48c00ef84cae780a227bd969d2d83f82657bbe3687797fecd1e18e2b0ed623565dec6167146aed358ec0f5745defc73e2d877d26ecd74f73a275fb625607873643ac2af7ec3c85749b8efa4067811e9d3fd409d6e5b6fc28b02b6a3f07d306a9870595703cab9373c65ed1d7a91b216b7fb949df03b18ba64ba94264d270461a1e9d0b5128ebf8a5366caf57785186ac7c02bd25d425cb2313c7295175506b7194812affb59feb7edaf0cf9ed29e73c427f35b4b693b132beb754a342508c4bd774fcf1fc1f931369d506b339c9849b6a0de3d62a9cb752b3944920ff52982d75c34f964b7613bb3f4c40e15d46c6a46026c7de3537a8bce8e6c18dd2b7835d65eec43cb918b0f0738dec003404326cda3a72a6c680a078077d4e5d35330256f51652722adf9ad86dbd48307cb4b717d965ea31bf8c1947332a720199260999dd6f713f96117e270563dd91078cb267d3024c2672f24d6f7d9d78109c07188ad06fed254af90844bffe48e6422cc6a63382c078b9bbd68554d4c1d7b6a786e5d4a2be2a36289c53e24a093026434a760d1d586707993800a88a652da4c173e49dbde30e241b5324db2bed775ba5456ba34fd26cce2bd8af53d834605f60266dd46543e6be7bb8b973a2d281db3855860c13b1fef62ca26427a64e641afd2677c15da4247e799e137dde9b098d0872cc7fb88e745c7e01003e1a2049967a2158531cad7c3864a813f8dfbb8f68f649db79dcc9f47fc52fd7b57c25b11a00813fc73dd8658aaa6e47bf78e87cf2342df6e422db20a6dee023f8d6062e00aac376e13048fc7e3cce62f4391d2c44d8c85207d0a9c703069016bf04dba4cd2353db6d1f18673a487e72ef82bf76b64431c82fc1da36ff158a6a0c10a950ac0383c32300581a7fd8bd97cc412462bfb137d049e1128adfeee4cd8ca4d18ffd1c12c5e04e1414edb909ca876702e63037c2c1d18e505854362db180398b22e29fe28ba7f5a80ae56e597684a278bbc0690d8a56d2c0d372ebe64d003c95db4bb5c04a11d5779c4f4403d28436e28536dbc7d80c001d3aa7374b9e628028f1c5be57da54a99a2a050e85d8131a81a5c057fd4706a0389d65bd9c7d2d1e850626fbba05182d975ae954b956ad050f5cb66238478f04a3425975d0a29956607594d9a0f1c6c8855453c2ba393b8eaef96d180d825863f74339f87afdfa131e6635bb5110a0760ad11e63117d3fe485b6a9f2b3ae957477d702c8a4e9c11331e0cde3f45023419ae2aed633f8b164ebf9ad779ae28ff9a898b424dd06803324a5fb4bd4178a62ca23d7c1bdb711efbb0ed104faece390fc346993ea962916743465fa4364fbac523eee9cb5daec9b53087766696f41723a664b5835df241d200c95ef536cafaf28717054ed4fb8cf93366f242caf62684f50c8d84f2f2ede436481fbf854342ac31812cecef123482f7e3cce4f3a5d5fd287c6793b935ecaf416634e5e3d9a5fd0b137c37072681c54424ded4e249d7a199eb361589222e538eba84f848f956cc6bc0ae64ee87fda29ce4a6eaa596a5a201556278744c28773522e2489e25c23813113e52a25a9fdf53c9a422af90dce84d56139556a8ec33c3f9893ad3467901c470ee1b685daa9b3c9954eeaaec114cbef9fb15fc4638c696b81ae99ef248f8ec714dcbbc0ff5ea5d77a4150ab6b83cef7bb627c3fb094c78b587f220b8e039d1bcade0be3d4201393835f7378a4716f8e465d6d691ffdec0401d3f0b5cd7c945c4bb03710b7f18725ca07d69ebd59bfa71692e97d28f037996cfbd5ebb8f6412927f331843e029328b6142dc44b1ff2181ee0d0215fb15602c581e63a3978adaf2f473fd9e4e1dd3b8211f169b240e9efde912010a8deea28b8ac508256cb90c1121b3eaaf029584f5c29016a11732b72f58430db0a640cea821b3bc4b39cab7f5e1e60a5435ba9bb701e59fd3232b7f6a9d9c7e9de27d4d84f0fd7ae6516ce5eeed31f9401c494b8646ee9a57c9df50e914e08e1539d41b2e89d81b6da6995c9c193a1a71038b757aba2626eb8e366dcea193af4f77ac0f6295504bd07791b42b5de04c3c9b56e831c38874be84f98f190ac5a5dd1aaf55dacc0026417713dd2fe1672ca7269a2c037e0d070298503a4badf97d014d7586e5d6e71aa617d16af805b1fbfb1eb601933e796bf7534add489eed896eeae58dc5824da29d0b88ff90dd6265a0d8d71f5c429b8202371363ef5e92569a72d6f1d01d6e10696beae029f96d617d0b4423ca7acefd9f29186459c829a5909d85ec1583327f217f3a641db275985a246b6eb20bbb5437577d0ff7ce3cb0140771c448597ba8a18db3117591bc5b76d1de721cc13f076aa30221d881eb5a5f944deab238a0426481b07b9df5815344eccb39a3a05acba4a21c53a03d05b88d107a6074afdfabee76a4d6ff2ad3d2dd3cd0293749c8adec1e95b6e9002e3c1c54ca60f57583e2fab3e79b6c584964595ff61d8a36e4ae322a04608b6c40a0a2a91f1fb86815fb0f1019fcb9261241ad5869200c9d66a3e4f10e39ddcbc021b9ca166ebef447aa028d24c1a870efe8c0ab963c95ec7d6f62798a3ea8c647b5ea42a92bb6e3974086d58871347cde19889b8f6a5e10282780296f5b1bd7c291ceea96626293d977ee488fe8f8cfce05df78c80d9c5dab835bddb6b739e3ddaa0fa30eff968bc4f13c8f6bbb16c1dc68746ee19388922b9db93c7e792a5621fbf1df9690e161462b0466644384d6d3448fe9c84eaea3106afdf2cd9d733d8d9ed880f856f4982556daf4b319fb0a28469583d2873efd406cd403fe7b2791d9d3271c6e22105d8750a951e859ef7ae85e66609a0ec5df2021c0077afeb9e3e9904d8378f7784c9a171d50b6ab10bbe2cb06f93b2e2d14e8158670e5194d98301d67bb578c03a491178cab195284f0bac69f167b78c9a823a6a615a16399e6c3bd7e6065f22be77d3f5db11afff0de13eeeaa959c133d5eb3f9d82442f4ccba60d9aa3dd5a50a3e578d43951a6d522f5ba0df5be49535a138cfac583ec656eedd3e476ed8f8c62af981f85f34e26ae4ca3294d057dc0a2dd347ae4bae3fabf5fcd90a24003d37c9f51bc0138ab492b33993989168ab5d550e9cf28fcceb207582d2b25b9266e4f78d1c5a033ac0e6e8c56bd4f5c32310c9eb994dda9a927544aa368c3175b10898bd11322e65ddbe8dfab430faea4509a670f4b8b54b4d0ba7aacaf8fb8af253256d318b6f8afbaa232a564cd8c9c98e8821b33337060f4d298fa820aec1b75f1f8882c91add7f08b53135a30345751b43683d63f032cb972c2269f3c07b0e8e47b30be28345cd98d9274cc74192d0d2098348dbfd849b3ac638313b1626352585f67fb02c2871969f8b240efcbdd9f6bbdb111ff743dac52ea73d084d306cb03a6bb44c1e4c05b0355d4ef388750ce0bb515fdfc0b660be805899110e6a5ac5a9f09b290d49cc8e80c01bb1fa05b30c69767db348e1dd803bca6acb2f3336a9d09d4a573f4877b188a65d114142817f7a6454eb7842e8d4746a61e6e696d3b1604833b1d5ddc374faa85e98c36a00814891f4ee3316753f0a933a054f3f8740c0cdb316d1b088d1768eb8b8e3829ba69851885a9db438e1621fbb2f75565be90a56ebfb63ea551319dde57a2c48ef09fae2996243e426addcb0cd65a72b771831c5a941c0fa44fcf3f274ca6319ce1dcfd9db344993f6ec8c4109087000f835f5714b8b55b55e3c7924199eef8ffbfa6ac2f368d9aa51cddd0cd459d01207690c0b4480b6620d7dca300525b2ea2e4e5bee08ac7af6407025286e942c688ba0ddacefc32d1d501e561adae1d8768503999bb7523fe9771ae09721a221b5b21fb6f3246ac06e6c8dd81f3aa50c1202dfd3edb5490309b7945a5d48b11b17334c4060234975cd1ea78ed3d0f920a2bb777a064706a886a434ac19141099125faf2ce80b3aafdbc9a67ed806f59c6d5793a8dbf083a67c562b5eafa498b09e01d908c5b8d53c5b596b2932ee1945ee14e71295d3237a887256541a04b35e7a969618b38b1c139822672e801dafce2be98c0ea1875f825b7ecaa719439d24c1aa25b296a980f1266f15e78552702f579674777663e36d940564658fcecc0d73d8880be8fb993a322fd8e58d58e79d242001746757f2a07925ad30c2adaa134b50498352c0cb006c1b80941d618f475838d3a139c1ec302659b3ed363e726747b5ef3faeab392e0dbd908d1aa07f7a8809cafb68395e80645027ad7b0927f394b588595b94fc8cfe50cc646eeed95e0c47116af1802106b0a58f88f6b6cb0eed5833e5b05a1ccc2f9f31a3fc3fdd40005861151cb2ceb53528dc7eadb684d935e54da6eeff40870434e2daca059b92655ead69ac001933a793d17064403ee909b3bd82d2790f6ae397f4836b5d915dc88a146eb2aa9f7ddca0d96310f3d9345adfda952b0a2463536be1127c016f2e3572555a059d12c59fb7cf77d778165d7a8c3393b2e19d9eba726ede02b2d6ed4da6ca3bf95c79505845621a0f0b958da76d7cf6382e787fb85ef8cc0f9548caf2d62aef61b59ad07f298eafa05c3102b331d44ebe0c54e1140e4e4de759aa3e6da8fc67230c42ae3f04c050f09270dc45f6732a472edd6d2476fa631bd1f06c7ad19aa6ae01207db9be68cc23b6efcd7cb8001b07703389b6fd5a300578b72824d5eeffac89abb0e0794cda6151de0f1367c01facb6267c04059c91f601637a741f219e9c114a2cd99db52f154cb781e91d17df34e88ea6362b6fc6b5acb3fd89861f49b495ff3e26b99eed3d6e7b4db224e5c5245fa4798842c750833d6c6a84553383cb7f4ae864b0808bdd7850e9b06da82fcb39ec61ee6cd2baa204029266fd05a6f36dfee60c1941b9b5c6ce3302589cbcca3c2f1560bfdb90999de7ce415784509796a701951cbed6d40f721ee5d5b5025147f726aa55b6015563047290462c384517e720952cdbb8ba6d56b13bcc309317ce82ff5e5b68fedc8c0b7da0473a2603f641d3d9b8065557e4b432efd981b926bf102655b1a7702bbea94954e9adbf35a6b9205ec055fa2e1e790a7c77cdc06c01061e85766fbe98976de041192b4e64a83fbaf04107dc95ee5b87275b2b1af9dffa73b0efebb0b6d18a4c149675e599cf32a78b2777b4551dd6cdbb601d71bd090934f2a079a0a684af42d98249bb5584728dabbf7d1b1ba544b8b6469fa108026e7d15442c1543b5fc21a5b8b36d7277da598377a28c564e9efcb11e3bfe4c7283f05041fd4356c9bcb15a7af65ef85d865710b37b10eaf10e53fec40a00fcef6cdfb51394143c2c38b6de1672f9418f73fae2783f69f59dd0cdd35501861bce181a5ba7ce897ebfb97854009551da2cbef49e654905ee2bbbdf2b23c0c5fb4e472a5bd152eacda4244a510132831aa7613fa9056c1c126ba7eac765c7f653ee04d629bfdb259732ab6c468c9854046223f52c73e8bfb90f1cc825a291c79de23f881cd7abcf0a0242a59f630fa01c19136b3f1e2284752aa7e184cfa0e6330333f86c7babb6d3427a85ceaf123267af5c0e522059b943a9a1af98a670ce81b9582cb21209477962fba08bbd5fa38aca9ad2b85cc0415ae09c7cfb5234d9dc2ab896e32529341ad7b09d3c8403a3719ad237a78b9ed408bac3752e964571a1ded038ed58ce948f702ec117c1fef736a1af634a9d50f1bfc4bf8e5a4693291e2c36b1d80d23c46473e2977fe02e72fc9030327741f4e045cdfcd34b3337f4cea198753c1a61caf9ca2ccb96bf1e6edef1391cde61a216382113d9f39afd87c1c49f14ba1385f59b019a5d5f9ee6749b42ba703a40bfb61143a1095c3c987da14f43e595e368da42ef37fae571cc28b56adf21572e72aa7ae1606bf2fc766ebfc6252ab9cc2023c08bf2899602c273568a90a77ee97b394dd7177e76a51190f35010c50f24fbbf97c02465808aa866689250ae56165486716e27c1c67cfcf9c3a25b52aee9cf33ac0ab375bccbb219905c3778697d7bd30cea63ce23c4b4dd4216ccc6943327f8f7423be37355514e23b414673cfaa2a5574396120dff31b5cf922d3c95fe5f4cf7e21dd447a67c61dc62fd2f5430f0bcfb131ef8f37af363312bb52b1d41dcfa26c42e2e4b5325aeede0927cf3e16cfc66a158f5a8fe462a3993fa4aa872f08f62bf0308d1096563ae7ba398686ac13710b199ae08bc1c58639430a5e2e215ecdd839470b6e3c22f6210bb134e8dc081e0529a143e29bb2d1dbabe3941ec62ae63a49c75e851973cdc0860fba55481b3e4d3bff3c6465548246edb98ec21e73384e78b070b326238ac5db5cbebdc3f1f2879f83697887d0885154d4f8af206ea9c66e55eacfc816c6708cb29ee74996fbe58c7dcb5ab5fe2b5d44ea027bbe03c1779e644f09516b7b95e59efe2c498ed5d6bf9db7e3fd91812bf54b3fb3753002010dc58b83dab2fa9978c54175d533b7b52d3e2d3b3cb465080a387bc6afbdf00979986ad718d571f2842d7e8a947a7c4e8238f090e6fa86ee2e4b21dc6da9c184b74dc9424ad7764e333c4837ddbc3cdc63f34fd0aea66bc298d74618a15af0652187a79fec7019eb4b06a5a09dab9ef61ca75c4179e3d4f5403d5579ac19fa6652ee567b09af6e8b0efffe4e4b22fbf1533ddca0634c719108d7e17bc4cf346b4a70e1841ff5a663d9d8394554c70783a031f5637a71169030b69ff4d429931cd8a264afbf7fca9e5f259f5fce76a3124c1b660d2903e26bb262ccdf2f5edaefdb000a7a5ddd2ea7627b7a529499d18e938608afd92769b6983d7fb0692eafedd49b8954b73ad3bcbe81c7c39d4b8b5fc902c539241e2c9c6a8567c7d708dffa6fa64244532708a23396930059b7b987c3d3bcfba3de27916b6fd3c1e0044ab973d085df62ff0dc2a0482fac6d61f604cb6ed931856a73105e6f46cb0bdcf251cf658aaf6f0a9b64b7c67e847d6dacf83b8ea9c5c0a72d5d0ac236a2cf48f6f571af5a88055f802e727e98d70ff388929525f558351012c7d94a5c286a4f7170588fe0fd0a7af79428eacb343eafeda3c458538f47851822374a0cee264f6cf9f59cf78a25828581f4d1634c937587023f51897ac0761ac864ff1206df573237aa3026254b320fc4106dea9ab9c7806224aafa2b4ec8509742fb02201075ff3daf3ca276894f90f7bda5ac0d9cbadf7d9641a79c9de69d6b9de2eb01154e655c06e4c67e031801b4d9210ca4323ee5790ee43b3555f52c1a62ccf60bf4b91528346fad61650120442eb61021ada21406575a314302066b1fc156a6161fbff42ce22d9669e169bc6e32ba47571c16b593b47d6d86023260511daded7fa008e0fedaa3e33136edc76ba3501f65f31483934ffae81e07bcf135bd40856d73905111fb387cc74baf6aa890ee8e6d7b2709c41a80203893fd9b76dbe6e0bcfe9528ce46a319591fc7b139cba72430b486c4eafeab6f8491c6297e66c62149e8f0b8ffa1a717596207d327fd7e7703f5b84f8e9b3aa96fff0ea84d326b23ade72d50b05fdeb34c5270ecd0da94e74e96346f721c566f4b89423c11edcdcde4c598e3ddc7a7d9a34f6a148c69ef7475016ebd57f15facbe16ebcc2fc1a34567ca01fc89421c6ea96aae78dfadad9072dd098ed56c82e441eccc06c8b4c78fcab5b875f28e935a3a0a7dcd42b748aa104ae45112879d45658d85b8014710a20a7e93ad1ed06f9478be12ec7f8f7d7490d2366ff2c350d81e5c82be0c534d2c61b1775719877ca5d525d33cf8aecfb58583c2d39c5686c67461f652ca068c883347176315850c5ad0e880d43a89a0c8e227c7c3952232bbded164d0ef426ce128dd136af211093a96451ddc28fd75105cbc80254496e1bffbd8882b207fbae4be41b197bc05f0547eba1019013f5320f210088eb1aee4b9a4ec656e13717f38a808171016d343b598c63cb01b4aaa1f8b2ec284765798fb0a79b23dfa161645eebb0b3e9cfeba0919cd84c9bf55e65aeafb70524c84b614e9cd1f36eeb220dc0f6137a4e3c9ab86eeea3623fe31b147d71df4a11f11017f9a1e881bbaa348f954e741c4c7b9408b1e38a877098e716ffb092549fb37ebbe2d051d86658486b20e472f479f8c6833c06d0efdba7f64ee3b51e38b106f91fde4a1a29ac7bfa61aa3742ec01f581caa36e9aa62e6cce4c2e5c6f86219146608c6e28f2cb1bcac1b2515975a6d2749c8d76ff9d821069f6dc9671e1178d1c533d034155659ffda47f31aea10f576716c9427da8f31b3ac097f9628dab86429b91a452d7f47e3acf6c0d6290298765ed6e6156e404c8dc854cf91ccff683dae1ec37bad12ee82793554075c39e0fea0aef889b4f58f93359aec23bdff8020a1a7cfe304c69452ece3f931a6b591432a62c06dba8dccd35c5694943051d972fba5d5cedefef7ece6db768a682fc8ea41de143f3c8c3aab22a65222154e63b69c044d9b854eaaa61276c051f25dbb54d7df418bfa2342d21f09fd9961f10ee087bbd9d033dbd870ad7941fa0606ae4b608cea1109c60b638ddb089317221d319a001a2417d37f58903604e439b935dbe5404449a2f7059c03f54f5e191f901ea49a363ca569e49211d8fbcb78f7cbeef069f1a35cc3ff092ca34956edb18b61d30b4f3e13549da9a25f9f2a14d035d968b2d808bf6cf979f5bf75db62ed8015ccadc149961ca4f6ebf8c217bcfd51a4c5724959448edcce43790c11121df990fb46b4a5cd6b230583123bfbd07a5f19dd4b63a6f2b16d207ad61a9b8da21544682ff18c1e889dfb504cfaa7390f6d571d8bf7977a85bd0cc19b78d7afa47a9564a3ed5b3abf2147451446d41a731612d5a77be0979451c3565409e3fc59435ad4544f2159680b3969fb0a28398944bb8b8524c28da1d7c13dd26e5e061658a9f10c69d9d13a599afa3a6f43f2b9192f8d44046184eaf01560413933a541bff0cb8b62e1bd89139cddfd3b0d3f38dd178b4bb577183152d7f6b7d76b9bba7e09a17c47df1fb2c6c9dbcee20ca2858ccfcbd7558eedce33a7a02e4fc8e1d48094020e7c822fcfe1c95f39d48f53c44deb4a3e0728e8ecdb43070532b567c6833544e1df092dd4ce0ca95de6c8d2159006af0cdb43b5421d4a99bfa129f54b04d22026f245799af7e4e19b38d344db4c98103a6014da717b342bebe4e5961eb2e6679af25fe4502a8c37171b43eaf5ff9bc7c63db5af78a1179bb0be4cba7017e2e786574f904159b4fb04f7cc2d800242f71052359334f9f7b41b200c752e434fdf819a0f7628ed5a725621b231f1139272c4bb8583624074dd6b4a11301cf7a86d5e9870195e5edfeac02bd5c577ed8e6beb50cfaf869bc55755d0564271de5cfc5cc0049968610bc06b0c0ac91b3b53bef51c4e28a9039f30f0b855d4c7e26e1a622f2d111176e5ed4c2d38f87c36203d527b84ddce029384cf2d4713b1146cf2de18e0ffade9fa37eabe6fb9013abb1a6a181d31306fcd5cf0b67f9d50757ecaa7263ca15defc8e2259a67c3819c1eed1e4bd6ab93cc56c7b62b2cbba693001357c6b59ba1c7d37ead9abfb1edfe983e9e07196b5f37a3eb22c50520487c73239c0bed849cd33b706ad3f41ee2189bf16bc9bade34d2f823df93a0503bf66d284e07d71ba68c02b5d197daf7a3dca1757ec264d736fbf1b07425cf4879169c1965303a64e22aebebd90c7e47321079eb3339147f6d0522492e34e4ccd4c735e86ab67b06af743e625e99dbb418bb85bf11c383a13fb27744a37a710cecdacd5b6f942b5d798ead477d280ede6c6f3a68ebeecbef41d9b6cf9796d4a2225b4cdca798a3747558cc081f5d45686083433ca69d05a49ca32d8e485009fe8e3044ea0170000051cbdf2e6c374e098bbdc1b59512d7b8fce0ede1cd9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
