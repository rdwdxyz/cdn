<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d0a5049759f487023cbee4a17fe18c6dd189f2c11c840c4028c4a587988b9d2e353a70f91e56433d165bd861ad0113870d3bd6faf0094ef4c750a4a9167680263ce0cbfddfd824af96e72f4fecbabb469fe7a6b0dd5010463e24f3d9a4ac9b937e21fa1da93df86a6ceb15ed89c82abf624d5d2dd481ee5987ccee21857a98e86c61d290240c6380191f6869465af6d1877dc4a56c3a7a82df99a136918f5c188edbfaf3c8e61a31e50255c2916082973048c9d039f45be8c1826c4251752c2150cbe04a4536338f28c3089735fd7df86efed943326ec96db41803c9da7662a8b36524c4dca7caa21839182947d535c88377db93477462d41eadebe450637ab994001975680571c7d45ca31a6924d5f6d155735cc6728da285b62e15fb4534e0612b7264272b5b7ad192e3e3f44fbc1a5c7608552ff003c7f00af9cb052a621cecbc6a535c53934a9d1d7e924a49d513d898a8e9953d5ef7954854832f63a798fd47706a2418d115f532906949f11d775bd950b26622d7c8665368b5235d8c6b5cbe9ecad6d20934d662705902f8de2ad1235dd9d5c04ee5757fcc9120ab3af91fccef8e7bc5c7b1267bd38626abe2495695c0dd8def10a1813197569a20ee6f30343dd6ec7ebf8ec1b2f86bb7b82870d0b9aaa2e7fdd39ce491811a4a61de196c477f0f5c7d6c1173031ac379d28fdfeea8482e32653c53cca029dd370ef106214e37d431fdcc49e1d5a5312806124cd55b31ca9a03182053b6835877d5ce793c0fa602959fdfa6254d4e877bf9d2fa52f1dbbd6b45df7eead0d59f9394cca50b265297658cab338820f9c99abecfae798f2626bb25909637238d751a1abcb8aa48d374a23c28db27c2d7ee8fdad622f8b4b09eb4de9fe84dcdbdcb2706a9557b146b7c1514fcc70a80e3f2048fc51d9f09a2a4bfb8d92aca676bada8b9975d9ec64b34dbe0afffe8cf701641470302e03894b2e0234509938a1182da16679e326b81904968d30ef5676e1fcf156dc912a3fb4d02a44b8bce7deb4979866b299a3ead947432ebf20959904f6b7a611d7d91629cb95135f793c5554bc892a77828e750e3364c81b14349a8ba2ea405c528dbf216e6272c3676b70b7746c53036a36772be37b2fff5b75e94ac42be875da0b49dfc105ac579e89a6e96536c436c083368e39791f29a3df8655e0ee9d1a08222bd0f6a132641ae766cb4074b7da33f14263ffc2dba643bc30cf2330a9efa06d20e1ade56205eb0329dffc1764904cb207fde70388c1157bdc4b9663bbe85d261cdce6a80093680b2a0b9f8d431e5b37a41c0e5bebfb61d5cf320c424649df096f009ea5e3c303c0899a09270a07ced654c35cf921a066824fe23e034d9d52a9b49d2dfed01cdcb7f56b2f8276f33989a8a48d20a9aa34f48db6d9eecabf0faa6c661bb2f0cd7d493d5c99eee3b4bacdcd56b77bc99f2d5e44dc474c239912a9837361fb8cab40a17212a5f37a2bc168fc4774c54806a71cb53c226aa9acac720592fcbd770177862255881606903d73f24c91e5f24295643c78142d127c2c7d734eb4375592c838e49b1fbc0a5eceb4a340290753659bffd421dc934f4b00743e0b84482352bc2f0262fdb5167689f2faaca8c69f3e85d25b1c427c34b54e0e144be1abc1ea795fa0c637f50958e914db6cbb476463301a76787d5b97e96e6c721af6857180e6d900d3aa8d564162cef8a4ad5337e64d7d9c5baffdaa81d8306d8001840f958e56d00df42ce62a0f9f9d23d07fbc6a0b0083cbdcafbb95de77166b4710c3c75dbb9d09893fbf03c79c8f7cfabb1c3177d2455111af79f77fcca125084068b7e76e0e2d03b1405ac80e3f73dcf46f2af8c4e59e2146ea7a40946e84a5e1d40a3f522f8dcab86a2a15551af0a58c582e91333d3e28a949d96f118d58d584a25fa054ff274c28b00d1471c2f663c454693c9cabf952af00c1c586336df059dd3ebed6bb586358c6b58f5efee0015f79407b1e70fcb6c63795302661113b59a5febffcfe4903bc2b978fecaadf0d83d2631526248e71f261e387b7f23d537b6f0ec7685d258a419ea591a03e23d241ef869db32be07dc0228af8fb0b8423ebd817d8133c10791f2b88b59272101d80aa6b8f8bff6db5a47f67607f7313f55af07deac6ffe51e2c2840207d4b83bde462e1e17c0d8a18893331fb6bffc2f163ff0ef7acd6c9d11f54099090b19e6f285d290ad42bbc0588fd40343f03eeb67cc11f86dbd0ba45a3be470b7ea9838e5434e68e782bbf786fd80d8bfbb17fd66f4aa1e61ddff4461162449200bc78d013d6adad5633ccb707015acdc0109378e262a367d13fd69469ed1866cd794a507873292cb88620b64000fb31ff38edf414f46925d4ce6f33a7f5dc99e9431f09cc59baf8ced1fe77fcbd33d264829435eceb2a94c2190acf4c768120f1d57ce03cb0765417bfcdbfe0d04b5360d07d91e311d4db2766939315796a2afc7ae8f4f56fc97d29d26125f93edba6a4be2a92c117f97dc431552c911e04eb1dcd29698e41a074389485019ef84b636c2e8bd7b60fee104fcb339bf212c904d0f9fa9a15cfdbf628414400923ee92777f3949890fda3157024692d56671583676f9c1cecfc5c616dc4905c61ad522dd6bdb9463f8e7f88706ff705a47755dfd058ce5056971b2908ab8a3c9dcaeb39b159a1054fcefcb433f01d6d39cf49ae34161b4f0eba1f4c015a27235798f6a379d9e3ad57f0e442fc1c8ffc67fdc4fb534dcf3b3c0a82ba8dcdae6156e5eadfde8ff2934ce3e8866673a75d2015c15f1db01838736044ab40506ccc0e13585fc1aa9eec81b3c1ad91ed85dd33dc3e2e0f8efa1e6307e24ce5d51510ce1f6d4dc790e5848981b34de8e6e551f7679e955599800192996fa2c99411673af9cacc1bff70d15ce3889a79d1aec4ce34b372d905d213ac38b07f284760fe35d7a532ddd05b3df222df3b4ad3eee9c36e208e4af0017b9ba3edbfe891ce148daac382961c181019e62a0b9f7fabf6f7896e0b9f795d8b4c4696b3e09971867c11688cf2202029327d45bc49dc4053930bbeb5d99afb2967c45d83a9680fc12bea1a18e13f30d4443d4324acab67bc8eeace491294524c7e0727f8afc62084eee77a11d02b5d8a167fc70f6f1cc60e8a7ca5b50399ac760dc1113de29500903f4e836d2db12cb1c96f9c54438bbc85f3713a91e1396045c53325fca82442fe1dc8408b7b42258353cd85e6a11aa6e3476077221eb7efd8dda6ce3d2f7dfdcd9e0372dbcee1af8c090381a12866e446c9be1c22844169fb50359560e0004c7f85385623ed8a09d64a7112564bca0ef76a59135ba953d5bd7eb3b272cd0716dd733af88b4ad2ddb534a0106bde56bfc5d0bfd500c3fba3789340513c41c8abd3ae421b8e6a85935deafb39a7084fb96673f8fa62cd509b96378a9e0e30bb59669bf7c4e54d119ff1a7ceee1ce8a055a0112db53ab0002c1343578a1876b57bfe6e277144626497436877bb322c42755d69d418cf68f40763d589c9f9c5da5f0fb423a7456bcc1a13c9332354227bad10f1c8c8fa2eca87de9f537b2589b33845c4b912b2c2e0a0858a382bd8d6a3feb11e7b6d442ceabdca86e12a945ce588b976416aa6e60a5edbb1ab380b02534e21ef3f9fa15bc4002416b8481cd3e904441ddf2dc4c00fccb954c95dfb49d011f6eeb3b7fda641bad743ce9233500cfe59c26636514384131848b0a37c434870bdc92c6a8ecd7d3cddb206289ed794dc908452c28b6778e5585e9e406ca3e1924a9302d0cdca36ccf47e92d57c8a4858e1caa8dfb199c40e277a916512fd4eb9d621f5281774f5aad3697c96131d76f1a0b024847905ddcd79191a0e9ba06188a5f7f46c8931ca57b780984d34419ccf33b98097522cf7e8ad721f34de7340b238fea923bee8b80f7ee0d84c6432678d85193116c54f9043a978eeed4eb7670b7e175c78f24715f0a1b2b8f7a891c1179a8b8828249c63c6cdf9ba6b6f4b693247e5f691ae59aff857dc58ae05386b5d639c49252aaabd6adbd07c9ef1958783372036cae0ea067df50b7d8963e35a27bfe86005b4bfd407301946994b4b267730bd21523195455f929e8f8d4af7c8fa02dbd12847ebd284b7613f27844a2a6a60aca019c50c29542dc6e9c41006f022e138969eee42253513cb66a46537c193f6913904ff1f992f39b94ffe0fe02f2e2cff845579246e265035969e39e26d912baa7929a0f40e7f3c4eeccddeac11caa1cafc2b18da7cccfa70f3d35bdcd513eacacd1c214180a23e3fee3fe056c877fdaab8d55c0b70ee533f0707f15f6a28609ca8591017dcfb398bb2370fd5066ba64ab9ac9ca5083d825df8839c5c749e4cfb7dac954dfa99aa246cc675f4ccf42c8e5ecd3d4cc45d7e0398cbd9963a109b3d0259b3b8fb70443bb37785bade230742df3be6bd73d3d11b105a50ac7b2ae4c01787d2471cabaea4f3df008035f9bdf079d438a86cbba37caf15e730f47071bfc3a02c3894acce2268ba469b2cbc47b80fd995a177c160fc06a84ced566393365e70ac17a125d639b5449073f644dcdc608d439b16e3c6cfbfa975dde2b4cc5b6af37584d9c7bad204bf55d89bfc8a6192e1783118456be6da0d0f02d55e823ed732073f7a142006f90ddb1d3af7d9bdccc5a768e905b7f137031f2e6a0eb3e9776e18225560dd9e7999efa2cccec8c47d3c23926b2eced7d09a23002da5f67a878cc71f336e6c318c0f1d1b913e307583d94a6f0bea023565e6a7610c21fe8e0de4f11234fdd179266c36b57262f9d31e90a9166eb10d64df39aec7491c34a95f2786499d8bf7f3a3d1cc0408757588a84a2dbed7ac3f13ebcd46797fd286dbf62e7c04bc408d51710cf0f64151cb2ab3c1f246e4fa93e4b140cf2298581cf1d44afd72c475f8098c8bcc40d4ab730a5d84e38f6572e8bf905f346e7121a602d23a078c8e1f497374d9f17e757de3c16629bcd0e58e82e44b8fe786db5156b8d5f5535b61a02cb7edd32d36946fc1b5467c4377f1d306b1413f625f9fc16322d52bcdcf1f019e61e55917c7fecf8bc75c46fff702ce0711f6cfb28a7dee5ad5fa2c821bd0f65cd77afaedf485455361116f92e715304e83d60b1104633087624c374ba00de01e4114d2c7bdaefb523835d85d4893647848571ca7ef62e808de2b97edabee38e6384d765b0c78a4c2cc8a67b60c0cdc911d9868271917be1dee8a7d5ecc08d072bc1c06ad85d2fa0c513c19f30cde7f3cd75dfc224f3ce753e82e77410f04d4467fbe9c91e0f0a5cc0343564bda049be5960018f0cbfc920b58655f6c3adfa66d7bdf7520ba8dfc76300765f78c7ead7b424ec97d107163b0d47fca402fa73ca16418dd2721207bd7cef236d32809164442623db59a33070b7422b879770b369cf843cf56f91aeb410eaff83606a403b387f0d30e182f693a28a691f1b03feeab5324ab77d40b1688716a406772c8045b8fe90205e2570a7245457a8ab9ffb8019acf9b4f86fde852fe1dde3323a4f343a82f2aa3a7d2b31a53d3f9550c54287239c2ff1aba872f56ba8b18b9301beabfe7dac12ec4647320e38186290de397225ea265f239fde6bf3c3ebcb837d731167dba78735bacccbbf1d442c27cbd47d941f6071303279bf0762a6629c273edae6588ee6aa2ad4667729af24f632f4ae944e5109acdcf20a8bf13ac67ca919a7669f088216a8b874a4693cffb1e792f1de2c71a3c0899bf635ad97a549af6b81b12174f6be83f46e2f4d69d7ceaeb4b1aa7be7e8d45545a077c053816b58ac42f1d95b00b8329f41a20c77143731564939d31e80d428e36993869325baba0e2ce994dee64a139135baa2398ae4d6f7c31487062e693d3054e4376cee755e3e0dd7dcb14b87371443ae69fd1501ef56699101e1fec429f7ee74285a5ba5e69b3d915f974ec1634bb2e0c001baaf37dffda828b37c3461feb3a6bce15586ff5a6c31b76e935ff8327dcf827275f4ca8b3dc0ea4e9b66247d39f54144960f6ba51325c94557b39c60e2cd3fb7b454ab12d398b6e55de67dd34bb1197259c5b96019a8d5f448511f818f2117c2f4409c577ea10401255f964d24fb128d08511dd1c5c8ac36848a1bd7bd7f4ec4691348e0bdffcc71ab1abe52f632a1084930a4c85202c8950b1aacd955a9dbdea8fbc2ea47d25d48a129b7fbde7445c88e6de52a40737ccee08648ada759a5c8c096ce144ccc6d584a7b977a9c2b1002703780a38aa5ba2caa259c165ea590eb2c07d9196e818bf22ec317e90b103879ffbd0699b7988a6f4944a427f24791fe3095d8ab9db49646acce9be2cef7fa1abb2ff259dd710fb401d443842cc6767d372860bf50375707282eb287d931053157d20a541e8ff3af09590a24df4ace63891e57fe3463a56a4185b8902831ad209290419bfac3f2a635dd07731e00e0ba9dc0fa48eb3230861d2c01933630a3017c8d04d371dc50505607b8e82d01860d50697607a7f0532d2bc96385954802b40c6d599fc5b9c1a7dca409baf074575b1b371b0fe2c5deef1a49a835ea02114968ff3884c31aeabce2ff30192fa88249bae3db3edafd0b696a6cb29dcb95ba18b29b97bb36e736a07b9d89a275c6d72daf98e7df0276fa9f4e45371beee65236a2b19341a42eb76eed63c85fa6f05eea55339fcef981630892260f291b518ed97675427dc7a46de8ab25248dc374aa78f7255eaecd1d8641ba5ef2b081ac8219d5967c78121f1f9b1ae3476024ecb8cabf482e2fc3259d742164f5be94b0223e09a83d6122615e29a8b16fdccf1d373efdef06712cc30e444458605931553fdfb75fac3d5191fc9484c7499f878a39da35b0c5b4b22874d4f9d11aa6a118684eeef40b46184fbc493f74ee4d0d6b2b189ab0465dfc1499f7424b864668d0f351e688395c45d610f3899de771d81462abf1a15b1507bc534089fbb7f8cecbb56562315feddfb44720dcfe17e2ea989f0856635527161fda5fc45a5bb708fe0a29e54bf444777cd97235e0536c72bf30575999e311cbd15d56ccd95c3f36e009ed7f4696faf7a24a1be5b40852b7165ebbdf83d461bca0eca46d769f30728d66a006e17d8f199abad4b09eb704f7ef6cd4ff7452f29b056c7a078b4c89f1eb3cd90651aee97a791335e97bca53cef80014521116b9920387dd6e928e2d94d978216a2865591cbb0116cc46841ede92ba8ac9f0601cdc03efd375fd8a66aa003bc8022de036d74649e4571d88c616eee9f412fad0a3583f2b1e35eb66ca91a16dd13ebb0fd3513c0079ad1df2ecc3ef31acfdd1fd8e355e60d7f6ef00aed970da102f97d3f102e4561f100ae51c0172619ab83603b7a79090d20e3ed60270287c46320f891075b9c8cd764591ef3ed1b787f1c485fcd0a42fbd572523bbe2a572402d948c21333e3559aed2d9dddb7c6defbda07c7fd199ce20b17ab1dc0a2d450d9dd5debeaac5904a7b475d1498e03df65bc4d082f18b19580444768d26ba38d4b3cc4cf7a136ca0b00d2d36faa65b6436c3639ab862c7abe125fc70447a1ae61d4ddb353e2c6ef1ea1fad1e43b18bddcc8237bc09762ae1182b27282993e5b5326aa4179ed20ffe06a58660701eb982a0371698091046da0b540d08b5a3be83a6a9365ed94a9eefc91c53b434a20fb3a2499be3fd4c13094dba8aa4c64e53091f9f75bbaf96e48e997fd973f9edeba150540879610d76110bd5e4aa5f19c177d02891a2ba51afb2869499729407ab157647153bad7bee47bdb49ba7dc618011d1109910735e67e1e14f4bf9572fc7ccb793cc4a22e2c77f03c4202d8dd49bfcaeaee26640e35a8fb8040b77ec4d438b11d50faca9deaab6df99ff87140f96aca4c2ea1623890ab690c4ee45b9fdf9082424dce52833d0d623fe17990dacb676e5d7d01c2b84efbe6d2bc25a6339f8b554253074155355351a91ddf85e602196e4ded8c113b575990c50b73f44459d86a56c1192128ac69bb2e0e47469e5ceb836af1341b0d78aca21bbc816caa5c7098eb936102a1b18907af7c608a6199adda139674d03e479d61e43c2922d2b12303f1c6b6bfa1920bfec80c569ff80013195cb20390dcb1738dd232c9c503584c1bee8be8d7437f5a7e2f1b58bb95389808371be36a114376482bc57770ed5eeb96837129565444cf38031e9ca4861489c4e00fcbd8a6af440063d9489ef767bd2f3e9ac339b88c2ff6cae35079f9a4642ebd2335bc56d86fafe8e4c929fb23f69a5d8afc0c4b4147a5dccd449ce05b1f2444ae2c98f5745ca05445534b8bf898e66fff847df560143d8cda14ddfaf546704382faae237fcd78eb5e63cd1164cce8ef2ae67a91f8f09698e238d65f3c19204c9c198ea2bda5045b103f08fa7b288ae9b5beb3fc6e82004dbf4907d543fd3ce8d27f29d0b3ab2d80c3473e1e496065d2cb75f8349dc927ad93ac0b907e8839fc0a2bb4e1c5083f8fe3334fe06228d8a906fbdfb0cfde0329941f41311644c731964a10874916606f513c86af6bddb30de67567c3023c3698c4c3e12089e9ee2cba2a1600d73be0eab87bdedf068036512003512e2be8e5511119f51e0ba0ff38f530c07e424d1a2e401349643a2bec33b19ba1054846a091456c2bd211ef32b0761728d9ea3cf5900b6da08dda8f248f4c41caa0eb72f5fa415e3f5a6655b0bf3a2c33bc0bf2793aa36947acd42178f415f90f8c7c07886cdbddd8ce5bbebb05d63f5a104aaf103941d5fc5bd4d70f68557d5d28885b4f6cb16c361bad3e5f4df84fe3e7f444080fee854302f9587be983b843403507119919cdbaf419291ad14391ff8d60ada6eecde99e47301f1b2ba15572861525e83599879683210f4463d84fe4139747df0618181934604e024667610710ba61cda4e25f59d21b876427bb3e1757037f8f63c578c1de25e20cb98c6f9ac3410eac1e72a9f87f2a915a5f7f604619d8d5bc7aab5625b274d497c44c25d62a9e2955869bcdde8890a168a0001d1f8d0544a1df7f1d68cd1c9508ccb32a7a30ca317c586b288307ae16fc920c04054f9edea956773677a3b050e155be1f5db25cebded9a71051b3ac95199be10e19c388e1755983b449a6cf95cf92f62e89950f963d4891a8cfc3b7f1671f39563c8f309f767ef6f6e525627c99ea147b49d9760caaadd4dd2c0d61cbdd3ccf41ca829a1f49604ca365765026985cb44962b7233aa9b08d9579f4dba8d3a9889d51518c643fd1d20e15aad0bed9fdecf8556bc95c2c7271c7c54ff68c0a3732a588b4324f36bcd07540bcd631efc7f520d1210a0ad26ad413d636e01dabbffa49f5e45977b132bbc2dead85e2068d972353136c0babbbb3a1a963ceed2ef979c7f0ee75c345b048bfaaa34a2e486d1d14108d8f447e1ca663cbeeb26fb174b05c73e5fca7f7b00cc36e1e52e347bde96d209b81e4f9c04a472dfa9d982b697c47623069bb09299ef9de19c8ce59cfbc4375085f69d88baf09df0d18d6e0e604825200979a9fd7ece4c446fa0b63bd342f7f0ae4ef3fdfdae5558f8c5719b54dc9a0a2f1b3e48a272c570efe6fe889884024e2820e7c39f92f22e2e0cfd6ee7306918d90869ec54ac547c23eaf35eb0955f0649865d1e0ccf03534c2e8576ae585b804144cb09b996e0c03bd6aa6f7c37272ada24874d73ae34986dd82d89bba37541543a44978997eb2c5e9aaa680b1203c8f8420cbad159f84504f0ad37a80d193512f449343c3299d7a45cfe08a0cdfcd94613aa0089641ad8ad75c2094524470748e3f88c6521414d43d0cb1d85cfe6bdc9460201b380d77c97b5b7a710814210c7b9aa27361802383643b5b04e9f30d38754363a030c132a6441b7c90e2be106df1608997b961144f7fd5b721a5dab67794d1a0bf8ed94d45e3b4539108b77480ba68b91f1140200239ae48c3160ccf6c62b4d998c79fa90c764072dfc937b15238a9cd7f113c30317a5e93f8ac6cfb3d32b9ab98024420f86c5fd4746934bc75f748f927b8bb52b5e065f0c166d2aeef0c78e3d63f05807275fd8bee82890a304c10b60fe523d83f593aa43ff33c30ad61e481d8f7eedbc48c7fc804ef1d7f1e575882d48a59eff09b9dd4dc65efa95aba65b50caf011ac3fe6fefdf223fab3fe04393466d39f0ae1c1a5dddce1b0dcfa2cabc2c3bbcb3eff7c1f9c805c86056b3769d7f63cdb1c7cbd98e639c627e37b7691f88f65bb09b44674b5049a36d270b2c416512e3edca311807728e2d0297266d570c14f46e42fde116d49c4f0d3b2c6057996683de0695b90c6e56eeac2954774164da7f395ec9aaf0c624782ac20a437ee66245bdd0c1d7c6c9a9c94cc652e6fcc434f865bcf62c8328bda6184cfbb0b03efed3deab44b659aac0bc90e34d1ec7d473878814bdfdc4418462297d0966b2354c2f27d4b2e0c0fe91cf409062376715ea2638f9e9e8a4af3e84a8ae7f8df35e604075338b266fbc944b3fc4be68f8d9abee0c77ea04a531dbd37928c0d8834b8df35e3dfba5fa79e0c2df30bc5065c735a33d609042e6db7beebb2fe1fd5d8102e4b08381c237e93bba6c0a6b946cf08938fcdf2685c96330886d210eb0598f2da7a2a00e4e0cb38e43eae950320ca90316908f754b5ec29946508847f7d74ced1c221887771f100a15b76a672fb3a60978d89dc07c440fe143328b6535559c5d8f0331b16b66898f0f4651b74cac6b073ae018e89417a7ead8a360ac5bed1bcfe816bc9f89bc74724d0bc9ab76fb4b3436208302dadfa9b26d949265c40be33b650a16a6f4ccd013bda422e4cc298a62878f9dc873182e8cf07df206b8a2f6f0897033b5ce10b2df2f69526dfcce494957927a46aba51f8dacac2475281b02af2420cb616c9c877184b97f833d7a239c660639a2537a8fb2f5fc88b2fe50bdbbf3d938f63aa8894ac86b6cb63ea2a62e9bfd325cefda3a93a5af900adcafc05849ddc129347cfb94900ede6b4e12b4b8d276f06a1bc3b9af22ff98cec513a9f4f81797f134ed290b2244ccdc255f59cff672b67996fd157c349fa98e94a870c0491ccba5da762fc8afa6c1e2d2f4f827b2dea9bf3afcc3f9d601e08e1f43229cb33cad0f98a6b16366cf116d441f1967b36f17ebe23005d7703aa176aa5af3af490512c31276cf678a111fe0b0c42cd5d2e597c3d72d9e966c971279122ece92aa8ee47007cfc95e81d383081252a4fe40f5b2f911dbf199a9cf5086821dface9af5af4405bcddecb85acde118b6bfbeb7a25cc96bed3b3e0c127fd95f75ad37c096139514edbc571d3056ae67b051823909db89fc4eb67916dc6c4b75001a99d6eaae5681b13081bcb11564048b261bef2b701b0a13e7c0fcdbe172410ae7ad1118d456398d33d67005399f458127da17060254927d1632cff2ed7de53a2ba4b7ce92dd6f1ce8175634627fae25dd3164944cc49fe3676ae4902bfe7ce9028500ac2b18bbd909c6414d5db0c8ed44721c0492bf8f971df1deec673e1fd0c905c74c5796d43147448ba5a06a3e1fe492a054f5fd9a5e81e32918c522b179f9467a9beddd8dafccb18da745a1d5a7126161e289592b348b5cf5bf7399695cb69d3fda4566669859aff5d4c22039b351e3c162a774f464ea1707516aaa899d7d552c4e95401ca80b4e112ac5ad3e77d65c624b00a312bb0d22824ce60ff58b2b8261a94508afde74d394d9d7bcbb497b8ad6c417f4c3a20b452555038f40302c6b4bb03fbb129fbe6c80ff25f4a447d2a472d6854b6d3c622b8b5725fd572ebf58bd660b1246b43b096de2732b6c80b33806cf23b5ff6602e8f42c61770c3e6166e8d54bac6f993e79b2eff59487a6326046ea71ef5e6f1b16bc3427bbf3176183825f4515e07d6da2d4fb0c2917ac84d8a916e18de4375b75435021e50b6640fdf834fabff0d7e0824521956a19ef8024ea807718e88d8d414c3a1069970db4d4847ed9565b2f7f766970a2e4e85582d54e12d2f0d560e1d4f985deae4b8fc04d93865f6f436d2f0db0b8d9c705050e20a01c7e6dc7a85d0156cd8e747ffae4eeb9c21e82b225e97815a29195ac534468168888fcd062fbf656f6bdc9b792ffe7a3125fc8f09e5f1f559d13c59e32c2446b33371e73d14887cdddd812b063a7970f2d303757f728ca3beeb474c2d1186d436061551e0bdb88c64cf9320c225b21f5e0cf9883f6634e96e968d65cd4ad080358e815b840d6d30ed1003fb0e1cac6e4eae85d73fb11ba4fffb8ba77f32ccee4c3bcf70791064da1fe701dcc271b5d314d47cb1d9b8ea25312737912936c31b0c01b46a698f172809b3c3e8124a17fb8c5740e6d4d78a1aabe226a54bfa5594294cc75d32976977aa3ca2d0ffb4f880ebf05c2949720b125a777161ce602508b2662ec4ce28d3b115f8d0b62c609f8347f3f2a09b266d0e716ac7aed1b92ba74bd3d5a732b6e5858c1f200a4d9f65f2e33a5117df5d50cc96299707fdc8c1bb94fb231a9cbd63fe3ff8fc77eea1f3d2d2c7c8f25662c36b20915b27f7586c370b48faa149995b73fe86b7b85dde0867b93f6a43280c196a74ddf87c694b9b752197ccd7a12c27750051bf6489ce8af59d9b2b131035749d577526d13d5f00ab7bcc0d498f72ec4a432f523563337111c75f26a7e9bd40340b6293df677b6bd03c399ee3bc8d287a86a96a82c49ab97ee45fd79c4fc6db1c879d7e4591d24225efaafc7db1a84c4c2ce542f5caa7badc2a66b139c070d99e96c731b5c116c1c87eebaa7c1554a641aad5cc31499cfec8b647e1fce34ef8931f96c2cb776336cda4a8664a4089f9b63db46db6f5fe78ec8a437a1bcdc8fc07a013c401911a1a6ae80aaca9613db302dfb5c996633e8112abd0a8aeefda35e7330cee95e5b6b1d752ad80e9941c77fb1cc67f5ac47182b4428093db0b537769e15f03e37a4788aa79786bca03716838da5708afbc3156211a2d524f7ae24adfa5fa12ae6d1033dde65fcfd4377a21fc05edb2caf04b9a81d9cfd67435b9cc5de77cebbd23524761033fc7e14a62754fc51cc29d937f8f23de5ab87b69de6b1cdacdd921001ba11747e417169be77eb342e968c848331949f6c45cd1956f8152c9b23a16190c1a1b031f5dac8c3d87fcab96db527784dffd238a366a51327481b07185cb7ad0a6040a7459585b956cb51fca038b2813b3b56abe5dfb020a8c60730e39f10bc946d1f83888b92857567544be8e725e882a8b9321107b246df7bbc794c532775bc4d6ada68a9578a54b5d99ba5b98724be135b8ca1e063375b9dd5fd7ce1f356ac03fec9b9affe6122b40d2391d25aeb9ad0428afe1e7bc4f49f0fa070accf8ec061bd374a6de7f7e5bb3fb2f6267283bd83439d3206401f5f54732fd0ab67c187135b9cf6123fc7f736b0944d003ba265a47346633e283d61ef70e73f03ed991a89d2c09c9b903166cd7efe20b7e18d79f6130b9bd7de7312772a6dd525881f60c2f747ac254eae3c768580233d6faa246dbfcd6c2a5ca0bfba329476b3543d8dce046e841e3801220c28964172c9da4aa1daefa61de21e537bf7ab7eea45c268d29d32a8efecd442c5988c067f08f899fc7e066aeec7cc0c6bd2a2ac718a1fedb862dd7e0761cd36ef2656459f4ad9c9fd323ed5d464d9a1f2c7a67f0b9b50de83a56e9f6058292911f4b36f0c308b6a4bb88f3cd3a5c2c62942a9badcb304279a5984cca483b36890e2ae69e018344ecea17aeb502679e1feb355daafc76fe425af13d61ee797bd7aeb7e624030d647b07ab94eb724040b6eba1b82e6d330f0e1eb983c3b76d434f00ee858528f14877ebd5fb08ab3dde773ff91f3efc8f11b6c0316322b4828fab6b884b41887503d7e8cf000628d0f68af81fe39e21d1cdecdd0a59af989791bd3187026f5d6c9082a3bb2386b8726f489dde8ba31ec88f8f3786e9acec710ef97b318bafe721055b94c7abed893f487532f938cae5cfeb791e8418ac0348e748b2b7be3c9c83615f58f1911b080b398e573232187176cf89ce6e5b584ab3d7943f15dfc04b9b4dc1c0d9946cce95aa7e02bc90bfb550da0e1fd7e8295f35c044594d45eff0ce17c73427ceab34c3dc4a271b853e2d8c9afd27ec35beb41bac7f099d5e00f97018076210b805ee30997a8ec1496d6f3ed67f8612ca601d06de61591583a12b7d0ea256d65abc82f51646b99de80d51a61fffac8b3e6af3638d67dba43d4e7df4c1100abd99b0caac1b0ac15867c11a49f00eb488f894e040765200e450c72d2382c12d35c0c94af8a046dc98b10ff7e4b3a46f321f92887409f18a05b232398844bd4c80fffa3784afe99bb2f003867afe6431c9d5d9d499979c913c7e639950aea2f1eb2b71d5dbd7de97b1ad932e1d1ba2eb12e232acf081451aeda2798555c8d28c9622191f6fedd7eafd942299650e1074def999652dc5aaaf6786c24b17894ab697e0711298a390fc4ab7d1d6de86520ae50f3b46e827e725c6db1e83a356908e9d87ad02493ac34880987aba4dff9d89dbbba121a9d1525276bc2488139762aaeb96f4f0f3ec8c23b2d0f5d0b4e4755ed247df5cc73cd84f761f9ed436c9753f67cba3aee417dbde0ac625b04c6b6256aa3cf88cb67b87ca9209aa326b9432a2fcbb9a229cd097fe9b785693aa3ff960d8763f29a24fe634f246653be7dafc4b10a55f0c3d7efde0f07de9d491026c618e1585f3e0713ff5b8c04bd0783930e0b4ed02fc96fcc3087ea15fb9f07b2a3c8c18421a54e694eea2a2b27569a6f374d1984f0414c48d3dbaf495ddb234298aed2cdb8571001f34f6af5f4614e703fef239ff680e88cf82bba63a9ce300f3c2a1e2d8eaaafa611d3dd5046a8c035c98a0ae2451a214d14e4437fa1fdea1315815be77c78316d80ed95890aa515a688026a758931e844cd711486bd19f3d4ebd89a990ea9e365756e980b47cd6ecd67ed8643c0bc7004d082bdd4ceee943ca041387fe288ba01d251ae6d274e256c11664eb766a762584c8e4a9b4a97a375319fce6b5cd56852c0ba46e68654e665b6b548bb5ccee1a296e6a3a47d8eec460f985926e66bcbc668b698eee1d28edbd3336f7b63f7617916ba7f4a4311d3c12db01bb19ca1fd53537aada3317f3eb4b9b24b34e6cf3af724989c049aca3533d47d981d7b2a47e26ef41bb2990d57e8c8d4f47b4d62c98cd7441aebcc5926ba821a4097d9f2e948459045013ade6775210f54ba80dceb1cc208e686f5ee17550221f78411f17e92f26ad0f2270a7aa08158510596bb26aa65d776a3115cf9745c62c7686d86ae17f9977fad533395eb1da1ab6e90d8d7b804eab362839c402c5b058a3a9b921e294df4d2264ce5b76bcbc77ff341c34a3857e5ff21b5f85cc181268698bca75a176aafaf97bb7585ae19a6640d293485f3d50177e44fc7e1ae1157d16b37b71e4b53ab8c57077ec35c62b79f2ec0e6f902aa0815b67a0affba46f92a6d6cf940459b5c01b5248a8891aedb5c3843828961063d5b5c16a2d6d9d8d466e63711c43f4f5a68cb07dbe1010347a7e340e5bbcbfd814fad5425c62d84e30cc6ec3af9b6bcafb0889cc039fb9c83bc173421b5060ee01c234ef3116054322205b7e1937abd157d8e51536ca1bd3daddb99da0b31462632cf0cc41b33f50f881f1b5480dc6835f2c5958f686025081736a9422045a7029bc8899ac0e5a9e5693d2e09c48da93702a8736abb3a1dd34be427f1f070fb0b3ea9e01b682d36ff0d798ed7929692c3e8c945278a785d1e9a7fbf6919f2419e02a8edc8fab716f7809a3a9e270c5b4f62dc65762a80c183110a40f6af3f6347c648fc5f7e23634863e474f66028b57927bff9042f17f5dd2d3349b944cfd9c1a48617dd03cf34016bffa261f41a09f6b499aaec00f06b1817ea57dd089e4bea33a5bdfcca2770a29f17ae06e24664cb928a905f7f37c2ee38fd95c1d3f43adf98c7ae05f73a91dc681e517b043fa08036ed25a23351703f6ba49eab28a264db94167e6c7a0f2bc2c1c7ee91a7f0bff449e3edcdc15d4515431a8c592e96ce558afeda134d7834653775dd7b18e3501c9267f0db53fe36302fa86129c2b3811a39237c8c1a742f59b8129e93fddc0b407ee49686de22521f4a5a59452bda1235f7d46a757b21fc070c804b4845585e3491ca5f6124125803fdc975d663105dab3efcb768f6943375edb0058e54c99c03ebf81894ec0f7f9f9f7967d3fa1ef76528a9e3cd03ca437063e0c8c7c1c34edbdefa110197386784cd80fc548d5403b241e84862c9d1774e16decc055aef0f93eaf6fb628f4773e3b70343ec3c72713e499074714b2feb7755acf2494d28ee0d5c76e85ff32d239b3a8484a175087880d90d93c8b97f65f3ff05468cafec20cfbeac54a71afa5a9d8b0583d16ad318082c934c87627b1425c0294665630f3720339f95cb9b2d5823f01ee3ef8a2e1df52e621586b17244b9f38167485493e0197967b918afa7f830467a17c77a24ac48c99adb60b5dd3ac90ddbf1d2ae2a7ca2a17e8a58ce516e567beae8aa4cbddb8d35dbb42bbfb23ec3b71c205bf2a260187ffb0602921a2f582668624bb0e16f0c84794540eef2eb511730e3db899feebf6fa4319cdb40dd76f6dfd4bdf82d649aa04e449a8687c8e69ed5421a0cccd780819751984f2b37f20bb06b02a31b033eaefcb1aabffcdce00e2eecee0b547276e38a6cf13f2cd557cfe7b883016b39196afa82afd1e72781b9a173c000e75656de9798d6b2f72a593d932187402e0dd2cdb9af7ddcc79a11b55443d8f70e63ded3c8be8efa013065fc330b8671f8a50db9b45f85285e92fba620268756d2d235185c3498aaef6d0b37a7e6d06b2fe6176bc39292fa4a85a494d3b8fd47919d12f2a19757fe34b8abaf872deb3b1a65b295807134af6415d8da9a6f47dae2cf2e9db8224e15371d3a8cc19c77a27a147cfe5f03c36c23558fa2f989ce1c0b7966e6f793c67c43d9a1443997525424d968736dffbfbe1e7a18c5aa510488bddfe0d5dc109a534fe874d9dcf130b6ef7ea749c955ea14b6d0ef87e3df5be2fb4889dbe10dee8327ca639ac959d2edfa9e475a0eab7c639f0021ce89b874826102e1c4c82c8a761fdf012ce8eea6af93473c8bc29d7a616de0a03d3992e2a32074b04e5448a5becac10c422d96a6abe1ae9f2be098ec84f7445af5cdba03e77de53b84427b9e72c026f9e62e5862c8be9d0c7ba730a544be71ef01a23f8c44fc6bdf8d3014919a453bd6d623a5bb7f13221359ea144ae4d6adf3664a177c962254a17088d58b1494b430d054c547200797355bbff36a0207fc91ecc251ef9e595bbf660701dfb40c08bd735ed4fc4a2ddfc497ee20430ae5244b0afa0ed5275dac68eff134757c270acaf61cf04abdaa876080d64a2fa6cd7a5bf629173a463a62e8534f118d2bec94ca9eee480c6499fc64e19395a030821761f3ead2795b8bb2dd0c04932f1af1179a37501e8a2ce724e3596ee1ec2c69bd82d5738525474d968ae620f5a597bdd36e19eb7f520751d57bf21e2ed320ce3ddf86586ade9763b7aa5a950cc86b05a5786c8bfca39672d8478c25459cad9643ea590f45311c99628292f880a58001bbb3b962e7fad4932d2623abb03b552ec79906a903f8c8e9190d26fbe8eeebfcb0e0a7b9fb2a5aed52007b7ff580061b9a29f397e3404777e40e7b8198439febd9cccab13e16436c66e4e23c4f5cf9e3b359fce1fdc140981a1be6f6f3bc1c228648fb330477c9e6d24e98b801debbd56081015a709a7084017778a2f209e1a9f7d1c4cdaf04bcdff7829c62cacb41e2b063e8a074c15294bbc259a8f7c558fe6259deca9756795471c01613c41de60c22523b632c374a05c9b9bdac169f0336dad8e3c68eefd55a0db8d58eaba434f32067e7eb02c3573502369dbca989880b9777b7e0527545cf2aa54a67128321a101ea46fc175c11847c604ffb0aa7f4a7a8ef29650462f40","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
