<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5eecfc8deb012d2b0ed2120be18e80579f2fdc67425f664dfd792ac908d27ce0cb49ed2ed45e0d3797b9fef9325b4b891d98f61f1513d724c70042f9fe04430cb2d5fbed5d5c98afee31358d810ad77c6a0dbcc4c26927a46aac3f9be2f4e83f892c60e20f1113a4da120bcdc2da2c7c98959ea17dd0e4c8d38237c78121fb618ee50667281271265eb02386b8c0356d8c68b5cb47791ded8506f7a177f4d4e52de9d507bc0ce54d43f4681a6c5f2da96a68cf918340e514b1be1bedebb3d55993d2998a1211934607b32a0e2b01d26282fc5a8dd89aec00e4a53fd46adfdbb102acc32397d279533048f4eacea2bebc8c1654b837052c6106dbd63e721d6a28e2c5d53987276802fc0427efd0130eead5329aa337e29701a95e52b3d2c55091abd3f137362f9005353f891b8a8b62b784186328139451d3fa87f3552faab4da20d4c0857c23d36ad89ce7f1556e0c47895a67b141757ce57ae94a25ed438dbe68c3868767e91a85c1815e19db2697205198588e06f18dc75e3712485f1d4724f60e1686676b72039fcc1937be9e6d8115b74f285d6c28fcdafec45f0a826c5b33c96abb4d66ca13a29017ef1411dcf1c2f88fbca100cd074d15b7c7f33e73985d19880a7d602c0621dd5c371d1569c763fe946a1e453adf5e98e62316cbde8d0a4fc503e866d5b007715517ba1a11028599059e68988183a9c94652cb7fec03921e64e107b5691018cc717b9578d432d9d31629fbc53cc5c23db8e04f9d608ea55436139dddeae19109a4ccbb97abd458dcbcf1104d9a918edc835b2e50c83de29ea3ad42395e6518aa13d6750c99aae3814420e9cbcc4c3a549c3c412668f3418bde6c64cbb3656edab9cca9adbcda45cff0151ceb34d051bbd668ff54df49e2fcdacb7582a88c9fdff4e5aa49f88425d8212198cb0875ba01f8ec94b0bf15cd0c115b7d9281cbc24329c8274b9b938ddd2073eb402c5453fa6977a749511162a7f7fc926d82e5f8c794d35a67b50b6225f3220b83db47cfcf6d7d64c6494e6efe22be19cc50923a71036c4dd01d8d66e25c4b6dbe543d4ad96ce68dfb9936f341d9e3f2904cd40f98954e3d35d83449585e7e11d5390acf94c7607eaed7f75ce2b801a0dee8c0c3667871ab60bc4bf3f8e2af9fd5db2a13fdd801c60006f3fc12a4c9075d386748b5e5ec1d446cabc454cb780289938494ee942c30958f0db3cfa735dcbc4fd1412746feb7cf008e9f61d4c406502cb91c97036cd01bb69643f439ed937a9147dc879b63f5fcfba073cd1516ea206e1e7e83c8dae566ffd2af7fa1fa27db24ef13cb4cd92b882f80781ae9c8aa71aaf66f811f3364841a2b6ec5c2bccf66c61851339e2112b24ecdd5c852a68c2a2a31808ad2455297c82f222d8fb2a01f4438eb993b652260bc99d18a6d3e587c5b55aed034fabdba8293809581f35a8389c19679b1cbdefba915a1c4e598244bbf8ace26ec678d515e4b8bb44631e7867ec251835014825cc11d10fa02e79b44d2f7c88babaca96ddc315af4c7c9e9ae799c454fadcab70a462f62c829f2094f3a3ab46363a1cfdccd69aafa7eb894206b370a37897058b638e4f8154951fcd2f8a39ed517c6f16d1ceea4394f0b09ac30b732140156ebdd5e5a184cb1233661610e402c41c48a3b9fe559453b52b4aa39a00cb72cab71d3433322a99e5cfffaec9d963150c20d027a262ba669350bab1224c3048151deaae032550ff622113acacac26228ac3c25bc0e4908d84b99e4eb503bc96e6e66606161a1a709c642100fa42edbf967f651c05472206c6925bcec90f4602f4f213609db0d5d6cb4ec693eb1ce3433f971ce6c2b9feffb32f7e6add840d9612e56ddcbf493b8fb149a7a086b49002bf4db882fdb4fd65c2e99e93be91d85b7262c69f781b22db1a782157051979ff42aff44fc1421db1d409ee4043776b6e6ce32ac54fb34f32f145d325e2e4071982d088ee8a25a9c5bb7bb7bb6d2a053f23ddeb655749c3b156fb483e865196455f73416a17d14aad4670d6e31c87797cea158dc2a03668f597b3ff283fe35e6c56ef9635d3d886c36e772b0ba0d6fc1b954a0011ebea7febec2f79116cb4f0936abb513bf1b73b8b975e9f49983ed01afeb02923059d3315e79799367fb78d2638c7efc181fb64f09f5e33333efd296c8637368a3873dfd8206dc82e04336dd33262545638dc95e4d53194727c4727c4a0b671a593554caedc61e840a4feabf29a2986dd599b290f98480cfbc3af8b8ea84c38e71bdcd47da98cdf72a6de46e3e4e16f96c1c95682264afbe4c1b726b02844339f4838515a1ad3331ebeea022e755901e6284f038f7ebb97d3886d7b2f39700a733c950dd8ace56032d4cf1400631ee697ef1cee8b4c43a74d910fd3e6b2d0e6b37e23d5ba6dcaa80f1574bf332a6268b35dd7d7338f189ff67a6be0603903dff645e697919104596375824d4939c7b58bc6e3de8451e732fbdfdde8841171a2fc45d0257f8022226bf3b45317ecfed466e9eda9581dff0f43695d3feeb66f0436025e660732ee67c40e05de8f8a8b2369368c3de25db60914ef9e4213d16d6828a06450fc6d707e752f5ed23d40fb0ad4abf9f4ecdac533a31f2f6f96bfe9d462a644bacd74ce76cc0b71a47bff834eae74838cca13f995a7b215ba430cbf502ed28369e032925b0bbbfeb3cff47a9e5973c28c798fcf200266ae72312e734b49903aadd5f93103c8d63ffb372920a337ce9377854c7834ec84a4dcf090c359b2c05ff66f9e92c8e168db52b4d6a6e6f63e32388b2935a6a642bdf6354e0f95ca8fb9689e065c2484b29a6cd8c796351d593baf39f7656d6144eedebf88e3ffeff116eaf1d374e0e6f557987a603a126f0e9c02dc9521f5173484266c41b5baf650912a7629893336c67f65cab0a85cbd7b5fa7e3a9b373875451725ae6370753fd92650ff6d96bf78383591e75fd7d66992a984e8d2876f36893250bcc69e3fe0521a29557ac2fad85b247d7eea8eb141480586da2c33ef47ecc876787e0b2b30b6f8ba112f6d47911a44d0b0af4234a228ced573713c6a28630c39b2030d4cc2ff5f1c8fa552f64c473ec7758d209368cb00e1a7da6d0a5d6dd9949acf9fc09587a17fa978a7b1d6f78a45307714ef7559beb57da5d9472a3e400993d1dfebccc72ed90cb804f14b8d8efbfed651b5c57481b3c1bbfd8272736487ffec79ae556d4e3021b46b2b4b66a444e024acac262e3a0bfbe08f0b543baa613fbbf933eea219793263cc2da7ec94447591fa7188e2c6dd3125d1ca1603976cb71d968e9ab1bbac68028cb3580f32656968e907aa77abcec11ab7d474350470b91fe6543ee6b8fe0d6133b422fc02346242bf0cd96b70281cd1b11835d0dad1457c5c83dd7bed1fc65bc62cbb24c2b32cd4f7afd26acea8a9fef4a25fcc12b3e425141d4787a7a41f328c81436da206742f9479c340934bb47885fc216c2c26c508fed6d810a03dde032305f6506de0ec2604e4f0a4fbe983d7b702e23fc5f5f2dd18d71351162c46f5083d175ab5a1d675622324c085bd7b70ab8880c28e0365374252d4a4af4896725d492caa419e064ebfaaa2093fc01475dd02152450042fe61e89fe603c88a0e4acd83ba39c53560edfee2d9fbe643f0ba358b91f743ff340ce047ec7fdee83b2ea9ae2e6f3688155f490156865ea462a8f4f32aeeff7154c535521aa3e625a9cda1387e025e9f8ed1509d98b452fc2e4cae45448d1bf71afa5c6d454001e1ae907c04e18a8705c1cdbd194830b6e469eb4be489461be065eeb46ae97cb5d3ee05009dd661a8751a2181a9dbf8a764e654988cc3701927961a00924430b03b2371eb5b4edd8b5f68ee9d2d38d738445d9677d927b7df1aef331b91f29ec6669ff393a7fc2e53f3801040742b5959e06784968fe4b3d02f5166f15146084a090f5bdab5c4cacdd1f1bfb66d226947721d3f668de813df31eec2f042f39d3e36ef4522be051b556664159efd936d31fa838feb91c4ac0081476407af620c512fbdac07d49b94e6eb6b33dffb9a7e4c7497097f609db951ef6f186e46d9b965dbff67fa4797e47447d00b899016390e559efde9527c30220a8ec9e293d472a06e5a71a192ae6aec5e44a29edaaddcdf8823483bf2eaa54a415a04676300280373266060d5775d16d54a5bb9c131067bc29e5ed7ff32bd3d90654eba2ef6933012304b20df9843973e64b6dd30a9a0080bfa312280c4e6acb4f0a7b426dc7c51fbf9200d4885807574ca8c9afe22bb88138f247a644298a584f97b26dd2f0a1c011bda15b2ef9ac371822c95b562ab7cf44864db86980b39bff9e98d51385be2cb4088f93f55d2c221a8d3f36873827758637cae39b6b1906961cdda171db5fb9f6215e4e757c754d64935940e94e042713ddc7f1d7fd66229767706b28d15fef04413e1e2f32bacaaab7568aadb8521eee90a3be92a52fb0f5e0bf4d0fd3d418ad4f9216a031f9d66b7f26e73fab5aed6553f63c047f1245d7f1984feed0010d7ee164918ed048bdc2cf9965107f401d8f7b12b7dd97605eaf53edc47c9a0d5c85d761c701a420e76d34d2f9cd34c6aaf4cbb7017f55bb265d5ea0825037d06bd26e4f83f5022b7f25b7cddbf6134d5582e20b6fb3abe81070fd2db5d79412a97c810075046edb3a4c952435f5b63f1fe906a2cca19d1273b791f1f7eaab90421f755a3e299ae018411fd275fdfbc7ddaae88f96c968b76b8adc082394095d4a5a71120e9ab811a555fa042604d491172462174d5e989aeb0f501e920723e18bd5e33b64be21718ffcf5c7160776eef529e3499dec0ee855489c76f240acbe0b1fd08f81d394d26ea586c0b263a9bf27a5b04de089379164a1cde1bc949b9cb09748c44c7de084eb3b3ad851938839fcc8d0ea93a41eb8d0faf611886a9fbbe4c6627db59789134641e7df36b046eca8545ddc20581f120e1a8a025c95067f9f17b7e690cc52588b62ee555bee522d0fa44cf317fafa99d0bdcc563b3cfb1f04d86febd3852af5aaf77982f0cd9896541879a7bf55bd078f867b5b1f59fcffd6ca35e1ee0dfd9ebf7fd0e520ca65bac1a5b114044960c283aaf1303cc0f6ece03c28e6da0054fec45d87a69923a0dc33105612ad4486bd5f378bf43a5f29cb2e662f7c0353eb736ef9be6ec64baa2750f06e9c052b85b5dc270cce7b14fb1004185d7f38c266517a9506cbb6896c49a1b931a481bb43dfcc3e1bba66e996e5933eda9f6f47e7ee4f4815465fdd92c289fe80d171ccbbc0b2e51afa8e1931efd8f0058813f7e03dcedae5cdbbdff9e4bf37752ae591c7e58ae8e2070064c29d6162dd92b5eaf861f98b1d321c7de1af91d620b967d19fd7879b3d29589e02f3586d801f7976ca575e101d77ac6f2035f2e42698b736f5a86ed4dbbc93d2ea9f1d1d7f671d6ebd68e79a982dcacea54a241db2488a29a7dcacefa6e5c461c0351966986b9501d9d8da273e5279edf9b478dfd60ba836494a0f99499b0afbed2acf96d3109e68194f2d8951eed8a911e95586cb910e420fd28b5c0d6d831a693ca3b548355affe362fc932ff64eaba28c7a81504163b81051f86762dffcc40563832393a101c19e99705d30ef0e8a0fcc86b29c9a3f64a5aef7c23aee4f5cfdf4ff9a80e726834b77df4027e17664b35222c5b5677dcc95af25df81bab1099d76b8f4f99b51c9e63621a3ec135c4f5e14845011faba5821b71f77e247609ec352cbb359ac1ae4f1591fdb88b8b845b3426c0ed9aeb519917ecbb2966a050d51d21a3df4ccbf02db86f309c8115ef5b9af8f3659eb811e794e624dab835ac888e17297d8fe5f8b06f7c616d869de7a09becaaf32af5b202da6359f3961a6cd43b01a78b1420f7829ea2d46349d0693c194cf65db173c76c11999d3ce0065e6b8b374ebf8e929cd05df260f96bc9f5400406b928a6221e550dd52b0f47a05dbcc3c1780e4388f41cf7c45c0b936e932722e7cf5f52de36ed059787270c650aa61706a2816ea5dd26e5e03bd2801210df44ab1cda8c45bd5c4d302708d87b42a3527a7b230b139f7bed46d9198f3d58d95578f54c8d05a89a342705764794d62697c4c2a72d324ff611b798ef9266e60e2b282d6e41597ace9724e415b61546c1c56782d0b0023bfa203cba2303d69bd00dce4bc1f067158912423ca26f3dcb96a10f2fa85ceaa31961f95bdc7f76ee4bb5643c5df0cca37692451ec5dbb7f3068b1005e5308222833430558bec3f3543c40c8fb21d2aee8e32518f9963ad598d551f4e9fbf6c0f9afec8219a53532551880a3879989b1fd15f65e93150581df5ae8845e3dc522d1c7306656044eacb02e8105a43112c93f29915b1c9c45d3ce25b4fd1e24e096a205f92d6a328afbfc50223e20dd0ded74dc0be54b08e205555dac58493baec91780230e42621dfc5fff6115a1d57772853b5ad9db55cef6c1da5f36ffb2a3ba3d3494764c54e543e80381ed7ff5fc48ffc7e2ec2fa45b94b477d2bcbf47b8ec7a0357cea3e4b7e2048e642148e9e1e5e3a5bada2ff8c3178142a90de0a1229ffa75ddf34bc4f110bc15b15ddedf1f7eb6bdd35a8f1e2d845ac2b7c6de7469818a91ec350d6cb9d0d38e1d7c367fb848369a0918c45e0de01c8130e6f1364e979d00914be4f1a4dda5ad67ab52cd8235b201311f2733221991b27af09297f3e01c07ec65cf0a7d8ffaa2b0c2b7806f893f2713db72454a03b7dec36c323b8967572b07ee748d0c528b584a9d8b7affeea0ea2ac14c0334ea4eee2ba6f68e5ff087e9019a36141e9ecdfebb0501b3724b6c2a31e26e0ced18bdf87650ab83fcdd70a82b7bd739b6afb9e5be8ec4eba11405b4b7dcba64456752001a9466acc4cc6612909e40ad7708a0d63de4bb50c403778231861a0e245c706f9d746dcdd0f6c59421f81b097823d73e9df79bb13f77f46bcc74cf2730f3b4aee184fceb3e134b504c1e29fbecdc489fcede26f0b29cb31fd844ec0d8776247c2c56d20ecda3e1b54b4ba97edba3468156b913d57f89411fc1f73459312cccf92d31fd77eba4cce32206159e22f459a7134e9d824ad234375827da166365d680c21af344abee501debfad657f778198af62ac244c04504432fe7f67619e75005bbbb459e13b19fe86512c321e0c4a8db1ac56968ce0bee39ce0acccf016cbdb8656905ce874a6b95c0569cadd3955b12caa19d055dd1737ed402a6d2a4311cc1e5a341d9aa1b5855c579abfaa6d0d16184fd1bce4d9383c3128f3611f00c9d65f40409ef32284b8f3c3d14d3245aee795c6549e012d61a26aa73d1c354b7aa9dc00f308712b70414abdd0672506354558f442cdc80eaf56bd1d41cef27f3007bf01f08080e4a5c9430214b00f928d3281c7efe7ac61e1c99e07d01773560918df7139e745ac56ea36954e821b2c3bf6f4c62ef81605c5fddaded486e9541ba37ff02d0b4b237c129c629c1143f3f6bacaeb0d463963db68fb186c46d562586bf1aa577a2cf40e20ba4acc3aee2196ffeb1359bad80f7903e5c4d2a630abd3f1cce81e6eb7b90e20242de7b32dc3e91239b4c6d76e7973d06785628142aa03697a472331b71f04bd79f5868598683aed8582f785785b0f18951017989888831a4e545300ff6e4bd6c4c31dcbfdc0a6f0eeacb47b8f405fa294d4cbd48035bea9dfc86c0c4d91d3fad47f9fd806e6b1a7ccd1ee3a6bcf06c6eb74a028890f0296d63d05f399cb49c0cd00481f8dc5a8fba248149b500f3c6b37a05144471cbf421b4333ad3cd4b4d4c2d541e800500fc29b7d81065d9923a24ebff08f386bb5b41a955160afcb8f2d6c37318f9b3fa60f13b5755da2c4c1b19cbdaf45673fe930d64eeb78ad7ee040b8b477760c79fd5afc1880d29bd54c4391ad8eb0d2e5acd1419a170cb497d3e308b199a8b6281745f92d291d47e904c0096e581b35aa1b4e2b88d42062ad6c9f8b526249cb74692884603e16a91ff06030b74a1fa71399bec41378d2d8c2a0e5ba9ab8d2ef17196303b8a4ac4a952282c35a17897a43afff80b88ac9fb194dd99c260a89d22839c7236a15eec3f052e9bdcd3cd01df14de4d475a65eb4deafb49fe16891c44a4018c5635a1751c388dcd8fcce964a2e961b317353a4d46f4e8b3ad1406e7c2347834fe8f13ba952b8d772e057bc135eaf46472db8a60fce684c45ede928c7b031d20dff041def10564c059244c96671061ba923e590f9a635a9a084cbeeb33b3cbe7e9a0b1f007b3cff36aedeb0e38ad4090fc8711abd0ea2a8a25b211a258fd2479acbbdfebd7f6fb63ff1cb9bd12401c9a7ad8e41a19cf2988db1faac47a3f2a04ef63be1744078c0fb18f7876b99de916f7341b6e62b065d214f2998a17fbf558461397d47624d19197793061f551afaa98e2880baf1836302db85f64333c08eb61a581b20868df099fda8f044265dc0a17a5e31427b756e94a07c11227e7e4c3fe16f513feb54721d0617d354f7a239649a9ca9dbd560e2fc7bfd853e1023873dc60f46d93d386919012107c014252d316b61c46709fa3763e25b2260c82b7107110d86264837774237c4dafb8636d4518001a1adfa7cbc59458aa503685006fc32ebcd826098e2a2cb5f4cb56ec99ea2a8ba9dbec252855d62f2f910bd8df841c931ff55a6196b639adf876b7a040f019ab122c845386070d6796c5e28b84bd25ecd2179f43e622dd48d9d89faa82a49548994b679cae634da0ff6d8001877847d13f858be1fde7ecc9bc9a0fcedb81c5d6bdf6f9c8e3e8d83f6f104d075a88c2d5723ec93e7678c22ee66526dce25f6304f3660835b01093502294d5cabe1636a9f8db011d7e56e82184adedab47b621fb756f9818a005839968816c61516bbe39db5e1993c5d147fd511290dcae93e6f00d05e3b4a9cdd4baa072b297488ec027f79e560e71bd3c8be091cfd681a1c33a4fd58dff02c88c9bb3e222f766ca107b517aa80845258bd3b8b136bf7719ccde2451ef74f3133cde29de29afd87f6147c993317bedf3fc4899e2cd8fe9b5e49a5456b33bd3d73d849c6c12eaf743060004215aa4d5ffb5ef6f0075ff4c4a0d632fc7322d1c174848c83d2d4b1664c4664c56a9f0b38f9d3a2355a594a1ecb40e063d5c3a8a9ad83ca45cc93bfbbbe5aaf0d17ce2da2fcfb8784890d33d42443eec42a4799babfd4629276ddf9ea387c2a5114b49b885b0785c036389444ccfcb8d648691f668c05e356f8f32566faf4b6482851238d1ac19411cdc1450881e5eeafe55cf9edf7a23d401b9eb0f1f4487f5d35a06ae28eb8bf05ee2c910f3a9eb5fe14e0c354f32e4a740bda45841d8e932f35ccad986e25ce8be8feb51124a474525064aa2a278af6e97b2f17b9143e4428ab5eba032f2233ab96f6a0d585b031c3ced06dad0005058f0e8f9db665c46980b3382d7fc4bd22be4975258f582c40df6ceb5134c0255e271c1507a72b0c3df0bc258c0556382e33d34866cb94b23bc7973107c5e973f6e7f38af2a5f1493dad3610b2495227a4344fd07d49eda8188c7ec612fbd02cb1152cdce08c0b9acfc97bcd2cd246f4ecc6964f49211f97116a82a47797ca1f24714e86b8f622273d70916e70f51a002f6620657d4ed753f997fac723d92aa53ad3787211b1cd37e5790b02b4d1c925dd980b386425edadeda16eb45908c9e2ecd7693e010af8596c23fef65d21c8100c0a663646d341b302ec93a40be276f0da78639ddab66a4cc37b4e50ffb928b78bc096eb93c66c5dba9b09573a781ff2ab838dd93f31a4866ee2afd4ebac9efc09fdede26f105a9e65d43b6b0591776270bcd7c7cf1181714473cec69d160207161d4b260bb64513a627764eced79148a78e2dcc688ed58a7d9dc162c389890abbac953b5640122e40936d160027b7b67628e9ecc8e5ee6ad93aa5b886a66c2c4142cb22daa034a625496ee352f12246420c701f9021887a3754aeba744ad7a7707960cc9beaa625f936373eaafe28ebb27851d4de61ecbbf63a7310b1ee36b9bb84545897a5558ad24a0447b04bcc0f3acc2d37200298f969f6fdea01bd203e89a0f8e6e007aad65b4cad62bf6e5e536236930b38e3de2a36de90aa1376f87b67999cfe6b445d0cc89cdd23c18785a4d2ea8ce206b43a7b9b844d7c2be3086691423abab4d1902e92d227c8bc582747f37082be5cb3fd83f0c7f87c18c8d6ec3489cb85ca364d9c60f94efacb87becac60cbf01efda3a76f4c3de96e5902f8eec13433a804e234a831125b38b895e584a7015a623d0273972d0d0b9a5a9e9aaef885cddf3cd7d4605e73dc996eede97227e83124b68e1537ec49724e286d7be2a02854672f8da3f6f9dd97212a20a1d46287e6cab9fb79164d5de30934039586291b6db2a3c6cbc309870c2b06c41da18a6449e40ea99ad061b7eebdd6159d9b389810b655264d9478b8700b6fc9bbb2f01a35fe8b0159e31d58a6440e1c529bbae5cdb6c5bb6e97b3a75d57a1f80352ac474f2bc2d08e06a9cc1a3c7235e473521c08e1c9c520a5eb84a0c87c9b361967f5b6dc04db2ff35a6c094903f5763b63aa86374496864404fbe85458f06468d06665fa1f8d9b6cea65255fa4b9c7ea7e3047f98ae2aa16bcd8ecd172fdcfab1dd290f62d8477cba34ad6ae814947006b84fc6d11e5ee946d4acbb52d4cac1e977cca19a9536ecb9f67e8fe6e5b796fa87f9691163503ae53f1a197a85f07d4a4c40090335b598944e3fe59419c382411e1adf9388b0861d36ff5d31c61313c4774b6c3b9af9666a0e3031e28aeff3a163e1be42e566a4fdff8ef9167ed00f8261180c66eeacfd3fb09e66505a2719fec3aedb8007e4b5fc7dea65a95798456a1df349f9788490175ab62c686a918fad5027b3f83d2665f5dc1c7fc5e952779294b47a1bdc17b5268581058caf4826bdace2a9cde85f2d49f5e4b7337fe062c6b527ffa25da0cf8084bbb8ade6b50fb6877dd8672572cc8b9f6bc655bd4cabef7416bae36e975b86f05a4d40c09119436f5c76f075977f0a5f6eb76224fbab807f3e4b461b66abcfd0ff0e82359a40d2e6ad602103b6b4d0858d78d3c80ab928a45e5f24e910c1729bba076c3b9dd18946363c84bfa64e0c432a400a82e3f797adec1ee6ecb94ae0eac89b73d3e95ac4908a715e3be60aa2c47229fd83fe6081deaa5bd0d4fafceb5bf68b0e8cc98fa4ea787cce0e30f86cad9eefa10cffc5bdb2fff7411652b32a0c0f4b706325517e491a015861ea0817c801c67aa8aed3081dade5935376c965f4d2b98a10f03d6a32a639eba9633366fabd0627dd9598ca1cba8c74ddda148734fad9f8d4cc135bdc3f83a30c19e54dddae260810500bcd315b672822d39cab4692b9eb20942bebd734f8b859d8213dd0f1e48f7d6d6068f2aa81bd8b3764c31c41d507669beee20df3000e20fd2393ba5aea563ccded70a94e1338ee407a3c37774475a6361d7062bd175ff134076a2ecd4e08b4f1dff77a661442bd3e937ad6ac0eb977c6d81ec081c07f5ff94c38c19c3487213d06b00c0947fe44915266fd5f2b4751ba7bfd910184f930a958468d4b8dea2e195c6b96f32923be22790075ecd77dc9ff3212b6a91dfe29030f974775fff1bcef4fa6bf08e6b6012c7414885ee4a7a73a235df8bdacbd176375355e4e98c9bbd55e363f8e0baaf80ec2ae2b8523e32ee07e0ae5333d878b439abefca222e2dd0e6dd2574a84526efda0f7f081abfdd73b482490ee86d490e2bc983b1fffbdf653401d78198ae6bcdf3ed9f8006ccc3902b431def0aa09257ec608dc94d70175c4b12ec44dd6c51c3a36064813f8987307f7cf5a0dd8e3b783962e4a8177424c5cd16e106fb365cc4e0d06d2e7bee6a94214cef418e6926b371c7cfea3ceabe85d4371e637582875cfe8c77ea4a4701afa861a33fdb61d163c05646b932cca9462db6071ce80add32b52e72add3b0701d48673daa55d706e858ccd6ff9669fa8a2b304075d2af9d2d37b594f87c1808888762981fb2e3cac700c882ab05505fd0abd56fea1642f0357bbd339e2cf93adc2ed0b9cfd0cfe5536c578ac153ae613c039ed78e77b704297d70525c58f021a8184d186ae72fa312373f6c7a007c47f095904b8f96bb434f6424d3d2e7a3d4a5824588c4966a5b2cd484f0ab149024dcafd8e5e5c9a0716ccbfce86604289640b9f0076ac206af4f76ed0ca828cc416bd287cc7ce35fb93dd58dcda0ee8fda33fa03a3908a9e56e60c0c20cf68ecac7fff2c2f7bcf6a8488648171c6d8b76e9d6ff5e9b2d9a4cb8077130cbd73f34c45511202c5dc3e9fba2fd33b8716276c679fcf14bbba743c6f576888d58be7a12f806800c50d181dab4d1f6ef34e64a63007850d6bdb33650486f3d61a10671db03b06dfb955b0e07f6d3a45e355a27f66c88c500f96d2f894c1f3dcbb37190607efa531106bc40e61db4b386b2012f232979ae272bccb3b5c9377f145b7f13ad73d3e97c728f3a050f35b94368ce4a7af65ed51471b188521d98103fb9b385dec8178a8354841afc47c3e59b3230846989ac12b27e536ce9e5a97a6a03a1417e637c06aa79b39a47ab01499bc6fb59c4ef99716a6187401837df1383347c666543c1705d4124a6ed2a8531e8580a72e82652e8351531c3fd72eaf6dd85d1495da75f7343e5d1f3a1b7d2ccefae94ad4e03c4c84d894e06c51aeea425486a4633fc32cfc5d0c04e207c7062a40688c771103ffcfe253f47b503479628d26768087a33f7dbfba8840e6e8eb0a7482242b167ed3db102202d873c4f0818f53a2303202273a90aef4bb913f4c53321b89cac7356a2426068af22cf8d51547cc6aca503c4efe4af2ef65db6581d6a640b2587125565cc007bfaae3a142edb5a54ec4db9331f2982b2798262382351a805ce56fe6e78e06ff3b58532320839babefc20a378148be0da46511a1848698ea1d27b8946538f1ffd98e652a5ae45f6d1582e96014dc78c484cfba8519f11dae1fa947c071da1912bb1b1a355b284b4e01cbc85f79777200f428b4f7878eb4fa51faee07e9344a17315e1213766becc75784342429922fcfbe7231131fa716a519e98a96fed4806559492ceb328dc5a0183c1ab435a60ccfce4a35c0eb7a201479cc35d292fe1c21751e9257822bd35ab48fde84f74654371e90ecde8aefaf198199657a558217394f9c9f7461556cbde99aac17de80031de58f59438dbc54bd4e15912b2f4ffca253fe585dae94701574e8b170d0c9dcd02cff8704a576fa82f6f557cde1159e4cac7b6899106197a70ef49dad6db9b0ece9e5661273d57bbc68d578b5d7e2ae5ce228c92065f6cb5b486eba2857ad800af989c4b63e2f91621bb75eca67ddaf70d6ef2a01ce8e2f823f11e2c9963d2a68b6b2b124b5f04a0da3681fffa5ae6302d0b0c9b990ee1a02f87473789a43c88bc78677d158460be79183f5560cb5e7812a03303f82b8e1e54c171010c1b5a2faa5716033ceb71b97c88594a89412da7805254464bf1c1bd4052e51ba271191edc795f6e44489123907a04af9d7219bfd6889fe64439c096332f4654d0566b9230aebcee473d38431295901a538487a23e29e14ee8bd9adb335f29d2409ed2e08ee0e9882e019bc80a0938f99a90a18bb228e77c12dd68caedb98ee9cb2a37021fa3267e7ca7d47b907eeeb81556a5f9757b1e4dbdc6845e81088054953ac0abea6e0ff9dd27d4215d147743ea07da1ee609d44decc44f87cc70b8b93ac92ba734456b6d36f10fe6111de3a5f102502d0d103a2665e8e0d9058ebd8a191ebe43fdb4bbbd8ee586285b1f66b09ddb8e2f2798d6705bfa988cb7ef1309ebca59bc7c90c4e6ba465528746530d7e2f272c15f7ce4e977ff0c6f9c502f080e44f8033987eda263929bba81655bdea421763335aed425561078d449ed0855f3dccc86af9f437b7ffd13e027f22d90a376cb543a1a2e5fa86db3273ef4275d8acb8c46c2bf9afe2e14dcd3d81ec7304cbb56dfb30d35f03ad4997eeed1db1702670ce7ab633f2e6d129ae2bde87b71d1e716762f7dc3f1b3e121f14b351ea083c3c68cad5feac64a06138942e4a5068c677090a13ff58489a88f44ad159eee8a3e8e3a80ebf7c78475132e69afb2549286eca9156b72a3d7b531c0bc34c4a9204533fb6ded2fc3f66380c2028d8105036750ec5d19c4a2563fda73659df5a714f86cf0941749e35104c9114d91ce749a072cad6a9fa6c2ae98f7d9b105c46ecbb1be88f5356b3589b54290c992c5c3e9d63f6b447ac87d00cfe5b0d7eb21e8646eb104aea94b25a8a1dee2f7e10d4b7f9afe467daefc04e6c73dcf61e0e5435b30d0d938aa61849bb76ac64a8bc6eb2c07693702f2a5c3f40b4e15e07a9ddeddaf29b8b3ca1590870c2862e28407f60c58ce543997bd349926ba5e449d44f644f593d09eba5fc3e8d6d3a1634fa06f768872ffb8b91c52d08ce9e2d0729e3315082833cb76a441eb77aefff2cd07946ee7e9661600a76f50448c0da72555fdb89d00a7a35dba6fb4f23daae7286a25be6afbd0a512e71f1672b962e4d9c1b89f2db5cd1f3c7cb5654a7a7f1adc4b6a3239f2e26e2a089f4120b52f0af442f3ea7dda109a8eb6168baa117ae5d70cc03853bc5c39c908c0032412bf4c20a20ab793357e92b30b5f7d34bef2c4a4ecd0c83614255ba07f93811cf087858c8e43ed9fa2497099e53d81462bbce794abd5e1e279752810529566690e7d89edaab64243b50a4d2154bda7f88ea33cb3bde776eb0b3b0dd2abc71ca3bf2c060bb457a0119a32bec1f5c1dbb968556f882fa0029d084ea6063b906c5fff849baf94d79593fd7c490fc726a87633c0db9ef99d428bfe510f70d5e9de96017c1c292b1229a2b6708c55fd9175abb8c337631ca5aedb22dad586cf474f6cf99d6ccb008106292e5080ddc451061b7321c1c103cbf35cd16552cbb72da479c1cea7df36962a11fc41da80d69aa335c83eabba8ba0cc9e2f21cd7331ca5c30073f9296a59bf223300da2fbab5b4483832f8795e85de1bb6d9c3443291","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
