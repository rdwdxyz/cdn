<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd824037b32a39a988b7d8ca6a937797a07cd56f56bc6544d882c579900e51c33f3837d4025da0b7a81dd0b6817bf8177355121f8875e1b865efc037cfb987dbeff063eb8fc24204047e443cfe2f4a16980d371bde1e0b4cb0b6925ad389eb2c1160b33e34a9582409a46db9bc6efa2658aa6f57dbb49fa063105c30af991a9cb201dd40b1803e9e51d5c2e7e81c9de1db304985cd2563de423135cb4e41ac08c89dc76e5212c2738f79b9cd7a721d3f464674c36c09e2cedb437e351583e555779e6568bb1e6d472fcef0db0fd7b1bf2cb45f3005d85922408f568d052d303c66754f8f611ddbdac01540149820de49c01b1055205bfb28bdd680e60d4c3d08984ca4a022b51a1ea4ab896d74bb978c46e0736864eb88ddc44e6ee6e0924b4d306ba65206fe53857b147d38a8986e2510ef2abd7c7a47d492997b21f915aec503cfa164f8ba382641387b1592d7d604282a89c3f494f024ee59786442deb1fbacab04e8ecbbba99919f9bff4b89944a67efaeff11c47ed05e89a7967ba25fc19b9655c922b672381a1ed0b4092519310b1516c51df455d284749e4495d824329b23aa12fb3d5cc8857fa252298fbe8b1d8818f4dccd51ddc514c1b819ddfcb0dedf577778be346b3403f0fada78b7270b32523a2ee76c66a706d150f3910458133de4f838de2326e46bf48f6534d18801042a38621f79d5f90a072a74c79a8716b23b19ac744a935d0e602bd3c1a6196a36d754ac644b90c66307c3ac764cf051311fb032ba74662baf2f9b8c7945dd518d7ac61bbbf0a598044ee5375a8cd28423ef9a133c7cf5fa8dd8205be13c2db23f5fa4a1686ff9972ed20a7c0ade6bdc0c6d14a603d05bd79c2e463075d9caa89b58002362d41938a12b67526b6f8175f6513bf755cc89a283335eb4b9deb7745c2e15751ddf917b4118aa5f8dbe27b099fd09b4afe87c5dfa000c3b23bd3d42e6ef6e7a820cc9efd078168d542883d962e6bbf351ea77e8fc2d76c7b1a55be6640a6ba4991148dac01081759dd6b12238a766ff18a5c42f523f7cf2814c891f796c08f72073ba04c0c371855e8dcf9c03be980d70fa59d107f5ced3e85980d2d958cef89a28ba5208bd28b04e008672ba8c977ec72a43201d43108fe544045ed658d43b794a71a999d55bb06bcd2b9351961b06858fb67ea54d5a27fcdef1a4ea74a082fd6c9f216865196189399874fac2d1fa4fe039a93482699cae706d7aa63781a9f270c25e516eb19bddf5a14633265ddfe38969b920f63000c6dc759fa64bb5c1e59684937d5da8bc52c6b4580324114ebf8b6076eda17cbc9314a9789770ce01af9596099f6406b19b094815b8f3961ca5797de6d8c671964f497f4b703a840d43eeb4a4b0c3ede8e63c78d8949e473facb36f2f7c87a2a69836f64cc5173311a4aa4bf3c19b49be17f5dd33e606bf39d036f8659fba543b9ee18b53107c64c7a760a74e18728a17fc38f26c9493e0dbfe9168e62a9df8dbdc16bda5f7295c2cbcf50dbbf5d60a4dc0c53e38dc3275337b329aeb3786b2ef290cd1a813a798c80ed199bc134ba4cc48107b7ffe096bb175e5cafbe441702a48df9d581ec82da3dde293c3d1bc79103241bb4177a28a6e01889ca854adfb765fd0d86ba8274b062a305f96fac821f43ec17837a6cbb5e5c7062c0dcce3a79eb8adee123c0368cb2edcd46492784d987123ff54551cb6a612accb24391acd0ea96d362e56e4344368f72ec3471401b07024176e6dfa0bd502ffa8da8d07a5f61b8eb35c640c99eeb06e8e037cf9f12d5d3249fa2b9874660524429a834667b9cfc301f20294f55204702fcb1a12dc34057536922549861a95e332880dfdaa66bd4f47610bab2533f72e1716941569c3f66c76705b5b8402dad80fcd229d99d00bc2f98a157f647cc254433fe56d9df123481e85f84ff496753ec2af7b291f904d06a7b8e78d2c27118530cbb229bd037838c1b874dbed1a39d1d2d5a46862ae074fe77bf997fc4e2063c0f100bc0d564027b27adcb6355c6414843ae32ad94079d954c564e267369f0ac84dcce539d23f853196e32b5cd08929f9b8ccd6dc7a6d762b85538d6f0735306ee3265f6f898ab860561a6b6c0890785c730bb578893a392abe25019b4e0597c2ffb1d9e0f25a1c3b16685f1c649cfa272ce67e809430f702251bf6de715c6cee3102735485d26d1f148ea76f4c47494ffeebe411a43b7fcbccc5a904d4ff890ac7f053f4f3cf6198b7d2d152f95b934fa3ef9460a1abe5a51cd5248fc44a45cb7e29fbad8a4b51338fd209c11cfbe97ea98a887e4e6f9d43b203bf3d0d5f99579c6411b9a69842d96dfb33316b363ea38b1dd60f0d04b389720cb21282e961d1a5cdc1966ac39ee9db6f4d5294a9e1d181330475f0cc55b632359cdfd1ea95dca522f136c775c1fb7dcf23f60c921c0e9a31cc8e9748f52340a378733711884684bfce6b039f3aea1796b2533634acde4be12c0b4f0d10e4a6cda78e5b77ecbc35b136e1c14fb2ade2371f24be6e106cfa55788590937622d3f2a1e89e74400f26fe63bee2ee0360bbfc7ae50861cb085cb743fedb0101892bba44b4f8383be23baa20a6f2b50829475069be74b7e755d862d2a2d851e4dd5fc8a5711c4f0f41729137482d624d1d0583aa929e88c9f4f9d0f90118070cc26978ae8082952a54daa91e8bf2c4c6364afe277b20d04026ef4cd613acb4eb184f6622fecfd666ca23b32e81a98db2989d9430fb79fe9a64e50d1a4de35ee5c5675b275c58517e714c9a4e9a91fe3da5886b70549089199c56a58d05838fb99782d48a01d1b1bec9f8fae45ea2596613e2e8e2c4e630037c22c7d2fb7a8c70988c5710920e24b386b6e58091fecf5490e2f9fd530b73eb1eb98d701c303384956668631ce22b21cd4354b39433943ae070b29bdd6df5f03c36dbce8012f3f4d7a273ad9bcd1404562e048eb0068d03da89110efb3670b833c44c7debee2fc45b9939aa2c49281b0d0f105ee693d0336dfd66a9c6829884594d4c2c38fbfb1329fad1f09b72ba657e052385150170335f4fde89480a89c1ec7a1463c4d15dbcdee84f06f1aa14629438c5b4321e8135f7df76934f0b471650f1f7727acd7f7df36cf65bb780b958ab785c5ec8c20c465fbf32acd6df1caab85e3a629e20902a23b43c2e2494ab056762cfe0d1df065d7ecabc85f118d2e0d5c30b20cf66dd4cae98f2fe65dbe8d43c7a963372a08e56c4e9ee6f2888770e78d7ec85566db7ac3c5a3e01ef4a70bfde0a3d566084026bc7d231adc3f9b2e85518e46a2ffc29bf8656b50606efd480c546aead9ba05d7afa6e66eb7892b253e94eea5a9a1c79f8fb65e1d83f6b8f6354add99c76c8d636035886ab0055e17241fec2d80a187233bbd07b559cbe7113c68eb7ea1339d76d747d80400f22abcaf4efcb2403e44b37a7672f3f6f1d2387f04dd5f3ca98287da276e2e5007384ac27b9ff0166f434681fb6d2f9f9e67080078e44e5d68b4cdf8ad025530570709784a5451334c8db3f8b2406991d47f0f0e154311f3de133cf780e052c41fb37fefe6e7297ebf29786b651329a5772c4df0a53eaa4f6128d08993b6cea4d5abed374c734b2552cdfa26b44503643ff7e3a77db8251c4a556a7713c7d14d2b39ab7c324b59a8b262accdfda08a59c1fc4d957432073096b438b0cf93698272ab21195a7ce7288ec652bfd1b4785cec66d2e99ef3132ec273df1bfcee5fa5b66df025d16737c227e40d694ba41d8f525d731eb67cf04b77a14f20689287ab034438e7c9056d8da5b2327f0c9e54fa30cc358513ed63053a5a35ddd0ca15f04325601d3e5b072e6d3613a62d6bda3116a342e5c73df748d9c6f5330f9cb304bbbd2d48b7aa0ad6099de811dff37092aa095407e1d25be8560864360e2b47555404bfd0bbfe31fd8cfec529f09f1e2c6a095205bc7c37414fde90abe357d859c08c4e195e27cff780b57674481f190eaf24516168bb90bab2c494b7db9ff02f152f13d3571e4543ada765c9d24d010b1d2dbdbcd5eb09f01b0665ee3bf803f2e3ae4798ad4b81e35d1bdb9122aecb5354ab0ca36007438448428edc30d0d23ac65afaac3ee3c0016b4d91f12595f977aef75e435f256000ff2263e08738d13648af9f2cf1dd07cdafa29f1bf713ca001050431c1b84b62d1c2a001c990c0539a76371203c4379d20151faf12e312a3c95b6c4c92f863dda3a10bd4025dd7ded90c9ece6a6704271fa628f4848ea58053aa575ec075cc0f07e3d3003029fc15e3d84c607e5bf651b13fc4b14110766bfe305e5f8da48e1d2a40cd824bc3337899699bbebb3d164a97217debcee3bdbe14763263470d52f089e18e3e56799c5f580629a2e1e61e8e448d58b95035d5ef7fbc3e8ea70f1ffa84e4429f451c4c6bbbaa6415dc23125e0ff411b5106cb0ba3db01118bc30d1936084d8b1c5355f7267a896c87415ec87af9dec462a46d374a6f3f1a11d5ea7555ac7ab478eea33a4f9a6086fe3917a295370987a85b540280bfe83a5348d85786465fa84a726ff576dfe1421430b37bc9cfd4bead1df770dd3b66d5033d1114360047f0564954cbc71f3237741f36d6b00908e64407273c36422dc074a11c429d70def191209918d87b77002688bc8274ff19a73dff38294a4d8e724b31dd8b46155817513a79fa4a7c2639a637aa9d813a2579ab2840cc23bd0499d7443939bd974edc201fa1fa7359aa390cf2ca1a1d2b49199ea76975bc3628024bc55c4fcc84b1413f9521e5bc3b22a701457d92d5db8f33aeea6be9b5378e008ff9dd20327391d5b82f7e193ac6b091c0337f61cfc98d86b3cef0bd52633d06f58660cd4a23ed40a054236ff9474ba8aea253d3ab35817de0204757ae85cc945cab023f71ecb015d32d8cfc3ff5d3d940118fc8c1dbae6f198e148b36c12638d0ce69555930b2dd3f1c079be53ccf4e1750e4f8231289324d07b560b3f51fb565f3a39149ecbe23caac15e74102c034d79f047b786bce3006f2652ae0c0e4cdec966b4543f063e17da13ae81c888c47a4c4a12e3ec57542c67909800513e037ad55ab8ffd4dbdf25aeb2f89b6f11d19cd95178e06a08610e3cd1819acbf7a0a7f77a2a544da5cc2498e9e635342bb6adc803e0a02e7cf4bd24200fbff0ef07363e8e635fb383de70da14ea1ae690f7bce12a9fdb1ea85e93720ce8165a826df639fce383d055baa468ec1f16d29678251af4e24d9941f098590aab6360c6421a4126b07bb82aa3d74ffb93c52315889617d91f009cfe886903b8037ba687249af813930dc630f5df71bcc71fc02fa3b8694e6054d1c8dbbde8b3703be83ad8fe751cc1d1ece5b2c8002c4ceda6f5679e173a4987942a29e34f0df57c25785052072e28af36f12e1ff6bdf9e55e90f936f159af62e859869c689b2e554fbf6ed8e239e97c20383408eff43a56427f9b0ad09c0ebc3a0005e4369e7bc4adcf7720e9595adc788c9cff16a93d13a6bc6ef1271288e0ba3fedd50dbfeea78518e47e60138aacde31b26963f9dd62c111b44ef0be30d4f9ffda92b329484fbad61d957ae1c6ee8caab411ab4a40c68519d89a612211f0d3643799746afd4e150fed302546a60bef57e4aca99e2dc51b1eebce3ba1907fe245abe1c0c0a1c913450933f2a04a4aedf765c105eefde3f969ac761f19e2e66fc7c6e33e75107ddfe19e32824ad7bb8c35a8dc9ff46039e2d30159e7608d326bf2c01af2700a43037b046bfb9d2524b10f534585d88a6ecbdfe53db5f6d03dba2ad3f75e1c63c54103b07c31d3b9778d442676116cb41597b43fee7f118c113179ba3eb9664fcffbae29c0b92fc233c5f1068c5c1429d16291b21c09a6f72ad15a6f2389762e44d66e81d5116b1d6722199359c7f08f63f59afbe286ddf36291439383cd7e0e81f3f835cc5b700d7b0b6fc3fe6e0b6140dc85a40d834ed99ab57d305cf1c7ca65fc206b742cd4c48bb56a830f7d334fe5720db5341785711de2bdb9f168d9fab2d693d9f00c0cb41a942d45c6acb52ddcf5caaa8de3152f7e3434bc1f43e9a09e7894d327a4cc251c12023dbffb6c82d013b26671c85b07e704e1e80cc24a33a46c7a1b69704729b81ba2076c422f0e3e9e6b9473dfdf1533ce57c5468198e30bf751e503992ee64bfab872df422f5a4cc55c9f31898e504b25f03eb5ad2fccc1a9ac37f29dacd66753dd2eea264971464a954d2252cd5351ce1ea4c5f154fe116b2ea19f1a9847904ad06e5d343d74128788504f20bb751d487ab9c0a8a725566e3ddced70d15432e8bd2003ff2af78ec6df8fcaa85b18ef207d25c8624d9ddf9bbb779880e4b6fb7eeecf57f3eb23aeab27e1c1d22af13f778dae7d3c0f6f1bbdbd3dad09cd9d9cf14294ee968b872d908be9b83c205fda2f59c49329493c6fab2eb27651092ecdb3054dc4dc9a2115ea779001abcbfc503b2d0e2f5cedcdef7dad909cd63f855a95791b18727e53ea5bdcdf85967d5a441e8c9fbcc549d5af44c07854df5ecbdd2f0339565d9c9a5f67dd29bf9ee6e30e3dbb7ecff92265a2daf1c92da4a6dc1c755493d4e27c593145254b57a414c756f5d408f65ff6f36e8ed194c10c1e9a8e0344dc62bc9be50fc3e058cf4b36eda1c516767eedfdf2d94957e01ede3d414fc0845972461f220d25ba815772b0fc431dcfbe7e4a2a021b616c471839b82246ac9bee47b829e6a7e8e44035bf7166d4cdb2bb5f525b362c42971880d39253adb0aaf4f323b8782faeeaa4e7a7aa211330ad613c89b5068e0a188e1b30d084ca3c99d71b651585b9815a99b658bf8bf02e27bc9bf63f9b9025cfc469e6e06a4ec46ebdf0915f2f3867f49669e33a6526c634298362a3b2b8cded550090065529aeb071d189fda9cc79bd96112b69dbf32cc5934330e405ff87151817363c62aa6cc3b1eaf3ac78598e0273bdc94ad1a173f6761ca6ae76ff48d47c1538f4af1a8a6fb04e5b3db118adbece6c7e4e3aa0d1b2230342ec185774d4cb710a3ea8c99fd020f1f15ffad3ecd47ce3657f44c5a0e1c17d19b857db0f8d0ca8fe28a624d1c894c7de01676ce78598fb30f6710a47a6e83b4ff5f8686cc84eeb9a3aa9718c031cb588317ddf7457bd2fdb081e32fbdb3fed9e96cb3a1b3e1029e1af37e6bfcf0ff0e62b69b9e70e98679967a02765fc0992f4219a5fa04dfa83f4c706a404dd69314b4fb64a1c82c410d62eb0d00e292ac9330fd111ef961edeb13a47472bc02b91a83cf1e34c9bcd3b2c5b9ad51bd55922988c326bfb45541c53536638d99a45cbf3a8da289937c560bdf91e5b21e1559beb0015cb76e268179be0e54586d2281bf7dc80a76e69d4e60584affa547dd5a275bb0a92b04d156d31e802d20e1e3e5e4111f11a8a677e403590fdc817c32537be061084a32ded40039f6e25289f2d3a0306976a282f3caa68194ecdc178056af8028e08a1409b025d92deab12e32b6bfc397acbf79141e96d7c4acd152a0a252f496d46cb74a1b43fb9408746fb90770d873c3ac777993002a89caf878c8305258ae6e619ea6b7ee0b1f78704acb0d9dee5d5e151590f5fc0a3afb626c934617cfca593b4d7c0ba04cbc34b355d2922134456d0055d34db6b090f886bfb63dc27b36ddb42a32744505d55acc7d80c91a19b9e5af33fecdb1f67faa952230b03702926535a36438132c7db3ef313752dfdcb71d7afdc0abb7526c00c169de39d85254f1f8ed50def94d12bab6bdefc0e44ec955b5b5cf4137059dc37442599c55dc801c73632269ceaffe8799170bd4ae4c683b2d70cf25d0c347f1d5038a5d8a634023cd37d005ef58a1c942b33ff5cffb3df837c2b20581dde396548ddbc0abded4fb01a55e8b3a3e9891ea194d86a1ac13ba567f27f627aa2bf6298bae10a763b202727ebe26ec86069fb139f44b7b24f2856ffbd24a4650c741cf461fc345ec66dd5dde919d6e79e9241c13fc6b017cce33ece472b3e4af087bcfe0ac70b032af71ab909276d93f3336179249b09748da3399c0e26c9c1d8809f6aa4fb61537bbcb4ad44ebaba57a9804b9655d27d8212c470ba77ee278036d5d03f567099eaf6636cb44a44ba569a9f4ba2d4bd8fdbe11537a5893d373d43721bc48df7a4f3d47b7eaa5b6f8780cb04d7b7ae299c251fe5363fc5d496b1ef222e4ed74314710fd0e9837a41a05a1f054c72db4997727ea2a8578cfe803cb313bcc50a5860fcfe30d8c6ec182dbdcac5d7da86259fc67cc26a0613cfb60a56c056cfd13e1c7f2bd696d1fae77a5200120fe9d43f0930da2ac43a13d473e5c200cfd8a8c3718a10034a2480b908dcd232bd6480dadb0c6b8acca32df14fbfea8c48d7f7508a7828a7edf599a9cde329c0e42f8d10ea417f2dd9cb14237d173e0f46f0364865585381336e172fa0caeb177b05803a64f59644620800b0c47e76592c1217bde835d39d0a5ee8af3cd5051d7f94f9f8fbb7c09b6663facbc2a48a7530e02e5a93d48924596a26b7ce463b9af2576ac7e0ce08bb7c3bb9de501c4b8cf579a795767037263e330a8de01d1e32d1ff5241a60a8b7e8b801e7dc39a5316297b2783831ac6e4e1f84be15e13b6d68314429e1084e0210de5e457e6593c96867ec20c9f94e5227ea45302ec970102edaf40f0fa93e68da8ba22d947b7fcc8648ba4b50f3ccff4fb86fb4bf08f0257660bcc90ece1795b62836a91386e022ac624bd9df97bd44752e7e5f3018486476646b423df5a8374c0216958bf25a0e7431c647aba597a01d3d9e48433c55dc109c1436cc6bdba57657c95903ab5ae88db8bf9856a9e8bd391d4d69ef9b6e8108a5a8172a14161dba0b2d55f2853baef5a778c420f14b8acdaad689d2a77296f857ddf604d90cd42cc8bfd6d44a2115e46e76f56de53d168a0eac53c0400271f8c73821853c9292ef548c342a644f917a1479ad4a5b0dd9397c5a33bea767ea2406d14cc282e9420482083c3f3ebe20317dd6d65c4d54765087554f949d1db874b5d39a28679d04b89b066737abdd743a425ff118e13bd5a5227ce2acbbacefe221032e011b07ae8e18797887b415ee06206ac1906220f5047d9fc419bb5d8b3f19f18090a430ce1860f6dbecf7e06eca6c645455db4bcbe0cc098d003825fe4ff12bff6eed4ef35e28b2625c9cba9dd406c99040b80215630eb99eeda66d106426f28a7236a99cd5f44bc695fb374bb37ede19e543da6dce988bc1a63f11d07bc5b71c65e74b725501d351e0ee544b645d09068ef672e8acb8aaa5c324d43dab8ae9a776dcd36d9ef28d91186d43efffd1c0c07a296837af7095e8dfb6d35db38861344a57fa9aff54b063c6542f27457724836fe8d146ea632ac3518c147c798e130f9b760442ab7d5185c85a521aac0e27a3af8badafaa37c2e0fc18cd916253f73da7e1b17e0518a6ab9a001014747424e963477da242424170c096597105c38c0118ca1c6518a4ce6308fd4c229df2d7b87381fe3557e874ee211feaa4b377bb0dea35cfbd9f0fdf2ec346bf1fb021e027dd9f263dcc20755b932759ef22afc4bd60f365286b7f61eac56d158b825c23a7011cfa6334c68d59f7de920ad9a9a91707ff20aa206e9e551740b3b71a6c63d368b13d1cf3a0b95074729ca34b9d2beffd82f12dddfde2cdd99bc314f0844c96ac128f56f6abf443e5a38f08cf3f6873bf5aa38df591e81594f709e9476d50e2c06464ffabe889e5e59f66dfe5307b94a62031d80b82f2a85f1c42599054ba90465154a711d39f8fef80569d980d72e94d099a7ea1a1c2e6779ca9f685fc3de1712fef98d2844de096248dbd5480049906bd4ae4ea5a419e27610f8c6e14644daa775aedf3764ad7886f1a9be0e281d06694c9eb0c72f5b0603fbfdd88cf6d0703a1878238f85454348b92c76c3d0773980a217b3bcaf04ff1059aff4e20978fce27f39ceb84ab1a6892b1a2e4986985a3b9c4b0f85d25499efa5a60c1ee8b73da7902badf5b8bf2f481a272b4931e85a70ba0a616a4c2f9c6c69e8f68f6de248076de5b1bf3c33fa58953b5a535b5872f18dc38a845396b3494d3b2363e18f839078698608c76a432ab4605982dfacbd391ca329d94966d12b259e5774a12b2e2c9e79062c82b3fd2973a67ef9f5bd4da9bed17439fd32e8fb22a56c2453e0f946a3eff224d0a1c21af912ae60283eafac1c67ed5ed077f43dcdaac431937d79d07f49da7bb3603c2e1e1670e3635b458569bb862c555d1b0379b0a837a32c42f113deeab26a4270782153c2e73f6667fe705f0590e2c24cb73b705263dd3d540647ad9004ff270fe852caf4110d8b77b6055e5444e04f89b69a5609999ddcb1e9840de68a4f2655264ee446470ec8fd1ad39ef1d2ff63943b53c23fc042a443d4741b67380562fbd275bc6bfb77db56917b2160a8afe6eb08d3b481b5fdf963da75391a20fec1fc71f93008e3df81c8eb55a51781c0bec74b6fb5bfbcb1522bea94cb88c48d4ed933bed4d1786703df9f6373635980e147e4ff9c32525e21d4410dfd4eb5119ecaa3e2a64d78206730fe8ecdc33503369662f31cd0f938903cc4e726d359496e89cd272a44de677c906c3b517ba5fc5c9cfd5b76ffd6d5ba7ffec3032c2db352626c425a2c3077bad477d42b603d15d7e382300cef7fef76c96e7feff063949bdd6620c14a28a9a13d67d374e265a9d18a5435f3c9eacae50a29dbd55aceadd3232a476bd2f7ee989118547646895e34c67a9d36ab9c800aa34ba18cf81d829ffdfafd34b4fc5beaecec028a3e78dd4cd9c205bce5ed77d7351d1813cd9b94ca34116337c4fc3658b5f3eb6b1dbbde0ddfecd660b5976113f31887f5daeccddbdce7aae9f21de9b9d35381983b46e46dbbc61883c93f2a74d79053f4fc0a4228b5831776126a78292f018f8e0e2d8ee7340f8e31e709bff70a0384c71c43dfe1e0b2fcc53fa929a4bd37a5b7a1887f9a1f52ff5c13954463e7cfd65872e8ec463b38e7bf4bd254bf463ab7795cb77848190ad4ff9bff2b382f65b4c58436235e1adae1cc28e15cf3b330a88787c727f2e45406d3f89cffca326a52ecd488232fcb1187f91575fb74c1841d9f02ca384a00c210f3bea997296f79de20b22bc69cb5c80d0823b7f2a5826f674e69282b2781ca0fa489f45d9ebb7bdbf715fa753ef4222c585bc2aaa27ac32437b4df0f925d0a089552edbe435fb66b50653f9c9c7e366b7612999b636c455bd880f997f5eca5a9f7cf1f062af07aee152104001bb143a73a236abcc135c1596f7991819e1b07dd949962d1e5a1d16676e12fe29d736e12e5c196802a489de315d5dea87ea33253b3005e501426aa6771fc4255e32782e032b1d4e111f3351d3835ebf6a16b4bb73635b09d9f3549ce28b018afeb920df4776ecb14a74c5fceb60840dc097a518e6dd6329148ff2b332c598b11e18e0e2fa036f38adbb89875dc41cfc2da16cc8fd7988098c215615902fecb2b3c2124c26c619ae220b62c1740c9fdb8d9b5353c0f8014408a0e46984a01b97f31381eb08502b1ecd20d0611c69617a8880b73cf35892ab07168a0604d7a90d447dafbc132f80ceeca707c82f507bc948515ee36215d8406b93e931b7d1eff31598bfebdec4bfc87c2d29a590ab79365f31a485df3267eedb0549dc50101cc4891d38b65bd718b4a79aeefa9ee2e95f90453f3a7cf8cfef8d124a0ea002e7beeb55e3e0eccb053d6c960e0329356e8f9468d2f522ed025ecf549054daa7286ba9ea238ad4d50e437bcafbb06e7164be10274b20290fed0d3dfc179b490ae9187c8f6d759b3a29c5712655c79994ce2acd8218b7a06a07237dcc7735b279722dd84f17224db27dec1113d2ac204226d29c1e0e61247c4f4e30b3c568306ea33b3449f9ae573cf3e2b0bec60fe618abf6d0d23521354ff16074dd8c6d4360c6d3dbd1ca4a0ac044e160667eb8cc3dfc947eedade86a793692f75eb73b323d2d261562cd16a32304765af96c1ec1593613c531c49abb84b24ec8098b3a1664339c427500d8fae475fca525ccd165d666deb5306ea775c2101cd340f0b29d40ad6b18dc5942c83d7a0349bf4e9756b6ca6e3e128c7b6aa83bd7984a5a3011a57634d80dabeb370b23178ee8803c9f845f9b1580539584fb6d78b0343a025c77ffab1cad46655cc3ea9d3d7bfdf601ae8e5b49161087e210c698d43b114d351e391f9139fd1fbd9165aca07b1573a83367536dcfeed087272160efa108008d5e201b100888f0524c1a27bc9efbfff8ea68d5de42b60029f35f500463a2f86dafa8b5775850aa55883f8b3f5b45a7f751db500c1a29f5df51a6d59d5c4b26b7f9afdb54d7145dca37ffe0152286606b5081e85d7597f03826c231f36eed28b4611bce42467432ef954aa03c2973d8cd471d293079dfff27956a33ace49ee3c4fd70ea387de7a1c78abc9051584441bdeb23dcb687433dbeac9bfbe686ead47ccd706b426c5a4a2602af49a7c4ced8ee15accfd1e2ce342829d0b4176f63ef2741e8ed853892061cbe05782b10026452a6dbfc8c865bba68a530037b8b8aae38553e501321ac84cc900408e8fa81ec0a4bc48f9ef8c4b5cc16a70f78ce270d04477bc209419947e153f339e4cb400f9ba7d8dc6ce92889de37e4a066546165bfd99ca4d2ff758ed37530491e4982b032d6a5831a60ae85b7e4204fad855a15632b9f039a294b142ecd860d22c894f5b062b5acb07a13698bde1f3c2ed99bd800941e12e2d8f14fd3b0c8c857cd54b83c53d338b8ea23f4b0ecbeddfd4554f006388416f30412a5501cab7115fc118aa3315e7eed8309c8a7442e4bc5935b1d134660d2df162098cf3eaf047cdcc9b1593d0634f68eefb5afd235dd8c0df75cf31e4f28cac343e91bc71edbabd21102dfdb6e8b16bc48738c062871d901d20f8aea555ea9a9fbb58a2bf5fefc0ec082815386e3deb863f4c8f7128257196a894d823cee6447d81514292358212bb232e23dc81b2d940c0bc31082e21afe8190ac765ff0eb9a1e829839007ade039e77df34a121447c53b01d5b2d3491a8ea30ed75f95a9c442d8e03d8d19248e4f37102bf63886f7d0ac6f95f85571151232026f8ada95f032a9cf39b74f0d02b487ab221eaa830e6ec3a4d16cf44dbeb6ee46f197579484ab353502af28e2e23dee61b0ebe1481c47e0b261988b94145859ca4faf482ec8a723129167de26f3ff32bdb09b5561eaf917bdd49b8466085686533b19209ef45c0e5229a05a91d3945e1702bdbe420763c865b9a718549f830de210013cf868d023e421e02db2d43f1234f78a3cc605f959a95532b306da4f2b2bf147eda3d7616256cd20878619601d68b94cee33f18137ac05722f7d6231fc748ef8efc9075dee1beda906785d550da1afccc12a8c5210bb77f3f38949eaaa8ce0002d217f0c0c604c8ca6e850cecd68f59b9005f86f6a721dc3ca801360b606aec9b20f1b68614b6795d927e84fbcc44afb6004b627491ca59ae0a95439f874fa6256aafe9dd6b41454f215e0a4fb55d01ef2774285e312e6367386fbf9427f812cc2231d1cfa8ce4093d75a480084699b2da4d8f76cc87b4c9f56d7bab27ab016697fd1c7b2c0b7942994a90c13ef90ac9801c81db54a568cf22b4f96e6913b5f44314e7cbd7c8c5f18a04874312bbc5c120275dd34ca9e901536933ee9172cfed59102f5e91103ecb516ffcb66dd6ba3ab733cfa6a790dd8ce176dcd09ed1969f27d24d4aa386ed4feaaa30402678969ce2d7bc000f0f8b97777c8d46b4e02d9ec464731bcbd3abb71f5058e40f4e718fea79a44623bd721897d6e19f422ccc36bd372b12cbaee236f774eb1b46e2e5a672a043a188a75d7541044fa8cc6726624f643060e277b05ebf818cfdca8e9370a6ca8ba0848d985ec516b52e6845145a9fddde9d990d03d230cd296662d7e95a858792878450b1ea9a99aa5aad83e5b9025291d2b87ed3da64fdb961cc52547e1b9fa37298a411a14697e061de88e1722b4dc579b0988962c0c04ccd5b98217528f1fd475d126fff1a47871d302ec67de36f90f13aa83b37098d42e903d519eb3d90724473918b0fac1dbce726ae9dc2c0ba6dd30f33bf6850ae9d5e11a117a6b6a5f82502957ac7d2dc8390f5b9404ac3415f3ed5e3af5e85794a793bbcf129508e921c07f3f0ff679d5c3812213ebed4eb96125deaeaf39b0e90db35d1dd5cb855a7eb8d5a7f1d80fd0fc02423257732c1ad0423e7bed83b390a4dac3023450e428a7e6b18d5a8da9c490d7ef94ffcf6b3d1a9765ce059c78b91590ab681b1098939b370f0693634fe9c15eec0e51df760d0e5c03e6b6051847f39eb6165f3410e2c324c76c5863bb6dd6d32e3972004de4d5dd2459204e83c82835b0e0d2bb9c07b5d20c1f902f5f8e7e2fc08a444c12d1aeb20851dbe23a0b326858d7abe6708ca6ec66de209b57b2e62abd38fab25190a5ad91e0d95e6ec63b734f40a1b77d382695be83bf367d1006aa0fa37721fe16a32da80988072b630abbf3a502fc9faa21bf378e66c1975c017c4769507d2100526fb0888e23a7b3e9f0b8c8a5199a0c8b26c9b095fd2036c3ba39b89b732a46381254ed1a84b40c74b6f143f292d5f9c2f0cbfcb027c8c6992d907cc3a29a6ab3a5d49e1a0e673c58ad1b142290feb7a7dbeffea26581566f0402bf278a409864d721e148fd08bfe218138e8502fd8dd7a64798e905544d6bdf77ac7f13965bfc339dc6ced17f1f3707bdec8af230ea1d2f3bce17d7d587b69eeba864c96ed1d4a0d0de07f8164f2c03b057cf16f20db935ffb44831242d08a8459686076ebceea9c0a7536510ac835c33115154b39c7eafef0070d07662c6561596341b569e4a1618c2cd77bea361acdbe591f9a890d3117316934489c83a4ecc5bbe6c0174ac74c25464c04b0513c398f170aae076fed890482fb9f85c1e32c338896a4a4b9881c65bb80d180e608658f732336e73b86cd52f1c42fc35bf722c7a63532f29c7f574f61fcb7debc511ce73f6e785f293d5427b30303ca86e87c377b482d73de235f28420994337723dba62ae1aaa14c7adaf116aa6d532568dc1616e9df0c188c4f0c862ff3f3062adb741fa9110357c7a606ad45a360d5b9459a092062ac993acf67b26a89ca432a6f07a67545c8f2fbbf08d82a789bb0754dce884ebd8b3129d447cbb9216bc1dab65ff026b4c3ac0b15e3b3eddb4b6e28edacd8016e775241661efbce159369f7fbaaf289d9d20fa8618e94cfbef4ae016e0a5a9ce84cbb8de00026f9605552459695957dfa1445ea9e2207e3c7c269f5d63067d76127de9199699313510258bc05f176651f384507609bd5e7cf501c34c8541aa2d500759dea30140fafcc3f8311f015beb394b16c2d9d5c578a4971a774b5299b95f84390e70fd69ebdc77666fa62cedd49ad35f5501990146bf473f8576fd5c3c398b42e79ddd007b55610c783c3b701b17e34d9a4b8bd7a3062dc6efc590a2d4745e3c9b3f1c0857b122993d60b8421f89b0c31a39d4a52bc77b8c892353a1a67a2bdac57d4599490f196d1b65bf8f0c67a8e69ddc9279c8c97383b73a227d434fa6abc6d9457649040829fea0d87903ac4cbbca81ad7549085aaba8fd910dc1b7c8766bb4d4810de6c54813daae33905761d85b12d98cc36ed3b27298e2f48b094755603f36515c79669bf1f998b726188d66ec8654910786c27b4130145e20544d00b8939f705bbfbedf6c027e43ec9f69f1b9643893d269378b2df61d7c0fff70694742a6982061f7c6277a58173b2207e6db7f6648019b7102fc121512324773ed6848bd8e67e72a719a8ca3e1c460f689f23619d0b0326f72c7029b336c3cfe53349b1e2db5af1bee2bd1b3640b6547806d11041dd8bd9ee1a5307141641cdeced6cb595bf67858bd62c870ff4177e366203551413b299f935c7d9eb0a6fc364d8e00949f2533db8d1ef3ff29498b82b5c4cb0ce2b35b4644e12e8de901ba9eb5a0902021318af227f29c26b0d5b2e23c2e485d0cdf17692d2d9477b068dfe540e6a9ea1683434ea3a36c10f0a68e1e561097297d28163edd0941540c9a50bdb0e16bc7b372eb88b4c5e3445dbf484c46ce9cd9b6c6ef2e2bb325231b8dbe09cba40faaffa4c24ff2313d3556e5c5d0f952ac74768ef58dc8a47971142c3b22f5097ccff0d0c6634d5f7afbd8a1cf44c9e884a06a6f1426e17d2bd62d18c783d95fafcbba04c5e8ffef059a4505ea8c9adead5917720db0b3c8336aaf87055857e92e9615f3c2118d89b5d434076fc6924bfc5b5f0f29782d473d00c86c9aaf466e87f92b5774d235b9c996dd7d6ef878e980dcd9e3e09aa795f52ec888c63e87eb5b6a51f08cb8f663cad888724775bb7bc6409885c72dbf126f1b3b587feaebeba0c1f646e9577932573aa2a61091c6d9fe31e610a38e6939d7eb0ecd7808c1817b0e23fb6fe3cd96ec03b538aae3cacd2f214741ceecf52087e6dd0d4232a0b1a8376407e4855da656dbfeecc80666d302c2b56ab51bc12c20db6f062b0e82063064560ffca6b8466b1f66eb1776383612c507913146d8039333aa2efc3510e06eca59fd4d9bd726d882b48a08c8d7c1827ecf85ca741069e5d51bea65f9d2c053da0a4199ee4e166f13b78de60860ecc264d2b8bd5bbe3dab80e13e59868e99a6496c263f124dac24b4141b8709ed0fcbb5d843bbf5f3d5a8ea3c3d59818abf42b463188aececd9ed05906abf787e167cc6ed066198db682faef0f4713b06e4910546f004df992dad3eb98094ee79ed01016726b9890057d9ceb16d836d07fd8a10b553479368c04e4b9269b921dd6213af0956cc10b82cedd510043362fae0d417cf7941782bf55f50d0e591a6e1fcb35b8e7bb485540ff7fdde27823eb38bc079c8ff3d37fc444b6e6971051e4140b8611a950b99e49878aad023de89e4fe5e76e3314afdf34a0fba8ac9304c9a5617beb5476aa9943f6e42966551d6345812e6e308397ca1fa5dfe6e6bec23a3825159b2cf3de0f5a509d20c7cd5fc66e856556cbedff7fe546e85e41af43aa1fd7fd69355e6f70f8f98da9f00d4eacfb30ef2984f5752f40c6c085d3d0c5fcbe05f2cd33505e855cfc6532592504c191eb770a6e010a9d89a0f439daba6d36543841e72d8d79822ba91dbde20d91a9d1db987c5aab9d2e3205c09140ec0751bc3db3dda8fdd599d0569170d57fae875f6720bf529cb3ae7a529b0f219c19bf5b6a8f71b247db8095eab4bcd45774929aabf3b4d97625a6b3638735856d14f6132843663dc0a3f2d54c6665b79c10391f85b3629bad04b92e0aa13e9fbe8e41af87bd33316b007d9253354ff8ce135570fdbda0a3b9493aa608323da155f84f18045a6523450febe0ad09e7313221848c46cb5d1b69cf2a1bc1314c0ec4aff3030ca7073fc66fcc1daca283ab7fccbc86f6d40da49f9e893cdf05a9f2e60a767ab526f3e24985b3c17093280f42eda03ba9a18f9ac1ab7701a64c014d774b91696886a0249afe6054c49560b1208bb4ec1518c6a7461f81f438afdc47a8302cdda3069d0f66457288907b08eab5de7c048a77fa18969d6b5f8ff611dd77c925f59554add607b8407d5527e57c1f63a960cc6160d08c47abf724a7f47a41c4ace659525692f6897aeca96d90330fe064bcc989bbf388eae35436b6e4c0a0e25a5ad026f69576a8e8b36b6032c18c47f4447450a723106eb6c445db3d8752d351a397cc53dc31b1172456d87f97e6d6798bd731acd5868508b7496c38b89151eadc25cb4d03e251fde6ffb2321b6f257b61a36dd0a4d639b9eceec8a0b5ae99fea2bea3bf0798fa69c179d70598e5308c9e778b31a4f49d587d3dea1f289bd7813adf0d545b56a2a76911bd33f47bf6e66af1437c6df03986d95d5c8b2e1ace02fff881e940f21af077e4481f70d734041435d371b2ec410456e92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
