<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0a5b13a012ec0485394ee4280383e784ed56cbe61c078f755573c5be61415ff3432c5de1f7a47f5541acc6303821010381cceb85b02b010cc8157525407b5b31c9a779beece0869d530566228b8a19f578cc6df3d7431a360c246e5c08e4d54dab3e6c6d14edd9636417fc561c4247edda4710c5c3608cf4d463393d2d09d227ce5e909f59d269ecd740042394f52f0c82d0f16882388ba1fc9210f1ba1411a5eaa019d5f0e16807c6ad2a6b4414c586db057fff8f211d8a8b08bf8d6bed412b2d419fe77c8d93ff2923a80c0a8b941956be6df963bb845df68228905fb5f8ab374556f06dea87068dd0adde23079bb2848b73f1ea8f305da0947eba3c4bee25b7b960d5bf3c48e0730ee0c35b449960533a330dde82b385ce20b22d9253c2905d47803e7bca45b73590ec7c130ebc5d8d3748331a1200e15cf1196fda52b23e7f08885c80e63387e22412096cd2c1c1b9c285e36636134cccce0dced3e0060d4e94bdce4c3d44ec1d8c431ca1bb1e9578cba0a509848a233936a0bd94eb98d0077abb69a27267d51b517680a68f46d71d2379a7acc90206e686f5b4f168db3608f25d785b8ba38e30c24b957592bcfe29e2b0a5a199e11311ac08ce703ad1230cfbb59fe803f098c79970359207874e7961644c23d42d662cd2af4cbf61097fed732f526131031c74646565afd8a9e443da4abe3b569af03531b1259cd2e01f1c4180be34e3fb9ad2a7498906754cbb910125b5cd3f5d19cd094da4271172c0801ce3746ad622f71d971778741918758394dd942557155d734141318247093a29101d1e1edac3fe732a0b334e100fda4873c2c5486d387045ef4d265b60cb6ba6af47c9666a9cd4d4ca12ad7c00f68de94331c3e23d786eb6161417fc797633c5d1cd01d87f1282caa042d92601d528e4dab5cb06ca518979196f9dcea22b560c530ae44a169c58ce9e5306772b36facdd449d56729606244887f0b069531d161f0d3b282785f40dfa0daeaea58617dd6a2b4ac438cb4e8dae10b85afeae6b9fceb9cfd1b908d16fe82b11f35d7fc4d720041e99c4ca23b066e47199c555b5d593fc4cec5669a4531fb88418276a41bfa5cdacc1c4163f184ee36503acbe829f4a3bcd0f6a3344987012ec473d70ee3a707240e45025d98e88a14c4be8b6f803164c519e31f33dac6450857095eaa2e84ed3743adccf0fdf599caea583e1681ec72f622882d2d1e8318ca2dc16a5df520da7e8d0d1e047311cfc427fb3f962270f6c30382d8d1e61b63751fd1422ac88573862d33310c7360a36033b7f44b456f6dd5b23a90718d3f4d9465e6c16b459a8262e4f4f43f86ec90a91f335b5d30e178571baa6328273a60ff2cead95984fb3079325fa2679b9fbee733bafd7803dafed2ed14b0496edde1c7a48957e8e224cdd840aaad5d0f674db6df11e8969b072d583c9b1173f6041dab0ccc8f6dfeeb85e97a694d8096b3f3ccfa6771daad85cc3f5e4136e3c2084fd59e9f06f75df9942e3afac6b8fd7441f0dc2877d609c360b3ad6e281d1b9ed782d43f33aba78b4f9ebc22ac7306c51977a7d1643e1d442f6465a1b860cd27185ddacb4b63d23d6ee6c9193a136ec2e2f7b9c9547326f4456f21c571c2d4743866764d5fbdf5044330d384317aba5ddb5f181c538b858072513e5d48c99077fbfab3b876c413a30dedc8180814e7b4fa488d88dc72f7f4e97d333d561b6250d56d886daff96fc5bc0f072382379e444421e9428f2e9b747f8df9949ecefea06d351c3ff6900ab41d0c816426b24abf4cb8ce293dae6e1f0d7e55319c7d863b263429a1118a4fdc3098440315d57df93f241c7c919dc29500bc60904ddd0e620653fcdd57a6d9a48601e3513ce59ea58e58f10402f55264a3db5864fd18fb29d3cbd1b4f0b539eb0e4e2a77c394a24b87b39247fa665e2f4f2b954843c55a98a1e2b764825d0c09ad8675b1d101586c1e641a378be855c297943745c57dea87c1c8f3bc2f7edb0122b7023b137016b293fd3dd1adf2b360bca9d105fb5735248f9503272c0e7f3748451b677c2d35c0fdc45de597b9b21706da395a27eac83f61f22a8d25d9bc287ab3753774b7bb092d2b35c7190205598219d6678d61f92d42b4957936cf26c7c58497ab96aa6abbe6f160fd6d2092ed734fcb300c6e1c368aed6c7b885bcc8ef32eda39fef0887db17f13d2460d576beae9c00652ec2996cd4859be6d485df5f21a0280d6cff5435a4347204fafdbb7ade999e76b0bd6777804bc66f7209f2d9248fc91d2c7d2bdc4ab8dc9e9a438dad035c689e67b368f3ba656fd754e7359ae2712ddcb660d2f04bfe382ebe30bd01c3c138d9d2116bf07a64eacbc25145d262d536729eda731635a39ca501a55bc8e4827618eb294c3eb3cc7c909b8b84ebd03555ab7ba7b00c65638c4b5a2d5323baf0f922740215159c0c75b50d5e2a848233be77265f1de1e47adfa1520a4e99e6804854028a87156417083fd09295455b6cc0dd941e05b81fcf486ad03760ae07cb55f5ca1c00fdff954b1dd444a3c72addffde1d88131a06df10540aae673dabed89f287ed29df44455922637cb0a066ae843be3eac0c835bd08fafcb9826fcb19a36f7a65419c59546dd7a6d37f21edb48d4da10af7cece0cb25cf36110383e3b8502967acf83228280c4b5abf156503b87dd649322ea209395aa5770dc3ca625e2a75e02cabc6953525e756c9847b3309062b62ee3e4ef98b652f7c35cc930d4616ba6fd4118de37109aba0a119364a13d715b39bac5197eb07f4894496f78d40dd25fdec840a2f68ed7bcbdc0715a1af8e2a00b7c19d9b19bba0bbadd11f796081e95751113f61cdc1c792583fe3b12be3f1f51deda1e7501d660dbf29801c8353887d3bf37e78dc1e47088f31039b07dbc7c7501425023bd1dc20c48970c7d47e9cf4510e97e65eb14bfa61037f542a6feedd3f49e585ad3bc8eda89493b03b28f331b1838449a5c2cc6d1bd0e435e4f62e5b89b734771d2388b4c1725f8577cf7ca7d2dd2dba62a4ec4bee5895378cc415a26d56bec03ab979565b206bbd9a7ecf7218ada7f032b2c75761bfac2b914059a45cba69f3a15685e9f990e8acf4ebc1f0c2546496729bea5b3762bb2579ddb56b59caaedbade3d93e8ddab864be209092de09ec5ae82c044e90157a486c085370875fa1bcea180afa88b0a926d0d0bd3de31da1b2b4ae5d538268acb31d5de7a16905de11bba548257e5cb59a9e11570405e2f857420a9cf3348c908befa4e6dbf54ee1f062c85dac61241586764e61b16723987172dacfd8f106e95973c8ecb4bba40aedbde92b2d406eb74dad4badf12a93ea404d5240c3887e97928af307c7a719b1bc9b424cf93bc3c35aa92e3b7c327b77124fe28198a8cf4d32f30567e6b507d62e5678705624d266f38be0bd98fcfd0b731a7da9cf15ffeaf2b044fd79e9f0631ffef1d726eb90ed04717959d5ae05541bdc5a7850f6e80b3e05d26947884f2a7e22a2de8d1587dc99861d0138d9f7d0a8d7168806035dbd3a014b8131b7bfda55ccba4be30fa0e7d136ba2c3f0229c1cc2fc42d43f634d691b105fa45ea9f7da7b44cd3f1be267cf5dd0b11fbe830e5fede316e7cdcbefc5cdae31250840023d0001d13cb4878315484b8033276846afe0409a12402648d9b6f87803a30ed237d808b9fabf12b5e2d9960014e095cc8bc4e129dee9aa71eacde0cb2d69d1148d0965646357de7e00f630bb88c3e187c3a6a0a29e0cc11a4333798710cc1affa37a38dd9a234b073d8045c70884af20dd6b419f34188af5150cb9d58258d3ef0db2fb9ef3a3d62f016aa4cfd93161bddf516d41126d4b19c4c7710e3508e14c8ad760542138a3843a8054c72746d3170d9377b3d30837ca934c649bde0538273b5d9734237046fc43506c98d318d043fa08467c9f9b00ce97bb10ec3709070b2dfd76a7110c69400eca0a5102fd70f51675edb964f701d55ae8a454a02830c31318d077fefa911e9855bd2c299ce40e84e5f8fe5b2c74eeb0d9dee11ce797302bc58ecea186071016f0220d4618d57730b995ddbacc08ac5039db6804d81636230b78dd05bddc14fb408935ab633eb5d8b4e8c8ffed826c5fa66eb0a09b8d5ea5772240f321d695b3fde4d64c15859109a2485d9afed5f2aca9b8d61608bf8faf2baa05239a6eb150bd6461f6258320305b7b8ab9179de8c647df2369de7a1f2471665c60eb82eb8ea6d2c993830d41d75a0e132f7471e28869add029906ddc505e52f6c621812a6cdc8b13fd0e1855105b0fbd910a523fe3f66f23939ff544b96eb11d41c563fc37f1776481f6c82759f572d54256c1b76c6158e1b064f80c6d809a40bf0b47532da0b1041025dfece159f912c3bf55f61a768605e07b919104f05d72a6b06dc02b1171e0e150373e4f22c1b27e691a7c7636c35fedb8f8f1d7163fccdbc8395bcb15447a798c6b23944a1457a948bed00924c94f007892a80d2e5416b09bd7e2b74f04fb40c791ceda777b62f1fe44324163a3b3d9455e94c8eef30fc2b888a0a6bbfbdf7686a39d19bb702d918a0252c3aa5a1439aa525cf4b71120a651cb10a9bc83f54715c659a0f25d8a0b2548b890c8c8cb31926d17a803ea10dd87e43d7e0e128c0340de558e227d1a63e582ca700e94e648845bd59def87ed36c2ed698bc935dea1d643fb1d0fa116098c9355c57d72d94525599106b559cccd3c885f7319bc5a8d5ada269b4982daa5aedf9c6c987b4d19958a84c9b329b6249668169baf2e6b3e0e7e86ae93153c5d60d357f2a8b6c8ce6f639a9e20b55db5b8359fec29a0f84968ce4da88441c19c88e1df3772c67729f9442fd915723dc2fe9559b9b9de707d1cba36667b4d403ae219e89101823a6f646d5a9dda55baa8d3ad6dfeddde2daa8dc7c1839db770b7bfa1564ab9a6cb1b1a40e169111443a29cc481fe8e07dd34dbb6e44e56e28b7a5ba2c7689557ed5be1100d72a1733a47e4474afd33c9e4056b68ea1baf444022b2d235988448d413416744e291945f91769ebed28adcda1d6f6246f3708caca5dacfa5871e978c8451f43b4077b7ca42572b7a751a9e0eac3c1996e56e8ff5c36a1085773b94f2cee929ae23e5e23552d9fb024af52796c2fe80af983dd7635dc7ee75e6d34fafc3c1f0a0ee57886f5ab7430b4cac2df311c22ea1f611cbcbd1c0ff6d73de10976a226cd694b397583f72745562fda6d53057a4555647d56773b7d540bcb54337692208e542d01a6a9b45a3395fe13eabf597a5dcd14c5f475e2a8179141cc69078328d4395f7310b8b3a1b01a3176b8a311f9bd2d5f144b8f8c1f32be54c5280784716462d02d62b3094451a0ce24f795c218578250bb76f090aaa0052cceffb4aff76b06280c040106986cf6098dfa4adfbede5f65f75725b0e48b8a34aaf207af270920d83e699e32ba6657d117e87a8f46ef1c13a85e96aca4c40aef3cdd7e72bb7b07212cb4e8ca7523c1b1629657c0cb0ce32c0c4c047c7671ac375b41aa6cdbf626e2ce4730c6ad0ee8ff76631db95da65068fc3a0391492bce875bf2fb42297238764741bb99a8055f2d9880ab8dc6aba043b2c333db13ee216c7358b5d9df9a4c410e64da5b09f8533bce8f46b42f6e0cc1cff41624e5705dc163eb1317e4f3ed312a5488a0300eba5d5c450dca8044ea8a4b892c7c8fd5d018e21af05f44e54cfa26d16dacebc24a72bdcabf69f145226924a0ac100e40b8e99f16180e75985a5111109c7bc33a91338dea15c0edad008888c10c17add144ced8f22725f804c2bed1b0bdb3d8a0e80dada1fcd5ad76f626d64cd60bef994f4286f644ccca7f1b21e4618d3e4aa4aefc644092e26cf7a92e6cedaefde7f77f8dc4e73a30f569308ebe0e84b061f62f2498576adc5a65c3eea9fa9cc8c86bf1753f0274867f2127762c4a60993503d7a9460a65c498e400271b3a8108af352c75c85d8d224f930715eebd45a404ed442701781115d5fef07d6a82fccd318a76c02f50e10877fb731a8ae2668cfd41a85ef4bd806f0aa024a905d54840de5411fa0c2b2cedbd4340bbf92e9f33a0ceae6901f5d70eec57dc21686911df3429d7fdae7a25dd7e3f5067ee251d0628cca6e20e6883682a324915aff0899a0025a1928e071124bb18fbe60f68bcc011adc1562507c1d6d82cb0c7054562f6e219a35df21cfec46e7fe757f222d0be4401b2b3af987511eacd0b5c76557f0f3993627dbe5f0ffd66ce3f8beeb962073e969a1cf64afe1ec5b8e3664b82827d10451d3bb8dd7b1120c6efd54a3ba5dfe26ec04dad1f2ed6d6419a843a4b431f8e46689b2c7ca61c680644bfaebf4136f1ecf89e870b9f720b859694846ecfb5030b20bb2a2fcaec689dbdd1ba6252d4536ffca2852352056360069af57c983058c3544a30c328032695c63d0619ce67dd5e615417825f6ca349638b2c1fe1ca6b2d9fd2c6c3cf73a0e469de0b0d1e0c48e973e425c6d1a63a49108d8d135976c7524aa80b0407bf442ba6f6123bf3cd1a2ae831a8d61cc934ed34edcd25cadefb95f37ab37986f62b63c6eaec9057c5085e94480b49eaf13efd171b2b0ce386e5b400965ab9338664f89b7c5da2c27cd034870d564ded9d3962734912198f12b7334ec06c6ba47fc1d11814795dceef586904d5e8c5fc4405efcd1684242bcf08d64f4fe81c434ffef250fe4cd1ba09fcd50d98f2b7b61d3dbdf5b8b1b9951f304d9de3193140db0336c60cc48ec5f7b22eaa4fd3c33958e09f76dac8c32471bb565031bec9a0930d6bf98936690fabb2afa3949d90d5ce94b218b91f522338bd1b1994131a0b660d4cfe1e958951c9d5167f2ee686f59ae0ebba458e6b26abe858e2e2cc3147cf66108b98ead59b5e0e139ee9950ce18175a25e09a27fbcd48873b01ffc659f7e654c677707c356bc9724596c0ca73117df0cf23bbbc7f6cfb2f819f5f230fd0c979e08d63698d0068e157ecb571ee287e3fda38cb4eb0bf08d7019adfc3a5640d4eff9c751b22f2de377316258e88d1fb794d9c92f31518454356aa55102b332db386fac6366e9ae801db8e2478537e468be942e83e921e23af8535b9f4e0869bb8c8dfc318c86035f3281cb25af35835ac1af4b5ac4e8808172b8ece9c21c1ac42387d34c0a2c0de89a52ac6408f4be2bd2267424aa920e4b93812d30f534fa9a38f98171c8d881f3bd1b7d12e64c7995aa41e48b40e9c5417ed57995cceee9efc5874627bdb8018062d8d4ebd83cfe805c860b1983a03ed69b2dff808761353a645f17cfb7fc17692477588ff0e4d7274bef22dca4c9a631f8866f8c6fe4ef204b73527f58bb9c964795d003ee96f2952190e003f2fb9e6af19be370a49877111d49c346fa7486cb57a0512cde5046a9b08d51f7dad7700d28b719896e8080e4a23d1ca0cc7ffbbaffd08be60cd79872f7498120392cb93c2db572ecfb1b3d372466bec4d2ae9ac8f5e80f2be81fe78c1ac3a0909e0eb42f2ab481d160c8afda8003075ad89f460913fed7f10808fe998905c7385041c80ace5ea75f358f11167886b0a72f7289aa29cefc4ef6cb1197e7facfb5befa83bfed14fc4f02df136af154ddf99a6c2ff33e313308129abc3b6be5f9ec9570b570e5bf74bb31ef261fc34846eaf71ce3a4a377f646858834f12ccdb87352c7b7e505e50772d545176dc52d4068d718f881e426e0c0b10e73c341f4dc7abf7f28e1215eb0181d3abb24658fff6f44fa6299a1b05907ee4fa971ee09fc271a2ca1db3d3398755d1803c2a75042a9d4d40e118c702badc39cf4976cf8a9d272ef6ca29cc0539e2a2f1b931a5f3a5c3690be9c5a5a3ede5f7e8318b4a0895b269394dcc965bd038ade08ac177f30be36ae3b37d7dfbce5285bac44d6352320ac75496695bc18a38775b7040c70d764a9b565b9af2f971e4b07866f0f5b6e20c03306fe1a722f01d6e62b3723207268b0a94f41862775356753ecee4b9b84f8bfd6b03f664b5816be63b74c70f551d3d942fba11c0bed30b500ae200479f3ad81340635f30c349750cbe8791630afd85a4238d8fdb5cb233f41ff4c3f984773d00e249831566d254b04d9dd00be65228faad10e93c2f1dbc3b87407842000df0a4ba60ef8a8fbed6f57017057d66a49849378aa9d04f93c6e9859a7854c02f6be7d1f9b9e742c2d48c168607796aaa0bc95d0f421cfa1103da4bf98d5b7b61d53ee0c677d46e969acbd8808bd705b85bf561afbefdd4c9b0fd3d88098dbe55aaf394130648230c633247b1216d05057c95f7b94487308900c5d662c89a012260203fe0cef31bbea49f68b79657a8ac9b3705c7012bb5b979795b4a0ffd97c1c3ed0f2813b999fa1b188b9f6a690edb0d31865a384755190c2dcb4bfa3ce1389e575dad634dcd19d7e06eda05916fda4d18c8b8365e163e4e815cd22d9d0d0a2e419ac7fc583bb1eaee141f1c2bfb2a81c808f1b12f013961ac713a9ab063e3c97ba845e957aaa934b520dbe53178df45870c0375481612502952c79d233f1ab3f549c17b2cea6f00a68a8f781c72657a527cf2bff8ab38a6f58f5a548efbe72955122f056f82ced94639e7f134bf0551423cef4353223f951027e8d77fcc0f6e05acdf2168fd1055ae5955aaee4c024522ebc7690ead21cbb7517edff5a413dee79a2a11c98bf70adc36fa858ebede78d50c8aa4fc56fc96d28ab4837a714938498039cfcd847bd4d06cdf0d5d8ea82c8743e3aeeef1a45ba60951b32bea1e3c73010b0a3f95d7cb7f7a80b1c282104902161377c4fb070d0239a5c125a6e1e5bd783cf95588f35324ef002b94a0532ed8c623cc4361e94cf5eccc2363474bf478b237c1600c451d42822332770ec76724efabad73668e5aee99db4f559f071313e3d83534c02675547a8270cb8e8c5e4f8a5cfe079e39e8c889b40bcff906066bcc67cc4bdc351da084eb301b890536cfcb9604ec8e1f97bda161efd034cddd62c1bb7fbe6bdd0f20441e67209b7d0cacdfeec26fdaa82ddd905a44b9694d2a0b001ee4df02835481e853883b3fd05fb609013fef6f1c44f1bbe0f6125e02502caf702a7207b84aac60347901428f5356b28fbf3d6d7308d4159771ee605b44443b9278e16afb699fa0e00b5b7b7dcee8426f872696e12e9d314b88bc2993512ca50454b8a1a4e44773f7dec35d0ffa2a943eb8cbe957737d71fca2ee4b7703f125db5613f3742148f8faa9e07b1999909454bc9cb495bf9c5f6ce6f8d2805d8ed00b462caba21510ee8acc511866051e604bf4bcf245578235c0efcf3166a0845e4db7ca9b2bc38c00914412b08c78773645a089c52d56565dd1391c7dabc2db882d1c033ceac1d4bf7f1df043d5b92e92c3d5b3b38da2dd8d0a347b9c4a7b56c34436b0b9ed541bc71a879f381d105f85a30372c94d5208841eb11eccad040ab60d0f263b373c28f5b650228e869dd1d3f001fba331525d339c7805c77ca36af0e2524e46e7a9adfd49bd27b1987734dad79f841a407d9c4d3cad5ff5546603a1fa9ae70e2062d6044773b51fa98f4fb33f5b19e5d871c2046e82dfd966ba3741edd4b78ac2be8572f745055d152a8d87453496afd5760563be0a631f0afec70cd5b25fee4b329fb0a89a52667c939f10faee2ed70a53ce07baf6180c1b92db562e42a2af931cc705fffcdeb4f09c4da27a06213e4db80aeac762c36b70b107c4c0aff9dbde6245c3cf73467f2833e429cbbdb41e2e6d89ea076454760ce1b443d1d20e56e4baba6a825c394a1e13b9ceddbb70a5240fd136cd07ef0e559913e11730c6e615a237bd9fbd62a254da3f83bd4d060e6796e082603258ced5e14c7c62b1d8b252ebf783eba9a2db913cbfd750761273ec2da2ec8f9c00673d0b6a701a67e321472bcb7148b78e04375a105ade4048b93e072d101e8294e41562faae1d61bcbe9b5b97db127ca8ad807871a14765e95cda3c2869e2febd811e8a479486bed6be8fb50025f286d50d7835fedfaa93058b79def45a946ccb38cb07939bcc656b8cc42aa95123671717e2409b1d9a802521f04bd71dc0d4b3abd70a2cc1959c6587ccf269d00a1f416555b8102ca93e8687b2c0daf258c353318afe7dd5c5d013dd8ce92158270ebacd19b3fa48bd7557c27514b23ab82cba9e7638606490d15aa4a99a681de9528746a54ab122e6472875f45aaf5227e50d5b1e34d5e8880006437b8f4fe50f4e2b423e175fb70a7e220bd34a0be7853368371326bb97ce2f07d99d116382d745d1fac60652f05de186c59875c52d9cb8db79678bedbc3e96c6bafb2890b15397e1631bcd89157c7b8e24b8bb147dfc2e9d685616ba44b32fccfe1aef3ad756720194a8086efca861a5ab9dd1b99473483a38cd77a7070f7051a90589405a8d1a4fa1088a5ef6b17ff0629a9133b76f32ee5cbde82e468467646e6c88b2dc4212d314f07b01a0d6d2a2b4b52f166b37a278f27691e7cfe8f334a987e0c3bb1f947851396c34929b61e124163c52382df786af639feffebae324d0716fbc4f6b8f14f8bdb1262d258b77853a6deae6ff82a2df45e0de4e6a97f43e89d4f7f55d89ad782420b7f838f9e668adb9331c1e1ca11529d66a02bbcecbdc79827e88950814bc7328323e7a269e33ebebfcb5a8b427af77e496b3f069f537187ada0788db4a033ce8ed368d879c5cbb171c4f02969785e09c78e4ae193a6556f017acfd3ae64e846bbd0aa05801b04f650461a66a492c6c0054d51daa0dba77d778b21c5502d07e913857bccdb30fe8459f408967e84d6e316e5a3416d1888ab494f7fb44a8bfd4ee25a93b367c7b50bd576759b6aa553c7f93e8f8b8c6d94029a608d1de91d538f514acd90d0e68bd30815f7731eafeb28a112edd3ef39fe50b646c763c61fa6b0ee1732fbf652c5df8dfc457ac71443d3bc9ad8e4679e0cb83992d7590c56d44fe0c10b57d0cc87f85bdb0712d085802fafee22c36e18c5684352a3a5688c70bb1edbf800e663531b01f7adee19e5f2f91d05cb40fdbfa3710e096ad57176822a180343b8e996333bbcbaaa74e03ad13429fb18aabef9aba794bdb80cb82dc04f8ea94a285b509846e551d0629f07c4571977fd62546381dcb12d1568ae35924b2e8416de1829f06d04c2b0f5105ace5aab51d5c4a95d12b6976e4440450661b1180000779bd0b469bf4858acb4a42fd6fce38433bf361b0ef1ea4fc03e8257119f4fc54ac7871ab9a90d095aa656f00a1100e23c1269f851f81a6510ddee61fb45d70bec73127f7597e32452d319f457337f9637d6ea28533950cb985dce53baf4e3009c12ed63cc37232574fa549f50b1d731fca6d76786b7a95c6aefddfa2a2cae7fc695d67fe28995aaa60f1713aaad7d5460e745b403943d416fcd1e81febba5f8c751754b048b07d90fab2904ee0957750e58f4768ab7a8496afa2f8ddb864c1081cde3e8d97b3c2e06c9d703864b8aeeb8809bd86951bf71e746ef9dc78c15502b2d6471e42555680d8a4da11a123cabf5ae7bc0c8826235fc9965d244c8aafad05e9f23697c3c0552c6f613373579a5d7b061d6c42da9b45e285b8cc887f66235ac7e145bd50392d967e7897f7dc75ee1551d331cc4c9ad41cf8402d0be3122e42d8e9dfbf9f5cc53e611f16ea31ae407261bca021c3c2b80a550f70aa8d35d02ef981c40f0dc18c42aad646a7327f41ad88d897a2961a1076f0e2b8da6f6e48de9db980633562f95532e0136a0ea65b774f60858f0f8413f3a744787bb664a2fc557e0eccc5b7043bcb46fba33b4b3a0f4e81e951664b8cb033d694ed8da0da9d90e4bd890186ac664f7654a0992eb1faa4f0173431f90bbb83460810bcf498ec4f1985a58d08eed71e7e65b2a2b2781bc6f280bef101f99d9fc83e322f512a8cd65afe224765a343776d8068852c684ece297a428eb66eee12014e6231df4eaa9bcdfb62a68afa4e3f7d256d8d981bbe87f76e3a5714d7199d1c1b1dc5e67bb5bff0903798249e192bc7e57352939a4d8e6c0f6bbc28186909c4411c53e097d14382bd2651852cd5b37eee493b79236e1012b0e765db141b1df1ecbebf508cfef3cffa76891d34fda691fe15415c5e15c7ea11888b352977faafa4768abd0ab4cf5ed047db74336d322ac3ca40beb08321db5704f3351c269c79bf12c32b2a0eabd352c3dc78b70ce0f235a933fa1a71582536cd068ffe4c19c8ce923d57cb3080dac92672dafe649fa2e4030f236880191f55700ba83507c281206658ed471c426cbb77c071de67a6ab5a887e2b53193229dcb819d5d2725a4b8c826454441fd089cf7064d57c2299e631a894febb7740fabaab9fa12c523a76edebf46f44199a22ee8e180916f8eb91cb2ebae0c55e4a417bc9433355db55999406f7a72935f00638f8a7cc249211195aca870c5c6a4adb0812a1733f41479a93b98ac95014a382e18643133f9bb545eb0042b0846cb89bb55ad060bf939f699c5b806d765494f0ebaa7bb7a592bfd5d4fcad37a01f1bd02462ea3217a71bc8565a7361a89b155e6250b27b3557287d630feab6b03facd1a0b6425c1de674d40f939b0ae4f54e87dcc66a469f5a399fdddeb53273f76a041fe7b1b5cca4687c5b5a5498820eaf0db7aa0d0e23faf1b0c1693830c71a0f89ee083be965ee5efede82094bb8c6d9fffae446641059a72eab177bf4b7535150425bd0e9fd49716ec328b4d2edd60bd077b870c7aa4f3d6ebdbfe800f7ca31990ea87583ecc5926bac4017cf0c76388f970eba69fe7b78a116a2ae87506a61d192e0d22fce51e3867cde6afb9c1d7dd9b8bf1b7ab5dda73e552ea0ab6cb689df8b3b30bf48f1d79b97765818a7c12a021caa2860dc5cee7b6fbc955184c507e97fc27e370cfc69de1ceb9bb2c773c5062c0c77f6ee36da0f874a275f3cf02f80adfd60cd8e35286e59b56f30cfdac8e72c08eab5942fb53d71cf0e7e67192978771888c539f0554aac41cb98e4dc4b263a1eeeb0d820cc8ddc9e4464f257f9f0b89170de4329755bcb0f4bd575c9270a91cfcc7e813c516b5d24036e27953b4f3b46c0824ea104166427538a644130ccbfa6379d95e54d063be8bdc2fbef01f2757b1a7e49d382898a06bc6ffbca13f1f4a59c8598c838442eb346c1bcda1d00527dc1db386b2284c3d8d2c379cb2997c385cf8916e943d0d151634695b0dec093ab05b075c32c825ddcf989c2d739b499686443a96934a36396040bf5c987adbf3f51eabc070e958ae4de5bc07ffd11dbf6a12a61fcc210281a7541c90ed947d4c7944333739be17f2d3e6c3eb0d40f1e9e42365f77c4c24bfc92cf4f9624d6c4f1bfa704dd221bb89a9caf648847b87b463d0fdaf1f79776d1f04696bdb6e474ac144ea7743a9cc4ad2526e9a8ab67cef59f8a307fa4060a8b2fa07d0029dd8dd744ce82bebdedb6078d0714e862dbc0c777c3b1db20c5c23760f3cd69e9480da6026ae9beebe0ad376b2ad14bfe61db4fa103038e96b2210f864168a7979576b226f5dccb13fdadc965a1ba558328db1d3fc5c1372cc8b7610447d350449587b3922f74943b74d3a26fb5ec32b4b88ed2fc3a390122e52c8416a8b9de47ca6400e5ac7cec455f289723850166e5f84d32a39a790aaa0adb8d2522f25d4f212e08b015cc17a9c6239c2c4329347601e9631203be18ef98f504cd289e634399795b57d69a4d87eb8cf0e9026313bc9722da6651a03757e62a23546749bde188c840b8ae7b5836af795d4fb99713a80878520f9fb2cd72d91f4562399ff88f2113168c0dac4b3668546536a70dc77bcb5263a806726665d6e22b0efc873d3a3790ed3e7fb0b1cfe424913e8437656c845d791b721df596cae4c14b1b50ae3e10b550aed837d89e7640271127521d4ee4f02e9758fe7059358ad2bb503db34f89db631a50dec6df31ae05078082751701cafb4fc7b9ff6acceb17a30df228458e471a1bf5ce5b4e16f6ef817f10f0f7b4df99f5653e49ca592cf82fe9ec917d0a61f5955da6ee589279d4a7dfe335a87bfcfc6d453208e7dc441a65cbf1821ab62279d79c5fd4f47571c4d8bba04cfb6374602b28a4096752fabe290a3e596de6e50a57ecc4647df72cfbbda554d1a74f030c1a49a2ffda106582ff748716a551119c00193fe76b5d39c29d3888df4631a1e474ef6f1bfd710086ca8843894ebab8beab303bf7c10ab7eef5fb057c91f6079c75006460d1f2a96f8ccb0ee551fa40865d1e80ab4eab9c430ad77ba2a50460e8f5058f25c6c59753945d0936828031840b2762d8395e905f139a88eaf54751aa69eb97437cb53344f66bac8c766c789eff08f8481805d7da0a8e8168dc55907571e08ef6ad1a8e3200222f3e418fed9b4527fe18b4b8d09bc5443a3902c37a6806938581303867aba0028565e47da3d333b03252085bf43d731c678a594e9e665807c448e4ba57cfc44a3e82e230207605242a61fcf06acd4a2f79bc2b5c756a68229da9823292110fc310e5578d080b95d0d420e09a7f7d6b88cccfadcdcc24cdd971111ff264d17458340a974f7b44d9a343e7ef114d0b13fba248625319ca535000c50e9af61e2bb3c5066d2ba614f677d63493fe991a66b9f6a351208d09dd0b0647f238302b6a849da377bdbc6f58bc9d77b865bd98d2a47e3f8ae715e31a7e83a595041bd9e8cab308e28736abb8f53b144566a694e954228c03fb934a02b390fb5d27eeb319c6eda8fc6df8631557a879e3164185acf75e3af8cdd4c470459dd74085889f4b730a8e10e6c84083e8a60a9810d45572ee44ac28284b8ac6820b9b29da82ff71d0675414a3c8818bee789e80511f59b11390e5ffc5bf64a9f1f51d2b2b94fdbc16c152e2cd4aed90662ddc5af22619380a66e1b14a8eb913d86e0677432af0e3b29ed8c98a28f0616aec0c3833d21abf7ff92a6078df6f08041a8dd3b111845d5e9cd3d803698f4fe1363aa25715658d1a0818dbf3f407cd4a38bd183c135d2288ddde75ee22f3c5a7b2832b1d67d9601bf9fd532b71cfa11d29fddc8633b519b783be81e2f83a0249ca4ab0155221b2c90f1704a699b8d575548474c3f45f4c03e9d75279a7ea8c17d97519b54f576112caefe4fb0e4b4d8b2539ff619ec997fbf35e7f171afc4dd51a043f653146f0bf30a898316dc3c994e373bfec6d799913c56c1ba2b1199cea4841ef1fb9b5ce92a71f1c2c2b74858b286f96e548bd18f4cbf5671f00cbd1058a7c43a8a18e4d4a148c16048a610a444b864f077831f4e2dda569b3af3d9a827e9f4a8ee471486190c1256c1c5ecadb7cc7be238d7e424540d286c087ed033e1e533925e668caa5ce454e6d375c906ed5cdde8a083dcd09206bd5cd35ce033c22bc3b1c6c8dd527e692d8d670a87abc7df30261ec4a9280553ba2cfb06e4ee767957b24146f8c324c01b10420b58b1597767c1914f3ce981f6ae1043e365219d5a5baeb16eb0049fe501a8e84155276bc951880f55bd6316443c2879bf851dcda2646140785c07777d528ca49b4bc2beb2e003c9d8f627995e6d3a806747fe05dc48c6c217a6f319d78cb0ddae3f5818c80cbb784ff1f677f45bc5dbd9ddf1708d0417aa3b2693608a0ab86450ca249a1552d323bf4f12c2273aa24bda9fe4f8156aca3c8019459544c25994bc605640017667cb443bcb9da6e091641977282cccbab0aea68257795a61a7e6354488dd2ed7730a656b86bfdad2a387aa6088164f6167cb609639017dbeff496122453405e4d5fcf73d89117afba2d95af5e3e055963ed369816cc583c33e221c37db927df440a98e4f7865f2667c5df3ed70cdc768d2a7aef92c872518dabae521bc6a36b3cb4732a4c8f03012e51570ae4da4a9f3e11f5cc02e676866fbe317b43587cab4eccb30265c1f5b89eddf621faa7ef5cfe508ddeb05f9477ff07a2b0c23f51539262fab63024e8cf8e0b04c7c112c9d53a9a6a8df6d73e7d0593419241284d417fa97912499c8daa9736246046df692093dd36ad02f44fd18bc1faa4ef1c552516f7473102b81c555eaaa2949da574a5b10319f3b522c0f0b03a209d44552140c069fe8a557be51d71f37cbecbc4ae995e571731d820553762dd31a06a772ca7fb2f1c9596c952dd2185f14ddbbb05757850141e53b03a895e85937187b1a773b81e0e87d72a22ec2ad9f320c939b166c08ff880074dc4410077fea8bcf8cf8dec58bcade68b2206b886aa19b2ca1e79e987365d6cc052df351613e9949f1afe98ec5d065389b07c376261ef5c789d762dde51162faa0af2e2e1fb17dd38b986027b28e020982e29c5d6b62fea166a325ab7dfde5edac631451276401914306c34d288db7b459b79bef97f32815ec47b4ed40925310b2021923ef29aab4bddd2a58e35533150617c8367e8f6c6c0bdc3eca5ce64c2ada2e85552317b43858b85e94d8e5af087bcd5f22cece3fb593121a20645203953c61d8fc57dfafe93f523db0b73ce1eca3f21ae8bfd45766e9b40757882efbc935078cab946b1b8d984ff3abdae4197331814c20d42089858623a579eb505c3373140db56b78b6182c4084995d4a815604c417c17b364922bc87d591163b67eafc975c0c2d68804f9b6b940c6d594edc836c431311aa0079b38b17fe788bed25a9ae38e20d958ee9d3b340b23fec30c3f0bf0252b39f918ed6bd5d33a7b4eb990153571efecff0ae699aa7a290b3c5ea59e8c7df87064645bda467fe5934947655f918ad172cd68287c5873a5ad1ac59792f5f3f9a9284ad17fdbdee4258eda5d21fd60ce13dfce2561026ad0dcf00abf2532770af6977a0032fef02aa5b1deaa831bef056c7e290ce58964cc17d57aa7a5073438d83197320562e869b7823b28e54d49035e51c62e7e64fb7593a5308dce605f76204d50dff57970b627d02d00decec8f166c52dac328496cea7574e94f5d46a2e2ed00af85ac07c2cb87af0cab9abe8d924a46a42948de21a783f72da20308f899c8e49dc491c0ef9cba98d84b998478d6b53544a91fc90510836404f8baea163cbe935631538b945610dea778d02219feab00001a166a5a4ed436ce0d338264837d464dd401564a829fc5dc50fcd437a435b7dc7451d1be90f424327038aec08e782171da65f9976dad7ea1951f16c5cbf70aa1a2dce3fe0a17466a9c8fabe764b8d43fe5da3c8049a50ed5e3879141788034563a6c4a38b025296550a657ec8fae31459751e4b76afcadaf15b993f65216f27e0427a3d547c8a78218b69617f563c23527c445fe17d639ac02bd7711443f12ab30caf6a7a9b3a52e2800121c35aaac1e5b512725b2beb0e16d16330fb4690e71198b72487798268fd79b8ba6a4001826207ddb9a71e1f93b29c3991cfc3dad4ca638cbbcc0e0de1323cb2cf3efe219f39250f96334066fbd92eda7890befc77ad997b2a9d9a6c56b03a5f588ecbfe7bc548d2222b5bacc1189f12dcef2641ead24e33d76b052796bc66267ce9763e5fcd5878a5ab743d6a25693bf326e4ca5b478afa203900deadcb9433d5169fb0b8423e80c04fa38b8cd458a9d210ba5259f532cb0ff2b1a094cb6523d0868e746956ba7192508d555c804ade3ce6366e6f9d8838ad9baa9218ad0fdb7633695de328dac8c4255530f6936d7ca6301082a016b9fa7928a3bb504a795fa5f5b2e759c70d21ba949f106c3b6236f2fe233bda79018d2bace4125b461d917290c7a241f809c1108f98b6cc66aae1287cbffd3e8bd98fac8e66c8d632615c6484225d6cd6c5ef2da228173f658396ffb0900f4af11b58fdc40afc48d8ff2894ffc271ec4594d4dfd142357006909c89d9f6e06010d191b72369301f414dea71df40fd385da65f3ce12f05de2d747b3c66bae47356dbd11655dd2f3940bafe26f3c97fa2677c40d7676c59a42e87b4015defee5a832aaeea2c740675e5e6e231cb4144304982ef21b4b17b3d3f18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
