<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"795e95008c5b64777a53af5b75180b50b5c31d879642b32144b46ca16027c0744933ae01a9af518fb1d0c71aa2275f108a0a5dc8dd0f981e65c10a73d4ec9fe9282c81a066533c16d6983d11c7336a381f25bf5388893653ba559d103146a85b047fbdf0426062ebdd3c182fed3d86d906fb56076808fe0c8edcec0c749d4563a708ec60f5f94f7600da98ca956d9d4713a6ae5636b5d95eabbfa40f273a78c31d00c701c6fbcd41655603980ffc22f6ec4b5a1d86fdf264987d9c326c66eafdb5e06b655466b7e3751a9db2761c96c99e7e31d2cf94919972293b12ab34ed1aec2dc595f9189ef461445cdff0fe0ea5fd68c6f4fe54565a32103e849fce353b30cd9b1c5e7f7a3fa68457fbaff37f5138d40ca7eabd02d4ffe47214896108f22bbfca744371e6f4740fb8b25f58538af8ea74dd1fcc905ae3ec0552aa09799bd88f59ce3cbff804348cfefdfac3d05b3f722736987458a9ccc2cb4ad03f738602b5a78c335a00c4e9e17bf90a5fa405a79682dd630dc545ccf4ea3d4843179418c62c843b88fb4e7ce85b8e5b40b61bd7b2fe2d9fa6fa0ccd2e2b018316d90f0dd016c1016e819ed00193acf0aa7ab872ae5478d17772acf8ea3000db009a01ddfb6157cefd24e66ed509f6b8aff3ae897c534d2c34274fd25de2b2505c34fbb48c2aa183943e73f1cc43fce5b129420390d39f30e058fa6d7c3d2b3aa9d8ae377995fc2ad2e2ee2804562fa62b5348435997cf77e8e312a35069e2fcb2f79f25e261d7807c0020eba11f86a88608219a44eafc89103947dbf0860f2f85ff64258e7e233038e915b9487d75a6af97d2a3842385e94fc1239c6c5ae4da73352eaa52f303e4de46ea7c81a911d6d153a159ce5f8df6dd52f3a984909ff4958ff9c464386c920c6820fc78e4485138c80e9d86824d5b7a67e41db615ed03d5efe447466853ffc9af2397218d750edc7b7caff79a4a8023808e1c293d7365e7afeb734dc1381e14bb666279902ffd799f3557016eca59136abc450bd1c629464e96084d578664b6037850f2adc889c7d2280a63ab6deba7a7cc6fa6b8df993803d0375dd7bf80530ca38f20e239643105381d185b793f29526c748fbc8df09f7f3fecf4afba825e7fc2b2cae6a502001d57ec383ad34b8ce7d985eaff30d272ab914ba950e28411b77d5ef96f9a15de0c4a0d3152fdb74f985e2ee19b3a3f3dc5120c0c83bcb10f3845a88dd4cf259dc503dbd68c6e7d8ff30a200f48622770052a95685aea2b050c3388b8b43b56162c01d871f5d95d91083733f028ce2e98c4dc41df856e803795224e6e04b107cd02241ecd0629af2790a9a1bee36cbe3129a9cb8beb6e3048206da73be1847218d4665d8f23d07b395eec0d6cca56330287f5f9a1d0110442607087b69fd39dc64ed2814895497922162f736af1ef3bdac6f02911a65e873cccb60264d7214d17c214de7ed70ae1dacd3dfaeb4451ca4783c974914777229e46be9bfdbcd492b3ce772abed39b62e0cd80afc60cc9821eaaa833ef9d222183bd2a6bba97e0636001e87ae8fa81e23de2c44a386ae11b6e19b124a5fd976d1eb1d851d8ae22003359fd3060ca255665d10c2cc5efbf5a172c3aa20bf21db601c20d3e602c0c1a6d8e81d42d84d8bc4d720545d7da9ee1a077363fea6e29a5823709d825ff954e2707d258e772b5f8fc8c09c2d03632c9f25a9f54926937e70ff68f4270e5235ebbc2d09abc6a45bebd940188d6bc250a2f5c4bc624ecc554c52e1c32ac9dd4904ae065808e158a8acb00a87074796c448e2a248c6ec355fb7fa546facc116cb2ff75cbf8fdfb71912748afba622871ed20232f857a996914b2ae7f407ec8b7176cc76099546d40375f6ba634f510d1bea93e8ce1d606e97107ebb4d9e1db7c1a7f9324c87a569bf338522c3af0544dd2424831aeac09b2ab714fba61ca3d1dbc9e88f1b59f712953139ada25b68ac4854db2873a49350daef3944bd83fef8f395f16de0ebb877c7b6a2452c109615cd85985a0763f009f2127f4f8cf441daf03d121f0d20ef3a1e664652ebc3ebea921e23139426e81dae55dee21c71112b1b0e575fa65afd9d1af4cc1e5d8fea87e5a5f7e6356b9ebb7d0d1743f67e00527a5a8af994c5156c421fd1aefbe1029a112c709ec140450df3d11700d6a0ae2de057642633974ef52661e17663b79100334fc5170e3c93fad305903dfa8e89db2a5c81ef0926d4388f4a28ad032d1222b9de15e2e009e94e1998c7e697881e7bedfccaffdd2db5d9550e4232a49f4aaf570e8325d44da1f1650670dfb9118abc970c3b36cfa287178d98a8944ab6d079c2939fdcf263f67d69acb11bfef8aabe4b371a279998100ab3d0c209a58a5e3dc7e5defcd674ea4732cb497e4de9ef9d2e84716f0ffee3f562be232b2c265a55c7d8a8fefe565ab69ea971fe8c47145e3bd5913298335a82233efd89445a5d543c1b460c85a25e789c0b9e092463f32b455f096e30e7429e0bcda5abd37df5f7045f8db8281602ca4d5ec4f3291e1389543e3ac6a2ceef5c863b11c2488d90b9b6ed752761a09216b148614aedff61759fea557d1b2b8152665acb57a41818ed255ecf75b5fc9cf3d3f8953e8f93f89d829f50118c2566823cbe2895e03ef33a01d3fa5c603840fb6bff785e7c5e8d8545fb2c05c5b577a4c2a6788b1301608b8c12f56066eed68c20715f0f6dd840905f0ac04b7786d15eba4236eee1ecf04b4bd4748f584e11704e4b2748123e7c7c28c5e9c52b9387b918dfb60bf1aab2476fcf64c1d7ffe71b81ad75e33e314524508fa2f2d9509b948344ed95edad2f642451ff69cbd0fafe3d403ef38603ec5493af71cad93aee12b4d6bf02037c3927fabb7d1da133adad5e09cabf954f6cb9346dc7b98e6eae2f811a5f87165c4d12046f0c669aa9c0f658acc19c88e381b6d4b23973cd5af8e4dc435cdfd26bba8c2ea20986cb52cc48cc8f1a474e6363fc178f2d32ba680d26abefef119b09944286d4e43026f89d565f9a8826f0babbe96a3d8c66e77d2f5136c61c5d09469bc846f807422711886c974bbd4005a3880ed86ffd4c66d2d49efdb532705ceb1a4ced80f92ce86d750a9556abe240657844f4ebfcd472cb85556c49e6b2b90dfa255af7838c362f73d8e6afa18afc45cd1d9f56cfcbe43d4d6af9245d63fb047c34b573543ea8d8498b93972c4879e7f1843ebec7f0645d49cae6e2b755104ecfcbaf8a3b3997ca9a44559edce33632a0d4f97195e0627ae9a402b0bd4b4657ca831b2811cbe5f7dbf48845e24ce43e6c760d519e933130805c91fe1343abe4f477af0bc61a08176e982fe60d1b56bb7c30be85474327413da65a8e3abb352080950baf09e5428bc59b613aca89ff38963200093a90202271e34fd82f2bf6d60ae7d41ae2a1668ca762ce871edaf2583ae32b3502c6e6bf1f9a750a22424bd314fe77d7b40cb5529edd7df8edb0eddbacb445cfe3ff5841cdfc0fafa7839a7173eff2fa737bf0f1cd2d22f20191eb978eb3e91b4bf9b36b18dab4b30ab353acff2f7ae03cac34f7082677cd046de70b65c647b996f0ba8fc1bcb551de5d9971fe01aeaa10db283a3fac87e9f7e5477b14f6fa0e9d5de2afd00687a2f1fe9849f3078fd845fc5c0e50bcb824912f58294003c489e9c4d471427473bd61daba46bcf528f2dc5b0357264a4fbaf0243bef3c6132c8cc6c0c1fa2c832729df5fbbb06b7796742b381da108c2c96d0b341ba2ea0178d6cea376d83cb621ed55ac821ee9af6d0993373b8ee5258b9ea8ead2c3a1cceea9eab3891cf591b406382a35399484f86f17b5fbd67c102607e58558fa2210f537fe9c2a99a19e16ab612f465e13ed3622b2f64278b429acd434f32303fa9e1e331ec57fc8f9729ad655d580e3dc43acdd136f95c36b7bd234314bba71671bbbc660099367b8b8f8f118206da7294db370ef244bfdadc321c441bb58928e66dc81313905d9efbd2327fc3eecfa68f893ec4c5f89192b3b5bfd85c9e018c9a03475cc2bd8c039cb303a914d888ca92b345309a4f2c608c6339a55ec3b2905df9955b5370b14d430937e115e9a8e99631f6a8c610c881d4891f8584c9574cf6c094532e1afe1e4a77f859395b4a337f7f07dc5a62783f6f119363179e03828e221a26a4d4dd34d372fa01ed31c12d6b5f6ad264209f5938c813c9f17ed4aa902a2e6ddf7e59213c5c69b564d29bcec131e0b3c57ca7e5f18c6a3b1efd91a82a2f42d0f68a2bbb6548153dfe33e271d8ae328343b9653383d26e0478e9323d6599f2008b2fffc34184e81b8a70181327e817e869f198d644a9afb01ee00a4f9e564fe2b1ac91bca42b4d826b61bd6d3cfc06ca4c87ee214889da2b602280e70a601b4da87be320e4b7cb61d99a4b3a5aeea079faac2d57fb67f04ea1401e2975c17442d3177e38f4792e68ef20d7c0f63485edfc363d00160f739ecce0430417657940d9823d6a1ca781da6e62bf1e947fbcba24308dbec10747bd83cedef1a9f36a3b60240534c5deaaf415825125281c753f7a8e2d47847f1ee62b53bf07beef80ae7cd4b397335f99cd9d5ff0deec25fccbe24a1e0cbb54f81d78cb0b59a055b2831dbd02bc15d276f73b2cfbec79117dedf3804e3b22153ba152fff26bb13b74e5193cb3957cfdea4071f82e5dfe9c6f99e30de42cbbe5b255996828ab238fd2afb39fe9916977e02c6d330c66e63782d787f6d9ff9a56edcf82ae4e2e4b046cd2ab0ed93aad04e808430813cb8dc507eb4a3d9ad8fb7464339a323d68aa60fcb2beb10f2c88ca1e6199a90e48764aa8245ce28b2df1b7dd4ac3cc5388ab5967c10553a764ca4a773b4cabc1748657fdb9dd8b40225b66062a09ad88f2b0fb02e79132ef50b2f1000bbc116ce71ab2438f93d8223a55a183fd50bde3a4148f892434a64b0c8685579f87a4f1c3a523f510b90bec8676a3e2a3a6cb23ca8762aa262fa9cca0d596b40d04e5aa419a4f04d1f8aa53cb52484958f8e66f17973d186c259ddf4c9d13e29bf99aa4bb1c53ec7d5b9cdd137749f794a32b1193a6cfcb868d2afcf2e3148899fe4619100c5b74d8bdd58bbb0ffb9e15a3fcdbe328e5e3e83e67cfb489ee80d7a69f0c313e57f0db4cace948d63307e90ffef91b0d3540200315ffaf4b595fc98b8d865bab7490978fa06fc5e0ee45430120a806508160d5307a86cc4eb9a08eaabf384e3e566635bb844891390bdb15cccce68c8fb1dda34bbb12e981f47ef310ab9f5dfc488e810e8a4071743c8d7861f7f787c7cd942c2e15e1cfb83e0e84c03b50de119d3fa5f5e6e5efee8d9c3ef9fe15e3867e98305579bb0b02dd254692f716ca0e246f585eb0dc3d67b7797a8a0f833164252a3a002d22a1a5054989cd226567a3ea85d44d1c30af8096407d3dccd18fabbd8c587c6c92f3a779c23aea8b925165cfe7f4047fceb05e19500338c1a4136c55b426160bd2f5dab09c71288687f29201c6241fc00f42deac8a9b9abdf25f4d0936984c8fead5126ac718ce4faf56d78553f72a8153bbf8f995a3d4ca5d7d20f50f10f7f5fa45b90b3d765e5e3bea78ef6df00da6327a969fa325d3cf1b734b14d60e5f6da5035ee25cc8ca92a361bd026fd9847c665ee99f04f6ffd74abce4644bded9c0ee9bb4bbe543d66cd11f8ed24b9c3d2f7787f0f848256043e888620989b0e0a9592a4f51280def26aa12598f7f894d2f170bf14563be8b6e9db11fdc6ec2916f299a496374bc45313a404c0e1afdf4fd5e647699fa81509df6fa7db5054529d59a0acc4528088c3b7b5698f92e8617ec3fd857b2a639a151d8e80379723f98be50f7a98a8f1b89c46fa5b4b8c43919dbcd36833e4d5f2b12bbd279fdb89c7c31227f588797b9ac3885d477e9249d01f411800e7ce6f67ed5270c47b5f659cb1926a0e7349b6afd866bfd7fffd0dac1edf06fda750aa4e62cdbf141ec3a8ecddfbbd800148a1952c6071f242c55bd838a8a5e1bb2b2b4ed1bae09a864a21d035b1098b43eaef6f18a03ba2c29a47784865ce247e511f388db07719fb4138cb9c98b0853f1d7b3949354df309cb1c549ef8ca8b397ad69a5a39ace70baea1a23a12b0d77ffca5cbfb92b1c8f5c2f410e430f00ef4c1203dd997b5061a423e3486a60d57f3892775776344126b04a566d37237a57009edc36b3a91822a16eaadaea55a7595bd86de269c58ad8cc502b76c0bc8922470311b586038df05406c1d61819944ee65a98c1bb76e2b9d6aba74ddd438ef8377fd5536b89d0642462f0c1d334c160f15681ec796d8a0557fd34ad17958d7c61a73c49d7785ade4d7e4a788e1115a774c2c83f7b014867ef7396a3c3acb030170f5e624fba61d1ced7ae8a2628725a0b152b646e00d42a09e1adfc171270e9b1cf4fa91f760f8e180ff7d0fadd758421fd013978f3e77cd340f5b5ee17cc4e6a946ffe62e3a8d06400a4ad504b39831f00d3d66f6a24a6a38a64a26c6ea6986540d7b246fe11e5bc62059f2039a9296a8a9937b0b48d010684134eb0afb3a20e55f6246f3efee7d985f00d50c6cfed9809dea10aa1924cb74050a19c28695d432d8b5a1d75ca7b7ff119544f573d46eb43818bd8589230503dfc6cbb922d9fa49e7e2c9c4180b3f255a8f787967ddc5b5af5c0094d3f40c859ee004fd0d43dc2cb989e594c591e65fd07ed2c38c435ef62f7156de333571f322448dde1382c80bdfcb1799f9923adb988568354ab9ce12a7b7dea0947931449aef92aebdf4bfe279f6f92e2b1072cf41bf59eb8fbfca8e7abf5659796235f73a87a08354ae3f5996f9f18bbad8232081ba034741c1824edcd558cf20612650d5d51afa3c14280bb6856fa66a7c158cc4d7c22fddbe9310de33ab12c22ce98c648665da72526c9359b0f56db3074409a5dd79cbf76a61affc867416f90f88baf0182066df8b8d3e45bac55c9b3a733dd729e11f14d1b9576cf137f4899dc251fe0e023cc0b66a0945dca302f99449305495bf4feec896dfe6466567919a9ecdd482752fe8a226140f7e7e86cdb5d6608608d40103ec3cc39653c84fc08af9931852d6990938d65994f7349ce1ec908a15e9ccb40d03a9659e22d3bab6a6e92e4dbdea01af969754681eff95f1f740190642032ea171063ccbe32e4f8402652136e899badec7fd254af3cbd34dbeb10994189bac94b73403bfe186167a3b47c50489d74dc32facdc1c841dcfdbe54d971d5744407df48f472a93b16258d94dc2693e3238603990baa1c982919b142d5f4de657941543c074864a7d7b33fd3ea8ce22cd123f87e69e6dd7ec230a43341ed2cedbcd346f0f74bc7e3c6d8cb4fe9872a837f15bcf7af90c75277f699c8e9c2afdcd736e44495f142a64ed64c8dabb60899f164f3b43f947c70974dc60b6d0f6b5e243662000bde135f592dd8590eba08d6b0e972ab68e38e5469f3a4e20723e4cb0d31bfd1a0ef0fa1c1fa7c93b59f2e510f423a507d319a9d517da22887da267c3410e0dc3bc5d48ddeccc102fe8c84b7e6ed42a6afedfd4f47dbfa0dda7b643bd9f57cd8caaf6a9e50170323374081e718a8f4b529013cdbc369f49985feeab5cddffa1e9f5f8ab90ec083ca93b06fc5dcb2022b7bc6f6c469bcfed11688a7e86ef495edd50a2ec09f512f886534c00f93124d8f65c45e01c6d03caeac34000d9d48cc824cdf172527f56eaba71baab35f6a5364e5148f1a3cd966e39e8b7c50f9de99545f9c523a985103a33e502401537fdc43ee944acdffa86e908d2b70a43cae882893281d6d915b84fb2f4c70395aa52cfd694344e690b8acb785cbb00ea1b8048395f61630e614c8ae73fdd67f23191027357b94421870f1f49fc10fd5f3df7a1a1eb7de87fcbbadba873d4efa736d89e665dc1def939cecd9526c19cfe5261635abf01c94b500324f241f2d560fff60a82439564a86dd16b172bfa7eb4e80a4d833180c50453becac945bce23577e9c2f09925df6c28fccb408962621f937ad832b9907a10075fa2d92f707257f76642cbbf7d6136c67ea3e3254165aff3dc7a5c8fdf2f3cc610d07814d6580acc8d4bf98dcfa5cb7177dca445e63524ddd8dbd0b094585fb7fbd849d842943881d308aa9e8ca0ffb04320d82a94356930f95fa47939a5c0b3e3cf2d5d50181ce39ec555846c07450e279b1faefe29de44ee508f61e70fac6427609255d484078e4d781673e9c281a41c782dd2f0fb9b944aa167c0bc91f0010ec4bc61352a666f59ee4048faeaa9a96fd4a183d6bd64f4c16e36b9f1916661a8979edf1c78c631cdee80437c4e7d9b112e9f5fcc8b6206450becaf0e5292d27a06e4b2d1cbff209a814ef73569017d66848e42261d21c3fdee8850a443aaf224085b4f717d3e30442c859f7d110cb99cfc2378cd36a6c848c0d1d13b499c5d87b6916258c1756662163df9a358884fd9837694d3f2fab59a89a1442af9e37793522291defb572c9109436458add3f904746b4d782a802fc0bbb1fd34d16aaa9c9a94a13471a45d1e6650c7addd19a8dc635ddea361b83e87621d9a9bea5a4367651a59281c653675644a59a95a67c4e45110ab5a59c0c0f4e1ed85d5fd5fe92b228e8bc258be2c8d650a419bad3f1af4feef8a57d2a9667147e8439cc59140aee03c7d088d7785d42b36c4d6db83d7ab59b2d19aac22d9c0fb64d35a32cb65437082e70703735a65472a66cd43fcc10aa98c20f183f8f6303949a57ee704cf3dede18f9934bb779d768296864b923df0f1c022b0d6148b94e229c05a100de8e414519af651582de35c7954100dc780b3fb492b975004e92c6acd3221ef705f520d216c6a421af3f29f9e5b1936f7b949b65780d0d0b602dd19a3325c4ed4fad9f454d724802a9058f02030ea542ba30b4e10efe8886746bfca068815c5b7054d008f4455095f86531e16a0cc7f5220fdd2bcd5dc47b7f3de68fb363142b53197d207272e1c665b17cbda56517fb33d367a1ba1ab0205074fc0d02b26f54b4c7b4669025c28a5927c200e0508285f4aa54bd615ca1570515c291876743c0c083af2694d7f84e287fae18a11c0c99f78a3fd0663a03b9a33c7650d19682840867bc1b6a2317e5bd6b94b88ab36e650f5f9aa8f7ace63e18af79eb8b275d9d7af3a32af57b466626f86a75244047873596ea3869c2f33de4d666d0b37b1e8c2fd47fa32eaaf6cd639b8f02bde2744420c75f1c4972fdfbecc499d24775488079ef909bfe9f64a51a0094bf7f0ec8a5b843f1ee181fffefd4de8629b088681e3522c144e16a50aeab0e68009f9deea44f7cf3f3bbc44bdb600f3877f5234ee581093ed818ddebe8e521b44ddcbfd21346633dfa279704ee54ed77083ab8ad3e6d10d116722dbd4ab09fafbd90b07eed06688c8335cb202162c79f479d4cb33985e051ae0e4dd3013f1dd5819ca520d5e822d88660194df9eddebe6906fd19626c1362d1fb52b6317441226275c04a0e32d703e1c4a6e0d7093c0d015c01a5e912262281451640c288eedfd330a0af61b6d6d3c170b4f7241a06fa2ac321eecf287af2c1f87d16fec61a1b61fa6ae725402db92a630f8beadd0b54983f6a686994c6015b0433f56b4a47c025315a55a6755624e154e75a01331b302b018455fac5db94010b828a0d2a1810a0ccce37dd0b1955dbc5a56915132b9146051be6f954dd9979a31112a04301490844e8ed44c8b907c7518accbec92b2c54440b5d50d45272bbfabf1e0e2c98119d2e0ef86768c2309a4a0afcf077f85eecde60021b1c647012dc37769e1f3f1eee532e270a0fa5f38516a6a6d677bf067fe18ae2c74313bca314c24d50e4f1303929aadfae7eed3f3ede28bb557431f4613631c81c50a789e3505a5edac2b0094005f34a1f63340e8d8a9c3431d88bfe63847e3012889c18bd0704599af3febeef07972fa8095b1e25aee09f4250eaf4faccf80b23496f6e1681847df86d5cc1310860e201fed35a1698502ff0ef220b4506ae0f702aaf31ab5d40d214903e6baa3be4e0263ef55977d56af41da6b251710d60065a757a7d006031a71044ac53e6c2a7597b9e41ee42b67f0f361da822a8c3839336f84062b0d4e96a9e8e7d96bc627565da766782ca80fe2f5f403c9812b27b239c0892d7e1f1b700d93ec21132779ca807b84681d907008e47adc7795e92c460538636f7d959d5510b9809616fe9dc4578d8e80eca909e675341c2106f4433b779b5e43aad4bcb022330d31c71bbe793c466ba956c1ddf6a0e62f69c4d080b7cd2b5114af92cb32cf54da8214ff951749725b37e253b6a40eb2dbf7d1d61dd90ffeefcefba800e87ab682e874df3012885b3dc9c84d5cb6c974933d0527bc1b5e7375bfea35099289d4415171d7c4a5dcd5489d33a7e63ebfd7f765765741b52f6e527d029fda141f3febb5be0c0297fd5dfde89d4c551ca722e52d4c5986ea7fa2ccda64c0103e5653bee936c91cf158bd89f17d94fa60cdeeb51c1580b37a591a90f1211d9f7a0869bf1b10358705f37ab64721417f48d202e7cca4a925f2244ea761318efe5f55b0c92310014200aec6b46947e54d8c52cae8373f2b187c1e9f6f82c82c04e08a8d0714f3f3b35eb25a6827ac29b2db81f406d1beb2e1793bb30567d0a701e0d192f3caf79b1c8b7681dd5a0bb59a1f8f68f56c28f15fa1144f5c2b90c65ce9906fbf094312646a116486a0494c20c48e9417a5a9c9cd5121710761e7940f12538147113be39708e1488803cb1c5e0ecf5bb84a4ab02a9cf7bce88cbcc1627e5fd6d77f41b7fac130ba6ba3c7636fe635e18d7b47c184aa4caf6808dcdcede4dc56e8f189d7487149af3f5ecfc2745ef167cae5e7d8e671d0d0f120d4a960b96bb3e03c453175027a0e3881d093a2fb7155d69b012c0e8bcdcdb22df7f948442e64951995634eceaf372e9836a670bc4e5da251cb1026494990f521fccc7d411bee5d8efa2fc35041609e1134608afd0b766db72931ed3ef17d0487eb61f1eb77e482106bee87235557c5251a46450c02885112ab1725989afd5f867f2938dacea58f813bcdcc4302b097a35aa45e4dc7582fc02f080c2b64b252d7dfd4c4d64a3dd8826b8c31ff9a28080af56a6b5a848a7b88e004e2117361baec5a06ce2b4fe715b03017b58d18c75c92c2b2c7fe1f27445e05269f4106907febee282010f600a1ca7907e08348b3c8986c541cc7e401bb7576ea5ee13851fd9ad8f3dfc8baf7e4085c42654986a956148138482531c88d9269a5822449d66556c01dfc411fe99ada28445d5558460f8c54ad4c598a1c503fd8139abdc5a25a1057432362960c9e63608bd0c9461c0ac79cd7ce9633207394949804e78f6c321b1ef88a32fd0d2507abbc8ecfdb5ebb2e8c54ee39af15f49de77db4b1a03b260ae2998bbcedf2e1a7ba59a6b996df1fd2141415267c802500bc5ebc9b36e9789a8e168ac5bf928b95e5cdc3a34727158496b263bcb5d4341b11143e2c09587bc585ee8853aa29e78e90fdb2a4355b34c0c8780724736fa8c4ed473a344e461ecba2d086ee10327ddd8221ba819e864eb20c408a3fb8354f4fcf4ec58631a77907ca9b6a95e861ab02f68f017df2ab65857301cdb8af6abf1e7764ca363734771e57c6f4dc9d0c538af62e8a50e5ba6a664276432a88a89cc0fb2d16ccec43f4e175f66c0cc865e431c81b99b7c1dfc8901fd0a2c9a1d400ccb7a7308fe1e60b8b6a08764b3de15082146fafcd15c2cb54ac22c28790ed7aa799ed3506ed9bbddc943de7d04ba8f200c6c4e4bb02192f14518ece1a652c614c9d5bc14d3c0700396e7a80014cc90381bf56ffc3ba38aaa5ca520bcca8135dd8ea4f7d8129e66dc1b822aeea2e661516f34901613c6f088523ce476c7854dad357b30fd9040c8b3fcf955dd9a17207d6cb24be23c44f6ac7ab2939cd975ab6e998c15335368e3b38160106d90db73b8461d2ec5760f3945ec5ce2091379426a16e041db82d93c85a0c60857985482e61167c4d8a9aacd82b7055b11b769b1c89448f2e7ad5b1c2987106efdbb3aa7c2fd2aaa733e22c24a2294f6488d6c8eab9f5243bdcf41297f7a9bf55bf04d0dd30c008d9f0d23f5973533b4b42beb0d154b5667eeb219186b09313932b11fccf103c9fafbfcde75716f121a60a8df22c32108eff522898213ea00754b2aa1248a0e4692b963c9e715d3ba0fe4f464ff607b0cbe0fded5b5a0949c758a6e880b855e15ff712b52b8b6d4c6d5baf11bbdf265716b59dcce0da598b7abe5cdb0a60e02d428491bf0fd945be6c9304b019d8332a07d9fd71376bf722b26610a8513567c604153830f4d78b76671918991f00092fc2f865f246c26144e5215c044bb1d2c13bd1266789be8b91c5c328aff4eb8ed87dbe4f028eb325b6802634fe4e183200182677d45c1cab1137cb4ca22503476004c980a96fea7b36acd89d4aa77954981dea7b337ea52e5f402cd1c957f66061eea519cadf77fcfce23c699cdf4c01aef981109d51dbb467578f669dc2601544cc2ca87a9e1bad10797ed786da62ddf0df77e03fe4d0b251d7dfe1143a559c26aba5f86d20e482f6e19f51af4976c16111d2497a90c8b0e2681caa7b18570ed289c5d80114ed17ac3c1337b92aa2fceb2b295c2d8a1a54101af48314f25b59e15af9608169a22a4f1278f729085bd7e06f7aa294b678fd2684106a15ce7d01f51776dc3ed3d2d3ccee6e97080105d4a9f912bbb3ac699df6fde98deb97d2370136b701cd9fcfee975d2c60f1e310035085eb550018733260599e6c0826fc81e7f32c24a2d767afbc061712ed557544e45c070e4d2dc9fb4f7babc4023cc5238f0148f3984fa2b8128839dd68b96f23e3ffb62aba0e634b08b9f66ffac10441d0510e476731359e1bc7554be9d371a08c07f42215fdbb5a130e4587081720640c4eb4fff65c018a9835c623263b752bbdc7049a0c35bd342b45338d0efc15c9c11b3c3cf7e789b7526693f3a06981f70ebbea543a47cd257fd04a9bf712d045326a8c2a8e4982edf551179a8a929763acde13e9f6795c386f95e4bad314b373ae3ba5931522047f2aa583f73ddb65bbd9437e8243a341f76e1b3a66d60ecae2e2c9ac37c2ab1ab668fff8cd8fbbf90ef2a932ab04a165e0900e5785404cf6bfe707bfd7ab9a7957154429b4fc32749dab4598b70c628cff01a9a60fba6f0e3a80d615963856119bec5bdd56cc14e39a94e303e88b1e1e17954188efbca2b62ad5e06d146713bebf8df4f7de74d8e9caced2ea134da5dd014e5bbeb00c7d078e77a0496ac657c412bc14e173d7aa78289737d22346cae4f44c8d66fe1e6afc0a2eb141dd3e78385bd4f2f399d9c6ad73008e4dbe7163c3b77e129b707bb42aa624a0c0933bbc50aeade2a5475689286400b3c59d00c96371d65b645127a685069d7cfd4baf2b8020dc4f2dd3ef62adc6c2a99ad59940b17a5ff2f2262565c45da4b67cfafdaeb1347c34a73e286e82a9a711802a5b8723e401776ec012fc61602535b9953d33440e630d4ec9010df2dc4c7f7c3fc08347e4686995a94f634798322ce704e1612cedb3e32d35a2b0b84acd886d823ef9711fc46c657ea635834709ee2ccb1ef3917f2ad3305233f58b9b66e71114f585e71355de82bb5e930dac4e65f818e8c1a80bf624ecd295fd8dd11e06523db81488c079847f9f523e86648ed90e29b3188ed60ff6ffcfeb182d35a65372a717319d384c796a257f8011e4ea80fe54fa76d084b2d87bf2f00d9168bfd8821349c5862e0bb491d6217b5365c72a31cdf6ae5d8b71eef71b19be7d1d157f8b49e6f6511475ae1c11257f4cbe6a81c547b0e9f34a2325a4f87fc5ec103a1b542da3f3482b8274ac5cd2173adc20884d57d585a5c9006320af59ec5b27df67322391a6a899e34f25485d9d025bfee9f21a6d4a9879afdbeffeafc6f10de894e0ed4e3634f18a616a2eabfbce99657a9de036e8ae11c7bb7822825fae4a54e6b4f4f2b47d01b19e03412da3ad7818f7fbb0a623cb6589b9e0d2b037d7e75e9a233481f4bb4ea03b6d2c904e186ecc0f763e1feb28c795ac7cfc9666386309abd6497206d7a2c20099b9563c4229d2c07ded98425bc8444fbf5cec6a1fa2561f7c15645abe35fb32663da046d66802d0f3132e9101f48554ba595f5f159c091edb1c1df2f760e77b625420aaac07450fffcfa9b68d7549ea06d508f064abaec6a897ce005abc8f8dd86be8ce2c3cb0856f4552439d75d8183b2bb3b3e1f2b5596add9325b72e85088c69949703a87c37b0396add092da025794d8adace2dc339932ceb298a1f13aed629a5a5c918c136d075e3035761f526b14ec71db1514e5b8e5e57bf278a98dfa988eca7e943d112f90b9d850102638c44de9a8fb999db743d7160cb433168ea0ee63c9dc70c17f23dcdb10f9a46fa624428a29938b9b5312664bb20a922b3380bf936987c3f89171084473bb0e071bbdc326d55b2f656f666675407e983cca1b27a622bb92d661ab7a931286dde903dbd43741e614884ee349e1ab2e0742296f66f3b388253223852fdff63aaa241b02d735d18fa5be66875afd8b560e03c0371d218c3f07ff90115c83f033bfdc6a8956178fafbc697539ad3048580cf9df9b53ea396e15be7dbde1610c332f84482878da177f10e2759d8563f3d344254c54f0939802ae33dc02ee8a858e056bbeece5f5a848afe0f080a92f3522dc232e551891961f068997b1acfafa7f12df4cd6320bb544deb8d1a80bd8d3fd675df9fab29bf81e1467c009d12ce7a9235b071eccabc28faa2ceed59968741d8b41e47282142e9400ecb84aeb496a63a2036b56a977d4807fbd04dfad2459162e88c8c9d53da85aeae7a8aabe5f06128bd3fa1b52872a4cabeb3c5fb460169a41ef037e648c300ab93b15df7dc6bbc820ed3a7a96000c81fa78fa85949ddaa43ca6ebc3744119d8916e25e6a0f0d8804fda580c1afed0e14d0248d797b36d21248420fd1d40d799ba1583dbb4e66a2f06839220b17fed42f19e444273d4d8f7744c3b27c44785c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
