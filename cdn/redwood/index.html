<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0700376961b27e9acb21d59a71d6c34de419777dc6f4872e746e8491b5b5df32977be8fd6e625fb63075eda9ddd956379395705b15642d66c16877d792fd104d7402ae9c7aa1ed3f62965645cad587657b329b2b540c0b1c58dce35fabd3060ee3a685af19b4a90ee15ceb2926a38455d060e5866380ad6566e0b6243a120644dca7b40492dd4dcc062066a442c2a172ad0ad736066be508b0ed0b908946aac63d3cc7e6f8d33ebf920e2dbf502a48ffebc6edc6a51bb6fc0adf9250b0e41b036fbf0fd4d73bc111f814e3c1cc39d940b10b657ae6f06413c3f625328f89fccfa136019a20609e5e83ac6a00c6eef66fa0b4c86ff15770d9a628a209b34ade516044187ec002749967b4c0a48ed77b8aa61ca904c00100da40a1ef52f7cffb3f6a26bcaab8d86c575f18cfdeb8a5b7e45d5597ed842476521e0bad860c4b639df98c3e4dad1f778d8c5590ca843c07f3f8181550af16a5e674de21f4d13bbccd8a36a2b2b070e2c6323d19a9ff8e6888428d5da3547ceb2537894305750b7879e5327e859d358dfff358fe8704b52e368b3d9798a025397a6430aacc724d344fa3b81b67a23cd024aca1cc1134bc11c01d0c05b39b44cb2d1d02f46c39b51b23e00c2e3557be90d9a8a64310e3f7d119540967f9f6ec09d774332033c7abb46ef43792ac8f72633a024988284f2984de5b7f1138b77a22d50399b6d84e2332288e425210a40fc625aae0d6585005adb0cf70c4cbcccacf8e23b46fdbc197ee7e46749f30386ab4d6ff78b99038d9c515596f841e593c5ff4ef43b83744eb8ecae1aec0a122e54961667cf491ae8394b2f8d8e8640d46ee003b39418813836446111d490d09ffadd0a3d8bf4099e999494f74c995d6b4b750abfca87f9fade333ca1d2d26687d3416aebc0109d26856cdf596474819e03952aea5e01377f0c323da38b75d686c99ecdd095d69f43d2da5468da59abbca99d7fd68daa7f7bf539168b77030758f56d7591e5ad669b1834e5e2356344b3dac914f8cd10ed3cf963d77eab45148a7e48d9327e8fe08d576c52197395431847c98fe97477492b821617b809f380b1dd47a09ecdeba196e9d07939f8cfe53010b1269a49fd4b2ad7dd2e24c90c8a88b2afe63e9268288d0969ef35958a96d2649d8abdcf158c8c5ddeaaa335abd3527d5d976be5bdccf52cf486473385cb7ff59aa9a768232d97cf522e5a3fb4167c913e2017affbfc71a17f7a4b50793ffd1f621e4a168f8546589bc72884b817e5028a60ef27d5e4f4a0e190e5607d9e4dd1f4fe08c3285e62c9ecf211c87820f10b48d6234466503c96c6560dbc4042817b2e12d447a43621535f9e01e7fef340dcaa5ae409d3d9b7384abc3f0dc319999aefe422ed60eb4735838bc5a7ac36a1ac42f376e2b71bdd8cb715b4f8b25852e7ca8b054561242912384f45a5dbbbf9eb98bc1ec87f4076444131e10d295302020a9a713895ba593a529d26d676bffd2f2a82acdaba003baa8eb4ba7a2d3fb1c5e25a30adbba4ae5928faf0c0af3334a073c2b66f2792a29268d4706dd6b29b7ef934b10982512dd4fb2f8cf7e552485ec6f6858efc369e250db6bab92afccfb0faf02923dc30adc4ce6c9890573223aa8bf896e720fa850f48624966073363c8c4c01a8e763ff2863e1466bee4ac7d73955bc3aa21cdcfb512733f4def16deb20c66b5c5b1f4fb68d77c6ebf7a3c1fbe533d881083be7acbd013b9fedc93a1076e790fe16013b05519baa41793e058cbefbe2d4d76ce1dbf4481f29ae21b5d7fb0cb57b51a3ab55f48a0d4168ebdbb39817645b3bae04265a97e7c3d6cd90f158931313afc9d4be1e7dd49a0426e782a48aaef80f3bf23f418f4c906b176cd2703d2236470bca323de208a15231221363e6adffd5f5132a565c5836a2d38fdb6630117ee8275042c5f8d6533bcdfacc393731db98874e6bc1888656264d6280fa638bb1cf06137e6efd92c467a6595125a461ce1182b37f9b2116b0a7579370ad5ee28fc218ed90933976344e07a9fdbab6ce99eb2846ff4a8d436156e724c769c66101c29912d7e93cc8e821ebca36daa72ac5d5a3bde65bd2c631937e1fe4adbf9314bfd546b4ae2648ad98c69189fa51dde308f2baa8611ce6d2b3dff41976491ff9f6c4419ad4617f69a41984cd0c9683a28b9c07cae120519d3182686be8bb9f70d1fe76fcba7aff2d090d0eb091cda6cabe41a02852f917a0dddb186188560762fc1e752d6fa88498d103ae0176cd0d7a3eaf5fb85b472b6a7e094cdd9cae117072fc54a397518a322a85126ee5b40f4b95eea57060494ced8e95f1501bc440965b59358b83fd90b20acc1a74fda7fa9715eb124dd240ae552ee2695cc961abc66b1aac988d8633349d0569ef8e0cdace21677e0f0d6472e21180a80acffd2f4549a85c94b79afd4fdde2ebc367cee15c48ed6818554b8151163958d1f955d4b8fea51825e739daf9c0f7dd892ddc8d19a6d89af5fc3768e9d01443229b6323ad71e058aa21e326f0bc305fe0bf6eb1e99e12a6bd4f822157aa34f83b55c5b370f92bb0c714a8eed0113b80434302c51c7b8e36739c4b41784c873684dc633e22c3efed2eb4371913ac1def53c20edbea56528099994656566353f209c5b575e4179d67c7ffb89b80f31faa12e24f1f6cbf48cc441bc2bf56303d094ad35b00197ad746c5f7431c888ce87362887f713c663bed8a15b75592d341043d2440aaa87242e3c0c41c254ef1abf4a46ee7775c7e4706e2c99584928d5025c828962d0276693b2794722926ad451bd5106caeeb67c772674d261cbdf4f455004e8d1e264d76314a00fb6dea88230cf4e313955147ec529f06a55876115e89bbedcc371ed0a91abc40fe8a46fbb4a9f8e7d2b0fb5143f83b09ac6e170a3a79a1508e4daec9e051a5e56691e7abdca85691affdfddb01ef0459193a5bb5cb2f25581032380816aff442fd806025cb7b5012274f67dc372a5ec70ebc4a54ea75d3cb3550964d3ae6cba2aecb458b58e4615ee9be3a3dfe75d46fc7822f9eb2badbc16ec904b7e8426855b8cc873250cc7e8074bbc43cbdec27d7492de743e83caf25644dfac33fb5dac2717d1e2f94d04c12bd6e452bf8b516ae112e4c6859e30c053c69ea7b6ee191a1336b1dcdd5b99a0ceadac39e1fb3792b676f48b17fd996912471df2ae8276e6b0f088834c4ef4b63ab16db832bc241ca32fc16f6fee6521d9795ac34191307cbe2194a3c45d86ecc813f287efe3f7876af6f7cbb860a16929746023d113c0d8c67ce79b011d6c19a89565630902026b14694cde54681f10ffbc1fa5436c529770cc1cea517d81e5bf081d1b2850b092d02dad99ee9d127b54137bfed2c150e04730f0695dcc427d5c85e48425ee529369a0b98b3c3d3e859b747ba1187674623de0f00556aeec71f2544affbc07b2d18b7f09d9ab42ad40f2e62546b74a090a099873745c92dd01901c56151f6b73c12f2617ea714d66746a6c986a7b074c6d093ad2227d81fb6555afa498bb2147c744b405ce27b65dcbbf7a32f4716b19f8e2a9a5472c7fccb3daa2a8e20d3226c9de3a87751f2d62e7181e85d711ddbad6c749c948e69773453c5a147ba41072eb9c7497dbf6c0201387c41b53736672786e14f94e689c0339ef209ca975fdd648be0c3c606d2b9f63311873a489bb80010921197291988971e0436cb3787d3e3937407861d8e506c89cb390ba959fc8ad719f90a45b413fa92eb98828d6c59fc3ce3e3ddf4a6e46579082343d51e246f1c67535295a507f3a25546841c8d0ebab539fc2031bd7fb39e0afdf9a6670d155e7011cd5f14c48371ae4bf2c72069586382cad5d7f553a939fc17e4b1ff8d53a51850a9c637b0819debc4d48e9c0ba73ff120c9f06e28b6f0db2fa2757063912a77b1deb72fe212f622ea6a05c13d0be4327e3bcd2450fd91a8bd3450067c3b0d9a097119d5d101426a47f73e9371f64e79c6b72d9d321232f81fd481dcdcfd4f074c725561d7559bd00d85d5b4afac169995d9c02503b29e4db6ca0fcb9d82585e998314a839c64b374d3b93fa95e2cc03bfa21b7b7631ab4bafaedba389ec2810127b55d7e78ba1fd30d2f04aac787255ef6088801ee3f1645afe600523145190a2488f69eb8474609ed5db6eec1ba56ae381d70262cbd1be5e9fb9c3621f354745d11ddedf6b2b6d5aa07bf2b6aadf959cea27e7ded6f526d66bdecb3e8fb1a9da19d42c4f5361cbf417b24a18c03dbf651dc118ea2c0cabfaf910296c48e11571a767b5df7db26091935f98f256d23d34fd7de35414769a8d34599a14b5c6c15178c46730e7928b46fa0d6e74226738fdcef016dcd5803a6fedd9eb2f3f88f75437c3426efcf5bfa9c8ee6062ec2dc2c41fbd7f9805f26d566d7b5adef1a23f2dec8c83fc461e206907b79374f343f4c11dec31ba4e387110a6c8e88cdf166ca4dcad51ffac08cf3f5f4e2981007c9b1126a129cdc47a3e843ba74538d56a9a92e037078a5b1e4bfeb799205c754361ee7b70ab80be0679f51e403bde3b9c2f7c7c17bd66b20fd9bb07dbdac1479a1d95db3c1a0d0cc40fd3a832c308218bce9c7ce9990c5dfc9e29cfa8e17334fb7f378239a8a20c6bf08a088bf48d0e0a41af59c4f0b1441d5adb77e5f6cb5b19d214bf335690e108ddc3ee6b445ad7965f9dd4e0916bd289cb7c96cc59445a4b2706e9cfb123937c57badf121653f18d567befd46ea75f6020ac55f45e4762aa4973ecec4362163ab08f8e57fa1fcdb9a0e56630ced5db3f295f54ae07f37552eedd21ece5a57a212089c01e4875f5be328d5b3ba915010d918e839dcf0077b49afe2b1132108dd525beae45d3da8d4ce743a8e23006428bc053932e5bd898c7b4bf9270daff78ac4d842d087b74299258789c8e6bb640c7fd6792b56d566fc9594ff8a5771e5cd7a9c6210da1e41918b891d9bf8472d59f5f168ad7c82be3bae1063ca10fb8ee81ee49f2f87017ca92287e9627213af8329a0f923158dca8435c9388378571bfa78fb1a90d13cb69fbe76cb7f63c7c9864faabae63514bde9f0ef396a8b8af42796d57b3a47edc796336bcc13c22e02e05ea045098ec2646566f7d2b27f2f6880242d7ff2f03fcfe0cd722fb36eca0e91dbeeeee7900483ea0cd5baa6ecdbe56010b9a762850e1cc87714807dfa4ecc0af66c3a3650e7df298970c642619187fe3715112abcec75edc55871200d72de9d2cf7c8225c0d4e867fc6804387a74deb011dfd8bb96fdd9797e7d4756b9e16abc5ccb0799167ab7dc023db6bd97ee9208c9c10d9fd477c189f0109a8ff3085ec1b1b301981bafafbcb9d066b13dec7085416ac71f504df782c9099005a2f66889905be540c97822aecb555c2ba57cb56a2b9e22f7c984d194f14c0d7c78e1bd7a22fd53a76d9e30628f551f80de2e397f5908bf0c90bc7fbb83dc71109c8607d9de0a793ae010486f23fd272f16b34587b9349356d43195f26b69cb91a032eb3e91a9fa74b7889760f569d841b081386b2e128596d2aad71fb25e7cbd85a2e7138a07c49cb85732cf56a42b8ab4e3dfb7e40cf14888450274f3f71eae13a13d060abfc4d108962614c63cc133d27c8b8537ddcec8210827a42888d9563b0c2eaa930bfcc2ebdebfb37997d2630ff9939ef065330ae13ec3dfe71ff7231578fd970d403054aeaa79542e985434867945bb5a725c415db26aa1a070f36b026319fab264fd17ddda7598a2608d0e2f4ee0b191d4c36d2292f7193f3e8ef394ee6a816aad36a1c0e66ab06a7666f3d804dc6b1503aa5464899ccc18ccd461dd580f812005f324b1f0ec72c63dec72c61ef640bb1ec468b4f93f92dd2ccfa5a66ebb668ffeda528e045ef3ed3bf2780f0f290093879243fc3d6a0b140a1b1072ca0751203f797b6eeb11924b096c56e16e796e3ee6c3c0bdfda6a0fc579545a99b690c90c7a5a9129bebdf68886b2b2616d3c14aca7f8b063c8267cf56cecac92f0589b41cd5dbb80c76fad2fdacd79bdec93c2b33d822964eead61e0dccd754e5411eabb1a33591033a4e7da9bf48bb844eb8eea99793d51ecde57bf58737ac4c6e696a7bef734e47e5cfbe2cca6b813c8f19950afa57c796c27968892f21086670966e83e110e7fd3c9225a65144fbf1b364138aa3c2e634bcbe0646907f52c07486a67fbd2e42f6ee3d1102f473eeb46ddb9d6352f2d4784ba9cc3fccb091351656f2702684e6d062be58d04d7256aa5739144096dd65bdc1ebec033b9b553e0c75fdc400e8dd12304bd852d5a8962397c9063266a6b150155899b8cff5544b16c59f2159216f8f975d31eb52da8d3deee9e875906edf788aa4eed24937dcfa37187693ed90d2b226266bf6add4dcdee6519f74d27eecf71e86d078ba580d33a0e93f01014fadda9d36645fedd354f86dad839d49d816b87cedfa8d4bbc7e0a514082ee7a162eedfd742ea2dcec1e1f99f65596e94c15d5f4162d9bbc87435f4234b6313244bb2bf1eed5bcb6c0abf18e044a637bfa8d40c9171c0fc32ac25e46db10103df1c6a04fd87b5030732c5ce6ef41021a264c0af5bbd2df9ef08ae473e805bbafeefbcbf71e1b01c92355a1e7d82c1ee3926a8a8c5be6b602a8d97c3776fb4445ef96d29337b9137211d34ee89a06e94e0351112a896f1125d8ed504b851456420fd4cf3f9a99884977f66b35e3b9945320fa6386b550cb80383f95cd411be8bc48271d001e0cb8c825233da82c3af8f3106edcea0196eda315bca95986a8793cef5eed3029afbc9a66413274b05f584530e733bd9810f9ac248cf6c2f3f1c3af4fc0802e50aa62d6c9483bc58db2fb1bea918a4a96a5899f201d74cb6a29a42dc330b1025eca7c077c6e3da327bd9d485f16ee5f6257ad1291f3ddf359abb0aba850a955446dc4fdef9c55e88a1ce9225dab4b67bd8d4eedfc6ea054e51ec03241f448874ac05311d48df994173d9abb4390bdd23a414eb7363edab40c4dc2da1bf4b1bb4008f53180d769dda20d2abec8b0b31d6686f660e56c04b8a756653678361d056bdd3384ce55ca8bb6876b5cea0297d10d3dc36dd5f83ce19424bfe93c2ea1c13787dacfc82b49372dcc5413091788cb781ca26c715a3aa58a072d192f0d22fb67b542e521d5abd7ea1232a2629d18d922b7d9aa49181b43ea42bec916178d267a048d935e3676d2afb7678541b24d9e7127de00782606ba4455493cfe97af0125618f0a115e1834d6e47053df4f4c1034b4f7b46e448cf98b233c3f027814afe575c5ef0ba4d27976c95700e164af3f0e268ba8c76313d0772f5fa78c3e712909fb0ca4eca5c66b15a72d523bfb6ce5667f15b6a57128c36d22d1df8381e5e09d4eb07368ca5d1e5fe8352e476ae1cde60121c29beea263a398458fb4a5310a307b4db5f50d339e0cff712ab44543113eb7830ba848938867827ed84504fe6d9572683c3200c26a1301dd375fd2a15828bdd29485673d87fac8f6ab18f3b7e000b3d710002542048daab9c1be8585dfac465e751e3daed0c00fdfa2ea097af3f2c4268f9e00753a62afa5adb834c82ca1342cae6fc45d812b5458206cb689932dce9bc3b27e1c8b43d4353b7529f0e964f1769414f51f2446768b0d90d6eb03f56c2bc7b7f612e2eacba95b7c7a6fec300833d36a9ebe120f22aa7ba8cae142c5bd5ae52aada47787e989790b15455c68c6a0b35e0ee178b8c842f94b3cc5c3e09bfbf9638469ba658892464d7136d3063d5f0393421557093eeb5ff03049964cb1018368aec07dd838b2b70b13a2e1d5ece82ecfc40fd2efe29c6ffcaea8015a83325f44b6edb0ca1ac81e4d4d038525dcd4f97f868181bdf47c4a7200fc03214a05a91034dcf7b9f6143f7a83971511d4cb8898021f9f0ccbe80150b4bd08623e82046dc0f9fb71ec895d6662c3cdb08e117e961804758d9980c2ca6b29b365f017277a7e3f0db590cc8a0c0eb3125944b6912ed0d2b787652b1f69081f5522ec41732460aa308ceda4fdebe20a06289fdfa14ab102ff8408ad7e6e9f257fdc280c1b2e846cfc939c1c696e3223be919265f45c65e9c81f6d33507532319efb0e17780439a3644229362b6d38739306dd25bd4e192c8a0f5958f57ef3e6ef0d07bab4ba2075645b9c8ceedf8c321c9fa40ace4766f5540bcaab7f3288e65e271fc28bc4ce6c78bdb39a8d2729dffb69e5e6184c334bdd9daed01bfe388706796cc294a84373f488a26f06366c53827d51cec0d831a443e8556148e242cdea669646de9ec55f8d545580ef0385bed3f6ecb13bec350c975105391b759877968619040f28b6c4caa2c7cb193b6a1c9f441999dcc1d48c0cd40ab2a085c5626dbf26dfa9ad8fe150a4065673f62d6fe873bc64adf6779a8db4eadb6fc7b5f5a6239e225f3f8d910f3705f44b293524e9eda39c62aae3752ea38cbfde23a0a2dee92497ff36af92cea66301458a9d6808988b85bc34efd08c507040a66f1db8c1a4d89303cd359e5cc210da9c8f863ef27d39af1f289ba689c67ce96f4c4e08733b08e617dd2218972199a4e6c12cda75e934c51bdcdc8daaedcf2acded849bcd99ec2402ffec2e54cca0f502f1d5d42a2c6481c7b9cfb5b99c4a26744b8c7d55429f2e238e3b2828a0d507dc42b52396640cec1abe16907aada9ecaae54611d7268fc0a663e99c5dada48a4db1e56f385a09210c58936e3191ce52be83a4b272e4af5440e8257cbecc92bf28534000d33bf9366011f7000293a4c212497853469ae9f5f56e4aedf0429fd25a5c9c5883162257f379444536cc567027cacea1d86adef90e582ec8a8c5f290ad12be29d35753bf50a5e8d0bd1571ecb5507f56d125443ea4ca7db1984195cf66e6b94750337f77f3b0cdcaaf71f47dae400be5ffb6fa3afed730f16524411a634370dc6d354d4051ada2d041b168818aee97495729f9d176ab88f7835917bd2c4c2a6ea4112091092eb2d78c079218d9edbcee9b40003b0ace2b2d14b9e297d5563a4c11e39a3707e91dbc57bdba7b24ac0d18528b3c8c301de69734a4c1b3f67aa04c7055bdb473ded85e21793f0ef0ec00d57194af7d0ffaa1a1be25650c1f7a7c9ad1e9c94ba08144b8b1ef0979a83d42f18b4c7b1baa035a98d96d5445e5b01a767228dce4c1009c3e388d6b18901baec087a21f7f044b2ddddc9325038fc400a762331e7be9e93bf3ac212c9f023dfa116a5001104fee27b228ec6ef3458ef3c793d44f8cc541d8ca7d33956d7cb18b140fa900c2899cbff134e0f60de3436029f819f2878a714d88e346b10a29bcd8d429341b55b6e805abcd66110369402d7f56ae6c0d2a61af48edd22328d7948a4d2dce63c89bcd336bd49760f20eb63267f564c52105da5cfff593fc37d2036f001a6af72f8c3619bd4bc12b763975fc97d3575b3dd1437343e3ffaccface4441a629dee866f681ad2e85a98c4ddbf3e0f2ec10327eca73550e45d0aff1760adc6f23764f621751dbaf659f90f39950232ffdfa17d29ee76a12886139c52dae9e9e1b5668825238f31c5104f06dedce495489f3019051375a33aabd8a182d38822eeec07dd547f033a9ec0dff2401b90135632473094da05f31eeeead9f09329d541c0959580951ee10f9e872090648359672a9b2040efc43fb8614f51f6424167bc34a6e6882252cce31b6900b5b89c82290729030c0f0e749ba2e7de1d6fe7ae8b3920c74720eafe08da7583e4f5b2095532076cdf7d07f19adde7d748185f36dde92a6c765ce7cfcddbf0fa07b1d0ff0a04e08bf89159fe46035dbfb277a391919a021ea4be7044cc3a81ec58297b9cbcd96a6b3af2e193c9c888d28e13bc82681b667e170ddee767faba8a2cc49ab56fa6630877a7c326c885600008c2338f1b2e7526c55dfb73a5c4d40d88ff201b18d2a134c9a9d61a23d45fc6b1f0f0ba89e4853557c0bb6c183e167817763d8eb9032bdb94fcfb41ccf28264a55b945a14c0e995b7d1cb57a8e6aec0a219680e8580c3ae0c46ca7c046c3682c7af6e37a156b57d856a4a792fad643fbe502036fe9586c3a98f3db7bd8aef7d3a755f4313a83cc20fc456fe2836a1d8dca0e69c04df83f3134e9c37baee725a763b882605034c082816c3544b677dfdf664d4ae33e1d1f7b72d980c1f90a599472d8bc9feeb241c2264528039d4314c27446651996a99b2dcf09d8d16085161da54025d339b7f3522d0ba4af426c92ef24d3dd50fafcf43fe3fd005b576c24f1949be3e1ba907d6f21bdc59d1e47228be32a37eada8bf3e5f2461d70deac148ca9457c6e9b4f7c26cb5ddc08a4b24c8ec7b76a4ae9681e48da3d084577141be3dbfd9abf331badc696c068ebc641371d8a02c5902dc297c8e12ace45f278f613632eac582f9d651403029702fc6a4536fa5848e33572b23f2df7878cd4a11c20f54b8c7464adc5de5590df3365c88e574382d57ccdb798551554a0bb515243b9d3f463408deaaef866613260f71aa1ebf7b25886efbc8ab066cdc0278e6f1cfb5e338c742f873a0d6ae03bd72ff8cbbcc3c87d66c359a214ae24d23f2c387d46b201311d56b580d8c2b5e9f62e50123ae617e2cd86babc58521f98d510ab18068a1c76b6616bcd4e59bd1549c8747cbdc9f127e730ca7820419fb25073d18760f97c82725a54a039447e710bd0fd4008c519d70381b72d9b06a87be5bc619e4fdd115fbb8b61feccad17af12322bbe9918a5066dbc9d30e429e027e80ccf3643d3e34e3a48962c4a70778f6a4d4b346145014920e6f9a0d3d2e05304ff9326bfaca9af6be584c0ef96a8219e76a0757bbf8f3a20c99243da0d4c575dddd9f02f3f1df244a58b8db9ae8f127e5806efdf94cbfc6174385a2a7edf09c47a8e2f3caaf30df81f4137d446913716efd5b47817f92efb3f74b7671da19867973d95be65d653361dd341635ca7a6e539dc500bd5d4063bf3739255357b203069d676b64e2088cb732aa6e22f3e5153651694f4bdf350b3a1b1cefc0be52e00c5d024a81123476b898c5f6bd776a3c7ea2d5d6df0b8a43ac7563b653a2116201d3bb685bacf2f3c08d11aab757d6ec081b38a61f0e4fbf7fd953e44080cc4428c400160f7c490d9bbdd84d6981c4a17a19969dcc75cf008ce87a7922fe50d243b2d4d8a126bb9bee255227c1d6aca4c8548f115ea09b665a5c6cdda51e685f00a062f9823220b024e23807a679c6f916392488ee059e35c5c9894653cc684616c6c3847e72511809c07d4bdb5818ff9e5528e38674e94d0611d9f886c2594849fe67f52e9be592e3b1d7f8edb2297abe346b6450d82be9e8b5db272d88ea0cdc313eac3e7c9a53c007bc903da51cb7df03b47858132dac42e75dce90f11d2012afbfb7b15295421064aa35f93dbf97c5fd3931a595bb52ff310d54acdde7380465d5cb885f261629c72f0c646ca6b12c77493ccd58ead6b0e21689752a132f56ed8a447f37c212803ea27d8288b66f8bca952e85e9921d64bbf248b477aaada334879bdec36e232feed87b7fb2006c57914de2e27cfd923d27259767f10c96ce746f78a02014822597cac8c1d01fa21d95707cadbac2e9a6fc84dfe1c1530d2d7f7d02d1075b6c3c98a3a26eb5609a2ef2ce411fe57ab8c41cc0b577fa8f273e961de16b88c25737cdeb789d18257909daf9d7aa758d98590262f7a541c1746bec317bf7356533a0f6bde6ccb389fb4274760a47613928c15ffa6dbb385c6ba83539fe8a7c9f3208f0fb8ea9122111bb5de77255c0520829233cc1e35a9d0add69a2046f93faaf1fceccddde0a0808a598127315e21948156613a03c770c42052995b7849c19b57be571a673a2e6fda7b7cf11108367235566192e4f1d77afb6a0fc4d0963f5adef551110e82a958b4812003b6f151b868a59636c8177124eb3a3241c4cf294939dea5435250d57d31b90bf1c071fbe4b6a25d4804f336575ac922be9a14161732596154a67c9d483debfae25f8e6be59d3977357001c2e92ac728743b555586975d9bb1bf23fca739f2e083ee4aff5ab4c7fb909c20432261ac0f7035844e7d85cbcf64aecf817526abf31035c2a145f54e10a5c243a989d9baca371d156e26c760c18a604dc1c5f25dcef534aecf05b1f2b68086aeb385406b8da91157bd40aafacaa191c6bf719e5ed6c486ea2de7e6911a8608bc10644cfc0b9da630131ddf82d6cef2f44b27354738d2b351a99428d81d3688a4ec61a2c8fe6bee776dcdd5bae3bcd4ea8c372e55ddfa4a23e4193266c8033c8446e0632b7abb50b1659563b62756995eecd5d07866361c1ab940e39bd02726478f141bf04942410b5b7b4c673361cc75661e75162aa829aa2b9ba5dafb2eedf38ad6370208b97563fd52c193b2a8b2c87bd232cead08d33d12e6c3fcaf34be2abd7ac2779f329642872beb05d309e071f331c6a04256c1f3532feb580ce52755cc1a912198d8e92826325d4c8eccb1acb5958d1ada617dad251b0a913d71933a24fc44bc12f21365f2ef11fc40aabaac57d14a81861e2328c2a1ddbda467d93e09748f02b4129a263c37131b5780f9db976a676632caf080ed183e0fe20b29cd397d3b1a3bff201d4a685ce5c282b6832b3240408f2d50bceee565e63bb4250b771271b4a91050ebd136f50d349c368ffe752ab153f70a8e07bd9084842af8a499fa5ed63c6123164735b9202c6ca145bbdcd5edabe81858f1e0e548b7be5a37122c5dd9c2890052112fc5347e586073304ea9ee668919a698b74906cfcadf0adff4711ab0458e8358b47f6f2f51e7724fffb4a90e210d7e728f3b693be07ea02f729f37cb2e28d0546d0ab6483fc468c7b3c06657d272f7638f7fabb0a0562db325fb87091dbfc418e8a57b3145e05fd58b2ffb6d1fdbc9e2d293ebd287c18788d16cb1e6ca8235bdeccd35096b88feff60e13ef4ec45dfc9a9f19e9831921e255c1d74c4980271c467546d28dfb0d30872292405b1adbb2324be8a8043e00781f491846cab6943bbbde2db311bb6fc91e378855b3fe38f8ed650a2608ebd2ffde386236b0c14012c466f3ecc63d1840b2066d9e6844b4c604550d358c7063d53016ec95e9a69672de5b79650b53fdaa98269c113f16d7796698eadaa562c126d7c711ccdf4e5d713372664a01721e50df834cbba443937fbb8be27babb865a9eae6a7aa2b1f90d53d68862b712264a966389fcaa040de42b5a6bbc57f9ac57f8ce184897099a531d016c9f4b33f5a7dc68461dca6873b23a460090eb7c1bebd91e29f164ab05a3aaa04e3c6f571fb30a80570ab5f999b1d8aea07b65d403fe144a5d14cae7fa36541da1f7dc1be0e6a7d23d2c9eafa5257fee0ba2bd3bc0d3a469e0f5df35e901c41a7a04394aa1a8161c00e6836d093fff6b34d037c5f481e9ac4f0906395a690a9beb453e7bc10a8c7fbaff02e975d3cc98f28a732c9a42c850cd0ab1f957c9bbbc53d981da56650a72d215c42a527ad1fd5e881a74596e88209a6a0a46984fbe116be05bdc764453b6308b8475be2d2fb22c95e751e8a9a827ae927b4e7b8facc101fd770b288592a218e656a01451cbeee1243fd141ba7b88733533b797e72171f8175ec74787e6199d6de7109d56878ebcff08181a430056f1ef17d1221e8e767cecbe1cbf47f24354bb569bb18a74d96c8b72dd695d44a2419ddc7b1b280619b33987682eb38a000f5a36d970ff6085448f5ba15ab60acb3cee4e1d15e2f0439586212c8546b991e0c72f27cdccbe6e6da355845c9e1c868e088ad431da8ee28fcf5826933f255dfa8910edabad5bfe9e2962f589f13ba2fec1ee5375445a8973d68a0a6f9e4942797db5c4cacc05f1d60d513719bbbbf42cb26afd42b47e2c5366417542245d94dd81418e51645dd40b3f83979e67646dbc6b3bb72ce75557d94603eaaf522c2a533e196880faad4436ad171168eba28af170c3e9197f4a32782fa4ab2b2fa49bc53c19b7ab7fa3c0498751eb2561158ed9bc4c59678836100ad45a03eafd027c752afb7ffda10f8645809b1869360731ac571eec5e94a16dbba3247e0ffa696b3b96a4f65cafb77c1c74f40ed040852f67329d20bd332c9ad091c276d6fbe67434d0f678a0395dd5b03be0a3d8170df227ad2e1b7e50873c7447678fff0f6be2a347bad1dc948fa8e602d73ab237f47695cc4652b9066079dac180b420cfd2111ee5b3e9f2fc7927bf648fde76fcef8244af65fa0115144f275b20eb7411a7d9bb51935fa245e432149cf353fc9894d5ec8e2b0e184c869f619a3c611b23e065ba11b5b4bae052b58b741bb8af6ffd489e224661db370c1fc497db20d7a2a3340f7890c3649e4645f3be44a445c0ad59aa76ca4c1a881d06261e8fec6609c3084fcba3e9bd56b567d657ae517457884e1b2615c0cfb3a38bec31bd89677bd63772322caaf8fc368e990af9985dfd629986747a030c7671735f0e8ff80e0fc87775793cd514574fc5db15ccc0b14559f79aa21abd74e674e2e13e46c35108ead08c3daf43facaef15bc63b568ac676df3df95174412fdfd8b290eec8dd6fc909c5f8d3685acbd5beb8c59e22207d84b6893b75d708ade3dafb105ca2799a9acae91ae3eb77ccaba69d23bcffe35b7002761c2a4b91a1fe2f9273e1ea72aa88d35416ea9c25a14634e05c9701c431b5943d43246ee293173dfe0546217b351205d0b7caebcf083eda116233c8f1c4e4f1623fc43ee4bd761472540be9187ce978414701d8500c03f9103e19c75f99191f003eb7d717a09b306c905cd13f13c858b6835f2163c93688dde5b85e3ea7ccc63b4abd18a968ff2ad057e9c9a940daf0beb2303e5b9304994d8d69ee2438510cca1b19d49b7dd79c5840b454ef77ee207c16fd23c2159c8b4660d858007e13a238354cadcd62afcf8be679aa93c7c4c24b3c10687c538078ce8fc7f2de32a931d966729eb878a99ad05d0a316da8634edfb6cf169f2119a829c2ed2f67db1463fe5fd5d83c3bd6f4961826dda3124ca5cc858515614c56b3f7ca799ebfbfcaeb0ca9237ecadd95c8dac56f9e9df81c8cb8220df0173a599af9df4347056ec39fc5ba31e4f3dbadb18e213945ea08ee09ae355bac3d9cff00328b547561a3fbde239fe06171287848b49cb22e1ffa4cb3e8e298ee02e38cb6b099807ab960ac4c4bafa87c5b156725e68d085db1cdf930fa7799ca97302d24f448f20374d362df56ec461ea2db4634a39bed8383392b2b1933d40fd9e1f93bd68dd23bba1baa305b009ff7f762a86a0bd0ae3b0c4c67758b88d4837ae1e50d3ed60f36bac1f5a028ec8a6c92a9370daaa979d9a66a93651d4acc7169669ac38934566a82433b58c545a3c2456d702a6af95b7ad1c4d4c8c6ab0eaa857e3253ae658b3f0ebd8040999387a6dce975d7ffd1e3b0a452431a9dc2ace9b963399ecd7b23bb88beee6514460e2b4be65ee9f98382f9babbe2fe1ce1195edc77418fe74136bfe5c65cecf0988519945c01ee1b4f95c7518b5376ad5eeae1918ec8af7e3bcb2c037367c1840c6cb62c969ead3346d109756afecab57e631d91d1b9bbfc8477f68fe7a4d94bca8ed6d7b2e3ebb9eefa1ea3abab3ad99d849c7fdf44dd19b66e6f13935cce6124852d199738ce75b0656b7672322c809d677bd705906511277d377033e84da71218646cc08951245a1e4eface4a093bf31b50d7fbb176f0627315c9901fc46e7c60ee008687339b391a4ffaa181c756b1989b13fcfd7ae897436c781f737d6ad3fa0272affd97e5993c1c8ee7c700a56f231b81e1b3c5d10554a31298ea576be79b08bdff3eec42adfa1612b17da905cd0a0bbf2f2ca0f61a388dd11a50bb50bfa296c41ccd4af36e39ea1e039d3ae3f46d761da60570450ec90f6e74d6fad17634eda21ca4e38b063bd6ad0deb8935fbd918d87f171066764e908226e4b96dffef3841fc86043faaad52f7e3ec5f2cbb4977d2661f42cede8615305099216db6d1bf36ddf270b54af0d93deda353c66c2743f7bea1c10ee2191b487958672ffb132636cb674e269f777bc14585d53895e63b6512fdd6054650b93f755ca07b3e9e56d09b356067775654a31d62d11d4d259a983b3c5b4318abfa9699bc8ace2307f54163834a498dd00d0d960e5c1456916ce8395e364302cbb8edac96df658d72e52d70f114e4a5bd66c0407639a846c9ffaa652344301a766ec3c9ab872e1494ba8b90941c598979d2e525de80e7e41ed4df308f761cb78f1b7ce9eb09863058d70b9a1b16f3097c82a5f829d519c338104417ef6c2b806f17f4585d4ceead282799f50d5fb65e01f8461e5eab488446023039eef84c250f3ca49bdaf7904f29ffda0d3751dba6fc001bcd167b9af8a2a34a53575587131b8318b3d9136f852627e3f0636fcf054a2dd864db9e5ef90e9aaface577c22e0f0d1c6e095431b7dec4d25e8a02f87a25d0c67cfb2b0ce0314787f51c2988795cf6cc99a59a870f70b2a04619526e2bf92d08774e0f3b1acc784ba20bc50af4b370bfce1d82bdedb39b21c81ccb2e8f4cc816b5007147aa60e9ecf1059b7703581bd861ecc899ad8f3f9a4037d678d68735879e32c6a4311bbddff851a82fc4aefb6e0b5567be27ea447bed82bd38c451d88409280c65a75f674b29a2c81c42ae7285653c31bc147d925f59db481e736e1ae1b53398a9f3451363a26cd84bca210aec101b9f3f85b341dd1a7c18c9bc75bd2a829740399ae0047b56d79ef3f442eabf2d9fb2bf47e1b00e6ab634c9f2c5ed706e73cf2e5c696cbf559fcf10cedbe8d876d8048ce086c5cd774748b6729cd3cace8b001d61417c902d321ee6e3a2845726489028ba8e2cd7336f56ab7f335404690f6509cbe1b3e78872bee89873e75fb4930b29378ca2e914418d8f30e5267573f42be2e34c2acb3d898ce672ce44128ba16ca926e12529d4c039475daf997b4ab14bcccb0970abee034b654de3ef1e90f32f75b930b50618e4cb7cdbd8114e8ddb06c9ce328cea7d9434be10b2f9c02782b89fff56c5aee5f8347c5b7f79ec21ec99af50aff658cdf2b400978967933fed493ff46cc84b15ef20f8e42b6e7aaf7aecf5f45ece2e737b3945340a7a2cc7998f655a17cf06cefb90e90752d12d44adf83a3c6a5798271207eccd8a6ecafacc0b013115e2ea34f8bb081f8e159c144b44af1f4d3e4572fe40a452d25bf68dd3c51327130d0f85cdad5d8c89d3df002698321f91f6c47babad7de7e761c61ff8ffb529233c80e86822c2db3fb9c3f8079b880bd0a82b93feb6eccac8b52c388a07e08795f4168af2168489caabb448b7c643443b6e524415b4da040f323f8738b5e942f8b2ee5187bd350a0d55be7f956ff59b7f302d2b4dbe9e3499c39c0e41ee120e868a1ef24303b106c7efc68196bce0c17b67bfa78f0d53d478688e2b7068a84d1d38a4eda99b432e7021e1eb24f4e83282f71566063fc43839f1d57d37280aa80a6b4361cab20aaedd6bf615db73e9686b4edb87b52ecd12216fb32f99d9fa9c4a028d2941873a1d2ea636cd5ac30ded7d582d185a5b600c3f4432b25796c194c054ee82d3ba05f7f141d0a1eb4f8e68859af147d0c7a3c79f2d06c53970e60b412ad864fa63f87342980cc2653ffb8c7ef96f5bc7545035e8ec3675aa4f99e33a3f883744df59bf18475dda380c4be42d06085a1d30b638ee3c6e6e6c1ec11c15d6a665d0dc67954987a3b81771bb2f7541127bcda04e54d1289db33c2dff63359173cb469b98ac80692d5d0883c303b93620fdae759030fa0567c33146fec6ebd1a1fa8eb15110fe753df81aee1cf40f4797f44d58c06c82d4714ee8640a85f2899010e7fba44611f02f6cdd72305f38fe3810fddcdcb0bab197ff048d15703e07d9ef522677efa0c8e76543e80aa01979e28a68e1163092f3cc3aea7b1181a49df4b0663461294d937eb07507d8d8345f7ea94c6fdeb7449e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
