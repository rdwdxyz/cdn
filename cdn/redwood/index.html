<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c370e875e8f6d08754255251f5111135f8afe200a85e68de5c90e00435a79337a4824f910e408c1308ade92bc714fef83c846b93cc6d20c02784bd3e3760e4f96940116e0f26bec47261c48cc129dad8009774fc3033bdcdf30927b990d741191c464663f4b9d287f6d82a0efed7d8c6fbd7e73c992e3f8d245856097ae084238ece6da2c320708ff4562484fb2e7aa84e5ade2c05658242ddfaf4a1cdee21668a20b2b1d7a1d3acb77a8b73e0c05804ae28b06dd908fe2c0c66fe9d7f6f3b3b522a0b4851708c0c40174ac66661dced9ff03e95b39bd870a7ecea7733f2a5bded3b3b4d49714ef03d1bfe2c0f6b3d7f08c13f642db55ac61737febcd0735a5ec27e44bb95d0348d340b2bb57d638d5a0265a6b4044e56b1a6da2c2e5cb489e8497af004217afc9cc8b99bfbab47a31dae488daa30fac5bfb357fe11706bdf5114d800dd7adae2ccc7892146f2bf1162b00801acc5e0dfa3181ce75107b82d10ef6b1de2b4b3cf88193cc31cc7823ac56cf4439ddcb45b08862d72670901e948e76054b713f9f7cfe7e0beda3a02fa250595e11c2eb9bc2626cc10a8ab8c5780c35a7fa40b94aeb136ddbb1d3d84417e647de385e469f5afed89004b335341cb7500325ca25eca4a6b26190c167e64dd8fd1dea0f2f5e612b493862538a2a4de63fba2f2f353b9e0f7839d4247faa171a4a8eaa0d85b4dd640480753faa0779670e0d5b7c99b8ff03ed270734524f605eafeea2418928fe1a41e057b224842ebe3890c75e0c8e9a7648f70fa8adb5cdf6020e8883910a91b20e3e4cbcb13f4ae301be0d1fa64b375e166fc846a61732958cb0b08b0d150f71bbc4e5ac59d1424909f4d6adc28ed0291d0d23e4934b0f1571d39c6ba6845f7c6ba5eebdcb75f68f28f2f32d892c9177a4afa3e06bfd21be68d6b16a422486f76177a3810f4c612ca3e9f9fade9c3ed7a387753cd74ec9fa4a6d3417780f9ae7b5ffe817368142e9f8db55a484f3f2e1726785d79ee5c3806dfd591b6440ced177ed6152d07a13fa67da5b8b95e1ac7d8e062d8493ec424e7483837423c03457bf0e926c334c25e10e0d66a0b89c6c500c6e448eb85e413174300f41d1bbab1760f8a5f78c4de1e1fb25674522de58c38e5b2847d8cea9266032010b079d825bf23999b6d84dc3b2acebacecf524640cc2a7e1889f03d3c4cdac5c2a2cea0cb64ec9fe1b6f5e4ebf933a06600346b15e75be656371e8a3fff12374db70f6b9e930797ab63be33c72ad800a95e41407f67e6ff3947437a813626cebdb9837697d56f584cc98f4fb9490bfdc7730f1f03d3b36d7841315fc2cd231bf7a7238250f004d4abcfcc13cfbd3fdc3f814594caa5a8651143744506932ccf6a0cea59fdcde4ca4e0a23085e642561f4938c5d8c8c5e4c58193c3fac6365b8ba1b57a59a98c80418e1e1fe4aa52c71e5ac68136fb398619c617bb14fad8abcc4b08ea2687a3e068633165c7425ea5ca7a2795612918f40c97cd776c270aa168f1ae19684d0b730ac954d8e6ab8a55769b5a18da1dec9498f5412b117b050de03163fc92a721b2479c671185fa5f662730fe6817e07ed0d96db27fbacfe3c957830da87201a76a07d30dfc26c75fd98499d58c99a7a957d421f4399ab8630d2a2be5da736939f572eb4c52e1188f60f973f2f67833f23c253122ec1d2b1a0e619c614e2c19f9cd520211d38706a0e1c3ed9e8af27f06289bee84e3cbedd4a1d59e3d978f8c95b99d8ebed2cd73ddca89773cc0d27011dff997ef9ba28557674df6410812f83e2336cf20383e0c7f287543f0aec8215877dc5719190d6923cf6c1ba912531d2454054f3bdc403beabb0860f853c451398d2a57c4c73dc5848148731e16c85e6de01a34ff85b5c320470057d2f64b8e3b7a57b64ed354d7a6714bbcef8dc4d0a51b2a3b2a1b3f9e27d006f9aa8c71119553ca7550f462833ba608b3ac96ef3f71a2d0ba31314ea9f0899be5cfb15fbe85acf87f2ebdffabc14f9ef5f22d5dd7ff4d00a9c04d3bdee27fbbea2c40d41d3d3b1ca43acd6b357eb9cebf1a88694513d1193e97328b4eb0c040cdd4f1e81409bb0c8735e52fd107429408a4544fd70a0be22f308d0d1dc1953409529706e983a7da0f1fe5b95a3e6086fbbe490a38224163d0d2d13233c82d7194ba97e7926479c995934867fb6f439b45802c4f94f49ec162a433ddedd703aa7b995558837aaff5814a0ac6db0ddea7b6708a48908f4b13684a511310bf0f8c144143acbb62c83a893257e8c6b4f40f7ed7bc2ca67b789b25018224be681c42c585ce89e88aed44e9374fa62d0e8c4e33f75eefaa6bfa8bc7cfd2baefce0b164a5f3078e289c10ffb10197eae6a26de5da57c7fca3b66a5095185b6a85eb8b7301ba920b62075c22080fb7ac900c7de74faa48aac591143f9c2cc0e10d85b2753e73e4da5067a9ab1cf0e62ebae05e2e9c44c90b95c7b20b2b7ca8615ddeebf42686bdbf73cf5d4694c77ae8e330169187cffedff16b7dc5509246d29880ed2b6ecef72adb8ad4a17266aa3e2f7569e831b011355a6669879d463f6946f7a5ae7ed2d6ffe529cd9fc21557db97e11061bb71b5a2bb4c6f755bcb20afa6eb5dc7b6c916cab9c5fdf1e57b7474d57d212643d949329be4a339956600421a5587a1a5edf78b912ab3497e1259f7f1f93c24d06d25d4a5d2b20f6651707f26107b39ab92798e4efff98c45f210a4435f74b4fcd8128b4c82a53c2c7fdfbe694d1277b07064eb296e889b52c3f19d20edc3d6cf10f3570fd0ba473342768b2c5bf82c3375c82b921f0456a7964bc3d24e2002580b3386a6b4af99353eb7043d47cc8fe147813a819e7f8c05ed1a2b8f1425b5a88f8cace2304ac9e8f4b39ad0b860f80219ab226657565cf3942bb5499ec24d538aca6aad60aad31cadc5d9b84ea5d50e8e837c9c923a00c6344d9bdaab49510bc9744fed93a7fc98a48d4a6833968f7198a6a74d6ca52227665c6936bee879554df073ca32e0e033fcd5e2341f92b40bb4c5e07bafcad7c3ebe797391aa339ad48077cfb16b36ed567a7d890e336c53db1db2859475dc63a97b56e9e9bb7882a64a6974729ceb0478336485af334309aa619188e2997ffd16bb102221164fb975a20857825cb16d0fe07c7784652661a75f4ed5e430456e73d0b4bc2fd7a10d9ad1491f586b1fb66bc922ed12212839b6f88524f55f56247190bb89b19a79d3705387bcae48561423578de92f06e0dd2c3ad4394d37cfc38d3a19a7725350d446d2173e2e6bd7ec2a6cb00216cd6aad429c4f4a54fcd1d303fcaf81969df7d56fdae8953e4679a548be8e9df8ad90b7e655a1184b01823f1ba860abd62e5001735f6fffd4143d6f794c2833595824843156ee6cf09d116f5007daf8c336515b450626dc3b76eebaf411f5582048d81eb628e8f16798d9ef5f56db4affcac61eafdd4f8725cecce29c705eac365fb77f2006a8c3a428611c263f0b8d170ce4f78a8912b3f600268cdf600b63e022e20a6d250da21a6568c4a18f84e25efb6326e6264a33840c5ca2359bed7d75158502bbc86e816ee0e58021dac7ef4b30ee80d8535f10a4a463bf78910fbc934f73d3e2d6f157b52e8c9a2d1f2ea747cafa2783fab080bd0954a8c1278018fab261d4e09a206d8958ed3b34e555f36f2d4a349b3ccac287cb5486344e812cffc522d6925671283ed434dbac91695bab08cddc394b830628739a9593fa9264906a91edbbc59f734f5ccfe5b42258fca8320dea9e94438a039872fca88be4735e3d3d8f792bcf3568dd0ec2d8e05ef2619a91af7580995f12bc99fef83b667d041542d6ff3a776d796bd37b25ed39fc04c42e05eba6b714500f6c99e9095bb52515da5c9c7b4117e1a4935f0bba0b861602b93987b884440a2f700f4ba92ec1f81c377442edb87f433dc1e9325ec2dd081581cb3015fae09709dc5e33348b8f54534e90e664d237862984486002d275bea1c2acf08a8a9fc8448b50ea29af7ca7d130a2ab8026caed467442548de3cc04cd2515e70004f3230d36d51d0aee7558540e5329c420ff469681c971bd55fb80d873a559de258eef18c31899532f8dcec3db2189edd7c99ec10432c979057447e9864e89ca2d17394dae8f8a2389316e30f51d24d99e2c7d61882806b804b1beab59cdb15b78325398a000294b5f26f132b8718dcb6f28a5ee60083e5fc9aeccdb6268793467dd9e282fc7088198ea4f1620e5f326c78ed65862e276ecd57e87ecf2603211cd853643762db08a33cd8800b5ee377a0ba15e068b02c0fa7fc3c4f09a334809c843e7a8923ec240e2e5d2a0304cf246619b2d8b00c6e89517638e7aed47687161c116e3a42e96e6284a59d2a01b8731bcf69ecb5be23ef61108fe91d460dfaf89327c9541509fbb6e0dd699d54c4f74456f55d3971cdaaf50eadb4c786df2dd312b2bcfab31bab8adc44d2814297591eca6fe551d87a220e598865ed88fd7f0dce3b81358f59fea944ca8e0b2b26d24d50a03e8954e1dbe16c91dad396ebf3ab5ff9307f95195520c8820e248b19a28bb484b850ccc2c9683446dd7a04b11d04ab2eaaec5e63164f16784e10fd989bc3a0250bf43e6fe2a15e52a84ee430c20fa34ed272a811f503d9640a87d416b241f7962fd284d5d39c48850e998ba8d790b06200d0907795f1088fccc9dd3a7c6c49a152b674f67b171a281cc33a3bd78a6e0fd87c9d3fd4cd6afcd0dc8530b7ba29c0212bd6793bdefad57e9261261150b2d3d3d2363acc596869705bb820f639651de55703fe1f25f471625c5721eeaa9dd2443bd76ded93667d378fb6c8bccaa3b7f871f20609727ff7de9efd8676f4206f6a7f60d7296d833785a082f7eb8b558f774535352011f890046ef8b6895533c84c2471a63a94549341216bca6cba8c3ea28bc9fd28f31d8ebbe1736fc8a12389aa3d1bcf2fbf5c098a057c25be0d83c0d23c7ea841527697d5e1739db6b3805382fee97ca4bfb4a2716c05ba7bb2f73dc9805b04c4b0fd687aacc64088bf6785b042a6a9b97a7f658b0191a655aab6b20ed9d409abce4aac98bb05dab046aa3ada5d5d0eb48993af972261677ad18bd2140cff401d8604e89d39f76553c23e89c510fcb76337a18b128e34c2f51ac3669f7793f55513ea944b28206d03b10f17ff0d87dab56c7091400e573e080546d88d24509c56e1e9245b4a4c2047b951a3a7af7e17eaf89ed4e02dd2d6a73085038abd8ebfa1b013987219dd36b58d9a85173725f232bfa12efbe769db473a4c971a9520d6ad7fadf9214c3bf40e7ebdec89c2cd66f12b893934259567a24ae0a106180cd61d2328045a1ad83686f757636cfcfc7bb8c4e975f1b839d61345d243850c4717e8f0203318df4db2c42eb3f003549fb367f150c32769eb6054ffe6aaedd69217116ed6da30b09ca90d35d25334847a8e81f128239cef3041aa78991f388ee2ee5c3f26775ec13fe202c443ae1b31d3dcf48e2f4fe74071a5e050095a4b65a254e138cedd79baf4f34ff34e7b2a440838a5cb88df27a9ecd4754f9961b5e3916e54e22d8f707d85ba99f7dc94c84b49d10a02af03a7cf59abff8303ec2ca4d2abe1bbd9e318375fd61402fb4df6134a365c0adbab74c38ed068656203f9b9e0e5d46d614b3b61552f16ec9c6a13dcf31d394637ea2466d37a8dca4ff201c8aebcf399c250c53d6ee41e1da195b888a6a6b9017e5e2a860bc7f0836fc4647e5750ad98672e30b172bb09f2026a1e24b26d8e02f7d071372c2312f6823167cb19482258c9800b7a85a1b05e8e9beb02962e58e9589c207f0b7af1fb2030e0d1214c96773860f768b79683b65b9ce992777bdf84bfbd4584d132759070e7d8abde0cc4d56f4138be47c42c4b7c91d3f6e95de0d1e4042694bbb7a87286b4800ea05701c4bf31662844a5eeee8908b2a78f094e039998e983e20bd44a5c052a5e48de724c77b138d674cc0b175a40db193e603ecd475b5906fdb20e746cd3699d1399c3d195034b01f9306e26253756fef28fd49a64646e81d67d89b5472c1868bf47e4067876e2a2cd9e55352b9ffeca6e66e4ccf7ea9e486c5f2f8f6e7e5c9320514a6086a8e8edff3c34c04b38c3c85119f47f18dd938ae70bce991273093628dbd990982dc907ebd9e0afc8f11fc18c54c397ee084ebaf40bbd4ae40f600c2caa70b58cce2b7268d7ba4b0b53a2f9b53d0fe5895e8e987157defd18460b13bc18a1e52399563f0448ce66520a35563f07c317d7a47a176b294df1fe3ebf7751e237a05ea930776fb86102c6ba7de7c22f5bc70c4792be285251801c7c234af2864f3a179d20c3c651e49a95e94f754d7891a5035f15e9be1e844aaf8c28715e777940ca060c44646975fa1381752722597581b29780509a55cd0877c79d2ed67a9016f6249c1a4fe932c5cd04d904d2d3266903840f6119bd78796f3d7c954489b81fddbf13e07ecfe23194268dee44225909777cc92fb0fe58ec7697b8600cda88f54f1fb84facd6cef0b9b83759bfa9dcd42881f534b41eb6419dd15f9cfc1c678f068cd69840878ceb1f11a5e95b9a56943f5169f6a5b1793a615cdbe480532b38bc091e13b344efde6bb1097d9fe6cfc605fb3c223de663ba9a0da36aa5c4565b3f6564a8d79e034f97c76ca234583f679f6ad581f90c560ba25eb201357f6534aba7d699ddb176c44fcc678a7db7e6a20e9d8e31f9c1781d34d95dfb1ad535d582c5b85ea1381835d9661f5fdf11f4cfbcfa2764ab241696ddb73b57de0e2cfc54eecac70f9095b0cdee3e44f2a929dfe5a2195687c0af6d24ca3b5cc185925fbf1791d41bfb6b97bf6aa76b216b0d24ba905bdb278dd2e75592ff156520fb508473ab77baacac52212567451ca2c81de9b3dd72d0bc47764b1d290bdeb6125c4790c22c2f665d4f6bb31a9c2dc3eb5db47932d0d13d84fef618c3d25cdd5767ef9192154c738c3fc8cbfc93ec8429a786da53f5f2ef4606942523883d7e43e6448f6caa21282c51bfcc8acc5f789436b9078e1606b2565b805a70e92874815629c3f65d1f505759ddf8b3346fe24ef9a92fab89002aad997514d8158a64594ef6f154b57d1e9995fb0242bb6abcfaf814e9cda6248a34e771c3265fa39d093f9600ad5ac30000c4bf1d0d1fb4395187a68c35221836a2753d21165378c15b869d3ebdbef8e9114ca23d78146f3cee52200a057fc8eeaf48a395fa4cccc7e54a4125bee195989bdd7e02842cee847e3e3b623d0b4ee9fea87132d0e704d2f863392b9f04b513cf880201de36aab3918f0dc3c6524e7a1acc7975fefb61d4b767c11331b98447aced5edf84fed4901eec21e02fec86e03a47ea78baaf86a8193a59c4b740455e263d327a7c4a65ceb6be173b39e088e49d693e491e0ef61d154e2bb3f6e0ae21bb3dce2c2b068b715b442f6026970e2a8e03ddecb01d49efcbb1eed33e856bc54bbb38ee6deeb8ae8188fccc01145e025ea517d4e3e3cf10c9127344cdde6852956fed87bb1ef5278dfe56ebd553e7a7cd67a895be0d3a9d2dd1a4aaf551197aec34970cc1b83998da8c5f70cdadad5fa514c3c0840d80fb9459f55e65478a44d3429e43b108a13a09a8a1f173700313007eb48d2c0ead31d070379e8519ebb7c587f8052fd142fb56144b6dbc9174b5d7e959a8cead95241eaae7a6e8dbc7c3cee6651899467c37885071e97e8a8b38b59246585cf49706c044677357bd67230f4f713bc4b1922576a7559d94536f2c8d98288c92fc3ea0d173fa2c51d3a18869867c43a195c85dae31ac4fa40aa4536b582855444a55a4309888dba86ecd1b66a78922a39437f64919d09be5d04b5cc6f0a7bb7e6751d694e1224a7bb477211002c5a999623c9ea3c0966521fb24af37c39d532027d230ec51fdf37064ce92e56d8f91bcc7518f50a9b03f8cdee08c0bc8109bc40c596e1d929e5fbe2bb6efc834ed92e5afcbb6d3e751b45f80e807ea56122956aa824ce5a1612c5c27f419dde6accf8d04706110fbd16ac4e6e036d9500c86cd3206f3d485cd889d40e5b2e1dba021d3803b5b3d99b1717fd88a1748f7640ed8008a0e2bd7bb69f3b131b8a02eba5d465825051ae07b69fa2e24738e569e3bda926adcf9d02cb89156dcfd7ba46e99508a439fa011eea732493d1c419daa58e8f2816c4a66a0e95cca9a56afe98a159eb078b6b52a5dc1af91ebe066c1c543d08e0f0806413054c5ecf74638ca08e913bda056fbdf79de5980bbc21623a73c579440e22652736146e41b1c46515d36abbb3ca61502b93cebba9966254f3e9e50e2a92bec920c945e476c8391b91080f0708eef88494181105c16d3b10b7216553e08ab833b8201ad1a9fca672035ea8058e82073796948a3e0ecc7aa5359627b48539d1a94b6c5c4dd88be033cdf60adef1dabf041f7f594d17046d5218a087af8ea18fd2a4403f4c608f8c67865d44bacabeddc689bed4ca722905e4b380e4e84531bf8920bdeda90f4efa6dc7cd03bbb88b2823d17d4b0332a543b9674bf1a750b4f3ceb59eddc0ad20a09f9937652ae64beb3f47ae5b4be95cbaa5f2cb8ecfb73fb21b89fa1f200590410a48a2503caaacfd05d0862703a091b64fa3ed1dbe0ee060350665217beaacd3b17ea1ba7831fc3055480b578773e4560aaefb6d54689fcd67633823be3b35c31c8b31d3015707f20c9c3aad060ac727775ef1a13bb4fe799373119d632c3d1553a5c2e7642cc3731c1d6762f50fd5af0d6a8456fb4c6a126fe252c2bbffa0ab1a896755a45070ae3204a2ca8a7f86b764d0a6d7976673dfbea68c7637aec47b9b2de9c0f192923d4f3736cd3f8ac7db630ee4cf6fddd1bb5798e823c9009ae21ff7e706e833b0c7db29980d915520e42f5cb7248aee7cf8be3af14835712824aedd9a531d14b3bd709d00d90d9f4c7f75886f62d08d13b2acce36a44247bff693360c186b5ee4cc24d47bba0e6f0a668510e54c38f0a66291d0849677a2b1e83c88a3a61c1c4b5ef99ef10dfa85d33d4d29014167656fc9ebfd0f63b95dbe814100058984ca1006a0ff036c21e904b76e2664d6a1bac651787b97278cb9ffb529603297c076b24689346eccd479a034a24d7df3edda60cfe8d2da2433a37ef5a0bd2b8172ff4a2e1763f103cca033437d81bf84ac777ce753c890535ea874eebbe8ccd94192f3895792ede18853edb1ef9b3bd42d934e028c6a5e18b6d184c5c5b68bc8f025d8e67836cb5a20b629c7fe7b59fc2551863fccd8aba47910172164c3b0fb67cc4f382bd9c589bd8f04a74bafe89eca55a1ad16460d5405f604caeeafd7c6b25a3b8be8507715f283dac321e0ac95fb4dfe67755853b409a1712b532262c1b1aea79ca7204b743f881e156d9ecb2b913ed58705d0268a656295c8ed72c9e5879adc17e91e886d42a2667875a20702774bdc10b09f236a0b9a499f41275c1791b627268953a9e65b30828fb7854b25f03e333eb079d95e879294c2183266588c3a4113c5df7e9e9189ebd46f47389522d044e5de7dd72b98e39bacb4a98afe6d6f75a8a1a49a4f5faa0f4ce74dd24138bb20208cf7e426bd6ca5542bedf1d857cadcd20a2b4cb756120105b025c21b18f669a2e0dc262ea710af3593921f54e31e7dccaf2d9a5af2dd4eb786b53366b4dcbd984fb9660f804fe0c188a24258dd15d7977809429f17f8f2f8dd33a034f50bbeaca245c6c720142ff335f4529638416ded353d70ea58dee8e7d9f48d5aa3d52bbec4044751da445fb092cf187fec7399882821eabb8da830e782c7606e919dd09e40a3ea096d54beb60b51b4e100178bc7ee187e85e62ff0cf2a6af019aede182bd13ee969122d5ac8c8fcdbd770993e9fa83452f20c5f5c46c63363b4f5e4250ba34addb34cbc4060caefb3386b1ccac594c416847c1e38b62f24cd275c37cbdbfdb5f31b1ff14e07dccd6a0f46b56f14922b4740ff5e6a2c62223f4e83996dc29a4fd8ae038e2c89c46d1c406cabf63bc5cecbd962a1b7c051d7038ed39a587fe927b7e0844d267ff445a2fae85bed46ca47f2c119e5818dcd7f3e7bfaebf41f16274d98c0a78070f2e375c267ea97be8406ee579730490ecdda8e0ec6a046314823d9b309a2918fd79f1cd7093d24f71270f8982659d87a389f3deb12f0b77517fd2c30553b678cd45bffc6b3b7195b6d552267885595fc484115437327bb01fc227c6f6d46be7f18630fa75015a4caeee9779d0ce65cd28dca5251182d4b70c3a458094dd97af9e1ee8e27c05b28b028d25c1bea7df8641d10c0e6e6c9842c216b40c773dbbed955b27cfcaf378c973e28f86a066cc47c42654b7975304e509f7291f8a3da4bd080f52fdb75216b04b02f2b632ba1037c544f05b83ae0368f9e507d1fbb5051fe34a36bd39eeaca4668ff58c076b918bc8697287a719f28cae9d8c93de0fd8d3ab1c0099326ffff009a98c265c76b76781646cdef6050bb8fc5983cf3877fa1ebb7093b584de2e86ec0a6d0efc201d352a6f67f0fa6d0d10e309bfff76e7721bfc21bde99c9af3d8732f180bf6ee8d3f6193abb1f725b20b5dec4c1dccff062fc6e421cb65e220aa7ac88e7fefc5dc475395aec30bd5c58239d4c4dab75549ccc2f0f326edec84562638f80e6812efe1e84077492d869f99d2377379867ac2da2882c95930b8e731a36301ff472a8f223c2c7c418e931caafcbd6f8d7511e14dbef82fc6902660e836ffde8440fb2a19940695816022d6ffdd275c5cdffb2a3881f9a0d1489a1ffc69cd4cbbcd85d2d876e8c9787a98a877a15bef9f9d9f9a6d4b459e60b85e9f00b366c6b16d2129fdadff38e02550e9de8e3fdeac93588be43d03c0e48d269ba6fab31a1760df483254e1b36b1d67d4cdc275853c4ffd01efd51eddde45f7df7705b923e8ab1742cbaae7e846339f5e1e3f5dfc4b29a6d8c12beb658d6ea9612a39b4aa19859a2a3f179873d0c2cc8c9403e26fbe2cf3fa339b3a82ccf9c8bbea2b6fa40c753d14a673558b733e4d245d121203fec182cf9cb0f30d1e299a4b92b5598f934197bad270dbc81d96b69585a9502920d5765d7076514fea2933c2f579321da309238fd3e51d4cfe7b846f3a7e89c303b08e49bc8d83d9b86eada6c23f0f11e7b89fa38355463139ed946d1188c1d6c2482ae11d9839a3be04ba2907246166da0551010414e258ae3880eb57f57882ff4dfce44ce4235a14861f45b3cb64b016826a199152470f103b33ef01e84538ff7bc153d587888a152574071078d1dbda671cb74bc4a5fdfe451707593da2f15c6358f2940af2a572867467b620161ede209f4420d26268f02bb59457eddf3d044861d2f49f162bcf3e9846c3feb55c442190dac7ca524514d92ba1eca3b2493b2126119600cf47914ec51e6575d59bbca84ee501da5ac9b735917b66e05fd98fe78b387edda85bf67e6d60950817d1eb1e6a5d6a5242096c77430342d1602dae74e7b8dbd6f9f4d7838d20afe8657faab7e2dc2c05a0bbc36ec56739da4e45d93fdde20b91b7f6973b273e74c5f70795bffd8b806c0df782229725069712ddd8ebcfbed3d8c3f7b807701cc4ad7e5f8720e4f77b07bfa8f5b2d6f3cf1542c642c895dd74a2d0618f1a7de7375e82a794bcc3b97bdee7f93b5326599aae0fcece4f1a8fb936738c70f23dd5cf7511ffb2f4d3c9093f1d9d335b00ebe936690c7323026a95d02df9f36ecb6b8f270a208165f2cea8ad437c94ac047d5b1c970ed9256bb1f3b8f36d2cb00019d2a0b95840aad1ac8d4b7e145a37328628c62ba2be32434d41516791fd6f94944665da80ab0ec96702549f9ec9ad2cb8d1d0e63a1097f19f8ff44a1dac5508466511cb9d2c6d2bc38e3f58295847c3beca460ae79afe24324bc7c5f98eacb91d39be1731e2ef3ee1213f556593a76b52ad1c2235caccc8b5a551f7e7a70245d6d6e784d8af617c9b37bf30fa14505d7c4c0035400661f7441d72ae6ac2cf5a5cf561721b72cbf61c8cc668218a00c156a03a61ba9b54fcc51ac9e96c88cf4496c7ef78521f37a6d9ca00aad4c7fca6d8c5e89cf1195116e0dc1047858f87b5b8e30161739f0b1b5da1edb9fa5e6c008bca6dab0398542d295c8ccd6670e47ccf803ef00c70b73f028a477535a8b736e043cbc6bfc15e3702c97b4fb09cc4aa5f3e67323f25123a2209c1c3823117ffd2d54446e10d652af238e4320abe9df5b397e26c2a6e1b34692e57d9c0d95080deb99f09bc159f4b9330533da2490404b6f432c7710848a0155182df45863fe8027edca08a4cf288bf4881d7c3e28654b26aa0bdfd297d9b56aae56ff6631bc57018e544fe4e75913269b6c207dbbf3f302ee90c3828725b3d1bb1450f8a0378d4eeb0a42c2a8ced3d926cd6be272dade3d7c613b53b4037cc551cff6be1b1e4d767e201f74da746e80f8de8f59c146e4cd4e6fc452528e010a92c10c713d7e8eda0eafdc4642348813a5448ac2b92987de112f2af09c5b7db80c8598ee5968f59441f06c92f4c5fa360d2d82a090a4b7d99d64c5d4c5c700eb2cc0a24de7a52686004581c87b95a823dca97e7ee35d6f30658e3c0f354a93f62c24953fa2dc71a48550ec935dfe2c5836f7f4d5839c1866a859b6b20613eb40679a0fbbf540e71d9b418b5fc1bf441d3534537eec6703d9d2f379be6fa87d7874bb2f906fdc835c9537f8837a7b3fead4148390015445ad36f3123eb0d185a88a804287a77c9ad7f607868c8a90fc54000ea398f1c21dee375329d0bea6760f789802fef286251bf8d0dc7669a8112f405d16791c82a780bca920928d448eee0010a09e674d4c8874e2eb1a1c5f568990b3de46c7f594b70e786e89b2a7fd329944e121396c6b4d841d5bde18c8459d232bc7fbf8d1720432b267da3c6e3c30351fd3dea90b88fe8f95271315ba38aa871ab7826412597a7f060c6f0bb1a861ede60274b63b5c8fcf7bb6d592c6fecae13296fe3441c1f3cb783b410083c9e61be2a4c2df32ed9a88734c81435b50b7d2cb6d8741285f810f75544fdfbead573a846243d936838b2ab0d587c135ada08f7b988f9351f98f6bc40ab14d8c96cc96131b6003ca2f400c3d3d35fd0863fdfe07facc359d1346cdd9c68a46c0b171a0f2df1a7cf401252a6d51244d7ccfdc2e0750a14f0e91d957cc8619aaa53195ad6374f3d31d309510678dd311c69e612a2126f772188e810dd6c9d3a30493dd728cb101cee19ffffc1de4d2be3e6f63a3324f905453e1eb19409f21bf6967dfffb23e59ada3a4b42b466f3d1f76f66b66e4669ddfe13b6e6cb10a9583ab07f2166a46c470de3121d2c5c6502a01125a5d5ea09dfb798693c24ee8bd3d6fda553033715f64b342986e80094cb6c1e657a7e05fd253cf7d124c2a43704c310a042f52e39c80196aebb2848bd4e8b85f249ab8374aa7f0299d97af0e050e146bb7432f9666c618a66021e1d0a1ab0aa77228c8256d1dcbca4992334d7d1f9e38533b5d52fa981b0805b2b8767d3857691c4d6bf78a5fd826ec5c045b262a48eba83e92a67d36bf58b5f8825ace6c22423ad5983d24ff4d99d889fa7753e10e0f4fda991aaaeaae41c4ce9aafd06df808a2546bad68aab652d37a7cbdba5f823f8ea51f1fe64b24c580a61136e84d7f8758e26142801a474890b39ccdd87f2797569c5a80e3c84539b7c064cf9f873c4896c7b97cad69ac07e2a67b12dab1a7be495b468f5fbd00fe9cffa164ded50f4f6f6573114c5b3660b1e57bc30fa893e1856b2e454a214c2b1294c82eefcd0502e15d6a4dfa8d80a8c0b15f339cf17440a3d6a67acf6bd92122856214b764b54cf6ff100be0233a5e440c0e0c2eb488108c6e167b81226ac1c68ee6505615e9e2a8167327be5a73b5b66c6974659cc83d03b7a7a11a1d5f2986d020e608d352283b2770135130d60e1699262f2d69d49380596e3254449b269146284fda938a64f8ceae9f12e297e66c8627fa41ed15500302ec65116563cdd472710c089d16d268e50efd691a21b9e0776982f1dc7edcd051b77bb826923f45f286d188744df61f166d85e98ad4b2db674628e17cf9d4213f375455a7fd90fb5c69a853238cbe2c0b8773d64a2a67a246bd0a04a3dc06f6934424c035ad811b5f5c2ded9f3a816aa30742166bf010a769158eec8b4c4de4faf33c833e39ba8a536c3ebd5b4f84157df582d0121326eaeb18c9b6f0a7244722a27cf91d2a691427e4dcfe948536110e3ce604605f9cc2ce8a0a0260e2ee7f7d47982f57c48390c0b56a702d4acc4055ee293414ef627325570e396d09f4c8dc7ebad9951903ba2b52ea96084a86168cd59c8125b63e90d08b5154087189f20f6147794d1c4cb8b2e1be9e81fdc32f53b2f74b91caec0a7c968ba2087836951c8043cdc5101d74bf0709242e6adf6f7de28b098ab68c78cf1c3960a44bc24ac7fbd68303fc47a0cfc9de8da1c397e229c5b285b29d5a3b299a76b9f728b3916ff4f38fa31d36e7e5a2318ad5a7506c11c77ef2c1b2fa258edefacbcea7585fd30da20174461bb3e852c12e7490f29c484fafff720efdeb17a1cfdb15d5b73514ea09511032350c3a8ff5780019aa74862ac23d90429bf8035b249ebc4ce81e1bf4e05ebd7841d405f70472986817ca2e9033077c6e34e89bb7bf9f23bd307a51cd68adfe7445d5b879e6cf263c08dfa3527270a0c71b6ea165e8d89d619b99ad307edc7bd65a6a70dcb2072820165731f6c06cb5de2d5fa57840a31e87fd003512c9a89166f0b08257c9054955243628c2b0d0a62b2f87c9a60e77590c448725dd529e2f3fae730b3d48de6d6d892cde4efaaee0deaa78b1c22a76cfc7448508de8a442f8e3ce9f0d19378121d57c58bf9c5171c3e8a317fa6ec49b7aecd225e157f77d69118d5c58d70c65a880af1743ac4a001d0a710a1726a1e7cc0b7c7eb7881a1ef7e490830673d6156d661392e861f8c56560bac498afb981270a8057f0497ce83c150b6473a70364464782c9cf78268687aed1a0db457ac4d6776044ebc10bf66f786bcfb2e191b23b2f4f781cf11fa179d094f98929ca18378b433efe2c8eb325b49f70b1c66afccb42eabab80ec451a8c2d4ebd3b4255dd531f27148bee2216f55959a6cb2c9f381f80f4b4533a9d52ad3db2475be98755d5139586a8d55186cb533f813be701cf0d760323ca2c10009c703d5cabdfe6677a1d469f1f1a4f3d1239ed2a8ff8322bb290c3cec9e1dff90b19bb62c819c2f9e217a0addce4e5bb2ad4060d03613a50219b3f1567b5b48cdd22f5954c9bbbbe21aa31c3f7f7f517b3777f2f427b57bb6aabd4d471df6d4a240f909f24ce6aa4a97631ea56bd2736be5235b6f07a776b2b415587045e963350bacf4bd735ae69c952a6ee7f21edebbe450db079cf0ea78f92a9f2fde359171aa41df10dad7ecfd953dd44b5ecc6dab126410ba46f3adf24dc554f7906e8c5615f2ed046d34396b86980803ffe5c7152971b39ba5acc25e279190f6a07fd207d18baeb253469248e9fb695e8337cdbaa42cefd0d04a12a9b01643a1f943769faca5d5584ef12accd22864dd659ba99310f7ae4ab123c1b22d2738f984966a599b7e465fffb8ebfe78ccd5f1defdf16a32db8613ff8103f6d507a5d5fc1ad46afa294cfb16faf2ae4df5a96801681897eb5c66b3c132c7bcc99cd41c683e1a68879d4a093c3e50c58b123529854969bbf9b9161fe4aafd90431e633eb415a35edce9f20f22e720a0affd98c4f39ccfadaa7e96a8ea3318ae7d5aed0f37d5458d921793ab9a9c2c80bc1232cb3d0cd8fc448e5d469a36c37aad8999961ac7a9b21aea3f3deb07f13ff2e4674039f5a350050678664b2f1802894911e3c1cd8032610d1afa561c6ed9618f7080aea7a0c99abf2eb2282f91398d8f9e25952d78525259a8fa3bb41418a537766631b5536a286925b3f79a353ae0bced6053e9ed4cbd17243a1f3fe4ae16a3bf3bc39be1b652fadc3b43a514814c33a853672ef058bf54d315bb8eccc97a755cd373c9bc93b9342098f58e7430dca761cd181ab724dd9b8d97fae71be07eff4c226c759bf09f04b134292e48d76750e04f06e8baa44b34f7e746810820fdf16427d414e01cdd2a34c78b45ae19a862451dbc356d5d86eae661c530e756688244607ace6eadc0e8630b9fcbe7373d3ad684742f1d6c37212ffaf09c0ab3451815200f8ab5ac74c3e017b5ea90974762d6a3af8ef702f8aa31b7df3e6ce4d4ebd27c94d184f94bb70929004f8edf62063e6f1af159e6005a2b6feaf23bbf945fbbb205d3f8451ae33772547adc26a6ba92cf713b9a59ff53bb2b09c15762a4e83b675bb8c09dc738d4ffa7dc955b50f3f4c87e847b974096724931310f8be231c2de7489b9c8e10b4f3e410e253b06ed2099fa8df5151222f0db65f9fb873f13a45ada5f0d30263f865c960d3bcdf14c88d57738a55251cab3cb1ee4253a4b32367b65b3af3bbdb926110792894d18af348a0ab3a8ce63ee9c539d1f537e3a5b0ad290613d4c2db868d254e2670716334e6337b6c6f17b05b0fc2b42fb7a6b40af78d32a5c6b356ac4b94137084ad78bb085e9ebfa2f2923ccd003ed99353a8fd1121c5dd6e1a21a19f4310193b5b5b1fb2f0e379cec8ae6ea3267e4062e1d12eebafa158c75a64df0fd2d518fb8038b56db1c71ebe057bb9c73862d866b47481c1543c19226e0498d9ff16986cac4cad6f1adbe01a608e58cb665bf01c97ca5d54e836d2438f51931f488f9bed459a97b3bf53e22219747984107e32a3227baa6870302202dc5ce3a5711e60cb306736813933bddc85a1e84f574ad5f26baa5e27baba6a1033b9d82eb17f387fcfa261c86b765b1b60f74644b380400c7bb1226f2e8ffbf182903334d4a281d31b02c0d64db4f2dfea615b692ec0053f99d9ee00c00be67efd51941a5071fce7f0aec37d54b1b922aa4c18f37b292134ec57aaeb991b12e321e9528641797ffc0e9b19fe69c6cf5f51ef64a4c80d55335db91e58bf9d3bc0a28abc5fc14c0e3ae91d95a91013a854ff0423ae295e6a483fd1171cc0a2199f8ba0ac0cf879f77d873c68403416cd2025b76febee0efc6732af4907344e78bc0a806ad5ef6cac913dd45281e1d382976a1b029d29ceb751eecb73b77e341d47da703a0c7416b8fdb0bda350fa04cb63c5f60c3c0a0f23a28e1bc03dc6f40815edcf17fdb80ce25261fa06856053900b75351c84cc8a4c29e103c76620392ec488d8ffc9d7c175e28eefae3d6890d40217b5becc2ac1fd2d417c14f0e8b3a0dc55fc1358bdf8d6b642f140bfd6569c7a76b8e28ef444e4b2fb8d50df479fce79e2409e129e309ddd2a9544959a2d23fe8746fddfda33a82bf663db362a05bd5f39248c2150fecc372e601129507b196912043e95c2484a0edb4d1f9e60b72981a3fadd7d9bc8794a1024af64e0a6eb3a42359c2f11c5fb3911bd64f7c3431a9487cb7ce902b9ad15b5777cd5b45f83b463bad52ec8d604bf5e61d2b1b7f1bcb4f6db94bceb2d9e976a6d04155cf1646cd74046cbee763550c043cef74afa200204453825f4f49a9970f464bd9e4ba8744f348ee543ec55c36ae302a461ae7fb4e38e3fafc695e246aca8269a303ebc7e21238fb70597a0e179b769df0e82a542e80a6c8bb2a8c62d9b4f4c915bddf6471fac83a25af0933018da1115e33ef972df3a1fbc0d63a83f6d3af9e4251d180c690c0b1568b25606b86b5e964eb9a1e2c572ea45dfe0d878d64be67bb8928921b29beb624e80ce9eb368e376f9aa848368e2869f94b55be5f6172f21d34bbb2630ef870676b893aab7c8ced0c93e57ff8551a7f81072a621ac332a43844072d548ec9039e2ef06fdd736db4085b6eb76417e90878ee4097838673acbb82c5a51f49def11d5be064bc2f13dabb4f43196c4f9f1992f5473e117454953ad8a642cf8501710507b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
