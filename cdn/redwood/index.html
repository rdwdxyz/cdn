<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"812da77d7e6cbc6088c38a80573c689eefdeccf5fa32a0cd4b91687044f1ddb975081bb6bc1ff111f0c2f54530a44757d727d1f4e1334ff4c27de3ebee201f606907900accbf220d4c4a8dbced445a4dfb08c84c35ee398bde6e17ef56987ef63a769d4106c2b1b008db628bcb992e2287793beedc1cfdc3a62fd1d4528ea8ac574b903958e08c79906d3b6955976b320b71450be60baf29fc79f997db0e06fd7c8a0b249afe9ae3cdc1718a1c5467ae1e1fc8ba3eecb7118e20fee23d404614a736233471f99b1f1c31c361266b1abc668a2927e1498db1df47ccd6221373f25c55f84c989dfb94ada767d00ead1c40a8b2767fec70e9937ba674b61cfdb15f8d0c8ff418ef83aa749280fa4f08a5497d20c021f5c3c5df12d57efe35258ff900fff0ae96f391ff5e0cc20f4a0a97b00a0983fe9209de6602083e076e46eec1aaa86d6b8439ea3c9335138b4b6e9aacd5ba2843c2e75734f37e819ab6924772806d531952adb487180e3415b055953e067f0a68d01c4585c934321525a06cd2b67bb803392b1c34c3e87ad66564ed09b1886ab943d027fded8a1897ab220e5cae0ebdc1fea0b6d375b577271d9ebd77cb45ebc359841c6e187292feaa344b0c59e931900983c94f8db6e256043858867475b24bd79e129716d2505b1af2d40b945a336a5c2606abc454d2968c70375db67bd9b37ddffdce6083a93762029b79d554750ed6842fd00c15de8ac1f5b57078e0ab063719e19d307e8909fad2da011f718e33601c13a3a344218e4774c38b5da4096a0b7cca2730255f7c3a12852f495511795ef36a073278f179021f83feb390d732d37dd10d8fac352bc9a8905724ef8ad3c56b1c906ca96099af8a3c8ccde5467fc2ee4878c130bd79e4667a59aa901752a6fc585cb1d4ef2eff73404bf9806713bd9b968ab81b8b40a103acb667170c224867c7506fc9ecb2583134eaa2663f25577e47701a56d5e02093db1b89d1d871afb6e77b8828fbedfdb9972eecb144a8b15e6d918a01afcfe4411bf4048fcda391364a6f04ba7949bb9e2165116097c0ca0d3f125fee8775c61135ad3f365fcfca337df859859334a8bc18e0615c7983e191e1d640b9d59fbc8b15167bf30dc4ed1cc9c045792a07b90894e01d41aa48c48e7c7bccb6cacd64da478cf3b9e0e6f58d38920b5e8c79cabcde945f63cc34e337b63e610977b1668daa0e693624a89bf25a9abd912d923ae01d0eb55314652bb652dca5b1b8dd025b637e191de3b5fee0530356356513bc8548c4bd257b38b2edebef58a99edeb42fbd8a26851c38f046d095cbcf86b00cdbf3a9542f98101ce6b1151d387c59e1463bae3ad3e369b90c6aa4a660bb9ef1e9cd683d2cd65591863d218e84c3f819d29299b0a370d8cb81743818785a8e0c6028069879190fd221e52b2d3908423bfd97999defc28a6f82d01d45385e00b124f0f9c017f550022cac97ee91ed27f9d65791a0977b8dea231643747363f0683e90df19d2d192a296fbdf70b57d40a2202d56399372478e9e2e9b497ccd532248faa3fa49b85f4c017c11c04ac3607067c67b8d95b7af57cd3c9f6b7a70da9c6b4b5091c07b79ff9c9f51a947905962e7426b494e7750539117668f79071a17f7dc182730be27b576b289ed2701101cd4b596b5dce1aa8819d801670b4306d11a7febb9ee463ab8135d113dcbe4849133558e354af7de380d247687250e03b2b8e063b549772e92db3652122a8d2fd0eb5767d8622347f044554ce6bab50d1e76bc6ad154d068bddac184741272b426576f939fa0f6c7d85c7a8ceb321c127c5767476ed3d13bb3175513a0e412d5dfea828de80d0034bb017148c887a12290e6161f20a1501a6eb128718767585b4d4c00238106ab817484fe2cacefdbef86f19ef6bd955b46105842be925db6f5359e720a2c58688929317fdf093fa0b5841ad87cdb3aa40d6a9e4b2d81f49457d71caadcd930a7e41fcc54080f24eedab50168e1c7e141c944606fed4265e20e1f00b1f22428c4442b4a77948e3cebb0043bb2834db6a01c1d22c5f7aa0de57b16dab3de15ecbfa0020b79c9b11cc86156d49618220d085b6b2369dff34d46a42783d94113a46a2d4250a3077b719c67e205a85e8d26e3a8ae82d14d476703b0dd1fab003e345559c5f4d9f953927d855ff3c1cef0f67448f5b87f5c3149c97c383ebca4705428a08ce12f1b3cb3b35a6e5c2c9889a4d8aa144db103ae15dcb49a0923b172edc8de1ff700a2290cfce679b6c89fac082e085307fe277484ac7d1faea6011fffa41503684bf5a0ccfcbfddb1674a366d4e10753bb949df07df5488bdacf34c564d5e8b66893a4e974787d88810209a2c8bac4aa44f0494cc17523ef40d9d934ad937cbeba19017478ccfebf816084ae99078835f76e17c7c5a87e177430f615c811b3e36ba87475fd32b29480a63a65858dca285d5dcdcdb29668ab194c69af3d541fcf12147054648fabf37bf604993f01b97db0154a3e851621730495e917ae19e966c09d9bb4a176e5abda000460e071b74ce1f182bf1d7e663160ef6689a7c2846ab1f1bc7ff7e2af4bbf7c41f5ce7df4178cee512044a1ac0e6889546dff0e340b6677017e0524dacae85f25488b284361ed6d8d9b1612003fe0960076b5df2e57f5a3862cb40948217db84e52a982762212e6eea61291393decae4346703ba72c9f20b3cd048f726021b732381ce858e368e54d1dda05e024d5c8c4d2c594251c9d42ac3e770efeb9388dac8ad28c34c006fd69ce4cc3412dbe04cf2d9d06efbc2a6f274b2884e101b9d652566a4618284596e94ec3300188928899ab7b41b2dfd128ffcfd5f18cf71b216247d940b12ab882bab89e186701c2f17e0d4310dbad2def61dfb4b18ebd36533104a9a517091e287b04ac590088d078136719322791eeac8a5eee441416808c201abe2b9627a22414c24e2c43ba22959b3a46268c2f89bfed11245e92fce7d2e3294519d421ad54bd2c5e95f17f04e6d4f30554de5da8fb00cf87d81806318160dbebbfb8f3a610bfbd184dbd5816c70d97ac8d4c0dbe3ee15efd39a47351422ebe4ff0cd2f8a79503ef1e55fae40a162f6f55eae9c4bc024d20739d969a69713f4029969d8108dd52544cb40a2bcd711bb3e2109c7cb5de229e7739450378b5d5dcd1f2ad5da3e4480d4cad22c597ffd2fd7360cdfeec9d96914ff43c9dae6c7dbefb184999e98848f692115b7f1a89a0307c686ea40513318737c4b6934da6e57821d377f7c75919ed44ed5591e0f3b644bacbfe66512150da4ffab573b5b52db5ff4f406869e818aadc077b3a1d1c2f61906a812f91d944d610cf9a40695cb93e1956ddd27035f566ff3d0bff4efa81156abaddd38126981dc86c5804167d32aba66ea5de16b3c6fca41f0fa0f794808c18c85ff9cec9e9898ebcc374920b8d4ea882851d2c9d797d7a5fb975da55dec3052c9f68f3e10ba7e00af2446b7072b87686d9137bfe38d29517c7acc061b132472632d2fde45ca7e3abeecd5e2c776d2e30ba03ce4dc5eba2f7c77513149c37f96e4b0e0e2abd7316316d76e7c2023ad8457cc609304c190a38934012d213478cc8b04e919baa5a83c01de2a720c108a4ac7a2d3780529f52cea6859234165ec68ccdb68f376857e5f65729277a2f8322700cbb6f38ada44afe6423eacb823a6b33d19d40d9c732b4ad7b493b01348f7687bcf553bd66991eeecab3e76b0051c3b0e38d19f07b5ea88a5f34688792ab093889e83a6c724b122a511b3a8d659e45c14232f84148fd331745dcf1bb2259693e185f3cb1986a0e2b89d8effef4022160cbfcf90c8dbbcc9b9f60904fff9d4ef0fa0cc469b3c8e67cf0f83c218163657b9c2355fdaa93d24658647b4f8b457d40e88b08ca5840b6b5c8785f1d3bcd35c5738f8e2ba8d38c612716139e9c44da09d529971ee3a11373e0186271696e4a27b9241f8981bc27e1b82193affa5976793d444cedd67097fbc39ec34544286e470864b910ba132f80b6f455479543e475c7aafd766f28bca6881c6864cfa28d63fd0b348fa3ab9a1cb67841e2c4fc655842647e7a4c97b6bb9bb6f6d9fc4d3c421ae6a8c62e9d16ab3499ceb6269c64bd97c322cc91b401863d7358bb2a0dc7a346d83011dc68c3d14f2e802337d59d6f8a805c16c8ca14e9ff02b6e536a7739745d18151c99fee3fd4f934e35cf2c20390a79861e45b56f7ffb39c45ca21af209e4e67215530b3a972a1fa8521943bf987bb45e39850e6d3d496ab61e13f7af45145602e1bf81389f3fadfc748ef4dc584b22bb6ccb9454adcbb68d973ee729b77f01cbad1b15d4236dac61638ab6418308f3eb08bb708f849a115cfe4482bbc0f63991fe88afd4e36735004e5ac0b6d2459e81f4a00425b8f4820885ddaa1f6b8954049dbe949d595c34e0ad527d52879d5e0e335f98d96a741728e8dc35fdf590c391636537e87f49a168b9c9a66bf36ede1e446c30952a3131f25b1561b6d5aa08b80966999530eda970e1ee85408bd64b8e9c765c15b8e7b2cf6ed1a7f66df0dfb98740c5ad65d9a7b5f708c5b162c2b730d1325d816477c3a0ec312aaf4995251ab106526eb1630edc6363e463f3725c2a9ba5f3140b5fc984f2c47e598dfe9ba76e36ef97b51250188202def843413e08908b0218d2bf4bc6b7296c1c5fc4c2c747bc774b339a3fcf456a450f6abfe2a40e66a4ceface331463fe946c33b4f3a052fed2ac729deaf3c8350f2a6c1ea63db08310fe29b43263f641dfb68b64029f9f4d23e9ee182a48e9f33aea63f81cbe82d9cd295aafb8a9a03e2f540a7cae1aec182dc442de2cd0874052ddfe5dca1b6fc42d836dd2ad7ba826a315d85f0d66faae57c5bd50dc1359606909afcf9098992b5e3e8d2f500ae919e70335afbbc5efa1cd8d8f1a91e70e1f5935aa35eb978fedf80403562915d970d42920e80378313a99089421dbb45bb85ba5fed072983f1aecfae8b33f1bc3e5a3d6b85b151ae0c4dcdeaec0a938dfc82b8209a63c6d088922275212b5f46dea63233a65077df9a49970d404728a26a7712c168c4fa2a998477b44829334cec64dcba141c02a6a155501166044aa8731af63fa0608c42a10deee32ca84a10724a06d7d25e511db660e6c92101ebb1c4ca8dd77d0d569c2484d106c27e1c1ed41ece47ac9d33931845a872bc639ebc203f5374b287d89c89fed4a7b7832122164e6156b56590aa5759fbac222495ab598023d5e1a80afef4b6f75dc654cd7666db95ef968edb1ceb915c68f1ec15fb0ba8d7a79559ca8a267fa3789aad38579c91b7f76af89a12ae511339228c5213796554c2835791797c8993b32c1984b454789b8e5029341f7b6f6a68aed3a529e8499b00d388df53d52a5f62f043c246334d2d5c7d1e462cc80eb7c112c7f298e668e03cf84ca1903ea83c1171b8d3a791e74b118920e44fa17c8b8bedfe096024e88d5b8f7f50c47038c2086d1cc5d5c1c8328003b211bf59863da1f4615cba5bdb433fd91f98504d39aff09c4ad5ae8c1911a5360ffc463d9cff30db84b16a30f25a049631b68a19de024b9f6bd53f11dcba45c1f59499f43658b5063badc0d831eedca49a44bd29876a316859b0cab9a3627e4e9bb87ae154531f571be709790c403434e73e01cda1f1761e2e3532515e7b104bbe026ea6481d5f74a296267cc376a3da4feb3702ac2b4fbbdf5057ec01bfab25c4ff5ca004c57102aa905338f8336e1d92f7c5d24ab102be29deff064591bcbbe254e79f471b8da3defbe4e5f524a5d372dc69ba645f53ae2c145730763a5be9c2310fec853d7e6d64d21a5cf45523014c0894848bc24e87c4985763cc57fa4046d9a704ae5a82ad23006892828cda4740d50a229a3e45fea1b12502750fcf7bc6c0287fd014e7c20b870e933b8a8eb3160ed1999475fb0ab2c9fd91c305560d861a39c96f5c35aa8020096a423c3430548d1563aea1b58bcab02311f2176904407e818e4112fa2b61d0fe8086e00fe40302195f5f9b653ac4faa5572fc82156834785849822a9a0a3d73a9655a762816913e634083b0732d341a8c56d2de6a7321ef1cc43040717a8ee610960cc267cefa29fe4709b5796765cd84bfc1ff721aaeb054a1b507367775c922d9cbade5d553cff7e74c03f45b58cf1599dc67277f6296d918f597d8a72af987eb1d0a905840bed5d38852afade4912f450437033cdf45b215fc3c06d3a0440e424e569bf4b529c8d7a3bcbea820815521fc61a30167f2e97867e29f2951ae3e3b8573dba16caf6c1ed1014c8a95d21f1918cdd97804faa4b0373a5ae81121328ad78f7e536f493b351d9e8c3bf7039a56222fe813f53f2d443ee2860e15e4bd0c90f4ba5222ab38ab2c4660ac3c79e1582f03c5cf8a77862b57204a07ba3106d58c2415dd0731c3c7f54aeb12fd1ebe16f7e25733c3bc2d0d8cb5e0314bcbc55194e5ac8f97d57a09d63dbc6f7e3e65f9ce87fb02acbc4d0629a86704356e4f69a721fb52e0855bd5d1a7327d6e624e7134d53505afbd66e0aa5b3b117f78797172fc7426ea5e8d1a12fd785f154f1aa54b19318141eafcf09d5fb8a3670603524ba5277a7bf242d42f52ba6b914ba0f60f554618a20cb2d921e8cd22f61818eff6064a6ae57be22715a0c02895d2af31735be7380853f6802b499d8a7b151fa920e68dd0fd2c3fc0d27e5da98c9525dd3cc7b2b6807245ea598b5267d2b1f72c7f6b3a4e3e9c4742b3051c50f562be52d3be2078d294795d09be0ae3c56ecb02db808b94038c30da7effe625e890aa433601e3248e6bbebddadc3bc172c04969d738e209b21d27ed25f2e0ebf9384996b4ed872ee13190d0fff9c34279bb6c64651f8941626ebcafd5346c4aa4c27823be5d69da11e06bb52baea1f665325abc2f547954e2b5c8623ceca1e9c46e1b687a3340f87704343a8f7cb6789802dc21dadac56b467a440ea57a1f4eca0cfbd0fcd6337d9f9dbecce4e69d8bec10364f37846dd33204755ccb1a082fa99f9679a9639e0e690257f2b610be734fa4ddd50d9286efbf5380a4ea19f26044834a2941a9a0c688088fbed77f872d9daf2a292f78b07473423180c92575a0255af0ea7419d3c3dec1754378d506030506191d5ea9bc3510c1418515bf87354d84fcd0e17442bc90eaec280ba65b13d5147029a2082d9a361498a819ce9d7bf0c9fb8fd92270f246d94802ae1f8d7f5d184bf7fdfcd286c9a069ee3c2594bbf971470cb2bc97afa843148e1d9681be7d830b122c8977962a9b89d5886e82b1af74e551cda6f4f5d09f1d9df0a74305828366aa732f64c2e1bd457a5064fc26153ad7d2b476c18e4625005eeefbeffae872ed941fab204510ffda44101360e5a22e77ac61304e5251193c89cd1a9a3262f9c3434d5279a81b945f0bbbacd5d4382beb0826a4266a870bb213a28d241671f3e12b0d6987bae445bb9c59eff8c6fde84ddb5d2abd66e21f4028feacdb7250f2f15714ab3ceb518b0c5c57a7cdf63aedf58f26dbe0941b0106d1c49caf08ac7b2fcb2d5afa3ff8141fb9200748383693aa4a05170f7db003648539dda579740809db27a8b9a1bd7f5b5e085c52f885ea11e81810f05a21c4ff4f85ee6181f3d127c4e673c551f4239620fbd48b5623dc79acc5387bdfb3cd2a9d7e212dfb73ac8076bd991405d6da3b938a709ca155852bd9ce47d19e89d6e8b3f926e9f3f2f0e797178d814fb2daf0eb70577933f3c3493624b7277e8a0f9050b17fada06c62148d8159fdcde859f1e69bb0278095c27aa28faea04ccff944616c12fe5141e0df493b3e9bb5c2a5d1d44f383484298d092797498299496a43860e167bb15bc76eaf83722a56578346a2f6c1a040255b544260fe3b6a63a099bc355688745b8585fc030972c048e11d0e4c7a49947cd21a1aa1bdbbe24034a2e415024bbf83063019b9a4662e08ce6281d78d2afbee71f361f229882c16cc670c21d0c33d6fbabf82543674958c949bfa23159433fc3293a8cf01fe7b2923d8244ebe939b9afd862284212329a98cc636a6408cfd100d116e2e1238f2474b1d056238f5dfcbeb81eeb20991ac336b6d1bae28432a9e7e70e5bae661c4f62c526603afd1fa06f20f2fb08f60409666fcd30d144311c757d79ca2f9aecb87398bd25058079e3f8efc3bb8ba7e3555232c45bed0fa430855149aa67451cd7ecfb1ed1e7b2a48d09545889ea96879bb5f25aaf5a0965fd20a396d62f86ab0581245d283b42da8032e9741c1e00353410b20cab38caf8ddc9391bdd8f5a624cf616945e675310365b149c6e9e7a73fc330b78a21bada73eb9ca4dba1f64abddd7c4e45190275a9d685cbaa2c64fdfc62192b7d76aa2c288e0092ff361e20bd2a42f934cf8d4a64575994c9327eabf03fa45d8a861231d713b8b0fafba26b360e7532994d3f8e9d82dac11862e66967cd2e2d1f0faf080b03a3f310750618aa765f62f0773b535f2e9f0daf21c40b23479fb3cdabfe0e8c8bfac30cfc4793be0ec044f7d2624524a5b2592202386d4e6f54222142b15a84bf2018c0977d866801be3ff45d8943599467aea8411404facad4665c926c0dbf470e907881191d144cebc4370b979d075edbdd6b3407e0099de6fc7fd2aa8c139b99800dc35128d95d7b8e943d681e115b3ff06ce38fc63c7f66d1397b6a30a0a8c558956ade4bb84b92b96969acf311940ee1eb3772994223a6e49c7a2dc3bd5941023fb4c6d68f24524802d628ad4ef66eafa37b0b60928f654a466eb1f38f94dccadbf053bc6257fa72aae1a9e7f1d8c3bfb0fc3381f2a97345459b74ac9b0e0dbef060f92b12914c5e3d032ac7f9c0b53e6e4721901435bc6834258255d5dc53509d4286701a9c69187bef3c0cfb08e476007dc4e503853ffeb396846cb80b18a29c65e36ca7da66a60cb253916d57656b3a7b06d07678e4e9ba9df4454703e3a8f7243b159e1d52478aae30d55baaf519799fa8204a38f4adc2f514b0542a4f2e6751e2a974290b4ad44968dbb6416307da6e03dabc6b047b37245f53d895483e227eb279ac46dda2158f3db2f9ed58e71c2e23a4824c133e6a031bb5b53b291128b986eef633618ed2e61621f4bc09f75c57917bc59e37a61f1d9272a26b10bb5af1005b2b063450ae06d81455aa2b6631b977b5f1261309f88eda6c51fc734de0e93f76a64cc68673ef123a206d4789919cddd14bc41be1680b9464dcc72a40a7567566b6e633f241870beeaee453c46dc6aedb1ca2025f93b7e3e44c91b7ecc11b0e845adb145073adf50b8989088ac16ad019031652e2d37282ff5197d539a1bf8757bebbe1bc7f18a815d775eb71ec6b3bf7cc46615917956c9e6690448473f6777923501871c44b27bcef0a930e2f22d120c27eaefbe23d0246e738e5f92bef825c74f62dd35826f94f65b022f4c114b0c233dc74bfa2eb39d3a4f6140a7e2a642761647f76d8f4f587a37264ead52bc86e6d80213464ca32ad667f8579724ed7b40750f6674f8bbd7918a424fbcb2d9392fedd32ba93a1ed20eb97589e5052355b0ff0a9ab24502fe5f9e04a67268c5990eb2391d268f1006ac4c8441fa34fe74f08e08687a560d283012434d26c332f0d3ff719d954cb0acfaba93a198738c9fc7c9bc0dcdecf10baf194c3f3f537ec17cf535320fcc8937af52cc59d8f5541263bb3db50959c3e7256d210c85776de704b9f1c83e67617a5e23e676b30e89e9c2b8f1089228c4b57a3c66f675fe85b96cdf522f510fc8c74e09453e99eeb7be212f3d5cf771b7a52b6109c9d4c7d74b5951acc59142107aa382d529e550a337fd14dd195fc9371762507ae5b0b952ff5d76f01d9571481e38853461a7c5085f341a196a192d5e06905231c750cd99628f07222768a8b152cb7b652054eef54ca030b75652d28349486b0ceb872b6ee176c38a816bcb7bcab2b03c4538586146fa933cebd6f648ce9f259403cbc7cc4117fe432be7286904d86c4822532aa6e40b532211573eab2ea241079d0e7779170cf5d719db3803d647bfdd7fa7c5074119644253c8f53525e0d4d580568a929470a40afc60fe1dad1e800d7076ab210072bead1ae2a8eac3112426514e0d02215bb8c33a8f2ce542ce4d98ba39da31ef402da03bbe4780900184143c4a7f60cc1014c81e61ebdca8da4db32509a8ba400db0e7abe189516cff4429bbffa09bdabcbd071ef75c0101545a9fec4f62e22d04d0f4598194f34bef15ca3dd1676c5e5d62b57f2d1051a2b92851e954aff2db251ac32e8cc9e91d30a2573f173b21b98b187ce51f8d8c8f663b036db2799507133a950ee9dc7477ad9ed3e2aa39f7ad8cf53f4475f7645263e51d0be19ee67f5dfa4d7dd62f1f9ef07c30b4a80c4e4f54eacf951e693971c4f413e50a909c2bdd636892e60b9cfa4513196be5d11ae4726604967e14c101f88ef11cf0980c902c093c479eefca15c81e5cd932b9aba76b34a2d5fa33e21b69b53fedecc2766d02da2e58f2aa8a04b1932e3b88e41775f503865bd3bdcec992ed805673dad67956cc6a2f22ab0cd019c29f03a556607ccf47c17b1342988c646d6101b1b5a720eb904e0e12a466120603695f863ff34af0b59716dc281b04453307d471b0155482467beee2d6b6c06b43fec449c72d586f6f8c451341a84d2a5a98124f412a0821fda7ac6a8cc926c8e7014469a90a19113fe473432458aa0d01ad0dec75417da7f26f12f331b871e38ab3407ed0050f35960de53fbd9514d94954f3eaadc2de8bc15095e25f8c4590ebc157b346bb255245a91e0e466b532667ed321c6a284b738df7187370f339d3696ad2637f8b20e949230babb5e5b84074d254d4c6e4d9c27201ba43bebab04fe5051c8b302744b3aac80e60982ac7df7b300230b0ba68e38311425af9c7051722569e004b38a71357060df098a6fbf4694788c7d55b2bec246b4a30c95389864573d4348a601cba3eef12804fdb6cd86749506a30a93025d5a690bf8ae7d00f71ec75c05e6b6168a5002303970752c48a21f71175804fbf5d9dae573cf10142315579d0fb03b11cb5c34d613f623a32ade17945603c4d8205ff506c99db738e4fa6df47cf77fdf117c013ecd1c0edbd230fa5447960e7cb6beb41e840c59cac1569f04ae8dffb1dd4cd4140060369fb81978e6e08f2586543fadd6586fd1bd218dbb1aa4807fb6b6899a0ec4bd23952d363691922115efd638ebccaf6b7dea8fc49ba6332e83bd9f2c2012ccae9915515f672c4ff5eaab7a4658ee9d95aa9e7416ef0030fed44bec49cf0c719786c8604aebaa1d60b720a8115c254f0ebc17c33203a56b407cb2d72fec1db1eaf483ce62c347ef0054b35f11669ed6a7eacb04711ed505878b49b8a061d878676f1204812b727f5e1d4d84d693192fc3dbd6abdaa8018a0257c15d66c4581fd7a191719be36155cc95c2cb9d01b8907ab23a7ef7c3e1a53daff4838889c8ff9f47e04b5bbd690d28329764dd6b3dcbd3575760ceaf70effdf0a9e958d109e2df60b7d71cb38ea7b71f81bd0f267876d7dcdbc866840b7897f366a0c187542ee8d37a979652de8acaa7cba197e0e116a53048e3c61c34cc1fde5f308c6a35b10600151980f0b55920160ac514b06cd3bca2e3f0dadb7942008f55045894860a488f6e6295d450ad1392a0f1d1a5b3fbc3abff090526c630bb351a96f2fc9dbd14eabe03b6c6cd49abd831f13cc5c63a52b3453c9dda8862e592374774955d50bdb319f99f06ef2367c317e0d59f33cb765db9740e84cb92bff8d6f699a06bbea2a8e3541884b2ff64337c4a26d055054ba10838fc23d47f5193faad15883a5b0b2adcbaf69a43d3981c06f24f60d5f000fc84243584906a3a0139868d57a0fdd5eace82d62371b32d742f7b93f71d9af9e7c69fc3fb0eec687e2efa6abbc1822ea6479352d9ff7fbc4c856ffa127183cbdbf42c15a6b91ad5fc595363e6879b9773915d375ca6756c20b1a6a9793db3d2bb4626fb163d811df48c2338e9c6de0be14c29377da7a48aa292f951257b3860153087fac18dafa84237da3bcba0c0c4596ad8f367d26423a2375b17ea6733077892e418f6788c4d606f4610d450186ca101d469b36c923e478001b1e1e27b5fe3a2fa284421d3c5c601445f7e70d2004cbf4c071c9109a5c8cab90ea7308362d7c7168ccba1fa1f7f313547178254f5cd0d89a8f42788e8f16203736263143f9afc3a83f324f29dc058ba439cfc27a61cd717408ddcddef70b399f17340e6859606d5049190aef967496dc6b2ee24a93dda2e876fc679f01956adcb2bb3cebe83905793ba7bdb26da5619942054e1114ed500ab7d1adf6749854d0d8bbdbfbf5789ae047d0b7eac0f1b9acbe4c918aacef868ad54a0343833375e90ebae3945db8d2c311d3c0159dd4919a809774d3a4ba9b5bfa78026498b170cbafd727831edc932091ba53ac935f77b725d4cc14d302cd71fd7f9cb3b7beb346b0b12ef985f319d152cd7cae885735c10f68cf972c5c4f21859e1b399237a51b4260244045beca3fcaadd17ccb31425f174250c4b79666e8e4e468467e8de4ae7f9cda0ed993fbe9ca780718c45c3824c65cdbfbf070584c5cd38d41e2d2f401cd414d1d7c2d86d37bf9ccfaf2cd39c28631bac73143b65d9a7fdf71d79fc2d615ab847a041d3ebdb8e36c5c01089c67dfc4ef2d9bc8d72a0f674f06b0f6f4a7e94c7fffa593aac18d756813474699b7664dcf1e63c14604a2e1d5ebae7ab620eaa52687effb0f76914801f748ade632b119e737789997965666aad369608f626cdccc204b2edb60fa134c486fc5126e7c248f056e150ddab9ea8a37b7db84728de89e78b88cbd6bd984fa067c6989a713e3cf49c58045f0fb62e9effcdd864903946af8fac0d8087adea001d2d054a18033a3a5288aa37ea83a79da413a92bf7e9ac55d32e40f6e2e9ba4627ed00b4ee29bd6810b06eaa20f6ab71822f739d2c0c580e2c7d9a74ac7a64f2f7693b2e397f939e687576a6a82f38f413f5b883094e75862c8d6b28b2a15a8ab52c682be868fbd3bd5b0307b1bceda853dd8e1caf5379142a0b5b595aa7728526df6768a71b65460e0dfb54610c500b55a7b6b0dcc05b1a1265bf772ecc1ad87a360c0eafb6c8ed779fdb46c33087ffdd48a37654fb361009b5d3c8d8724c2b5177daf916ca6df28377dfd50ac6666c6e4f62fffd4f9abc300e730595136ded6212a91855b4c5e5e0cb497f70e6fb08ee60b8f258dd599447a261249423cae2d3aff8e0b38acbb28414864ed3eaf2e97a94be5aff425894ad4e14a25b3bb4b71acc992959f2daf7baaade2243ece050d6400e1ca7649ef5f7a0a9639dc42e7e1bd1b0a25dc82896fb95c75bc8a03a501e1c0ccf0f4dd9e45a222b8882d65da67700f3ae3afc8faa3c6d35dcd3050c022e055156b7071661899862433b70b2f1c74451b5317a404b17465c0fa698a404ee9752fbecf384fe28957e437711bab025b1109081cb4402278a61fb8fd6b4f6804b2da9c91c21d347f6022b7dddf540ecfc53b52415d92c6ce5d8ad94d12d655df594884dcf15dfbb2ffbed8b73f1b8ae3c12976ae4596c0b18716bae8fa95e92ab1eafe318a8fa6cdaf046a145d16ff5fb7e94257a7d7a8fabab4e906e13aea198347a627ea2a1a3cc277b9bda648991cece4d12d1e63629254e0b4ea376851acbe479e4956a35a385c6c4f7a2b6a6b60cef7801f32c413e75e01f09b521a72743495a501dc3427ba8cffe53b34c28e11766f929bd87f47d2467c1a1768ed89feb23fcc97a20c2e441cd736df3811f21c0eb59052e501445ea1db07ab721d9518a7f84dd3a132bb24c9432ab602dda2ecb3aac6bfc6305d358616ee1cd97f1e53d2dadac37ba8367c85048ccfc05f8e9ad1c510ee6a556e16ac237a98680cd669322634aeba8d5ec12482a1efad0622db51ae22a508a671be87d8597d40066f817bf7f0a1ba9b7f49bb6fb03edddeed1a946de4a741a83f2f48ac90e866623fe35da0328c8cd0d35bc5c9246cc17f34a6634eba2f4e906864cfe537ef95b9c9c064912e71e31adc1ad54c20b6168d0009afc67bbc020376bca164be6dfc7836a8e7f0700c6b52835b1f28c8b15faba47563edb6a090c2d46c07b71d7e3e96850e303a2d31997970472181a30639d2121070b39bc9627f48fe0ef4fd47e00780a754eac10a46d2c9aa431eaffc285bd64f07be345084a192ab83e08c38199c79768021450d0933e6e3bda6ccdfa20a1c3247257837ed2af9b6570d3df0bf00a685396b8d67d6379a3c300c6c27b0f56d9894fb4f1de214607c296ee8cb90cf82430b1f749db4dad092040a84521729022215224b0aa4dc5bf91086ffdd101bfe9445ac03934a0167035b2ee6ae3c1cd6693bae57e0af0a6b6ce0ff504d85972e0bb4b2621f0b2f1ec7c0c3fa5f216fe56a650c93ef3879d1a1750eb35c53a6550e8ad28b11586989a84a0e930c286220754b30cc425c84f17c1d767db4409ba59e62c9906e391090ed5f5d46b88539886bfded5599eff01957b26d57a781aba9da106763d5ef2db153b0df0a35f9b724145be44bc9cdfeb6070c964a3af2c76fb16b6dff35d51830df57ba7f9e0613b068f0cb948a0e70b13b91ce5696cd2aa33ed90d90de8344f78b3a7a28f5ce4defdc19111004846e7612d6952d7f322acf1664619d12964fee5a6b18e5069b4bc964595b0874c9fe4457428643cfb42434fa77e112a45bc8108e6ce0ce18c7b14fd77947a76fbacf9184f9c02dfba6efb28475a0c8997f939999cd03fac52d7d31ec228577a4ed6080c3742cb33e785853fce33a03206e0b81c6043e9f14a307a28f22ed4125651bfb733d1796a351b8cecd310ad16aeb9396bfe53065944ad5d2f9ee2faec6965ee38241295be78071395aed97e4c0135102879a67e794b568eebcec527e237f7195d6843b975f741324f01047ba54738d3609264803d8992b76fb8b03863b2d39c5c1d242984757feb1e120459f4cb81779a83dfd4b916fc6725a3fd473fbd30d2109ada5f52b929c16d0b82cf2a7a00eeb2196f527f3f6dc30666cf030101067b03cd316d2d4289222ec0f973751bd9f720ce0a7edabfe2f6fc1600381c89181d6320eb09cfe94ba75569b56059722a5318cc794e229562027e9b64385f4aaeda1c0f1822c9b5fb89de9e8b36cc54f8a8a342cbd8ce8219db717f08cf8bb7bb4b4a6c9f6437515f9220c9394ddbb9d818bc77219f831048a44f9a1260a2277869a2f55615246ee73c5c423a926853c7282369a740052ea065c6892646e385cc19dd30634f5fb8359c2c1895425a0092ccb63d10540c298c0e9fc0642b852b3ab434c69eb6180825491e8ed8f19fc1f3508a3c6334ac39e02dbb03de21b011edd0931ec1d0601c7cb1d7b116d04bcdefcc87ac2fb27ec0c535345470bdb703f27053cfa625ed79fd5d1c31b1294cee786d1af53c1210f48c491e43cf56132690063d56e7f8523d9c62663e96f3bf0ec6249ad393fd850d6ea60d5adc35915cb8a79f7c3f59fa2d22daab9fc2772e0bc3eeb151ce7bd4745758883f1d4479e9f985e788ab9d971faab7d179e0fbb95ae8bb62ccf3a7ac59886c6cab38b962f664222bee9d15184d2d1cfc4eaec412452832f4fda6c053ceea5fd9ee8a2bd6d94c9eb5b60444a9fbdc19598082e0c7fae0687ebf235b01722acc76969cf2eea79ce0c84b7a2a6ffdee7a709ef4f4f0024d5244486a99e65daf9c8720b03755a496b7ccfb500964a7a5b0c84ae617468c53dc56853eaf1aa2afe8cd3e6d6c1e0d820b7df3f03bbef41035de012535ca375657f2ad7a0778c0784bbd8028192bd8052fd18d3049504f1470f6310617440c258b87550e391ceabcb3f4ca9ff60bc8af20a5dafbec2e1cf6e3d37c84c70d0cb404536505a6e7b1128dc2c370561b84cef8bc5341a78de08f0eaea14d8bf21273ef1efbf0f6e38425027ba444667f76e554de0489518599f7ea19b0794bb33a322063227420b27181efc32a6038fe68176de3055268d4eebda7dd1631a1a662c9c237c0b89658dff612349e58f1dbd2c9942bd648edec2df8339fe95455cd3e1fd76de43ac4b7a1225105e353417013268162b3c807eb338aeee37bf4fbde461acb6701077a5fa31af7885fb48dc9b1a5a71ae00bda8a47d1339cbd01781e178ffc03992e944f54c5e5039a0fac7f7ef7b91b94b9ca495881c97b7786b74f648f3914ec567d849690fccdd676e789ff004e5821acf1dcaa7e34d7a33726deadd0143e5a399acde7f5f061524cd4565c01531440d28d32074cc008234da7813b66ccba8ac9c85e4a42a757edf421d96b0b040374576cede8b297454bc5da139718501b8e5ffcb5131fcd001c74c6ed5a7f43c0f15eb9caf6d74c7fec96b3c3ffd059a55594932d6ab7636164d7f31910a84577c72b28c8c1f61996a9aba7c817da709011272ab27872ee28694747f916184bb8119fbf777d7198c128d70b1641547bcce63acd062f8c3fd51551cd55e53b35f018bb02383ee370c2a78de5c10fc9c79bd5857f3cd3c2ecce7d92f6655a76d1a882b0d346ed393c632213db16c616c3d411b865b41046663d93bfa59e56e0523b71802a1f31a094643aa49fff43b698bedbb7f6b329b1bb44b128aa64fb945df2e919621e0ebfae1bbb6c760db60e6dc9252c6c57b99db963b436329f6f899c8432930bdcfcd09146055c2b8e554a4bac4ee5c453079f12885ff8a8244f56d0c3ad4be9c53184c06128a77dd18ef1dfa9b53e8fdd253d3399f96a584bf2fb483e798e9b7787c15e30cb418e5434584b6ed46abcd164663d1a078b4701eda74678cf4be5d3750ebabcc562cf909f80b85d3e2042d2daf569f9ff97aff2d1bfee77fa82df672f1626894d195aefe8a28e4e9130f8434650a1c4953c1666d5cbdd57ed4ed66e7bbe22cd00f0aa13a5d12f98c9447dd8baaab57094d2f815c789fcbb2cce1fd1a053256d23042511c8202e35052e46982a5788d4299b3e3487c69925c88c14799f51da94270a3a1a9c7eb13c2d900097a165892d35ccd3a71412274480b4c8eba86705e18dc261d1a285117acb130c0f03135fec1b3c9e19e4c176997c7cd2cc904b57a168a2aea0b162cb973c184a3b8fd5fe56e7fae9062c7803cc8e638a6e54faaff6595294c109607eac4686f5e95b3e68a5610ba009d04079ceb706043067848d3ba7cbb4854b6ef4cbacd9af733f4754faa54c1fb346ddf93bdb93ba71753c064ece97ec1d491881ddeb4321fe5c2d8d0ac34770fd3cd83879a5cd63a86c87191cfd3b175d6c57de5b0520dca914acd03166681ef616c6b27db1605b9d542d73a021f05703ed46356ae3d54a5c2b99f06f3359a30787f2673aa430c6ea4962209ce9744a872042561bbdb984a8fae7f57bb6b74db5bf4563b66db44ca28a302e88902a37c103aab464ee476181791a06f21fa7b8c237298530ad7a1c0e98806e751abdd5009048f0aeebcad069a2663e84015b4fe1e4838ee3f0f525842eb26c70230156172f626b5d1801d290e191153c84d76e938028b879cdd1d2e0ea520508e600c043a1dca11472d9a56881315e970c68fae769a8a5166df69956e281d4d3022627c46c91d817c6fd73206d80549e47616a646597f781c14d83dec1512ca519af601ff9f46b3defb1eabb4b7d5f463291412e2e5b299d2628dcf5814af005f362fe638bc5634b2185cef8369f394aaaa3b2f54a1cbc27a8f12cb6a98e426d90475931534c04e2cd6adb032b7536cf277e223b7b991a09f8223ee7c5ce9215f341ae87384195ecb2a36c5628dd5651da18942316246591c4f79e5331395512f7f7eeb84d0e2763e4d1a05e6029b734e9a7dd28e2dc3ebf8a847e0b788fbccc14529b468ba2ca2cfa4f689b64efc04f35c6bd96869748b20836e2e16dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
