<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b30e043f29cec34c80b0b56f17979c279b5fc60b48b327eace87ad049e478985511cb9e247ab198f76b3d4b3bb7ab34374e5992c2124487260a7e9c170983e425bf2fbc3d37f4e150672bf32485ca762beab46ce92ed6ec5b6a3167d8643bfdb0332ec162f99120c900d1a583096bcde60404b6b6e584707852a8ac8b9a6c4bfcae6d223acaf6a189646015295c1aa4e8880774d64aa6fb42ef5bcb2bad96a1562aeeb87c3de04f1b0267dea2ebaa754a108f70c35c034db511a2b95029612b9bb3a2dfc3f77497e264c258ea92eea8b33af20559debe28e8a31e3bc330c406db88a2eb97b4887070fd2576e0b3c928d57c90fb3172b8e93ec5606c44292739a3564921c5d5bc08af5eea351d5a643cb444dce057c79a0a247289c3d82565c6d3143abd078fde83c8dac05b81456a0f373d8f9ae3aeeecdd6a44f163618e32c0d67eb7a3e12ece89b243cedff94625119e82fbc623b9604a0e95322505e85cfceb05fb2d853ccc91db77f608fdb959cf1de5333379595f3693787e0fae7f61d03f57f41f2f19d96f17573ca9371eb773f4f91ca139c8b4fb2f5421cbc07c86f85e14f07210fa4d661f293f74071bc47e87d855ac3931841ad0cd6b175bae48de452796d10470478960c11083b5408eb8354ef90f6d979a432dd159f77f20dce6861dd9a68946fe95983e87c874934a2e82f19bbcf95c344978866ce7c7ee494c0a52ee0cd94bebdbd7aec7a18be4fdb49b02798dcd99acef30ea47e6cb7b4ad17fb5c0e12915f073fa813018e20d6ed275f4d6ba5f0fbc555b06b532734e5b914cf83297a54a1b426972a0ac950aba6b1f686f576684f1abe1919f64a06c80a500939f3af0fb8e162439cecabd23d1625871a9aeb363eef10c011f6bb001482eafcdb885890f722f31c98d1418b87088e193c430f26b4d0aca587228295f5eb16bd3c67e9e6f7b7f2847017b460b4ccc2e0a08833447084306886bdbf334e732ce44c0a0f20828b1dfa1e861cf604c0b784b1b3fda25c4bd5809349d155a83c2452ddaebd6d01c3feb3211cba792326b4f0aa1c12e2209c4f54edc5028455ea2f2764c13a51cbda5dbbd5c1721a113a46d2ce4ae130a1e4ce364ea15b8f357088793084c49cf4e7ddfce4a55b07e28b7df11fbc386403859220d7be386599fcd58c543ae89278f218b004b045362238f75427913f4693785a20fea2abdf48a96e5c4a46b7c52ef474fadec4e2f48c4a51ab79fbb6540c2796167b2ca23358e72b0d96ab84cbcdfabbb2baa45f899b1e7fd34b049e59bd1d86a6b6a7131ba002fa6b44365bd4b6c7dd938fdc824e061c537c6c448cb91a953c4422cb8cfd46daa6121aa97a2d3902d92c2611952932069e50df5e254a4977bc045725a004b1772dbbaa497c33b5cd87def2f8a028df6cc00a6631c18f5320b7fd0b1c8990d2f364ec3004fd8d206a1b4492a7d1174731c469731f6d682706fb982d201fd39832dcb98fe4ed45b2c3258a52f437ab6391dcc06ca0d51c6d88400041879373ca83c7a453a7c27895eed939d00d87a137a2d361704515d4b6777a8ae54f5cb3e23f14f87b50f7f406c0d610c92d8e32523896c6fa94fe77e9bec94a3b37b0135f19bfd78fc4d51a0b45f526223ec6a65885b78cc5a7081a43ddc7850d7fe1b5a8e2ebce78082243a80553d25df007540255d18550cb57165ee5d9b018c7a24d630e42f215d40374a51e3899f078d3b99eb95b0efa981a4195e8aa52c137bd208d732919d718350388806ea3b52c7e80e74690503db592bd7af09754d70fd99088074d1b3b7fc338c04a8e4baea6bef2b0656ef3846760b25067cfb07b22a68dd026f71b311ff0b695968422e6eb53d0d61752bc84bd889fbae96dc4c347080664360ac038a33dab692c016ab5237b00b5ffbb0fffe72d1d4ed2e6770759ef4a05f97dc1b59888209b74c92cba60f4006eb336223ad2c2ceacda019e2cf36cfae15eb8e5f155e35ebaac52887ca5cfba0e4c0a2db5b44210cfba1d55799f803189d29666bf75105c8e8931a8114b367fd710d9a9d601aa185fa7341dcba5c7f92bc6929f7774b3f68bf4d99c20a61b1f544e34405a2bcd3ae9c7a4ae8f1feb8c1e06c7ec5ef0a7b7d4bdd67b25d3b2d28bfe04d8bbdf36a40a3b979c1a724a33a62b72f4a84ed61f964184de9ec0062b45d8ceb8fbb0e49b9b51998313d24046ce8c58dbd1a7bb212a33305cc9601e39fea041ea984b28ad8ade8356788e947437f8d2a2bdbbcc2290070fb0d3ec1fea4e73e8536f4776b307e21d4148c1a8249f8dc41904cc3e2264120879b0ed6eadd531ab72c304fe6d9018947c45e2dbe27ce76d5da5e9e4443e454628fcf565dc8f45915c43e762eb0c18cdf9ea216c81030a1ca3069bf3982ae183f52f57bf79de904180c29787f5d9db80faf843d1035058c6cff22672bfccfed74add1b9786f82e6d26f4fc98bc6dd5befd277490f3f2877c321c133ea96aa7ebcbfd7365b73f8ccb0b9bc10f82f29e1320c5194cec7151a6c57813ba903dffca9269d0e8ad936c7e38fdfc15dd6ddbcc3b37ca140e733d0895e0c9d3f1edb75f2b8b3fa7c2d8be8fcbb1cfb7a7d3b5bf75fafa45bf2bea64aa0ab11a3ea391203cf9e46daeb1c5de508424da3c758494549d62d019ddeb11360357ef18e7ff2967504bff3f6a8b473961c887523cf7374b5156a2c83daab4f4c9c8ecb37ea3a200370e9d85d6e27bea3a54e5fe59f84f8e5027f9be617fbb23f903bc3b1d7851e5af76b9269064e9c6f74a8d39cb372ba9615842e8923e25f67077efbdec717e2acde6e90c695ab3c3075626badebf9d2dd6523aae1a78a3a12498b0b98a6727aad307919f9df7f7e2e03689141fc15dcc2b4178a2af940d735e3d1593d06422a762773d1827effa034b94dbad7b351dd77838e90339658c893a200336356a1f5d4bdf4a73e4efc201ee11f7a1378c1738f22c98c0959f7b7dc5b624b73a78bf2922163e849dcb7a157159d41d9623fa1f04229ad23d499ef7890cd4eb7935f402f191f2972e3e4a41d35431d5050840579efaa4e6a9dfc2c636d25efd69986816a658d82766158b07f5aa404eee94471b88087198697277c7d7b09ee70bc70284597a6b516a53e9ec229b983b8bfbfc153c8ab85cd970aba22fd3acbf15ca5d5ae1b604a6f456395d389782e85c0be7728e240311c09d7f322cec1390ea51969369e1e691c3803a90d72863ef1688f74408527b7ecb7a18501d23b327208494d1c2562946c9eb7ca561453f73972d3be8ef56751c890644549b12b860e1c0a86a2352f10555b6790d3a11cdee4ca75c29a8fe1d2abfeb077bd49257a03f5818ac3400d08c533c0a2bd7e77639136c3173af873103f72acdf1a4a13b6077d750633c78977af5deb7496bce370283d820de1d156bda383405ae5763aedb81edcb9dc849609bec04a09a022194c37f4f72225c197551ae8ff49ace5b91f81f49aa005e289fe12e7888eebcc3c43aaa0c563ad32d9a2c0ef348d12e2aa95e7ea008e476eb8db5293f12ed54adc3e4ef7fe9a5d090d7b9bd1c55aabb85ebcd4de786abe8cec338b3448ed7aefe23956fc16ceecd98652a687cd3bb7130c9b3f967b9a204a3ffe6afec3fc665ff924c971ec631cd0c080e7d5f22841c68399849c18fdae8e121a911bd6eda6d0fb1b6f2607fa305a210d690143b01b63f08e32cd20347454217e8e59f560ab4de54e56163b9c0cee64f0fc0aee890973d1bcbac39a230f7a9ce462782907290cd2c8370c1fc7b13426ca5b288119c5751dae03c7381f97b1010bfb494f53a98ffa2f7df62a213f1543459f44e4c16cbb0bcd35944f02d1c3ec9b7c996e9f8a56920f8bee08a2136597d34d4d225a2defe639a574079567df4e37158b8b7424a890fe523a5766d4c1a82a0b8dae69ea759be57dda6647a2fbcf1c577cdf3b6853cb8ec735c0a3651112ae028f7ffacdc80e82dbc005c444c1ec1b8547cf8304ae0c0af520210e57d071baa0fb45cb5bee3d653555f943dc92704b0fe854b6f3099887b2ac236f2015f5041d80011fbf178c8398313ec5567fa5ca9a982ca64c2bf344442d2c846ceb0e58a8859d26e65af5fedfd822120ed933b12a3b84be7fca7ae2ad767a5fe144cf17db5b89dd33bb90883566fac6dbd26a459628e97b2eb40d1cb336befe08ff0b0fbb9d5b9f8c8e09550f0d3357fd7eea21725f1edfc04f4422576d68ff7ab511082389541757bbb275ccded5c920d11b1e3caea341026288a0105bfe4852610bb741c1b41d7c606fb9527ac8608523fc595dc973723864f98cf1b161eceeb22868e695b9502ed15d8807040846ee012ea2109651ae7574dc38d895e6a72565b2ae4fae78bbbc3137174c373e321d360cb9b0ad9a8fe6c478131daf8703663ecfcdc4828a7d9e0869d19b02447845bb6ef937813a67cfc8339a6128f2c09c36ff07afb75883c589eef4e202bd47e61e3072a300ceac7ccaf2bd3c28c8998f32fb6d7e798a90ae0a14727ab566e4b626daf6417c18b10cc72ab7ced7a5cb1483c8545fe3529e8015bd10845303d4be8d88a8dcc9a557dfa9486eddd99bfaef49acebfc32cc8d5f5791412767159fdec3f5e687580f202cea985d4830417b232bdf98f11bffe771548a82d3d975fd8d75a3ab143a946dab9158e55eb957d204cc91a38bbbb4a96052c367f26c503ababa8ab2dcd765845a309775d11a052d8b1230cee396328d13a5e309bc7e8b8cd62ba8387602dacefd2f43f79db3e824d5efcd42af4a39b456adbe7185029e94d3e930db17aae686bc0e89661c4e0f636a20aa7f2a93ae53a557e57626c24365867798688fd7b3f961d33e07a4aff6fbefedb1744b2512a4f38bcb3e2dcf658fb3017ff42a90cde6173f29955f0395bbf8359b59133e25b86353bd7f406ff2a6059259198cecf435eb3613c9a5d0a81638514b95b787c32a8b1dc31d2bddd995a762e5c06f61d9cd0836f5ac318af540733ee1d48530c6cfee8eae7a379e529749cd709f8eaa9bea62c91d5dcc92dacbd2ef8feed1f01b6ac8692828dd3e30175e91f34d7c0603aa58e03755d7ca8eb9634927478acb5df6188c4a0f57b713a7cb053c6a9a6ecdbd14383d256ce212de4aba71ad49bcae1da5352a3aca2bb7e38a99dc44f4e3597459a75058e64579a7a1793cd79e9e9ea2327039c43727f89e3d440df87acaee69f792cfb660e983412e64bf8a720de653a4d3cc6e3a98aabbec2bd6e318a8caf635d4d036278c49c1b12f4d75545dba778a159703c3f565840203561862258a67a6d9591d03d4368fb167aaa0cb6914c4e7292a306508494c84ad7e06efd99b55a6e041efbaa868b285ac2ddd47ec7f4065a892bbe60fea89862fde86af65a40bf010a2e4eafc7f0db82a8e2bb9d1c564abb032145a7f306c0c99d2536452b4b77b42d94ad448a8c37bc806bc69d5ec18b57fcaf7eaf4952e0c1a90d52d9de4e4d4b44ac109816a74ffab670f93dc0e905766f395990210c7f617bca1dafd806e5327e673a4349b235ef779ebd28a0906068835f77af16d2499f37622dc75630f17786c7f6e1054e7dfad4251da5e5dfd9f0f818b59f6879720e692d7a32a4b6b2486acb8425a46f84adb629b7b2083a55f45c73b5ea5710d7a5c35b05ba11045029cdfc3e60cade96aa9da2c768d38db3c20a88efbd13e8ab2da840f13763d7d87d8aad7c24222633406184640f5798d01c7696b6b791b80eca38875974666d22bd0d172da582ce04a6d12a09b7d5d36a002930046c8aa58e963a2bf3c5b72dc0126c31b76757683a7c31187da22bc7f5f8cf58a48a9e6c653f7ec4d0bc8f573bece288b38711e450704ccc3b9e9d24057d9e2654134cfbbbdfc4bae9dd302d42ccc9d1dac4f5eca9d34a5358e30d101068f76f51c2e24714f12bfec7e7290286cb5c82c2e8d505deaa768fdfd18ec097ffac6280693a2411e12bf91c531e2a8fe5a7c699b1dc4554b44fafb1c5d346a24cfadeb00abb58365dd063d56bc39eba969a7041ead7ab6d190ce966be66d4d7a665862742164c68f2d7452fd8cceb5949679d84e4ca028d85eef7c94af0820cea4ae69f46c2b19c638c3ab89d0d1e4dcc377111e71a5163cef18b871e825847a710af48812be7ffc25d62f7e84e5ef7b89d737edb5496c869eaa524f57cab2fb958c74406529bf8175cf2e7d6b22abfb1dfc167ffcd631de0b53aaa356ae7207eac8f30e444f40c880e48560d9485b76321f07fc3bc05d62cc34e9931894d048d4834451daa8ce7da27eead55566aada40f81b9b29a564dd71b561cd9c5dd111c117f1a8bb95c834870238d91e929849141ce557676773b748d56ff43a343b0885f16bdac67ecff5516cbf306cc9199ae140c50c9fe8a9049c1ce3904fc04105648a84774286cfac7b1cdff370b35d4f9b879bc48a8f4f5b5cab97e9b7ddb28d3736026b202899b1f8d8f85a6ddacce137752bb83d8e5a029a051a50b34017d8c08ee19f5d0fdf547fa1f98160fdbf20134d0a2aa856a433c104dd288fd603c4c8b6e28e0071a9811d19157e9d96154bd60a7d315556740d93ddb3ff5f87552df02ce9e478b22e6f5cbd4989f017b5caae8f55a97322bbf057716b94b62565780a17d2a056ba222cd1e8d7fc59e8a08060f4fe902e29d5929aaaa1c92c6a0fc72fbbce5058354a800fca9aeee37e03d5c25b7bc10647050f0ac15db59f028d79074c9d2bddf74d565eeb5768e96dd114adf58d3d9a0a82d7ce736fb1adbffc8b9a22aea372953f95a1e084046d42fb4ef9c7d87ceb9a7e4c53ce4da2ec71f0f28277259332ff6958cb35bf322754ae78b5c68e780478a1ead029afcdb067ac8c15acf2e63aa540e82d98cf124d48f862505698ec0edf75ff330638854d5d3bf474571f55a33ccd2e845cb2f7bfef8751ab72bdad38ae5571bc1c6d538ac748172b90a3194a30e6432e457cfe1149b7ae982f73aa46a2d91e6309c47a66f633092c7e8aa73444f8198d22b4c127dde6b0c2e3960a2624440d53a7159ffa2b72a30bf5200cbe502b51c3532eb9c362b7443c9de3a3607bf7474e9ef03e48975cebc01a436654a90cd4114654aa86deea109b2347dec5a7af0fce5e44d41139c0129bd34868ceb75ba726657f851c48ed61789d846311dd3acd08c3e8610d2f7fef31d88b224cc095a454942c23ca44cbd9d7906a648d78746affb7108d619f1c16d9b5e675aa7d2c0ebf36574cf1d3ca1f12ec7e11b524c70cb7d2642507bf549e40b74c9a24f754ef2e35b1c32b7b26d972a576b835253efa1c757d746363836ebee7723393c2fd45ace40a0faab9e3c699cd818bd136772a63c9bb4918eafaeab40a6ddffbbca856c0fd079ec1bdde7dccc64fd50cccdfe62ebcc90481c8d43a763f01e619b898bbee7f1546d879f44552b74d03ffaf0e14a6078c3c19e42387aff0bc83d186fd851709f6f96e0ee6058522b2e6c65d199663244f922c81a6de86683403b96554ca80242d032f08795c40a16794e1981292e460bc3bd0f17c0e8da00a1b988972a11f9802f8d753aed42bdca196d79e31713c4222ca34c22291f0bbde7e9640aa0e0e7961e050d60216568d4d17b23350fd56fbaff8365acf040d5a309421a51dfc1d984c075d774b606d4f269149a7019c506d0fc094f9bf89455bbec86eeed3d47797c6c4db02a3dbcd40c02050b6209cc8aa2289d6607e18c976028028d6849bf0b0b9fa103b8fcae07c76381c4ec085d84956b81adcc72ed835cdd6283289504b2927928381b8946e2d8114c1ec05740b8ff321e1d679c631676fe27e4a87deac8e4488072dda83bb9a017b2927d1132cb25a2144fcd2693da19898b71e80e3c465c54b80db3c66ff11e4bf1ae71bc64bc445fc20ec272c70f748942cbdc410e262382ca29be48417a37cb47c20e84bf243532c8a6a80b1c927f96354bf46957ea69a78234b7fa00c6bec48b782822ad856f5f1ccece4e460b6faf0c49195bc06183952007d9af05a24f2c45574c59082189f9080fc4813c9b85d1cf221ec776bd34a64ba268d65aa9144d6c7e8f3a5f78807831735e09646287d79eb80aa3e8932d1bb4248a6d63843607ae671472cef1c57c4e43c0378956722ce23129505f9ace9645fd1804395c25b4b0faceb1d6723b4da0f878f7d917e7ef90edde26fb8cc275deea880253c75720040fc1445ea3965b330225ba788278764ffbcc3e21f366ae0957ad8308447bd6cabe1a8826333eeaa3901a004136303da8c0e5cd303e9352c9894b2ca79b535901831671c00c74d1613778f5ac97bc2346e6c607816c1bb703d4c35ba8f91cb4ef6663a429046d06cb65be665968710ffe9c208fcf2d0287fec004b9ec227bb982c03e49b667773984ce804b61877573ecf0f6352b1274d19e495ff92ba1e0bd85313d104c1c92f784d8178e2e97b1e9d26996619c09e4a564ae989e0c3cab7d76971768b2e53a0f53bab68e200465075fa6c3747f8960ef54988cb577b7ebdf8074f90c21e61a632234a1c4b811fc71ea2823d34bb63e8535a52c45b8d52725de17eb7caecbd524b60ffbf9621bc3e844ee2c4b7e4cded9d71462ed75d7a9b174da0767e3b6abf176cc918965d292408a0582114e00130a0641e210184671dbd0071ac66fcdb30f62827a3f88fcc1a3bbd145b76180c625e42d740bbee6d6918b86793a5cab712c320d67eca7235ce7b98c968381b8f6bc3211631a000396a4e5793a38b80983fc7a8a247cdd626e30327bdd8314820a9f4c7e2197b90aa326e0f16984b0b6916c3481098f100ab8709194f1651c402729a3219b8caef1e41298e9b4c08580faae8c5249feadfb53809e7084540a8697ca377c6183a0b88d5a305e72aad3778b28e87fb1b6642fedc8123b2a3dfc549dbb86f3f0701bd71e2fb5e12453dad1375ad7e5470d32ec994fd9ed6d6e9483c986cbee7b764e13fcd72000e796678e8e644a55784592bbd2e40cd6f5badbc5bdfa82fe4bea75e967511b22f0e4672721d9e92eadac11caccd8198edc15975542fb286afd9affd8d2cc21e929cbe1a7f17a9d1ec5b51249301f3917171021d707600cf16d0677c86fb1f9758d8af4b8f4c7a0583abeb2e8639f34a3b3c38359af26454759ceac578b1e2a2935aa70edade6bd57f4642f7d10f639977fa5839f5bd7e12b0822376085456806c51d2f56fc72319f7b035897ba83b4af478f265dd8f4871e6c12a7c32ca62a3f37a74e434a48240da6cdbd891e4800257c703dd4f04cbbe4abdd7fcd7b80378e4e3834fd7d5fff333d45a694a43d9f8469adaa140c70273937342cd314cf9a717995a8d83e4b15c949b2dab318b986f70b0a1bc5878db8a0a9be35e3b48c7f04c2d6afd27561270f8c41089bbc3719fc20d879124f8f4f9f3b7b5fdb0f8bf83c5735f81d794837317d09937da1c738c895fdad641049033ce4d706fac2596aafd54a1d1c4368efbd258558395d6e81227da7a61d52b4fdb05a9cd9cecbe82916fe0881a150ea17b4df38dfae821cc91c772b0c4ba17c7b7e05640365fa629722e20dea512b644c0fc348b3e8a163acad8e46c35645df544970c6becf174a665cb2c66c8c71055353dfcade0521ac08de61f015d6aab6b39e3ee5f23724b438d364f76b945d8a1b532f079524d4f3c7d4a767318be2b40c055dc7405a5829d4d51e8be42aeaf18792d471ab0d6776c78ea55f5a16ed6ac1b0fc2cf7598e647b3ccd0026065215cf5c68a159b8816b1450e6311c07833b8f3216f3c39e12065ed05e3668018195aff66bb0c9ba58be4166d92cbe4280c33edcc2a2ddafb65f02243ddf2813c742ef765e12983bcaedc8a76c2d133d338107f2c8e19d8d031567578c85d54a6056a1399a9d31f83be7d2626bfb4754df5aa23765dcad18847bc2bdfe41c4250f8fa3131e75e45c1d5a8237b28fe241909252f279fcc525384d2d89d4b4fdd3987323c1bfcc1515a334429a9bb5457e6b96a2ea658509bf3e6a0f9a7f73717850713b5f91787e25d7183bf8c03663db1dc9440893c4ecb0642ca27f8c99c9015bf89d496378a24394359d7dc0eacfd2922068a038f2e1348c4514aeb09240d252b10f8aa48a8c331d522630a850fbf7efd8d7ea799dac6d371c05013d6bdbca0130302ecb090bf7e5e64b5c4c7c7aa004d25eb873b85d85b12f1a6963c96338d2246f08953f70410db7010c90e932d4518db6799dc40ed382e2619eb2b9e5528a3490831235a32d94142be2033756b537e1befdcf24c42265f532a99e598bbbc644e91f0559b235f08676aae7ce6e7a4855be47b89ab6e864cbc191dea4b18b300b38ee1ab1e0f2125398af9ed2f092b78ca8bd878b4dd455fb7187eeac04dceeb97ddfcc07f4a9e3c960a5c89391a3cab626bdf5f3a6fefc81c34646bdfafbebec733a23b1ce334d0e31fcd5c5834df774802d09d4bab8d46499d5d07ec219c1fae29f06f6dda656ce301219b5d99cbb06355066858deae0d8862607f7d8677df2802b0378d84859395677976d06920d4ac0ad8ecb619479852fb2c7ad77ac6ba16f8dfeb3d8f0ecee2b6a92874df683ec943c4b495d7dfd2172489dc5b90ed395cbfef870c18fd7ac829fdb29e639532fb792edbcdba32d7b5237147bb3b06065af4dba904aaa8c7f5582af4f218cbfad36a58650f4092d8c93b12ad8ea34fcda58c5c5f9f4b34f92427a84293a5cc9d3683800067be20cd8110ed5ecc2b73172775b1d6c2017b24c0d47ff6992afbe657a6fcc6261d7cca901694d190105dc7be0934e64c43a2b231b5ddb6a411cceafa6e880d7a3185094bc0a4588972b3d5dd08fe2650ba1fafe5ecfcf0c1f03d8c323a04355f80df0543cb7b24cef08415c162002b4f3a55a3656bfa5c76301b699a283e0cfd0ef72751279c42f91001ca14731088ed8bc7d968a8374c3f06d377e9e58ad2be652ffc8c533a74a06678899aebf302eaac9a98b722839e48ea2e123fd3b0af07d4565f0f071ff264341fdd8f8f9a794a5998dc4f8e20a73953d3571ba9d5d26856acb60f8e9312619f61b3383db391422f45656b9aadd7c5ee0623856429eb2660fa6ff9e120c486d62f7edefc06ce46690418710dbd378cb1638a23f18ba9e281b1f7533a74906bbb5bbd52d0adc7b48875027ecafd6c1985ff003d9f8b41c0b1825e0e2622138db072caba13f5760869c46bbe0e290eafd3fb73462bc63e2f5503077e7d77294db963f7312e8197c200c58039a9fddf0658f5c3c2108ca198b71af7eb33950aabde9fd926d6f18c3c144bfb010ee94668355d7dd085a6d8539f1beb85e7acf1866b23578757d8082580a50daf7e4c86be3c8adda33e44f932bcc48ec6982343b3fbd1f1862044d79489c4d76d9af85ba326aef36ca7612d36be4ab2195a393b33402b84c490a0e66b0b766a6e973ac73d05dd240b3aa5e2388ecad2770291d324267b64594ae83388ef7da31b7f2aab84199c03b801d0b9e86168c73a68e00defee8f9c5019100d5b692eb8c90a1fa78412637e7c9fa9bd7ebea3c002e486977891717a035d1245c28f73966fba045fdce85bda77869ae2d35af2e5f56b3e505efd811df180e3990c10474c8dfa40f55c4e60ffeaafe64f19946d1f2b22549fd02fbfb8bb9a08bbca1a512e9053b6ea6259c8a8820a22c0ef49744c999302ca93569e9af766e7dfa4546ba405f82bc720fed9877154d7ed0116ea285c72a0fbd9604371db5961fe45110069107d4fa3e9b0af9d9318dbf220ae31120f0c4abb0107ac9929035659e0d2cde25bc8c1b3ac2886172e576288ec8e7480f27bf49b3652f9ca0198f78e7f94d555c7becb2834b88aed21abc268054769a5fb9cf0c5105f1948f3df8ab87cd1b502406bba0ff5e517370bec94f70733f0b522dce4ee15b926147500aa52323d3456e241c6f27c3c02030680a6076fc8dfa765f81ed88bca1b47a8ded60b7ef463ff10e95b3fb281a50acc86cd9b14eb33ce6ba78bc15209a11e80085e3943621b4ff828f7535aa0d0b7d898aad3ea2d9cf35106c35ab142b31065d4aad3f359b2c749668352217639bf3b3a4612e7537147a1cb2e8eb79873630bb3e763e54417d6d936e41dc5826e64002e027125f1cdc2fb087b229e4c27467d80ea538cb05da5795beb2c45848a935998c0b576f307d437f76164371f064327b5d3337346b6d442ed065f42fb5cf6608c0f462191f0a5f494b8db6a3c9227c0955df3162ad08d9eb27ed5dcc0f33e6396f751dc3852f65da7fd3c66784ecda52d0088a40d3000507f80737d69bd2d6e9a3d389846b6beaae43645d2da671dc421fe7d8cf477cb377a9bced9a67b6328872de326bb595310e9a18682ca892feb5cc619ce0d73fa7edfdec41014ded7070dff6d2ba0767b37fa31220010f3e7e1bb9881d0932b994c83837dbd9215e1cdfe56a6d34faf60b7712d5e6746df52afed97ee5ff02fb89ea97744974c9c23c151c9f4f2cabf4ad31bea5a0d070171aad157bec11ea3d685ad32fdc2a73f9d54fc89af05c592510c9891cad141188f9bd75eac968f49ba71ccae0cc6149a55eba75cdfc7e362d555072a241ef4264142a7ebdf85158fc0998d9a65790ae90911961ec9f23dd12c6178204f635d52b4fdc124b2b9e3502d501a8bcdbc01d49973f40e4e9a167427feb6aafa693886e1240ec001d6f81e3ca26e2cff4631575edfcbb9567d791b94ba701ff6617a7efd1f3d88a8c2f2de621c84547fc2ce5d7e212213ec08765ad946723a4087a4a5c1fe23246f8f7a3124ceab905e48e0c28bb358ea6a2cf2f30c3f637a78d4405f07412ab834a9946d8bf593939bc98f5768216341646203e5d3aa26186a06bea6083c1e91655bc18f352beab5db1e718139401a0ad580218556dbdff3087fa7b2fd163183643581c1401ee3281508203287c8f12d3d1dd26983f1a0d2ab16f29ebc5c76598b5fb71f1417a092f0aaf5c6a15586274ab4c9f3979c610b3945776de89a5625358876067976686f3b29ab3aa4ec12dc0a342ce8fd687fa9e7168198d24b483026755a9dbd362d0bb6bfaf54d4a16b07acb5dd490b4305a0798f3bb067dc44ccc73f5fac321086790f42fa7c664238f93a27d8ed0f87892894cae321a96f54add2f6ddf3c39d5ec5f707e0fccff330fdd5b5b8283749c2a4536886452eb6d82f45a42a3b1b13ad1a0320d61007b3ba98b0a03c4f6eef3bf5edd8f3bbe82141d28aace074c84ed18c65e66fe24ff37e0497a81a2bc8ba4e63f679f59cd39fd4ff352af21434ecbe02ffbe1d12777f2172651afa1e4cb189c49f17e669d1eba700cb8f8c6dc60dc0fd6f1521e71ffdf859deb708a8a31f645a4632e1d3070a9d04b8fff4ec6747568de77f19c0a0874fc0ae824af56143a927eb8e1355e9c056d768ad96aea61f76bdec5f0d76bd66ba3ee24a6a1f8587318f1537b0d2e8eb95465c11344551c5aabdfa0c7a1d21d808e5ed06e2795242e483601183238ac0224521098bd9b5c3a8bc7b1a2e20e62e9e5fc3bede7efdd669162c8cb3f2d95bc3e9f9b48576d459961b70ee919ec3ecb71f2999df9db4b06f2f0701f7538c0b65e120f05fe29f0778cf43b7b209a488ee42f9e1e0e62cd041b95d4824aa9ed22648e4de4dccc429c24d91a6bdab5d37419d4759fe87162aa4ca8ce13ef3395f2bd5414b63147c5a6d645c27eb6a98e56b0d462a112a8a735e694080097841738500b324df60315cb37f34d48781bc31a79e5e0de57e3878b03d2873a6e9fd564e0daee11e4972c05abd411e584f7ebf811eaf753252e3f29b5a307eb34d3fb6852955a9625e0637b5349d48c6391493823f2a919d73385bb2b0b9f1f781009f38ff59031001cbba9be6672408a48a15411faa23ef3dcca80fe91f0a11307e5cdc63d654d9cdc8b34e950f8cfaadf586adfffa76cbdec39a7b22295961c190d79f3a0c66d3c345124fa4254fc9c9174d4097798b80f6a15dcabd0e1152f34783ebef0c006a2093eec8b2eabf7f09efecc5815dd05d2add045ed6da2ab073fd87c760861f96f700148c02a3073818bc26dd255dfdfe40222bb67fa6c732aeae026d6903dd8ec7441406b1ce87542e75358743a512d6ff7d00adfea05c988d94942562c2f7cc2ff87f3baddc8dd1db03456eb348b3bce5c816ce8e510dd6d5e0eae9fc3883c786e45a3fb10b103229d98d90c209e75d36ea5017b9463ccc21124180fd71a57b129b06d844287b0220d3d5fa71a2bce71ba47b76e3af906c2979558d3a41460232d0751cc4767450608101da982b96066106b0bfba4ec93d8863489e99e7907bc6371a0605a4ebfe93a8ffec1889303b50c08786204e8e72363261fdd7475a0a1e09d94e966e7bc9403e4c50d90b7c0b6a03db932fbf47484aa27a1c626eff0a1e8199da5c70d00736c939d5744533dab421620de52f5a8bf774ac9dd23eab3bb65603509bf8a479af6ac2d6f00783009d136a74a63f9c561ccd5df673f10831393a3270f058a3870643466a8cdf2191070357a2c8a180910bdc894551346ba7b8191afa7189884703bc3de96aa3fa9cc02c243ff7be87c40195ea3993678cdb44a4270b8cf9485b32fe043bb17449a0413691b42a8b5e2c23b5934c10d4aaa360944e3a829d7475f4876e388d9b9fa87adb6be61ab6860b790ea4e6e5fc72b9db723c736241036456322e47151ccaafa4a5315436a3725ca79d8c532478d92bbb5cc11a1e4afa6ea6d40ea7c6ba06452628b504d4422aa7d76530cfa769941d2bf56c954340f99e547c7a89e047625fa5f624474a1b1eed6ea8d1c4c0906f4401856a0aed6b5eb0dff6a9d9f51c305d5640a313d8e4b4c4e626e8023bdff22041ab755c58f6492b2dca67380ee642c2ef6df80fccede8e11fd6476deb32ab20ef538280209b07cd62c315d5d74ad58153261c2b108ce6bb3fb80ac498a75c5433ab0ec0e197c27075999ace13b06ac393927f67288c762842aef2f01361084aab1727b9eabfb716228459f5a351394f0e341215a862bb2e1be0c76adc63f731c7e2f9681ffd18d0fdb302103150258d3c1727f1524f02bcaecb70b50930ef09e28f139522b72e2fa9681ff8d4fc721232eef1a63c0fdfc62e92ef7edbaa4fe42df8561998b7a2b185898079ffd380ca80b170e1697e753f8e6a275dd271892edc1d32c7c13f5e0436f7ae830122b1e59e77339e1fb8465b09aa1baf6e273d8f4762477a2f24d360946521658df52e301f0968dc6ddb65450f588b759c1a6f773ad2af510d7becf95a965f600600cd85df1c6b0ead238945cca2e131f35eb1ae6d9df55d79771293676dd196f8df0873f309b29c818483fdfacf576f652bebb10636e37ff4bcb0abaafe8cebd08a38058a9b67b527361b249671597276b6c03a4e83fbd0e6cbc20d45c5b2ad0102b861caa6834e26e37ef8cf5fcf6b642dfc29380aad4ed2853ed2145580bc6f8ad2083508e411ea50a20f74f3b12487e7921b67ec91038f84bbecdcfc8d098352b797b0bf0aef0192852c7fed9a16570f03110beb6c9442a482dba7f122efc273eca4171a3965ed8eebb5b627eca33dd71b8600b31402858210bd76cb3871e75465d324e4c8cd2e93387d49a363f214024d81edebb3d2514676fd1ada65ebacf0bcea45bea04e0da10bf021e621a58167fe7c206c8c134624cf7110fb966dba0cf56bf565cc53f866edb80db0039465d131ac61f55d07ed3e556621d6bee951804ee35cd91d6e006b86c99e7f43573fc175eca047f848f065a16499b825b0ab568b20944b086115a41634364fe9f151da8fb03b3c83037edea4fca4e91cd8df56537d8f02814e6db92e2222e1240ae193e13bfd352d2646e50aa9675b53bdd5ea4221a6739449e3f295e1bb0da57df9a8d6c592a7c717984ee0e6d65c42f21e47b79e79f0d5cda335bfe756507350e69234e43ed25ea1826da75f04ce58f7ff06b08b9a013147ddf3d6ea146a8f81d089f49eaba87bfcdadce1970a958fcdf348ede1dea6ce5cc1ed7c4bb7579e04e3638b75b822aa1a2a64d17425cbd454f09e56b170ad90a9118ad52981ee1ab83f9ddc10e6fd34f3e3638e31990235b7507f0b36a6f52e293a99a58a6141f114e1807260d0fa0118d25cc3e5d2fba3b8e63f0899e2a06eff300f9b452ddfdf7e371f5232bd9b840551fc8ea37e9b4e31ddc6fd336c465eccc2ef547455e7126be36c4d2a5db67bbaec34e2053b55d69eb79eb905928d437f5531f276a4cc09fbb497ee1a17e5ca8df5e1ee74f8c913e391a3859dfd56a97ee3f79c4f7a293f160758e05d49050439241b4daa8ac78a0318338cc280d75235666730299fd412fe527179fff79d55f999c0eb4315906f94c9d4eb2a74364f92981f3defc5204c86785d9e07a9bccf7ebab523e34739d9e6e46964206311b0c189e8fb846b1e15345c181bb57aedf5d160eb0b04ea7f91dc1c31879ae26de39cd7c1b8ea85f74c1e32d693666bdec2be124cf41098d9157ed32820adf13b6bd996882cee6389488d9eccd362432f2ef71cf92c42e7ca0f395e93266fb0c0ba7a1e6a427f13f250a00bb84d51bd0a997e5702cba91b1f86ee0c8339cdb979f97245e23d4158e5545519797b3df5538cc2b055565eec4ec85b025af88c198526ee5cbe6326cc260de3362fd0dd001d599edb5b43f893b253b852a58a27217445b9691729363b5ca1cd43493845c1dccfcd4f88d531cda97f54ed7c94d0d90aa80cddcf6093ff4ded463c63e27055b8ab5365dbdda670e3b258512112761f1f1e0d99cfd8f7f92ca3e328bcae2dc3ffaafdc6670cefcdd1fc8f2383c51d9cdc302aa667c50abe02c6fe810bce179904ca8a23d878e3449e750614915602c51175e97517979e81be4ec684bad2a8273b8e12a0a7f4c9ae596a4581220bf8bdf1bffbcdcc464a6670ab6b32eaa07e574826e034ef26cdf5b9851b51144b288fde482c60154e1709db38065ef7e54702e803111293cb742c9654a4afd3039e8e4680c861dc94008972b3f6dfd0f557c9c6b08a1111deb7b6b29e0b7171adbfbc8d5857a53a68af5235d3f3b041cca125ee740597792fca82b734e623a8ce8d960c9fc7265890d642f78935203e0771bd4cbbc3087845229ec0365afca403418c2ce61b8f02b69d01e574b4c766a61933b1916bb15fd92da2004cb0c4f6fa14ec6ca68202d31543b2e2e9a5539e5184704009a18aed7bf1e4fdca62cc80dd8b0f25b5ea2ed63bc925ded123bbec075eb0a24ac853ad09935e2ae39b0725ca5eb821759a4cdf85a10cfab61634547b73ec9ffe84dd23d78acc138434a08411ae2d0fcfff9468996254b3c73aca51bbde77876fb4a03e389ee86aa0d826904341038d8b6705b889196b1b1f40be123597db6af4aecac5d4904f8613b76aa8daedf37c5382816e98d71a5fe6b9fb8eeadc2811fe0c9d921e5eb0b2bd035fe477557f111412264cbde62ba1147d422dfd8932b0140f297c3a4863165b510833be361fb98f14fc3f9365cb63ec11bbe17d95ce0da7148331562248d22069ba79c5519ba29640669c92ec3f21ff83cc98c4a7e1a28414baeffc2dadbccbf39d78a1b9d8750b300fe4e9dc25ebd82b67e38834333313b38fedc68f441aca48ccc28c28f8fbeb54549c9cb4baf82f2a45f7b815bfaeed2c05b67256e34f9528b12d1f97f631a8e6d330284cd819b78894f68276feeb6d771f84c23b784dfd75c84e470bd07e8c820a70369e88ff0e9075160b12a0d1dcf9ee9f5c3fd31fff065bcf30db16ce289de73e1cc9ca207dd8817076c82010d922e7922c7e9914f780114e6de96d88ec68c6bf622bea8d86014109fe5393c4b4964ae0df990f2d47aa4a35a2024f799678ad7d84bda0b8d5ad1fd7a63c83fbeff07fd9e679796be7dd2a2b8025a172559c6c9de520cb96d035b578c003070311cadffd2c1a22ae89c1940e2a4cad46bef964e5f76da7a87bccea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
