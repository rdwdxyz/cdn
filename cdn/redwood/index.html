<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e5d46e4c36e48d8fed568f672a5c4eb92b84eb2b7c996db283567841bb2210d606cbeed289562b9c9c529746c474039c7d0f750308bb82950bf3f26926bcc9cdd6e33c0b07459e283b68baa31b090a291da3efbc89dd7a7cb5eb793959b6c0ccb0704efd963f250a5fcf07a6610074086591d2e64ca9ab1fdf105cc5b3ccfa7ed8a4e7c1b79530b877210870f6f738987319794f355035180bf4ce7370ba7dc6ef8ab603698dc73906adeaf7ffdf940ceb0c569536dafc93b0cf285433619a86fe7a7fccf381825ab896e2adb901d7039e63b59bba994299e59a121d9ada18a99eb98cc76dffe09ae2045646dfc6c6ff75ac574be3e87550b07763c6cc3ea8c84cb6c6b68eb8f7462a73065e2eb373d7124ea350e71e41e956d1025008659eea9354112c0403564786f5bc105c20658d90807e66bcaed00d9fa0325cdc840d31602bbf0d49b1948cc845a7efae706c6717802250f2e884ac8478f0b9a3984c0f08e820b3065de32496dc4bc31d1cf61fe5baabc7d3b11d8ef30a1afa5248e8037724224e144352ae9b9dde3a4793a3028dcf522b227626b4e5092a923c2975e270d751a084f754c1f1ee100f073eb850fe974b27f4680f0ebb4061f18aa64a1f200d0bc1fd91897e1d2ae15f4d68b142df896094c1b759e5f002cc4db70b30f8f4383e34d8738672bc7076a257b5cb0ae03fc916defeb0cb97a5bf7c0db93f3ed5bafcede600ac6e8a53247bffe168be4b90db5211ff48ddc38525764ca76c12384ded159b2da246d455f699a455c90f37b569431ac786822bf08899c6b04db78b1e211a781a43f2632838722183b4da7cad71fb98dc1e3e5f650f4542bbf5e9ae66215e7937f27200eb33f5c337f05c6591768e295394c605b491e09a4caf2eab8a77c01b50501999aa31346e06100b459c93171b07a4cc21e6b37f19a8a0eaa39fb2f5d5d382a3e229f47b3529dbcb4a7ef80d97398d6ad6a207806f62724db854a5846f37637dd305617314f00f042b32a2f4c8e9c16df05e389b7357835df5682e467c107e7b27a1bc380a3bbff03bff11646009450c7949b5cbc722ff76e45a5b52bc2f2801ab7d50d8511bad8123738ebc13649dea103c8df42409e3b2f3c9d6bce97e861ae97ba9d8a063cede0cc5c6dbf596e12bf0fce97ccd079981984e29c7a9bd799c445f5ce7428feb81d96088a3029d1937a5242c51dc645e7b6fac4ee7d84df61ca5033faed6a2052af565c315db34cd8155411336a68052976a286149086622b5e9eda4b0b204eb90ed43ca5ef9b56cf12e775deb2a27f7b2ddb77d12028430b358940a6972c36693c39a2028aa728b00ba96ec53042ec04e8765d4a7f5ad7ac8127986fde149966da295d8235c5bcd323b1d737dfa0c8b1afce8372660e0469b565dc33a678503fb1cb7c9e24e41dd6cb2854b62285c29eebb779d11ac3b2d544ecdae8b12d661106225f2dafeac1b969f24586bd5e5f96059d4d6e7952e0ff4868c212d20ece459accd72da374957637815b04adea62cd624eb4c2c2685a413b1ad5313de6748004c28316a7fa07edf7bc7b2d7357e661ae9a4287c98cb5e6d39b256b85124c3485e069e2dc99162b121ab7abafc2dfa6d0a1fe9e7f3e7804f766ef73cda3821c32363b846354ae609a636f7d40ec88565f6cb3bb13fe062bce1fd3c3c526db59835c9ac673985f5c4cd1eb51f90c2ba8bed2b6ee11442dd06ceecf3f8946a817a0a5fb417562427ae130f69daff6d29b17f3925caaa28ceb2928d6179ebca21de2087580808994c6740b03a6838fd4288eb8b16db1aa3f8c69da6f3d9c5608e2b200f016ff799291d33db725ea310acedcf634387110fa544aaf531322d4a7b7ddae4cb2252012785cbf54a57bfabfa0d05ada9f7febe5f20c647580e8b0554d870630a3868833ff4481179728c8da23523863537004128c6691cd12f2128d6f9ec8a6619c9d2c8e033b61ada93fd401e159a73523f82c0b9bd0308287bfdf9eadabe8b65b3a487a488a559fec8ce15acd6d1fdab67a61f45f92095b40f2fe94737fff51ac4c10835e9464fd52bcb657d499b227807ee4c57c225799f509e44a94f168286af57658c3410db03f497b6db57454a1ac0e2bb6255591f8604e17a41fc65f212561c9014e7012b9b03c0368479be4b2f443db0d1e9a29e3a80b6c34f182333165c1e723241c6e6900705156f4db286002c43acb8b6d9937d2c1f3e28c5067e58cc83125d1fbaa9c1771d94ac53ab95591477023292e9c14566747c97015d0630e6848099d91f1f3b0d28fad8497732e5be275560cb148d4a23aa8e220429438025d667af296649d6f36799b91b5bd164ff199b50b514f5eb69213a68b26c456046704cb9f858d165438caaea2ab88b92a5cf17f9fd9fa6c5b48e2989db8bcfde1c65629ef02d2889a2506b5e781960e764aa031e92b4517d35cd5a41ee2532b8f747d5c2c2d7d15d1497b8aa9a01db8fe59277186f5a9da8bafadc07c84bd35f0afe297d952731925e5a65e01b9ebd815e0de5da558fae087129a87623a7ceac0f024a469b4ba9bcf7a7af6fa24d9050f33e7e47aa4b87f6d3b63b4f491380d6690418dc83221472f09017fc0234a5b997418a6280656355a26f20faf0039d78d70ec7d1fd4694bdea160bf4417d984ae5c814f33df0e20394a6aaf200737ee28f46dfd116a3dec9255b8fc6973e9fd468f59193c7a6c2338af98233fd6d2eb25e0c619e32a2b46309c800d319a66318fd2a4d307d4d042db81fedea8615864d2e3988148e82974423a2956113f249855336d451eb451e45b4395f3904e16701c023a21e46390e8a554f0422783c3242cfa4cc46c7ef4416986aa0a03bcf706ffabfd2c8c55e75d448e0a4d16b9e8588f7775addf244072f89a5c7e5caedd515b9295a838dfed15fd2faadaa9a3c29f20d15927d77340a3bfda99ec163904c966bdeb9fe6fbd407dfb1026365ec3ce06c5fd200520ded3a54dbd9681b70298c4433228976950924fc576118eef35e79caa4d6f3adc45bbd05823c81f43b6f4830bed8c64af61a731238d89b027cfe41ff0ae05f635ef02a9e2e57cb9d4c07b5c70c730bc9708871c0d221177d608779263ec28a5374f3ce9c993c83a764607ceee0f21f1955ff9d41a2a6db31f84fcc2cbbe2fce33f7460a72fa7f911a8bbe35a64ab653c6b466e97d669aff346b758517ba11ee75024c98556aa6f688e3ac2811d6be89c2e7c09c269ff4fdd6b512a6441cffa445cb852a94bb27371da2ec1024e522cd129951a496de53ce037fdcdb87e3e536e2cac0a09a37750fbab8a7ec94a21bbd597f99c42a6f75edd5b5a12d5a0094bb94b2e83837bd5a77267db30d1c8ea3fb4b9cb67e24277e966d4892e9049d8f1681a74f0ecd455d016d5dbdfc0763a79dc7637d6cd743431c947ef615e9b5662c6973cc320adc3e03f055f11d03a4b6bd65676f8d555d094a35dbb0bf9ecaba3ae14f18250eb5791cd2c636142efe43d66626bac212bf18b39b144534180eb9ad603a84206d679871171547e843fa288988fed9b6223fc98037c930788db06fa959c9f36cc874242d0fc10d39e8815cf5fff544ca5ce7dd6980916fca1b60a487cb45fde5201f321296387d1b53bb2e2b394862a9468d437112ffe4ecb2b146abc580f946f460bb7e8f37f6fa549357954096c9979c9dbed78e97bc339f5a86cda939783f9a963babdc1e38e2e211d6699974300cb989a6d3edbd87e68664c3f59ae8a53e870be2562bd3b1843f4eb0df8752035343816d1f19c3fc89864ac7cdd8b0182e68b6749076f8d92636bc659b191d4e85f55e31efbd4e07e12bfa1c2f676cb096cec3b3828a903d6ab0ea91f9ecacc46ae51a9e3f822638858fa086623bf28b7c77ccce28212434ec7a48900d80252473ae9c4395acabace1fb8f5295b24175ffc1309269f400c8f65d61962947564e794ca5e833185d40b3a6c994723055a4ce5d2daa5fb1278e49270b2e20365d7a91a1d0c265ac5652fda911162418653230eade8aaed5261cbb079af375c017a9f3fa01236683edaedfe9479d6d90401a8ab7431c5716aceb5dd9c5063d450109dcb05fc2ceaba6ff32d6ee76c08dff4a1c8510e28d4221d3d6434bc02a5850ff24b91631e63bc4848b7e5e814c858b80d9b32ed4407eb2d191959917cc1678a3d299b6b3ad5b6de989e39292836fc9105c8daa3eaf8f53b2b4584385622794c329cb66f69b51ece4a48a7a942b90b03b0547fbddbcb5cc445f6f47a651433f0a678470afab5f74ac2958ad56d89e09e4b6b19b26364cae81c276b29fb6df6d67710460be457c92327b4beed634039f9f347e94bfb975132d5ddfcca1a70d48f3d7baab2da78942bb09416279fed7bad716e8654cf0757dc508a64075862c18af792bb2328c8b691e0dac728e056dc7bd936121aed9aadbca13df2efba05fb820331b9af7d78b3e4c1c4f594588c933eb1419370072088c4f304afa6c4565f857eca339542cf30db08c1c0598d00b476edc752df1f4c3e3dd935b84637cf5ff55a56dd3e0a6e55edece54d40e2888eca8eff7a5dc8dedbce33014a3b7cbf7b8285f17be84b68dedea642aa58671f0577a6588d7c2c44e74a60fa8e703698f33df29ffd236b35d2f42d97435063c585e46918960188068fc85b5279edd8b744653bb7652e5d4eed6f05dce3432e167019c8ab76939f8c3f63b454e7adb4bb98783dd0b059d07607a17138039e2556281a274446f82adfb7efc1ccf15c24c8a70e079fa308c8b487119807e2e91ecce06c023ed29ef7ffdc4c467f0d5a3e3c5ed1060c86880989430fcc79471cfa1b7fa902addbff0f7c51ba6e39ebe6dfe369c65c8407818e724250d2020169620c3d0f63e13c6c30fd88fedbae6a5188806cdc627f53c9e871f132ddb3e757ad21d587a7cad84dcf47df44b026e6eaa00d70d531ec6c604175e20f0a0e8c89bb27e4f03097ed22511a4775fd144c6a71d62cffe5bd6685d4b9abd64efef5e6ac1d59ed199c201cf90a054f5191173b7eed022148e82e5c8ab9af6385b9076104197e14e684e4980bf5962f9f0ac6bc446abeb1081a725ef7c74c9d72cce7285fca969bb9dc3776219b31836c7a57ded3c2a5d2a144662de0166a5d8a4dea5be7574aa675847d8daed7590358c079e32bee4598af384d7856a5df04f019d381b2501c17704fe0f139adf5109f49746bbeb4bb60f45a926075b8332abcdf6474ff8b8c865ec4e8cd38911f4520be450a7225913347ff9d4f466dcd61cb6579182f184024f902b5c7cbb298a64f2a0c2e824c161b77fdf787a1b4f953c5f96d4e19ea2ff1c26a9677e2c4f7640bb57f5ac91f8123827d5b8c68d36e901004a2d0e7ed0933a1d9396f17653208d18ee11b9547286e8c46ae003b4df4b76fffb06bc200a364d7d8d4eb11053a7f153a945c620556e6bcb014d58b7eb8ee77239fc67ab369d34c9eabd46e186fa6cd47df79b1638bf8c26b50e41f173c143309db74597e18b48a5becb1c3ef3ebe34a36f29749d11ff03ed48f97d69ad6894ac38545428c4019419277915e625263fb60a79201babfd55db3ae6f3e49c8ad22a3ae93ecec73068db4b02edf8002ea3ccc275b94324514197ea3f721417d8d20ee1ae9c60af5e9055cddad1286b315292407ede23f7a4b6083274fd2a71fa7f11f02ad6c063ee51a5815b54911def2642cca4b017a172a24350f48fcd809b99f327da46d286537d2189ac0ebf8f8cc1ebf6dadd5cf8ffb66bc2b09723c7aa08d15642d5be52f0d962b2a493caa5e76a7514bb4ae87c6486a76b9c419e0efe9bac235c573e1e60afe69bfc9e01158a48cf743fb8b9b2627ee350a9dcd6f08cd97139c53606b06471ade024a3785f4278ea6b2277575fc516a1de856b28d654ed99329d6a533814bb49e1e4bdb217f9d018a024daa6cda9d1a8681b94ae6cf5ad3083796e0c49c90c445c7120b0e4b7e021857f829bb33fb08e4fabfc031e77795450da69fb8e4fe432e57b2d75d846fca22fd26b972523c76d09669a5946d0cff9b22f189af25897189042f13ced5fa92371947b5fc86d01f0e8978b966124a4ccecbd91d10d1cd2bfce5f602472463cd3dd0d85dc3199fe1fe6108578ffa62e1ab6c52d9b19c0ddd5798e3199ca49d480456c45d7d25d27cba0da72f0731c7086f928eff567857c38b7eb52c11f8867062f2d37a917822473cde5747ac05cdb9dbf46ea61c30f6202d03320a86d47b2c263d4fd973a4205bbcf9455ea24132ed147cacf23c55f8506c9112e43a292ffbe416c9cb48b67dcefabb5a8d537ebaf33e4a03ba57f015c90edde3302673ec8a082bc2b6b510bd081da1e6484719bec83f7b336b151d284b412b3ea4217f1b8f07d15b9e13adfc9d5eb76f5adefa75e0ca938bdc8cf453e452e0046b950c975ccd83eac9a46e42ed7b0465c9c78e669f476a64daf41f97d469bb028556ce08ca726c0fc21b8cc9ea1eca577b94fe0c670665b8bc111ffb7da8bff16a5c02947450f72ee8bb471c8779a7d011f3600da9fc0f51f94e1d89eb4995fac6a43c0b92ff06d1e9c28ba422eeceefbad299c52efe6b50dc98d9becb6736dd65a842e369da235a98e6280b15a6db874bcecade9a9ad91e34a3c870dee3a86be8e9fdf438db444d8b54c7c78905ad1e995d997c967f277e41a852ea69ee098df01bf6c491f0eb493062f5462eda6ef4c74ee703ade104c5f7f9cb0144d71fcbc3b0ea928e8488bc043b338bece39806525182d7e59e27c3a053db5012ca4c9e9a2f0b0c3b8c9eeecc1677a07a869a8867811e7901a29479f47db9c01966ebba6ca45308b5e3c6c33855da87ce9d7341787492f72151ef95de952ed046eababf457cd9207f5e0dd19a4cc80ef6cb056c5cf40d376c03d3cf591d77fcf4b65c5890da25d439e7d6ea2e6ef80358871e360679f3c6696f131dfbc347acdb1200788d08585b011ab386a3b20d2025320ac320781f4bedfc83b0cf80249f6d327627658fb1254c40ae95a59e6aee4178e9a58c5a5a708db8b35ff541885fe203e2ff5efd55048dc0f77a4aeefa6ab0989f11c4feeb701969bbb8e86af306ef36b24e3fc8519c8b279c7d9029dd624bad4bc83a14e53de323c2ca8f1013ea05ee09e3c7272f14595594236fae1e05b170ba8214d5e4a5b1946fe69a60957b6e83cbbaba559714bde704884d2771d6713cb81bef38e2f931ba04e1db4519ca8bc11e0a3b2e80d782c8903ba45476d67e2cda945c81da712531e4af462c2c5208043e3f9f02ac0479b335f9feee044af39e7ba7eb55aa6317e1ecb39f669a3a50af502596118f3b0a8e57999b01c7773e0ec70eb04373fe95ad2fbf8be9e5a3f06ef652e7066704b07377f5e0a5a62e178eab140b4a8a64bc00e1e5220674f20a73a4e2f59800468387e0199f960d10d80d9b891b4e988ebcf97b9f768364874768ca07c68032ab390858d43a33bdf9efd2ae4e707029448a1c8c43851180f668421f036031a63dd471213162b46304f70ed2538f46f4b41cdbb8dada62d6450088d0c2d7e99eecc8803945116f60e2d1645ef92dbf6b55ebf2da889aa222815085be2eed5ff4cbd0e897a14dc48749122eba19da847622fe07204b970d20581306cdd35aaaf36b364c022b732e54303a597d868eec4dd4c0652806e49352479e21c9bd0f91a6fd390af458e5267de9d71bde00eb008ee6344991570387198cee6b2e3de5d522047953129c832f9d63a3950214baf2349cdfcf22f7b7f673ff688c1c94f6845af613703952762eb602667e456f2ed1e978eef0963e600521fb3624b069a57b89512d0662b8e2c9afc57c61850ff9c34b2a6704a4bac2d7ca6ed0c787634e8b19ca28845a718e2b8dd002b02e18fa8dc9fc39e3977d2add3fb594e927d8cbe2c1714689580b4f7b38f08e3f77ee8d7b4c8ef034c11af06ae4a4b6a41366ca51578a96c6c3a6f93d56b35ef9e15c5e95b12ba06b87ec8a0d6534691f94c7638770b6e23dc1711adef547d51ac6896e58bf59c7a20fd3846ca7b9f6480e6b8bf6a38755846a7bb0fc802c1d2ac836866a374ac3e3e8876ad28d88a5bbca3a994417100617dada74510971f0b58316d6698a4e977198c6162358af5d09e2a5decfd49a1bf0cd5b5ea9ba5e277af40874754b5437ac65a2a0136fbbfed5911d9cdb7f7eb4bc219201c32af71bc58b52ad7983a74702b566ea748c9c10d99000972d508db433a534764288f01e38769080e0926c973ebc565e1f6f19725ce2e168619aa23c7247df04d6bb680f4b5ef7815f65b2b9bf2cca39c002ed23231f2599d9f547b7ad1b6ef935b761956d0eeef5191be9def7ea1c9442d3f5a8210bd3f774932a09ccec3b35fac2b7acad4e90e11c68d1a0feea2a7ef7cbedcbd5a294fb9679c25d9708fb983c04817c7ccc258195804f3d9a69c0987e14295e3e2664f6858feaa8c5db91963e0e08a28da4e5131745f0985e176d65cc2c76611cf78c9b6a0e06fa6d25497575511cf424d9fb4e66239fe5ea97fbc75b459e72a4200dc132fa5c870967592893996c80daf96137af306ee95fefcdb3bd0eb963064752559fe62c5475b999aed34be779fca61dec5d07e889f43f3529a7c2d314d4cbd2331e9e395c8bfbba7123d8918d5f9c3bd6aaa164cce26ff39838f84f0294904b20db364f15e9a9b320c71900976af47bffa011839da313d9cbb0ee3391c2e3fa93c6953ae256a4414270c42f39f6042960caa8723c29c3ee62b693b32618d540e22cb0c903e629ff0f0cc2eb13cce1e3895b54641fd637fdc389dc8484bdab32c396287cbcb85666033c7457b9ca21b481c6ebacf25285452bc745a2b890289033782860df06bfb0ec6d24416bc098cc1347a5c0caff1389ee006dff81988c8241b01c0e8e47f09861ab845be3c3e67dd56a08831ad0519fc55a96ecd5310cb883851d7ec4d728d448ac3340fbba8a5c74cacf6af48308ba3143beec1e5ff2c138811ef5ba2725cc1a580a70db2dc9b9e4fe9ba46e86875cdc1266447f421eee394e3957a9c80929662e1ef02b89057e2320c95a6cee925edf7821f060b4d340a49d278d0e2da19b6f545e63656de85d4a5b9cbdafaaff1a24c6ae38c8e8227157be9ecc245b7b738667f4c8d1c90af066161caf3ced6d5f65a20b35a921179034781400ce8bd1029273e2d48ac54f4ebf201d7c899d2d961abb6d26187708e401178a7bf71bba5537efce3e29c1946e19cd5fdba3f1a0be6ce3e44f6af25e7bf4df168c85d261fab3e63bbdf632f0482fa55ac3b339fe02f3679dc5af4682bd8bd233fdf86406e23bce7805148a32c3f534891bd7623ca0a1117f1604680ff21dd860e4af8d3926bfc71dbdf8df5aff9d44118f34bf2134f836304ccf393640d8c1c3d0e624b990c10ccd3ba906248cf9147597e34794c5121f8168592d80e9e21bc5ec2e3d1679cc8695899a501f2e72de6e4f8001b3dcb380a000ae5ec0ea8edf337a2a2433a4c05342375422dd71bb6ae95f2927c145f4a92f5a2c031592153e1bac2d1588c48b9f4369fcc4509e0fd19728e1ed97992fb816ce02f7c17dcf916558d281550f1a3b80048eb3e81e987ef18cf06c080b12bb0e4e6f47af029769074dcd9f374d417f8c5633fa234fb643e2e52a4f567d4176325d55ebf799408a07ef3d830c47ce879ee42c4ed969e15dcc305a4ba86ed0c9f6bce76c815ea4e02b6f42cfa035f1054ec26ffc1011fbb14a9eee1edd795ba286c0030f32fd69ed805cb97d242ea737809878410de97a25c7d17642134dda46de403e5fe62d6211d16d6a819e5d18ebe27c84b336a7b37627203597ecb8bf4c398ccf5d98542bcf7ac4cbbc1dde855940012a636761bd27e04fe623363937880052e7d61ed74cffe30f39c9f036b13c2bfc88158bcba3e95f6ff3f51f1e6a1e643ae8abc6a9f5eedb0865a141200ad28b5a266d0c5b4add1ecc40b4834a652d04a4d4cf334c5f474c0b193f533199f96efc0ae9fb408d6da8f4cbf14b6f9183cafda47fbee824b4337b07802b3b0c4b82a34be9fd9beed617bfa0afb084df3bddf47282b5b9d3aa2c5d26465a5fe39eeedbcdf4fd84721f5048a951eaf6982bc68262dea37023eb069e133f950ed4e4acf0347cdaf57d59e6d49446f74403861777a268fcb6263706e79f79b33697ab084bb1e0c710c17e0632866d869345886b6db7cf55d97ea41973b8ffb8579518d406e0eb5de600c4dc293c52177495ed9ad527d93977105c1aa17441b0bc6dddaf09ca5c65a88e8d5da91f9dba873abb3628a38e8fb5b470140173203cf0036da7a68b66e1b8b53f77e6ac19b4764a8bfecfa7bd80c33ba1453f46fa877d6c3ac9b44a0f4fa9d13f30a560be09304fb477c7b1ea4022b226dc145b22eb941511f8f493d6fac606deff7579d37f42283404ae3fd78742ee9ac1a8144fc0c64216e07d4c980dc35e560537a74ae8a1d6489b7383cce2806c324ab5af1e4f8e1d55fba3b9e93ecbac3b2672c2922196f8d5f43c70fb9f24980a06d5fd8aacc387fdd201b65fc21e3d1435f72f000d653b017fe81c64ae4af638620f15e1ecf5e409be6b310eceee0891c24aa69040b93f4f7a4147d28fbaccc81ac0e977a974a1a19fe8d44cc090e7a4c80bd9cba619e98ddc7f6d13c8488de4c1b1a0508d31face3d48192d1f0d36dff173792e89ee42903a4ba450887ae6642731155e33d07fc7d1cd75fb4735f0348479fc67ad1ac3a7692024ece0a3d60ab7c72fa73f2becbad26437cb07330e2d78e10ac7b33980e15b684c41cbfbd2fbbb5191fc1d07d8b216d0f064b2e97f09facc518a62baa2b27b0cf0614eb1d6be9c1f54a0bf54eb22ff5bd5a28cf154bd0d36820426d99e0910118eec24ae3b8a6ecc1b53ec358c6443b0393e8daf50f5a2830a55961f85fa0234f38b72f3815bc98423de1f38908cddf353bed462a6f01a27100e93004b337e791d875e61d76e8f605e6a029c05e87eb317ed1fedb52ec571e952be6599c8fb5a3f33672d3bf1b36984606996a29103a069956c6cd0e50392d6302198103777a553d5c94d5b7c4597f0935bc927614bfc5d3f38bb112dab29c5dfdedd90adf51794d707ef40101a341fd742d0d26c2b5b06192642bba1e539f8ae0c4e42f8be782e5128accb709513f03d9d56c280e7f3f9eb43dbfd45ce9d9e48c56b3263516a782b91d22576345fa65a103288aab653662ce8f761ecd36fc0c801db6c9bcabce814acf6e9359bbf98514be845ccb1b311b9d2602ac453a3a391d96abe51a47cd82740568e7f18006fd4799fb7fc163c0d07ded85c617c23b64eb89407caff2098729255f833495701f52768d89fd4f426e62467ed6dcede9189467b8d907ae94cd1ee358ddf7a29eb7caf8115550179e4af9a0ea4c7ce33f9fde6caeb2bd01484d9e53cec1379d7bf0962445f6c4498688fc18f5f295f1e544393b1c87a25042ff825de94b3d7615445d406250f53ab01a1e2112bf550abcbf3209cd592038c9621d2a8c71331d771b12fd6b8f87e21fc3896c393a2473823acd6b6fc85f0ab43e550988d72f3396438d8946494a08960498d8c7f2917238dc207f5a8613ac5ca954bec945bc29bae1886352ff1b0089f208fb7687d2cafccdd6bd28da84b2d5a44638d48537b1b7508982fad3837ab2e92d4c83a0393844dfcae9d2156f2aa656b184f566326569d4ea90333f46612d680531e2abc636c90b372d734c8aacdc7d6566ea9a2afb1acd3c6073abc2dd818a26e6c753d472206a20ecb2c59807a2d5049c4a85d88edf0711cbdf122adba65cdce49ff6ec7cfcaae6013637aa76ed3392b24c23e2ec619e7b85d0238d2c853e477d990cac46bfadc247fb0dd36755c058b9e580d928acf5e4d07b38fa9d9e26bf9083615e1fb27701d6097b50c30663d2994389d2f3ce3a840be6e34617c5a0f6a7bc01479aaecb8ac8d1515826004633244e38c9a1afef98ced6775f731c0a3d516abcde774c14fd325449f013e9b48839881f4381f7a54faad76a7fdd98dc49674fd9f2ce9c0af331e43d5918e1f9d712acb6520b9211a814959a5953ffda9cce07760855fc3370e0f3fe65874be1366dd59c5936691f3984c51df50795796fa02596d6caf997936d4066123948051f300072ad4c93b7d678bd801ac8a64ca3f798f145fae771c2229b0f5ae624e38e55efba482bbe28ad02ec2c0a8b72c075f030b0c6442c512c4824f0f4a88d9bbe8b9fefc6b16abd58155852b6cbb8150cd9a51db88e5bfd09b55f2fe25d478ff47fe305d1f9a3046cfc5ca8658150edf58f6bc11b6a3d4406cf78337c8b3e2ca34e96f025d63680a7186b363a3a5d93236293f20d4ec9f30337d68e2f1aac03c82cd0a448209a01eeda864348ea640000955c6d81a995f11f6ae81e828f5df3850d9d8ff21b76bed34aa533031192a28aab2ed4829766572b80d837700b023146d7933041a28609057eb7bc522a1dc91892c04e51c9841d7fae72316311ee2018c835ad8ff9dcf679212ec5d93ae6f33b161fa8d50c2c3baba430355fc032ac5758f2d2b000cb93e4b725f33947e2438a3569098e2461414835b7414320f884cba0fd485fefef65fd7ac4da72b316791da1e3068aea8babef551bab8c3ed5f8ab1929f206a38a21ddfaf464b634fe7d2c98e738de92c800820eaffeed24348d5f7a03a845874a659d7a2d855c0a311be1d4367140deeedddec7ed1bae3a96838527a76b1746c9d99df4a21d0c2a2330c2bfbb30d9914fed5efc1fc3df9f6624444df78ff574e1a8032c41d8516be2a98e90525f90ef835582da0327a9bc2e6303ed069ede5a6d4a678e43bc2922993ae31098f92b40f56816a510bf52afe8b075c9b81c8ce04e7fdc0dfab4868932d991ac12ad760dc688fa01b03a6e6be435abc2d13c417326680711825fecb75860c51568116150a0f7f1d16076cba53fbc7a3cd225d921910cbdc30e37144c8d7df8a335e5bdbe68c3a79bbfd7243e1ffb9e748f4698b18f2ab2c3c643db4de97b008c10f2eb9d7f0ead259a814886ee27935b3868b35976eff409aa4a74a9f0ebaa1c4de5797db133bfe5d4a3a0a5661aaac4f5f59cee59a19212d5915d1e9b8970b9ce53b1f779bf325cace3801fda15dc1ee8e22312a204818f9cccb37d31a2c556baaf78b099a1ed7a0c39d0e672dc46c5fa4a7030442b17cf002a851d1006e97e8cf6e7f7006b3af7dcf47817b03164f805a6372143461c4bd7a3c30f4ee4c9bf323e782eac5a550f34ca076591d945c7d372c9bd05d4ef9b018e2585b3b34579ee0945d15dd455db8d55ba82b0ca81809c4b8bc9dabb493b809487eae2a681b0c22a68d9e94b40e1d4c4b495ec1ca590f7fea97756741dba369e21b0848362a5c8bc383b524548ec913a2ef25e6b3c57bf73c53d247389187ff7e74e4db120a5549f6b1b9f9dbbf0d1448da324bb4d5c0aabfcdede88a3a1c95b2bdebeae3c588b6eae73460fb6318033ef9e69eb119a3bbb8ab0a32fa3ac86ff435935cb7ec603032b6cd1d6661c2cd5a12795bad99cfed8cb6f4e6b339dbca42d5a574f35b7fe5027f5886852c749e2524ef7661609d0e212ca55f75eb2630d1c9ce9b01ffc819fa7bfacb08e28ac004b5ce40dbd65d47b449825b28ce92f33efd9a9c24239ab8818316f7200cb3ca36367cf5778e3692c2e0057a8e007499fc782fd4203c26fc32978eff040dc453862ea78daddee2851829b31aadc7692824cc92fc80344164273ce434adbdc5b05426ed94471a2dd8cd71e41f0e8ada3edb5b4f8ce4b38b726e460118075c08b32e502c196dcd0ed38c1ce49bb563902cce79c2e0ffdfd660db8ca99b03ae4a05bd12c64b81ac7fd2097027fde57d3ab1186915be3d44c0244dcd9b93c520e77fd171a419024d000efa1c1e124ceb12e7e7c0ba3ce3fb86c7e2a18cad3b29f1f6f339871042ef4e45eba9de355a58ef9ce0a3aba49aab5a1406ef5f8559d93b6740e4030450003efff6e691f3dd8acf5e86e3dc768f05d05a8abe5b2efe8b7ac43b52eed3c10d64dc9b9512ba09839f9bfd6c484ed69ac8a43f4949b99a9381f4c95db35fc68f7e1b785327d329d683867ad45fce8c5d013a5995e7774cf3856a30f22370265168c8d0f7e456a4674c6bee502c513c61362d72d99c6b6ac1203463e39c4ab6e25740174498a843227c499e62c9ab27644d0cfac70e03a6b030228f80e4ffc5c137d31e15bcaba2f605e8bfcff2c2f0f161a53e5361520bef020ff53918e5b3c1fe91166c3db72276496b1dbdfbaa79358395120d3d9176fa001ebabc02fcf1bf90546b94392423e108ec6e48607384891e8bf673eb45ab7ab0f222bccbdd11140d10b4b5ab4f6cb0ede7813721a6d454e9475d0c939f6117c1cac6606d95d9a1e6f87df2ee5ea27c089aec6c92e64b801798243f5bb227c9eb966629cca0774d092bbf2d9bd8b8c23e95912961f82136d1b0ae5302e36b10054a0d201be7adbb11b913b8b39984eb370e52cf46e048e10f80f1b20fcdfaf766c12676f974e45180a8a0d74f4a043e370fa0026899058a5fa48817aa28ba036e429952df602f392ce0845b08c8bd645d4b67a28ead0fa75b0ea95814db6ea3605bd65c8d2d572b9921b18bf151b150f83f74cb9d0723cafc29f8ec98cffad37918cd4b2b450b5c8516b1fdabe017a87250c3a64ef4a15ac82a67a6ac05ff0560b8dd69282f5a6a4e73294963f71dfd79f8a75cbc2f5d07d98efe5dce66a26cd227c298a98fd9d8aa94b639f867df6b2d02741b73050491449c3d57e6000736636549d8816b02d16c2c503aaf827883687d537d16c5ee5743a4134a169965f1028cddc762a4468185259deb4c1baa7c652211bc7807acc469e8dfe2d7507056bcca25f1fa8030dde29045fb124e810daa412a8552d36c07ec8ece7a8281953707148fc664e9c5defb3578883470b95432115e4fb6db844f8f772b05c1830efa9a28aecdd00e5ef76128a449f13d3c46c494263aae46e116221926460df44ffcd280da2c9e2993012bb28f2a5b6ac8d1180a86be2f29fd2b653","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
