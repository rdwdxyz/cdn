<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7ae83991a5f67fe6922a9a0d3bae99951dd6d8487c9380d17abcac59a29875ee4ba09fb360ab2786c42b6b886b21ebe29a715c072f426248dd7a08549356ff67ba581dc3d549f269aea391650bac869cb91b59b661654dfee083463386c59da4dbdfde7c60fff935c3f939d375902d8a2cac801064299d2a029e1264a79c5461d91f53299a2f41bc4e00dc963fe09a82aea1cb7d8e05d879df8e86220c6a1a475f37e8b8ccc29192b36e9e21be36aff2322db41c03f82fc9cf5a8a3b1d00a9c1525a5140a2e832a6e68136d3bd92b0e324cc14f2951d6a10d6d20b2fa2de9c879d07757a874571e90c02d575de7d4dad4c92321ddc24de75363cae8225b9a53767c192993cc0cb75612d55aeb894015c256da8e321f06587ae47b2933e8cfd5ff51ab7f7e24ef6974e53b420c8853e9b299784b8c959f35ba1db1530f13335cfc67dc2670de088a0107a73c0ef3872984c183112e004dd63f29e6839b36ee72d5d15a7b1880f80875a2f1d3292f461bea622bf4603b7044de38a3d373070de76a5438013a44ccf2449983bf0215dfc73a10f3ebcc76f43277a5b6abb16346838207298caebf26a86f0acc62c8c8e1f1fa953a5e045b754b1d9a6122789e47d3ee7078154a4ac1d6b566bce0263148f88025f5a3f0380ce617629a64427e13de6b8c53c3b614bab53b5d1e51beb407a03cada7851c5f98bd24e3432f4ef54b68f2cd9ebedba4a7a7a5ac1f4e7fca957a457257b6ea64064007492cc65f68b17398be00d57ce560725945729a953397704dcb088c591c0a0972cac30e99308a6963e91b0769325cb85eef31170dd99b2bd301b284fa65e4e1175b818544b3c2e953931e23a5e391f4f43ea1c079adbc7f8cf64ba399bc2083d6fcb82b6dfcbb903e555519032df3f2ce5e81fbdfa1f200666b84e5e69267328a1f87eeadc5158da352072d9da627b37a2f5522a61de3fc126eb3e332f350dd247b9a7f866528329b10544653a0d7d9bf19ada97d9d0ac3f763e0bce5274bc9eac0c2b20601622d3d4457537121da592b57367a6acc0607eb83da308cd79fe9e094d4aac067f0386dbfed2e179a119ba39b25419df13f9fea1bb0a0801ee24e8c89044f592f7aac2ae9ed12f8ad80722d979b12cede35a851b1ab562a4a3b4835734aa88c0ecdcf6cf2c136a8dc7efa3f11b88b06eab5051c718f7c0d3aeff697c9ac0f661c7c8fb0aba9e00e542bb214b9aebde0d888a5a810e5f5c50f0c92c4c29768fac5cd3e9cacbb6d7aa940302f3a73d75e36b1a76817c48226409d129a72bee9ca930aad32de90632a31f2c11efbe66f305ae30b9c9413c7cf265bcf1c589a6920ce41d42ffbe2e3bc8db21cb80fb301b3ded71b686044196399fbacc5d0ed883a8cae134d5b18d1d451ee01fb9c4d73ba6008ed46ccdaa265c3e16e7c1c3943154e00870339e02c3b2f7b2623e217ce68b36e5b2711eba037a74bb7b048eea8c82257d5382bf21e5c7c1fb022645d6e6f84117b0ed449afa95be5bd3de1cdea36120c672f5c66a9b1daac482da150205a2568218a319068f9c3c1c195c02c250361d4dbb9787279e5718f49771af242b66c7dd95d687a2e509b6710f1659bbe6b03fb0dc5c663b0e973325be6b49c2e7d49026a012c81e47e3b1511dc73c4a4188493a9974b09b19e2864b9faf58ca8267e8d3bc6746237b13e959833824db9f3f0c662a9b5c97766e2a4b94466a209f5ec9c53f22106f4f6a8a6327043c800c7c567b0f73b311b342a409b4dc81a08e941bd89c44b88de2af2da5093d08907b90baeb622d56ea0420097ccd581da203bde090b0b449219f1af9e2ed9c86d07413adefd4c771170f7a46f4d9ab6759aeaf9824a3d7d2ec316d8fd0f48724ddb3123ace2b469e3aee654c1f070defcde5d9414066c826cbb3d0e6b8ca9dcd7bd20546d95797b5bfbb75a04bf2de2226b6f67efa9dba910000adbd95ec98df925e8ff12039ece361a2114314f9162b14e9d6e868765517c627a9068637be4f7639631736909335cddaaa608e83f3b775814a45b8efbf5a25f02b9e034b211765769f2d63c5b696d086d6cfd9bc467895a31d9fa6b9d88a47eb55ab5fc5dd5679d5bfb5f634c139cf052b4b396c88c594f23a4495c806662edda8a37b2c1a6d4c059a5a194ad10fa76d2a6b433644261ff81d9b6fdc230d43b02dc648afd339e65e91108e79772cf505536d6f14abbc61a51eb8a8c554f76b340806bcf258c761d2906a388b654638ea9260f7a692ad9af9c2a8070f8d3ba8529cf9a765780cd350878cc091b47b7e7d22a8b3ec9267e954eb0c87e4e2718c333106dec5604a87ce4fe6ac76bd13e64c40edfd1d7073a04d360c6c87d7463276a8790b68781a5b8c1e17ebe10411cb95a8980acb0cffa45937412dc5dbde6734d716f9b97264edb0cc1532cae5b045798604b6b18b4627268ce06892688a1a3aee354288b984d366215e058db1c468337e1a154e6c3182f41ca74771353c8ae00cd4d7cf0b5a57551702e5a53d0be85c206c24d1341e1c2c3983557456541a8642597a42017668dd33710000488c0274d882ba9cda8ac0840e1115e1c01cfefbce23c40cc1fbcd73f75b011e68faacbef45a56673f3e5ae2d174f6c7f4478d788eed2e300146f7c195686a009e9823681a9352f6ff6722cc65e693f1570ad362533ed433061d941dbf1ed847d2264b68e7ec39cbfc0b3c6a8bff4461c19b741a7e98f71c8ce2d2e92ec59de17bfbea4dceaa3e4cac21bf56c1556da22b2f7aaf883306250b6912edf915940b17d108340a90e83df0854a67755e45a55e7bb5a8a98f9efee61029c10ff59aa06f319c53b35ef1ce090fef8a439d9be51824d8c814e869b4e7bfaf9aacc50907953baa2c06d676f94f4ca6745330082fe20d9bae95d4fdab9b38c6b5378fe914e8af5929da5df9434399d69ef9ab1f30c4c83ad02924efe9039e9d71e1cc0c8b0b877b1ce0b79a51b59a8eda0f02d3d5a5e24b1d90720fc32858e6c1955b2d759115fb0a2377a83b704329a3d5cc269e4906ab3c86e966bade888c08858e803e2ee4aec881b0df7e164b62887dcbb291e49cafeb0a9e747325b3ce7d0c4de8891874095a7d3ab96e31c002d0a2275a4f0be834a44212f37c2d6a168b9a28fae4ddce7764b5856bf83daa631533cd0929449431b07512a17b86728d10503a16fed36b4ccc3ac9bc33c85561d9ba6eb8cf1c80e2b853411583de0f7e0108678245f93f3fae8bef7004241b1977feda8dce637ea59d5370fd181607f199220cdde9375c880d2c19f54fe259fe87ad3bc6a2c12a205b9f1f52b334fccf2de4887bed0e99e243e721b708f115f5de2d43719d120c277452df8b43d556403380d232e7c5ac852fe918e9cc6102e209545ce31827a37658750770025c2289227fe318056a5c7ef163ac662c87a23873a82ef904ea476e9cab2183a517934d4ec0525d84ee32fe68ebeee2acf984b0177ce111b1ffecc08308e838c31e20ff02b0696e61732c25c03d288c9229627bcbc64b5efdf0938673b4abf98ee2e7eedb2936b0dfdfb2c1950c9f7c6d34b00bc49b4f3f1c4d0581914659444bcd4c3f3c223d044483bfac1dec1d6db8eba0ec589995171a2221f4529f298517f06b91fbfa98d2417ca97ab6207e535bf1e4d9594be1a08a8eef737412a2625bc4de935ca0e21e150a1678d154591069c4d01397e13e5c132c9670122b2eca0cbca3dd5a5b917ca326acad95a5f175c0fda305c660a7a79724bacc4061e9c810fee8dad4b3fdb0c45e4d20c08974151f263f525d8c360bdda3664afb6de3d76affd49da99f96f319bb1b63a992093c78aecac7d8c97b7e679cd17530d70a1b69991853bbecc0336cccc109ffeb8153e6b3396268c8a1d1545006e2f5478aff0d07cd7f886a33425d6641e218560e758d11d8ddcf7559574de3b8ce469ab89bf0bca1d2ad684536e6a81034ef610be6608a8e23c6d3fa0fcf8c5de58b8a30e65dd759fdafd5f7060e8593c608ce4cc7bdcc12f40e7e40253ef203f640bbbe58b2739de1cc8a87d361c2ec7a4ee8217976ca645a639edf147c58c6ad64df776337d54bea48bbc1c66be34f44aebd14442712482b70d4e9925744dd6baef46a3b0426d1a56866ec6dd0a59fc2920b6e8bbcfd30b82e7615ce5f2095056a74765567c5980f5e033a37deb867ea2e092ca1d3aee6fa892b8a9cf6da573946450c65af60d1ed588ff2e32eedf13111186f7e26c3c567abfbab8eb9fb03c87323a063f2538a2745951b49c9211dba1f8db7b80643dd4023963aa2483f35317cef531be50e9db097bd913223184352fb560c94c5d166fc54656288f9206c125def17758eafbec2cd0140e809d910a7d1dd24820e12bdc819a659af738d1153f9d29b22b20af2816cd3e9f878eba73e6fd36370349034533a49932352a0cbf3eb209ba50b72d5c2fe5acdce217ee4633079d0585de270d43b6b11358fcca803281116c8767966a7bfd7bba0d8e97c3711afb439e8b649322c61e7617d01a1e82bf3a5e9f83e4a863ca747c318b906024f3d894de0c4cbbe3b5ea4e1f32dfc14f39ee74a11a7a1be87fccb856d29bbf211bc9dace11e34f4b459552ced82fde96ae7ee871df9709c6b306a4708d0c82d15aba34ae2aed939ddc3fcd5e51881089e7ad9aeeccedaf026bf7a30efafdc8244faf6720ec9ddb46c755757f5c0aba8201d2fded2e1b522ba61d201f23fb492af4d2c235793e36dd7d90fc92e6d018aa62571820eef3c33c2a9db2c2dd8be29a3c74880f3e05940982e425dd8eb08a32dc1df4000c5b83bd380e9386ec76ee2755d7db227e413a22ee764dee1e3f4959b14d9b11b6d5934b8467fb6469945086d4fddce843ec2d62bac0bcf10ddd46e4d9f7dfcdfd8238fe419be253abe24612a43959980021c7a284b838d70a36e26819a53d187f8fe11df3a284186cec8d71042efa83f5eee8c6cb859c4723eb12b2dafa341c93ae1c2828bfc24e44c4effd1efa7ca90eb1bfb9de8d344724ccfa74d15bd0cd8941ad32c019f026f711c21e77d7d7185b167231720ab22e264d8dcb14d73dd469e9abf17c41d1802caa98bb3ea81a12235a89dd74009be096c3db482d118e09944c0c70a002b3181625c14ed95e5c53c443b7fcca53138ad837fe430878017712fd6b0ee243d801f8b4522a3610cf4e9a8d254738bd2b39081cec2717654e00559ba6cbc38b01620ce641bd3159d74b5e385b90dc5c9f0da8e1b076b0621e12580076eb6d8a4b8d27ef50136ff4a12e0a7911be96bf9438cc8697a1a515d43af77d5e43862e8def867b6f908539d16b91241dac097d748d877234e1d86fe29f400b1041d683255fc9653bf7e01c34fde0ea3a154bf41921eedc1cf9e0e83b49388862773c0144bfe094e7d0b281c510ea6655ce1817e17086b037300d21591977da61c31de2ce903d333264949390dd5685f7ac7a6cef9374766aac73383604837fdd19024530cb226b1f7aefae6f388249e288539253bea29d5be5505af40a4dbfcb962689fada9351d0e30f1fc92bc8b1fa599e6d2cec938f315873d544e4233e588ace483eb738c7089bd1eaeb47abef534586792abb2412bd32823f2d17a056e0a1906a6ae8a432f3b16be3bab5e8edf6a881399faef69d44d4a0854a61566c7da991c3dde8c43e0a0421fb3b04f319c52bace3b6b99d6296af0e0c7c3b488dba25690a19bb76299d92e0338d0cf6e2a3025f5c34387b37072b7b0e9465871dcc357d5caf7ebf88a9dd696391ffee70d70922d3c7dbed467884abe0813a7f63d0b8f2aea5bceea0c3dd8e94896ec87564bba7d1268240f26f58b8a873b6b62af86b4936dbac28a1ab5d48fccb953413aa2cd6247fb27201048c6f00cba412ed826fb5ff9f9d50b6adf9c93277d62a3e3a031c4fb05fa69c9bc85d69a003b030adaf0b76dd6f6c2092cb066c4fb33cf07640e2fd6c14c81046d1060543dcb96ca4c989237563cb5c556fa644f96793ade72a24d4419237e01fc295f32556d584c965555d622d89a3afaefe4b5f9d51518f1ee2105bd6b70f37234e67fc8e8c3b9e912817d1e1af844a6c5153b6d627e92cb96286342ecbd77bcc5411a26a4e71e2cfd15a63eedfd73867ff82aaf23867008b10063c7db0b9f978a6e6bfcb1892a75acb357397e710e60eb81acf3f7d417e7e867fec76acb88eb589d8a0727bdbe0684caffba448048d7f5ed9ae0bc59b98a1719bb7869c031a3059f1d9878ea628ba155c52d3742e13d73f4b7322c2eace8c410b82a72686160f339ca8a01c56ceaae646419a7eed88fc780c554f282bc94c87397a165874ad9b888816a0d4a318a9686d1b4c4afb0e20159f9ae3e895d2cfe110f636f87ec4df614f49f42057565871046854d59a285e3f82f259cbfbdbf7cd79d2ea4850529ef6a984536fb7f5c091a812f213cb320624c7a4310218cdd749e84a1570821138f1380ac1a0a2bd47920927a08315aa1c3f93eacda87593709930cee3a902b12d7879e0c263f369954ee890dcd0db7e6f1c67c3155c5dfdef711d843a94be0257f112c181c1ddeeca0c15b0c73730d18cd0c9f6deb45af0ee073f4239107996fd755f0a02368cc65de89c1831d0646595359eea088e84e2bb51c7f29c2dcf5a5e3ab5028eb8f77fa6110e10e0a1cda5455628669c3a9ce95ee7fa6da3903670871d3429667e3986ee3671ffb85c72fb2c8d0daef8fb50f1327eacfadd852f1c3928a6a219887b2e631c28bd508b47e5e30f272aa0e12c42988035e7312b417eb53c9ac5642ec87b8d7d63d4f73c58537604747c9fb6582d8ff1fa1f3edffe0dd9aacc632e76b59b5a98380fa8aa6321f2580a881aecad87438526cd3370ce965aa98f309abe140006415d52fc83a191e147b10013b97393007fe1ecd22624bcdfeebd2a253c87a6423813dcaafad997bf7660c3f764bbd194a086c7d83ef5c25fc546e592fc23d28f9d339153c71c1a7e27824a378bfd09e6010b7611bf5a8b4dfb7bc3f8f75d3b9e3225880d4dbdb40d73954c6dd989ce0e245b76281f434dd17796385e28dfc4149d75bee3eeabf22b3c186b6a778e97598c7c8deeb5933007ef490ce3db58f496c00742747456b5ae2e15d08ff41eb3f17ddb81548832e3c40ae3c79c9069bf438696bd45968b3b7f9cb1dcdec41f7c3079184d08dfb1d730aafe995d8ada1f07b56a5b7ff8b53f9d3b092e674fda3c16a92f5419b609197e5f5484ee925304baf497236c628f35ed7e9a4e97c7005b3ef538ffe00df6491924b4945022697e7866f9de0a2e3bbc94bd124f25b938cc6f0388504ab5c11cff7e34420c2c3b7824b1968c3089d331459f4c22ba9b977a40e70ef2c0cbb2692a9343f10ddf7ccfda373fb2711ec615a1d5b4113972b2e47eed74942527e5d5cf9934bf59887990f45087631b493f1b8f24295a6424c271bda01786937c50231cf29c3dcbd5f0135b00aea62e7c22d670b7d2faf60654edde6134399d64626c036e9b171cd3f5f930bc5efc84ed282093b37175c7042674a4d0096155617036935003da3d22fbd226a62310787474d59767e84afbaf2a2c32a4138a7023a4e64277e9401616cdf1c9fc81305af8f68ed06115a11f0f32395345211ecac2f5969830a35dbe89db4859da0be2f9b45b317ab86e4b26b68636b04e99a8771ec7d17cc594a75196a1368b38930e0c61d51e9ea1e6b925bb6c6e43216b151ef830278fe7dd28b3a83cbfefff6d5618ec67cadbddcb6cf599bdc8870f722045cb1483d6a937c7dbc96ea8bffeb4c2e2c58076e898218494f3649b6ff511e6936148779b02abacb56652bea8f3d18a8a9fb4204c09df076c8a88feb9469b7f0637ca382324158c0a553adca90deaa7a45efb14089b6cc56ea466e2894c371099cb01d806c51b93d40d29a41e724519228f9000076e4f1ac64583caeda7b3893ee9dde2396514f613ab1f1034810580d1686d0bc132bc03afb4581438a4f6c1db52dd2b129e5c7ba39414507415ad7f6de0c101cc7b86325137c3ef9fee5dbe6ff7f3f4f1b0ed78eca668222c1658ef6e009b175463b4dc4437aa4198f321383852adcfb2e36ef2848ed297e03b98d29eb5a3bd330a8eb6e8b8409020dd99c48f32c934d5aea45853c802be5a698cc160b9f4aec9642b48fd545eed682eeff3efc435ea5afa9a9e016a776e9ddd04a42ded9700c0d39b2e8f0df63bee1ddd492b482613ed39cf9e2d505f33bd9a452938e6e00595836e4d8141309f3ab227127ddcb634ce769f99b9e3da135fb576d1dc7dd49ca80971ef5787a2d39c9d7d07b2652d7c57e4decfaf4cd8e4263e1cac5754e67fdbe990b5f6f0bc1a6eec08bb55ec437733daadc3179ba070fb8d959405326a81d0e0daabc81530f1f7059c8ceae70cf3e686b1dfedf2f070a2397c727998b97505596f2799acd2837a71b16d2734905588e7acf43b9d527ba0ce50506bd33af0e7340edc71c044e508295c37af56ff15a93519e000b67f52929fe8def238b9ca7c9c392ff5ed3cad2533164d208e3da32d71b0070a40a1f55746229196165c7eaaf8ea039307ba20d20f1e37f2370409d5eddafda779efc69cdb16856dac3aedd1c91a009cc2df95329ab1b96839c8701a423633efd90d4c7e14be0fa359fa4b6e80346174e73f52ebc70ef719e92ede584623939d5730a49029f4664c42dd8b6514f8f124f3fa106f7c13a903191c7932fba21130fbfe45c13eca95617b148ee255464354186b7a9c8644f079e71b2c483791c3e99de9ccd68eb73e9fe1ca7f1cd3cd4da5c2deab39f51d71c22dd71c04edcbd5e8da7143c93728f6ba085d044b3361a8669a815af7a459975bb3cc79e6975b6b98cba4281c31dff3567c7a1cfad89f08c12afac61023e9977ae3ea5a526e191d634c1e5829c6a27e47722ff5301e04cba34da56fb6249f015b409c509192df853700589711ed01e4d806e0ca73bc65545820ca674eef2db59b08970962772b3b87c1f3b25fff21ac6d8b76939cb4c334aa244c490ec5f4ed9667c1046a86376e2164bd73ccd218616b7fcd60c822bd6494ae24a4d43aff9f325964cf36a7b7caada4d3c3b3b210cef91bf40bdd7a20793add0614a3fc17c1a02602a6780ca7a7065306aa7fda5346252f1f16e7967f14a0539e3beebe13ac73c46887176e63d2ad050abb0cc71a5a597453c8c34c2a59417f80278e36a15888aac9de4ef264cf48a007aa4d8056bccfbe009e690701811b683764e80236f17a1097fcfeac1709021cca3b6e30d21ad6a48bfe7295fbe5c2d1dff4ae8fcc07532f00322b6ca86bcf0795ac7a8c7a4e336dd8975e47eeaaf1e898bc520e89c629b50299c2feb7169a965ad853c7ea4b3b779b4ef194b21025ff6278cd394998d997f1dee75ee7140c7817a7f26e3339fa740eca31c9b11a45d0e3406e2d639fa4e1242324d22801b38ad2b3c1f8bcc421e35bbaf405c02ed0230110bb321f45f6a660fc764c4dd2d167836b037d38b79f10b65f37afbbc3af4e5baf72a7211ef6d852c84f80ebc6a31ac30b347cae6fb031e5e5ca761c85110217e2edfe3c8c96c485b31069e159121f237cb05a97588f2ffdd2290eea2d9a150487b4ac80a1b6da7084fdea57a5fbe24295dc8552dde099d0378ba0584c754e00647ed1d0a3918c119fe0c88ee2db6dc6cbaffadd8b7734d3fb343a64a59db6d2e355b450f0189ed1dffb1883eec75d40d5f65364327e51e134ea51b2279c1ba5d035e93e4016f9a85c8840c02d0119218df80c5b2516cc2e0630c6ac0a113af6edd85d2148a66e50b11876b0d70576a5885d783392f0d9fd9d11217d823d7ca294dff97b0a86763f261b0ecc8fedb6ccfd8dd5a3393d9310cd2410a9ee89ed307d0e56b08364b33d60c8b2398cb6fec4ce122ad4e67e6671e7a32a1b54494fd2775995d5c339f9f5d88997ba091c4c5d2fc85ea179bf1e15e219152733858b0ed6fed985dad8499894bc1f467f79d9bd46ebfcc43c1108f9c4f28f0546eeb535d3fa781d31c52db9e7c1f7d0bf42fdde9b3234a3969859b7aa13c5fab74da1f3984e8c8a60981569193b34cfc150d4dcae7ba67b6080fa600280d72ad3ee3663069b6e3d3c159409a7e812a7cf931bd24458114582b9d9b2c487ad55aa7dfc1b75e3983839f90a4487f3300114be5f04c55df70105de8edb98ad87cecb0a9104c72ae13c8f239318a3f769a8881699e358816036c255b8cc07bf7e588fa0f30b7c9a40f41dc490ca0596ba27e6ba8738b3de28f8a4a4eddd6ea4bd5f24a171587fb9fa81558c8509a087dace4fa14550f998152990637225d58e884354c0cce2cef230429d9ac3eeccef32f7f6c0e75696b510c9374cc15554274ee5d24c50302eb990ebf10c365c837c7237669ff5545a5e842eee1a5f801c83c9f3af3dd697a89ec3fbf13efb0cc7a1f741d67b6aab682ccc44aa6c28f02db364546ad8a29a066d6f1fdecea7c9a959628e05fbc225a98a8433e8e06928a45157a4f3adf503f5d7fc8afc889ea3212e5fb5eea588435d27005b1e5dcabf2f60c3b87b89dd68e17dcf43b718dd2c114976c3bcdd489077742a874bc6005a48777f7ff8cb5ca5fda7513bafb240a9937ee9ce5f72add6b91c1eea743431c4e895b182c2f2261ad4241232d4657efc5a05afc78290e33bec95511890885572ae6eac3086719cd91ca7929b9a73d0ed8240dcbe657e0ef8674ecd241f47ba7efa5965024f30fa05e3545bc0e495655f184d3c6852704b36844041f95cda78bd2e08e4e61c046d08f3783efcebcd4d02c98233631b468c3889b3caa4fe3a3df55971d7e18e63bca3eaafc8f0ecf634e1c0e6d0f4b99d23acc7824053485d8af10313523c0ccadb4f5a9d862e454ff5e88415d04b42877e77e23b9482c6e792e885f410de7af870b92b385beccf715fd140d69041e19b7c2cbbba8e78e5f843c49e8ad23b6f08ed4668b88f9252cfabcb7820d8204fea645b9be676ca0cd7f6c06864de8e34097b00658fa245ff1c27e6a3b571e5124cbf5a24389275e12359e82623740776374e90c4fbd8568933c8450c3df4f759c5324d371abd4891e3bc2e76e6dae33ab76d2cd1c7c52316d7fd3fe5459286c7782dd611cb64a8a0aa2729e95d0df63692d6350d9433c932fb42069fd42d99d234722f9dd1c2a408355599df8e22d9399125c754fdb0654a568d14468e881432a984280549423fccc5045a82f9d98543472f2268bb11cbedda46b44938560e2805c22a535048795cb2e393c004b06955e943dcd65e9c61d81327105913e25c471be3be9c0b4b351c02408f096258d526ecc5aeffa33d2a9b36e8d3abfd68d53105ab01f3d82165463d5ae9207cee881fc4a67a2be3e3508f9a1910a214100f7c189d79eb7be4d837e52cb0c103f741c3207b1ef3747f98f8f3d985c0bb4ce3cbf0e67d07e0c3d8bf546ca90dc3ede820bb14c7458db70cfc5d1b64212930cbaee8f8d8c00ac438168947ae9c1f874e626b5f765577eb862fef6c574d46b8c3843c73cb86c58cb4546613f3e19058b2643bf3026409d1da9228b8ce24da3a458b5b3e1df8f1ea94b7d603e0f3a2683517ed8a8ca362bc447ce980966140cac86f6cbbc054b112349dc56f79669cd8f75c0da8e6f323abf97411404592b0a4ee026b3939dc585e2cb4a646fdb2024bf8fe2eaaf967833f8e9b7efec1d6c2df7b77ef48880d5033b19cc4e492c3aed78b2c177939512050a0b5d734f6a696ef2d6515100227b50bd531571d662d3ccc741de75019dcc22d41201b67aebd7ad61c1edff453b28743549a7d43111331486af0768c3e94dc8802ee858407e5ee4db5c70735eff99a57f876b878ef178e9ef7f5ee4ba4f7e1d3f943f3e84cd59bc91ba17c2df94b87f25ebf84854d2d3706c6233b04b15361231418ab743d3144daffa46b66fafeff2a3ae861f15e55c075374a0020d2ca8eb40998fc43901c7a7bd2a46d810516502afe34f3e1ad94a32d8d61ef0536255ac8bbd1dcc8f5a0ca4179970ad594401a2de51177d71b87591b6b65bcfc527199354c2620d332160b60a3f8a5a4a6ebee1c0cdd3cb58e1579dcab013e9a822deeb2e21440f9d2c3ad1e5258d3a3852505b711b839e919d3eef50a3679da18dc80acaa457d588356546390edf442fbd92b97ea265aa9c1cef1948e05acf484227515ac4aa9e97b4484e590ed511a9f621d5364fc3fe17e0c08c6bb4b43d757c4014cd9ae6cf79278e134e695886e77626863a5d0be16cb791f1dee85197dbb714245977d3b7a0893a90faa7b9c5d698228d606e84b99b026b6a65f7ffe939b3d6387f27f746a0707035df9d9119503b4a8c24a9028d788f80c34d4cf485ff1481b32109cad84b4fa928d2c9af1b71f54ea4c910fbf61fd0aa36058edd5d3746289b4a93b0804469e0adf0aa73389a1fcc5ab297d2a397e73c0246310449d821942533ea72bf36604bfc1ebedfaf9012d8d64ec57d7e4a2a5e911205873c2c19d9f119602ce4c4bef78ee25b79ab97da96d83472c50a8926fd789401f99a6bda23a3f23f48f420b857cad116dcefd9a29d390b25be8e9648542f1a8e7527dc8db13b00f211b0f5c48314a8d8385fcb0ecd4f2a16c9925387dc4410e2944b4ac433760957f7cc0db22fc468a6fa1f43cd24be911150b7ef3e4187abf6c29f37cea0e52cf25b925efc4f182af7a7b9bb314927e26fc091f105bd1b2738248048cbb85ac44e47852ac94c9e685b2ae3e2c9b098a54a799c32727e4c1110a5c06349dd2aa2c4e3f41af32e3e1fed7dd069c26327da6cf8e4dbc363da9cce6b073eca5194c3c389d9efcb43035feb8d59715e7b6e833d135df873fec6720fd51b97d54bae28a293965ea76f15b535f9865e794744d3f666d2e7d09ce9d4878257ece28e36174a70ffaf8f5291a180e9482fb46402e3120f7b894e9272c68a9ec484677a73dbb41b22918283f969683653c50d0734b2c8d93f78b91cb7446902114d353161f19d56a9c67780c22e935fa08221bc3d0fd4dfd6c9478b246c6c51ae2dd4597038f2c17a5384c2e2cb76b34c75bbf54f9b1aace0a2556ef9de31039337447df217e772d994939caac30a414d46dc0a1c4d22d436dc7a2695504ac75e0a1d87b99cce27f3b6def39a3cd8489779c435f1d5788bbe1c6066ac5590f1079ba4efd5f0619b99f1c627b296aa939917526206470b54e71d6b520c806f03262cd61dd4391d4b7c208086ac68e8e5e3bee3c669a95eeb551530cc554eec6da77489e427a1af9da54352d87f4073d4560e7569ddc1d720619c4a7de43bb54a878e9815bc297db5959f849b2da9d68dc77bad6b0f93e32ff6b4e8aed36a5a8b20afc56e8f537310f3a5b032343d769068e561cdbc84137e6a93c1ea0a86aa96e696c787e966c7389215995fb737a06fc607bf38682f8a3b86ea80b2e13aceeddd8560629f33e4305560648b0b7052f69885aed56d1f1c2b63065503f37f895dd7d1382ec7078db9412572d0adf3dfced11f530bbc2fc9c50e5208027d50506838c650cd70587a6b115096dd957dd2eeb5c3c3a92a99a977b74b77b07350cac0cce8a904cb16c21f00234adae9e83aa4a56ce0747824b74a2999c40cf38c93aca93cf6b1c61afad3f9cba1329a84052c0c31256236405e497458d0d1b543fdd09cf1503d39379a07c6f4aed809c773fba6b6079fa8dbcd215c8e11682966b2b3943ada4de4781421046d1282fa2f4e15d058010d3b56e2608294ca4ac98c7862b1870e487852343198aff2a527f331559973323afe30065347c2b656bd9d056976bdb3425018687b9719bff8e4162198a28cb676eaf55f5cbb5f42d055b3310c1fcdb0c947a078e61cb63d7fa4600c667603fbdb31a3ac7a4be32e2f2561c6513bbe723a29d6a44c7dd7460508b58d5a8d7c7acff1d776637bc8b0c3b0f77610539b9234ae2eb089b566f7e6168d8d72026db75d36fc8d67d85a0b59e95c721c5623917513b25e1195017e70c92dd5b63aa996ceac8b89c288caa6532405dcd3f80c7296445434a3925856d9b3c14d552acf2ef3f245bde031281c142d9594e299a5812c4158d1ab2c486b0eb30215abd680565e354d69cd3ef5edb8c6eb90587f0dfba1b36a6c227903f46b61ef4ca365c63694cdb8a64a3d3db2bf70837692f7a6463d3066a7e9a7c2fd766f4b2f172dea285aa55e937407cefd04160977d394c9b35653ece4c2bf3b58246ee8766603ad62dfef03014e19fc230f95c913d5c4fd21234ae18efb5079fb2fa0ef3bd42a63e6c37543e89d5f588e8ed5039c78f94cb5490705ff5042a6d3fe295af4cd0dfbb051b353ace3a64f92e1c27b48089e533a511f16b3151676f818daf15d090e4c529622162543c51884d61709a5895ead72b0ec34ab2d9a7cda768eb1552a02ad7df748d3f096ff102c5191707570655cbeaab27c89eefb719431367cbe737bf6a6c64ae7044b01ced963cbc5d564c358a18bef72bffd504309ecdfed72e4aa0a9a4a14dec705d4fa1efb1ffea129ff735df21dc99ea6ce16f0308522fe4402b08cc7a0e7ab3788e98ca0d4ab27ef177a0dc6798757bf6a7b2371465138f9ba19d8eb2bc0fe59c712900b9297df8d8a98ab5b2d896ec6aa51b71023efa4f95d5f39741fa752c61cb39fc0860d481511f4afc4ac9bd9e2ae87d93388850fff1930d1e14b292270195772ba401248ea55904f68609ac69c3588550c86e790769f0821c1001c11749cfb51dc9e375a85e2ac3b8971ea70352b5d2cab20f77b652076058d7a2011f581821a58b5bcd92ccea61ee53fed7ad0aee43b6909c07099e7a836f77757d1778a588deef9bebd05cb41454b9f40a4770f0b47a51210cbc0da7e2972f020ea8537bad73eace99ad58314b30e909f718ee9c29231dabd7dd5be0b3cded943895ce32723d4079b79d765b22b4845fad02f570b2e667dec7ba0bfd7892f747b059a4c9629451567c40a551d1a51d93cdef4ead05e3701ff8695fd17fc8b821d13168a374ab0b25c8a6b2255d83d097b2e67555e21cb529ef5060c431fd02c6b4e643fb3424fc058d87ca1f1e3f549a04c568fe22e6a28144bf4c41c2574f0e20281bd63dc74c308c525cb09fffaf55d0f372b3d03a89e607fc324732e451e28d715da0c5051c199be15c64a13bc782c0e1a0f91325c26bdb2c254fd5eb07cfa52a55ea8bc3e8d61224f7866093a60ce329a6891319282957153d6afbcdb666c90c3296daa387edc6e1d07ae778e466f635536bf717bfcff94297385cf3813049d5c42c784ed5d98ea404dc9a9f8e527aaf4808a5f74c6277e706debbead92214f9cdd05c26d4d185a092cd969eb34262733608c073dba6e51a437d4befd5d837ea6e2c5db7b30e74dabe78870e392493f9818ffa2a87d7f74e2b126ced049c192569df73845e497d4c03cf1b8fb9130fe0e735bee2041dbf9fe23a5fa31eabe814cd10e7b229add59cea596e2e801253861651632f6d7c2a1baa02ba8b95f9be496a2ab7d5358af1b6a43199ea827637be50453cb99d14ff689faf49006e98bbb4b0fb77e674c992cd767050e90e2ba408654116fe0ece844c983efc00655756b72a021e93ffe31723dd1764ce31a21bba9b5746be94da8780f79be52ec8affa6a43f2c4279036ce3c084e1eda71f1a9473fda2b52548ecdeb430be2278683ac2fb6074ffea1c41ae3506cb8613e1256be03caafd6141e48ab05dcaf6bffbd96d5cd2c0c395c8884ea953810d5a67be53121038b3495ddfa52b7237e1a2be44b19fffd11f8eabc5a93b0f55ffe96eea87b29a4c9dd9e67520e9a92a9617ee82706b436c568a44363148b541b22d36751970bfdb354871866d8e6be1807e9dcea0f698ab9e25a7b875cb75bb74e90cb617af2d91adfaf0d3e71b0b091d29d69a1619ade01bd729174fb1af4de51ae1ce21d2ea3634ab3a16526725f3a7f508c484c7b6f6d4d416e7c6116b65431f1eb5058ea49982903b3220c05c6290dcdc6f691a8ee8d0d5abc8f7310431acabeef5106ce1051641677f71fe769dc741dded75fc22612c97aa4ecc7b99e48102b5343c477d5edf56c76e9bc48f55ce1ef286994b005d23bd4450493d04b2db918efdb2b8f7ef1239423a2c640e3c0c39d7814155e476fac8c0e0b8469024537fdd2d762c7e448b3b55b3e19d4465cdd01842203cbd1381d2727c347d6e04f267108118beb87c799d5bb534315cd764c1e2af3d6060c3ff18eb5b0a0afafc3b205dd7051fd2b79649a965bad3c30957ef277924b7c54f8658c6c93a670798a44f03ae33aae70f509e550a7472ae3333e80075e5fceabd7547be4e8118983d0f35d55edef5bbc5bc7413a2457dc18325cda99555919dd014457af810787b3be908ae61a8ee7fedd213708ec325dc8017b8b59541f077667ae4cbebc6bdbd06d705c1205fc1b4fd7ad3e69b2d7b144c39a0a67d1338fb108d83efa31b2a73fa00c445ca3169bcb36cc5424dfe398bbf95178fa44a06ad06a84443beb95f151db750900adff311cbebd3d00c5e07b41b71f553efd16eef67d06040e01e5d7540ad2498b096f457e5e214d1c7144c2a842287bd4df505138faaf4234457d541e26c1e6c3c632f0f30a5483debc167be7ef80186759be19a47ee4ea69c742abc05f741b0b6e47dc9b2ff85e4ce02daafc9391359b9187dcbe5cd2130827eeca5fdef1590245baf232b2cb6111de79cb55f0e7e396d78365d7c04b8f81484d59682e8f046ff7c04d631a00b636d94c2a4c27664a15fa0688194cec8def5ba18c1f180bcc8678cae134bd3bd6e0966323468d50f679326342706bac9d98b62efa3fecc036798a5d18d831b6e63c716b1774cfbb6a015be0c1f8001fb3f9ef51b11a45873fae3b5a10caf45d6744f7b045c82546f9cc8841f51f568d43b3dbc9a1937a70ec84b57d8e00dd56fc2c865ca1ff2efcea75027e7b1b1b4a5a843d10e5fc3b74ede7ae4bdf799e9b58c61de873ba39dee50a851231dcf0ed5eee61b4bf5db5cfba6310da560d538c33d18e971c55be54fd84ec257f057bb3afcc92d1059a72a583c019d29f5204ae6b5bc8e4b07c54d976267ebd8e6fa1cac5f9c980dc10301917d7c2eb2ffe5efab6ac29ece220109a6d793d4ec29ca4ea86c7d263292be48d14b188b117b9b999da8bb7589409c6538ef832ba7875a949f95c2f74f9991295cd7c9ca81520dec72ba34e757fa309560999351125dcb0f6fa4a5054716c1e5067ab86aec1e6f0bc33fb616fde71070d80020538911e0fb32e2b73fbccc573769d0d32d8f6bf029f595bbfaa677806d767c5b67c756bfe83ca0e2f1f09e61ba1f4beb047c8a02c5081ef60f0d1aaf9d79e26e1c01340c8ec5f4d79281f01b479bd1f188448e33a36396bbfbb0a2cff9fabc7ee67b11a0c088b4e0fe6425450fc8d88aa23ae225e9e2671cf4892eb16c4a95824289cbce4cf80e2ef4ccbbd821fccc8fb6f96fd259bd9df94fa0f0a683eb111eac0dad9d7a20b5ad0a0a036156c2e76a15770a214a132561deef5f67a0bf5b55c0a976e4e16dab2b3c04b9afc30f02eab64ddcbda1877faea6bfeba895bad96b2c655387b4551e43aa1edfcc8dff161408d130cbbb6c93b25b2875afc5d872bf48ccc41a080f7a085cdc4526e87a1587d35e632a26f3bd59796f1a3d3f3356c315f22a9a1e135262194de4c239b0c31ea7eb71aa790a3a8310d0c1f91a4b18df43c414973e4e4e4a2beee7422ab0ff5197bf686e073c04a9e5903a2c6985199acdf28bdda0770b05334e9ec7fbaab673d197c7d72758c7bf1c412437b888d3a74e4e7c9fb58dc7316d33de0c07e971dbfccde3437ad1083dfa88f47773de0dd0be4d3e2015009deac4d4d4015907d9bab993864aadffd516b77a8d0e45b64539c07a4db4c266756944ee2f85417861b7ae1df98a301fb3f3dd24bfe47ee2a5549f4e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
