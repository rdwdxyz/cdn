<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2be3458ad14ec005c8faeeea550debb58d0d120359dae9429cc846d770733ac7250bfea991482c7b8a2d73803fe0c9416522f5e9cd0380ab05ac257fed81ae7ad949ac0de9f3abe21d370df29101861194d7b081b4cb59673a434bb46641bbcae141742301b71ebff79657837b249b80c2c288015d8560d0b6e67e8c581e4dc3d3a3b1121c2942f7d4552a84bd9db7ea3996571e7d08f814baa087f32652ad369b2098e7d102749bc8d5b0bda1b9fb903379e3867c585d9818007187474672e43268e7f25b0c42b47c0de13d3874c345b3fb4710a9b2803f6cd9b53d96e4499b6682c1174ae5f629507bc6a836ef0fb47e68b5d1532af36353f89cd7f83f210fb72c744033adb28cf0a0143ad54ea7b3ef27aff12552a8215c404af79acf2a34e3f909f8f1e46466e039fd45c759658c4e65e4b30539ba9569813b82c122d87175fe6ef90720967434503ad8c525c0d9a8b9a8216158ae0dba9164e5068735d134daa73ea64727f8ea6f3d60c9d916043b5753c25772fab42f3118777d9563e177e14cc8c2a0323d8edb266b8048a047a0913be8ac50a436790bee4ad6b1865af796988c1864c84c8a771588983c8a171e228b36b2ee07d9bb1937132fa74d2ff1319b26b90295fd534cf5587a1225db129712e1497e41263b21fec82b95cc973d126c45017ab9573dbc30b321b354e6129bf997cf0d74790b38f17e1db1dafb3997bfd7ddd7d70e67d83df2a0be50bc155eef5736c2f6de331b116d6c60ee15591b0239c3e81d647debf9c621b1924239cc142d1441f8881a01fe076ae0e57a8203bd914afc8457b70274b57a998cd1abc167acbe048c3b13e873881f3754bb058c0413929fe6f2ffd484128c21e72ae3208358a269768b5e04b0749f3122538d59b6240b2791e6f87f20b9adb0192fa1c64e98d46a23c577bb893fb4c28c5deb99e37b63715e1786640bc28bf08281b0e5ca3de840630cb94a51c2a7a22859e161c7b6dd9412d5bad3eafbbce6750e02eff0677a45950e6175568338efa9c53e669b08f3f2b345b3a597edca6621460bc500f9ed663ec7c3188dc04ab14f061195553ee83bebdc2e6798ce310fa73383b8265293cac1e0ed8ac924166832f5d9f5a90d81a9e96a0d628ff57629f5fb71a7e7354a979a5feeba1e8302e359acdfa1e35842c318d884bfb653c75752441da8d0c3b43f998bf9641683a854b89c60a2870521edd99524310afd67a4c55f55042b887432b67d74d2bd5d1aa83d5f7c331f3eef6bf76d622de5a56d6732b6aa7468424832775530e7e6e01f4274bfbf9f940a52e70eb84bd1b5f5710d4a0786754c6e76ec5a329acd50d03e8cfe3ecc06c56c2b6e1b7c0a51639e425b0a3c5d8fb3a12e9339ec3696f29b03e41bb16a0e8bc126a6f0f4ab0c553a511a23b44121897beb2c2fc208b0227d15d6e9e8455d77f2d5ad4c8e94e40fb41972914a54b6b1f169ddeef8d3d3d943b850d6320a9d8e39638cf0ac508cc8cdd3b0a4e8b6d6130b415a293f31387c7c852072ea790750eaf2eecc0ad9034cb6fa23bfd9ff4add92049dd647fa1c093ba6f62bcfc724689df510a3a5512599c9cc5a93123d40b477362eabe3bc9cc6e79b254489b4f8245ed940d8ac54e04eb2b55618d2421f0d95ef53c6af0ae66884173e0fe5bd01ccc9be1d82c018975c8636fbe66ed268cac9c58b787423b40242b085cfbccd71cd1e2ef515c98cfb4a08f6b263a1474c4f259c0cf42dcbd5d3d1421e2a303c1126f5c21d00a9ae07c20c79220ace5b3fb4162132f339b8103f539df1656820bf17ab2135edbac22663ad8bba8716bc975630bad063f28d5d6fecb71ed67714dcc099ca1a7d04b192634314b2d362c3340a6c5de045ac7fb2a3b798cde3aade01bf5f0d6ff101a2bcad4f2e195f0c4a2e074621950f2962872816e96e36378b237dfce6a3990067d6c42e02289084bd3563ac4d4947a29393b2269e415f0eb7626556d51bc969a44c98af37f88cf37349addb20086345bad712b96579d8d82657fea64974342acf5d1ef2c84fa8457f0158424a40f2db52a8a725a3da91370bd897341c9273e0fc98000daa4b188858f22ad6115ec501ed82654abc99e5e5f90039bda82d01eed209fbae0297f864e6aaac28a8f876c4de6737310af53400f1a9e4f82f5246de7afbb21303c261237698d5698497e8b20a7498953236fb4aee1810a797eeff286be13d9109e30fd49f6333762e037793a8900f82bd2125e7afa90fb90ef1c2f1a113810d769e33d026abc5ac9a9e8ca0bd0d19de5d2a53d83156c165fd1729bef65da469e1138f4f7af409b9f1a658d8d1364204afd67a6839abcf7d72203d4f88400d1e7bdbe49ea2af4498fdd45f65e726f19e9555e10329bd0b29bdbec2a4ead513a0fd1c62ae77927069e302a3b3979c68eebc146499cd99d515563b892dd7add159b84aa0921e502556f1a9e46b959f533c2fbbc34b2f8184609427ab06e1bec5d5080fa9684d8832d033fdfd1889845150957f2ae57e06b770434e1ead1803693586f7ff1e1375d1f75fe34a0e83d90f6a91303acadeb99e08fcddf14eacfe645547649775f9388e2403bf6d5acc9c0bbd3246931f0e1ca07854301012424e11a7094698ff58adec5d70a4253c8cc1481861491ad6ddff69717e49858e20df4799f580a5c109e5e80fed5fad13ec0522ed915774a32ba82f7b55f4c7c0153a87c61882b2cadbf336d0592e5efd3b32871571fa1a54fb1cf2655b3f4b1c9a7fd0e6498509f8d037c887a6cc4d33dea6be4588f7e4ba28b009cefb3a404453d4ee10b9ed07e4bc5f66439f58b6563d41e20414439b42619f581b0597e32d14f5fc7badf60fcbe1ecab2e1683c1609161e51661c171d314842e4a2555d12c85344183b708c332ff2fd8c838f6b9b8c2e3910c33e099e901c5da8020af8821de85bcc452ef95e5aeb6e1e0c1567d5f5a6f822b1e34962cd15c304440292f5e0c1a266c6fcf6b11008275661d2fbdb64f12c8510db970cb06275a6537f30e183416a355679ff96636248d3a4921d13d9d68716ee2444cf9013ee2e72185838429e6c3dce792ef78dea81dfb088cc4f0fa5a561b3529f144715eb21948f7cdce133792501237cba2718b64029f3a1f6e111523a3bd4d6ebbc4295d09610471b0377f5706fb3b2a348aad906712736298f57fa354d921c5ef1cf5964841465fcc911f25c9fd275aff5bd64b14642a2fa6405b4664025c07a00174a929c9c191b41b923b38a20fd0249dbc149a44cab051695a4bd0e24f1400d4fd5534ba052ef88479d1b05d9025b57a6f622e5eea83bb08872e193edaecc9dcfc1425b311968be234ce10f283c5c5f0f0b4c742368deda38405ee8ff7120ebc12009854374411ac9eca68fb09fd5629bacb48088be6b9a882cd729d4168960eca3a39997c30423b9ef37ed1b413c0b38e9630da455ad58c5a56566a2bdb2dce09fa82be2a3222e2ed62237805caff4b03349a3f41576bae54593f68771353d2567424ca2754a8fb8e541f5eef44e9eb4bf3bcd373b7eb60c23ebd3e4f2539ecc35e1bf20c78d1ace5d399218b4853f2f383054a5691e56de309bad3fc735379bb824f5ac0a8cd6d7248e18f9e108a759a918a15e64cbc7cf35fb31a0528d3d4ecb77595ab83cdce0540d50e17baa269926c978af418d9a741ea54958ecf3bdd826d0487d6a7ecce1119e3e0535006af061554c83ee7302925b39f613775f67e4d84601906e12cd8dd084a1ee79ae028171e56b886fec9b6fda100dd59895060a488dccd62c2653f1ff9ae54587cae8d895a4071c6f4571daac1955716f1c7bf705222164026fc5a8acb945fef59845e535d29cb47d219d348119c738bf7a5b87d6059159b9d17fbd43da9bf2587ea67531cbd0ab4e4acd2bb68492d746163e0d8baeb46f54dbb3ac93e831b42b75ecf2b6c55b74a7b51bed0a6cc54ed233f32bf68e175a2193e8074a19236200fb55d4e38f30c7c70a1717321fcc4109f024917a381862e9d433f01551ea020cbb562c46ce1127c647680fa8d32cf78400e662aac5ecf760dd9e453fab69d801e5765092ae18e7f427377bfa500737defd3f5be9520a9bd6660c95eac7c58e79da467b33abc6a5dd81d7b304d002c150b45aa13d36b8071986f0e1a1ca52d276af99d92ddb47abb159cc582a5b8311e50270bc3dfdbad1a18e140b05a66bbbcebdf8299c8869f07f7582a8cb84ad53bde344b6514ceaa1f7f46e17e8b74e16cfab6caf561db9ebc5504107a8c17500089425b9c66afcd8008dc5e22608f1496097c016902920118b65a061ac7158e08af6d85bc6bccb0444ffcf6faf56000a41c375c651c52bd4784d8b45193c77d43f03e99db359974c85f4259c0397223db2e47c592d6e068a643efc9d750d23acd75db743b2054dd159596bbe31b1f5728d06d832d62c9583d4cffb739f65cca3888148f028841ba4f6c36cb295d6d92514d3d562db565d8f9d5f6edf09765ec45b3315aa771676cfe6bc89958299b1ee5996461db9f7fb8db486950c11bce1895c8accd566c8415be7b30b79a7609f58c701ab2bbd8eefaf3b65c23b7e1aecad570a08ca0464f265ef1cc33b75ce9ac8bf852a330d596c406ec0574823d7416551ef1e82210ee257497b75b4af2f72eddaa76860c593c7b5f7708ab16e96b07d383d3fdf67ff436d14ff78f8a4b06a8b092e0e70ece1d6ee0eb5eea0db7ed6116ea818b4bb467a3ae2d0ccce5d20c82151d5c8d5ab85eeb8ade7721a599cb785c4144ac43224def794e42422edd4dc04126a6aa7164c1dc1a9250179c68ccf8694aeb72ce1e16873634b07ae6959ca7b41f85c2b33dfce2cef0db701ab8aad71b24dfed12aae8edfb3478b79fdc008ebd4364d73254d058f478731cc38b13fa045a20829f096bf20d77f503d8f615eecea5aae997b791135617968a890ca0f51242ab490f527a28798588a99325bf12c332c8e9c4422985810f479378275e1e4f5eaf09d528bebf5d4607455ac0aa507f7e8fc1da592625d27231092d1f1bb338a2b9de7192ccfdfa3507a401f2c12acd043081fc9f3469f33710adce71db8631802ea2de372d38697adac508895415e5b172c11e3590a9162b1afb9896beb75608c1292418b52f0909586c5296f969effcafd2bb45b419ddc4d05ac2157af1f8917ce1b43af0ef960f33494a325c01a5b9d6d1e44c7c87154d3ce7e92182e5bf2d1142c9dbadf99bd367be5e22f9ce4c26ed0e6ee6b3f98be6ee39943a560ae64c8ded8ff0dfb2eb3ebdfca4cec2974b5cb2f533c25de478c78278a1aaaf1d639aed418814af9efcb424699d6ff91aac2e9f148265cd6fba028490e4d0096ed33b229f0600ef6a66061b88c6a11ffdc330a9187c5d44d6f66f4ebe1e18e7498ad6e2a523d667c30ee36221da106be7a300291e29d5eeb4e3d0b82d09d3f063b9882afcf19f6ec345b440e818dd23c405add3041b61ca2ea1d7ba4f2188f863d2ec208ad08ca25e6a3edd4e3f2d73e1401203ee330bc4dd2074afa3378155d269fad46721684f5352b8398f14b3124a4923513f02bf815ff761c81e9c4cf3bf9f0dc76ee90f1b455ae8aee973a57d6978c8eb52d917a52de19f671e35b3f12d3691ef6cf8e948de0a308a01101cdeecc452d8636568a9de5c9765467b44c5de09792c7dd1e8433bda6cce208f781a94025c7aa8b45e84ef32b76670dbb621f84bc3d7591737c1a8f92e4bb5b0599887be994b4d2e03e53f5b8f2bb2e91379e0851b6adbdac5eb021769e37f5f398cb3ca1692fabdef249cff3e88c4a1315b6f377474d7358d12d06b2a89ba4b005e5e581e70cc93b1880c6bf1e32a89412dcc4ce7b9422cf3b3e6064e5001d4356c9ec2eb5ddbc5fce692882e2e7b1a2fc629b992a3ef723d69dcde2d4eb2520bfc8d86795af41ab44e0607f12ae8aaf96e4cd121e0d2b76272c28fae278c43d950d2c40bb45bc2e1743792e01b339dd5ccaaa848cfb935de2de159e2df8613b1f4c70ec71768156a8ecec15327f25dcdb5281a03766f3acc706019fc58d0adf198489a9a7c3ff6366b1c69f6494e21d0fe3cb0fec5429b729359ddde5d7820adc9874f8379efce063db16138df506901fc811d9c469b849e30d5bf465f1bbf55bf58303207d9933e75d4f7c8de71e740cf2ce958147f003e4afead7d53b129a15658b5dcd3c282657e4a6da3f9a025958ea160bb42e4d8a6a42d9dfe1bbb01a6b9f764a4842ab9e287c2727078bc2a93587c85d2320f3a608594f12860c0186f734da410a56b6f58d63fc6565319b0a9dbe8599a079681212f7c431cd6c248f3c0a80a5ad73ad91707f2846418b6070aa895a384325da43aede8f865ae2db8ae6db9d8acf75285cf7285722876de8b831f92e94fef86f8e2b9387682badc9632565a3f938735e524f0fb469cf987fb881514cde15e49f0e51c48cc377a8c7454d40022c2eae8441f4ebd9b4e498ab94c8ab6e44d7e6aff2a3f1d9d5712dac5fb1834a2e8bcd4d406878172d155bdf7ad1b315e265901db7eb9a1ffda0e4bb29fd36e663020657d661e3cbc95d4caf7f3be4f001c9b5886c233ac8019fd6bf4d69cabe24d689baf3e748441980d1f2116321e95e60c994ad79934ed2a6327e34d571978e85fa8814bc14cb4379c3dca188728f14339aefbac80cd38d7d3806679db0dcab3d47f7a819490328a9ac4d378412341f336ec703fd2ce851e55e543acfb7e75565049f1a5e8ec2ab14f7325c88b0158c55b4c04050109a49edc827d20794437fcd494a292a34aeb73c65ae6118c3cba1ae38ecbd0a7787e77206d857762e66598e832a723dba8f2c16ae5604be091ed6dfbe3631ffedb6f7ba7a0242e4b65595739e132fd7d98528f4415ca7a5f6a67a99e4ffe422ff3dda3f073851c454196a65a15520a63295bdc047babfc1fb9ed2c506165a33e5d509272c2357415892725190478e2462bc32bc768864774dd1716c42176994ac0a9527dde986788960c4e8355fa56b3b722dde13039923ede23577c7a45d6c3caf51fbfa2d2d20cb8e10caad00d83e2f0552f1c149c647fa5a3b3701e03b0748c593c7520ca4efbb0e1147d4dde47147de31997be760805b7f7f2ab0dc43f091c5645c3341785de4c4740df455755690bf0e95011f8f43563a6a9104433dbc886b63a570532c1d52de15810156eaae45c85e26b5f47e080cd84e34e3c2301a524f9d6132b6f04076237d5d842c56e4eb48ca0910099bbf810c483ee6577bc74fac60cb8acce52ffca15748e6fd62b4265b270d34eb390b917b21c7017256c00af23466666e137539d2f15f68f43b0821715f1764635ef1bf48ade5f95c0dea0b08387ed0f4635d1bab72886e62c8233e0aeae70159ab1ac9a749677b9f1b85b2fb1f1ac98c1bf0c73c7159591361d2516818123ffc22936c045478051d31e9e3260c43ce71c3dfafd6e8b74ba516f1c9d01b7f0c56e5fd32da9057c267959c55bf08cbe925b2afc3fe639abd8d8dda715cec3a7d94502051f65459de65c6a89120d6facaf74c4cdec503348a0de6916d1a08ee63d1b421b39952c3e803dc892e2a2435ecacada5b03fde8660636fcc60c7ee24d4355d1acea93e42fee60f89139144d2b81a8c905eb549b0207ac3cf79aa8eb5fb529d880df492e6aa0487a39621035664a611f48d121b90d1f802e735040573cdbd591f0140eff083f3b2faa7e020ec5b51d58e42b042cd04eab855d8e11328c94b1d83ce19e278e7eb5b2cc4e152607960fe05436bfc166bdaf5bb9f9218250e795f343cc34cff5f27ba7c6f84ec76349c114190b2461c82b88bb082f65a14483d7c9325681c9d35014007db1a44de718f2f177b222ca519daa7b128a7a95980ee7ce961e166ff6cf035fa7f56643c54ee3d9d0e340eac6e49fb9c1d84860635b2c89640665602ab97861a2911bc413b73a32e64a9b9bc6803e55c36010896bbbc78ceeb1dd083984838e22c4f945f2c318cab488dd81305958524a0034717b459b25c5804f330abef4476d3f27d2ea4dbde0df5420b6a9d854cc7aaf8820331b42efc950bd57fd462da161044dbaca8f95ef0207ae52ba07f9690b515058c20863ac11629153df4cd5de1677b220df3844cf2e72c4b20268a322e40579c08b880eeb7fdef567d1418914f72c95db10dd9c719c8c20bbe85e97697912deefac04656e11d0795378405e79595794b55789aca3d1ab14a51d5bdbc19ea9511d891f57df831c8da5559745a9ffb679a337e55ea255c12d117c5f0da9d52ee594ce4d478713ad0d1cf8a933b9a2476d5a1492de13c34c775526118575f134358a2f5fd95f6fd3e1c8e5013db8e726bb0acec2fc7919e135b6db38810814aa8745874fa99afa62969872e08b3941abc3689c026de81de8ffb06f8907c4cc56f5fd47f12f617dae7eeb4542cb2498ea1bbf5ad62b6e69a553f203696f3438e1ecaa16611bde6c462a221d811d8681501c1df5d0a61032d0b36a3cce2df177c8daefd79862632e80d1c9e1c41518f1e77fb9f42d9aef33cf8772c7c90819c0c833b2bf7a3a2a1b3985097cbeed6d249e4c009b4cd806fe4ff635a2bc6a59c3a6ba6de1b2728b92fe31b7236d4318416b5fcefecf8a6617debdf350e11ad38f4f183089458a65ded64a0068237d02d1e70865aab5015fcf60ba09116bec1ed27a958f1ab6fb63db0516e4c0cf6964d745320414fae399d04c396027b5a999e53b1bf7a891c4901a7a23649d3e48c71cdc583ddbc994c71824596fcb83fb19b888e98fe8559b635b65d9be95f801a2e1c76504870df886973bacec8df3924e116d7dee7b7e7dde60623b5cc60c60afab296adf5f059ae575a2b019cfa70ad8c93401146d1b0a9dff67872b05b895ef5f84a13b3bb36b567138c50f022110fb1298c310a6d6d73c554d08397d639f11b977a760c551ea34221398d2d52c8bbcbeb4eb7e230b1c9cfb24ebbbf03c7f8f928ab30e2ce876fd5dc14e06e7888719f5ca49794a0f135bea4afe2e252365e36eb7587057845beee5eaf8352f114f90519f3b93e2adf063d22dd2ed1e0de8830e122943a66e0e732acc7705694ab08b05c5aea0cf66540cdabf3aa4a09008a76e497e2ef8938b213c4dbc5b53432671b961b5b4faac0dc9f42e9558ab74507ffcca37d52c80e9a772b9683f625de3a075a47ea57f62468e7d9af2d23bc2bad18c3f226a56cae0e5db88c6a026d248c46846ba43900603cf4b88e963ec6593debdad4a947dc22e3ab98014b7a98600acf51f4b5b89a1f4849f645342b731c487dea9d13e2338f006c1f64655398d6043fd6d7ba2f814b725435e23a1477d51a4e982c7f87e28963a8f49b11b06503c92d29db20d555b06fc8e78bacde8298683bc338c7adc394e350cb1c7f4aea81c0c959213d12db17931168c8f18e6c2fe51fc48ecc2ee359d7dae36450414e6aa5888bdb1006da8e83def7685c9b44af56258339599ec8c5bc207492ef494939f93b5d2f4fa7a05bcd49c92632193b485fe203f6a59ef32877ab07e3ab213439dd15274590299935311c89ff6c5af0c57e3dce2b3cf75451c3cc3cb9ccb0af71d4aa64495a9eb0a50069152420baca3d08e801b6787c08991c13cc5afbf152e8d54a73c22e5c75335af796fb3f042ceb84202ab3b355ce7052e782026918af02c5d0d88aff8fa41a121b2a0fa96a938fa18fb93b0d53800885cf28a4cd3ff0c9aa7f22979f3ed2637e5fe60b6129a72ea1e80cab6491c75519357ee80aff4fda1f5acbd8cef276086c4ed893d166c4664bf897dba67faa7eaa272eeac545fc833e53ad0455de9bead8270e51667ac017e63f10db3c78c645255fe06ba29f28073670bbb4f278f20607ef92eaad8f708b71b4520713eb67a2271359f9aa792f0a9bbcb9ba65f6da4021c9734d167fc6de6d210e0a36fd31a1aec52f9ad6d387dddfcc179a476a0da81fc7e47ee0c0b5b703c5638e11132c10a5128ffe32504ad4d78efc01073690171e10992ef89e2d95721b23ffce96cd308e88e3ab6b44352ffea11f3d639dbe89829b7c92810a2713ff81d5a217e0179852aa02d000c1615ab2596fbfe9086e4e3aafd0a61c5720fe167920973a71dc0226d5773ecc156c84468a55e971260007a1bd7fb09e40fc8e2045b52fc27d4bbcede49c960cda9fc9aa234bb551088934f471567af546341d92b41c72746c84a478e031ad28c3fe8ccd336b25994c565d3315eba71eef59a44b4ce03fb53186e60616934cb4e4cc3670d8c97b8431f6c65df2c73b1a1bb1bae983d72c4dda8369cd4cb22002aa62fec96599b744ac3f5c21090cb58a21c19b2247dbe49399826d26664b052c3ceea9179f1195d7948e8c625aba10c241182a86a73ead667dd7e50a8beddded366eb8852b4a9d632f262dbfdfdb6fed91ec9921750831dbb06bf6e338fd3472fdbf97e739ea6743eb76953a11f594347fd93198213442ea9b6446c17f5548e218add6c1e50c9bb76813ad45d657505cb81dac895c6166ad65bdcc0b1ca8e5009c04a9bb9080386cf8f897531315b4ff8ef8002d5d816773818b57422adb08548f1724ff0ab0b645818706df7270670b51eee467fec187a313c98ef93533301a8dba09406418b438f6ee912cf215fca834c6d09fad4f9c047a857a2df4d749e47d3aee26106d1b180ac7ed5435a461f28a6d784ed92ff35d8003dc35c1f377a6e09e071416f73b75f13618e0190656d13b5b74057a9e85cb7df4ac65292e052b9e722f34e54f4627a73ff133c7a360393d14b61c3d917672f9bb064f7126f73fa039bf487daeea13ca9568c9e2880f680da5339381ec709cd4a4efe4341b76be880adcecb963180be8c78b4d6591c9ad4da4077e46b4e392201d69e6f407fb1b33d3d51fd2d20a149b02b0136396a0befb799ddae9332a35e69e39a01a09edae723724acb0454224d473ee4e2de61458b0f59a9007184955f69d499736a62bd3401b2841a5507b421c935b45d93c326f18e5f7394aeb798e50db62aa97da207d5ce190649060079bc96ed8d7fd3106bd9010ee6b48e2e65160c06bb27915c3716223c2317ba38e361bf06f530c3fd4283c2f80cb3a2e0f7d1048affabbaedad8def6c6ba7595a6d730ff1d6c41e3f5158d35dab57f62425e156c5a86784a0f6ecc9bf984a50f77b06a11ad7dca218a2f6f3d68f45472ca4e3cdbd45bd154832b4a69ef6870baad8568130034c2f30f08af04dae9e6e84239fe44d892088373eb1902c36b9b4f41794a3def66631131c28bde6281319fd4754cb94eb573a78510dbd2380574d37942a57b0ac8a26fdcd4db8c08f91a14ed4dac3befe91d3bfc1333f6815b5aba7eb75022846f32a80aaef4eaa73fafa79c5ba6cf8f5b2332f8e5b6528296a09cc2165833f49d9a88166653a4c0515613bb66cdabbf4a80151819d522ebcc2f0ca6abcd94bfd580df4ec7636f0f6d07e1b88d3a0e9137aa0d90605dd295dc4cb48f0d8f303af2887a3dd47694d4636f4f5a6d1bf963078bac919b17c94b179dc8ef30d30672e90f66862dd46d41f7744544b14c2cc0c92349152ef9b483ecee9eb6e9ea5bd8e489f7eef36f1907e72d2ceead474b6923f054b0d7c9d4f73c02dd1ebf02015b60ff4e3aab7e4f0f8fa35b95f83fdfc975eb981051719d7aeb8359e5c58c369f8b1715f4326069d7f5762972606b9c812b9df7e40ce58779a56cdc13522b7de299341ee5ea12a975ecf41f9ef0141fb63993c7c9b22c496eba595fae0caa169bece092096646699d03de0ae8d81e8bba2a590bda72a144ec00974632bf0d308ac8a4c8247fedfb25e2dee0d7a5259c3083a6bcdce44e3aa4625b10ef2df943301e0bb5d79140283c1c8d35b05510f2c2cd67ee5d50bd4c3d83f5ae5dd8e74dd5d2b456ec48eb997061f15cb2f9d3b49118ca087560d6bd2d669a023b0d5be1722a144b8729105f6ff34adbe4c8af5746db69e8abbbb2eaf1736ac8dca0db1606df7c684a856598b6f193701b5d669f78d22328a40f27c47d3426da617b207a33ecb0f9fe7a9f2aa5ce3b6eca276bfd625b924ae0677225edd5cc13c3fdbd42eda16ce52578673b415c9f38153ceadc3905f223e1d3b319285db2f145af7daee11fc61a7f97f1002bb06e124dd0a79fd1dea91ee1f5f9ef8aebb4b24cbcdab94083d610b5ba308054b1b9e3b3d573daacf1084b596cb3a382252e2535bb5afa488c7ef27df0bfedc011f6def4222100021fd34b6f3cea2ebd9a3151494c55d0a8472684a34e96754a7affba36122b4c91ea987d096626db7c76a1edd63fb257dccc3516052cf19e6ae5fe069897c13878b575be726dcc990f1bc0f0939661255d935314d3f6489d126d861fc4a7b0d7f0084cbd63bc9b54e927ac4b309a7287889feb152201b8b6637fe25cb1918ceca06b07fbfe92e13d8f924f2027953c263e084c4d0428e10abef625f6448e0e5d43403790d3cee2aa5e3c7f7f80c257c821ae5401bfa9589d0810ccd167ff56bf38fe131d2181722681c73fb1bb10ca9eb64222d9db849c3fffff037b9cb3a9a5274621df231645779b510291a612361e0ad7c01f958c9f243a5739ba1730dcec4cc9d0a920d118fc1fafbe4071474265c792c8ed2f4e2a38d8a1e99555977c7717ffe08e2217565d45e088f6cabd37d76ef4891f6f3b77fc5bd98f7f97c9ccb84f13832f030e787290fe045dec32c6e0bc244f0a5f4420b899959c12c3dbb8d40827c55d41d57af4bf9609db87ecac856fb378bac33d0a1f54a8d76f864d77aa86ffe9d59d588c5ded966b947088865c096dd296b7a7c1ddae75ae5967265cd7f4236f2ba78d2508bdec00787433df8a5527f74fd83e8a55542f3a3b466535147b5eee19fa94d68417f21cc048e3d2c38abfeb227b6c553c6d34c3790c62b93895c84db7e25e446446fe231bb560f217c37686f84e80ed2ed4b9379d827534cbca296ac3e572f4976cc16eaed60deaf2de5cc6cfac333a48862dcde73a39e326427ebac229f3e8c8b837d5d28ff9586efb06aebbc4393f015327c6eec54aa1e2f2e7a567974d7d74bca1d1e1630dc27b317eeb39f764a52ad32fa24a3e07122772c2e6d7c37008856c6c7c04abafdc10345b5c4dfc63de014ed0888fee3b7b668c8c2b54577615ee03beae9ca2a453071ba2b838aa39333ae4d2be279e7a592ac6d802c475aa0c9877dc57367b87e883a7c2d5ec3d3c076411b314d365e1f9c2aa385a8eb3a9bd3000ca651702324d30b9a895abdb5ac4ab598cfe6b5991591f3fa1d3c2b1c46d45f3801efe36f85d6922b484ed8db24a65fdf873ee4ffdc272d2e6e9d843c7d57e5f26c113bbeef07962f8f96ee306f6ed4e4c4df6ce072a9c19334e2925c556ef674f236965932ad6249a797a1233b7ca956cb1f328338431e1ce9b3539da48d15f4cefe674c98c5c933ad6b6ab49abc0a138a19bdfd9145609bcd84a13f678efdb8d5fcacfac3628820663e6568a1b2c10935d2eda0619f2ca568fac5c3fb9e52c96af90f1ae666ec11732e5550e7dc0b74b471572166425499a1194a27492c4e56265977e0a18cdb41daca6b65901186c1e98e48b495d487cdfc844404857452016219fb1d3fa38f3d3069255fe97fd64a2a15cec4df32d3e32ec3b7290c7474f33a3d0cc959a119573b4fe396b0a435c1f0c61b666c75f5ae156fd5008f73f47ab139f756243d842e07447f2d5eb26f190025165741a5f8c804f4b63c25c33a8a5e6fea5ee4c06ed1bf7be5eddf68b2dec84f1df8e716632e308ad69be58d10063e91e4ed09ab3148070585fe6232a98f685af7ae2e696cfc29194160c14f05c9fec858301d592d26c6ab13b77feaf1163bf46043d61c4b2ae8b5454c183e203d7cd88842c687021a6f2b9d34e2ef06bd06e6347e1b935356cb4915b734640960f38a287e0855bd55626a6ce3f7e2819ecfdba83946002fbf689b4ada83e6a9b66004f4ee0506ce256be64d52d86c50ed1abadc184b47108bb21477811da6f919e1ed12275ab2264751198486ce4b8ed773534fdcac8cd087c7d86046e02a1fa660d49b818611928526d7926974dd7f4c0eb014a86d69bced169a3e6c4a08e760f17697aab53fc923ebf77c31d77e93b047afdc19e7ac65a0694148f40c30b4e56d69c0af5751bb5b480fc1a5d77eafd7318dc7c036fe2a660b3c0d011eb0668057dcdde7b04002ab955fd09c3e8c58ebeb4abe3e5040c6a40f33f1201f12570d0b2bb9baeec43a78a00bfcfab012701b43435090762881c67da554339ce31df85ab476d17ad21db0627bba41cafb440a5ff45bdf5ae0b178da9be728bca5e384a93f258f8ea18a9cc310d96009a545ecab939975b386bceef922c7ca967a36a8dfc7f8f5a3859bab27ad552f22819c7466b3de02a224639e8051acc7275c1726f252fea2074cb39025278d5c5bd0fd9d00b9d184e2cd6c95e80421fdd3b389519d19ba0196ea0c1c7cfccbbc297c5afc9b5536d6998d7083b32dd08e42771061b673db2947627666ae7dc875aa55177f2145cd9c5b9c79fb1ad30c3e52dc5d38a2b34c0a99be8958bb6b848d46cda6654b29bf934704b335632dc9b2856fee88f0a1d2289e862ba20bb08b3d65513eb82747c77e82cc7cfdd7ac95f046e1d29a3f9b422f0fdf7d99000a4bb8bbc788d5d8652a0326a38895ea65de7581733c36d85d06bdbbafce6ed57e24a66c99524398c435dc4bc1401f921d4742c4f6ce37b38ec85d33e2a3e936b8f1eee1180efbdaeb6b4420eaa5b92496e106e9d5cacf732376ce7aa6b30e8a63c07cab98e62fd90e0b5ebb5977c1eefc0388d5c2e80debb3bd2e6dc0b2088fb40177935e82197ea3daf5b75cf43b4ad6a19ab1b163255888f66f5c083773d8fb4bc5f383c4a8166dbdda46c146ad3cfcba64f7419d254c7cb62f8e26e348d332f2e0035dbeb94e6ed082082cbfbf9e729067ef4b3e80192a19ce663b71ece12b4f7b85174f8e6bd1039e1f54fd1b94cbb11ef7d2133c897d841246a24153197b855c120c0c37d4031455d9ed220f9821ce1441dd68b0c2793e23730da30e00d6be52318638e43ba0d85f8b075fd8f7c3778d5f51dee8830ddd27f540ae0e7f5bff663765711a4c22ea369ae53d5d7742a57fb9d9c085f14aacac2ca3163296a474f8e822703dabb0b07a960f077ae99921ab40861c233cda8804015f5f6e79ee5a61c4ce119508b18e3e78645f1bfd1f6478f9304a96944beb98f38372320f34ac97642087c13230e4dcdbd43edfa9e0dcbedc236b92e9e5533c2de3c4f374e4bf907a44c0b81b8b4b31685175ae10215f08116c62182c7e7acacb566317b7a2e5f91cbb6f6b9278d4d35ff1f7183e29d15ab7c82305e8710a852bf6876ab56d665637786f8cf835cc67ee49897e68acb9aad06b4ebfe53aeb161fefa19da9cde775e0663b372c417f7f4024f5cf652434bf8b1032b1943b78233dcf332babfa466c35477ee66cbc7592db3985609c41ea5689269597dbc800486366faa0e9d7967eb83b80dbbcaf4208e3515aa94f1128c988065159b1fc9bcd5d6c313afba0af8531a40c2f7cae9ba9ec109af3194f3345835243834cb4022788dbf34d2964ba033d99382137d8146aa2ce3cb0561fe8d426954fd08762e944398b785d20aeef0bada1a034173578f5a879c8e96f622d0f90d61589c3c79581405914ac3efb23893524edef2f1677904ffa558331f9515c59e1e294950256392e0948cce93c709f0580b502a100d26f72dee6ce712c2e52a65b4b4292358cfacfaee33b39f52310b39911bdc6f2291efbaaee262ab3f82bd3c6e2302b53ec02a7a0ed467ac80bea39b14ddb3c8302a0f484c87f0512f46c1c5dbd487ac06037e6332d08148e2d36ef949e3040e061e304e22d7bf72b2e11f1968d5043b2b543db93f5342b50be5ab398cd01332b393e43b26fbf1b0d0c346772b6d5f320017322831509118cdd3d121e49db07e1810997e671293d4439d67b3366d80eb841de44d7841b45cc9d1ff4738441ff36b360aa13b3aa59cefc8278692f0d7bf85a140db8f9a7de45d70cf70b9b7d85a15da1955222a08cbdef142c7e4a32c9fabf32579deee8bc2122f1dfa0be9938d9ab7ee347e45cc02462fd1705757c4fc58cb2b74780fc8fe5db214ddaa6caea4a62e55b0a890abc0a33dd564f9a06105b2e5903164314e9c45a5b0035628d1c60cc9dbdf2d9e58d29bc80efeaf4d3e002d645ab70cd6bf7e5101c364152b0d9917462ed955b940ecd8abf584534be24034d16232acdc9f317579409d257dab5e3e3ecf6e3117f0e8bc63aeb753f325a8659b9d11ef05381275f8ca27de771ae1cf3c1060ef876aad13a563bb793dc30cc6fa3011cde5dd73e4ca4855a41eccbdc68d9a4dc8e56a087975da3c3a7b3bc079670808bda26b34e8f7286a88375cc0e89246fa6207c5b695ba9a8aef18662b0bb9619d2f3d1edf7361ad2c22b060adba4991969c38029d330a6e32edfe351f3908a614027c1b170fca960e80c82e84f9c4e1800a900a2c20172f1913b119848a926285dfad60fc8752ae6864536cd8b2a970bd9518ace4c34af2d9190478a6d499056528e0a236f721c93f67dc8ad52a5f39a7a5ea935f7314347eb36e31225bb8f450213100f019256b0c11fad014c06e63f1ed114d6cae79f6aa8916b083ab5b6f0749b72cca73f3cba744f47afed10c501e3c5f62e999ad58801077b2572e2f346de73e124c1e56a4be413bfee66f911772e14f8b7ee15d49d9eb7192dfdb8ba48e1a418982a53eb0d81c61f85495b7c6d08b2c2b6d31dbd35e993f6ebf4ac41294a02564dff3d35596072a489727e546ae200c7ae9779631a07fd734c2c596dd1cffac8ea47c1e04bdc16357930121aa447ad7a92a36203b723ddbe78589ceaf71eeee20746936cb72719ec85dbc11a9c3381b69b425cb9951223a476b4efa61ebf3caebd617c9594fd6a1eb8f6214d90a81e4c931e96174a20e953721ed8c8b6589bd44b28855e60b91a0f45cb8324b8fcf67be427f4ef880b69ce917c921357d52c6b29016c22736cf43808eb26d6f24df91cf7422c8d7a4322b60d5d72cbf0210337b12d76818ad9ff3287065b060e45355a47bd5c55d1ff0710e00711a94f27efcb6f89378fdaaea72b271045d4fa029f198de8b4c4ba3442de0edbc460c771c54ced4869cf5f933677ffee18dfa1e465225e4bf17df33bcb3bae1e0fddf13f63a385434ea96e49b35d57884d6a0a6b042ddd52398f4d94c063a45f13a51016926212c82e8ef315f20204fa9a6cf8ae66cff807a86f94f4fa6a753509864a0eaeb19f3e26b451df971e2e0da5e1ea8387efe1f0fd7229ff0a8676a0218ee7c7e691c936d0c7dbdb79bd46b8e26be0317296926262827f49529b8d3ac63695d60e7d07e2d979be5bf72a3e8777d75bf8a682e9e11da592583d7d6eaf99275f0a29b1399081c3d1ab4d17dc65e897f2d58ef1cbf45e2fcf3427de6a15e9fe2681ef4659e2ac3c70783aa882a93695be2b16ee8e50596d823d31d0c313618ac08aca625b8adab7924d33b53a0b6060dbfc239ed094f6d5053c00aaada167c30084ffa03c6323b3bd61f278759d0c2918d19e7a68937e6280f979a24225e1f9bf67bd8a43d538ddd7699b02713dab90b1a9b59ff581237ca365acb2b526446f59852e252f9d08adaabb0c84605d0d0418ef164c834f9a0b93efec22ce0b39c919f6589a271da5f223d9b5845b07e23ef99a18c985cf6620c799aed23c8fb06fab9002a6f7bbdff97562b12f03794dca81da030d510a78cc6734c9abf0ec7f135c50f9e2befb7e19975b5c72ce4b98af4e91a84ce4435abdd64157919766f7a3dea3888ef9d11f972fc624b10b13b5464a3cebd97f5b285c263587dd505004eef362251cf2680d230c99db8941d469a0ab9ca11d7e62d50c6b503cc9e1e79a6dd356398cb9935241320","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
