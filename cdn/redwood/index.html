<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24b3cc02b99f795a86a87485a310e71a677c3d60e90d71d199462b598d9f449197f729d6076b120fb3dbb28729ec5edd05acc53b832ade41ffc057dd7c7daaf6e721a59d86875c4e0189c939e032602afcd623f3d7cefb5ef6cbc1528d59f73f02980d38c07e990558e7ccf3b3351d572bda5c8bdd7e651d1fd81fbdf7ff8bd16f9a7450ac4e9240214a38c2bfbd82dafb43370f9e4e27956c6365e97378df9e0fcb7af8de60a6d8bb14a7d4fe5404c2a178258c4bdf4a222ed1c83335e9e274bdc3db1071dbf6664b7a3916d5744e6c57d9cd0418def52c7f08abf0b2b959e726bfc4b33312757d8e06b05f08fd577b20693b66ce74020b4d065ef78da39d99d9696a50ad2274842aff5705ddd9ab9fa2c4bebbcb4dd88c2bb7089c46716ceb0919004120171f77f096a2719ee1e1fc19b4ed78b00092ae2b282620a7256b4a3645410634bc531b7dcbc90cf8ff11153c1c8463ceba9926875fa73df0ae41a55ed231dd5ea2a03db32093dadb53c629352eee539196e21b5fbd48d25e3d6044bc325090bd9fb0c41a871c1ba894ed5d720e4081cc6f77f5bc250b83b596ed55efc22abf533c17593ffa7d5b9ac4ba0c94bfd3e8927ed4e10c99618609c03f6653c7264b9486d8826b77233fcd2f152a36217f0352388f121fc06d0937f2ae40a52652acfc16fadf4e1795d4ce199890d040d3c62b5a0844ac40c9c13edf0d31f89f8ffd820efa205a67e307d7ea53e1f5163127416cd006d8b1cb1541003cc0b7bd8fbde2b36bcace90b2c51b026ec7994e3aa959896582b6cfbbc442078ffe21f6ccd685bc029393f94f98111d7cecfca84cc51e254c23ec589f88b139357d8a600dbf21f735220752e4031df876fecc074ebd5ce07def0be50ea9c665497771359555a4e95e9e09ceb0ae082f9aa7f4c95b03b131ef5fca34d54ee2ae8755280418c175d0d3e4c07dba3716f8b733c9adf97715df15913a6ba77961ee9cf32441089830c977a915a7b01a9e49e9760ce22c05d3c67b0864b251b9dda5603ced72714c45a67752a02db3878103fc7be11424dce70213b49ec687973161059af5e3a3ca3988149623b41ce3515d4bc113f5934f0b4a6a42509581e8465fef417ab30aa5aa0a69b27c253d86165d405a8c28d93f9aaab192e9fa348ae5b5d931f95e7edab38a97123341a94f8c910f412faa2ca68e7fd18dfa4ad9c06c6d472909b02e323e4615fffca255d79959ff284e0f943b0ba26b3a1f90d5c87e7e5a38f420755e8d07c9137e78eeb0b5e0a1bd05b8d327d20e8ab472f9b69a101a7d19f80b7dce2b99b71cb2d2691f7aca7bdec459ae42522a406212d46b0f1c573def348fb895ca02a6338f1ca011abeb4a7b7432aa8262d96c4583af51ad81f6c6570cc7e04bf34295937b06aad2646d949cbda73db5c759632d7b97dc87a4e753331a9f7862569928135e927181305ad49c18fb4bcb8c479b856b2324aa38993fe33d2f25d8f157dbe6f5d86b3e30494c7a23b2a187b8e364ecb1f83b7d6c91fa717d00d58b5ff72c00973210e0194563fc493e662a95db83f13d0a69c71211a184d088b027782f860822cf59a75adcb1d7611e4104c2f9c7a7dc1b61a617e126ea6b20173ce97604d3442158341c92f92582edd9e4ed301977545f5676b7ff5e21b66b68c6050e024b26550541783175882dcd32320f7d8f39aac0f3009ba339f652d3603af8d437981f6f028cf3fbb1eadcd28bf282dbdde1028ce3a277817718f4c46d14a96c79ccb61b95a4447b0a0d9737505c6163273874a6eb4a0a32e4ba4f88b0216ea6dacecf82544aa0fbae8288188e89920ff8faac3208a480199374041c54b4ee9523c26a93ba6fcd6d5b5842a19ab37d3e030348b9030c02a6398c0e7cfa466d04b7899728229fb0e8f031ff6c40f2fb1f99866bb749e887aa703b678dca8a06e74a1532cea1a650969a1de0903c8e616a7e814d5e4c5a8108772dce0e32f5cb954fda503c689ed05040692478b09fb1cbee1575e1a4c9d3f701b662d8a061163c08131b3ba832d72f92f477fde3cd774c0b6639307888081032c33f80637ed9cf8a69bfd5b209b7e0a15ee2bc07a4cd586184ec080ab95ee36e659835ee9875a05e6633b6235ea5446e1ae5462ed99de209270fd35b1f6c1cca2b2c5779cb47d2f14e15fb79ba4e00396c61002d61e832960b99dd0815c762b341ef0199c95cd71b68694138b900c8afcf077a00c2f46469e330fba8a0d90d0fd937ef815a25142d9492f8ce3a44501c6a3c5d4e2be898cd00dc7c420443ba6144e6db99764548c76a27a47917973dbaf49a9a7d278239a155fe17808c49b42afe700d8b8e3c2f458e3c03c3437f0e6379d748def9cb85aeb050122345c8534a8df9adedc7399d1a4766dd86cb0b574084987489e138e8a646177f9b1d0daa48598bf0fd04f58787f51b863fce544b66172be1e73a2718639279143cd28dfdd9946580c23612b4c9b16ba678705cd38ab82a777444d088a2ce7f8f218d4e54748d0e02f00f4e0b7b6a8830134b8c103d450a48fe6ba0d173cfaf65a45a22514e6435c4e28a8397149b9d41102219fd51dd8ee8277225e98df96804536a71ab884cee6f4a71c2358699551ac9d13590295094a0c952199e8d0d1db8590835c6a747835a292bca1a6d860bec21d772ba42d2af017b124a2492d6175b7505f0668a34a1510a5dc89aac31a90d20dc03626a74c6de2c1942e36900c6250adef12fad061137e893e5a10227995d40b079f07aefa70bcd72f2bb779ab9c293ff538ea6c481f9bc854cfcce7688be180e9715fa860de0817804c30a0f7da7b314a9085be5696fc043637245f542af03eacc2720312d8ce35e88478462ce34314c575c5d5672886376e0e8e8c00036db68f517121f156d03c25fc0745de3bdb2a1b3e9db9e7390aeae8a0c017008f9f4af531cdb4dda740fc3c7fc24e4e5a06426bf9d5b1a09cf2f1b25e48bbea42197d7dfc6c40691c324b5d44f223ef08b8f19ecbe73a725dcb39641ad24d9f624ef1f67e8df59d79dee4d2b4ac83d472aed1775a52e916219222f2378bd5366f2b88d73895d0232f7739757e516d03f35fa27a73fb946afbb0b99a4976dc8c65ce5d40cb80a4d41670d914c02211bfb03ec6723efe484a9d22dfe27b7cd4d45b10d605d157c871c9a49b1c98812570cd2f042ab497ee8737b02f27efd6fa4cad1c266fdb68cd82bd199468028396de1035cd980dd451790ac48488587f1a96f63cd27324c9f4f335bf9430e11cac343e74fe8de172ca7dc4aefa1a0337db1338201e742fdc6e5ec8f012c559da1287f3deac9a07b5a40f7b7b32b7f19cc982994a37f36e107b00b8f5d5a8ac3925111374c1a1afd60e665b64324c5c6cf45645ed4ffe73c10a16b401f922559db548ffbd3d0996f6433e11214382e250baed29de262a84ab0ad36759318b42310560ff853da57ac489e67a4004162e9fc1dc9a5bd1a7b2df35bb82175ebd301e687bd5bcd2d3908a8cc743e5f4fd3d9f93159f8334c35b11324a6f63abb896d15d2b187cd389b1f51725181ba4e172aad8efc6670736288c41568143d89e6fa093e2fcf679bcdcb660fd305000eccffb525ad6eedf6638e286883cd99f3e25fc2f08489c783affabc7e452088588fa5ee646d967be7704341cb710a0c2278ea8210f374007a4ee4a66da27d4b9417bbc64589779f407c96e431684535c5f6689de12984a44dedb112a6f24821bfffa667553a0a915fe070390670e2058bd308b5189cc8644832f056a5f5e9bf36419a19af1476ae41445bcfe97f9de5830269fe85f405fc43d48a537173699e4991c9bfb6806f6366346c59519dfe40dcfa9eec75b4af22fcd973b586bdca2a930a56ed7bbb4749cf98a73e188860a23afceed51fda9783e4293797ad1ee4bdee54cdfa8514000dc48ae21a2c12b25836259324d64ba2bd77f545a2fe0f6d8ec633dfe87183c0b9d64f3ee6b5aa42c019d5c8158c7bd3bb043308d8b6b20499f92ba3da02a7add7f2e83e03220be245671251df41da9519b7853689bd4bd3fae22eec07ae50209c16b41280666527c5a12a8a3ef1f1c6eb8dc46408e89a6238cd35dd3407d515e885548244a2ac0a67df04e2fece4aa785e040cb4173d2d7ae7ac289d99cc56a141354ba9c90126ac0fdac8b8ecd4be6147263ac995d32d2de8a2b5539f7b603f139109aa68119ee49480198c335c4577454e340308d2435ca077b4a143fb86ea10a7e82a647f0764f7f60b271ef8cbca1e684a1b6615523a72243fc7a37fd0553067d0c7006d3511b00530dbe2ad73a687757748f5ad1b13aa264d6e732d7e191a99f6cf9193261082287f0cbc9d636d2c9d4062bde4a442b56dacbc7e2647bbe50c4804a66078cfd62f92b0e88df2ed240042a586b351b949baca55816a17ee2066ac8d76952332e01234d09724b6e0f6c16f4683c50d9faa5db5a9483b171ad0d76ced4302157b48a2092204cbf6e86ce54e4e966fcbc4370a2dca738147d73937588a83fd69353cef3c03b5ac759631a080f79bbc8ecc1f04b4356a2178bd971e7e194c3312e7a5fda33e49f3e4e5bb0ccb70691b6193c1a8d0379370f6eaba542bd4647c9b9884b07ee2f87e6785d815ef65ce9f0cb7ac2e3909c3b35f1437611fe557e095e9269f2f1a6996c00bb08cfd3f567cbbce9da1ad990dad28c39b1ab49ad6a15cb0e39d4538dc45995afadce12a5a6c7841104d98b2fc02209ffd07cd4f4528643693c643521915e5b4d10d7611cbea212797c30d4d2fd33f2eba6058f2039bbe3b63860f18cea67a33643221f8f21a8abeeac1cd358660ae262d2eabd5844e1d664f3b16c21e6307555efcd16ef8583492ab43727d7f21f850382d326893633c1c05da99494087554180a1caaf7e0686b5ed8ad520e1b46c454a0250b30c55be0835616fec9ef1163a5d54909714b31bfd81f2df956021492fc5e9fdaea87a5c22d22ef023914a1208e422c04f7394e630e5f5c24204ebebea3314f3eb431a86753eee1e0c413beefd4f8ba78c42f3284766b5174bba668a0e91aaec70d204b4c97bca06658b38c5c5233ec65a6193395ef88b0434bf6541805ec4e4b163142ec39d106f384a09aaeb4edde1c07bc9f0a698c975133cbc56b26b704a9f1a572d8717e07404a4ca3d90b8d88618bb559010f629fb19c34ddfdbcf053a0e28d8f0f9b09d60e67f35cbcf4957ac2e50e6b64f8d9fa5646bd65766ceada0d750afa946706ddda4431d70c73c9e2380834657b75a4675b4686a3060e4b6021652c8ea9bae97dbce33573870d4d179783173d1e7cb21bbb595b1bde0bfb1350c4991bc51959f85864547f7a61dc83e94c159bd1e6cdea4cc1232f4fc73a455e7f2744948bea5aecea8206d978a20a0fcea87449ee9241451583be13c20363214b8f88fde160c8ab727dd9bdf3c2de28a4064a2b76f8899f7c39c9d208a3291babd556f1a7c0a18066486483565f46f89cdaf26aa8bfe954eab7367ed81b30035442bb4c5a429783fd64f00f95f37466f5db5f24b7c0c5a4693442a72ea21b0f3f2c57ac77b5aab4fa9981253688b103976f5f8d23f4cb34e14e37efd338952828fd7b17f4eacb14ec540dd92336fa571dbcfef4a4de30ad2135c7b443ef6231bad69036332a6d98448fc2610625f55a9c91ad485ce0ba74dd3309b5a80b8d53124eac4168fb73c1cf6ba14b28b2d4fd0051884290e67fa1da5c80270ba60f7b7c135b6d4d4528c058694eb30e33106b6f81a76ae87e8121a34a63690f2017e10f5119b97b0a80c6972ca0b45ca0dbd10b765f15a5455cec8344c41f094eecc6a14cc48250e973eb0f8b181026825ed50eda77a61f39dbd9c662e4fa59b481846ed52c9e616d0ea5c34943ba040c27e09e7b38d6349d76e7b668c4a501eabadf936d9e7614df9f24fdc9ce7dd97e94fe5e799566de8b6a00f019fc95c86eb1d3afdad84c032c5b17f94194202c84ef388c415de8c50eb3d292e07e941354f1d8ed756d1050485fd89ef3863efb2bfb0e1c7e225b2e4364e1be7bc0ad8627249c0b693ac724a7060a69a635b03f6796fddc0cf0ddd50de560ed76ac77320a529aa2f62b979816bb1ede93cd7bfbfeead6f10146613a1582844b8104e00e072e165ff2cf8095696a560dc70e25c2b41af3b06b870bfa4263ead3bd99e2704c6da6b684b839d97d1f33651785da0118ab63db2b875eef304198273f2ccf78bf7d37c20008f85c9bf400f30a0707804db5f92e1978184af43729c7f775d16722981a7cdb0f213ef542a2770eec3e2d094f2bb12f0b22fe41cabb615c6a40beedca6d3cca61a0a30f832125ed94930e4cc54fa92a9ffc9219cfc066397468234b361fa45b22354995d711ae2ee401b26cfb04bf2865de4eadcaf6d391e241683904019a7e4411d16ee942a0b091762750897c4aa458e88a907ae585860050e6fe3f9a05b0f2bdd4064ff471a5f3c977048a046bf59720920020fcdc1a5b9d9f44d12fde65b89ed235d43e04ec2170c221eb08091b3ae950d5cbac4043c21b61aaac8f3877f47987475b5673aeecd963171eccaef29a68d9a0efd11fa7eccd305b68419c5b6de665f56f7b371761d60e4de5f30b3b56634f521d4b00d7432ef62107cda80fb397aa59e2d0d06e54b5a08959938982eb7842840ec7d2ac45f8564e9852c6c6fa0d2dd03f0ef2a4a223eb41c1f5557a01bfcc7f89085d2a7659fd202a20c34a9737dab9e88c929b6b252b9299d53948c8c893f961a15e35431c5ff57f5bc62a5d687bbdaab0dced5996f7abb2151c6fe41e53f622877abf945475006d84623ec998624b27fe6d312f48472b5f41da858eeb2b0e84cf281b27e7cfd5dd82fef4b4c2d30115909a0fad2b93ecac4c489b5d27aee986b401b7cbecf374d21073e3849775a1e9647c4e6bb471c4a033efc2a6c79aa42d59405c0b330f36f1652872cc427d4d0ca33e58863615bbddb664e997c977f1fe15b007a5dcc1a0e63208b3d7dfa8743997f4b0b3f8ae710ee5e9acbc856f6a3613e4425aa9e910764277127552ceb9641e0cbd4cbc5758e3df46696eb80e32ba6a3abde7d91a8b3b1b3ea8910bbf00ebc08669cf9917bd90c6fd2c5a7a0d9c3f5016c518d1c45e502679577f8e39f421305f859f6402ab75846cf61bbaf714d43f5748b81651055459967fa101e9298195556055f190af1134f86998437fdd9926a418fe4773bb8d7840a8de1a13ade42eb7e2d71eba47de15e64b394fb90cc12f191e8b383b4155ad4b03796a7569d23dc984fab648f82c9e3a31d343a89d102c188b07ce801e41cacf35960a4e948df358e84340d24780d5c10e5121ffc1e0ee04c09bd42891a8d1389fa646a0d668d43ca9cdd5a5e19a6753ad72960302b45819bf15c097b7960d80ee7632fe10fc8e6059e03668ce26e59ec3d16525c59dd160e85920038723a09f6335d7f7aa343ed0004782036b179edebde5e4ff45babe1b41019578ad7c64e967a15e3e5ff430ea651e8830ffa0b8f308bbe6b15a8db6b155a21e8e7b08d9a279eace171985efae6f1f622aca8ba2a50e0196aee30e8a5a85edf46777be528494ddbb9c3e9ebfe90357d6d02c6da76ee435d78bdacb29bf0122f02617866dec1bdd6ecde06c6cde3c23f2dc1882487635c4a30a007639d8954db310d328b8754fb0474e005fc625d1094e2e2cd1f2c0a895b6f64101948d7a695ba4ceaa5fcd3d8ef44618ac5618809983d7fe20bb3996c7b23693a2c2917db2aaa9abb1b1bae2c52afcce0e44bfd0caa7b2cbac59c2710fa288b5c52c51f0e1e2532089dbbeba2cfeaa7a448abfefff94a7b757fae1d731fe4e6c222374389d4d8a277b50739b58c79eaaca4b36435c14cdfb25620d5b5e80f782d7bc34c7f6b7e0a5a230a4f74936ea31f98fc5054d635eff5480a01d7562bb7fbc19b7a6c55d9c250c33ae8350caf0bc2ca2a1e90bf9c216a20148f3ae2c00e6ac9cf7737f8fee6840ac4cde05174d8301447e548415e91df75ba81ee81d7414481ee5a5a946de20a3abfb8d59768ccc9abf70a4c59f0869485d29bddf1d3892fa00cb7982b88af569008629bcc989b62caee24021e38cbdc0e7f3a345fce4c436fdb0f7f189ed7b55eed128317d95d4169cc9051b87782dd23d5084237b64c423c31ebbd278e21f9e051269614960a50d9e187ffbd8e408ec1a60cfae258faefa7efda1bf353e2f79271f1ba102b60b761074a15e11571c6da9bd3b7182d4bcf0fabd9cc2141a20d996032df6a5145168849b366448a2812b1addf9e2f81c6afa9b7ae10b5a33002ad10f7e1db75ee4632276f90007793daa57d8f42d36f1b22b5747f5e51004e5a839995a0a6fd4dfe8999f56a1ed02474f226d25f1b947355dd748743e7cd500b51210abb31c52a498d0eed434cf82aaa61da0adafc85cb6e6b98c1b73644446d6a5f678a307d453d565245147983bd49dbed5d8e1988890266721f32c75d18ed6bcafe3588071329492078b5825283ac657ed04666166962b047163cc1667d5e9ceabb4b82ca8fb0062fee59d4232502971ef2ebc039041ea11ede09d77231747ae0a5e1a9e6e25f18f286425ccd43880c6e3dfffa5822a412b5b343bca825457e688a11e5414ca3caa4f1887f9f62847537ec96758835e239a587659c2f2cb46d8f793ce19009fe6f36ddd2e0a79606577fc5c80d12d56eaef8872739d6ced8d93774a5695a3b541623a5601ee361cf2e41dda2697d9171cb9616a2111e9513e0c9c791ff6a4fb700d0eae6de00bc7812c67ff68ddc2f8803436820cae347724ccd35f7ad9552bdfae2b5967211b3749044ca195aad9484250753f7fb8a353c5347b01963536b404717606aa9f7a9dce71f600399f98f4614b7cb33e48153c79f10e917203b30ae82b238c76d7edd1472be17d521e6bc555085a55028c0010db95df636f7301f8fd14caffd923072199c980ffd940c326feb3debcd3fd2e65c4ff4dcd9b4bd9122aa92011b878ec66dd021594f5b6c18bbc321e5a342964a588a01726a733ac970d56320df9552194b61fc9e285a5e65d2d28e4d9add9b6bbb6606cc81652155cfb3c9c647f194f0cfad6c06987007ffe72345ce2a82ba180f8043382e0f086485eefad804dfbf40edd8c4c9cf78ef13a261cdfa8e43b1c50cddabadc2420391f441cf9d767ff0eda3f158b63d360150a826a6a4b70f4429865d34f3355d479eee69708c73ccd58cc7f21f0c5c68c956cd1caad1eff6ec519ea94b9207645bd43d197828131f4c490576aba754602fe94ce294a7b6cf252851ecb17aaf51470d4d13c23ca818db4f75e56bd01fcbf0d177fc67ab500aad91a44fb3c69ee093f9d73121c7549199dfafebf0abd3f1b9764ff186f6a30a5e374252ef98163c87d65713b7f740bf16a20d5be79ee0613854380990c482a7f7c02c63f928549cad5326366d95fcc49b391d32b7bb9d87571ab1ab1f2c7f0a54679acc34eeb412d09d18cc0d4de23e6b9b6608e181babb08129f8ad7bdadd088fe09a55e4369dbfd7cc490f5e57f8dbe55c22c3abc8afa75d991e0ad1a38868218005fcd3b1d09c479aa6bf3efbdb84d34328589cc3039b8be0f9f09deb6ed44e73db2503e7200eda4b735723daca2cbb18edd915990c6f2059ca4913e6be526cecfc3345000968e25668ac7bcea182f2616fb09860ed2a754d0711b30f0efe9699341e4f79943444449727bf9b146ed7c52c1d8fb59a17c16e32c954c9571f109194a6a1f530db8b56d5a96fcfabcad6ff93ea1fe4c862729a869cf6b3ca45fc4395c0aacaa8e2c040a2c2c155774e0219f08b5c70db387d2440be72c649ee362e5d6a3fbe88332040e090348173b4555b2a614b0c95515236956326855a104b63f324373331be4b2268db76e4c7b4a90c69fa2c72cec9f443be257e766be5719e565127359380a8cc8f66b0e5ba05ac9c5cec77ada532ed04d4f427ea78f1d2b593b9b5708d12309c33be79cffd4878043428fad8af958b6231ead7129adaf6ef67f4849f8a61f875a7c8d10d327c58fcfd45330cf81e0e5993cf814b49a264f82ab3529a364178ef5c2ab6fa7c4ab01e09d521871d33dc274e35c3c8fb7b7715529f7d9a690aaebbd2fb74da21f7b2a896544aa6b5a8e3031affff5e614837a1a0fee86b8d176d87bbc44ced6690ddf3fb3f7a304413c658cc04e1d36d97430e24a0c3a549cd0376f6dfdf9e402c719eab1f29aeaf48ad4d7abf31ebe590239b5bd5058c2a99140f22ffdb6582872580c89d4f310bef88f933b41e30be3e4d2e5d07a2721e0a7e3aebc72a26b61f7cf9a82390fb5d328e5859909d547da85986e913f7878994cb390a98e9c316ee05e6221a950bc0c3bb1944bb6eadb9b2ba3b002ecd816f0d7eb8941c66fdb0da979133e189cfd2fd2555ebdc483374c84bec79b7d8583ed1086df8d1b96ceda14ba6fc8153115d02c8623a9a1f943067aef1840ef2891113846ca1a0259f5de3a4e333730a6f6768fc19422ae7745b324e7a01e7dd99f057ec1c6a88b72dbe695053c6ba5156ba7cec44dcbf6095b8f8794c76672244d270093cc528b24c255d0f745419554e232827f1e57a87f7db29ea1f999207bc6172b6db304e3e092306db168ea100b7f9d7aa5d685ffd992cbb82f6458b99ec9a947f87739f7714a9940754d8501ad2c32558c1e8de7fee4bed085bdbce2bff4c70b26eb251da701ea39a38e8eaf1b686d16681593877b0f692219d049dd8c5a9faca51243fbe9dc1ad3494ad5da627a059e0e5e4fe2c18272fd109d4817fb330365248198c70c47ecc50cb08e95d36653a19a3bad9e7768d6495677902852812d9cddc512ea088c0b2c70dda4efdd1ed9c6cd4274af116a8cf941f64f3f7bb4ef00d5948fbbf00a5836a30513d637ecadeed712dacf700dc25850f9a99b5af21f5d31fea0d866df1ac6fdab647d993234ede37dce3acff854edd15544be169fac0a2940275d211a1b954c14cd2f1cfca4ce3aeb5e64f649598519a9d9f09fb1db2c3368ae9dca80285140dc5a4bca5f1bee2b152fa33a96f11af46d496e6e4f461ed438a4e199a8d4cea468c87600b6a89b06e35a0f00909e49a4ca7985d0b93de2e23fa719e76cd62c743925e8f0ba4243bc4f4ba8e9ddea2314242ea2cd9ca3ebeddc0849bc3a77be13d8d052988e3c2a394b7f37ffcafa7c650098935657d1182a5ef158c6992aa204a8aed77720c2a2c60fc8e632e8ad481f393a7b79648b5186c0e3e095ec89e01e469544e0864ff2c5d9f54ebcc92cabfa7aff3a94f9635d3bdf35cca89ccc0067ad0128e97a96d19b0bc399a0cf17466ebfd6094581d1c71b416557ca0bd772c24c507e1df59134012e7553d30f1b0b4dc96e300b60d2314569f23c152f1344534c5eddfd2c31542d196f5c292d8268cd7affad2215c5cad9ce1635c3361dbbd582dedacf1f5c220d36fa7e7a335a2f07ef9befc3bd9cb92f70746bfcc8da51ffda69a94a52bc8524411c5f11ca35ea68d4c9729d2ed5e858c812556a5b328f2871ffe51d1958b8badfea8b4f70d87498fc7020b1db297b0f4a9402027105bd7ce5d2e1f9eec6bb967d7f29fed25c9e0dd2d531ee55fde1841de9e6d8313ccec6698e395dcc340e3c14b7e1c68d8ad7e041e168e450dcf0bc4ee6cde99d9394e7e30e0ac83f77d5110befb5d4dac056bb4194a143403ee0c7bf2b7d0c1d59f93793a565737b90d0379794de0b177a49069dca9b0c8735e42882f7674a309d268c562d05dcd19fc48ddecf50b0a5f42267c84f81e4f2d0303ad6c29d83271603b592c12db7e32a9014a87a7a0a7eee72b294b700c166fab1ddeabcd5fb3a40d5a8915ab8064b682947db57425b71332bbda8bf3c2634710ee4c17d20a4c0e42a524ca2963199b70b7fc044d9e6d8edac16ab95a9be187db96171adf04d02964946e887384c491f23fdabd6d35f041a50887254ae3f2193721da46f0fbffafd099be2763e926b19a20b7db642cfe8b6a8a97b019143e4e873912ffeaf40b53c89e87cfd8ad8baf2df00a083f92ad271a788f9bca9a2b09ff1bd5eaad8b84c20314cec8ec099fcf2d7ec4fdb32c73dc8e1edfd98fcfcff19324f7dd1c11a18cea6b94b794e6b9360cd6acc3e52b9d2dae8a90f5079399b9cc03c5435fbaee6e11d787592ff2fa8eb87ed5a9ab526a188453a41638f18f6848cd6a66a3f86d98de55d2528e001a331c554a0a96551030235593c1a9e009eeb8e1c3e7142a0d36ee9f5fd205a9541196aaa2e92677c459271a313aa990d9f5d3fb91f03472aad1f1ada4ac9fcc6e404da942fc0436060a3342ed2363a9bffcc71c765dd87eeca6fec9e3ac27510fea4f05c4dbe54cd750cabba97a8b0f082205e69ee151cb1a797b5a940c44982f161e77b04361f0b90471c54e3fb27e88cd42ef8c5d1e3a2dba49b316fbcb0a053c0539780ce8bb059b007d5ccd2651c7af385f75d2e58e90e387aa127a25185990575211bcbea7f5b1fc5c7701c0fbc32f2701de2fbc592e44b5417832dbb80858018e1579d3f97b963954aac90534b82151e870145401aafe18dd2bc3aa3e9862f0022c3a4fc16e703bff7cb657f2bf7bbae7fa73f4833a0f8a44c615ba8c0d52ccc5f18d43942be80511cad8f7fba391819d5637fda45499621ea26720b0fa8bf118bcb566da1173bc8b0b8c298f8a9fbd48f0ffe92b27d2869a0e731e3defb953db1295502ce2d184a2c4923ddafad28933a7cd72eb7af09c36e07da5d418cc513dceea4d61c21d537f1404e5aff27e1152fb216a6f6e7d098248d2e16d20c32c3a0cfd5cdab919d3dd997230c9e7a8ba43f921c45bc23dab46d6d75f23825829015f5607744b4f20805f1774e451acf0d27632b67f2e0aa93049c4b5b9a39740f1fb9150933a9fc7d96f2c92927c48ab14f97449fb878d4d68de72e5aa575286f5d21a9c4acf7c74b4ec15943ff0567fff25c3132b88a5a5a2fe1ac387b52c76e1c480935c3fecc69fe099e42522be80d0ddfa3551a7fb4b87df6b681531a260847f05f62901b7db3ef012a6ec8b35cb9cc87b3e89902025a9269ebd3407212f65ff69c958a8f546f7722104f1687040e58d2863c20f67ddf742fb100987136ec07b7aaef76db42771cb069b1d49ef0ef0278ad4aac378916db2951b287024535449fdd8d43dad15b338dd9f2698779086dee2705d32a15d5944badcb1906ce21e77446399db07246708f6b39bc5e0c572055235c25e0474df1c12de2a675d458cd5be0af2c4a0ab8742782b40609e97521043616cabfd0871b448032aa8a483a8c1514408af87e5aacd40d325bf2dfe8bc0c3d8ffbf4cad6097f27266958727bd8db9bf5a44432fce0dd4598612c843d9afc1bd8d2d9121716432dcbd4b5e4cdde0bd540aa45d7f98905ea4a40878e9b2672ddd0fc6b4f96d9017a4ece748a5bf3e7178cb89f86be7ac1785eb125225f420b544833de5952a266a3d94498caa3b773d3836577aff0ab839c027374d6b0ff63bb08978b34a27c5a87ce6907e9983e1b66924b7d07c01906ab24e03a560fc39ffdc6599079efef3ba9ce5d1b0202a5535deeeb8bfca0c863fd03d6cb18cfef7139e3d2f0bcdd9b96291d9c4486c809f523e171caa704923a1770bec84877ae5f005eeec43d25eb3051001419a526aae8c4e793d5687f3281da3958ca96f00a03725b009ad436bb35dc8f97321ed6ca983e74532007544da3b67fb39afe2306e3d0cddfbff0cfbe5eb05d59834e481cf993cf01e8f4cbd0ada076a08912c5da552b1167cc3a66d46c69e7c2960dd02b6cb48580c31b0a2829bb9937c3f2509b957b96648f7f541b3e64a0bde1fd36b403d4c3f392f88bc09135957e4e997dfc8e79dbc98a105ef2d630e184b6ba599d42c3b6d6749be4a64f0649411973f60e31e0a4291c3702cbf994dbb39ba4f5b668693d6f31a497158cab74e21faeb67bc6271ed0197839e0355da38062099b9f18153bf3f55e760519ef3cf1a01602946561ad4184c13fd901d7f7651c201a91fb6517c2d60de6f5bab3549be828b475dba56e3032476c65fae28d9cdbe779edc5320e72428601e8c767922e88e9593cbdd339b36d33e1126f48909ae3e2f4cc47d4650201914b7bed27c592564186d1827111e3ffcfbdea0ccc90904dd2671c1868da73ae68492721aa4085861637ccf5b80f97e34308a80ccaf14c636616126a3633f2890e2cc5abb2a41c3ee4356e7b7e7e57a83c7485a26476d97bc7d4086e57f99c5544653d425fa338c30ac0fe37be49ab02dc2e7ae7dbfb50bced24775b7a8907761525a669f39a8657cfc93c1c3db19878964a4575f6621bdc53d693bf2f4d1c490193295722eb04c3b58c4af484b34252929194b021b3ec185d989b30e681b0f4773e72e3ccfa65fcd363fa50f13e6632e81603959c039208d0ed7092030302646aecf6bd15ff427541193786427b68459e7c4d08abc90694b1a8972daf0b1128191308d0113c60b4b1a6159d7e52c48ceeb2ef13871b0dd895524592478425497574c1631f7c80ac69c4874d8f22b7a5e584257635925c2a0fdf7c1b36c862e6fc1ef042d71e1f40e279d6b687e5cfa2069e0849a8d81199ab60973897ded20b50b52edde0e081b61f3e1091d7821ebffa4ca3bf0adc2446133fc12407020514b2e74d500a9d8235023332f6eb156be726d186d4d1ff3c386345484f07b0f7594ceb86401b9d48ad503beba38c8fe45a3167b2d568cce95ea9cf020b9f5aa0dcab1e0e001e4796ad8b2e8398a0a363bdcc773619c606a899088949cdfbcf5b92d88d3351f45d57560138addfaf506b195bc57e063c4a11f792a0f238602a443a6fd448f1b1b245457e54da89b0cfc42084471255833392b66d09603d38ce62c554dfca42aae437c483f98a404e4083d211861e1b9b7bd8236914f08e7e4a47c0c66bfc1a61199f11b6a9ef2ee648bfcf5e000708601636cc91834036e083008cada35bdd31a5047c74744a1af6b8a1ac36efe3e30c8ca94b4af68fb7df97ff52a4c53203b07ead5548c4836959bc292efffca46c38027ea1cd4ed4a687723d7165d61a7227fb64943186d0d0187514f1715955f2ff2cae7443a7df9a1c49f170fe7643e63ae6a225c2871b7f3613523850655e2369dc8bfeb04e4a5378e7c4b842226380331e413cb77e888c1ef95a9bf1f434514666f56503b5efe998b57a9abf1ae246da16d630ddb97665acf71e2fbcf244f56818260c180e9d510fb8d2e445ac353c2dc5e69a3a010dd394e2b435967d8236e07b18c8930ec0f73d96ca531786de4dd61efc46da1184374f0465947f62e9d15eca5d5213a879c81076ca345e0cbda5306c5cf073fe0a84f3101f471d92b61209bd90d29c34b72944bf04acebd9dff2cca53ae91230978521e4059c67d4fbbe0b50d9ac7d0fc28340805f15976c24fb4459b4392dd1e12e09a69ccc027d95d0159ad300aca269613d8ae2e48402ceacefcdb12a8183e6e32da1bd29bce3ecdc3ced425e10a4d633b1e3b95d57327f02ef7ab88075b795ed7b8da9e1705934a004542577fc56df5a77d315a03878ab4a2523641900321fe45508d5662f982b9daa32502220fec9ebdbee1e3ae636653b1cffee79d77d270bbc6d0518024b4a8a1fc4091077d9ba1e62476cfa8357fd7b00a121e92be0a4218e3bc4201caa8d6ded823f46d1f13b1309e0fdd056d3a29d5cbceaebb3d93a77441337e03c028714f5547b0a5a295f7009e318eb2563d1980f0b8fdf1cfc4e655286f749a06cbfbfb31ab64e5e3ca48dc7e91c8f7baa8ff08ec263b36b91d56d1475c0fa0c1dde553bcd1443b3af74baa1aa9934510abdb83554594ae76033fcceb042279ebe55a7eeb0e47a28f155ec91058c7a07dc4cebb192bd344b001a7e0278b7eda3ce12f3e88da4e0f31186c0f8dc45353d21957d9340a4ea648bd4f4b05ebf52dd285fb1559155201c5dd5a4853f76e0be914ef63543a3b65d857edc90bb5abc8febc06bcada3e1457c601612540fcdc6e92b9ae0c0299fb9eb82e51d192627112eb85aa0746c8465277f54259e88363bfd338f681f182b7a9786beffb4106cddc8756a6a9a2a4180cf05b8b8fd885ceb750d143717bde0b4f4a59f4dc8cc4235e9c99b1be8255caa134c98302262a9ce9bef6d472caca5c75c164f2e9c6f743291cf5c479e4d80d9e16e502988427add1c69f8c400713b96e4e010a74c9436ce44a64159345c6d3896fba6c35af1ebc633e70f754a662cfe4caa48e54984e70f95dd789957c400b39931834552603871bacbca5c4bca8992b752f87bb69a48513e53e88512c190a22eb081555a6ad8d41433b35bda20745012967773478ef937d8d25e58d3a5d028f209ddec5e58175d3567b7846f224428629192f6f38994d75154356e86e35e045061cd5fa99b5b324d5fa08351d19f7183a2e06ea8b72032082c6a8ac791240974001da0d9706c7b20f752f5f33e197fe67117c780954156e3db4b76aa45d554629eb1be3be44bba0221e14114dc1a029c1e5892d7139f3056ca535afa943dc7b2a6aec5d15af46cc57ad40671ee94da2f775953373b6d181d7f92d1dd6c8efaca3777e8bccabab28e673e6d887d197395b0daa963b886557d636737b536aedb071b6cb920bd98658bfc583ee1614ccb14044e486b5265db29761d165d7201c58805fe5000cdca6cb7bbdd768f11f4928ee0d84b8356789b522359bf8940309510d6be87094dbf7ebb0543c4b75345035d1a80c9f3cf57cc85f27892817c76db18f6e46ec09481394c4f220cd7ff9ca6c6a9a9c87429bede2fe01b85f86a754869f53c1916e67a26d2d435de072da3e51fde0bebd3c68c11d5a951be94214262c2781ec0d02f9fe6a36eb12015888b238810023cba6952bf9055e35873c56fa1816ae84d83a89e7b412a4d855495e1a9201216a0b8aff0de616be844a60cd00d84d004729795d623d4f3ca2e60215159ec8199d36626f625834b419ec21e1f3844025302d7da7f635c06aaa6217757ab9903c4b487321baffe28786ce0d1ac63eecb52f2ead6b65d894423c297427007f5c1b8c84934165ad33f45de73a69f26b983dab89f69b49c322b4bfed99d8b8d6d4312037f6831840903440fffa5070ea8f8b3e082063fd418ce348d142ba8006923ae6146c704d6cdfb56d3969c07bbbb5480dd8f23977d07019c128c3954d2b60d68d750e3e5a7cc8a012c57538e668eb7b02e655ff4da9d07117125b1f8df2f9bb4c6b165076505e6e3277192207cd72c9cc03f2c2ce6e49f57a494cb70e8c3f96f2b8f1356d17d5e36c0cfbc652f03c6a51f84ac8640cee2d03f456b3c7c908ed159aa11d2a764ab05ab89d43d1ec76e3c5250efe0d67fb27add7305fd74f34f42a30827953f60aa610864ff6f3b40f1d09ac639db08f07b3bf1f49257dc221ac7f183992319c07c12ea89fc90b30139d2771a65b61520254edc03d2542d374510ecf98255eb8f9e9f7c6d1ade2e5f9fe7043d040e1730b295a24b34f4884f3739aaa51d7525c0849fa35a85ce6bd5032c3cb32d67aa13900366cebdb6bb0be35a4bce2a693ef74cee8e7b43aa489ac52ac564040c2f33df6dfe643a1f124d49f539478d26a2f333221d26bd34787769ccb06ba9c62d5f4ea20fd713a460a92ce182290d483d71350fcdba14cd4b3c338a005c52a67118074f154a7497da2e40af15c8ed920c5521c24303949fe2d902ba74294c47ae39beb9db57fa7f620e1963969a6339b448c67c3330cb673340ecc26da8973bc469912a830aa302d016f6505953f76852014dee9634c103afb701c41981da16b54f09b4683ef26baff489020c01a29fb52baad203a6f11d798e9b3ccac790a82f3e3cb83207f3bfa576256a346ce754717f2e04522c796a1277dc6957604766e487970695c5b951f285a931c8c89a8cdd60951490913e5a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
