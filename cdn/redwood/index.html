<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c08a6a08dd450ff12938110e5dbae0f2d1f212bb7268137e7b52d0352ec59c897bafdff9fe997fb63348fa745eb182d574e33a6649b8245f151f8d47d0a070cb05c46b5d7c4bbf19970e489df87b464f90dd12e9bcf284ced9e2f037c1c5c974f46602e9585d8b25074d109919da0dc4ac5e82937c9e5ccb3b1f29202b7d374834bad1a5613ffafd528635a50216ab1441fba65a36983af509f7bfc920b46b73870862170b7bc1bba6d2b98d3fd4b71adff5619de9a333c7a90ca1de876bc98b5ae2de395fcbb994b948c635f62defcbaadb7f26f751a7b2f9a7c827e84731eee08573e155f9c30a1bc6ecb689623af0326988db65f56cbc679dc3b63b968b6b88340453d6b693a10faafe26485d24aaaeca19f29fc831a44a9e3d27846e720ab26136f587595c905dc1bb2d2dde2c5765e849cfcbc4e37c7f6c3b947cabce1c47d5670d40f8e8d8eadae3e8a0364eeccce917eb0c5f0c007405c7ae1f1f47d5ae7aa5f77c30bb5fffcfc9e929c57b7718653ead58e02c9c4671d3f08ae49a8500bdafe2c725a2f72d9565a07cbcf0e394e84f56aad8e2dc4f8c5aa2256e4dcffb4c58d1b77414ab0b0d1eb690bd0fbf5be0787c9069ecfaea3a1c8e5fd7e77700fc49a97be7d4ae21ffcd622e3b8d27b8b36f5d357026e689d841d9fcb3e516fcdc7252fc46eccc9f7edb5f2afd74a9d5fbb958eea7ac8914dcc1c68212a95e9e9a1aa0215ba236740541aaac9bad484561e45bb4ffefab425cd0834df4c807635b48a38b8780833620e4f74b6b5caa767950ef3ce49d2321067516df2457596ef0fb504532e6aec4374fb6368bd2e37f81c318ae5a68b00c392b2b570aeab469ef637108e72a996079d80ce30f99d4db80e8733da0ef123ae570ed31fb55eca71dcc76285f064b605f8610566bd2e366381e73f7c51002eb4017fbe24aab0cbfc1e73588fe2d686eb0ea46fe4e1f427ea03cb5851e1b40e1cf395d693622aeab9582f4c200f966ba645ae46ac36ab868aebaef47225b32ade9ce051905db01c0bfae205b860adfd119a2d40c115bcb877426575192ad6afe358dbd3eb66a3593cf94aa56969af704e2b19fcbe224598ec4db492fe2d43a3401071adeb905b7b391e334095dfd975f598e7590890efbbc54b215bfeca9222a026e89bd3b061c45eea97dcffd5c8c25531118e94c6a94e37649d7715d06c1517df720718f823d7efb5a4ddbe4c6c211b38429e3525e1e041e7e560746fbbaabeb3240a480ee49c4b4bead28f13df4a38e5fb70fca44a91b66bad982884abbb993217b98305d5a2fd1fb0db21dd392e0f6607e443f5e48b37b589dd9dacc961c09fc4e1be1eaa22925c13b5456a5822739d01f8df6c43c37107fa8b7a6b60c6db124608c07e1519c606380086a613256db335e3ece9401e14325ec3162e06f03f0f9d53c72e2f0b7b74ed424bc8fc54219e0d961b0a4197449eaf0b975b289703dae4f591fe1022a5a1e1bda00c6ddae0db2c3c36928c742f2ac309e0487ebff851e62dcaf89d759082a572f3f91fa37ea3f6024741dcd768f9019ee9e4f0de480522c7ffca1f81e541a1d6ce4f8cbe4588f4d8be89c0ab75d9219141237f3bbef6b431f3e020ba54cea71869bb6fd422da27a30a592962f901dae07ce9aadf04367eed05506e754ebb837dddcb170cf894004f02978979079894ff42aa5fecf5026f75b8f5942586c40dc35095ca91993e98e75d7adc26621271c65fb8d3bb0b2138b4ead39eeba0ad61fca68892d09c11804fb1b80d721fbf111c7c7184ff28ca379b76ac646b9b91ee6b080845a5f7631fb4786efba6776c83e3b7cf7ecd08783d45e9d92d595e5f0c7554f0b863166baf5396668a10f9a5fc1c64b13bdb2b953e514916954e5342de2a2ce5f6cec3a1455acecc2bdced4587d657ef91778924ff3ea892e0958e918cbe0dec2fc295a8bbe47ebe104ad737f5932b9369c7845900d75a9c8ee4380d61ca4798877e6e346ef801bbf5d5decfae87efe8d0b249f7b6c2c8b7f135a1098e6c93592598fbec51a121090ab836642087b50181872ebd7dc74deba48443adae9907f080c1d215215f6061595a2392a4f654113b34018fb5c464a0402851bf0474b025c385e21e82f26a53961c4c5189f66e35272c3d8ee3879d262c63bda54cbccdd9823a412c51df9f0d1c7409355f82fec4feccf9bab174cb741cf7d111c569070c7790728317af3c667db19d896ea3e2c531a60d83d6aa94455865898484ebb5a3d716e4046f6aafab674cb872d04555e3241e68d54420b94ef73f55018d4262c3fa431dda2c5ce91f47b978fe7fe5e75db946d4887b2604806c16d9b1882d6441875a51b573a9785caaec39db99a51001f470c557a76459056a2684a9cd50c63e1e89708dbe6002856c944126875e3787d4eb035d75d23462929893b6b7cac4b934f1d9a5167eca46d1b13f5379a2925115d6456139e6fa5cc17e4321287e581d6ccd947039fcea9b0e81d3055adadabf3295b728bb931efd3a43e20eabef08a0519f53e72ebd43aaeddc786be9e805f7797375a7d30f0df8a3addc2677862a05f29681bf154e4e53025a8cf6f23c2f347fdbbae67cfe0b6b5df9c4375c70fb771d2047d5d17a44bc8a2cae43baf0a19ca1ef60d16c18e6e9600ba337191f2e70db7d6195ded21690cde58b82665f17ea06039125e511f50743ac226a7bc464a32525b6fae24528798d569bda03d844c33a46cca92e7245f47c0822035ab81c259dba8e4cd1988267c0898e3e6a6d245ee68719be974afc1c17c3c6337f0a43b659766e90bcd6c5cf97a08fff7bfdecfb378f1fe741686f0e6168f015429bb55155db8b18d1fbbba65286d282fe908bbcd14b79e9ec39ae26218a637a11e303afba811d1c57980377fc527835affc935d9c606614e525da39ae386d5628fc74c53500c2d25ad300967db992bd4551f1b778411725c86c83705f1bb523c764b45364c259cc6066c7b7c53508a15d6df6779820e5873ef62f031c79759ec858d49df13234fe9ed1e8fe0286d71a969f4bcf118e9757d29751cecd65afdbc64768b0cecdb530cb8af573375a09fcf37852ad431e51f10d92f072b25630721ecce0890866295066a9a07451af4ac7933ed750f0c1f3f0542360316bf71380ceef34ccafde421aebcf20bbaf51ae95f9fd41a233fad1bf5ecc553ee2f98ee30151d692403b3df8346745f9e5e9034ac58abebffb8a94146fd00e8ca2588e36e9b57ec5d6a4ed2e95c23cfae23d3d8db645b32dca4fba97bb867e1cafc90c47109082b8a68e6bb7b63167f2c97cc5672264cc01dc561ccfaf6677e9bfefac0157f4684fe93c3ae580e2de2984dad530eaa24a3cb9fd1ef5a7b27bb018153a2a94d0879a3424c009831c4f30bd223e52bae2829c66f3f81543c68f638c6904b6a59c87f085024b32a2f26d7c15a754ce9459bf9dd2124088e753422a60f07230122eabdd51446d8350080221fdde2ac104dbb52c9e54730324cb269531dea99a7d91ad3ce307ad7be8b0785c3936586bbf293b0877e44cd5f7a00787c17d6c6c54928f89f4be5ebd4dd4d7f3f255c59655e82561d673b6597522ef63251a19a502be2770de9a3129802f3c69b5859836fc29397b8f3bf4b21550ea7db201aab62f19b291dee7b64e07c7710d5d69cff7f0501f94cc6fbac7786e0bfa0c4b6ef7f2086086ce4c643336bba514e96067df65960430e3f2050f4a67e2b02d6c92e70228179005887a56f3fbd88bd968f4eaa061373710c7df8cdb32f5cd2edf5c8c9c571401cf4ef66a33fd8a8f64423abcfdb614bbf7ef2d90ce09595b137119a73b5389ca2c8edff7979c065f685f9d063e8f039613f95374c1aeee1aed921f81f5bff77eb7b182360e74b12e61aeb07ac8591241ef86a2d65ba999d2d61c26a2ecc847cfd4e9fdddbc32aef31f144d56d8191d87060bd3cd990d2a5af1a2983bd6182122f28859eb407859c1952079a56e84f8b9972826ae10f8277723dfa50c020754a8dd70a82d26c9e4f4e9ecdc5d9451c86dc52f4bdafd133a265ad0d8e599398b7d4b592aeff04638f5c05b13ee0b52ca4315df134f6d8e496a5f0ce7d2a381de07dcaf656dcc41b2687030ec2a44786ad6d6c1e1b5680c70d613fa7a95cfd0eb105e6656423e9dda47f8558f2e1156c80dfe4cd7e9cb068bc94788102ac6d3a582b7729e2133533ba84a8fa81be3870e3da44ba6091e74a2f147f06974f9d20d8c117d9fb467662c93e710b7f247910b5f05cd09149499f089e39061584887deb68b8c6894fcba683ccbba7ae7c00ae8a6518d54514fd5b3f536034aeb2857f0496c3e07e6118ab183c2eea82ca8b425edadb7bfcd065c02a4621a3d190b9694b0d07bccd023c20d80e8ba5f563a5928b892bce9c0136438a10a1d582f2abd103b175d3308dca4a4d6c0e34e7331c6e0cb40a549ab6f0486c2b46852894c26e1c95e3054f8e22a9b9ae3485a79acc4d8b6f47d10419cc866fce669b174181675f234c64b97c61225a3d68581b2322c2723c450051c5a5f82acef5cc5aa6d3171d1ee3c4b368ab320e74f862acb8e9aa1af7e83fd19eff717399a17b92148fc8985c06fbd9647fca826610ced8449aa7e289b55acc4a08ff8c5d268f17e931e63701c4ee2992cb09eeaf12059d723c8d8f98098915546fb3bc8c7294723be1da33f42241d442d0628fe5f5086dd4591ca399b17064527be7a0e7d618cdd7381ae2f334f5815d919a48d0fa205d4b06f244fd1905ee38f037173657b4d3e8a70adc7b2fd54bc27f85db978e7c449234591a4b363b3199d62310271fb387620ed12ed714c5d34af76bd75de33f35b258e3efcc5561d40a8f2fb5043d67ac2d8b52bb5d4edd5e0f085252a4cebf1eab8c7130a08fbca966722a3b6c8d373b7efac8be06fb8763345943b1a7149155e03e014820b2c1c0a950710a9108b33354b7c2d3b9f0dfabd347f6ac6acc10fd80821af745fa999a86507261dce2da86b72e55fde1ec71fbc90a8a5afcbeb30ae5ca29191e8d6221533cae1bd607b7865a4baf93a3e7f21a42c1155035c3a5725f5cd8532bbf000f910044337e445becd2f8f4d16ec5404f3337fcf15e6c6c617c33d828f5e1232a8e61ace74b6c83d0ef68e095b839f96025df2a5b5e1f14d4a2fe7a3dea7c40b4840ea90c0acd6a1846992fa57a2bbc599607f146666a37751437ea24e4161931e3394401e9247ff9f00e30a9de9d2c0ca9185abc293173b9f4997b4655df9024e9c6d5dc9afc4866b72f1d190bfcad7b1994d26e1be7d98fa6b3f09a0547a98cb9ddf49b626ca66c86dd20cd2876b90f7765f01fa17b9f9d9c5b6b47f4513d0f5e4dccb57aafe41070459ea4904c2b4201e7eea5d9a8321312f5d317166659e69ce59fb131309b7422050654e0fd84b226563a6f4c32b149f240e0211b494fecf10e93361ae7e5958b7c6f0b6b4c00dffe9b17675b5fbfb74e20f30785ea0c74f5e2e5ec1465f011112c1936d4bd8cb9e9721c64d4938a145deb07485c35199616b18a18f7d16921c428f610d8a6e3af7ab7af6e1681d2ccb8f57416e0f63c3bd0166431ff54af71a78c2f9e492a08c88d89051c828399adb7a5e9348b4cccee868e2ce5d6f2497e885121a1c92ed124f53fdd92f226d663f0a0d3910a204b8f3d4322df9db931453d3a41b7f1bf7fe752bf39b042d43c56cb8d05266fe3fc5ea2159e91ed6daccd19b462b871c848531c708a94c253a310512e5a0d0090750470acfdaa46b84dfdf4835f0ea41f8ce4129438fa4297b764b503f03ee198fbc9bce4d9b1f16c0cba8b8f27738de5eb45287e79ab552b86ea689a4d1d55f742b4caa245bae0168eb71fbe2ae46a19465bfa1d79d34bc7c12473c5e8f3990edf9c3866a3e71f0fef1d66c8c42f2aa4faf9879530d5d9fbd29f734929192c9a6622a120f3539955e71855612b5063bb4ce6e3625315515cb1a972ad8264b0baae0cc75666492dd442d1f56674321b95d0d575cd3c0b24dc217cbdf9d42fbef88ca097655b2a0b516546c043be5e12f4797efae6a7b97f34cad462711f3eb6af1ce319b116cda166357ac49d85121f1df3cd5eb21b753cd8eddd5136070f5225d512af6ffd00c72b2d1408cfcbcb8d9b0af9336d9d84511680a21cd75587f7a7bf5c59b60c1f1fa83fa2d61760ccd43d83575a40679e267746f10c2708fe6acdd1a3f6ec863b81bf51d64c91325e7d6b6ed612b03a9d39469f6a948b41284c1c85b74b09911342b158de5f7e43a30b1ac5eb9fa303a7b89920fbc6ba6bd7fee46c96a59776a6ec61e6e124a5094ff6f0961c0c4d46d3fc3b67fc95ac9b8d11029e8d82fcb2e230082267aa74e430dc66551fa4204bf54f8e957ae1b41d39df22ddffd3bc09de8b275c811de3a4cbe5e6f005698b5a0bc6056aa3681f8d3cd9550bc5332f75914c9cc1291cfddfa148273d43654f381a1a51894acfd092d72dcf7f41c7fa063ade5506b98379bfeb3117bb4a1615e219ea14e11db3613a529fbd9fdccbcec4213db0d9aecfb2cb4cce7bc8348f7ef2a8525b1bbc35fb9a26844a2b479c17444ac477f355485900618bf6d0d694d137195231405850d9d003a462c6504b4fa5420f2eb7d15816c14016911675cceff65307f445d0c3b1e60a681199423f0b947e620081ed1429b8d1b19168e6d076f108c3c91a7db5c2b1074e41225851bddc50bf6feb5c1688c0359c85ea065068d9be234b0eed93f83e785ea77a9a56ff8f59d655b5cdd4a960e3fa66847cd1a44b329cb5289e204600e2439981b50e8bed4473184007f78ce1ef91fa4f65419e3de2437d1812f01e3d6b9afdfc96e162df89890c3631830ca0a1f34bf92f6df4a1d978f6a61ef1dd0462d0bad4cf1abfc81f1f365484bdc6252e93cb79793c1397bf964d5b34afb3fb84faa65677257dd2141485d30c9f123bada89b6b64187e47bad1538345060af1d9390eb7f094e0720d861fa88ab549b90ebc865aa92825726eac9425220d674c8914c7aa1b698b171d44f52e14917080d1cbd57631fc75dadab4aaf7b85035622e0b8650c92995915f11c54edc83a84cba6c5551226f537ca801a27dc164cfbf3c28060c63a7426f69af227b0d3b2f44ab23a721ee40628f9d38bc8df721935cc742fcc2f7cd2cf9b9d9a49f37334a55920deaa5ffebe5bfcb0daaaed8624416ae9683d055c76813849259f849c1fd2dd5db2ffb4d7937e9a41c0e9e7ab597535c5c04110ef6b47da75e0585ca634d1f6bc2a5acf8f649506eb8b0f4e9bf56fe7263a5711563f9b597128514a0067923edc46f93c54104bb091f048d3599246781b0af6182b6f9b7450c2156df7cb40973411837bbf2c87726ad595a1bf5fa9b69272120be26863eddc353afb55db75e4c387ca9bdcefff11e4b430dd1b4e4da074d3817ee63e6dac6600c55af9b32bd6abfde2bc6a5b1401f2febebe7d0bd1c7bab23967a77559555fbf50b79f3e6f537ed4c8fc351ce356cda35f3b77dc10eb12091a5e9e824e9f5a5144c7cedd4aed0b4299aaa455732dd084216965027f100ce87b4d891b03603262f9d33a2469e3794d4c24fae6b47b7bdbd7960f0a16e692823aff97c9bc97d7c193b15246434d2d7ca19823b9cf0731a4d43e8092c1c07886c6701dab8dcea2603ab335f334c98a530dc6e164553652a6dfdfc58713e8cd01affa06d084df3eab486816bee27c9c4816639db1f365783e0e3c83be45756660b4d266546a343822845447bea9b736c244b3ad612faae53e13f50e110524c7e2687e5c2c10530ce9fe67726e4d5751b9367f02de752141e1a7f54cf52c6989c820f2e1f93786548c1f0a8862bfd1f11286f45802f8b1f545f96ec903ea3570cb980b5640407bb3ba21e84916e0a4683afeb32ba699721f3f9d5b6d323aceb169bef4debc0248185524abf8a0662ab6bc03036dee0a8ab11f94d7c6397fd27ab5a75364acbf823e4ea7d1716d673c0fbdf65ad8ffb18f4cb5d4259fe6a3227344f452f62711b97568629c019dc4dd6e2e8e2f92eb8ce76dae025451e38aeac4d4470845262fcef8c1bd84b184b92e8e0b30699454b707a51e4109e7fa80d3c4cc7127ad629cd67cf0493f1e78c25eb7db2a8af629b4f4a016ca3d997db0766b89f2880ea3bf509ce20afbf683f75a5c64bfd79f21636937c92704eb23695ae3606a94fdf2f2d68884903a913ddcca9a66f53cb1700d1c5c2ab9fc08789c4a43bd68a4520b643cbd78c68b0b72d44527c5aba541cd34b504ab1fd8048d2f74073fc4d6c4b9a497bd9a8ddebe43b0054374c15f6e69a3487713beb9d24a8d7d5c1c30da0a16a0db96da8ef6bbbb212cf67452f877d4872c989c8ebd25dfa531b23c3d43c76df6bb77601fcdc90df52d982ca9a023f03a060401fc31f8a4180733a68df658d4be77df26abafc3b9dc2dee6bbec358da4c2ba3ddadf594105398582553ae60fa906a2684eae6d7b068dd3ee01481bfb2a68dddefc88ae008eea531db9b5025ff0f87ecb05118853ac3f1699f5db43da34fa9fdc8a791eabd2ba0e57102998587c91296d32704d359c85daf0a24932c730364851bc8d59a5ae23214a7ed3a25a68bce44338f54158a7b389431d227ee0eb282865c23b5c28277ee10463af8f12e0e6eabede4cb7515445c3f435f901fbfc7a3af6bf84ef508eeb67f6a7d85e6b867dd73a5fe3da731877805856dc82d75047d21f9a98f4f461549bf56b2566c8271df8b083a90ab07f2898ea370d592e49d256e71d7e134bc0c9576a8a26a93b2b39de5330943e9f7f40df7e1357903594e1f96c0eef6c0ba19b665a4eee2ddbfe95af7d24efc32c01cc98fa7daa0417182a4080719c48f3bd03f244c75fb84e29cf3fa3e320a684f2ef6a786cd6355887e86b864c925043d18ce30f67cd0c8b3da58d9e18e6f2ab8c257bede94eb1941d6ef45d40244d7b3dbbf0a84ef0c5bd35edf3d7ea624b06ade12ec56454e97f899f0e52dfbb198ef1fc4e7c4cbec83edf06478e6189cf177406134f1457ba79875a8ece023b916bffd08acaf4cdd9409fe915a670a54f4628e1685d92d7a21d9e24ebf5748a818716cdba1de8fb24fa4dca92287433bf30aaada09c40143d21b70acce50a8881372d48d379c6bb86a3899bdc53eb4c3f9eda1be6e4e96d151c46ae29f689466db050ac589f12ff4239d7318e70345ef5db7dc1bd2cf1ad78effefc2c787d6c43c9b69e6858b8b04c4213f4205fdd425f3aec6252ce57e090533b2659624df5ceab65438d639de02b5cf14554dfb2c684633167c085fb9227a1329b98f94bc33e35696112685d7f4fd3e7c528d76fdd229a87ef444485c2ca7a61d0818ef9f5d488470873d32d37b8a1775f6878621d8071381f130ca1c441fda403e2c4e8da6619d8bf27bfef9dfd4988100fecaba3dbf3a88abb6a6b7db5c01990c6a80d75b2992ae573a3ff511d01bfca8052b280b73fa68b13b7eee900f6d3fa74770a552d575c327b1b2e1b7e7f332e96940e69be298f0d3772682060de28741ed9d4ae72443143ccb2701fe987d97746a4a05cd50031c40babea315dfbf827bee85f52e0ecab552c7f80a864eae57e39045a76874e0156de1ccd90db2a0ddcb6c4c08bca754ca3b7c3261af7dcb4bd19ff86d9f98c307650ec1bf596858fa23b4912bd37bdab2e783dbb62e10563b5a8c4c5e48568c67e41c814001d594696f1f649acb53df3c88c16bb76334ad2bbe161b8a967d623da4b121f48c3eafaebc83f05724ea18d53abecbb27e4c86712e0f29a3bc659e0023cf9c5336317ff7709ce4395a7804be62731fa67607f6b138ec8f4e250410f0758a0cabeb078ed4231b4ca8ec2a117e93872f7cde267d01f09ff89b1743365fe70cc8cbb957cb85122193e96b9768b6c7574a23b92edbe298db27bf0c320c5cee7abebc91f947dcbc27d8af51424d2ae7b8c69b80f8d84a70c47a5da736bd9fc097a629d2c21532f4bc1b660ac631cc3fc6975062e603d33f7b22ac4be5837ad4fbc7736a8a3386fe48b38fcea385d45487a00d311d7402cf88ed4276931025b04c5e5615e4f4d4afe37ca8418a3326a73eb122b52b7f044911105d6c6062adaaf19125b67b577c8d157269d32d77cb0d168de4bf6ed425b406a7e66da8bd361e09061b8319234964356334c6cfc0bc4ef85043c40f8b186646d953ea67506ee822d07ce7711727e9e42aa5df9842004942648a667b5f8d42d3fb9aaef58c6a3dcb5650cb3ac13e59af09c3d56d7ed6e9e173930ea46bc1795123a01f19c07bd1a3f23691d0fa15fe8eaa8647b9dd1b066b09961170dd14e6bea2481a1724de37a5e79b5299f4aa4ef7598598d06cebb979a18e7389a6219ca5ce105a363c20fb3c5124d927946b9519f9b2ae1a18325a27650ed46e2a0aab96a8102eb8a2eff98f8c6d06c2202112d41d398cc0d386ee88549a95e537271f30e9bdaf38749527759599f562e6340965d9271d49047e91e586b7608b5bd58300ca888da782749415fa3d747c6bc2d0006c4d1d0e050494a78405b72175f5424e1ae4da141cc968e6fdf1a0df6d44fcba994206ebba165892f21eed30119680af6c79b206a19b773b590060d392e629632cd3e73d93bda9ba939a3c7b9d923dc816b23a9fda1b8d0c59894d0479a73e1e7c4f0cf69a543b80429a56d42a05e23a9e2b4c54039f569029001ea50b1ddeb28e4547014212442a9c68d4e4103ba9561e333b5311547bdc906502325bd35a262585b99d401bca8691b263a759decc9d91f91018ea21c742e092d26a45eb913d00fc2a4925b83405e6b7f71c846de51f49cff50e299d3e623735938c80c2a9939eb7a399a65f2de993708343f79b7f6aa6a518b510f2cd3119b2f24de217e5c2fbdbceeb0620887dfa95dcaacf405f1db36b4363b7b448e8f232be0f8190d4891f6a5c712fa9049a1bf7e43a886fde5fb46fed7ca8a5c2530d22357a26e96941dda743df8d568625c12c4c77a540d0f2ef3f5601d74574feb455ff13bd5ecd0e04b21a61bc8a49ee893023c8c41f3fa5c8e693a2293fb6b220587638820e7911c9c1c5f1c9a165abe051f17a36c7b28208921db566a2c916ce3ed5a6938c705e1bbca0a7e2eee5340df2761260e947aeb924205e4362b0cc65d6e7741823b44cdb188d2c262de56564be5b9be215a644a2ba88a6e0b9cd74273305b8634d0a9380e4570d66728cb75a4b0dbd8871031bbf4c0a70790de94d674fb2182b6a2d5add611395b7d4248d94c23e3e9d0d53c01de9231c3807176add289b48b4642bccea70d66dd4dbc233ef05c9efc095cf0e5e7ad73f7273b51f1cf09c229566c9041119faa58e2878b6c1019aad4a14e1a817b41f32e9aa36bfc7420c27d4c033a966ad2c90dd07b10fae5717739f7ada0efea07ace88a8c40c62ca12a8a1e4e24c4673c23377ef65e6983065d3d9ea4dfa9835fa7833cd3003a5151cee2a659e9fe828563e83cb5d3fae47da7e1bda65314c6d86c8386bf80aa8a4e23a711d1b302ff40651adcd7cf6a10ed6152f595ec7bc205dbfa5f9d7991f9c6c7d4030937d75223b056c8aa53861860348943f21b79d6fa0fd596719e237134fcbb0086f3839f5a6054d841eb1cb282bc8b4f27ea72942f107b49e3f2a640b87b310fc8be694db095603f319237b7bed60944fc1d5e6fa7b2bad5c29d84e91e0b250349e5843b9a9abbe251d8615fe3fe59e8797dc87bef5e9f06a42f8ce248a117c87175549c03bf262a1acae57c3cb31b9d78d4a1306003bdaf4178c0b80ce741408d81a63bf00bf8b6b296cf4d94e03433c9c7fb6b860b11f0df836003e92d6cd5ad2b2204e6c1a3a922570bcb7d1e1526e9f072562d9ddf58b8197482fe584cd521daacdb589660773df0a64ea8fdda7b81eb3d18de8fddbefb074309a1142379387b45de4d765598efa3ad3c001158afa4709bbc17b9dfac1a8701376c5149b2b9d3783cf91db43994806e87cbf34d50bcc8fdfc006fce12755b8c6f8e687a41fb31f2979d5820c4b46d63857c73c226ee84448c84eec592c42f7c5d305d3de39e48add9979991089380d0fd960ab4dbd84b82fc9ad224feeecc27a6cdb73d7c5f807b3ac0933be43958a52698f1fb654237a6d23f3b6c36ab4b346b3abe8d7caef6838cd5dd0a63cff2cb608b007357ae3f971a81e084e4ff94e7c563a67711642366a5863856df8a10c79756fbfd91b13e3462fe235fec4fb0d90e705614dc74ed66d3e5f735d2b68390801684e774a43447f59feb9662f4b6fa4e34653a9d7a8479be682819c346ba975e61181a740f3e22be25f4f128ef0213da6d832b59c11c1861a0e827cffbe650f88d3ddb6796e3d3fe5d98b008ee87aad9040206e189e56b9c6f38587c845b97d9ee771225e213363b117ae582d457afcaab54290e5915ff220c1bf4407c7aadbbd103bba67c335346df7e80024eb30da5e21fb1f5e5dd6e45fb06638c534de3f26c0600161ff4179f6b16beeaca368d8c083fe75bda7dc6c0873342f0116a88335f6b0ec690b7065a1996202681359666958c9411cd7d2965c738706e2add2baedb99eb743329aa27ff0916b15eb67a6e7ab83b8e7439658feccb565b27bb7550f6506162929fa90f9d2b973aad696981e696ecf6aae61622a1ac79c939748fa9609cb8f001484f011eb0e88e880101c1c51099084b39487d4dae87af644debb8b237ddee01e65b241c797f7eb620a048e8616f89d053979c6b6ae6a6056069667c1487348bb0978b8d6c9d00769a278667eb7fdcb6745e4c01a50de850c5d0c12636df0bceff701ea5a3481e15e20a6d7f2cabc0964a4d5a17c80e95fc507b4f9c751d05fc18ef7ab27962e9c352ecde7ca54e481850dcc07ce38f88a6e73ad6697d0fde6751269bd43e6510dd60033636fc40ff88236e1519f6bd8ba53fadf36a46d7577524c0588a770334f10e6d993f2183d1203371eb5b8943c6993c4d4c916e8580677b622ba32c067c4155198e175106dd534eca017b533279a51afd12e38e4004ae97914917e7b75e5ca7a50fe7a80e295d1c16939d5a7d68a04ed4276149217d78004ad9f568ef79cf2227e90c5f752e718eb000f70adad01ee1edd4f3215ea03ae50803f2ce5abf77cf1991e2009470f08622fdc9f2385bc092941dfb1be4cbdaf31a3b5aa8f7d3eae66e0b9e7f95ec55477d7d7d61ddcbb84373da8165b3cab7f097f1ba6970583bf8aa2e22bea80a7e5dbe24fb279960012381e1bffb2a0c80ca367952fd300d33a3ca08ef0ef56e37d79858ee835bf6206b7130baa8f1f3e690cad589c19849f69d8f8bb1dcd72c5b2cbd25ebd8fc4334b7f604176899c0df184ad5def47daa4f3c14522be84fc2d3547bd6f582566e40f6ee6ec0f922f788c4b04b495e10ca13f6c580ca1214c6cd5301f367a8ef2a6df54b9afc4f58619fd55b02528386a90dd2a0aaa41997d0fc521313c2d3ec235768451fae2b6f1e52c3a226a8133ef4c2b7bcf9ea44f0739d6027d851690f0d1448ddd7de99b2fabe84c03ae139e641aac0af2f484a0170af6e19ea621679742d9ed9fd3af2995886b005b9fbc721053f4f0a5221582606d1bd0486b9b031412fe26d556e4181b5664ef728d780082e5eed12fc33c8739afe3ff9b5a4d8f5a1f51c41b750668c17903eb4bd1d82e2a6998a3855fe2a18d0e47a73421fe1f8701b13a06a8a9fb823b50a8413d6da2a7bc0c363f747cbb1630690a73a1414eb21a52125c6575d26f134b1dff2f126dcf00dcd42973fd31c66499d431bcb22d9d04058a65a781f1b831d591e9c0f6e8e75ce7ab52242fbdf3e3a261c9ab0dd6028887b72146b86da7f074cb95991a8b4189aa09519fe87152a1159cd7e2bd514b00aecaf4507c65f8c63168fd586e00e47fd3de094755ba874b8235f46c26cab72bd0dd785cbf63281325eb1a71f897a196f584509cb3c2cf555c6ada2b3d61f2e49aa56bd2c06d64fb949c6f380aa8f74c254ca06b5b79e2d2e032844efb27a555f44b5fedc9a3dcd73ef9f68951ddfbac02de3485c63e91637ea979aa593eb04c045875b83992251fe3bb2a26a111e252ccb504e202ab86efe8252ed21aef13928ee37d3bb50c70b36c97026e3eba0d310d0c92a53631b4c3e82ccac6d37c2ecd5221008fab91ab1c7e57e408efc1f6e4643c9a51cd9f2d4223c5fe9b19c1db5f21c3c40f207acd79592499db4c8d3aeb47c4e632d0db83adc1863b39f33e85644ba48e07c1d00371f98cd81c2f44168b10319858cb7775573dac04867a2210073173a59c2e13a5a64841b5612c2aee5f478aadeaf6242690ed7d069468385a4e71a46c0b8d7ccc92b1274524ab6f55fed40d88eb0e197e46bd6318b29bea69ff3a0f116ed1bab8cdae498604e39768a6c20cb42fb9daa978f94e9e1bd61c26abb73c59252aa491f84f98444a606161a9684a073c3f77ea48156c899283a01407fc29b534a08fef61cbaa8284ff3eff1408c4130aff7827b0bfd5716189d069dc2da1473db154b1edcc28d1fd034962f906f9101eaa8c2900d1a2b0222669505af441bc11c7380ff5e0da27158cb80e4cff08699fca90bde449ee57e7a1d02a65c008036cda755280cdb75fd58f8fba5086817b74099b3c11067a17b5cc3413bc60d13fca8c4748882e0c9941d25d47946a743a76b6d58c2274506ae6dc1b4b4b4d8fb48e1a63f1090bbf3a29b2629e79b5db621d7df54c6d3f7527c653ee7d80673675a8f758547817250a76b9178d7b2b395cbb0626dd8f248802b01370da3cff43e4f843b13c23409de09c2440f72d06293e2568ab8306d1ef97397bd3f3a841fedd434965806e5f6e3f0b8c439cff158f0f8010784ab2412df2a3f79e5c9e7417d1aaee8201f1458fe132835a27c51696ee1b01855fcbf5c8c0460e9b66e569dc7a8c9927deed5508062c9c8a338956ee1bdc67b70fb7621a2abf364837c78bb8e08741f80ae5de85e66089cc11425a7f599f825e0026d2937edaae691001f76a0d2fa5a647afe36f301d97499af08bec518c027f376bc2825e54259dcd130d7278e3ea53f9edafb7c1d54f84f632ddfb6ff626ed77b7930fbf6d57d5d140df3a80685e2e8ef4ec9d5200398c179b3116c87a371f3f16d55493790303a3c8097f05551a3a71089d15e250e182572a09e25f5aa0d8f662b13cbb9a21780a37cc2ecc02d0a154d63c8e073f6c3dc4cd040936749451d8e51d881497590c3aa6e059a9dca6acf5dafb539dd5600e0d990df03fc42d23382591b65a8d705c5385d144bcf3965c5078d58e03077426b946e65c2398da7072be48ace55f8b712ca4ad3effbdf03ebda4cbc8d3f1fddc27b495da31cbaa644f3ebee7f1fdd2bc04ecb14eebf7a456e8fdce54104752e5f9894419be2a105adaee7a7f13061e461275f27e2207141d77a1c544856616caa0fe72ab408f778d3e8b5e60a38dfde7a8f3b362f8d62dd0872dfa9b9d5ee01ed2b401d08cc643e5784d97c38ebad479392742b6f9d3daa8498b82075ed205c59fa83b208c62e23d106f08ca9d404addf6160bfdbbee176c27b82780985c6c50c58b3d9ac39bdd36be532993c08bc2576c8eea783b0a277f12f9867b067cce0999a1e983c8bc098a408c1b3130747a58ad91130ffad9d276ac3c711037160812eaf600e516e3b18640bf4fb1973210da3cb2d26d15c6d24aa23db090c65937bc4309ad7e67f3c2ebf21dc484af5b0c23522469af04b4f186c6a5ccab63aa1c322f38b33672d035637dfccd81ed2f8d894de424ade93a1bb9eddcc6964f89645d88faf71cddc91cde15eb8f0a511c1be8763fc3aee3266462cf506b025d1b0c13a04b49b979a6f08614c5c0749a4b2f698341d7dab177acf5d5230bd586c925517bbaee659b98d118b7ac116b8ede17433f759f7c8fd260bf96e8fb964fb10bbf8911082a9024fd19fae9870909f7b27e3b9566be9a4a19129d1353d83879b42ecb41155e5df045f869dfd9c87b094455a846e8cae765c858fe0c6ed3f472b2039ed52b709f86e621c40595c1c89edf7285984a9175f0e6fb5605c99d15301f279d08f60f306a1361ec79cdbb607a2b2e34535ae346776be22e2a23c27d4e14a8a747c753f0078208a1079f1b4182251d0a20b7d46f895491e0d5299d689f5b6f69d3e4a1a2b058ade8b07b2cfa3050f95cd26fc313e6e410cfc233152acc545d029d4715358e6e248aaaf44691277d4d1c76be6c5488348e8a4218369029301699d6f9d8723eb584ddfb172f7d8e094234a82584dbd50e99db8146fedb47adb3049131f744e836bc2f4d946e59a8a5581ae3cb372b4deacfe5ac3c8420787ea7b3ababcc0a49ac4339c9fb56be45e74af14abaa6240c9e7d726851b6a0d731a4501e1c5ae11a669f44d6484cfcd0509e71b8832f7a93fce042a5b3e13a695835d6cc645614b7de0b61ed545582a05f7f586cbbd29a1d49288b1b1e6bc93ae581a72a92c7baaf0a3905a88cd9b5b0ff94e2399b9fac19e834ef259e1070362c8c994a5c57c5bf0e89a29d35e48d377e71f5398f3b62c5887f64bad255891ae53c838572ed69e3ec944146b3f0ea92e38dd36fd3faf345ece93394d040928701d534545fbe03b7997088dcad90b6b36cc1cbc554d3425f476554757a5dd8233193839f5e55bd0e462790686857e92a3b7db2c6911763ade952e325836fec9dc688c331da3bc8d4f1ba8e04e50e969ba96ab0e19ce265080a7509eee8de59a110d6ec69f34b06ac3452ef908ed1cd133360a1a50ad35a24dbc37d0d04f0a06f5e5d5937442004f43c0d6229d62dd71ac29c868d39b47090495da25f8352d86ff266001e4ff84f04262d7d43f9f6109c169f45d8ed3399fd2a933beff9f8e547bc4fb1a15275699eb5b771517f754ea79bca8b5a0d99d2b37534f2f301595440f7b5c7f4cec387deb87f2262c0682504d91c44989e3ae0a99a6b849427848b47507fd1236fd136d475766898fd7c9e327ec81253ef92c26c582c83c4ba8be53f879805de4115a4bdf01788789c156737b3d03ff9cdbcabd6065e979ce39cf1def6b6d0fed35f8a81d7353f3e46c1afa719274d62115387ec59b7ae3eafbd09757f710172bd170d80a65eb6ca3a47f5c452fe7f77022e158ef98176a9d28aa8c4f06b2e4a3af51cffc6c921937c99fee56df1c39247badd76bd37671a6a7afc4fc898bf7795642502411294225e2362383b5db04b9019de71e414937c414325be8a4c297511c00457254635fc6d0925525ea2336570f9ec5521475f3d3775c8b0f1b4a0c547cf97f44835d6be61e2f81595439ed2f5fc9ac1100bdcd721ee86d7b2ffa70870f75a1edf4c04e6f7185049abe8e4e8a5bb2525d225845597014b8cdaaf9d22b1a937bff0b9c160b13dbfb5fb60505da1b96f63566eff49d326f6c6dd17eeef28829fba013e1dda5eae5a20db4c900e83269c90478bd46b68eb56b57898245ce56a56a577007f494deccdbdd58f7cae9055247f92373e101be5d77001e81ab1628a993f5a0a3129e79e77fe872d58e8eac837c204e3653d7d809b25e8f5bb8e24cfa0c7c4fcd7512275b45b6b03b64eadb1a258340c2dfd22c97d3b3ab3008428ace97889a7f2c544b928f21e13aa9f00ea29e54de3e299c8dbca428d76ff56278e5f7c2a0514d1e96f4fd521cd4eb6b1e42919ff9e10396cb846023d3998d2920be7a99b01e9c5e6ec113d81a43b35fc1c29994cf728a50c4006711d6f41d80ac09987ca1ca9481fb9395a8357b6f8a8b0389c3a3c39b5350f19507b25e9f34a81ee2eb0db59355acc60562c613141dcebb6de1ef2c9ef4b1b9f54a5b90fbdd79fbcede7bc55338477d5677d42b322c57277fab5c6d07d176111806d3bd0613d6349c12be1d88128a955906970d667e4c6aa5636c33415c8ace000e8bd76cc7f5c0f17c473644a274870a3e3bfe638c01afafd019cfdc1c6a941b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
