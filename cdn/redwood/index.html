<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84e67dccfde00aff216d9b67582024263c41a72ce516722e06426d53af8dfeef0fd371a3b1988535b797f5e0db839c1b0c4ebd921bd8c94ab3013ea1afe03f9ec9e8b78dd485895558dc295ce5a232cb8f52b9b0e8d3e7c012f4b5b154a2c473d9d0558378f2241fc955bc8b9695445f75b60f200344b9525702d1b1b52b8a8b521740652caf34ace56f56a65105816eefe0f5f2cc497bf0ff976264a476f853171f11f1484e2778b1d0b5c1324495e4a26735ee2b6185c6c97042b0000978ce0b381eab399b2749952f490ebfb58737c17737387f769db0e4c5b0ce4efe8070dbab5d22b6148d44038698087e187e310a6cf304be00acd9a53f0e0c3a4559365763f11b6319b02be1f9df9155fad661d9ec0e3b63a0b78d2fec360e97cb4cbc9e860fe63c6d35e976a5b3171c34d1114f4b57f6dd1b8122b61c14ffd57770190bbc95a0b3904438ecd3a491fc67b6230fc02d023050b49511c6f9c4d043af71cde86969398ebf5361ed879d760d1b0532d6c1fc9832d77683bee14f378339bcf4ec7c8f254132ff925a57111eb0e27a99547015ec244f79214548c3ee93ad06d648bcc82f64a259ba405d88adfe8ecab816679d91e9335a4e6776d78d4f6ba666ac9d3cd0a4abcf60eeaeb29b7e5b835259fe4ef620c4542eef8dc9bdd8ec7707baa6aaef83ed1363b6e0c7f4ef171a1979789152b7cd70c22d4ad454425c4bc2d685330632f38b023dcdf06d4c25806d549777295c16df2ff2c77dd7a98955942373938e2ea46b11732d8c6a08e3f5c31eb04184ff957f811c08535b518690573fce3cbc22d5c2c23fb9f644e42359ecec46a5057e4874479107b8b80974955d7567e4db3d6ca36775f9a40cb0191e7302785dbdb5faa773f0c9399d379f8a3c0137b8da67ae6e8a8b8973ac4bfde69baad28f88c68ad6e121ee3b256036854d7a492098939c2527bbb396fdde4882c5637cc0e9b7e2dc888ca98de62a8b8df9ed2aa5753c67bb0a394f48281597d0c93c5a44fefd64f569e57f6b7fa801de239fb653e55d48f8c474f49bfb41d5fec5cff0282e81f311491b2814a7d121a120f9b0b215d75da04d308d84e01f46db16db29bd5ce288e116fe3549089c6d842332f41b0ce4190dcea2cad30cc08eed3c7db67157d57816c9f30855ab8a749b627da83ce04f1b36288ab3835dd498bb7f5e3e84c6cdf1ebef81a2bd848d785feefcde2aa28bd3c6be1e7b061d681d301f527d671f4b8ebec8783290769e9657ba2681d605537cd4b4c4e28a02b90bfa48dad8151e319a46c1be3dbcecd3fe41d9ceb031880bbdb5859bab8662bf8adb6b27b3e06716b0e33c4a3b8829456fbcc42ff8b70ebc0de24ae33954e06622e6e4081175d1a2b6f5e5220d790cacfe26df2ab670424653895cb611d48cefbea9bbcc2ab002e8d6d9cf020581d2c57c3ffb035581e36b809296de87c03f3ea62d9907992fcfbe875d0144ba39c735ba2f43aea658bd1f6208334bc0388360ba344d895a65d7f150bf0c2f120c8ad6a23aaa5e7abf82895cd225ee575180ffe37523d76fb71dc62d53ee10071c776c71c696be368b80da40d16e9f59fdfd91f5d4bef56415f3f4943124f7d3efe32169f782c54cc09b6d876a0902bf0618554ab0f0472b2cd555a72500a3e10a723a957d7478018753a6b474a0fa99a0fb50e266f3fdc4aa8687f59793cea03ae01989922080a94ac5cd4f26c72d78bb1c13b9e1b352f743a10675cf4b58a07f0b7f29fe83f29754bbf885f29b304fd4e3dee0cd93006fbcce9ede7bf784fc233f1e5a11207ece39750f1191d4dd296847decd29829d6713754abc94a8f262d083cc7ae49a8e64bf2913b0a3e5618b2941e2a76d7674e6283afcbd4ee82bec864a7f8d627da803710ca9693bb6bdd0892eec08de144386c5999a4c070f0ed10b3c0793c482008409166929e6a152ae161d15975dbc9ec2956d0240392d2cefffb1508928bb3fd0da59833309acef7dff8bceafacc47650be0473726d6bfcccb17bc62d5563eadf89c0c3ed665b1fd0267e8b91ce3be91f1fc24dcd4a0a39a1f1e00409ea1e6ac9c832ba48c84fcdc66c39be00adc5beb951548d0ebc6a2978beded6b1ca4497b9dae7f6f4d6e60a1af0cdfcb5cc63d72afd34257fa5318b69e4edd03e9fa611ce31c211573938c21d216e2fa51b926f0893f0b6cd7fdbe501e74fe9b12407f15692d30c16eb7d8e09a18d6753c5b0eb90daea8210d3e746d2a533bc8fde4c2fd3bac3d134400fc44feafb807ac4a239a2011771d154019a9d5a8caf531da65a0ae9de5a4b3b6ef63e875960cecee6bf319311bafc05c457b80179b18bbd75d0cf813ea090e16d29492d68bfd8ebee78d2e5ca3551f6116f258a759dd1c7d0de232da09aff17d9fb3d6efa96cee7625fae7ff77de7dafb078de2931456d25f9b1b5996ac2399c69eb1ed034f135e54fc393ee9b751fdd5f9fd5ce52fcc5493c7a85113f4e0aa49102cf9aa05d961626d0ab186b6ab4f32dd5454d18d7536e7dcdd3cdc8a5c6bb71fe6db2af307f9b60d5944d93cc89b2f9aee2194d0be72ae83709ecc4f9ce1523ada507e1254a7b5125ab144ae0e5d6b4b0a05c2e31e9fb7a672ed2fbeea4682d2073a240ff76dc441346bc431a5185cb87bd2d27754e8fd6fbd6740c8ec77b45acdac2bc8f4f8be03fc8306b0d1fc7284086a6402f872fde20b61a094e5b4d2e4928bc5b53fbefe1abaff66b046bb34bfdd67c6b6790c304c4f6325da13e1a0ed8afb88abc09164d62eaca6ea3f7c3ea1b9c4d954c0abf53154b81ec8ee938d74cd6a36b3cf4554d3303a0ef3d8bf1f7c1ef91515a4504a614327b7893041b54ab7b00ea7900aa4e8ccf5603abb627dd266c75218f3bd1429792b2ec11e485473cbaeab7184cea3f287f8d89a7cdda15310e83b1ab6ed7a8a3c99fc9ac9d1da588e78e62209d860c730996367e7077ffcaef433037e0ee91f96410a33df62638f36daf6dabc2629e32bd1c0c6bd17adc054d41dd2b57afb79a8da3bbe0aa9ec3d748555235f481967db184292196e13e2de490a1f41fec9ce0a911a132137d79148db303e5142f31b13d4e71574334c22770af379f5f9a273a16557a97e83cafae09e9c9724b2b3d3270ca99c8eb9ee69cb4acaf4715dc1c25cf9876fe209b66046d94b8d5d2e1281d42f69d45fe737380c33d3995f4cd08281cdb50b5cadb7ab35c3211675a0300a34dd5c39e3a4b2b7e6de3db006381795862559616f2dad2b831635bfa082412e2efd480261101539bc557b7c3e9b7f0410af64225021af99ecf2386e3bd2023d56e738270965636baaf4ae0571169f15b119e6f52d23d96b97f134a88c78f00e5150472ed3a9de37f5c6e209b92e8d8bd1e214286ac1c659bd7acc4e786333635bc3a4f80eab735e78714239af7540cc4158bf5a00f7a741fdeb2c616c6fd3f4926af6ac2368417a7cfcc40208d4b92c40ae003f57e516a7798f0eb6d3dbd4e008b1dc9c1862ff134611a68ef76263fa9d753b6007f5604613b67c1fe607559cb6b7df4bd503226c721bf8e9182082b625a6334314cba7a08016b5eac7cb1d1ed3e4439663f2e22fc42d64492a7d0f30331aa9ec38722bd61ec0c70a8450b961bb22720f4da2a315b4fec64c5e07255e4025ad3f2f2f73f10c0f9335829ba06f8bbef6c395f91922d66c7f4f6a0924d5c637e448b1c1e3fc33b28723786fd7c2c7623212b8f40ac31f8a610c1f974b3ff81705dc9615cd7d1557a22dcfe153d7279bc6abf20764cec9d6699ca4f6d6088782f6cd91b73a5215e2d7a81159921cd9ee42f290b5b344740af9c4a36ecb4a1f062fe8e6b27a741997e20f8542babcfdb0f4ac0fbf9097c295116783163274c465dbdc8a9c2783f5b3cc36a53a19c6203e2f8eaa4740313b2628c7389d47e9c057825d1bf967285fe886fad8c0efe145cbba3db39e7388457f480f412d5b63d8d95e27ffe3b5c9fe55b97483051778be7cd79889b7d9b0886469d0e7c665bd542ba631f905cfffbd97a04b4d6fa78ddb14d00f1ff71d37e55faac1235a47e3f011a31874a8f0c03c29f1d7a7e6d626f5353f03e5a52a61dacc053c4156da8ea366dbfa27f790ed681301efb3d0a852fe8e09d343eacdc1e75fec4ff919e01116e246e7d835434a79edc5bb558c808fc9e73805468da9ee85bf7d559fc101d30999f2f4d479b54b7ab259921f754450c91cfed4ea7ad3b4cebe9105f58e14b989e6403b7c5265f3e06563b4475975642803804b7b7c8c7ebbd269e0b81c406b6d52dcbc4a1000a182438ae039410e5619ced6576645dd7f884b8b096e413bf4a172bb02d403dc4a6548fea98b550f5a79b2775630dcdf82b6102f8ddd73e5573a2160444b1642d72f688535debf03e53481606525075f9b8c3b0b85ced98bf18c7351a64383768158d6ba863bdf619e06926f3dbdfe482ef3ad00e6e03a63a5ff938c699a01e811409e3044e24b2d4dc6bbe21c7fdefaad5ba0367724b66851cc540e608316d93aeef8b626f70e3dc472f4d4abd15aff279383813ba4d043e2e914e37e32d6ddba25ed59a0aaf2e166fe96498fecd0a8cbdf5381886df230f4a53f2c5407de65d89eb263f3d4bb7fcbad845211d0319152681ce85eb5812434e98eef550a7abafb38c0980d251ae6664864dbb217f8e48e1e241cc12ffa7fd44577a4ca1e372abe654b2787c50469def747044225d1e7725a5487256d6d9c2205c689a7be1aaa21453eef906f9b762477c228f403abc2bb693b4c1ad4014ef1e207ae449f28a6634c8354fc5f72a56d7e5f3cdf8a285d2c2ef168bcea9e9d8909f014608858f0db33e9c89043b1ec803957528004427b3540439090a2f03084bae322868bc7b31171ae8c5ff9736f045196c80dcd2961078c6688f10984f6dbaafed561082a595eb06a29de1207102df5203a5c92eda9e71009a97116d29c01aa583baea3d8406845f0b9e8f4478f8b10f4d4da48288bced1dffd04f1d59f2ee6b3bca91f4e9696b6dc5e20e452892057d5c8d4720abd21656bde75c94662db57b33a8e3186d0a3b452edda50c12335e7d870c41ac14c503e834c8e922bb500f6c5da587004b279ebcc6638496bed07b1cfd4be2266494e851e9949955c1abdf2cda89ba6ae9a2cd3627fcbb1cb6d1b64e0171b4e8ca8956a6a951ec24293eac06befc1785285bba3f3c449ca2c79153618a6c8f73c848c3a0b2057fcb868d16007d21a84fc0945ac0f2067f7094662a08afa1c4033ad658ec47ba1b3525b7f36705f59f8a5b67d154dc58c53fc79d163e8a105135afcf83e7227e28108c02cd84f708672b0f67bcef56e631c2f6159524314fd85a4603126f300cb8ace8c367f39a73dca8e323b398be5c50308db29a21e90594856371e8de3d2d8e1f23396b0b9c3381374b648562c5daceb98f7d5f85b812fcf42ed25674a536aca2681740e36dd08ea28c946158240643f7e404a97448a0e674751e5f32fba569cc4a2060cbfef210fa26b453df683dd77d5bce4973234d8ce67e5c8d8e7e08885ec935d4f136b3719436d695351667cc43f6381ff0edf85b432344157b177f27bdf293724265ec830944107f22c405ab7a4c119f88410b695fd84d32c0632af48e869fe7afaa29ace917ad36011aceadfd529508ebfca9dd15de356fbcea91c4ecdf418d769d727ba9106d82d9acca83799839f56d31831117a9ded7c20eb7b567f99075ced65f64c95d7eb4425598ba86cb23f84ed1b4e480e0a7a4a1f1e23332732fc1561d0917c4052490e999043ab2256137bfeb660a8a7380318df549cca080c02aebc5984d86de81c692618bc20dc371295fdd860c7f0b80b9604bdd1c60a5cae376e87ffe035e82a915917ffc40822dafdfc53d26734d75bc982f616c82df664bd9d2b2f708f78794017fedf2a088bf9ea89d9884bea067602294dc3199b2db6338e38032af78088fecc5259c8a255562f6eb34d71f0bf0c30f75c7bfe24a0455430b504e5a4aa23222f441894d77f0e431ede4e8798258ab5010343a1a4c406c83494cbdb990d37b7bb3be36cca445238430eb38106ccbb4f7e58aebc0e6d0d49e24598f406229a22f4a09d7793d52266d834dc36010d14e772dd3561260392ae5917b8f4cedbd68b592bbc5031374694d306ef49e5743cc3e470588b515b3f103681cf67ffbe9f6f4391705701540cc437daf86ee0954ab31c459ad43c3347714cb2681eed51baa7d89ce36d3faa4e60ca8a4d7d866ab98137bef6458a880d3d09664fba13f410f63bbd749bd138aaadfed96aa12822e1df7666e46ac6a186044f0d14a9d63a32eaff1ff1e03526d33f7f7baf00cec9800b4f5e148d1588c50545500a2a0619846241d9aeb37c13a247938d91bc29a3e45309f10b9c718f46758e026a8c0830bdfceaf25fe043211c35dfa26ecae67a0dba587ed96d3951b1f2353d4e777ee340157a7290a0e3780a19299fab9c0305653815aa99fcf45a0d2f276da9c409ccfaea35e72a2e28a5c2d940b1e1f2d238988ba74631024d8d8cc55ebd96fb2204f54e02c1b434255b7759cda61009242647e0b8da8da7dd9e697cd463c391a3994bdb8a91d6b39a0f38d1e04701000e6a42c1985a999697e60587ad72c42de2762d3e4cffe82f2f15400678ff3a301fe782fe4234d0afb1491797e01096aa8966867d402b52eb3058152a4a609a4c4491d34643066afdf7f6070e16ce4affa4ea3916c3bcce2037d8c7bb6bd2d85311256257b4c601b90e860ca0263dfcee80277f9360c81e31a4c64053c79fa081ee5b348819dd244af5e51bf5b8eaab04286ef18e483fae2f81497b2c74d369f9a34d66efa48810c02bf1b74709fb7334537889402d5ae6d3cc5c6cae61060b1e2ef6a47233d4bdf903c271e70ce4516d2adb37f8a300e1042d8e874119ab4360c2d917e81e94ac35bc1ecbd478666c56f5f79db231b303e26049236deb3feeeda942fbfd1bf91c111077cafbcf0efef9c8232b2e3adae41dd93622351dc81ca068c98544a5a008dd3ce3aac5c084e3c5ca7c769e6d5c6a889c58694205d05815138647341030c057b7bff563845d1b39de4e5ef500542ee6f5dc1450217b75949799a63c64a627642e4a3a59b0c3aef87414cc5b0275296fbba56be63a69c9f11cb67e99a1a660071cb710fdaf7f4a1b34f7f731e13e130eedeb79cabcb09d2cf47fe462f99996748aff0a3f53153f1c4556a536c1a1cc906f70a3243aa8d770192250caa8b217a122ef5a19963e4c6dfc42ec6669a9ad4846f2e7daf4275974fe260c107a1c2ba6228a4978930c47f93693e5757db0aa986b1b8f103adabb4bb577ceebfae9afae2e8a3e3e9181f37956de8c6931a464835338ebd0b274aaebcba9af9aa28fc6cbaadec70a51336533dca665b7e029435eaccc55cdd65421f18c28bd36cf23b0548190a878398fe01161ad2af279ed7abb55ac9e5f9dff638ca280a972b976208af3afcd5fb42bac5fb5dc0a06e5dee79f34536b126763394869783a3d6a70cc1d15d698b736f360cd0142939ce4796ebb567533f10f8804658546b589c981eed0408a9a60a0d946d4a557327ab234532a73fe78c3a45c977e164eb3a9259bb465bdcac666f9a90fab828ab7a32d8520e51f8d8679d85e788732e998824284e055fc335c5448c47ec1f4090d31d33a5ceb607847adfd7470254e5ac40279e806be9662597254de734259a120ac0860515d6751c9469a5585ceb468bcf6cc26f958be8a8439ae66de0b3f4185b881aaa5582586d4887b83fdf1b2494e7c54bd5ed52510ed6b8a6d3a5c512d316f64ca9e8a552e84326075c32b46b2fbc7da08291f658df2a0235f271e73263435ab2935f47801a1194bd91d64a575db656bbf01e85eabf2bbb7b20ca950d2be415c43532985c1f1e4a4cc81a61215731f21b0ec11b89d750c3329add42cab51c525d4190d1388dd699d6059e0897513d4ded55110afcecf81a96c8d5433ae166f220f2a34540c17b05464218e09137495201384fbc96823e7f96fcf30bc39ab19f29b33fb223c855319ac5332928980d1ed73798a63a82dc11d9fa080e0b231153ec57c67bf5de8f63751e902dab59ee0b589e46cc3530425b225d2c47d308262bdc4c8b56d153399d56a40c2ff37e752e554053bf4117475cefc9e4aa06ab16b246927c967b074905dc0832223a1af496c56b71ffd9d20a2af5f79eb834f03b7f43ba3ed1229b1fa8b32f01de598620014a845d2be3a742246c1f97bc21e483b7793645e5b954c43afd187e058477031bf24e0e6e1b682ce9e0766f13f873783779942b79b174fa05e02c252d78ff1763558a709d927bf5754dfe07136ce9cf1058253f8f46b4adf17628664b0908b2a071f89ab7f41aed29335dc8a288a192498976ec5fcfe6e6ff8c378979b7ce102fb989c8f3017bc48267b166e3e1c60438dffe7953006e89e66cbd5783ae81af75519e6cfaf6e4df19fe0894ce57041654054e497a0c2e57f5ef00fd038c0f248ccbabab61d8f057a282b6753fa503a29e8ab7531ab5c95433c24391729a8d6432a1e045904bf89ce0be662538432c9a01dd5ed9b79020dabbfb42125617a8f5d9f8381f34a5ecd921ceea893214b958c20253f45e5453132b8c87e8eb3f1aa48ca4462275db0b26a79c6efe92287d4725394f37098a1a2a679d3e02ceb5d0dad308f45099d74831b64c9b2bb5ef1488739d270239225341ab0331a263af751cf13804cf8a871385f4a03974fe5a61f132e1b487ca68b725720d417ac3e14d5b68416ce8ca2328a5752182b1e64c79e745ccf88522652c172e4bfbb844f4e92e893123cea96402417dfb62e581cb60e85a6d5107250fd83880e922567afe493571a196717251c6c1d0e8fa4de662ddc016ec3515158442e0cd4567412007ca5a7269bdee87cd158909b4ed7bef23f674adf5eacdbc91e3c2a214b39eda5880f11e55f33c1733876f7297352fc9a9eee2c5af47102a114baa034b60fac3a4d650295191a80de9e323c21bece3803efaa57c6bfe95d048f75429456d17d949ac8601708f9ad185b22c6748f697bee594d459dbce3a2f0f15a0cd849761d7022d7a925206a99617c04eafc042e5e0678394f89de148c03674226b118478b841cf2f4a7b4df8776d1c6b4e66c949fd82eb8c46a42457efb69bf8f5fd2adaf0a1f6fc213c62b70beb6224f8e0b577d8b4219d0f3c2206df501e5ba56b47700b345e538f23f1ba2cd8670a5b20a5c27e78aeee72da01430cc63098189e5add7957030c8e43628439c7297a185b3f71deba6556c2559d11cb83b986cac80cffa817ea7b505366e06940c898a19e33d4f16d09c18139e58660a99407e398a9b78e36cb330d6dd339aa80e23cc310a8cb39c4e2d18e9c6490a01ea20623c84a6d264380bc906ef76bdad3585f0ecd95e8c77d734870ff827d1b541e891c7d3e3975eae93c7d623a726244836ba921bdab7d6187153ccbaca243093a711f921a26bd6b919ce40440c95c900868cfb61516a5b78ce9e80071f058c695037d2bb9d54652c797806a5d0487e97768de8e97f78465ae2defe364c20e9d52b1eb8c415716a22fd55bf0aa7ba067904290d733fc00fc8440f7c3e6b146ff21e8fa27e95d8c3fdb2c549934e972d038c854c37a392973881ed79247578ac11d961e52983acca789320f936e52548ec7ea89429b36dddcb7bc517ea6733f7578c5cb81af8e92ae487c7ba0f0b58f6b2ab770ebf50f145271dbca14a2836a86e30f4954acffa2c4459cb5222e5260da501d6fd83db3a8515bcd51a9a77f39ffa4edf99917f9800518716b0cb4205db385529094780f50d8d67670d3b0a32b23a9aa64643ec142f59d72edcd71b861a63b846b1676a44bc5f65dbd7a7cb2d0631cd30170f798615c3ccf52d8c6c9bc3a471e4816ffd71374a1d0e2416e23df2d4b1c78d507819689085369db362664cbb7ac0199c569422129ffd86480dc235b7d8b87087174561fb58749ed66822e57d59625e0dd906e6c3bfe5a79da3d7218354934b4921fd432465616651dd40a0f248d2a7d5beebe81c6fcdccbe4559f096cfbbc9d3f136bc92ac02e257b6e1fbdf987a6ae9ceed5407ba22837bf1691da4ed21ed61d716c692a88b87df5f72e0441e98cfe2c58f742b7e7f8e1b2453f84f7e77c54818f834e847cbefcf42e329ba92c96018bc5141ec821c0e8f241a4c9df0c1b2bbc7ff9c49f93065421119dc87131113f027ccc697ec4972e1a12116e71d28e0e52854fe47294166de71aaf566fdb9f316956c2c2455930286df3538a1c702abaf8e6aaa8b76a8119dcbcb9541396e680c4a548bd87e362024628fd53ba7489df8b86dec7ec56610a2590ceb637a7cb327219276e0565fc82a9438c945a5975fac1c7bf6a0080ff7cb0e4a13b173196202e943874ee9f07aa257470871fb6a64b46b2ef5088991e89ded0d5e23581d68770ef3fed705fe05e384839c58b6627bafcf2ad87c1c486da9562e554e6f1b9df3102effc1ba77fb6a1a0cbd1efdc7dcdb007232dd04e6e42489408cf2ae55feab8f8802bd2a9cb83c357e51065dc95691968ebe6d8c10e4c295ccb207a785ab23471d55dc8f84f58f384d551645670fc1544996046bfb48a8c369e2fb2a258868d7929038eb8275119d22e8256774ac0b3581ff554b7765e7a4a59ff5e914cb9b9ede023f4de9d6f2fb61af69095c0a4302338b2d5c98345d3009f0672fc3b7a718b2810757735285e3308da0ee80290c0d7e5e46daeddb231c423fbd685fbfdfca0ef76806dea8d4f992d208f21c9cca758a175978cd8f06a1569a8a30b18388434fc10f8feea282e0b4b4aa02b0d659e3630a00880897d96b706561f101aa66ab80ebc80c354f43a2da68159aa2223cccbd1e77548df92388ed7a3083f68a231f3bbac290392579d812c4480e8768817ddefb143e3642184eb820ed8a068f22c3ba63252d7b3afc6da00fc2e1f97efb560aed9ef4890a8633f1287913f00dabc50a841d2cff5c4258d645841be299bebf21336437dd0f01549cf6694c7dcc1abd6f1c9be73f11acd030c37eb9f13c009f5edcb8796976e8d7af1fab83a425f6bb2d9153c331431fa10c168aa62d67dd38ff572c0a64b107693479e7d6ad7f122108d42837451c196cf75761c834420f707c431217307b893cce76471b4c6243fe68effb0dfb4705b57c7d27f12d167f8c18089d51a8b6cde9efdcce22f7806ed7427e30527f52020c95cc87dc0f193f708ded7c460edba19e7d6aed8770de85a9c6fb7d08da7528f0692d90f3ab648fb1bda63d1dc46940063430f0b4adf3947eb42dc33e8f4018d86341f7c51cf956eeba04b4e549f06b05b2696c69f82823179498c84fbc6af252c66847763982708703d8514f7fa2dfb91465ac0062e8f2a46b2137141881e5ada5c6a305879b7969a3b48a3b715b0dfeb1f78c1a59d34a52c3785ad32573a86329f02ce9bd453b36cd52803fd73cc60fe02bea79669879b2396a8d00514494efb9ea9f669f45c6b24ffbd84d59e3e20fb126e157215a5b291ada8deb891b40ceb1f6569a31f3cbffa87a6e6c2aa8fb6b51129435bd1ac9536261b714fe9621b06b57f834ff31e97c9a0a99e8871ffdd05792f8f140c38b7e79d7d112a85f8e62114e218468b92f1b4df815e9e216db478707f0e1c7fc9dbdee273ad29d95c5d4caa7c64feff9692f5047b7e1bbf80a818456ac1d644fe29e31cc7a09c7f25406aa2619e120b0789de5ac574715c9ab45e177e113a8ab6a72f1fc5097963fce7ea45e32304ea97011d1588f16834a4f9affe2d517b4b79f34d562941f88fa1b12f666d1d599e2064200aa56480ce90c01414a4721d61ccd12e018deaa6b1cad90d0146df77730dfcb4dcfc8b2a133635c583ad8580ab4bd8fbbe233a2fc374c0c2a00bb91736d58e7588f68da2daa0767672b61983263ae9f2093516bf0b7faff2aeba1421fc462474f67a8b46a74692b3cb7e5bbe6a7272c1c31b7e51e99ae8d0570269bc4edad569392ddf0f7a5e1cfbffc0f2aba57f99484a3042cd91fcf9a6b880afa43086aec3e03926fa99d3dc9e1413e22683b30c9686862422dd5dddaf33f6871f6941312c3b029b3a36587ea0672b4445206fdbbe94d2870aae1c034e1a44952e82d31e26119c9bb7bef3a33de81524a0514cf1607671c78fe4d907d053030b5a01233ca82919e70a31e270bf5999956d00f7d9260edf2e69b9cafe7a6f16741f34432df2657dc0ad2211262857c43adcbd02efe51294127f7035de832b7892260f93354b48ed1748c3db670c33ce95680009f6582a0a282db641b72a7d5747ad9d0e79d30e398050b769e86ef2a913837e238b1c9e211519dc175f397bfc38c9f052ad2f7c07b1c74ee308fce52054dfdd8d479d72c38bd5b24bd8dd544458937b520e0693d61e382eec4fa4d6bcaf2a0351ace99f58b3a269755bb503e7652c0a7d2e087f543d7940fabc19a35a745b8d1604a6ea6c0ce03a1bfc703d0e00f35246191dd8f3b721d9965f01c20bf666ab00a2cb133398b8b5c6820b8863434d58acdf8f000a1709416f8368bbcfe2b447fe8fb204028bb96abed23d8c6d694d19510ba373d7551387a397e95402186ddfe7a6393fa8df0499b43ea2601df3c86318d1475070f6aec9ee7e8a59cb1fea1f72573866913c2c1c4510a7d9bcc3d916a586678f4181fff1eb8cc2e9da3bffee370dfdd6e988f01e348be2e904a09e503c3cd68888ebf70b6189e9da7365ecd7e450052f483005816b66c8910b5aba2c439aa0f0e26d8573400cca733c202493a7c750822fa4716564fda13f947a8f4957bd708d95e48929d7543622965abaabde4edeca0912e711218166262b0846a0149fbf0d4435267ce8be22596ed625eb53c2c43a1aea2f9303db0471b0f2ef0acc23e3fbb8dfabe6b02e3adbed84511ca5ca81d9d9492b7b5824e6bbc30c31ac354a970a16232c74b431a40934c7a018fe06d6af4004f62a84bb51dd99608be11b1550bfe39e5461614051a8ce82f37c33fb5be03f543850d4815185ec7c05183cd5cb43588a5d0379560b9b121f2a4cfeb3309c13e50cc75b22cec73418f692655159dde29fc525b26b9fa9a7225270914f81347003e221809b645fd4e3705f33f9363662ff8796877a16038879061b8a8dc62003ebd3bfc672ade25aefbadd4d50910be222f3aaac1aa9eecf04b4afba19ee6e243cfc677847f66e59c4269121a52c84c11466e931effe547eceef66e1cf6c5a83597834c2c807201a3636768eea1a21b078cb189435c37e28d4940d3fae80a823e7c037eb29a88817b86397b7c0b75a07d04ed5b4433c055fe6cb9d3182dbd26f3a09e28756c23e872bdd06d1506487e59dfeeac933c89106986a9573be899e76478eef408fc2402ed6e76b887e7b61a3ff85edf2da86396da5c8a1d7ce8fbf67d208fcf09dd57497f7abeca6dfe22b806999fb26aee55f7de65b3dfebd823ceb9109aa5a9272c2367e9dff9b507d224e4907eb5f9348fc879dec7d375d4710fc2916767af62ae7a392db4d24ce50791d86959fdf9ed8fa6482bd425fb400fb0650ac6c42089fd5aa0000ddd04d04ec9b15add996362f66adad52176321f58eae75c21fd33288a47c0d1c7690e942d761059acc6ffa825f82399645aaa5cda894f0025bcbb20dd897df80796e12d5df76ad35181d16b7ce2aeddb226691ea6e494344321f23677785d7fe217e67533741dcd05d8146ee8a4d0e1e68fb68ee36bb7ad3f647b58df6e16e3922a72bef84c1577ccd9860d0e8efaabe8f525d6d15d9f63e080fbf51dd5647765b7c97a43a88ff6e8050a83e4ba2d885c6a4c638b5389a8f9f2e16466e95dd25064b66ba3902a848b8b1cbc217072b4d9b5c5b413d345131a8a4a6d6289c8095c937fa23086c4833f7725dc9ee4648fc63de0558694dcf365430572208672fb468c69fbfcce4f20d11ca721748efe8f8a7f14d10d57bdf9e89838e1fdc484dc71eb3ba13b23082f06849a01aba6b02bb1b5fc2b78ced1bd57c079ff3f73c50538b8baf40a8d78cf3f36846789bb0fe51447c43353ee62a05ef1646e9510123e44b5e2d97784c7ade1641713fa50af75126a7a9a23383ce0fb47db9969a0823e761cbd7726865801f80d7ca0ef033ab2b9bf2fd47a30ae8ddf2355377728b83f07693db6c70b9809747838693c716feaa2c8cb830224ae5dfe69d99858aa97ca2c42fa1f89229665f9aea4d7eae579324a7270d02fcd56d7c953ead9e9c728c6522e21cd82afbf4745d5ce319cc2cb10503f464743e877bda91a85326e808ef1fe2a4e41acd9eaed73ffc797d64fe67e40fa758df8f269e009a4dfd769d3d1692c703510cf068944e7394e075f6f08cc7c97d4d73d78ca23f431b81916110ba1684fca5478fe949fa039547fd38ab0ab030b3a96a6766becfbff1125fa3ed25bf025f3662e86e82f8174b006fc9fede36a19bce56d00f2d4ffd09aceb9c248e70dd04c20d51233ff1ef49d15d0ff309e4adcdb4bf4047096674eaa36f98a32a59ca7b0695d07e91771483aa109c32648f6d8606828f844b9fe953abc9fd7da4bf45e829eb9292993ed5127846ca3c9d118a9848359697293e943b0205ac670d098ba8a4a7019d3a2c26b590c22c47dc2a932c4cda385cbb2be450f973533a297d41472718d47d91a5f9281663f0d42258473b08d21286e8a0e22960a4049572ed08b00b3f4595866845ef3a1c6392887978aa84acebe55c94327f18648ed7cf93165834cd505f966391300128ec804c9b30af5b62c92b582f95843290ce9908cefa102006d3bd8bb4e789b270116e80e87fb314c6ed207713a15b62d7e332ae78e032151fce235171e85aefabaf5b5aaf0dea1c5a2925b459ee0eaae0d2698f12c9b0a9a752bbd5a9614231d3c906461cb629e4687500a11effdb7decd8631aff928a5b45418a217a4f5bb87b3c967f1299af8ab4cc653f9371a35117ab31433fc5deda81fcdaf99820a73b152c6b871bdebbd25dcc69ed113372b42e8da503d581ba3199d82d627a5e7806d2036686cf28d2e4dbd57c2ac17db6f8e61d201f4d28f4ca46451d819d5754eeac92d482fbc7ab6ba6d7e689deb1627c6676aed565cbe92ccc9f16b417e733e1566ddb0729c2d03162bc2bcce5f870b1445d1152aaa56e3631924a0ab02d209d33a3ade44ffc28d1d0e6946c087f1993d449f6e242174b56dd5d71da16ade7e6ed2f5da450d04f9fe9303cc89e0957b86d7e4548e5a993127442ce2961493c77ed136a7766a5dd31c94b6269072b25b81f7986aa4ed505c5d43dd53b98e83a7a53d243635e14fd9dc5caab3468074cfe8b2e1ee7c8e6d49efae27eb03cf7d71874169c40dd137ca489b68a0b316e5fb207f13c5386ac764b018601ba3bba7a5b8ed9fb1388fe344d0d805aa3ba2e88ba6133cc0d7a23ac6c6c80e5f0ddec2c9e2d98e893db71add5cb7051abcdb37fd93f11eae1c51e1a953b80e2cab31d623298fcdafb91298f8c2c5727c17c206655fc226f352d91520ed8f5ab16de91eddd3b1824beffeecd0e338d5391ee50bff479c1acc4dbd1a26067820805da36b2d5538c6b7d4bad8415dab9ef6508895801b030c50bb56819ee655fa6360e7805676dba82a01bf8dbbc1411d1683fabb58b365f2eecefd0c028c33176fc603bef0422e87f54a3994ffb437a32dcc144b4eaf8a1a76102362bb25c56f620d1b95dd9dd3e691ac444523a2663fb77b0609e94cb52dcc0eabd1c103131718169b9145e2cf1c87768145edf0184dd215e3c5a31b964070226181721db370357eb611f72dee9513a6b1d6b249da8d39ebeb36db7f45e97ec24c52581f2848719352f2bf79b766a2a680c22fae6b36cb3f3cd0a385c23e62af1f82666255e42846c94a1e8b0af4bee65c9db320f1924d452f115d4e29ffedae42bb67db0885dbc492aadf7e0745aef5cc96804e2d08613e7b712ae05227e1b02cd63d4ebecaa1d1683c54e3121e802136bc3984f17c44efbf4bcfeb7db3c4b6fc519195054abbc9eb84c7f0e5d922f917b3ff5b419bc392241c649ecc9a8f9a303449bfb16dcc917db96da2e986ed324a26c144869537711330a940bfb74b705199e7c40a8d33902b26c601fccd5cc3d924330b622310da1788d6f847a9b95fa0f36a1cfdf78d08e4bb138921257579434c2a40c58d7d49d82a9e106b7af5bba734a5400b58a53df193dffe569ed96849585ea68ee70c6bb1b1425cebe66ef83a2aa8ab421ce6a980d02c63feab591ee26e06c16f4f1f752660f20fa2a565ec7abe133f99a467e495b7e37e88252bddec523f6fd9dfffe8aa984b9005f5dd81170ffdfbac8b289630ae6440cf45b6ecbcc942d69eba1ae7127c2ccecf78d2f0883201361876bf07f0502fa8bf0cb3393f752a3eb7f4aa1df4accf545a073790d3aca8bbe86524dbc486fa1ec94d67ff1b19926485821d3e64836d45cec9333e59f5655faf7b213c4f41dd3e61d29b0d68a2f34b803936323c37dc4d46e7f7ccafdd7986918a2522f8750e33ff26c5f1e4ed29640c4207a3c03f05b38ec7e8823fc394812cf10cd75e57024a4e74083bd9df3a0c380b3999010d7aef1752da1c54e7d627b66a33dee0a10fa0787ee7be1bbf3b78af37651fabf381e442ce16b8d8a156b7c09b9a02e42bd5d11958e011908c98e1ba9947f283a7919aa2b054b7f6e0f2d5540330cd1b634fcadc655afd2bb94c7f0916e44b0e957d860b80a1a827c7e06b00dc66b15b9f4956bfd76c08c8f2c08a2f365d84c5b70f2a4a7be81c24bf91fd0ec54691cb4a2814e39f722ece046d94e637b583ad47bdb65174c5d04baaa517e5a84d403f4271f0e4068b4fd1322f8bc65c0ab3821572ffc0735cdc7b528bc588f10065d85c6cd69d90f5d97cb82ce21d09d0de4af7a15c4f39baaf6e23c3b5c9845b34f75782fe130c502eea3b3ddfda493a91e6096e4377f3d6ab28664775dd28f60142b6cb633e03b25c66d4a86701827671824048fe885a03e80b78e0f0abf19d873fab99b2e523856ce1eee15dada0eaaa7afeba7a4b4494d431be674f91acefa1ab06654ee0b3d89b52f06b7ed7961b5e9173d9a38bc520cd36aa47d8e420164504cdcea9237d9357eb8e701bbdbe3b657f4a13c488c9f24a48ad9ee6f84587fafa65d0390c1a6540ed810751e96f44acb78a329dc72af3329316916406d19b0d6bb8d3f53cbef74def806f8e46a531508a17e7041cceae384ae3ff10eec07807b7288466a37055356f4c99711df82c76ed5f0f8ed873b6a4b02441cc3faeadd3b1a015d4bcc2055d7e6a5466498f5fa9a6c863a56b79c4332b35bf55049c702916a6e56189080ea0d83b2d3b076bcb17538c735ee467cf0973528c3be879c29b41818710dc85316ddef17ddc636a656e2408e9cccba7fd7f2c97834d663054a9e945661767435558a1c1ecfab92701970d8158e8d14c8969a058785dfdefde58623ebd3bab5b5d2c12e03debd884f0b752b2a5fb5ad01f68acb677d732a4d8d363e7b6166b4b86f52cebe2da51cce091e5376058d93046ef94efeab9ce9955a63c9203102f69034b76d44cbebcb1881d3dfbdbbee65ebb3202a2f44d6972a9f1131193a7f817b10fb1b1a8e4b38038f94a919b970b2f363bd5bcfad29a9dcf1dc52fb24c69fcd0f658ebc24eb338122e44f9a9e7298e0ac073f2127669a4fb18d2d2b53092cf7e4740e3b22cead70725f0db083350928e715010437e453acdb6553bd2cbb6e39247c8a2d21c3678193b5bd6e4442280b8d490f7b1afabbb8af70db488aa31a507b5709f61a56679341d5ad1b976a7b63677f1942842b6c7886603f8b42418d5c1bc1c5d52cd97c2b90064eea96974824da7e093c9f8cee701f8121b6ea495e42f254db133d249a6269d90a776f8b95dba55faae526c82f03dca5d41cac38af9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
