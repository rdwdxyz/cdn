<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb40c142979a9559952abb5c2558440a30cd18f3de7552815b74a98fa1d35a596484afe52871a7c1c38ef085174dbb3c0c5b9cff755b4fd8753376e4a2470f9de87e3341d83f904d316aeac24c3ed7e99b737e38416827019faa5c73314e9aaf688083584415896fd34be4dc4b36efd49c3c9375da9011e2892babbcfde375757a88a48d9d317c7cbe0623b19ed99696f07c1123c109f814593a6d848434c936d4efd19380d2e4daa05888def7e983df2b5c952bb62461eff4590a91fa35cb156c4d0e08b300aebdb66ec2b7714066784d4d8348b314eb18f8ecd935e0443912a64b866714c9f580e62a1b40e69dcfc5dc86365d98f3332b5c25e3bdf8872fb80e4f84202a64cdd5c19abd52353cdc0c89e5db3c3f4fdd057789292f1685f95c00f4ee5333af3d3eee5f928fa9ad3a92c3fdae3163056de0186c7fb170f590a7156d93b576d6ffb887746545430eca086cd59e4259fcf6c3951adf01ec951c35326ed1cb492165924c24bc8f8db0cc31cb2ff9aaee3f2d5a92404ed997487e375a88bb7c7f5001abf5601ffcc4184c906f224f3b00c3b24926df438376fde074d848766175b58ebb42728a25addd436145ff113662e698fd0bca473731fd41cb540eed1136111d53d887c65e67ce8e8a8798a7d3d4253c64058d424297536ab406f5a91b1602d7793af4ffb7bb0d9600fe52b50a0115d7154e89482a5658c1ba576e1d69c467f4c22b7911d95fcd740df3948d5828084faa510dd6db366d5f6d625d1b671f7c8a6a762b2c13ae3b02c5760612309f25142f1ec30fc133cb61c30b1b95dab7e2758e2e7808bac7fdbaf75681e4ec403b465c00fbfa1f8f2332e2784c9e06aa5550bef8773ccfcb8955625b6eb2fc4edf79d97c172d9eeb848184dc9e631d8d656c6e526b4f951a957c91ce9bd2273f16cb3c0789b9a031ea1de2637e08b9cce51d12546a288f370b41cb9509f11b746d0b1d2b793aa1a2a66bbacf1873d9226d6a43d47a1b8f00535561611cb33b5730ec2fe5098ae7a08096eaf2fde490921e07654b50e77df8edefb8e89219c80a8b72a1a273edf8dbec0a71a1fbf6e787ecfc7a4ff84b1ec7619d922ed46ebe59705c4797f6478cc022c3614d43fe3ca7203c17bf4a130274149c6d4366f72b0372ea1a4241d21bc2834ea3474f04b9d6c6d478a3544b023728c827cf53e1c74d5cf9746152076e720dc02040e67bc6a2609f26916a85c5d714ecdd2aaffacb61c92ad6ba0e3f35ea80e739aa93550265b509290071fba9d11dc6d331fde18f274fcbc549693bf060966f4dd92525d948cfd420e75cda6701d9f0d5409cd637dd05659f3c26ba31befe11d421236615195360ba38d3df59ef1bed7b7aa1b1244a862d68efb65759337a44c5c601285ba60f13823c9ec1b6f70d7816f434dde9f77b359ee9278057606758edaa1ea1bf2eba9bbf8a554acc51faa543aa60c14fad603a1b1c64cad0c5b326f812eb8bb611e9ae202d36c764b38116ac3e88271b2a1e2ff8c8a8cfdc5b7d02808f67d3320bfa9e229accf8b1bd6ce20b9b7a51df27f85e3b13f0e43e7cfa3bc9febb6bd7434213d92c50ea24b43515fcdb8fe259da0b7813cddc4d43a7cce84055f443a83590c07cbac7491429be5a47e048e60fa29950e729d5e17b8e870148fa0d64662db4934cc0217f2f7dfc7e4aada4330f0f8ed3ed881b7f54f4770c7995a6d09716806234061dd22c62d7c218efd1503fe44a4b28846b80a37d128b9e25e60c3a72000a06517ca4e815b80afb84b4d11751697a3860e42a9707616ef8e27d0e9e6646f00bc55b0f5eda4d42ca956f5f8b11b91f2cd184db26f731c987461168d00ac268437ec86a0278e66fb596759f7efae4b11d45caf50a7505cfe8c1d42ad3594853c1f17668c8b4079d4bad742baec01f4d247b9d117e26d1cdb05e0f267bf5a1803db37cfe8df9d772bc054c09ddaad60972a872476a0db2f90f00add4d766dbcc2dee71cb92a51149281b8b2ee6f8d1e4dd4271b9eceb958f9158143b8cfd191a05014978e369614bf3270343161ac36917fdd6ee793307bf174b82b8a89b7a74152f22e4575240197d07bdbbe1dd49eaeba3ef62d8c482b8abb8a1d200b6f81165e372691974aadb7d56f3c1dbdab035ba8ef07e42441f62c28a18877311d517d5bbd92c314bcc73ae80c264614f3d6edc206b1ee87122f13b63995ed214fcbab27bfe934bdd9ae1a7551239e601d1d942e71e864ffe2396e1c27877f8102a61a883fea942852bf80ec9942006ee938c28df23e0692cdde45d58d8f3c955db08ef03ffbadbfb9126a8d5a63bef4aaf4551770c3daf5fa3e2a49b0a6e60f0fdf73d63a36f41307ed216dd7474339e1b6db93ff713a4b4e89806c2a5d835d8512d0466bf98968f5f6e168c550a82e94668d8bbde1c12cacc5acb4b9dd3861222eec01586be542fd5baedaaad17348ebea6982ed922f18bde255107f3c984bf89406811cb29e9caa2ab07b4ee8300a3d7a11c23f630f3fbcb71b9a2e1c7e81402b5fc5dd29263de0ab6900e7774f3a106444d8149772f8b83c4243737a715a9dad00c762d8177e54f5d3a705262a8fa1ff76254df91b1113885c13a455ed476845726d01da8cb419e45bdaf03f9f6afec60b1a4b8dc156bd5f6c817c6beb9772efc0b356282a70e44cdc61a0f1127bcffdff0c249060a83f41af3b73282778262acdf20f78504b8791a2ed97d4c62fc3bac00c7464f95a1b8e76b41c6431cdc62ee979e1a0ffcd56f896fe5a10100a2471de98014262c3fc2a9ed12eb7b086661fd4e512b85319372f798ef70376cd63462cda3b08f2e7c94360e16e559de0fdff1be728b3158fdf15ec9c36730d96de4433c65c55b9bcd02f424ea85f9879e7ca6f7e273427b8f0640b1271182b424f33bc34e8e42b931585eb35dbd21d8f27d90bb2034527296f3c48f7d8a38c87910985c5434d93124aa14cdf4664a81ff5f6f7452dd0964d22b5c2a0a6983e2f7f8e24603462c1e302929c9649f32f531a7e820a475aba2d90d1f168d36b4b56cbc6625cc9901c1677f821c0d7add7240174a6c96c36af2835b0e25f5df1d66327d136074ced78bb8fe38bb6f2a1f45962c7e373a958055439e7f11183b9c4788de7eca3837039a3fb024c84f30e5a2d1bd34111ed14085cdfdc7c4423c5bbbeecfa41465fa5d8b0d73550de3f38a7787ba7b108d7f1e6d4cacc257f04f762f2275bde1383dd8dcf9f8471baa864f746e3cc938a523f7472b7b915d01b9369881cfd58cfd0092bac15c6201c33df01c3c9abdcc17e79ead8e455753a5614595067b7fb722218699f74826168a2b0627bcc879644987d79eaf2e61a1df69371f28f8c394c2c90ea117ff8f1fe7d07012eb962b9cf80a14cc7377bd28d4afaa4b8ca8f0520da66d5470cb27f66de9897accd723b4729d517d9011fa4da4c46e99beec74db7c57e4b7f2ddc3a696c514bfded9c41acec1e888e3205d02391d096ce551cc059583d7758c1916e5f94dd6c62964e7acba0fe854e01dafbfdd34043374e1a1a191c992f9dea1f669f7e349159f93a45838bb37d7d9ba5a223090aa77620f8912df97274d94aa100bf9778da49e7aa09616efd5f92e51106b60d6d025aef3c8c2bd6d3cf071eaa7c5654dda9180febbe16b8930f1260ca4eea909265ca14eb36df0355a85bbd90d7e90c6cb67f71dd1bb6c5506e4e0bba7531ad63b0cd5378be01e3be8415b3e01f8439d1c71d3d3baac93636ae404b1ea65d0f761f19167b7b9b27f4afc3b184e0865ff40d5e54a7a418a6af9b75da33e888af5df735aedf540eb8836a7901bb1dfd3adcdecf6508f6bde377361dc7d9f106b1a24534a5b8353d9189c4abcef1bae3aed82856a893ce80b27d22f7c7d8bdac3874525c53db6fa000704e0ec1a5f55d924788c839ebef2e5f974788c730c7d07e36ee5b3e0cd895c2cec5891f71552e8dd9908a06c6bc8dc630e949392560bddda0e47b343c0e6f9e54cbbefc5ec0f116b5b59cc2a0608b5d76d403bb1d48862605d94a46bcb47f0dcc9f55a1527f4811e6ca492790ccd3c4af000666bf2a28555684b614bc1fbf764fddc41f7933d2b5f20cef7b914afb70053484109e9d68d1eee473da09621956165368f502c7dd276db88214e573de6ba4308a6a5a32aa882477892957c977696fdb388971de5f978b504de1b8c088aeda2808713c00e074c7b396a67157169b8a4179ac7aad946400cb6a8bc7bb61675c766bd70bc00275e97747c793567f301f3f9086427239c9888307b732bd3ec7b989ec22fd506c48dd223a641e0c6d0d9d1563bed90a0da2b286bf5da325593b5c649725b83029b7040cadc155afe548211d9a8e39c256720d27149f56126f32a9a9b2c60d000f07e1d6e2ca71ac67a8be639f674f89670d6bed26ec534f788d1512ff02d901e5f7a82cbe28ebefa1fe4fa5482c8a8083f6f6f4152c31bde67b82c0cd3609b4fbc29ef2415af596741f9b973601578394cbef610375814d5b3f1f162949e029548f4a5b2fdfd66a462c7b766e1ba6529509c53d4228bf8a7bb80161bf40e8789fef9c600d5c561179889670459e728dbb3e61c7e5fa686d0f14c47085574981873388900f897e33c369c5258889cdb2b502b76d5bbce401c2f6c54e8da99005bec68ba73d179189feab5c1bba318dadc7baf9e4ab8a8a2e9cc91eedfea1ae67113310a45a2535b5a071308ba59c1ee2f470eac59ed787f5076eb84f08f5d9149d62ee2788c01c8f1004999103d97b3ea9700e2fbc2dff407752db256fc5a26fe55c91f9e3f0ec9009a3bd2958d2cf594bf9a4648e6f29861c3c1bfd00f99e982af35797673534fcd857ac1a3bc434f6f889685363b6d52497c6ed46dc7b9a15da0717e23725be6a6a001e9b3c7b20af877696bac5073f965260ff9a90fc1968f61bb22f979baad40759e62e878424964c97aa474af644c3c52d08caaa422111b794bcdbdd80c7566c5593fa1f2a2bf2d4b82bef1d8d3b92fd9d0a680d45bbcbfa02407c03bf1fc53cb7c909a3bdb05de9ef9c367b3dfceaa898c51e8d0aadb90ee7a7ca1d3643df3cdf7a25a53168d439abf2e42dacfca3d33392118fb4726130855c843538ad8f23f9dda1ff0a2bc9a1f35e96a117c3700c0148a066f356e988eacee0d38d166c9d10785414dc11afb62b960cd697ca361e2758defabfb643af9a7e0b9bf03019fc8484826e32a4a1dfeecc86f35b9abfad4e4262e4f5ea050fa6b92a54964579840e58ccc535d32461eab798101048431b3ee8be3042a4cf84b272c3471b4dbb7765c275ee4d74398bb99227584c3e7fd6766a7402286c5699b60540d17b282e4cea87f8fe33ded1c7bea8a0682f92bc6bbe3fc8955627aaa027864650a5fdaaf4760f0d8e4efedaef3aef4e60131a3a352b8d9bbb9945f4f0bce70aa984bc533aa2ba2ee86537d4d9942ba6349c606747c58f0f7a85d15bddb2429bccea52731df0333421267b1f3c106e56c5750d36f3938a622c0c2d8a1b7578c5e2ac33a5a577873c84e9cff83a6d537a1bcee5ba12a14f5970a729dcf08e954cbc89e93c46834b061731374bbb15bae488b37cbd712904c29384c7cda74743d8376254ee7c34f3bc5a5041eac410efe6678be2dc16def35b2ee2dc6b62d5e777a05c1f0f1d9a513fccf549db3b9d9b0391800c19ed20f4cf4b9cf68f1d74d8f81fa76c9807afff40608dd758690309b33c54551e5480b9d0b3d6ccb1b573a7bd4e402bef9e1bcc1b8fb63467b46985c26565982c2063991ccde1f966a28daf46ae8ea03adbeca67870eb4c83b7f70f449dabec4f5061220ba31061e0a3428a3c046ee649781da44e3067492280d20b29b0c743a6e94edb1ea93235a1e453253e8bca420c02b0e44566924d97ac905c00f820d38c3c44a92cd32402a15987176a4d135fe84ecd388cc0f98f58125a3bff19c6f3f9455a3dfb21a7477e72b4ff95885340e6ef356a651fad178878fd771dcaf108a65f83dba1b6ff1bab585457c24bd66a06f947a0e296bded27694d5958e6c89d8c62823539269fe3822d8b06307f543ae048ae1f6f4407b3a3971762c97881407f9fb22c73d058c8d2951e192c7df762fe58b13556410e2602fd41d1f9c842e7c8cdb9c33585c5bb9fa508a8c8669229e62ab338a191d06532b0e947f58a8fec7bcc69269b5760fb64add5a5ee42b3117dd870711bebb1d9f784ce76af0b7b000c627d82cdd981c8cf46b6aa561a852946f68a574eff136db9c3d4083466de35451875b41e0f5b56d0c40495c9424ff075289a40bf3e7ff45ce2286835bc41dd71652fa34e3f197f6039d4995a4998aceb8053ac5463e00a8b963e6c5a5bb8107aa0d27c3831dc8de98095ddc15f622850da7e31be2edb2c8cee49b8ebe64583a2393a57cedc9bd219fab405d26cdf0f48a1fa1d7a193e85f2f6e0a4ee8da9e70b1576484f8bce643b5706fa12c4e6ebc6645f28eb1a67c5040f13f9e365e181cb80d451c2da6cee1b2572cc3e48a84842209485ad9a553793dd3f175021e6084850f6b10e2b143c0eb18a80bad5091de605d985948592e7d99c93d3060542d6db7409368dbcd738a537d0594288901657be74f47553b42f707b9f33ad5a6983ff203abd64ec7f8f856f26ff0138ac371bbdc03a77859d9f486c1c93fa6a8c8a55d8151072d185310628d8158583b4b2ba4cfc44d5f4a79552a96a332ff89817b7dd6ffa08f031b7c76f15c130e1e592b591c5eb9fd43fddc4d24a517ed0e1479ae3d081e3e7b80c5c3bdb127a24726037ac39acc0e03ff82bf71977c68155ee55a3161b3ae8e656c3328b4b7a66a7cafaf22b06310cc48c6321ff7a646652448942b646dc8e1076bcb16139dc06f9fcb3a4fd48fa53dd6fb9fb41c404125a62a509c794e635af9b231aeadf1dc7f73476f61ea4434aab576c539b3e95e0652da91d607f01089407bcdefbb8f2ab8e6e260bddf0663365eb8e79ba4ef642d4ba1b7412bcd41f75f295c4dc0be575484f30a32d3442ec61e766a990f021652b15c44b7f0f7d2920513f0f2ab90b3dd773882d7c191ef50c23b4a6b94b21b3185281a071a1e2a1eeced817939b97575c0ff3884ec2918394d7c39ea287f3e56f64deacd88786f0f202642dac70dfdd8f8e1e6b77fd54cde07bb8741d967301ed7dac41b82048f694a7e0993af5df70c63f68ff0f8d6f0e618f3b31548de1275022c4401e059d57418ae717c441a7a808551b1e5a8bedfa80631f7a6c3b451daef1c76d9a2e3c35db664efea136642076dfc5f2ed5865409daf5716b466f0780ce7071b77b2ed8d79d9058a1d63105cad26abf944867f56c9d569133fae9ce8fca04b4ccc7edd8644d1ae119b430ed61d99448a1a64fd61317dbff2480b1320c614ed324e0ce7f8ab94a4c5547cf333cbe9cb1887d071d04a02ccd6a160293ef265434e64c3826cdc699f6048e90f8528aab9aad8d7f0f92b35351a4c4b05bea73169f023f97e22e26da66d8103482932bacd955dcffeb1e1686e1598b822a848cf8605a5a078647766aadbc81d490257e359400275b13266088a08bb3a7bcb6cc6b4d62513588472289ff9d9f47c89c5a465a79be38e7aa371c47edfc290dacaf3e825858a95d3c12d56ba67faf12671ffc9ad11587bdae57bd2aca7ba88a8a132332055844045bf767e69865fe27ff1926a68a9b480ba1ddf3d6a963572c67b357e173af6fed2c40c0914f164b8e19a68105bc1c550c372d6bf5f3359b770e954a823c16caf7e18f74736aec923aa1839e8b3fc0dbf0f547f707af761264c3fd1f4174926dd8047a29977ffa90ebbe20ae3dc058c05efab0820a870441f9ee5f163a813e3bca0d8c2f3a64b6f515ec2cb97592468f640448c8507a503b68ae10557df6ead49bd2d1c3d89e265f1941e569ecd49b29d40ab847c9c63975a402025ea71341571f7aec37fcb57206bec8cce5bb3bd02012ab2b20f2ec0429098af12746e7563f1d96afff1bc05d3437912bc7861051cb416c04e1af0254afe1d245d32962a8fd3cb412c90b5e635a5bea4ca9f51ba6afdfddf0e9a7e88fa3624f0467c50e6bcb0b0cb94df6412b7c54760604bc7c4b04183245374f059ea169ae2f51e2bfc53c290c0e20ee7d91adaa44a5fbecc10aa7bcdbc7e0446fbb852a2eab564aeb0751ebf378d5803c9bc5d2c5d3057d2fd1fa930dfa4247ac4fc86642b4c7421ac008be9c4c3cf60379521b832f9daa9a73a14cd09ebc4503122814f0376090f663498e8eb7affa5fa5807e8ea2b032af2292173a08121b45ed09df7b31b59ceab7730d7364383b351b0383492266cbf9c697c5791c92cad5d6d0ca831cf26c40e7cf7d84ee49ce198430633d96a0e0dfe8620e34df51499d029523b65f84d2ca6252f30429b3781000f885a3f227a279511441daf5a46c105a10092c02027267ba5b7bda71d697168791c41cae9b54076d87a883098d622589884711dedcbfe8cf69f72344d77e7504acb281a4ee4f453bdbf663090e9dc5ca09506baf0c4232e431c05ce68899613b4c587b9c0ed5767db6ad7101a4d6e841affe28236c14182bdc3db7df7dc9bc6bce5eee73390f06a32d6f5171ac6010ce917dfef84200e851967f22932ac1f8981ca67d920948d96aa25d86dd3d79e658c0f27c3c8fd5fac193623b40a068f2cafd28b8b92f56f9f170984f8aeff48097b2700b28abbcf1be87efd35871c90ae9a02820ce91665ba29d76cda3618b139f6cc414e4176cbf83cfd808c3fbf476434e1f5653e1215dd27533757372f42c007c54ffbce9c61cfb1eb77db2aefb7787e9e51947d4ce957a045815a8d7c6345a6db4e1fd943fcf2e227fde29b192d99c7ad0d487d4fa4a42e0c4e5541593c757ed9eaf5d2b27fac3cd1b348f31a40143a6e1ac497de8d913a07a84cbf061c885b9741e944f0fd397c4b0c698d4d63f9fc11e8c41980d59b34eea6c8b2b59249fdf0573774dafa7760e32730055ff0b1a940917de6dfd09861bd7bbf43e0c28090ec80e8c6d06e8b9effab7616794201fd45015f6954b78cfc675b1ea6e4be5dd1840469f5ac2b7f7b8e4dee21238db91f3a3cc552f2c756c96231a7c70a91f53d568261b8e76fca142b1e5a283e69bae4a61d63d0af771b23136d85d7398ab28b7a25358733f7320b1b8395ec465811d684f5977f293788b602082bf1a30feb33d34aa01728b1c10749e771367ac1c29959d663901b2efc7e6e4bce739ef3df0f7dabef45eb995c8c9284744bc0eba7944bb8067506906636aa69d5f3d8c64ce8dc5bafe1f87dd4e84dde05837710c0a526053579824299ffce26d988dc93403a32d348919aa7b2306cfabb23a4fba58c284aca5a2b46b10a6ff0394802974e326c6f69dd898447a485a773f9d70e7441da421819ec8b8e1839522eefe6575248842c527f24919f4693aa693e640b60a1fa1a879fb07b83e97bf1bfd3f085a10130e760e6d2885b16512e7654a3768fee2aa932775c72c5842b37a6bcb5c3d6bb0bfff60e043d2c8c0ce27ca12560e082f5477327d0ffbb1cb96d5c0021e2bd5ee73effda9b80349788ae55683e5ec7315bfe74ff97d146439a28b6c123afbb65f21209475fff651bc16c10d40e8b312b7bf6c5f2589fd4701a356a0eb300a78773ec63b7bd31d73d97bbb9cd2763851776ba19a2c08fab17874698b54e15726d8b2be40b6d4aa83d9ed85c60e67f5bfd9eb494335b44f29b040a77486145cdcbf2fcc4682ec0b1ce278c3c27f899084df57dcf20e12013e549a73279528dbbd1789f2d161f658545402142b72b51bb8c065417a133dd0324be8c54f89abeba5430ae62689f42716d03e18d620fbc7a4c6f2a6b54e22076dc1a5d8f32de49a69cbe50770a01d68bc2cbbc51880e6e44e3f66787e14b65bb17909eb5993d9c6f79a3621c8d00399be96c39c4facb396b995eb55087e49ba66162c42e904cba9be4fb305694689ce0a3436b711ee958fbc9a038c29f7d8c71e73919b71f2ac91c42362c6e446e99d5eec89e0083209f653b87585b82ca70b386f03d553795cfc86ac95d511e1f09aa9ed9f3a3c8edf5d41979256e754a127c079802c33346f85f302983e3c71d96b399477b90ec7d8808fb259ea9e84a1617d93c4067305774d6a1ee137ebb78124e73adb88987abaf5dbb4655631adfd843756739413baf8aecdff83e8a9df2c6ae0458301246cd1883d8fdddc7ad3ac190ed40accb2bcc0e5baf91627bfbcf073d54f29facb3643e970e261271b018f46f7c7c35b31514bcecf59e3b04206005ffa739fe23c5cf04a8d327f4f79310a18a49f58689317b07a5d94faf6d2547e9b4e57932d7024c8b0f9cf7e1b707eb06b28962035446c4a713fad8e2de0ea2731bcb920e0c950e7d63d794bb1e598c701e92885affd048578868ee7b1163bd8c49d28df4fffc808567f90338d86e3ecc24bef0666f0f4ad60785d2a74afc7d4490cab2c4729dfb4fc9e15745d5825ae39b5fe5f3175f8410caf1496d22557457b401f14116d8ec82352c24b65fa8ff91bff223b3591b6c62009613b6063de065d612f02c7e04ed570281a3c8df77354f3b0193dde1efea9b55003aee4d28d43e4c10c845d5a92de87f9115c29fb4b8856baeb4b8eb589e58abb3a04b9482eeb4b18e7e2ddca1e88fc9b4b0de7301bd8ef734cacc684992ce49238973cb5ed6d661ed7465da50e531f94f8b3a82f47942b97d327e15aacaba3aeaf844c6e54c24561bac75c9e58a9fc7692bd8805b83bc5955549aa7284858d2b9ead912d20f2166452b8319560a7a36faf8f9348372fb2c66ed560f96876c5a4824b3baf8d860da558aa638fbc4388e1ac67f5151333976fe5ae3d388c3943ab5f107e8434f64e8afe2e1d24ef2e10bc90aaa62e6d3614c97ed7ed2ebcedcb953502ddd22925638a35f4b6fc5ee8565fae8ba2625ffd8f23ede713a0d862f965153fd273e928822190f0f1517fe6184e49b79d2032ea899bac795f7b199709cdb36f255e5d2e30f5a2ea359456aac568163905fa0c8829bec3c8de04e401feca102c1924a65de0ca1aefd6a72385a33b7ff29c171db29a25bd5e25384492710e6d9c8836f399815122109de4d1f8281ee6388930489a98618f0b2836281a15e954d39008d67a9f582ed74ff994b76c4d7dd3a576e9f948063ebaeabd08b296423faf94b5ac817692eb0ffab37fdb4411e3a6e930ac0f597102a182e6ef100e109dc325f1e06af90af3599dc4f915d755732329af0a4f4fde82215074b9e1701e5297a40eb1f5ead4a2ffe38e4b9c747d2b384aa8fc047ff70e343ed7e5a8ac2bc397f43fbc8a878312ccdaf5e0d55caf9b64aebae7f4dabf99bb2e935bc11f2eae05111181f5b57b3b0344afec43728ff48a326aed3bbb1630fb972e9b0d6135df25f8e91e22b632e1e3f3d2bc1647f4a1d9dbc81877835293cd309e2aa23aa4b50be373ef6bfeb8493ca40dd17b32195d834bb4352cd3c609d9aa4371b7581a3ae3fc4b5a30943cb50ebed44bf41bb1ae01515688eebc18fb2d132eb42de2455eb5575b05ec2dd22ea5e840d7abb7bd2ce9bd86ed3baa85e462329be9e4a9c88ed8f081c86609abd0aecfbb45c6ccf1b706860a335c00f287da5db4ae789b93cd87eeef3f3f1358b686b84d8634a29dec2cfe50e6eedb914ca60bdfd93d79ed05d9891d310265829852ec6a356337467c318cdd45198c31f10d06bf7c6df6d149c1fac4385eb75e867a1b3e00c8333616328abc4e952e674e957a7b19f798a1a2f7c9cf32b8287278dbf31153685e5c0804eb8641048cc674b50b81a37355394ddd796990843c444c7dec7c8c1ecf499a2c45abf633c17c7e22604774664760f48cd7f4673d274bf53f2a52532ac60dbd5d8cbd0e44afe291b509edcf06fb54251ee0d660446847ce8be94468b448a3ce8e144ae2fcc197a82230560aa087d7498e239fc973d78fc3a19293b363014e7833049d29eca0f9382e1482c2ff5c591999c8b552a6612a0830f373ba1a0aef8dc8848a72fdf0b62dbba72e4a60aa5166fa3e69f39dd5681f655efcc90f4312f56c5e5308f40c70de23e3c70e0bbe1930cd8668096f01ea81be2dc280593b0c042a97ba7c3a9bc1c06d31d14d4c4cf6de36b97d696efa00774a429f596b85834c908d56547f56b006fd8e7f1d411b64cfaf433db80844637f71ecc52f029676f766fdc51d95719180a1338e7fb1bcf5a2eb10e634e9d23de0417b28b380e3cfffeac182fe91ede75107adcd7b5281558973573cfa266bcfe07c5816dc34a6363459d780c4d2859991614ae453a35a862d8956ff6f236d09a883cf7a61d74f9f7e16d96f330c30d571da28c0d4f46bba2e34aa97aeb84408719f03b3f826f310187538b2cd06ff96304b910bc3b6eddea2d2b7b11c283a365674964d731dc8ce1586b4a786cba56ba3b52d18af69a4d13963014c6df3a09b290b0fdac276c70e8cc135670340dc4017faa73ca50b488f2607efbd789678a27dedcb4e766e24f06f6a3cd2ffd78cfd706600fcaf05db9fb77683de98ca2ceb04782a224d346b04d3f3fbba5d64714ceee6388753a9f43b2e9259025bf140856fc6f3bc61f1e2ae077f6e2d80efdc624ee155b70ebe002991c2a81cd8e85d3eabc05761d387a0d4a221735455b96535f9d7fabefe95c207298e40b79d11718fa2b92c3d781e1cb3c780b4d66cca8e3de1ca5ca03ae1f9dd5fef944ecfb243397ac5ce2736f515689fa60de267c5ad8114214dad80a7ccdd0c595638bfcfb0fb388f632297456dc73c2344fc9b1070d43c459d61a082547c0935225206495e173a177c5cb60a1200b194e4c8b2e89be75531d2ad131897cb008ae7459f2c60a1b4004e42c9239ae98d9f5dd3dfe3ed116b7c5c090a3ecd8699c7aba659f64dff49d7e1f01672b35ce8d7306fa3bd0c038df61700dccdcffeafe4eaead68593c44e200f6bdc5699194ea8e23a003127dd3dec1e1ef715b0f368c9423cd3d213d4084f1684ae2d4a79939dd09c5bc78b2c4328e323c4450ec292ad593f6645821769653d492bbedb9bb6d91ad19d4736fcd2dfed7576e95d759c54ef5e3841fcc0a0655de5e244c8104aa30aab88506820fdf2413ad4a9238ff14a0a92a86a2ead73a9135833a740e2d909d41abd578d0de50394a7f6da9664f864e87e2f65b303be8b3fc045dbe4549145c86d708d11a460106b6f90c08fc7e7b072a19fa3605a7078d54d3ffb4073772b30b2028a335d08a5ad4f8da7e47e803d42a4e4d8bf13ccf7ca28e453f26ffb98ac445ffaae34c0f4f36255354cb71024f1fb5f1e04703af253984ad59db5ee929fc6cfc3eba61a1021b5772ae00925287f45df493d67ad597df50e1130c32b09764c75acd7b06711e78ed0f04e761f08fa7aa4711b11f8a7565e16559609de3ddf54c3b826a3f25cca4e1bf87ef138c02bbfb39973d66bf3f73148d3f62dc3cf33568c52f651fde7bff8a2999506a5ce185f9b1c2653b793c6d96663758c97f2387667e2f2d967c886e9e73c489ed9994b09377106c3340de9454655b131d48c58ca0557a463f26955b894e676b81814a517514aa9da9476b8ff073d567ffdb30963aaea1a4f061217f16df9204cfcee2563e53ee1fe6b7fdfa85ba7e9fe5b285f115b5c2ca44edcb61042f5bdb401746a7128e69ccdf0d7529fb25c62ced87f63a3f4de508fc16e206c178f613e63b0bc0e78896e7973d5305310679fafcb43f6e6d2d3bdc7b5c44bf8b2be45f7541c33009f5096e9c6ba928f38c5a1c7c8305d80cf0fc668c91e9b1931fdee89d15b2f697c137ad20380593dd86029844d120d4cbfebe6f31b79363937d2975724419bbfde74874b2787557f71fe4f14d1fbfde4ca87b9350b6fd5d1168c77bdeecd77db528724600cb5f368ac362c82c65bc2e71be8cc0f8cfa15fa220e16118e61aec23f9dda1166cabec60887f4d6464bf7dd0991b4f050d5f4b47c1e26b662b580e8d577a7b417baea6681256811ab3bc273eef5eb626b1f6b1221c85cef43c68fee4a9b203a2881f35d2da40f27f46086f14b015364a365f94567f42f44fd2b3bc4c1ff69ce22465d7de9215ad775dae739d5bd370bee51361406c3c36870a9fb99b2763f8f7e921cb1d97a2388974af01d37c6fb807c1906620e6922e4801959cf3e846fb87732c508009188f67e7d4fe9b63b966200cd811ca476476b83bec1637f0067fdd064099d8d863d171ee569774c993121c03e7939782002ada0f0c0787ac5a5c2750243efd43fe150d3cffaf3d5ff5bf9e50d1caac720cd0e0e37f95d014a0bf1d529a71e794f478cb9c026519a1f9ee43f31f371fcaefca0ed92af8aa6a15205e5ea10cd84974a97f6ee5daef87a1003c1591c684fd1620f8f2be477a0ab61cf273e74687b4d1935de432a821dba24c9fb43c1408cc2bb48068d393d6e590506b5aff27f3befc26f71f5c9bb4f8691e204feaab17242cac57e02da2cb1832212382700efb4e8b562dd46c94a39226d0d43f977a71002274475bb383b9c2e5b9392bd3f0148584f5fb128be925d19c9011f861960fa2ed779343f43dbb05438084d89e8662af598b23d25a30f6af6a32178ef36f95e8a97142ad1711e6c3dd772a332e3f0de0a9affd35915340f3e198e8c6dc7dc902b3fb91931e839525052a963ada921d3480b227732cd429ec03fa17ad09c4ca4917b920c3ed8632b0f9feefcf990a33e73c7dd2c9f93be4b22620f87daf85c8d791ece52267b49cc8567d9efa5f4093b5fc91e056b836ad4d0d63956280e410615cc3f8f0194a924cf120dbf053ac9e863154d965285c7e265c3f8fbe307a2deb9a7897477cc4e98e59c3e6ba9c16e57c2a12e77d0b93f9a78944ae09666d69ed7c8daf7ad0632f92f7749beb0baa05858063dea48e548b3c61e49bdff4cf5725e093327b976c56ebaaf69428c4742ea66d4140e32fd51ac445b2968ff339daef10218d34fb4d6925c50e57006f3fd967351ec5e3ed76f8b13296cf6c75dabd677806dba7c74a96b497f2d4a08e8b496549091cb1ff009079552fc6f9319602e59411bc1fade1709d53f3b2a2e08994c53983f4fe0f6c8afd77e1c24fd227ff85dabc3b024cae85f1564dc3d04a56279e6d6d785bc57723a49d5886d19fef0158af7e61a974375a44b961e03d720506319768a82b59aefd00140894dc34f1a9edbdfbcc1bc88cb576a0c117e99c35b4022ef7b2c666c7c9b7e6416292927780f69ebc8139202e60b6badfb19b412187f396de58b14ec3766bbfd915bb353d6e7ee96f350afc99b585c6903b2e06178537c774df1683ba59915509c57c7c78ef08f12edd8745f2c64ff9531832c1b9d0c2a08bbbaf665a03c8230357e807072b480d9571555e36e39146d29dc6387570aad924febf86f2b8380018366b2f552909160a55c0cfcea7f286b0cc4bbf8395dd6306eac2d9740e1f2cc1da2aeed97f3f5f21259828402d0fcb1fc87654bd8b802fc6759412d80de0b0935f5a1ab758f27e25b8530a15c2b629c360908a23115cc80ae45848bb02e27a5cb306659f5317c754fd9fa4a18bf19df009a89b2d7118cd784278bca8acf1d4f309b11229837e1ffe569113a2ccfd9cd6152d0c8e54009e8de0484aa56e34582f8e470eb7274efcd4338533b0231687d3d8cb5069fae68705010ee7383def13507bdc56ed7085ef01801750c6bc7ef53bcfaf4cd473a930cc58dc61393648d68f5259e47e9393c31bee8324ef89faee2cd1cffc63ef535b776d93fa2ab6d8dbb2eecd39261e461a32651aa3e3c1878f3042d57dfef0c86b8c99364a5aa786194b93ba5a32b42751512d7b83d79c46da543ac7b45e7f9e7d44117b7cb7d3c2c10f15d9bd40937b5be3a7d79a353ed6a9e2d18d8b903eda804e5d5225828062f3908d1ffddddb635b59e5c8afd31eaca8811f7a480d208de5a5d9044ab4f6a887a53ebed314f44afc95e71f9971f09f74db5d58d491621338fec33343a05148b9f42c4babf0aa1d60fec4ed2af5734a9128fd6117181541f4a57d951ec1eab738bc392685ef60b9ca51709ca2a723839b45540d0b0baa4e5cb5ffe860783a41af6f7a9f88fac32710ada1c4b4520f3967f2041f65db34128fb039acbf882a17f17a115acdeca6e2e77213b57e6f83f08e751e6fbfd96a66371514ce041347ef6f0b37a3743a96012cc8e95d4a88094a2b3bada072928b70aca40cea1818e92f95753de1a3d7ffa86dc3a50327be5bf1de06cb9f96e4a318a2d6fc2dbbb40620c691098d4b04371f5004d40930c0b6423c8f53962028be673a59ace9bc41ac7ae4001df5cb65771951e5f6d69a1a18730a3f565c98f3dafaf856c950e1ae8f7814188d51b61751f0d910d30f7872fe63fe163417ba296d1f43f11c25dde53a48068a21728ba42991571216fef416c816dfc56d475f9bbe34979eaa12624382c6745effd4bb9b49e1119d3e8b31a4c773fc6e025306967d6d8725afeb1d5643e5497caa6e4f76b3a6e9831fdfa72a421745af2a2e8e56e19aae0848250a3098da95ffd98d5afa4fa9d279926be0afa1973505c6332b944851532f7222152a227433f8b82afaa7bd7251040ae644a80200a3708d9487ae90cacad29d60b5d14ec2e314dc6959bf25ebe86a97ec0bf83496a15f81ecc8f583dff18ef2609feb221f580d313cafe623f3c6249242f5e960cb5c613aa021f9e0ca7762f224bb18b79036f2c814d52a7434013e7ab64767c2527040e141418ecc200de710cabdd0684c2bddab32b398facc2991d87ff171f45344ffce83dbe6fe145a3b22773b231d05305436ecf354f863c1b631793d09371a5aa967a437df02a25561e5ae1542d866c05b2548736d9f95b78ead37b54050d5531ed8237a03d2ec28c7f4d09d04f567ab162dda958757c8fc242db07dc652034894118b729a9968f0cc0fba6892b739c0db0319378251675dd00dc296ec99c2a26787ec1e9e70c26b6aaaac33a714622a2d0948cda05403ea7af1e6979319b74cdfb06c373ab4a1863bf793ff3fd0eb7cdac766b8fea9fca421339566c23c57bbb70b745ec32893b6cf754d03676458eba00b5301514b03c16f72f3f42ef407b3347ee0f0b6f64afd5fce80e5d7ec4078a95b05e33ba422871810a080d8b3ed5e0f517ad595f3177fb8562bad69a28aff8d208db893b908f84b08ce9d1ade3b7e3bd5c6cc2fee177dde88f902c737b5f07beab96de5c5bb5ebaa957a4256b505d5da155eb0a71d3bfeec63bc9ff604d6d959367dac4f6bd7e0acaef7e96db49088bc4dd9bf2da9a20e4fe9f0eea9355ec5a01fa53242124a6fad56df6124fb248709b1116f2f47746255ddac79deee615e139e9bf0470cd0b4ecd60e2b71408d4c85c6e8fd7cc75c5c94e6131b971841778a3b3826fc463a5ee2f43b65f3ec012bd422d1f0e9628e0894c79233e663ff41601dfb7b57676f8bfb26bf375f0c30f24f861331883b224e4c5fa0b8e6ff7f912e5f2c7e2102108d6eb64b069a56bdd46ee700ced507d1a55392e1b7de5548a237d4d9215d80b729c4f55d759ba5c1a2247819c1d524472f7840400d50edaea4a2c5f33b7143d4bc062e115c171d202e6330624aaef83d3f6d400c2b28d9fc8fda4a2514a789a355300fccf54d587f1a249f483b70e2f4bf6c5220da8b49889344af2789dd43eca125e45763ee950e720425938d7a8a52af86717c1eda81ad46d5dced9365ad549831ee3c08138aa6858261e74c549d2ddf51e8e97ed8a802cbfed56f6ab5892be505885f05eaaef29d9d168e11a1edac17a7018ad355fae0a2f036ca1e72a7fe402df278ed9c311ebaf7e01c1ee27aa3b92ef178ef283a29d5db9f9e9e7bb768ae0a0f400c0793824842723f904f0f7ef4864fd4a80640446adc8a67ad8b351a5687a4a01b9d342672a5ab606f89d392476a5d703c13e1b2b39fd187234c66a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
