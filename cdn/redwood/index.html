<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a06f89f6b4fbc145c3101cd1d5183631a21f9d1c4fcb5d18d3629334299af0b8dd7196db4f8db1542939df22f766f80f40c2a36307898c6d1a048005ad8193741e283f8bee7c3b233ce4aa4affb9ceebdd5b83116484ba1fafdee7569a879dfafef1720b5d956e85c3eb32ebf428613e08c3475a8f2886703a32fd149b950b57bcbba1f56f6de7cc48f8f69a350059b6f77fdf0835112f3ef581707f184812771c23bed19dcdf91325471a74a618bd20b01b0cbe6d5b536b5daf05b878430f0cf0518977a9678120b5f20579a008bc8491535d8d01a12503d3f8a679eb42a00db10c051f637e7c33f8b4c3232ee0ae97f90c06bf0c33adad3172bb1cf0aac6407d32db04c15564b7782dd24c876a807bccf2c070e879693c06670667d85217b02b7fa68fc1493da56f2c75fcc32fc1ed30d017930513fe7d108ce5ca28a8c903a1ac009a733aa04b29bec9073d56412bf427fb4c7d84faba7385ea904d9b375aa69218a834d4ff740d6759d0d20d41ce6a982485cdddd288c374942db3dfb741ed66bd959602ce2b57b7dc862be2922a2ef3a8327eeea3549238c4de12d8f7ad3a493bfddbe1928221f56bfb5888e1cac5d5659248aa8bcc1fb7079f55747629c978f0a40ead6d937ac3979f4785f8f57d18d2c886cf1116e0912e6d18cbd888b084c9339fbbe7fa6fa0e491aff898b6d65b69daae398f28d015238b718f7d855c194f13593a0ce368dcbef489aadd5f4dd550352865d9adbc67d77244cf6050caa400e629ba99a4b0b6e1db41d9175e3f270d15875241cf2dd65a579ee0fb259b6eb5225bc85d41f60bb617adaa0db51b7b6eae2fa9dc0da1b320714a2502efeee0de45b8ab535c34e330fc9923fc82c657672d68a85ae26ae1fef77b357b5ff940ab34532f822f70f6eadb91e7c5e908637ef27b9de25b5a9379d106aa8e11d764a630317d42c04ad07876e69b56aca97e82bf27568a29df293e268bf02a5e0698a3a4dbad3384f04b4a0c84615194994920e1986c5fdc5b92ea96f6007258c3cb5130e8be2c8f51cc3ea806ef3d783010e537ab92d5ff0e3f2fd739cb9d6ad9a5bb83ae7f53a24c083f031e3bbf1498ecc9540219b93500b94c547607e9d6287243cdf9c92e9750c25cd4fddc455b688a94f8d2508acafbb2e8e3baf1ea9850051b4ee4d4d131b85814e39fbf0fe1f1463484b92d1d8768fe9fb7ca53c1c531a584690fe4c7c16ff87aa1931a60acc398c65590d8b89c0f5be971d3110abaaa6863c5ce723cb5cd7f08609091db31d6c5ff4f3605b5432068bccad67809f361048d2bd59771d414d86b738a4e9ed09fc42f02af52fc24ed6c47e31a60fb90fdb32a2a3a35ed8eb0ea5d357dd6332ca2dca8e799253413372440a6eb4745032738e9b3b66cd27bce18c28b2f58cf4974c748f3951b251fe3254c331e728084f5b826f3b49a90ab9ab6595e0355cdc942d374ff7c4ac1978ae9acd9267ac790f98df50de7c1bae8a1e13755fd3e33f830d69854ba5d52dd9ba14181d0dc190a7e98de4afc279731361458e0f55d1cea70dd5067e0a36d8501cc2bac9faa485655ca52ad6199892a024d46429c7774482d9c264ee1decee0a83559be920a5a9255744b43e60c13bebe7e9693283ef4f6de9a41f91f99e4a5d3824945b4e3bd232bc338a4a07365eed2d0117bab6c41b8ab0a4e0f00795fa0b85ecd011f0db8c5ca6ff51b32f2d0a2f7e727b90693f096985440e6e1e582ffcb95e623ef4ef57c311a46037f5ae5721d1d126c64f89cb5192e8fcc7e88f54af067542151b7fe0b065538f61e9e56e4029e37d18ef6f114768fef25de78d7989b5311e94f5d84f080c19a7baf96cd31b16a91032b0d202d8e2c4809c26edd0da8f69b2e392f60c1b6fe65d15b10097c9b79fc397b745e476fd52cad1cb875e8ce15ba769a15062257a480a39bfc0a4e2181736cb31c40279036adbf5e616284661d5c8484df90f889ee0638222c43c3a754418dfb3e7e77d993b0af3ab5988bafbe8aeda7268396b7994bef1c4a9393b399c3e40c9c149cb368e3eabd97e449d112c632fa448c1bc0f0aa8c8d463363370e1088173d3822f237c349276b198822940994d6aa8b4034f3f22038e078c6575c4cc752bcdb2eb612d034f06d8b0c8d4b631736e2b8fa4876ab1c5a9e1f8fefc7d0fc88f7d48425e2ef3f523a0dbd040631a1cac8e800105ed01c0001161adcf0136c7a03fd048dca352141c075971a789c48a283ea8de34d57f8e130fafddff91d60a33835c479140635fbc29f99c3089dbc1c289a47b40baa83daf83b055e0e52ba2442958890bdeab82504875e51852b239b3e9f2fcab93127bf6b0c9f6dd979f85b7f77f5cf8d608d4baee683b3436f0e47e5d60c74af3936680103c959590bc0781cb7ae00144e8f605e106eaf0fac5880b0761536b832dbd16c3be28d66daf9cd0a086d1a12f307ef52919e2018cb3c04445e474a5bed3bf13b54bdf9267337c0986d79a076195d6f68cfa6aa7532de80db712ff51ec02343c5892dc2321b67bf322cacaa9fea54dda613fa0ba765e50666141aba41c68c3ed90b5f1f756d623f1866e9c475b4bb3fd498c0b314cd4a30f718019792dc6aaca624a7a726efe5257f54c68eb5509bf9d56eff469ba057f286b731e029f122e151f8dea70bf4a96a2b7b38fef1f3ef4a2f8a10d094114ebdc54ed34a35bb46ba0acc7114f8cc18df43721e1cf077c18c6796dc5f78fa1ed18812a23abba930f4dcd4b0367755ee2ba48d1df2180479d5068d4e11022e380b26e7a84c3b76f4876598cfeeb0643ca4c78f57228192db3f0c680eeaa3d9568aa6671bda90f3adb417027003ef835dedcb083bffcc58165636f324d171bd0465fba6bd8d2f9b351d93faebcb80ff6bd81fea061a16e84481193169c94a9b04334148ef020f1903edd66c0f3979e3461b8ddd9025a98875d1978fce80969b0bd2ec4952524c95ee4d46e1020d060e739b04cb391db201007655f118b8f92972563ae021584cdedd5b90af5ab5a5bf2e97acdf1ab435127312c13f3c38a4bfcde34d69ff8083b7575bd210f551ddb4770ede0e7f3f72afab4b438e9155f86e6ec0e7a9402b39cb331d1b55f504d2a524e4cdc15b4b6ae488569a4754d8bc995b420dddf81c1eafe80d3a48d1424092e5bfae67a958f5037a64747a35668cdd18f61953831e8c79c94497f9cc204c1d7a2b5f0e79c23400f7db7a895a3fcfc9c3b59018691725ea74c31d79147ed5d53b432d30408861bbe0766fb2854d7131e0c150dc04869253f1983b3aab0d71b92022f3e8505951d2ecdc099b2e7d09582e3a4f317383ea67041debe8b94533ccc2f41d11fa72b2478936ff76801572de538e095ebc39d1ea818562a117dc405359988ec3707c76b4636dce21a9016d48b0657712fbedb7f01fb32d890e5e9650a285846eab7bb6a6f6247fb7257a7ef9342fd41baf81d26096018df1a05c91bcd56e8077bce105c13ea6443f59f630593207af0ef5f5f9a8dd26b3fb04c01a093900212f2a5d510f25f3326701864f6c1f798ffc8eb34c0f1c282d11cbe019a14a34d520686e7743368bb5f10555b043272f93f94c4843ff38b73c6463133577382d1ebe776171081b4dd9825dcfd54d28d3084d29e6304c9755085a3ef4c1ee6b7217ec3ba17a6f5371c09c4ce2217a6995e687c24411bb3aafafd61af08b111254aacaa04e2b0e6d323d78a0bde5c83d57c23672a80e728648adc4f9388651daaf4c4aced6f1dbb9196ca1e73ea01c883c4b8e1346435bfc7e5b319534d24bcf1217fd46f8d9815c045d6c692cbe867f060358169763cd4d23db5f7fcc96fa8aee299a3fcb6128860084ded15ac7064cb7f4aba01457df8082c58e9185871b26cffe05c51ba9d3c02ce8103172565c011143f3abdd479e6e66dcf24d37e41182f2ac9db50b853013fb5b2fe61df605cd6c03f1648d8b0dcbdfa4d3015f13d7aa4fcfc8e72215eb3c3f87909d0b91612898745c735f05635205657944009194356e1159bc5640a47f9b9eee30d73861745547f9702d7fd110ceea2986c1b2b837639a6e11715aa6df786b5aae79d9ebed229b05161cd9ad13e9f39c32bc1b67b277337aa8aba61f309245d33f0c69ee4b6177cb2aecb1de1dd43a4d2be43f82c4cb1e3472438e20f20907e6a15b82b5c82239d8f25a5665e240d1f1add473fa5eda23f4749c6957b685e51328277880437542c548fda3f74e5805fa2d8c167517ed90916a2eb0ef10672fdbe35662ad811123907fc51bb07fa07d4e6cb91c4cb2ed875c111e8affa0e7559d16ae9e673b01192b92e07325488cfbbe068a7c5bc59bb0c898fae0f392f134fc6a55ef9c767649abbf9a04e77fea6af940b81e1d549ae42c415e3676d8f5688dd5b3e41f0c85f123d118a5ebb7dc9c9b26f5725e49db45c9b4d540730abeb76703d7745b79718cbaa17c58b036994511e70037992982afa5cce89e879134d760f86466cb9a79eceb76134587317ac5f25ab7e8e374ef853d576b5a770d40e791066bdd789f91c3e636c88224ce95ab5bc54c7b4d337b10761c8c62774c309cc7e3fbd79e03cc5ad22e697a5d6d58dac21b6354cf6b381a20689c878f5df0ccfd67b61f65c2e57b9ca37a7aa4fe4a606a39d3c26f3c1acb89c6a51c7b83a3bf86923d22cafb08d3de37888039a23ab3cd49c6ac4b4487a78d7b33d95a71b851d42e07028442f4803922b49ba67e904f9f1e7504790537785d93116eba1c28684a3a6c76e54e79e2c5da8afcc7f28e0551675a2ad84dcd34318c39bf3b4c993a0643985aab10f9bf9c7a10718ad64e52f4e7c04ca25873fa4d2ea71183c3b6e95bac4d88e4f207f4a03604b5c6b8618089bd8d6fb23b936bc7508dba72645ad4f92dc7edcaed92e97f7d0f45165ec067dcc5528db674e5e1b58192fe796859103402f90092f5060c617b7c1edc0f2197ffe3c2b301c86ba8c926e7353645ab0fc220c10986b92cf5368fb3fabe3bb452d1c7608cae359cda279ee696476bcebcc2228b3370e68bf95d4770f22a3a9af2f7c691c1df56bca35bdc4501b121f2fdab2345a4c02aac278e6f7555b5b161dddd13017ad5933b11137da79ed1ad4b939c45f917811e9049b1fc7fb43cc2e364563a01472ba6a2a6e1a43dc6b111f2412955dd76d1144c3472c3f8cc92b7fcc0a989f99092d4f6990220ba076e78d0e5dde9837ff96cf56d93d04c58ee1b0f5dc15e0dd3f63c9113d8a9f90c2825e7f602bbd16c771b42b1d5ee335c112c4266442c389d2c63be9f0a99bca2a5d639984c04b834bc8bc83d7fba0f4604a908557fce8b42fee78e07816d0d85115a8fd14ea46acdce56d03146fe0e99e8d511ef772acf7f2dbe7f85a0fd0f7a5d9f436a30b92c3d2f893d5512cf8fb5b10ed8b3fe94557fbd7373e0561517421b243856a13f032c453dcf7ecd4a45e5256123698a3d075c32bcf0c00bbbd31924317b28da8bf47fccddcfaf58b8d2b1917a1c1625e12bbb9247aa68920378337f700d388e3d3d8e64656571f2140b1f72d46b058ad2562a4e419d101a8b20b49810841bc83d249b2c35964292448ede1a21dd81458157e32e98583b7f030e93a6e7f2d2d2970850a12a27118167080cc765fe9727a2a43fabe6098ec06d10db26ff1b5299f502a5cd678a051aa5f09716f1ff6e709f437b193e101a5af034a124a706dea4f95896ba7611f74bf18d9afff322ef0b7e4de7516cbc9ad1e6abfc8f58c78db38ef7ddc7300adbc6f345c1ef28f60699b256e87d8e85938a22fbee667218966a934dffd910283d94d57bfdf9a744e9b711481054aae21ea84c1c50b3788f218ae580ff7a016532f562c329270b013049950bdb6cecc66396a544a0a86025e4fb690e0f58e4a5577e62dd653231849f07f3299696140c68f8bec42c17c8469f1b1965ea7531629a349a71b5dd819c0ffa59ac1d0b4c1e1d1aa8cd193e9f5bb4d39d8f799c05e52d2e8000d647a9fe8971e9744b1765085cb7be66d185e4239d3cfe2c0293d201ceb9d60b120932ebef00265f9d7012840940725ba4101e2ada5d54899fae2ab4c2b699e8c6bca9e229a8b47f919b78a5bb4087fa8fc7989b733becfcca243caa2dabb26b8d09fdf39e2d768d0843e4eeaec5d67ca1d05afa2a7c3be6aa3d2e3ffb30616c3ecd5f55459b7c5fc8fa71c72d03a83c93cc9780875bd3d637c136d446e4d8bc4e2b0c7ca3bcc6e075383a2e8984898e2a8027cb9591ce58c65dfdfa002c88cd2eab1552e6a607b6f72cbc36c5f4a3be91c61a47c660e31d00ef064a5b77ccde62b01fc27623b8b5a8090a8ee850f1fb1001f96400390c7e31ba329abca55f715eed83f3f89f382e05f7ed49eda0793e5f1f795c00668bb3cc5d7bd1b05cabcb9b85a8685a8b96577af74bd82c1317d1594e7c140c675e28c6fd595455dfa5596f87068bc16195f9b147b391cb8498dbf89501f57aa7732bb2d58773b0e7415cab1df74f5b2af628ce875ab22d0aaf5d2bcd0d0605d3df391c9ef6cfe288e12d8d4b2788b763f2b0a621d99ac3bc6de2897254ffa713ce779191269957b1a524f98c89d0aa6a258f221cdfdcb161c52d103c621d91a0d7494987ec53d8da5b384bdf1aa36b60f96eca57f0ee3287f43ef3c01921e07c87ade1799226d3f2398b51cff57d64944d6565f37579dfa036b9d48874666b8e0948a3e12b449800c4faaa9269b40838ae69c4ecf14dfb11284e824799ff5b6a54b1ec6d7cca9e2de750408127eed2f7a81790e15de14e8a221dd59f9690daf002e330028900ce3223fcce0a4d3cd9d38b956af2814fc703dbc892a5fc8d2405c3caf485a2e5b4c302d2f28a941b420e5f157e7e0de3da6ad2561b3738d42b6947874c74be24c21ae83d081a72f8c6a5ee1673654011176df6a381c6104ccf51bfd2247d304fb0820666889502bd77b9a57c4016660a5df56b207acd465cdd1d7635e5a3f49431ab358c5d258bd511196e3d0a4025df15ae7ff84eaed3b7b0b4691a9a0fc2755b745179a95a32f61179d28a86d9e0a1336468f47f9a08b88172a360f07dc855ec0b3986531cfecfa56eb4978b2bac67715f784188679c25cdfca729a76a273c0fbd5a7cca85dd5efc2a7c6ac0532c25390bf565238a6d1b7b4f8ed1fd78eecda57251f144e67d0013ecff5ffb1b1fd4cdc541c7229ab4133d58022d87a361a197acd45ac482d32f2cdec97fe849d8a66d1593f3b8e3354ac1c3cea8ef32a4d828ce26ab7af667bdaeb7a4ef97c21f478d4486b1191c6d3fbecc96953dedbbc23d30f98889241dd4c4627bdd587854891232dca1de7f004df3c23598a46ccd7f369edee14326ef3de40b28b865e079779be7c8632f94af3166eaeeb70422c5e70d7c22068a4bfb9179aeb98cf0a12a2cbfca0694d5b13086438e5a24ef79a0d36ab654b9f2f330a80da4bffcf1a7e04566a48aa8a00a4061312cf7bd0b01de5c9084c0d12234ac3f4062111b808fe2c9e9e6bb66c93d60b74a57df5895276849ed90b5917e128dbd90958c4b524fdaf330c14e48dd45a17dade728b17f60028d8ebd33de369388b901dfca13150bae24d9a662a9d4fee4dd58210fab74a192603d515204b53485a516c58b6cee6659db19399fec28b17b65e96659e7397c5912e440fc7389e193d3bab4301550f430ce6cc2c237fa9c0f0dd4bc5f4d08ef35d9429a9b06276735100fb24570909ad355d3a9510192b907b7625c8ed6b976935d24274b10a3b5bd4d75d5338aa551efa6ef6282148d64188df6dcf473d50282484d2c23ad5eb44118a0382e7fa58d03fccf987f985d1cf579a1860a821ac2bab4860144f273c69be9970ad06053cba1a6bfdfad80b8b17a2c60505c2c31abeaeb351c9fe9078f21c0cdb20d6bef1a841d10ee4ab440194c2a5b85a14c903f00584771b59940ef80c1f7d40d4327f6fd4c6c63b58c1307e870f9e1018e4b75dd0ed11eebd730021b9f86486c2b859639631d9095e77c4c55dd2a42e902761edc3c569aa64111979a42ae74c41abad1df168c9b5faf92292fa194655fe24faa3b5c6c2f4350d608ff35fd1838754e3671a6fd37a7b5e5c4abcf64bc685746e963703582338df0491f9457ebe8a348c29f20e79218691288bbf92270d0a6c145bdbfa7a4d1551c1a2300fb63bb40e789634564fe3d2da1880c203ad11469c614cfb79e7536cf49b2177bad897fa012aa4d4132e682776920a9a191ea45aa671efee6d6cdbd626999a7bb3f04b5b92970839ab223a43128293c79c71ac0715740eef07093c91839a78d5721755c73b64cbaa3eefa27bc690340b56a7960075024f9770794f4a1665d3deab005c5196da2eb9f05ad31f1e93bb8c8de1695b8dcb57bbf5c451f6037c3003ba133bd64cd6f53d3af14e41b536baf0984ca7f3014047c427f90dd9b255095d21d7748c4a1f0d0230c6ae885287854df8979fa8f7c3aa701d606f8d6dcb42a3473c41bbc35feed16bef2ec07d9676f96dda8b52d1f881fcc90883b7580887f434504c1f229ef414c686f0ed22cdff3889bc1b3722010efc84bde93eb02a04a89306ccf519001de5949507872d9df212a7ab678d0d84abc6601212e526f1ab5af4b07a77f434d7421138e74c8d3e0fbfb882fee108e4900ad3e142ff8890438b9eab30b05b9727504cc74360d3930937932c8737e6e8459778dc59c51619274bff47cac0a5dd1716fdc19126401154dcc86cae3b0ef4531b58996e73abd94b5c4a0b67e031cccc180104a11430077665507764474330049a7599f2f79759cd2581bef5e3a91b86caa79c1cd0e18c0db1115cbad60f8432d810785484751b0d6e3e3a9d9a72e70b38c447cef21af4d932c98b2584482306ef926de122c4de2e3bf6e810d190977af6a55b0c110aacd3b0ebc65d9255c513c0768ba4d6bba9572790281119329e116a2682f0f85be4a088b446467efb3d6c575666ea2657710441c381c78919e0745e37dfd192b84c2998dccdd5003f44955295d8efaca42de356d147747766bc159e0b72c4da47176809a5b0c7b7126c3a39f36cfdb8646334c6de49a91348e5f563c37ecd41f49052cbb0c93695778ff6e4271fd5fc3940a8adb8dce7e9ea31de94e759f73137f004ec456c02003b1a1993b8cb329e21d94454788087714497bfe49786db3d59bd49a2c3fc5f00d95019e451759e6b0510ef30ea3e63329e3d7a1dc868aef7eea864df6074937d65dbbd9d00b76ddaf6df633b2a5e8d49d2d1796567196357a802dd7990e76f05a937f8465a70c718b3cf400437596636d2a777297450c8985982e811f2b878de2f449425038a6b006053d48a4e899d4f0df4a340f6c42d95c5359e8ec059768a1a9d35568457a9d0b62b06ca1a64fca434b862e414ebf0e852c99984d742ca103d1ef30a1cb7087ec95e76430da3b4068930c134f724d26df55296c23e9a333447b35658755e5d7684bfef1a1f06113501e4cc13efbebe7160290d340239a5e0b10cf60a011623b31199a1b4e343609e1847c9c1c5f1371c7d9158319d70f6da31dba9cfb04c7dbf353690d843e1fca6dd0d3e86937f1b944327fa34fa6c9e2be5ae96a40cea1527a5f6d68670e2fb9287345b478a4ddbcdffb486efce2d038a29e0963f515718ad75bff38170f4922f4289c0bf77248c2222b473a18f57dcdcb841072a65386433806d68ce7e427f67cc515955d94edbb65cef8f02a202ac8b62a91e6c5dee43d2b16a0c53851a755854cda76b93df735140894ea715549efd41c7e57fcc586f4457ce1342d7f0e87d5a60f581680dc808ce485d627cdb493a1e61559da029aa43d3ab5f5de9b9ec3895c34df997b7a169a76a903bac9ad8fc21fd7928ed6c1fde0c4903d0c292de65a6eb37b3a4ac5eaf77cc9cb25714f7f830f17ff161ea625fc2efe91ff1ea7af9b96c8f6bbb92aaa3b1c2203bbe96545f39f3bdd5edeeae5a834d8153980f153ac03a8fae224f1037253d8f92aa95dc5acf9294d02471df857c5401e6147b8c37facf130fffb6d59192af244821dae7f68d706ee7678c2c92522ce50231f9427ac49a63e142e92253048142ef960486a06d134bfe05a7d0842db873253d51644de94a5d69311e00ddf01747780dbb416a3c5d72e108f7a5ceadc1e5c85d7185b4bd4c82cae3d76195b05b11f2a78f8737a6bb7699320751fcdc64d3150a605e74d1f29ce399cd8a04fcddee9918357825ef1f835752919ec2922df8341956857b0b62998f9902cf8859600eece5fb8d7e6cdf54d0db3508520e6fd61b149d71c9349392022bca7d3632548d8aa3982fba6d61ece66b3bdeb142b4e42407db6ff8ba68634cc49f05e2a266b2e492e8be5098eec8ca6949e884e46c78c0a8f7c06aff96dbe20e8848bb53240096ebb0e6b7112b4792bf773098e7716063b590ddef73ec27e3b4b2d4fd358df845ed8f596bee36b77a916a08453af09709a8e4f14c18619421d0d2d351dcc82f47ef37bb408d83a406cd8ff1db8bc90031b8feda96ff082fd4d86c25f8868c38522da587b881de9382f645571197cdd455349e6c1c4c4bcea590ec32ca1ae8b07c26caf2f69b0a161efb06d717c055ef6487b205af50fba8f6d655a733e247400894d6a843c31ce7f05e0a85c69bc9279d8bd5bce743113f6cff44e677e652ad2d4b2d51b7a2e7a89f1d7b79aae21e6806ffd9a655dc2f733c564b1bde42941da2efe1a962734af26eba841641ebe029eeec5d6b85aa87f988e1f04703088782587617375774645cafd1db14e16c04f605f14619f9077bdd685f8a797986487139865c69271cc8df117ecb4dd870b7e23a1d6423eedad29fa984dcc8bad878e84df56a65d0657497ac4b624bf83be35e92bcf8e9c17ec0e485f7be093051196f937053f1b9351c7d7543dd278632c4d7d48530b22ab8dd2b3c532290ff1612ed6d46992cc4330e27af802174fe8462fb0f8e8669608b6e781f04b148c0e18e03b389d77e71953e565183a258b5ae911e0da03053f50f23246e1d672aee65612ed7ec90b3a98b56b18bed4bc3b4f8e4262b2e221b57bc0d8a723abd5e5c9bce0388acc33aede78162e99abb8a0d8401e9680863627bfe14fd471560c1798802bd9f61e4e584139d852e5de19064abf2269346dd71939e75429ff46e3150b403229a350dfa6413dba030121c90eeebcf0d9f9ac24bea2c8eeb083cc87c2005678337ce2b85c4a2dd2af0afa9ad20dba4692330462c79cb2339b5e69d4acec5b7eb6a80fc591053501625f6637d1fabf869019702679e3c2186871d9aea988139d70ea132614c694cd404697bd9749136e032b218cabf25ab59b28932d1105a99599ef4c91f0e756b6ccb61cfbd41c4f18a58f1058ee5d592f7a965493fb1581571371ccff1c40821403b78fe4b8e030b9b238d7c02000e2b02c3ed3c33fba601919329d658499096398bb5de53d3c9f72957cc28d6cce6cc5a1b8a95b1a4ea5403b78643ad685eebd2962d774677252704906ec76d6a6eaec58b23f8f2d2beb979d540e42c071bfa3fed041ba799f6552b718ecc3017cd4a11c93c7122f79209c597b46f8fd40a5fa85b1a9863a6a32ad286a17f1ca5d44b0f368693e7927298d7956bb5fb3e8b0d6e51985d6ac9fc2de01becd8445a1e806fe61aa00c34ea03f127665bdfdda1009a641d82b8384be6e468e2a7b92cbc0b1787037d41306c8cca84ec0886e92b1a62ce4a597e5a671244e5a6258777b241a68adce14e3c9ad88b9f3c719db0cb6ae19a5f746a323abbd2a2220617b11b415457a05ba5fb883bb68cb076eadc76832f7dae9ef527e5822324b97fcc370182f03fde26685100700431b3097e4b59cee4d6b182481928fa4141ded2e77bdee87ce26efdc1d267362b1faa3b9c35ad7f7fec13ce8d858e580ee57818b14009e2291849122a9ff230aa4d35b9f85717945babccca561b0c73b89cc46636f3fc2f3c15fddd56288fb6c78a6c7a5448987fbb4b57d55a145cd19d9ae5366d69b1f3b48a35bb5d5a92b232fbad542676f6ba18ea7e10694b56df44cac3610cabe0dd273b4aa523d10e61b98aec6450b38fe92334b57ea2e9922317284b7326b29ac3ebffc86e133f07f2f0890cd8dee4686c147ff86a069711333546800a738e536a479968ce1a1299a215c7593e294e2fff6a3a86ab7796b6998e5850d749c9ede4bef911d0b52e639c44c18d51e63b2b1287004d9776fbb5bba6526bc75dd0cd2da52cfd1b9f2ed21bcc44479447402711bc65ca4cc8f5cdb14eff7df8b8ccdc05d525a646ef86f7f8afb120bc72e4ab0701ca8630d309203f252820e26ed8085355f174878c464a6203d77d228f2b3af8c60023f35bf5073267697ec3d413288cfdee78a85669f44effa028fbec5bfbb512b92c1d26d36823b5a1f76a3bf1643136734c20b6e4338aa0682532ad48fcd962e202270bcb0c04e573bb4e75e331e5d4f10c76334eff37d01b85c7089de2acd8ca391c06950d9aaf4e1a6a1bd377fdda5a0bd0ce4931236f2775fa833e1f2962314c509e479331152f1cf5ca4d3d3c70df4f47f139746b7a2447130bdfd38a5a29ae7194db176573905b95f12d6227b74a887fa87a0ca677c573b399a9ceb942e672d21ed5f92072b9ce09d599e5fe2970ad95f862c58d4a805ca4ef74edd01ca748a47e565e842a808d0919bd71cf35d384d89b94290ff594b57499d62a2acb075daf2bb1f48e5d313a523253efa62b0972eb2bc03e75b65014601a1b41691a7ca56c3e3394752263fc52ce70b2e3c678a4bd54de0c30f5a386e336a380d1f5219184fd746af9bdae7db23fcbd2f12c73539bada6cc079979a0292d3af45bcbc9985ddee94f539028e5bf58269598f62a38938cb7ea0b33e7fd97223e24254977dbe625e2793060a519a4d2e8093f871099dd27a43d014e837da624bd056b02f85f5f4943446d564a250fef3ee907f2a28983fad283feb609b37bf20095f2182be16440a3654882d795fedc0631fc723e1a4009aab80c4c3cf7345ddd99c2c7af82be628d23cf22f77572990709724c75012cb95ef86be50b43ab496bd40a26758e724a502fb13328e52e20eec75f2184e2545a636d9c417e1be6ec1f6b2118cbfc0c4dc964cb43bea1931d5d30599e93568c22970becfe67ae06ee1efe6abcd059a71e6a7209353db74bc09e4860a802f5fcd7f4607f04abee1f97151f4b6907a49352d69b040b58a62e6e5a47120e2d5ed592b2e93799e86ba034253f1271b7be0b41f8fad712ceeef82bd95cde641f419c44f159ec9b29a9903f7aba0cb9e476b1e4a37a354886854d6f3a3efea4730ee9524932f148a72f04e482ecf321effadbb88a82f52a1775fa95edaef626433fe0501ab6cdae9581e9d2771f36cd08df9283daf0daac597f357641d37ca266181ced69ce2329e6823a0b18234e8254d156dbf264865416262399c2d53009e33e24b8cfb4f4ddb1b554052cd7697a8acf01aa5391e36e7b719fd5283a8ce2500b144b3005b9896191805cd31f2ee9cdcbcd463b78e00fd7a646180ff1112316ccd1b2ffc91a8207011a26fe37213f51c6d065b873b079456bb72b72aa56642a043dae088996588f62c436769df18738b93251f4f4220af5e9d7487c32265220ea208ec43b41b15886dc9bb39c3f5cb010acaecf11f2d6a5c5a502d0ef75719cc26b27263fe7fdfb0298764035380f9541feb3d2d8f5b0f37223ff90fc6f20c103ba4f0668f051f1304de11dfb031cf5cbb36adf4158874047a39d4a2be5181c066f4e9ddf8bd3f0257a44847750ae3e6c95ce566b3d0d5ab8b8350acc635bee5e75877a91900c4e6db7e71af2eb59d5e2c5dd3c9b6f17c27879eb5122383f028069546e184008a4085d1aa70d13eb450d394fa9e99f129f3813861f3be86149c0cb78561fad78a410a8cc9a7c5f011cb5779342b52d0d6208ba6e00d38e03358b983ebf83b5471810cb012e13b49bc54524c4443a012b4aace676b0d3329bc3967b8cfe0c91df2b1921077dc037291cab74d64ca24ce177276630311603bd6cd79b6db10e60f34852b7d92eb5207eb08e62f8bbf16f7f1958b99917d17c1dff48aa7090b2c317730187f72a6a3f39a8451c79d5c0f8d6755cff0466d967da3ba9eeadd7eb4ffdd4fa1ef785b1d644c14ceb9852bf18adc75ee6952ced7eb762ceb012d766afa8d4c61e919af3ba32c5be08bb7ffd0a45507ef189bca25eb9b7aefb3191d300199d2c84bd0e8097f1f3f89cc1882b5a643138c5608419b6cdb41273d3b173ad92260af872e21a433ee44e5dbe4d6409bbcffb633edb48743956a15d66ccc785dd99606fb38de4362821eeb2e6ab0e3a0c718d088f3f4a7bd89b362b72ae186663b382cb83af4aab6920791a61f0ebb98fb5a5190342874ff3280131c9b58fbd03393d8686dea23edf46e563b742c07ada53fcd351034c9feeeb3b341808fde5119fb8b600f607d83469ad6666d0dc47dfa4b52604e632ea17dd8291566377c2ea56229be4246f8d881374b92fc59fda3d0a50a0de5c498c1b4d68c15b6a5eccfdb05ffa9de20e090af198f66b3c2d6041364c7d95f6301f597f6a9345ae3cd86e3bee67710f2dfe18d6915781d3fc0a7642cce44c8b6a5ffb9c482bc905912a718ee611ca1074aa1073300f30303ca59df528337ad65fc3fffcdb5792a2f5ea79fdb9505aba3a329b6ea1652986edd18aa95e4632c8e98f7af67e3104fb9711289669df6aeab2f150c196e1972505166634af37f3a9723d76064907030e90772a682cfbef5e5cd664b17b65ce28fcf710874d905bb79c9baf4f209dd2ca02759e2229637adafa9d1010e6dd3419fee339d1720302e5431f3d92473666fb16c48a1c0ede70ff531f351f8a7ee893faa3f4eaf2401d4a95438c7dcb24c2458ccd52123854b9158504c4a7b2035d627e059509cd6a237e009c2f5b101265d798538c1e6af4537d1d7afe496a01ce38a302520acc05a5c0a41736f62ee3949e53d7939f456fd0b0aada1fab5104d1b6b0ec1ba00c3086946bc85b6b1e8c9c01801493dc94be7d44eafbf07b69279f24684794bccd37ab2ae5bdcd4ef69bf3c6013543e197fba6fe79af8fddb27fa708919a30125a2e8df5a7faaa560140bfad6905ba78eeeb235981844981b7f259c736644cd6000f794462aab9484bae869d6ed516774a845b101a03fc7c8d11e87ffbd141b295a9ff05683dfcf60f1d0223a3206222bfdde33ff673093f714356eb7f136e27c02083dd97d7546510f5fae83227938fca83a67cb3f58a9f7324070bbbf39d90657eb87b6435aadccd72a6310f909df4c161cb4af491c5618867518eb6be2810f7bb224bc1e2fcbacd2e3a097c95f02167384c2874222a56f539000e751408b27559b5e3534642c60ec31093f36f68d9dd2ddb66965b17022f8e814a4f82ad9abf0767fec83315a6ef279aac875f092f9a0f8b31e269aea09ebc56a5072d6bea5fd3ceb18b98349da076f7302c7d30c24003eefc7091275592a070327af461595951dcee6c8fbb40a8da9436d1ec996501133e4644092d5e5d2002ef660b2141f539f8e6371d68a4ff3d9fb5a383df35ffac0a5cb2a202299b45b42a24ef7f058c6c3f8bc8aa3a6cbe06619b40e523401e5bb8b2b04ba390c72ffeff9cd54f68825411214827a43e02a527878ee6a4af8bfc92fc1f194fe20215999e70fee5d052e085458e9fae3becd8396e07161ea7f823c341fab7aed64ab11d4b22ad332d8ec25ac835d80f58b60f2bb635b9302500df0416ab892d1295ecc3e99366b74f31d45d668f382b06eb777ff36f5cd24500ffc58477d4bfb110acb554ca3bcc042ba1d105d6ed0544cf1fe2a3e144014606ca84295028733aea1e6463f38cca189d4016f080de5ff0510747773b939703c96642612bc5a77587d54b7fbbe5414312494192b008ba3e33c7090ff6c6f05dfa32b00c2d326957aca5ba0eb4114a9f59cdf05356241d04c1dfbf95939c575ce3b0459ea11d5b8a6b216d94cf2aee092fde1cbe98c7df8ad566410db8b42134967b381c95c891c3d82795deb65409749d229b4e81b2b0952d0f7d1d7d69c1eb707e53400c1387ebbef788a874e3f25922c0da90383ae611de942259f5db0c141a1dcdeed7d5562a9fd6ad6ba5bf92127478c540ef6e14380c749727b5a6bb339d8c8001b0a3eb801252ed328b510ae7d3aa4a022a9c95648555c5c92756c503b3910ffd3b9f9652402669e9afe89c60350c32fe79a8a41c69f39561317276b27b6de6418cb610cfa538a708bf9342a4292a0848a2531ff71c509a275c1f798db4be6dffeb7b96f8688bbf42c068f3c9fde0f46d3889e75088ca6ca2c044eba31385672ba7daeeebf29d8a6bc2804023557fb93cc09d5ba37f7ae0d7577bd89f303ba175a98a01d4070f849efa8ee08baa93e75df04aee227239a078b06afb2183f2a5b21db6b9b4b1fdd31d6056dcbd91d088e81912e744996f5fe4aedf9254c3585f20ebfe060063db86c86532bd198986e061b7d5a57c8729cc3b9bcb9f37fe3199121a764cb8da7977af83fd4ffccbc6dc919643e97f4d4578ef3e809b97fcba857b46562315dfc71e5cec0e88560c4f7a716ca17f0ec022855c54268f9ad52658403112336b92ff79a00c8ff3db615c3ad45e1ea31d3fde766100a5914b4324698f4fe02e9248cd7599e26e96cb01629bd103df9614b0bea6222f6ca651d24c6933b28e6273cba875a3a0d2964b6e3b3c4bea0d896785e8cd54b8bf714e4ecc19ad5ac807f402310a37cf68599bdaeb2b0f3022b115317f2a484270a4ad307255d70983a5ca1e152ddc3928a9787376c5cad057429a945682d87d495673ef401b9899692d5eee37e60f817dd68e704358df3f2511dc20b24339aa3eee3d650dc7225e149a5f3269e32630075eaf04d2372dcafb4fc44a3684ac4a9d158bff5056b9e985a0572a92ba6d30acedb9b1c24147da05aca46f95aa404f569498886ea8c871e60c8a6868e87cfda51366b714b228ec9b78f97b7568bd8a137454f83b07d20b37acceef417c13c18268c22888de1fb906871dc072c0e94306f837123f542d8dff8f9f5edc12329b816ccbed7a071beb124e2eb414f68cb81b925f80d51a9aa7dafdb6f09389d5ffd83b2c803149e8a8f33aec0912d9f1613ecb7ca5bdbfbb83bbdc6f36ba7414f52c839841ff726fe99e9378c5990e1d5d7d2cf3d2c848c94d2cb12893f8da53aa9ceb1a523befdabd7980ade1f315948758f82a6ac04830bb7f57e6fecbda895f06517e72bed9d8c8eb9fd6a2bb61f2e71a449ffb0f140eaa82916bf44195c27c327d0b4f6b97dc9f326f0c6369322fea75568430aac5f00be1aeebccdcbc168b4a54f4805862d9e9574b51fd98edce272882c8b714a269a975936d77665724e79ce5e69fb251c464568b43da87ad649bdcd371dd496b0a32ecae0f387ba75e2a4e27a494a4b7ffa16f7f41cf8be385da91fb056a5910a9483350637b6e07c7a86cbdb4d4257e217a780064c562093d418f0ef2c70b399735713e88e46486b6877d212836e4ccb348356d7f8a0a50a7e58293c79cc49b7cc770fbb24a78f2555bcc2810006c499c42d61c5fd32f5c053af344b3cabd7afc1f5063210a06aae2fe4c34df03659866992dc7b9ef7f5000062abb4fee62750ec51f304f5531165d3ef9476920eb5b483dcc6974346a265bb2dd226ba956ce209bc7ba478a9098c7369d857f11667e77244b419edd7af645a4b3472872b2c328707058b560f759e2a5623aa38c8428cbc79567bccf377096f14de77c9780acf8d7f35cad7723be82023a01e7620922a525d760ec0e188bebcb5592e8805f4645f26e10d99fcbae265e6ee47dd5468d34c2bd82dec795bc9d125415064340e9b8fe79c6a806da950a2a5cd18cd01e820b93e0290e3a7b4efaacdd7a5443209caf3e1bae3c0d1a5b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
