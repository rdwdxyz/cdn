<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ddfff94cc1df812397b6512869b0d57f14fef5397a35c3926c2506071e804fa289fef8a4cb39bb35a627b3db49759a4bca5db0b0903479d6d69ad1bc117ec1cab317e806f110edb722bc9183fcb03ae3f2d68d0c8a1e0bc87ec5fbc426e87214507edefec2272c1834edb9ab5e98d4b0bdf3513707725f6bbce15466ccee93e3f422964d58fe9ee300b97db0705021693f43be6accfa595e713596268f737e543762034d99508807e6aea5b448bccf6fb45a3cf798da00a90a8cd683d280ac088edab4da92f42550d120f9bc7f9ccb5557c41c6a09c3971e4fbe8e50cb189263271632dd6a215560ebef45dcba1c8fd55f7c039a01240397aea0c192fa0dee174b3b72503fad936c213edc1b227554486f4be97522c8c3e3b70ac644a743a271346b7136b4713eb0a64164c27bdc952b18e841edebe8c99c1056bb2db0abd0b9dd114719050e9937de770087f117f499f009a58c5112767de221b639630c27956b4ac75de02ea85a88bb6bf41ec2e8ca650ad2dae7a926c73e3fa21b08412e3a15aaed0f600daeb2bcdee6dc022cc58219caca8ee2df1deec4eced6dca24e70335d449c9cb4ee4858f66531ea3da04aa85b1f843cecf68e24b12c898aaf5f457a2a626fe1c58fbd91d77dba4f4256d513bd98d5c9cc0029b1d801e6ef541b34042e6f6a5bef57807e30a37a0efd822f54aca17f5e8dbee07218315e5d9d1f2a0252a71567cb569f38dc6392b7e90755aeff7b54f41f927e1c3f3337fa4eae869ba0658e39916e6e48cce6ba24a7364bf6a6f58c298fc52d6bb48fafdb72d74b1162008e565d37c59c671d3c0871a9c9971b3265c5598175a570744300a6a8f476f66726c9cd456085a620c4d65706e7bef9b48e3f0f135282a4345b887010349d7a2afbe15551cda40ba451edb4716edadb1988e8b737f277a69955178debc12b299f4f90fe9764f600afa2d7f78340066320865bcdeecfd6e5ca7374cee05a84c0ea7c2e7cb0312129b81d776eb372a90fad628aa338eecac164c0b04a5b50ea954498ff72e0a2b21fb0989aac05d4bd43971d1a8e77428f1569cfaad2ae9df36bf5c9f0a2a485cf73a7cfe6cf98d4ecbd4b03ce747f5258d1a1216244fcc6ae4182274e6fe742a995f86c64522161ea2aeabefdf2e5207a12e08406a8e167b9a60dfb76d7248ba4a16d5917e8d33b6215882358450819dac08a4fbe9400eafb51462ebded9df021a28ecd82264e3bc130541e32696fff7c6971c57978d5b7927c83e5871a4eac44094ee5e9ac8fcbf97ab6a44ce39d5497921a2798d9b407557c7bfeabc850c85dda9818f3ba3e7d95108a55009e53f56cb3cbef02be3349010d7ea39f331c3ac14d2004a7f4af152be63f866d360640cf90348feb703cf6a72a3f55feefed2845964c07a4e810723330e2c23236d59f67434f54777de6b76dfe4f1f88e8c58a98058edecdb1f3b8dcb37e39a6798eb13aae63b88175b5502df9177469a9d2499556806e1431db49772269000f23299d094869214ce456228f42935cfee8abaf7604d7633807a42b4d6a89e4462b763722eeec836db5ba2c9f2f66cbcfaeafdc0d8a5f2e88ae1bf126e9ea2663e3a7de797b09438174d795e69ae3a39c6803ad504ea31b19bfdeaa2f46d5e763b63d8ea69da0ec894e55478cbee30270269b15fdffaf3b66c06d2937ead6519397ad94f2a928e403b68db6c98a7330095fb70b7fce6712828b447a639804a58e0f9c0a1bff0e2ec7a89a6e53e93d4e1a27593847e4c0aa65216873a60f3017eb5949c784a1076afa5ad2926ec39be200338d0d5e8acc312a11755be1cf3bfb5f455027b0f31833de7e901ea06910856d8ef564c12939c922faa4e3e4fa1925b0f99683bc36a2feb6967e4171d5f983afaea2dc3aea80789849afcf3964330dc2bce495a3d3be493ba2597e06422789ef1ac0becb5cd6e1fc27728e2f7f53dfa29584e3e04643946a1e385ee1edb2a9385f2335afcd5b8b2a6f6b7c2c1f7e085f130814eb192fb16407b334bcf47be108b5c3219fa48286f75c162021c2085f79d9ce523647a75e08623742f484eccda437d7a4416e390e2aaddb3290f399b9008746585b638f1867715b855e8a0795573abf3f4f84b67ed3ce4c7c7214c7e394cb6a0f6ce18e6c670842f773cb8b8695dc2496b2459a1df9425511a3807da92bd989e990591fbf09072c0fb4c0dba682ce1981e0778cd6d440624025eb7e1ccf79c5fc64e1b7c9e35e9eb2fc0d3e62fd38219757d9fe6c2cda2f4eefb3cd4b21edd1941f6b0ea0036754086a19a6ffb3cbd12d41d22371d7fd7cb06b1626f1bd4481c1c8a904d17247e022fa718506ccdd1081c509d79314da7de97989737932f4fd59e5d1f012736bd3e151839d0d244ea59c0b3d1b9e3f56afba9dee50a7b2065e47ad301e5ac7047dacd1db4e4526677dbde1468ae7f88f20bdf3fd6c4bf9bb005c6f9f17d50e65b9d402434d6c27a32f08ca5b283ed17acea138b92abe81fe074c11fb1c25d0e9f722d30b4838ccbd2961a048504b2a34b19b94a1effc7108703e33f0c15af8e2b083f6f10563c7dbadb2f3753f24419d8938cfe9fac43f5c5de676608b8ec87cbdc82edac0880c33575353c00f65b8ae70fb433c31e73ac0f43e41df069d0cf67d29dce3fb0aaebba28d519cdd49e298f2246aa0302f31ab4aa01d51c7b92686c9835d0433335d5e67f06c23926d5a90501d87fa8b878a1ae605b7c963be862146de020552fec8783fd8a9de2257dd248cf9aa21b33c1789b79d39e24067d42196b90e7166cd0c69f6097cf46eaba1c11115747baf20279e5c5f7572018bdcbbaa8f3615807ee52bd810c6ed342530bf8dcf1e30141d5ed396bdbd1226f08e2aeb08000bd74917fcd576d21a35acd304bce64789b605c143bafad9d28ef0fe8ec1f25fcf4dd20386af200ee3049e4a0603188b04ba1096a1f20f4c97a791a9d8985af441658cf0b9a5109e769f3e7428b684b2d737d4f161cb150de88922c58ea78a54f609999adc76339d39bd3415ecdf6eda485d5d2ced59be43e7c736125a34126b96ce519b5e7fd55fc5ffb525eedb3286a4617bd053de2fb78ac516abc4f5d0964647950f6b28b23a17cfae73cc247a13c525cffd1c6defc63c2dd65e536d836f799b04b5b964112405b917a4469e8bf9625053b237161cb9c56473c7f8fd589c44bd25d90be2bb97baad9281ecb6085008e812001b6347289b327edd982687b60cce71ef4af16ce4cf733673110abd49fdbb2987da31cfb7b1c43307e8730543d94725c2ab372768f0254b8f00c19a21342bf74fb8ec52266e3d015d909b904eae46bb81cc1f6e86f3cf9f46217c10de49a992a1e6fbd1407f46abc1d8070d76c137b1da4064267ca27554aeb69725fb4685860f83a43a0260c364f7e392355a3f396a9b27446ae14733f63bdc8858e7114caa19d9ec58eb6a85ed100ada172fd7b2b1c7e0a03e9d03b55dc4d15fed9f4798e943422459bcd74c8ba2ee0be51162afb16a68d690a816463add7a458ef05b30f5fbe7183707a231e81e5e837f86adde245ecf1b19820cdbb005abf913244cb6eca418be95616b63076aa844bb48e2cb1d51579d161f89899e76d5600c3a38ae59b9bb43f99892a076a3e2f29dfb97a6eb3708671130373664d397c4b23b0a640df25fa6bf100a36d2e2717f8ea7c38413dd84390dc0556517ef8574f0ba6ae2fd38089a788b40809cd5be8baa57008514f6b658d77d4ffb19935c1550b24ae9112f16bbb19f070a6a60c3a66d985bdc1a19661af880d6f496de3b81a1ada78ad7480880387b054f8bf5a72597be9f8b5e63b6300f33eb8527a62d6b93d4328693cd48e5a2f101c3bd3619602c0f480397f7947563896c8bce554ce9b3087d9773a3860047cc0c78b99b134fbea38dce675172e3d0f5f5c6f8efab6306e2292afbd9bcc37f8107da458acdf2342a1b7b6282e2f10dc383379f57a1ec5362de961e47b8fc35a9d111a9fa54ce7e9676378e7fd851c26694dab2f36ae8c7040c70387586a449f2a4d5c3cdd783a00e03784ad5cb22e09d22b033ac5cc8f659e76446511f3fafa70cb3178e26d8ba52d44c5c29f58e217ede4051e4f3906b01f55c0ab5e1c06b6623634794166a32a35558940a881d1525971697c3123ee8fcad0bd52f5ce94ae3f4fb7c403930539c5b54279bd9312a498e7fe3323055aa9cdb9e6ec028940d1df68e7ebb714c95cac2570fc02a0370bb43a5e3c67ed8cc488e5ab099ed4dd6429972789269ba49fe9df2035cccbcdd346093b9bd9211401e1a43329e8aa994df0ccefa94c464b5b73fca9e58a66362bf466690f7c7acc681298dddcb9713dbd7a3cc95e5812cd008d8824916ed2ac984a202f675e73b60c4a03ae5a0c33f02a3e0d802d2b0d6c9b0bfdc561f4d6e27a374360df3ede3bae4849caf842be5084be4d586610dd5bb0f33e5563cbb8566b6d3ba9388a0e8245798acde42125ea9f3317d252a42cbf3bd1a27dd530de0151446b0db3f76e2a81a4b4d8cf39b1ba9fb42dda744148b434ae38e93e70781c07aad57dcf9932ebec3a4a0dfe27dab3b4fe478dab522530a8ca09f539963bf3d3b68277e513049be20a71c83dd52b7ff44df4f6b1acb9007e71bcc29e02e8d542f81278213276ac51a9de68e553e1887f5d7847659eeca63421e53c0fe05f2ffe13af1fea9d4d086b56945a5b18edb3f4e2fc3ba7a74f1c3c9e481f8852f97cc4d823b7c55a5dddb93f4086dbca7a8ad46ac531d7136652714ec8a586cb9e01f1affdacbfe68481cdbff9e2c6e37bc757b8cb629d7676b6a758dc7a0bffe7bb4f0d1ce98fb2adeba2171fe880238f0183063bec2eeddee1d0e8ff5ac2caede18b8130797a22cee3c43b1cb47602ba7d0ad2b46f98bf795049b5d67a0e5a46350700b6266328d3a4110d9678e57c069c9020f6603a243995900c89038738f82aebb1283e7bd46946c56bfde4d6cf41b276d4de0b5560fc002cde31cd5ce7cae24530161e0d345835c6ae83f7aaa557a44be3c5f9153f5b6ba9392e3c78a111c3c7583e696daee80dca7a54fcb1b560d9e31115dfcbb47c60f48b9b407394495d4912b7a2415c47adb0dcc5459089ee45c00ad939c7f4a89138da25a570fdbaadd500e6509487fba3874ac43ea434bdf0efe2be0330e4882258f793ac1391ab7431fb7c712c3169754fc0a32d40a90656a20404d4d4093f07a6d351a7e06600092ee8043ca20340dd71ecc625068ee892c290b0b7c181a7c036f4f09bb54a69560f72408447f6c820b205ed330d6a587ae7430f309e42687edf4e6127fa8ff2b053f1f2558cd802e207347fd9a8baa6434b05f334684a34996a99685243d5ef108c2a7baa82cc1a39640de0918ef4a6436045004415ca80dd5d5aae8acb5cdbf8488c7476016a570587fd16da007841f7cce3769469a7cf945b82f650a0280a59b1866ddae338ee05c94db45b3e5189c1f488299d6fcf4ba93dae5cd12f11ad0458bc60197d2272f75b59bc10820cc2352dffdb99633d5cd834704cd25523862100578d43ea7d4110adc89c575ffc91818c1f0b73c3c4f03fcfb916896505423f8c8ffeaa254a058c2e1a8d41ebb95e860d8283f230fcf22d44eb23dff85932488dc92da16d7cb4cfa20510dabfe23f1de4b6b729606a9bdd2489c92ba076915303c8e40314e6574cb21a591c9f2c93f0e209d651791e95ba7b9708184e9bd71478de311e19fb9630a424c28a1df9fb3d2d89d5b6cd2e185600a8d5e84301f4b978dd705b7d07a1770e31dfa957eadc8f027598960a0d2afa54492de9ea38cc1c64cd7ba3135c2fd2ba33e45ba527f7d59134ea11e6c2e928c0976c8eba4f76d6f61ea45e105628a1e4c57a25475a08a2c52f8e8f94c9c284cf4a25f1309d4f8080a811f973871e3521516988d725922f0013b7144343a2b911984b735463fd0b8291b311e8e0dc8f86fe6f536ddfdc0475f4cb2248881859713483d6e20ea9fbbb5c9c35fc4aa5b20f7e9c1d56a8e0e14c7de36be828eee4f979479a4360b9ac1bd6d752584bb5b14d27a166d85339debc715f8973161c3f218e010b8a27936cd0a54e0a71fd0af9bf979d7285962d5f8200439c16e21bf787eae55c5b335db61fd44c4c8e98cb4c4a4bc1ec50295509aa5dc720d7c24c5c7f86b306542f4157947e02092de12f5532b5757c2748da33908a8b1b43721deb7ed378a4caea3a8581befb724d38dd76607f9892f39695996ab3f59e0f91aaac8d162a4b24eca5341cc26b8be4c5adfc88d6e45ce5074e63cd535c7fb0839caaa280f26ca9bd1727682dc9aac851743a01a6386fef47b384e417c7b1d7f19f0e44806394348824eceafdb383dc562b0a89ec6c20e5ee344e1370d695bb8eef894b80f915223f953ad3c42f415c55f635a82ea2e6f1d26fd8a87f35b302f973d3222590947c85eee0fb836e6144ff3aa5f5d47f898f5ae3ad102a5451da56ab6ea14b960444bbf5256e98d22dce04c8aeabbca0bc89979a489bae0cdec1e51dccb42046b80390beef9c0e866585dbff8808057b7ae174b49b279e6a76645e3a8e9e5ec4cf53fcd9de96ab43b9b0b24e153bf51f85a304e2948db10ee8d6c58b13903c3860ebc1941c95afd6392de9500b9c7241e14daa075cb6c180a21f398f8adf827ce229c1eb0cd5eb522fcb6f6554d2520a36e02ebc69bbb40b1e460522d1888e035cb66540cea040102bdacf190c62ce17eda2e8e4bfdaa3999dd67b54f76c3f01e82854ae3ef57fdbb0c92fa2945835e529724eda2abbb4592e0ea29acfda1cdc64d42e57de40e0817570e2c17445d16d779a4d6baa76ae3a33af6052ac9939685ca69ba4afdd393cc3509dfc81ce2b448081ff77285ea01248b7cbbe3a0bd7b1e07bb506d1b582de431c4d910fcb7344129b7a6f69532ca4a77e214bb6c8acda31398cf95bdb221e291f9b05cf0bdceba49dfca1903cd9fee2d33f76c821d610abd9d5234ed222f4b76303d38d4f52cb149aa316692fdead9896368b01e8e60c0aa141cebfc6eb44cb9d240cbd3f32738a23f57af0432b0ad6a64fd26478b9e4c2aabfe73badff4ed65160245beb930724ffb9824057956a3e6f8c7d9bf2e797345c837c03316bce426cf2706105747a11d9b1b4f9343d7691903b5afa96e780c42c115fd014ac052bf3694eb856682d8ec975ab24ece7ecbc0586bbb95ae8aee31106871017254ea526f86b5501ab74fb1ce973a77cad3c7b8034933ed83326fa296514ad557789c5ee333245906b69da2339843713ea3a9d8b9a32f37aca48dc86aa0c21117ad68e9deed5a1b55ad55b6bb3fa504d8d5517df65ed68ab830547fadba2b8a642470dca755d12a4f65783152792785f4cff74adef346b1849aecfd10cea4072c9ba69a854ff9b8bd7cf6791dd18cb2c29407eef3b78267074178cae7d4bb25ad16842ed44caa0766e102b0327af836fedd694d1b18410f0360283616e0979675f1e1ef348fb63ab43f6dcbc711d396826bcf6b19486292c80d833ef16888acdd80c399d89d2f45b9d8efa22143064bb6cf8b332039dee7c833a1413e97319e8d1337c7d4072b9a7e29c3d5599a23ed1f0e7f08e9bae43171c019ab7770ab0ddc3fc0d9bd03ade33bfcd55fc89ced09d1894f9efb2bb5a82de4da61e0604b574a136acdf9c63d1755b1ac716106b15232346c28319b591f16c8b740ecb212431eea7f3d472c320329f96fc3fb96fc04f075d3b65cad5ba7bc97c88dbd0f5a72185b3b36c852cabb9820e05b6ba0597812fab7925fdcf5c9e97d77092b92a8e5c310de96c2f7bcf9ee63a10dea5903beae36d74061ad8df1bb10a3c86836d9b5cc6bcccba5c1c0274163bcd68f487d7638b9b9c22cecf708b774ab9b375277077824ba7faeb8c65ae76e33392c9824817ba13db762e43103631f15976527a80efc408206eb0cec9437b35a759a6c714efc2180067bf3f0a8a9d26e81a33621a37e132a3bb4763d2f79ca2ca4aaa197691c68f233c7a08767d1410a0134ce260863d0cfa1fde0d738ff273b824380eeb554c6b42af625565946f03a910f837c57919b752b789d7db880ee8437638a2e8558fbad71be0383f6f94c25c23e7ff201a9c2364ac39d7c38f88fccdb3ba1bf40fa45f12485f0acacb106bf0a9fab9a2af7c2fa8ad53daa1390d10e5423e724407023667b06d02e6f94e25579080f5e4bac8bb61f3738f854f26b191b2c28576c2c33c155beff25e7945536676d8c42f5064d15c93146e61a479b5e1e62f3325a065502e8b6e13d196d06244046ed83417664a4a196c5f64453f930e7e6910fcb225df4879d20d20c4057cd5e86f64351ab70ea7710d00e65cae96994aa818b6bbc9538dd991299a380988ee8393de7fc6983a3bc42b41a1ec9872e4cea52fe0ca280312bea30e04f3a31f4f33503c172dba621c222c1a09f73a9d601198c9771fbf99fec54d02780d0d122382feb29237e6f04a6c34ed9a3fad4d2ea6e8a1c5e8575a6374db038d2f04f9b0954ed2775df3f1a598666bcf75ddd0f7944b432116d6c92e938ac550df0768227c0d1a21db59a6ae3b06e594af0a1688dd3760186630835734ece395731aa9e2f62be8bac5e82faf8e46fd1be992584362521c28edf05ec4141fd029444cdadf600b5b5e9f15df2a7ba5fc828bd1d740aa72bc83b5f7dd2710145a6af09c2ebcb25816f53f5f21c72aef0e91a1b8f2bdc78d069fb8e6c21baadc53e12a17579415642960daee0f651a18a8e8bcc9580bc681575c163d300b897c732ff3da29b3c9fec82e4965415df3256d214ad009a3eb3b515bfd2e3e1b1f910c65f6ab7dadd13ad00509cc781601b8c1aa092a16ef186c4db66b4c415283719f8f1af186f7cc6bde1d3a8f91b5b50d259a9a239c5477f5eebfd3a92d6f2c4135c8f2457b445553ecc6712e19086a2a61f856d80cabae7cd4f6e6e48c116434c437c66de9f43d495751e4c7e03e3b1996705c57d3126934304e5b6da5bc6780b8b4716c97d24582d9f22f1149b7244e8c6c13524235cd922736e8d1400bd8ce2017bcaa121a13dd1badd0b5d28425b914b1900800467a89327f250909a911ede14f770a90d946feb1dd2e3e4f1daffee0efdc3727de402443f96517e2dcab8a20a2fc987ef7f313153dabce51cdc23b5f64075918b931cb668125ba6b506195bbd340ec75db1c8c8bb705350cc88bb596c6722d588a3e79f5f01b7bf913e1807f4b19ca5c3915d570d42c6fb7d6ebf4cec6eaa415164ba4c9cd19d6dbfc07f762966bebd78d47cc529064c38243beb9604568a8db2b675f61734a51311f8eb944f09afa08bf89a8d82ee4dae3cce4b3886eb7a05eb681c3fc7cab4bdb1ee4014b54942e34a144ee67a03a2cd586d2bfc5ae943167e48a6e87c952898b7d9366e91ae12da6020ab4a68073d82e87f25bda10405ad2da0189427473ef556cd6a2475083e64cfaf415662980790224a2a939de450279d5547f1e8723cf6fae5919f9626cfe9144c9d8ca71ec1e533fd212e54abcaaff865c87b6bc187c2f4ed126a40c08ec21794500f21542d3b04a477fbe4267aa379a452fc740c3fa2e59641234f87d59fd1f59a3eff6e7e78a23fe075864ce90f62382df27a1c6e7ddebbee639630f919031a283713f4362ec1aa4870e9b49700fe436d7a78494de089d2e8f7c4d834781f139bf89aa7c2e93b0aba3a5ca18190ca511af557a2b2f7a878eed030da929c5683bf6b63013dc06328aaccee88ab52ce6adaf317420ff79cc647738dbadf8328e548497e768644c1ea122eabec85a3873f7ae1e7a7f5415f246b64f81fd862ea6545144f9ddcb1ea334f167941c923846dda3e73963bb884af18868c8d6debf9892867d407e3c156d21d22d55138ff50897581ca91ca0f3f33ac3cc6a62356bfef3e7427570c9466070c2e75965154e0f052a1c3666b181a17db48c517f151b6a5c4e8a4e368cc0db3fefe3e5820ac02ca57b273cc02752ed310ea417a1cad3519841c5bc14f76ebf8eba495723e5c3a8bc296fa782877626a265b782e119246cd495fcf54999714917e32b664b2d1085a7a6e0903d29081730bd337ec07a9d0b63040a0f243a1b7e5bc08d9e2277595209786ed687db9c126a086094432723dc8bc80e7a0a4d5e7e7793425a2fc7156c4b870130383b0d39e65fd8675ed436d1dc0d5cc4ce82d28dc689b1379e7a2a766f0c261c885c89f68cc059ca00857e104b345fa54c3fd757927ae5cc0af2bbb9154f6c1e6ac790af6aa90eed02b67df22fa0f539754e16ca0ffa0607d7443a007c38dfe7a822f74f5af0101fb4479e9e0acae14111086070492056ff843f5e57c60348464aa38326987eb502a3fccdcc4bcb6a1ba93672b7a796e7bf9a9a48e904deef959006b680780fe322660d6585b6e63880c691081c6b2a445bd7c781de718360b39b5d6a7dc43be2641ce3e7f6374391e700bf4b21c358999ce6306a76549bb708e89275f1324c4b2308f27042a2e0df51644f4365022571891a6775e4230d1b44876ed5c434d56d925a71db695e37d3da0e64e0ebe704416a900c6e9a04f7cb992e75ea9a7d105bec2cfa56c7af246c7f39c4cdc53f933dc33f306f5bec84accfa3ded9696eb613e92d6f5eb9798b62b69dcda0d31804622205863698628d0e788614e29b992bc3969e7661b99ae26ecf06e5ae6f431a7a860223c9254283ff7a90bd04ffb20994e803ab91b4529f10f3345216e9d0de7adf6a90f77c9e80c72394d7586aaa4e1397b76b2b16789bcc3c0226d0572f45ea675201253e9972c5dfe73d9ce0aa36708d8dd1b51f4aeb7c4e1a220bcf6b7c973fe7d14a35825cbba3b78d026adde61774803e563d2206b02d0d03a23c75bd2d562a5b8e43f7fb53d9ba163ab96d7486a3de14b4b4e7ded8ce1fe4ecbd45680a55af3c19a7318fbc8b4e4bbebde99670c856887a745f13f06ad3c874ee928a0a13403df3771c1523d4bc0cb025ee0c3e061ec4c75ef533007371394c392e4ca0b41ab91d817484f661ab8ae69d08cb031ab312e74ad90b9957240fdf98429bb3f6528f794e2df6486bb4db8fcd89e8379c4b8828e5b79b0e2c1b9009a9b6495d145300d8505361c859a281518c1a89f50bc2b965a31d56b4d95ffb443b6aa9107862816835636b1fb0b5ff35876c63aeb4a4b2bae5d0164cb8c01cb50a8a5993bc0a3ceea48a2b47ffc6521ead6d90340972a2272b251c1cccdc3bfd4adac5e971ea8375c66078d2beb61d2e55466164b1888bb18b29c6b20c0893a3de2cb532f547e6c71af1b8de46620a6ad51b39c33d61f96e210878efab8f12b1b9ce6ed3d10280f72719360f2fd80298ede5f87b08261a4c849a64b4786a2c5d3fa594fe07d2966c62dbf99b0e324f66a757fa8b06c5672f3f124151a0dfba257dbe5dffda4fcd67d7a739c395bcc1a05b321523407a920b8e9c56c505c8867e17ed7df90ef0c567d228c00103e5f9b500fe7691d166b2512a2430302f4b08a0e2d09dbbf85205012b01e79a5e51d83449764f681034359ced7d35cc071467b5a163838ad844b248181d8b234ee08ae1fe9cd02e999ac3054f9d79187b2524fd7e1385666060be53382856fa65dd1c5572986c5016a6bd38dffe6d119a630e76d073c5bd70c3c3d3ff62dfb5f2f15b3954b2f7193b40d37935efc43812825ea8c06659959718d4c5d13a0fc513b9ae8a43a51282057fd13674ebb9c3df66d9f531a3a75acd9dba75089655cec3981f9654bf8e3e822a3e477692a01553341fd0f9edce4a8a140b426c84a4b6b0a6714fa78d936b67537f8d785767b1249039c8db42d1519b443fc2c888f42d0e81b9c0935e06a83f5b230a5fb8ae76a67088a610bf1f7b28fd21c103bac17adb130d2383e5154bb01e3a74ab200cc4b73fed21ea776ec8890cb349ac51b38221c9c02a6f60b29935cf6a555b20468efa1eca4f417a0ef3ae41ba0d2a460757227b6f70624efef6bd2e17536fa1d613d28220cb6e4e3580e88ae4a248f8f770af26898b8686d676cfd3b8893782fd9356f345170d31b14af7affd3ca1f991dfa65a69be975fdbde3ee4eef87059d6e5fc8a9bd07f149b1aa38b3499920c3d47c728225922e19ef979acc9f9c625d87d6a69ad60b863b3641bd8c95119ffd769d3c5367edd16deafaecdf90b48472b4da45cd5aeccac2fba6813df2fd8f1a74c6243f0ec336bdc98da5299a7d577fc33b2871f94fb1f1678b1f3b1627928a62d667c382d0a6ebfb9f893b7b1fa250636e781601ddc81451d0e505b19bba61a4a5e84149b2f490a4ff63907a1cd1bca24a2a8e144739a3781a412b3cf613a95a3a0c92b90ddae6af381b2d130f017617aefd360d687c5d121688f1fec3def28a6272f8d15c582fd898f770b3f20680bdebd9d1404cf03a31a0358b8d467f430838ac6bfe7e2f2f6f858101e8950e44c61aeed0d1e985e7d6834ee7cae650834649509a017d9008b922674fe2d9f7e69348d8f39c4ce75aaeb903e63004c7410d1fb36e976b77b85a6e7aa70ab1c0ec5aa8a52e87b34b9050c10f7fef3ea3d7590cd6c52f6e5748d05e927a7ea23f4ab06a3a466bfa50e5c45d57822235191f25c45d9d92182dfa90db74d6267acc8cb38811fad24297f954f05e2184ecc78754b9230d13f8ae1638c8ddfde0d2bfa792f02c0ead6a6fd37e4edbf15972c03f7e41ba1b2b5e50cc89128b2f07c8079cb5086e0ff28ab3fb73316ac19a14f7e7237b3ba8f000f615784687fe2eb8e6973b1f90b0227acb7ebb35ce66d4b68767933ceb9eb65429d5cfdf0a58273a22240b4b5a09440a4a9872dc0613e20546b59c2d3258f4e74693cf8115fad79a25f4e7da8e132d0ddb90516f839675876ea4e086dc9fd53c11177a097215243fd43535510433c2ade5148b454b72b871bc689f45068a5cce33109d8c091fdaa283baffafd4200bef3e164ff7c3cd5748aada77240a63da2bbde472140950954fc5443fba56223a55c60ae82834a1aeef75610019c458a995d8b971ab6d5a296ebe7c249ecad8cc10deae7d4de6b833f6f4821d7f4c0166e17086149539c65d97479830de1a45612e7d6976fd08000fa613b3b57fabca66f94bee9385e2bdf87315f407f7895df9410a8d6006d398af6ede7be4d744f80cdacaa2e7aadd2d5bb062085813baaa5b9a8bf1260d6aea2187e793c93cd1022debc11f8f19554e102f3dda14424fef18f90d7582da4f70ed67a1de33b9e20d4937ec9db720a43ce7af0896e3701fcf9c5eac37de5a244bd4c6a33a6dccbaa7cdf9975b18525b100e332c06ff244fe04eea954c6e7bac921de0fa328e61377a5cee61b9e883f542a56e92fd5c070b1cb9cc309fa86bb966f07edc874d73e434e226f1de58abc211d786af043e75e16b3ac32866db261bbb0c5ea063c04468c3456f35454d71bea15a85dbe34aaaf9e1e91227e32a374b0c681b5426fb59af6450f43d0dfa7985ad586071b34a211f020c8740a4a2e1d45da7d40b32894e0a0e1da2176e742c35e91b5fa031f19b8cbbf5506470b896caccaa6b3dc61c2d1e13b43e5a69b55bb0c7bb495aa0b631887cc9ee9db632330cbde0c6098f01a61939cc54893bccc89c587321f2aa89a1456d9bc5106cc54246b07540343282d5c731aa3ed42a2c69cb1f08009e84bf761305a2727569aaf1954935273e867e94af440d6c7a7af6f133c108be2649d7e40b1e6b00980e78e7255bd3257db45e0ecdabfa18065f6a897e937bc9bce777efd4e7b5f31c8137c4f2b16ae97c470428929cbbe1fb0b8174aee492c398e04bc0c3275bca2a2ddc75e825fe66cd332683fb99076e0613235bbb702dffe9ce4ade4c8bf8f938267db2777d77b1f0bd3fabc2d600fe478037666cbe133aa55347eaa35ce0215d78578a3e2248404a47298aa650761e76acf35d7d5ee020d7d6aebb35592d1da28575de971bdcbbb472cd7d159ae66ef3aa4b54fbaa33dac27d51d1f54d0bfaf1ce6eb1f416e7874f42e3a9ac81e19bac161f62f4cd35600ee785df382097e82f5a39b37347fd0bcb141e4e3d55d37910ecc5f524281eb9d7e14356a49390d011495275b252844ab50b5b9728775646799d677f0b0c0aa2704e587cb1d752ee5f63392aac32598163cfa578fce9bf542e0884ec120c210e1e21c7988bd06a5562768bdc35649699842fed99910345160677f7e5a05180aacc1e7780a367d0cda8687cf6c08007a7d39c116a88662c3a08d7566094bf5482497657abf4ffc8d4020d3850dd7bdeed4ad8d235b2fad2511cf76b4cf285798937d4488dc09013bbe9f2d09eacecc89fd66115d2a50e0284143706fa1ee90d56ac3bcd789db6fd6903e05ab3eccaef62ec7c6d79b418ec11e483dad609122f492c9ac751aa9f49c81e529dd03bde1ea6a4ccb8a5651ce39516f58364ed361a98b5fb9ca78f854dc752a7b1409518b95655b5ab7192e8c8465dcd86bc6e27438965fc9023990f5a82d263e07125bb3ef3c2da4d709b0e1e6685a19b2dc5391ff10fd1fa0d277e6bad70b354564517457fb759d63b2b8004fe7ccd46ae739c8b80a7a9f445180cc76b1edeff6b3aa1e6d2fc71acd45de2325778608d0227927d317cc5992e8d8686e88d54618745806dec52e790f3e6bbff0504a7aab35bf2e3c107589cadbf77d1962c300a94df90accb9726b66e77f9a23c7fa186352ce97277fe217f4ccee41a98c431cd7121885774f8b56b53d625a89acd2f31ba1a96f5e77b2db4e51901e8e5f491397eb9ba436e94d9467b2980b86f81a832aaa2f1bfe1b14d46fd2d34539ce236cddd2b74df4d7c51190740494bd913e7da16c34099e9dfc93fa1b28df0663c2826da65e45bee2da54fd37bfaf7766de2b1616030b856404e8a36262460da59d71868d94ad29fb220f3ca25e0b519f70f0f01b48f922e13dfb3268d8fbc71fa2a891bc31d1b7cb808ab3b3d5f730b8d68164a6f4a6a8d74858f6324f23270e5a5928862c0bb8cc1aa570c41cf36bf0894e24a74e2e39904ac370f50bf34b2138a3bfd7d737c79286fcf9935fa68d4682699357a026ad2079d61df6ea369b20bf5adaa307c732a2bb0d123224e7eb50e85970e5486267d6f5349a0cb761d0ca0f18631bb580fa217e701fb8faf70c22abd15fef88b242f049b1f03bff69bcee39cdcabdf73b2aff9b8f573e5af27c604eafb9bd09335d36cb41555e831855cf2d484dba815c1fab5c0bbecf584d0dd1fd7dac8260b2a47673d2b37f7807888d820f2fbcd962ea012b967b2ec4944f97de82c35a87620be0216301d74c5d171afc6ff5076000b0a5775b6241a7b1859268abab5a2a84574117b3d9c118dc83d3cf04aa9d19a24a725eb2607d8f19b28fc2778b38141a11527fdc281e1ea53390d09ec2cdf7820a37ec6a296c75e61be1bf2ee47943cbd45c5c567c183f587cbd542631bdd89e444a5949deff7f8c4fd8e80b6410ed6003b53c5ac93d98734951670bf7955e0b33e3a02335ebea5ffd3a153580e4763e904d88b17b195028130f8f0148c6dea067cff998d4757ecc5b47d8d66689fa3e565b798ba88a8d98ecbd8fe3b0fc1602f25b7b0381c332a9d4d7dd563c0cd3f76a0790ce3cca294a08a2019228eb3cb2b32de2340a19cff955a54a4a6bbf151ad13c0c9bf8d680f83ca83cac94f5db89761370c5112f0359b9dfb554510ce5b4e024a8a992bf9a1b5cb0cf8e821a221b067fa3f4d65406197b42d2107f6237aadbae819f2efbdef471f5dc8aef352ecbb25115fc0b824deffe62dabb60c08f926a4c0d25ac6b01938df01da19957b447f70899a32d6ca0efdfe999dcd1bec5cfae87ba61ca2f346a5870cbfc0ba27d06e7365dbe83e54f5e86fbebef5fb388bb59cf07f13fce5623b69b96944c491debc6e44b8760e88102e529c704f2480c8859908d760d0c52c64c940e78440240ede5df5f69cb8bd9a9dfb53fc01ecdb349b381138849ac267291b59b633ed286586c10e5465c7dc4a2e4b611011ef4d743a9c190a11ae50d47aec306c5b2e4bd9596cd34a1cb450f2a112b575013ef652d5b2a8c839ec72289b79a49f1c58f4aad58b363067591dccf92286d1c06092b364fae4d624378e80bb6865582bb03dcbc43aa39009fc70f0852bd787d4f86867079cb70c5e2c278f86d98cdd9b7f808df505467857afd91f94a5187fc593fd2759576667d0126a7eb62d4f805dfd1b057da28cb2fe8788d761e51ad23d79e175224e687cc03e2ff6ea23322a69548c9724771367bd921189be7dbde0f9641b0cbfc92c69cc4e53b32064501375d8282bfe44a22ea654bd01026a93ab191790d1658092870a429fbc3160a47eee5b029e76fdde471bf3e3b3f7511871d04dc50987457c96d1e710d800696c46098dc4b3f3bdaf7b9b6b2e03a9ed282b5ff7aacb43c2a1faeb7fe0f3b2950dee7c3ff57389c6e2746b71c9a1fae35f59e1e813acb4fd0c4a1c3f58e5ae6131cc8ba5b4c318fcdb74098bf3c250fc577213ca1bc7be6647fec9089ba09caace72d6d45eddee92961bdfef994b6bebe23fd1284670bdec383a5aad0f7759d497ae3832288752cf61018e062352e8e08d627649ea158d78dd7370f5dfb9cbd249a30a2e3a16f06427750262713bf2178812e7626f02f83f9d9cc48391aae6a93c21d0860fd2209511fedc709c9b8afc2635637868dcc446a6eff7009a37447af4559ade3a3bc4926d35f90a29091d5a0e2840c84cc316171c9d585e1ff6a57df56e74eb75148516f4d61136060c57083cc29af601a610557760965f98503bc79224d6da0604f613ec27fb1029f1a1c24715517033a72f247803fd177eacedecc65c4d9d78f9f428854fa0eb0fb241137f3ab59012e58e62e033f9524298c4dad920d2c461982170a2e236d3d9496adbb866d93c63d6a41cada64f5b1ff9dc9c2866cfd5747868d3b7c4d250cbc1c603a064d587541d37f6cb787f8acedd5c8acfbce4feaf7b31f3179b34095eebd8912bfde9b5423080475043701d2c0f9e0fe034cba8a542dabb8676a6655cafdef6ba4de2a89e19b74cc00dcf6936a599b8092967f93f75e937071643de04088a2e5e79d9c2e2ec8cfe9054d2231b04177e8445dccdd0d1a0fdea4120112c129f85ccb3dd688100c3d6b22c732125cbcf5b128d2c25a00864ad0711052db90fefb80c76a749177bd4f2878eba30ada43d79cbaba89ec4ad550307e55cc6f354e85fe647b9fcd04183f3b21269e22756c36def764b61509391547f8cc966557341dc7d95662bf4b9ee671dea8abf787ed684a06f481f2c42fadca6ba14541889f63834243bb3101843503cf8c16ac492322fb2f53b7d55d3a7690b97d0a085cb971c32c8bcd5e59513eb9dabc0705bc814574e8b5952c4b2cc6e3b9ec0a6ea605fa050b24e9a0450e291b09fd2a73ff22c497b85935235754cdd78bfd1253ea7166e3a99780ca0a92439248c5db529aade4749f379ca26e38c770b0b9f7d465da165851872f5484d5b1ee47993a44502132c5e50b9046104199a691e1ce3a9bf20f7dfd5058384f4883700769af36bfd8a1f17d8d9115450f3b63520206bbebd821760dc29a7f99ebe37bfaf91d865ddb7eac9215559f0942a7c206bf9d949bc02ba2a7a36aff587227938bbc0130b97cb3c5bfb9229d071554539ae31181f4a47752418b3b8323ef212bd0972855b17daf26701eb09316bd91688f62b47a92303911aced01d391c078760db1aabebb570603949cb70b1e18abe1e1de14eac442d04b85c58f69a44a56c20349f9dbfe5d863f5425efe5d3a310286a20db392e8231be32dcd69510829b97ead2319cc033d96446ec1cd7232ba659547a7d256a2845f907b9c5a072dc68bcc0000fd38027c3f2b8ef48f89cc3b1ec1a0b49ca172a0e23432b6f9afbf6bce3a6ae0e42a87f27aba74d0af96cbec645c16374ebe02c008cf20432a6c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
