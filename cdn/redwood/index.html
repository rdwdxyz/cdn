<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7a37836b10971d9ebf59c3d955d1b527ff5295749ba31f083d93b5b63b39d8db5e7210b44bfd86aa1cdea00dd806538d69747238c96cad5cc3f8f1b0984e35ec2b032ba3d997ba222f7cc6e22dc7530b21f980818ccd266ee88fc97ccb3b5a3512eddcb7e85661422c387daab5cdcd0be777d3c73ecad6cac46beea057193b70cbdf8ef4377809187aba61f093e96482999c5fb9a2ec7cb8a223b414aabe2458b60de728fc7dcd0fa07854a633d6eb88b657afda6682f92f80007f7889567a0b580bb6ef04a0c0314f63bad582941422a7f758ecf42042b0a83afbcb0b41256c890ab27f05c7eb3ad8ba84d04f36b11cbabca4895102fde71fa75a46f0e835eef2eb39812e0df2ad4d896401b29e8d21287c5f18331b0872e35481ef552b6f2fd29f30fc518003e024a84fc4b10d131b4355f382cacba6c7e9b5fa39c93d2a4a98f36505b9653e8a341ba4344437827d6d934f864491efeb066a9c9efc153793d2b27d04204f8e53570a71c85f35aaff4474af4caeb25962d2122850d4fc59c83ecc150d2832148669fcaff540814729625ea8c0025c9a80035e859061feed015bf43ffc72d4b9bb7b59e0b93498ddb9891f3e1cd02d5799a8cd51dd19582619b72cf0df0503458ae5ca970fb8278378b94a68c78059494bf0a37aca76fd71e2dc00e36c040052c28f122f66f751f36c871e19dc073b034ddbed4b4e617234aed943d3200ac95bac97e46d22480a3bccbfeeb981076c6d50a7303239e9f969437578a01586481f753438150e48415acf1a0430ff67a94f8a71aebb60d2aa6a9239afb890c6be53b9fdb8e285549b5accb65080be634f511167c08270ee9bafd5fd46e49100dc8045700d6f9ed71b9d43b4f67df234c67c5b89fe4c54eaee20f99ea7f5afe8aad4086fc16e376678824b8b67cd2afa1534914f489cf35e433ed264115cc81ba0b4d05e7f6c96767d6af4a07dfae2bd4f73370f6727af9843050909dae3fd8a9e0b1abf226c6810d3013d069f292a14ce4342c22a90d96a60580f9a8c35a3053efe5f5ab09e55024dcbd8f52bba4a67128422565921cd6fe40287518b930f5a22dbff452cb616f437f5b22cf8f934cd043db08d5484cad461aee00a653464a6441c0918c40dba52b411f2be793bac8cfce4584763fcca2687a936411c8e1e35eab79fc8f51741582b2e20b609d37d4aa98fe4ef8a79e467c2b42ed51e9491554e9958bbd808dfa69f1a8c4ac38681504b45052a9b9a4229d466a35d575d6d88d5b89ed746bce92d2e0e5f934ad434167b94a2cf1e2b7e31cd449420d0bbc3bfa6f3426eda398cc1f70ab6f8155f3804a44cfb52783c397b61288d1ee8536a9df8fce3330f6ec5298a33bf2a00693a469de685f6081a7d4b6566249ad750e32d93b7c077ecdce2616168cd8c9d98a1689d0c8cd310d03ced5395df60fd40edcc8531e23f039130e70396b741644d1d1b2bb1d8c8e266d7e3ae615f0695ae3d35bb77af2e8a905c2d7e5c4e224641df001926c7a5f859116e5ec984a5552f2c7cf16ac356a50a3424be84dc915244d1a3fac86ab24fd4e92d32998f33e06246e9b6b573a0ebe6831b3e9beec4e9f87857ccaf69862e3244ccceeedb03ee9c1a16e6c0d8ee2e8979a7654dc6f2f4436d683ccb7e1bdae9220d5a4bae3fe3fca95d846fa229f9c479e96df02b80d6eb1883bd4b0357099b41a623b0b3e46bbbd570fa872db1a02a6b0131be166715274249eb84f502a007e18b9637e5d346b4aa93e9089097eeb8ed44097b955bf905c63069c058681cc42042d4fe29aad3f720b989bc26c0918a40660f22db48d8fea0aee2c7a61a4e707a8328d96f13173c9388b34c32dc187e23d109d5b7592a9de3d3b844a8462701dc7b4a8a351d9a272e285312b5d5d1858bf170cd1f096338ebbadbbd610e27cd35c6d8c0a8610843e57d6112dceba1ed9c16759af5de2aa04563be09da81e08a9cde2d5c20122a4157a4411e354b47510bbf2dfb35cac5a4f52f70b2f5ad7b84a762437d488e1e96dca484c564a62d122ad9a1b99cea56abefb2998519647c06dd7db6db7a557cebb815f3f7bb35ba4b9c88eecf911e524c2a4a51fba1c8ceeb30ece1bbe317931ac014978770766eb3cf5fc77908a19303e139a6b330a37400cd679ba116c4c19a9e3105c3f9598120da52b020b9910a4efdf34a89b8c4daf3b412a0c809a6e0d438932e0681e5bc67180df5a8db4e83aa2e76c7cc10897465a285c5614f48ae49b9bf8069473c71cd2b6cef730a063ff7edfb802ea8ec6ae417b34e876ece7c2c70c3487b0f56fe5ac7279e176421db47cb4d25ca53b6ac27110953c426b18d9cb4697d340f7068aa008c56f2f4752e18f0f72307d5d12ab4bb597302c2718381c4bca56af3ad38c23e673b3efe41723c6215e425d1fed6fcf9debff24a1c0b2bdfa868334f1a39aa23fe771ef2e7f73509d97a293379049864ffdf96fc43d431d80b78d040daac991e1cd3c8e23067a91567dc25ca5ab991343b8945369f7e50b490813b5043db99ee2f3a7d881c10c8feb25172ecb1c2c7ef0d6b920533e925bb288b3744bc5c2fdebb12ce2f437e63d06559f0e8f909d44ada26c56fe8c74bc7268113fca3ef7a6a202033b9b51139417001057c381c3acdd1057ff7b310fc6bf9b7da2b393d786e43f75bf984fb8cf3952eafc3f91fde7a0253fcdb8797771ed182e4f26e26dc3feaa902975442f7db9140d7634a6d4c1c2326f2cedc8c43a598d4ca7b08d5cc05ce9dec8476d7ddae4137a553f903b5961815a2da35ed48bcfc8975d6d2a3877ecf835c66ae4f1a43a69527fd90d181ea6115371f4d4a6eb22e4695972b0a6a195605260caa7ab4de6d4b9790671deab55e6fbdc9a848e200da460465034a92fc0ca7adc9f0325a072cc851efdc8fd95d9d2c567b3b4413c729df2f8fe90cbc97cdfefca6a15d1d18420475f77717207cca27b1977b9ff882cda1c65458b7417414a1d59ddb32ef4b2af11da348cc9d9fddb05f67db94feb50d7e53cff36251ecfc31082a139afe7a3d23255365a1188f66cd36501e161c67e80915fc2ab8aeeb8c11932df95b8ffd7c661e5565b3954a2178a5b4e17852ba2ec65615d9bbde0ca01363bfe0c1b9f96b9983fe8d432f2abc0ff793282ee6687c1cb21b105a0f162aa4f6cbc86c9daf0412c587ee562d1611737d7744d163f3bd6057de75311304f9f7203e35efa45a3b35386980dc2a11e03ad0eec95d0d4d6b8c9d9b4b65a09799f352c130c243e7502f64d3bd5fd920d90d641c10954f72df4621a58cdff5f7acb2dc7dc52dc2b3abb6af1f688a7a20ceab0aeaac13844bbedf55198885c4a9e40c2078e6abc45ee01a1d7dbfd5bcf49a5decbbaed80728d1e4bb68441174e0b17e2ddb96c87fc6062850c656e898ebaaed227f179f840b5c78489356f2817045581d2d9ab4908ccf05f74aafec3039f6e08b77a8e2a5c7a3a63795f6b004c623053928c957ede9af216d6a4d6560a4147481a9db7c2305e7924d8f3ff88f01c1ca70544dc7d125e9567478d262556c61a3dabe9ecab07bbca5dc78cb23dc91a3ec9f0eff3c92e90ce5517c4171b0cfe9d58b929cc578492666049cc9eac09289ecb214229aa61646983b5b423a5cd59fbe8695f0baddaa6ec0ed18c256aea9ad986e58f0b35b448bb6f048fd927b430ae6dbe697db56ba672f96a53f125429cdb16f78d11d68cbbe9da1af0c5e566756c614d99a6e0109e766e9572abcc8ceb01d15b5779598e4ae13df91ae88eea47c1be44059bf273bc6cf3301b2477762429187f272f6aaef1a2d57feff964eab631e18fb53032d739ebd386a07af06869fc9abba400397b251884766eae908e4746d77729f05fc87a26622c77d7b1f0f15dd62a73ac3cb8ee5da891139e2ea38fe7a0d81ad9ea7b1d7feecf9e3c88f50931a5c5b5ba4ae97cd10c578607ac90ee1bff38a7907a96503718c14f126b16e8266acb4dc46ce48a2b2e5bedeae0babe4539cd782c90bbb84103937f6c8969a07d1ebdf7001ed69d6f30cd51e6cba36e8a16bc8c3e45f7e52bc2a6a37c2358b1bd2a618bd8b238f67a616018402c997cb74e8ed98c6207df6747a681cdaddb40a50cf5c74f78c3767a0468dd2c01d0f67356978bb40fc281459b25ced92222aff65124c050e9e2f5a37aab6ba083f2d778b6975f4ffaf8fd06479e8b1382d6c160708a1f44114d5df4d78b6212760b00bcff2f6e8b0354578b28f026c1a8a037d39395a33e291b1d04c8cc72e7b6e9b5f1dde616722ae991313bd41e6a68afa5b70526be75ba186d4dc8f03b0b3443756eb1365dda874253bc76c46e0d77d6143a11bde8a63a18459f223c7f2d06068ce930b8809d3914a0805778a7399d6331160268a622b22ec2cfa833ccb2671ab81af17220cf6cb53f97ba5b6d558da1b0810b1f716b75feeedf16e21abe835e096468c0826564894bd7e3f73c173f13b1f6cd5ca51d9a24c99a4a3b31a1677ee31d154e5f740251997b90f169420776c683a4d86c6a9234064bc7756f86b8b3b56838a719975a16a9eaf2a2dafa708a3077169a96dda591acdf0b4707fff57bc4b514c3ad4c8d9c1cbffe57960727a993d744fdca4aef1005a37eff98c9c68af93bba6606adec9946295116381a0e941869fc67f6b7d03488fe57b2e045d4185a0bad5c131fde6224fbc642ddc3c85996ce61264890c49eb95dc0d164114f31c6b008d90e2aebe9cc8a5564ca78fe14a7ed71ecbc88fc6ec1941622be1f33227d81e0352906eeef57bbf6cfd6032eb5a696f611e05fc4190f5630e80279818c93f5fa8a791619814f6e5b87cb7a87e719ab4d72d29557cd71d9da5c7574786bebb05fef5dd66a2873706db39db5fcaa7274b1069955b444ad305beafa76181450058d5ff88f6f316749c9e53edf0df91d17fcc192f9c3e08c040b524b660b6ac4dbdb1da6436c673b87670dae680d9ac9e3d57ffcb1f466cfbcf4c55fc10c96d118edadc224162c2b42fad968d798f4491c2a0f1cfc9d301029e5b27a0cc98b9a59b4e08ddc17e4135d0320ec4d7be823219dbfeed1affb43f3e3e2cbfc5255589b9b07958c850ff628e101dcb9562a44ede5ff2456cd6a6ae2b8fe7e036912a7d99d6fe4a211702b909ef5769e4d4961db2c7f4e41ca78b461548e6bd5bd7388201d34e54ba17cf2d38dd40cb2a84efb33608324eaf496cad75fd0967f84f2dbcfcdf4188c519233e9ed9508432814974c48518bdb3abd36a8de25624c3103e68a48dbbe3bba4e0629e61b13f98e029a720989cc3afb9deaa090d5a2b21d0b252ea7d55262640056169d1ee5dea1a39c94246a1e8b83e56edc8db1ff573b47281ba00320b9aed3faebf8fca9d0e61549bfdc1a966162732da7c438ae58c8f96f7375a4e9d49544dffec0ce4a50e995cd579b298eedb7e96ce5ad3c652ca8dd6d6f88cf7937e5dbec6f68e20d90d3c1cdf21b70ce746cfd709302c38d4f88228bff9e1979db90f9b6672e1b41e97bf059fab8f1f60b17d459ba21fdb17f6e67f434fa9973f538ae7ead38a9ce7e181beac5085fc9e70182ab24e793d8b165b38913806e46a613932281160cf9c13f551b0ec827341dc62742f63c38e3eb7c672c7bcb340ed1e9f873a9c71fa56884a6cd1921a4c808df110cc06552fef4268e1aaa24fac1f632941dbf6d25fcad3a23d4ba7b4e4b9bcd791eb5512511f9a952fd21258050cb43549adad13eb08357624373a2cbb2da161a48712f6cf3c15dd14c200a9a5fbf62f4665ac0c8946f35512ebdd2196c07212f3939a9eba6e67860cbef5fba98ef936ad7b8afb617b1cc933236e683238ac7a0d02cb5f14d379699c94977f7182e2c58655602adf8be4971cba447981be236e9eaf0633643bef08b70d06829d841aaf38daae8d1e24c1429139090178fbf67fc6b35a8357a2e8bb6aa4507bafd55983b0e10176d53bdbf3b928466a72f1f4e21ee2e96c9cdad454f95476a7abaae95d545695493a35abedb9a9030d3a807f67e2cbf01c7aaacd1b0391f4f22470f958440291f5906388624968272993fef93fd077156314ad2c9fa12207a512968b0407c36cf177bb606f955eb138d747db0b70fa063b8ce8b33e6bc386d89d6e7b1418db71e58a0d206c349fed2831b529be245678e5d0bbde23bdf8ad5c4030196a2d5b2d68dca92cea96f16f30c3948306814fd1661f8dc3c7683ea5171227977fcc2f0d1dc67cc8641e0d782b6adf9dd87870d38aa22ff5b8ec466479a8b3b227cd369b6d95df0fe2b61659b5440a987254bf91991baf22e31d3b61d426c08d8f5a666df2067330603050f26fdd43ea9deed01c00d116adf02199f5a97ca985b9bd5a25c62cfcb3416a5f721f33482ab36ff52497ce4aaa08768b26bff845b753733b457d3645a24ea31c63421d233ec15c8dc8609f31fed3a316a82e466690259016d58c13556365938db334c9f3ae6619ee8bcea3e17753f082022aebe8b52f97e93b3776ea432f8da38535e3441c91ca6f4f7fb28cddcbc148f158ee15d6cea75e996d715f0be594161813d316015a261aaab577f9731a479c6d2d721417ccf6408a4a7a266e8e25381f4c88c8317a9d54b0f329d4e61e54dc597f957cde26e07b197f51bc1b3a302e0b89c61d6e32f8a9a75114db9a980633b9703fc89df99d1a957c19f7b0c536dec47f7184ec22fb8ac89b82b3e26a032270b1422cac35ebeffb63014b033c6ba72605089ef156e65e56c637147d6f33eb12507f95ff2f3ccc9c3dc107574a4a77ad4d2f23430f79da54c1ea666464446dfc7fe0901a59592c53718d41b279c8962cf6c4ea4257cb46d995eac628b2f6febbf959a3728ee2e5207280375a4e3bd4a5c2661cba7bd1975606dadcfc072626933f52ba070fbd1cc192ba7f64d78a3ee1a63237787b355fa4a89e00392f200bcd2d63eb8cf260a787453f03ce2cc8135d26fbbf63d3c13adf8705f38d1d3bb3f0af296e429d2f42419cc65b26645b6329f8de80c6b20b9952e23929ac7b5bf3361830dffcd0b2e2cab30458e67de6886eaefe1b6f316810984c5f0257c1b8f732ca0f2d82369bd928ff5449bdc5576a02e9a4878fe56a615b7d1863b42ffb1d77208a7f08534ac9219df0d72146bfe35d8f6ca65be96f96836d16c832b8852b68ca393c4e9761e1ad978038a42dde706d4c2c14306caf03a95c215f90a7735ce1e095d832c07a8045bc600360f5dde7e0ba911f39fbb69a9edab1c77b662e52d02c764f484b36cbe867b750c9ab7ce34599f59a6306f317f1e9a6121118729bc05992d1debda842a16dc30ff1da5c024bbb6344a5e6b9e7c3344f9cf38f1449f5e90ca2344772430b51fa1269a7d79f8ad9c04feb7139b6fd0f926f425ea2123853cb7ae0c7b0d7f57e2791e107135498d644433be3ffcd16cda3badbca424873ebb4faa721bb49bb0a847e468e1ba76cacfb5f0757141ea60a88101af37820102f48f43b64be7e082fa9851ac96e8f9e9e1adea12226c9f8be7b56df45501e9e8dd34b40aa1a0b5f37c8e4d488b898d680a3bc680d6751bac0cef886cfebfc80739504c221485f5d524833f3bb990da00422e3f0f17865de67947ac7a96eee1b7d3e9fb5613635b4c63213e9d995d7ee87bddd1353f6d38b86056b19a6057542f9793e904ff8e33212c519d450dd971a5643b6dddf82ea24585d1482585c5fc4c6d00dd1df97adf2dbd5f41b7213899fbe4f2fe196e213794403090d150ba1abc3a882f3db1a8e53fdde0f1885591188c7307176c11266340c1c18b43d8c8117dcc2ad19c94d7762b1a704b7fff74c3e9c7dbee279a2108acb5b3df0a2ec89d61f3239864ac93b72a77e740f6b6429299fa3e981556aba8a3924848561953d7d1dbc52902d1ae93a7fb43993f506ab66344b6fb6e8bb093a47ff33ab6d2b628b473f7cac0d4c283641726aa46a5a410d7264bc61c5ed60a88d8cb4ae69c3f8b696c64b979cf5c7334446378b5f678f57516996a980b039c562a1ddcd255cd1957001c51f1000f8616da2074b9a3dd47efeb418b95a580d3d01e5be15f02265f9c6693ec0ece12ae7f4b323cbd73b3d508a4440069b4428d130e9dd650d662012de0548674abac3f327404716c059d31003d4ad919100463be80cb07435542b4d5878d0a1042ca1fae5d55d27d1216aa64ad08d77ddf7966d1aafb8b4a5fe64e46cac0d29b52a03004393d04edf97e780d316c3ac35b7eeebc30bc6a84278b81f227f2ac339760e92172efa4cbcecb1f5efac2e34f8ff4f927026ecc54cb12a885e563a819d26a062933a7cd3f9b5506d0d1313f618c684dd19994c6e15fb847a525528b252c58cbc6a413048dc9efaa19f9397370ad75c393fcd4c134423354f962b1de740198dd101ed7013ccb5a2a50c4fd3dcda5a385476975e77d9c44f06899f8aa01238acc936ebb89014c59accc37af4c1f302ab03691aaf983eadb09600a01007669a4a6a01574dd3966c766c4c24f8504bd7af1367904114f78025d3f530b5103beb3cefe34c82beb7aec998dd55bd086f0588d65c638cdb62aa3e42c62b67927d696628ba3ac38830ad999c0fa9f6097766284fa3e53ec0b4bd7220023869814c7bcc69cc60ca43f2aa00383a2adba376452ce94f8966bb65e50400e7d7237ed534bd84dae2cae05ce904848f0124255b0b223394d0978ce6324a09521d7e1d1e3abbda1fad3314de54e8e253ffdf5123a5116b892fdcb29cba0e9f7b19f4d3c2ff5cef986dac55151c60b2f66cf36fea82a5834a57e2428e0c6e9b98cc0321aa2248836adac04a904d4852f6a6013e1d231b21d64096796a6b42b337314507e42323a1d05e1d8b26fa866e0dd1adfb3dab967b3415c80ca7657ac3ce07951adcc3a363634caac449a59cecb135e55f3541e338a9539475851bddf0ec8344c104bc5f8077523ce12cd328e3e69f0fb9338b6c628304e7763ba65f455e3bb41bfbc1826e89443eedea7ef9be23d60bc0bc1b40cfd6ded7b8505f4848a3e9667c589d78e72f14c280c2df2f4f8860dbead48a7f51b07dfbddbb9c2f4146fba370fa3f07566377330170b2a54b325b3bf94b53a75ccead1694f8ce1c4ad7195cc18f11b8d200e5cc561ee25a1f73510d6fe47da3ce3fad06a122cdbd65d8dde56c836e43e445b85c5455536995631e73a0139da00990d451af16ccef1435ba17e541a35ee3bb93fbd2acaf2e6203a180f9242822266c01ef5c433f17b160f9dcca0697c9bb12b6b001b7702c1c6022d9a09a124e818557d588c4ce70429db2efe23cf50fe3957f3f4bb0341c07e20fa28abeef52599edbc273b8e47fed3da34cb59c14d2e226a4678a7ff652ed6337890d318b972683384cbb791473238f471d788617d1915b5cfcd474d310b1c9cd3b94b54b8d587144085477d1334aa2353ffc74cf758bacddc65be1fda521d01c1d07ef98b3f85633bf20c480e74719595646c30964633b452d89ed41842ac5b03455f78e0a73f0fce6e2de225a54f982a32066af0bc87de02a16ac1bf51d83493ff0459102fac1c4bd78b866ba5fa147d15b6dcf39c6505686068b693d35c3c124dd0386e01e5b01a22c18e87ca2b3c26da8e35d1daae23c369fde204b5c3767a03ef30d539de2e9de2facddb0d34efb9ea96452558fcd28b99e28f77c0ff394053dcc3a2197623edbe2e86886fe752269c8ba935413673ba82a23c4eb4bb49d193169135724a44547bc35230ab8605f0ccc9c78da3dcb01622bc05a31d2566beedcb4cc32ffe5fd7434412e2f7f5f5f9d5567c482ed9e7800d5ae4f2188d28c4b305b0e7c65876d2f8493a6ebc0d7ffa3756a0bb90339df869f558dc31b967d1a0045cf16a3de6625e6f6f90e894f4a6e78c6001a5c465096c99aaafa68aa4c36826bf1384f1f311c0a316ac33f8feed1ce3f5b6163072dd8be8cbdbc0d64f000afdaf00b651e8ce50eca326fad569617c5c515f03e6a6b618c692d9ca283f9f51964b5e12d137536157f5c1a71487d79a14bf7f444b3acc44067f1a34ac872a63033a7639d56b0f43386b3c94c20afeac1e64c904576c3849aa4aef19219dcca8d37a3247838c7f67706b03840b47ff26606c2ad32b4ae82cf9582bf71535fb0696ae081d6c9de3b8199848362c65ac46ab3e8c491e1099dce1e204a178db9705342c30ce467d95276f5aa26ffcc158ffea87c0ad6d4e6ece6abb9b972f3d54475bf73fa4d7087ca388129de5fe36acfe10fb251b0bf8ff6c7d1d0ed7d214bce35043ac30a407e40e91f49eb2404abdbdd492ebc756c097c00d60be54c4ba9745deae0b33d11aec1c45162491edc88be58ed4cd13a14a070da478f76c6eb68ad400ce199f6d1f1ba62ee9e0f61dbdd91b17612720452189147e322dbd24ce4d23055ba956a76ee1b9fc5f26b1ae581ae883d85ec45ed50ede630e9f0bad85e82d8c57b735a12e43ab1b419292d347b68a5ad3fccc99a7dff352fcb89056dde5b6fc5e5718decf323315c91b1b0f8e4aaa4dd1f5329dd2bd492cfd64cd61a45cbb92c620d2f2c83527c327fd8b88f86bc6a050ae0c13ff2c00538399fdfec8cc06df8bdb9209d54680a876662e93d61c4075e605e1ccade24a02af4d4fd15efe192d0e55595a826677d2e2b2297881b21e804b43f4ae08d2f71756584d5be3c4586614aee73d62939da676c9f374d610ccf26360aef93208bcbed1300b38049e2867b138000bc9b383ed526bbe96b5bf8e1af25b47019999e0d35a752f25b295c181aedc5c14ea7472045b1385ba36d2d03f4b3fca918690c47d1c7faefb4e620920e0bcb9294da0782778e3af2c5719ff33d2d444055c376a5a11ad75b4575291bc94df9d3a042092df7275b0f77d2d31d3174ecd706e07b6d9ac8a92cfb51dd35b2157059f1d43df08f1c1addc44f2fe25507ba794f3c1b7f78d30a387f59701af42f9578278cc56146d05da6f6d5a8c43d9c822568f21c258e4184d91f7ac81fd47f7d6d64ef21dfa55c9caa5559e164143715e47dfbd1fc803162992e2e59d6d908562397206ff89296e5236fa35e10796000a4a919bd7b036dd02f5ddc9a52eb487a269ffcc53cfa8c705c1c2913dd1d2119a2e033e3b680f48fff22e0cfea5d0b1eaee2eeff846a850b4d2e76edef836919d51bd18396d91ebc1501262b1bbed29d262b396b6247705dc9326ad18fcb09d88a2cbf06e8c13ea119eefafdd977d239addd51de9df144b54e56d25923e34bc2fdeb001db15c33e7c567c1e2c6d1dfa4ed6e7cf52248db28cd17e15ea30f5f61ea6dfda33fa4261b209410196f64533504e3a31fa2d004f78b62a18de98d36b1fd265b0ce2e63492bd9d010626d579f8fde016a716852fa92619c863131a8c1581bfc2029577b47f6cc2d862d463e09a7219164ad700745ce4c8b52582ef6bfd22ce2a53c0bc8921a5184ce94b8c55aa184ad33c6bb092d5376cb9dd25f751689e90315dc9ffc8bfbce5268a6606cdda2248fec51b0175d3850675a0287908cfe714f852bdc30e9c6c817334c7c9e5abf0b0fc6254cebe9d4a2a2da4f12caa5741414c401b9a992698ff1029c9e8b98c3a6ddd12b8d449fa09104b6a9a0d9fbd3d9494b86fc758099abeee6c4402d9c3713e690083dea0156eec80ad7d74b30f381f07913fcb1b2aefb569a1d13d45d83901231d7045470c258a6eeb0b20ff19b85ba0313547afab10b37eb10a8802fca3c87ff6546f90791ef6916cc98a2156a7b1cf3094c728678231011a3d2e89d3fa1b98dbe413c6110a42b9b4865cbc77ec56e2a56c4b7945b64234a15f5bd3a3389329cc29a69c408dc406baea63708d383ae7205b4ee8fcd7f96cfd05bee0d67922f80b842b3d661b60a5e55590d8bc5b9846b75d96d8011148bc52d3a38ca96f2a9fe7e5aab73711fce45649330f673b54305253c617d8d82b910d404f67eae4f9afb537b4c51a7a90063baa6d2927545d99c6be4f8ad2990f1fb7df21daa67087783bcebf66fc8fee02d056a1a4bf6fe00c67936cfea8eeb1a50fb4d9cad23bf2919830f7f9db6588da08e92d15d82d1b42d2f885a80df40a7c6d2625b2b73ce67b1e1fd0f1bde7baa09624941467791dabecf469017ec6cb8a52ebdaa585192014c6b18ba93dda9282381e47054fb231acf050b93b554610a0e4f01492a5e2261637c6957489e3392f22c49e3bcdaa6384bcaad6c5ac8dcb5be8de7ae906df2454c41666c709ea7a7a4de686a88c79210c746edf6cdca81319d2905a97a18a6a8b2ffdfd1703956bd5a8086d71ef0594f53fae21d00e5952a33278ac270cc3de745e95775cfd9871c9d51af7a8e012ed64fae0907937e8e6cc3cdfb997282651b8032585bd6800201e5286a750a379cbac28b769f64704ffa457fa4aa2b7d0e8a05fc0bf9b954f09762876029245dbee9b8f5f12c96d9c45f53d50b69f645ef7936f058e38f9f65fef249659917abcf711dc3f97ca190acd01816003a0f0356d784327fd58d1321099816b95db424e55b46ae17968b430e088db43e2813e05fd2b71b48d6540377731573c7e781bdf59afdb3af6b9e316d830852563d1f2483e4317a083b6ee6e55519ba73ab86071015c9754ed344c2d0d66b9a0c564fa7adea602f32af49b9e3a4abc48e5b875a97fb69561d327deffd832173a8f1283e602589c7ff2f1753df9871d68ea40c537f6ae8f0f63564ccab74d3c2fd075cc4605662f70febd4d100196c3faa2adc8067ca3113dd9d36a2561935a542ec332f2b0970b10607635db84163c1595e869cec785c6a9dee3cc8e32ca093901ef486faf0ff29d8478e5d0b1fec53a70cda828bad38b54167aecd8fc4baed52fb596d5793d667c6d08283a4663e473fb7abb5cfae16dc11afc282b4e3a28d15b185f654f855b1dfb7e643f89d9ba21ed561b4612063a9960ad4412394f113e2547e11afba355cf46aa5650d9c070fa2b3cbeb2298cba6c9050a47e80952250d828ae3a03781da51961726ae75d85dad72f0b6fcac89cff038f9ccadc336e0ed82b6cebb18621955773b26a01747b8bcf4674735a6e94847f74b38398bb274aa7e11f0879c9d20000a80e079925119a7c543e969d6a624e9d0df237a98003e53f48b540f956dc240a1df0691bc2e5ff12a9f63e9aa38ed0f91e1687dc0295086a9b98a9ab6116184dd047af4019d03a518ef07247db043e48769db4a26a8b380de8f5f350d0319f5db7c3d655d5023091a4adeae61ddc62c65bf111dd9f0e950f8994badac37ba23ab0548de05c1209cc99e32eed23ea2da52855d51df02ab16ac6d410843ab1e9882c5c75e8a157b456bfb623e0b4194cf29584be48eda8aa35e0e79924e8144dc12326a94fbb5ae7cd1d929c8ba30fc009ee8b407d508ed39b2b2a4705e591f50e52b887cb7b890ba513cefc95bf64faeb7d5448d0f752b94c7d77ce49f6d98b4806d2bbe9674e7bef6450e44a10d27691fd7b9223322f0f0eab916c894803dd8faed9c5de0b283eebb75e906f57db35d69112eca75840e636c78b4347c092e22bf99f4f99f6f20c2f591d97a76e0f9d1f85c6c8994211adceff9ab0577637dd98d07d33dd751e01a4089cf078abf70a8edfdf1698e9a6754887c8c9be352a4216e51e8f8f3b4de51893eeb3aa1dfd898ad4e5d3f78b3dd126fc89342d39d466e5d77c6b9ed95a9e1559548a249fe846386ee405b1852716c2e98d0b0a0364418d3a83ad302d73f14ba8af32ee5ddf432348527c725f8baf0b678e5d53fe74dc6ec54583f3e1f77e8e2b73acee28596924facd247ebab53e28f2468b080ffa2b52a4baf32aa7d6328fd25b042b03afc812cb2f9d66e74b2d63cbafb30d3a7f9cce41f2492c4dcc137a1ae2fd6981378b03ff704f3979cbc31993dd3bd781bf3426afe2a9ab5e054d82631c57011b8263fa9eb2ae5cd7a062de4665dd324b4e26dc0ffe2cf624844d5f74090e87ae17bbc98802a9068a44f1d2e962e5db8fab39afa5caea01032111d40354bcb859b03bb0655814aab60c9e4d1b3d702b7f5c073e25f6747cfdbdb0fc1151aa282db1cd7ae34b2efb83c446d5fe8dce081e24457433ff1b30dd506aa999fdaa17c94274027d7cf52a2fc9cda2bf58bf780eee808edb8e512fff802d7c682424f3cbd518e72260de1e7396eb6403012c32892ba530132f3ce151e100076a1bfed10eef1b1b8524c4cdc07592a365b269b9e8cf27c3973d6453c07ccedf7f8e5f8423939605f1d6f14ed6ab1c2f241d444ef5c3a8347b4d5b26c18df40ee784d94c87c1da6af3c9930a21888b3de485c4db5645f5a69fbad1381ecd1670a39a060679432591b644780a8ef7cfbeac41c89cf3a535531f580bf18401ec87065353ac076609ad2425d605f6b9b256c9de7dba433acde0362bc9f2f6791a028c5c2510bfbe7dbc47df34baa3663ebfb71fa8ff02847c72e0a44516bceec22237a202e76eb5bfc815a6c9dfbaecad5b8f58b384aae0d6266b923551765b7dc9c1ee688728f8b491d7c12c42926391be494815ac7165cfb102554df988dad0dd2605b0aded468e014259110cd2bfc8e587dcbfeb1a03ed3df33ca26ab3fe9c63bc5bc5ec3875e0db3cbd0d0d69996d379b79f2d6fcc1620390e7f542468b87ea7fa6b28c2203ab7709b07f498cea716b7e42ddc49ebb16f39eff12553ab555134f201627437fc6593cb28144d84c3878d21c391ba19b404a8ab554657c167ae3a450a003af8a93fa1448dd199a7cf2cd9081dedcd10942937662d90a17a682d91958674591e83452d787b98bd222cda95f51a0a3f3ae0e8370c5488e6946c2685c17134278b195a5f4252b15805695437b1fa02601a6bf6030189c2309fac41b4b5409c2275e535a91f1aa21955e22410735df91d2b384752293cf70d88b05e5c7fe0e816f46ee1134461eff9b661b20151584fd6816d93634997a3291b08aff1f7f07f0bfcf1850d03ad338e36a473e9fafb5133ef4343fad0fc839eaddd546c96bb1552cb7d3f3f62cc73498c438ed0e9711614bd300fa41d360779fc112dec56f38d96304d86fae75a88615ddd068a65b63e22ac10ad8c9722b5a5c3d9aa1eb8532696af425f07b4b775d0726f235bae3da75e0c34a8054862afb147454ad99f499ee938ad7052f00326a1fa1e3d84d99b063665ab506ab5520422955bf9e1f112a410f544bad760ea463f7d85eee62b0a6e1fb62bcfc25d87d2c76251c778b3f8beb9a550ac6ddd7c3dac921041ae816004e8a139d6ea947fde6c9034dc822ff828793fc0af0085d01b8d631ded47659e37524527a2f4c257aacd64d1b8f756223d59fe8e9d8fbf080c2cd4e7f3b930a1e46c3f3ecc238f200b2b594ccbb4313d24b205ce7d5656f7928276c12f914701105570b3551427339fadd1e7a24c5b4c64b28b130b18792e181d23fa4296a23bdfbd9c4f9ea0d3e38b63cc6fd45cb858255fded39fae4dc158bd5258533ad5b79fb267f281831bef78deefbc111bef47ba98d5d3ea98eca43551d616a48c73364119e19d1d64b892a21fb06f843679cf6efeb14db011bcff6269d1a1247c9a429a0395a044eedda4e44294ebc55b42a61057226d294ff67c51a346f79d3a7d06c3b8fd04e66f0291c4e4e67d1a7ecc73e0c6adc197c6247d47299825532e6622ac29e16a6054d1724842bec3298998997c43cded6a5c71fddac32ea4634541a203471edb7c1d455b574f16a0c4296f4ec130bbc8a89aabd3252f3372769e06a859656e7b2a8f6733c5aa3b5360e2b8d957f59be1bff73ff31b7e6bb97c2fa24b97738ec3ee1981d25ec93c541b66e89cc3aaa2d4b3c3eb0c31ae8f2210f1563a00d0c75b7dcbbd6b4f913721719a6af04f915a15b8e8241394e46acf789581cdf9a7f006b19741368d793f5f525545bbd06e4db4982888668e2f8837d48f82d3a0bad69efa6e46fdf98fa88d9115026f26d90e75debed5ad28692c564493c09ea51ebf0a55602e1b2215b02c4271ddb94dfa59161af4738585c340daafa37555d411af70049d167d25f2d2347f920a8150d449db2aa8199a23acde4e8d25b899439c36a42a9418affb4713f3f5d0c7957153406afef15f750ea2013d889b29ce9b5f686d199b728e628b56981f05d9e67c4bded158a9fb5859bd01f275cc8a8a60015f4947bc5834998e007932f6ccf635fa4c0365d4fa6d72f0b78aea941dab930aa0d17db328c4bc05336fa40121730aa9897e33d474ec4c27ccdf2c174e4d3b929a9fce54b69ad6fa642fcda57bd3c5b2e907a6bc423effecdfbe92df09b0da5535f3d337992fd0fed9d662c1463595372327fefb69eb945c493f902de9d6472cae91db7883fa7ba672fa73fc5b8f79ab31a58eb09e31d2a63a3df89ab49ba966bbe61e1216db4a3a3c0c6663efb77b91a857fcf09ada02d5b217ded8c422d92b4767c4e84753c62b3240d7841ad0d914030863bd61bbf8d9a18364ccf18bc03e381cfff8094a64508c729bf038a73b15f71d60be817d7bcf52a38bfcfdc9a13e91c7b7bf7df1cded288be61c85f0bc3272673d5fbc5a58b3f5b54b96e33db807e0b0010f3d43f7224e6389672d60fa04193fa9e439645f370d47de5386dea3213a526270708533dda2b44981864f0312e47fd056905f500b3898b5645429a66ecab4b3f84c12bfa0dcc6c54e746be56cd2ea09b9dfda6ec76532a73f83e05bd1dd29a64b9666d39ad53bf288a1b12e172de19d351d44954605426574e7ae2bc9b2c76de15fdfb7a5971810682751b34ab50774f36c95145e67001a1837020d0d494fef1ae2adc7a2e1580825bc10812541e0d7c8f921e531678517622dac296c4533bcf88fd0d7359c24e6283ca0836ae72ecc551333f4b1aac84ace9dd2a6c406b962e500888fb6dfa9f77f6d26e9112316d53081794da068bab4405e7bb8c2947cf57904ee092e8cbc604b4ca9fc27998d37aa756734fa8a455a42f2011d2093d8a61216ac0f9a2c28f5d2422ae6dd9693701635e503b877903b2a14a29cdc49936e88ee70069c0e85d221b950f24390ff78d5989c9ab20991ffe2b8278f107f527e362344237b16dece45642597bf0898dc100d36946ca67472a383e7eecfb3714391ddb02bd5f5cfd7ce72e9d4a82f9aff03ac04c8f6519cda812b162cbddd464c9df8d76751c03b730403dc1f2b952610843473e5086fd982684e9f3e061f9a8f3c75d935e269f1ab4636622f9685c27870e2f70ad818b4d915014c1d7ff49f9a345a3628b14e53f978c49840f8e6aadcadb8279884966dbb06721ac54a346be3b920bac8f0ab1efdc7146360d37f18cc45d24395b81153d9657375107898653b9615813672f69df103439353e1430602fc6d62f87453a43d1bd519bacced4309323c29fc83c736085ac008fa31ca4705a72bd9dbf84085b280062acf48a822a58209e3d42db3b6b7c20291ec08d11a61a86acc1cebb823651de760e698ad72413db425f52efb2873cba7ad61df1f420e316022bd3dc2cdafa2b2eeaef45920ff56912a158c95cebfaab6f1335954e695a31822b3c8d3f7e8210e5dee92a521f738f5f064029a02aa6e870796b1d2b36960ee7745fba17866fbc682aa5b35a0ad89ee784c9fbcedc27a77448bf1536ddc709f983c3a44807ba1d02aef7a10c46fdec43ac0990fb7ae4cc4d7a1c6d5f8dcdadbb743219afe17505b02fe20e276aaa3dcde65f8bc1e31bf65594652ab772adc25451e2814314c38f1f12193b04ef651de09d006f36bc161af5184733be7c555c6230cebd44528a81cdde62628ca1dd94f5118dfd1523fcd35b844ba53b3aeafbade0cd6e21e4e69daf91e6429de57aaae150cae72ec51235eb939e58a2f0889aa57cba6be36593fac8bbfa32c8de4c6c44f1d2ab907dbb5354f690028f43cb5c1ecca5c1a65d56c43d2305b1359f8cd91535f6dda1d1176f09f6958046808121c973da52a7d28e7f8cddc44236118a16352df40","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
