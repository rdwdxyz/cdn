<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed4ee0be7b41a92b112c98158e94b11ab5e6ee681a0262ff2077453c613d2304a1c8109f5b8fc9c0ef5f1c691c91337ea5e0ef4f0f51a28cf68cdbab8a6dea14d0bf0d9bef58d48705dd7a13fa26224a64eb3e39b612daea5a4931b98932eaf6013cd66c55c91bf996a67e6726813458dda84bc41d228df8435210058233045ddb6bc750e99ab6c5922a9398d66a6f5597de63391d75ef7eff69ea97bc59ffdf8fad66c83d1aa3b38b52cbc0f65985d70c021906833cd95a161cd6fa761482d2da22503eb5986654fe496f8f4fe2a6204f704aab468446b3aed696b8519ca01be8076382017fb58ff990e4e57e0eda14ddedcd62332ca942773d024a227ecad84a19ed4b8a367bf13d466e30134c85f9a37accda89a4fd7e3289b2c15a805e78d6b787fb8c0683eec31e9eec78347fdb479b3c8f5c39c9f957a3dadb1c9679a25ded5bb4bbfc2c200b343834852f9f6a69c9de2bae34cc988d1b3b066981d3b668cb41fc1bb89bc0e39b1cbe044c64a807a4277e744afd4922c8fb70de2cbb4e4c1676c905fa64fd867d8652bd52c13167996456f95761284964b6240c1a70a764509351dff72d1cfd548b7bb41a8950f8076467c962192f4c8ba605eaf4b110f6cc98aa1a5798a3b457669acf10bad7069144d65fab22c8b85fe9edcca67ebcc9f8f6817b47542fc7be6b17a608cf669f1b82e22e397cdb15df5d136443c497df86bb2166d3473948089dabc6eb14b35145aee391fc42532c54e15f5191270832f6a6c8875221814b03ae2e5e7adadd5b85ca2e9282cbde10d293469ca74673b07ab71c3279e839fed07da1185d55b3a6d785c18fc7333f52391225c4d36b92128d0e7030f5f553e781aac6c0393bd030c20c91e25cfc0b22a575d8bf75f317a5c0f252888685a6f15306d34c9e4c4df78ef54749b85028db11857de13c711494381ff72402328417b09b5bab5bd1d0137598aab0fdad26fb13947ba132678b0c53a796cd4faaf211071d3cdafff0915abe115bab1da702bc14d661086a71733c9bc86cd33b779db6426c8e161b4750a05c7fa1ccbfbe476fb9ed49cdda6491501ab3eb3b9f336f770ffb308a43bef3a87e2589b04bd5aa8b592c23e3d6ef6065f5666062f16df49504322e7669c8588d89300956f24cdd10d4d83dad1014b525e6dc65e1c9c41c36e6fedde66cc7e5b1f4a55be2783dfb647c3c4cdcc734d502bb57d4b02294dec5c6f27de7ae952224bb8fb8b7717b0d0a3a9b8bc794df0feae53e03f2e7e470555b1db66f6656d0414f878f7791f8011b01ea6324cbf62349e99348c1c1d22de0b9a04ae75f3fd06a49da70c53b5ad712261f9d6b403c9ae318696b5355f5fc8fa4ca8488ea60f64c450efc11bca26a8cabad780dc10c3e22f90319692da83724445f6f68183305e808d4540c6ae221c06b01d4f145f4f6afe048a9649396d0617f61fd8a26d8cd1a567f7575848434ab4505e3b04fa93e427c638706b34641d7bd74d404831540dd4f4371ee6bfb3454b6e8bc959435a39c0ae3471efccda14158042b9830c20e3c5be1a9bdf0471b25e1decb8b43c002fb74a832134d49b604d920ae4a2f24af06b992da6d21497c3bf8ba1b74f35c2848dded8a95b1310ff0739f37d56e70baf67065798ff6a1db5db299a975be0dd2fc256d382815c681a701b2fd5ca1af54d6f1b43bb296d03f00254d2718e20bd39e05a7ace796a1562af2efdac6e4d382f28bcf7592e3b317603e5ff1efa3353eb7253573ac5b7a3141901845a46db4ff149a00da45aed647aabbb5fb288c3f375b3a491e96b77959ac7694572ed548b33a4ec2198709160de8232f4c37185ae6061008d0e858672bf7983360d828dd08d2028dc93e13eb147e8e278e069691208b366d448eab34c4c71cf090dfc885f7221c94c5e3b59a7d00ec8807464a2c53ac581f8341b34b7ecc3735a7955b50e51ae5a05c5b0b893f8923c7d5ca8e5cf3ee7d392492e6f33b99a2e73e87f1ee91f83c3d4416c4570ec23fcea8eb0c8367f56bd8f0c67cc66c00042aab972acecc1e0882abf5ae64e6d26c9939e214a123748be70c8b04cb86da2418fca89329547267f6fd84f09700e75ad17403a04700f6217a6da01b01e8bb5901bfae4c583c06419f3edc72a3b72f514ae6c2334ad3b02495e6239662ad4d9a902382ece3cd3c0d00fb812aacff013c7337e02844101fe84ec370a8c293d0b73b96f8f2a26ae12fc3e90138e58a7edec0b4a15603df8e1e7cf4a5ac82dfc69d618e8328ad3a292e03c399b66ab834167a79a5023e72d7c544e69794737f380378656f3a2f0d7f40166ad32f474c6e1bb851ce8c7e765d7d405872273c01ec6603d6d7680a8b4a8590ca9225adb218e56fd7d50a6ee9cd75ca1cc929ac453775670a61bf3d05f4f2273283cc80d720ac9e548cfbf5471b3c3d27ade09717f05375dbcc2f3f09524d9968ed531c0bfcca622db260598f4037eb5e5a27627cd04208293dd0a3961f66a9ef26cc01dc8b3c24b2bbc156e8ef79d4a715f0e89b8d14bc1981a6f5c30bebba295149511489ffa2108772602218db3ca738c60afe38ef706c2c32ac9b8fd4b795fe7c917998db0f28899c879a931dd197397396985bd826b95a2014eb7868b3f0b6de50b4c56825b7e28b5fbcc0db4211590cbc954a96e54e09d0979c4437fba682dcab9d7854344d456d9eaf335db18e1146b3b9d6263fa7f14cb6704656cf943eebe3ddf3eaba28867641c7a5dd22fbd3c59d9f8c4a6d4ba8f5fc545bdcc9f09341113fe025dd06a99d694a08d0042483709b5d9e0a6a0b2f1a54d179785e6708c8f4bcf4b25984c4381df3c0dd4a088866441e2f5de84d70beddf048b5f6c8075bbe1e72807fad3b8c2447903cad5778427b63a930c1220e00721f2a4a756f5ce7ef70d829dd32b263942ffffb4e048e36a1f3fd3143c785f8f8d29aa43f106b56d6a86f8fb79a9b751e34ade3fa8117584fd4a11aae5d3b65404f43037388cfe41f82b48b63583c13af671f8c70225a88b8b9d5d2829877ef91b6926ef6836abf73024a09455bbe3840e74f5f674301b99a000faa760586ceca93a3abffa6657b377b8d65331bcc0109e8b944b6e40749bb26e35ce86868dfe453aaaff5661e108cfb470be92aa23a215ce77c62294d9316cb13deb671ef4fdb4ca7f8b9cb65f0ff7eb8dd302ae8d4247e1eece6e0c006eceb69ac45ba542d2d2fb3b39d5b161249b787daa6cea3d3928fe1164d6ed79211396629bb2d219077760689f53583390f3615ebd82dc5e70434a20cba1fba3d8bf32ab2a4d3e0d61b74e6e22ad49788f94e9fa8b2096de9c71c34af76032d22ff53fae795f228e2367ba3550585a86ca12a3f46ffae0e42516e15d70aa86b1bc84a71973754d24af00501cf484b16bfc185e9d26c788b5333f822e6dc5542c599a1ad9cc8e1212507cffcbd08aed8e33a21a18a9408baf3864d09400219ae7204aab1a6aecc4604a392e1f1c8141a538867cf359ebc378be2a61f74565eaaa541ee4673cf0b5fcb539908568490cca2752a878f4d87c39c1273ccd6fa26cb5b1c290b8a334d5b9ab1a22615095798b8a2f6837adb672162e76c4754266e986060a11d28c1b61125821b1be33a2f809a0c8427bff860947678bfad45bef083db0b3463fa849c07462412788a76c2f305149bcf05cf5741bca66eff95a589dc482a12a5bc6599f234cc6888bff6aff271060b7d94e4409e320cb1d5fe859309b3929542f32c2117380476a1438b899b3d788cfb557ba6dcc5d76bc2642016340666d8c4b9b1026f99f28bd815aa0dc0908259cf5b8da4543f81a560a3eff2efeb789fff826cab98571ba7072943ff61e6b6916906e56f919119e9591f4ae9fc9eb7c3287780989669bcbcabcecfe3b9669c6f67fb29f1632d67ebb86605bd510845be8bd6fc5d48f5b20bd736e2ae3804a20094b9b6fd0a22f001d6036cc3eb67c911c1dfc2c3f090906299ef3a5d9839cc49a9d7b5647cb45af385f4eee2323ae827cdfd3f7cccf7e0cae48f8c19eaa0c01324dc6ed09ef81cc8e9e82c75dc14f87556e07beead4469a37e371a7c9cee127084999dfe73ad1201f61aa950549e3f3dbb23d28f956ee0ce0a8490dcfa839207d510077b156b0165c866d41f2f03a2523430dd2ca5df7f2f4b637f31ce95f6142d91b3d4d2bcddb9a47dd0f08cbbbbb99f21893dafc60a0a5513568888e0941fecdac011670cee3cb2fc5d15fb57add94c30cb5c64173ea9855cd3bd3e35969fb3c3d1ace77c43e7ec9608ea89963ffa331ae192965ee584cf83722ae8ce080f90ad06c0791c775f83a06fb48728258a6dcc1de561f4f692f29ac6fe942280539a36b04b14b80b7ffbb9efe1ef1d4082680707c287e5541c2fe18a2b04c28024ba97d184896b7c41d057570e403fb895d87fc88b7744112c10f2fccb5b9fafe294e56624bcf8c232023add147dcfa4a6c48e5d6d32445a671af1e7e1d4f72ce55967dd7aa434af3c610c022937afdda1edc44edbf08ed0bb784302e4f513de6ec5b8b92a9249bafdfbf72b60ce7a8b22a071dd26400ed3317b8c3f8f37b19042cc76ec9be293420537a1f648761f21a7d1e84ed6df5f2f61b93770468fa3e193ff89a3340adcce28acc5ba0f2525e73a9bf732617adf313a02111a4e4c53280938e5417fe5d7051b11079add5aa74601430e56f7566389342d7d3c9e070426641b389b69ff001d29270a8cbcb433d46a8276f9f9db7df3c862dd376676fcf3e4b39067b61423cd1932ed09e9b94043c41bd2cc64ec582498ed4e562f34cfc475bb3d7780bd9cf0a143f3b4684d33a51128dcbcbc69edaa8904f8bea929af8c40b72fd07dbd310a520f1c75618d660d6889e4b087b2c539c2c5e063db8f1cdb59e5f8af2214c763756fad1cbb4c2d1759d8ce2c7d6aae782688e477a999cb88f676b05ac3931eadccd0850ede2f40bf19e2c9c0130e83c9711c9653db71a840fb318dac11461844d2edee018b5b88ff4d6983ade6da8490670744c331adf1e9b975bb20290fe15e675ce4badfa065b879d42ec3a9e6815609d059f5235385b7f8acd51ac1ebe8f42ebeb53355b4c60868b9a287c2f0d291dfd5144c620ba8a056f3a6af1110370bd92f26e49240d6c4b078217767f3dff272474d907da7bb435837f46d962b756d4429f1675efbc51ca361760c4ed004e7d93b040060716048d5f6dc802350c24c08f84d9c9c713568de8d85b79999643a8cc8695976b48f8d6022167737a60bd3dec1064e45dd75f73d6cc8b2b872c6bd210791dae140cc137d1a3ff0072e9ef8f045968b6431fa223bea8776a872ce2db9bee412d83019fd80a110b6af93ac0ef24a679013d891b462bf4802ede2f168f62833d6a0ed75eb4d9bde744ac6dc3226fc98b5934030e9d1e37bd198d913f792e201ce22c4ac4393a71f69467422a2d51dcffc86f528cea08d671a41fd32d64c763d1a39978690fc0743275052873e7999feb167591fb88a5190bd03bb403a16d48f4bbb72f5376e09a41698f654c5451bd91fe2d5f789f21ed28689f9b00173996bed1e65ff9228c06b18a7cbe69e1670cc9f68004b418c4dedcfec9de53e3193388692cf85f09cbfafe05c9c4bb10b2a60d1747d847d287679a920d9b178c83465e0fccd25d88bf3f535d4c33fd9a546938f38236ceb28c738cf2beb0b931db1a809ffe044e59c46c077f50eb989a7547b106445080e086bd856869bce952c25c14905c33783359e670a2a56ce8cf14d78867c101a87887ba7e4ea0c27d4e74f626bfc466f90d4e86efb86a6d3c70ac74ef1faa71226dcfdf33e54aedfb1aa7c76d31cfd504a9ad8adba5313ae43a029861704a0577fa338d1e825b076880db7e523172d51b29036538a0e00aa10f5d57da2d56c9c71d3a7cb0e56535924184601d8461d9587266244d47f18c49d743e884e171cc42b41731bfef64e7c218c8283f48923600d316d53a87b3205a302f362d595d49f0b6c646a50394ea32e5da15a69c7eea4c8d87a2e6faae612036939aa8ddb20d2890916291fb4c736d219c05706c07ea04ef79638e0062203bd78299770fa305cbfea1bd3c7072179bf93c9a9ae568fb59b00c4150355551b09eae9b2d0e241fd1ba8e04bab76372cdb526dec7e68de189888523ae02d184079f5480e0151844b5abc5fe24b0d50f9679b622a3a5fbbfb04bec3b06f880105a28177a11794518cfb36571ae4993fe5133cb41aefc727c430835bfcd6786a48a9c1ce411f36f08b3f3eaaeed6a275cb2ecbec02e056ca085cbf75d5e87863d2dd54cd20c4e53f9f6699cc798e3f84737a585b60835cb687f6367746e585bbfc695e912d617421c7c6acfc1fb70d2a05a7af947cc5d73e3c29d726cfd81ae7954585eedc83a60bdc1a315ee2326324176d37a247048877c4423d27db33ae592c9119b8bbbffa7d92ff08c7348c819f1aeefe8546966b2d0b9a0069805fe16f4fb14dbab75b8bfb9e459d9d6779410aa65900e3fb11cafc28d74252ce4caed02625c88948847bf4f2366dfd568486a4970bed935762a70b8c4ae31029521bd7e055683580333c20506f02678f9c9ea1bb6d9da563c268c44e05ca1e50c9e50bf7c53b523fe8d0c232a381b8c19becad06987ae4bf9b447cd542b7870dac39cc300da6b1cdbd8c49bf03a1bb573205bb68b981835849bb91aa70d75f9e49bb4719298f2d97306939a3270cc221da42169f796247699fa1392fade865b9b4d2078303e4238bfe34196e78c50d08cff23a03475ec601e3d7b7e3b21d75623ec25da06dab7f24d78172eeca49054caf239ea6010d11d263febab054a1cea7cd5fa8b1520818a4c44f42f047f7de2db75e3c0fde27b998871d3ae7f10e829ffb417eefe852670f2ef5606db70df1fedafc4f76de38728b7a4062a448bc29863d262cf5cee7b146326c8a764f82e933212cf35c59657044b85a81272920cd2033597ae97aea353dba4a6955de3848c07c673d2443487ef2082987bf01f4142c7d22d6b125e52fbb720248f02cc33204e02b2880a2d9936d5f40386a678968bc8076a83adcc15e1a7af215495c03e3cac6538d73c3e94983ba6e7109f12478df807a60181c481756e101e22bb60b38383be5c0958350899048c0598d25e7eabced87c7b02df7cba859ad4e1cb4041174ce18529e01a7eef71f2077cb5dc5f1d66e14ca88d5dbc34214bff0b0497252e88e87dc10e85eeece61bd7742c8f2c11082f22f3ee71fcbc6abab7fcecdc58ceb27fddb89cd78e6b36546cd7d52a790baf9a7db66327ead57e46dff83989b1e055a274de4614173ae348f435b30a305bd574a977f6c19b3288a145be275e21eaf12acd92d95f48342117f677de4750f2fbc0b6bfc0aa403026caa997a6f41355600fc739db71048bd9392fae1c79fa843f8c4eda93b71e151f7aeb1038ba217cac83d8c98bfa741dc89d4e8477a69c14627c922c4bd092aedf9ff65d011adaa7d30121e33210cf150b19c3d14b02fe084fa37654f77572c33e24aff9223e82e500721e657877c56a977d9f4ebd8bdf8dcaaf8b8432e3187b364954cb5a248b320981f11347910cc7b220d79db4d7e549643577656c1ebbf26c09b2039bb0c5aec96d657005c9cbe6a75941db5038aabcf60a2d7b76466040981cf82522ee338d1e2bed6667d831b8f9f9b2e6ad3a5a36ee086d0ddf9ce30e0c723278ff6c05592e7f937839900b987d0e004c49c456c3022435bf50c53b943a47349c330f83e23b695056d4ac730b044833060c80e8d36a403a079f14cd1d8c853ea3ae549eceeb19e9435e9c8ac8f9d511a4c896838067ddf6ac1c1274a3fffbd658a17a7026b7cf149eb3c0b614b687c798959a5f8eeb124736cf50cdc23f5c431f4210ceb25aafa2baaef2eefe7996f01e97bf7df365d59a0a32fad2fd8b3569b57a3585e15f3e203e4aab014a2119f0abe8d974b7d377eb981334d78d168edc827c19dd61cc68fef0ce83a8950940a9f5b5b89480f8dbcf4f25e115f968c7c6192d291370a6b8bf7e00f995545332915f04eedc4529c0847e114c20ed5a3e1754c5c067c99e3d813255bdae5c42c142d0e08ea0d9d5b65ad8bd8ef11eef0cd99abc31846c02e12dfd927c3e9a54b3035afc0c3222e8a751d7b401b861c9b2231d50a6c0120fd1e2ed55690001b4b7d5f567d35cf83d8303ba8e3b55fc6e8a622ad163deec5499ebbd1e6bf6e7224dc42ff431aa5ed6ffc713225871dfac99f75c1f0745e8d3ff47fb5688d6f95f3a6c112142e2aa8bf7a432ec64684cc51c8655675185789d7f3f1491c8d1499ce5be2d7195b48312f576f6ce35c3b71eba3f2c0cecfd4e89bd9628126fd0bbe18c4a402f2b5296cbc2132f428f6441556abde2cb77ca75c2ec2bf36913c3a34760f6c88ee64e2765c85966b0387ba36dedaa5a9caab9f89ab4210bce33294cdbd6543a6ff0a1f013dffa51bf42d27eb0ba34075ffa40fa9055b006dbb0a213881fc911d718567b3f7bb1e6c01f9e1d4c886ac935f2cfdf0118f5eef5d391f924f503eb307e75e2474634afbda2f63f3e8c4162cd52b1148280c4786ca87e197f3e251e04b165e2a316463406dd70a32d3ab67edf32a0544ebce47a9a68768b9e18c5fdb47f90272dc3680c39867668fda6e0e7892bf48876dd5c6ce24e7df8ae390e9ac3d8945eecd7186cea8a47c5832a375331ddc8d26319b08a7549988b11ed3df9adf5465bd1082a1b785cae283ab6e4bb7b2f506c384406b142a451012ee81dd7f7cea037765dca05d4d5aa6d581f00c1ff2591c75671b19f3352cd1ebfea2c9437f193c6f57268ff4a0fff1933551ded8169fe0b495dab2df73e57bcb239ef4d166f7abf337f7c701a1bf3cbbfb1d17d046c1600e73132da2f729d6d375e9f6c44ad7dc36b1896da9ca6cfa95e11c61b0b030fed3d33aeb56d4ec015d30b46500018f9cf05e207bc943753bd394ba94a9268ab9bc9c5e9fda234ee9448122fad73b0bad59b1dda4345053041422dec39c708f2a0eb14bd9b3c345523adcf6faade79fd9903a85863904dac228152bbe5146ebb98db329ff19bcb7dfead211bce16946c00ad01252f64cb27ab0086f9307380845ed36d0d3058ef2d764830e9717490f34ee801c71564c1078d0896a81359205b4359d359abee4f4144a3d3a1e9f3b05c7ecdb7a37aeb8844b705a3ef410f63b481f12f22265854ee92326e72ffbebc9f5b6e451df1942f3a0af8272c29df24dec0440dc88f4981589f3caa69486133a482c374c482db758f9856f01618ee91ce10e05b134579a4e3b579a8e91feddaf31e52e41b7d48088621cdd6bc6ea35dbbc336c3c0b74459b8e08d4130b556a852ef360a4af9b4e278a3a2d9722419817a21afd5453b3c4b69380a7d9eb081e824954b93f022807b360eeef8de9d43527c6e2bd78117023d65d6a5314e4876a235beb07af57db387f2da0d6ca3c73d28f10aabcdb3b3702eeea75e7536e735dba73e453d81f70ec4cd8c5b326e9ce80eaf4e4bfb3c8c69906569872e570d852fb9330dc4ee99aa74967687c9fb2fe7903495935e8fd827f8d051318266b138f1f9add66a0cdd756aa736bb1c394c5bc8e73d495afbb6431004e499d5a8c3f42832e341a0a25837deb1494cd880a25c19022d543ae56f3013982220a2258ecd15a343c29e9ef322b37668266b523c431f9447f4f2931ca7f9d4e59a234577149fb683467ff0a29bbc2433924f553e7c605b39ed40038edac326da168207611589dcc6d53438682f862bd7421abe1fdb18785a4e803384d4def5438e51a9cdc6313057945e6cf36df4f430cd280ff3c255b4049c0193834a77c83cc99f2f6f670395783f95241f8450aebbb19ad04cbe1f6ef810d826e5e2361a32ab3a157de8dbb2b4b9c66900c50d1f64db7007d75c8671e16e685a76c8fb50ce7259def0e01bfccc4631605146cb0aa9c312ff2b3a3799df5f59205fc6ff7826feb9f2a7f2ee3c5285c9342122546f3fdefb64c75ab7b30bed3f4d271c4fb48a27bea29b0b50053b301530415c4430bb121f5a7a192bbcfb8d106437588f3303c50fb02c18d6cc1e671a5ca7f3a99d89dc3cc7cdda051200a2c46ef1678b29aaae7ac2342727031b4dbcbc65a94943598a3f1c3ac2ab0e31cd0a41791473c189e0081e4502f13a118f08d1730eed72f14234d016df0f6e0b11d3cfdb42a0a008fd29347ad2a914f8c546f616b1a8d4b910b30f3098764e934b20426d445e291ab9c7d3cb5f6220e706cde336497292dbd50bbf73c517470dfb20eeebc78d458879c2cae584017feaa4514868787355957c255ecbb4bb0a902a9fc8269d210bfa707e9cf9597129f888543c50a0c2a3d084e94a9bb53512f3c3c8446afd7c4ff30c571aa924974c760bb666a32c63031d56f21a40263db6df13b74fb9d4da1b235290ccb6fa908c93b5c5af312ae8e54490b16f8475eaaaa28ac572d4af46274a6690e35d44ebf322c0d73a618d76f7640e9ef4379fa9f9ba723348d685ae164b1466ea9d6522792fbaa605c2869dad99f38267f42e0443b6daa9553eb007ecdd959bff2232d9b451c6bcb34f739bed8d020500a3bee463219166eb6d205eff14f821f293efc1782ed33ba82fadea6ae33ed68802b9edf6b27bf923b1c5173476285d9c0f6c277a5238881ab7a42acd2fe57835f4ac8f0aff8d6f78ebda2e0737a75556f4a4ad91f96626ebabcd3c3968cc608c9ac8bd5fd01cbbd42ca2caee4c6a5e085b8aeec1a1a7042af19cb2a213703b0a99e1aed917d1b89c521f3b6a830eeccd7cc9753cac4a3826c6f59610aa8f6b68f4d0b300e8483c7bf3ba6d816d7945ad415ae2646901e8fdcd1935d94bff5a7b282449f3a471dd594361c6561fc655c71e366a12ae8e900f77693558a664da0517cec00034efe6d85a3a5ef949477027431e4efce5e80153dafa1957e75cd980b68851d04941fbff4881e251f368bd0a9cc6dd4f88cb57b27157c4b31a6318a75dcd1fedf3df357d5ec175262f3f230726273ffa6d1a8e335882c14a3f2ce1350ac70f2921a64d2d44e9c79dbb1230ae69c00a6d219e82f80e977af17f931c82291a105a17571f7ab971815ffaf899f9241d3f0873413c3a94eab6f9223bc621c1f90378fbaef3fefdb950fece94f0adcedb4d3577e262fd43e01e4ec7b7e68af91316543afa40258de24a42b4ce1f9685ad7d02a3228941863cb37d0372ac6fd584fef4af668b30095cbbb9443ab8a9848b645e6804851937082c1bfbe432144ff39351d4597f5bfaa2ce1e9a8fa79b37205994b4ca6a6bb5318b16fd145298413e8a6f8993fa99720c2379987499eb2a9c3c6f8626d5cf8d3b32fec3e6513f8f04dbb8738be2b962d05290d25164107a2d0ca96817f63504d3491310d8af0b0ad40d67dd80dc3c9db248a333aa71b3ba1be32447ae255cb40ad6f463dc8b5f36375ec90aa3a79669783606bc24cddb2ee8e16186137740799aa1fdd41b557083cbcd619ed5fac220d3121b7068870f67e1e8bedeaa124a0c49e30ed22a9ff7d8f070f9eae1cf3fa3181f8eb843728ad9fa12c767f6a800d0b1dcb0ea48b8e205c8f5951970f779902388988781b77aea2aa006e3122ddd8e33f512d0728fc90daffa702ea036c5878abebca11f28b523c090764df13336ee56df14a9dae68159f02f909a2276fd75fc5257d8bf57a67e6fa1c97a998403c0eda86ee00e35976ff52ad74a1edd2142d89eeb9be50c9ddbbd75cf26e330a27043b0ed93cf54f624a77fc4129871ecf607204916f1e8b51ebc69b040063f5237320a23c562a2c91d4983ab4bfcc01af0ccd89faa7b0ec5dbefb84fef47e2ca5c1b9935b19eab50277096a965826976f3f4e5252c29aa76735c8624194b374e263e3e31df4668ea4915a81d0197c73ed6b2d025d824225943c81f7f6b96e2ada58232d34cbcc7615a1e606236c1e9003a30b564d96b02ba19e447edea4d2efbb219a0935d99370c04299fda942c8a79d2e68d6df00a257c9a1734369f3e0dce83dd09b96bdf32afe6a9c3439b72d9ccd9e3143b9429007b6e5e05e665c6a2220e93e499543d2d631a18a10ad577511e37506a5184fc2d7f892c3b147c5d4f498f7725df69876c366d9923956973b6ea574a95dce65160c6c4cc9ff2c951bf2cfe24049e77a5d6b7788e294ae737e6c63b970546d2d2122f778425a40e9307f84d76b7cb21760694f1eab87b7ed393db193bd6f3d165038447fdbe4064ab25842fe3c726454ad3bd7a6ae7a229207e8565fd0536f1a555b80819665253e0de7e5094a38414f43c58bda4cef7fa5a76478e33cd7a9f7893ed3b00dae41c3020f8082ac88eebdd663c3f2fc3f8027433f411306c3bbbdfe70f90f5dbf128fc92c87f492c1bcb2f163700e4359f81c437ccde78cce9398d25228404bc1848aeecbb795f1025aeb4122ab83f9cbc68bdc7aaf3cc43d7b2dc5e7ffce5bb81a447219e11f8ebdc27e76692e10ae77f508b6b5eeb32d0f89c2e1d5a620da978731d2fcdd7039554ccb9068de9e5ab89a402474e2d623382492bffcb493b396551952e9ce64ed6cab62cc7f73d6806d68aa33b338a1b9ba515b916c8a7d9be4a10279bd156e7b419ce392f84f79611a66737b95af56af92c1912966363658d1eed0618623d1d42e520255ead5c46b571e06fd129586ef0b4ec5c552691770f02a34c4c01b67e0523fa4a45277b3fdbb318a864ab44b52375d213b0cb31cf4d0a69e785835d07b1d80ebf42f967cf38761d4cfeaec470beb3bcff2b75933dc4dc55077db755162ae5b9dc2ca06cd6f2cde13ff7ae3a3cd19e9f86572a0e1a0ba7f29d06ae6cbbee0c67a5622ba21d02070d5bdcbdf03fd29635caf76a166a7729627f0b92eefaf16a41fd5c782ffcdd4b07a805283dddbde33ce99d56dfc35bee66f71dddf37966dd090bc0eb1b747b363aa6113ee5e58a8389610f6c9598e46335cda5966f959c34014a2a5cc8b712647726e69d45f4f23d5c548b5a153b690a540cc02e982292af35f524e465be770ec23f6f330b6076cc2f221c2d2e67d3e763d9b4e7d6813ae25001d61b6f1fd7d93f43b9dc3935f30b5bc49b85c6136168426d190f092bcee4668336c7a996342cf4cce3f1e2637b6acb79b12c89b7af04109a7fc8d1988a3fde5ca6feb2d0e5c37b3770584d65eb6d3c61b7f93d503c8103c7ec5fd589f41e3de94ae01384200bcab3bf96fc8882198cfd8054e2a618d0556d72e2118feffce870b982566fd27c033a96bcbff7f06e933ddcc28e948b846c12e32d59922baa11e3cbc5661b065ff55aa83e6aa161710b964003b702880de3cc585cd5b904c6b7d8a345bffbe98833b84190846f3d6e5ab635450287f283d8335e4bc8f457ec0edfbd254e4cb4b9252c39c22473572da892e363814d545727bde147fc7a8a83bf6ab8ae6ec82e4e0f9b93a6442445fe53f5c5a553fabc1bdf1cfa95322eeb66f59f57abe7e8293dbc4d942c4d2463cc414f38125b9f7b898c94a21c3158e07d0c59bfb18c7f2889b4368d17cf923ebbae1f48fa365e697bac65930cfdfe2b7770019b6ae86625859f7af2f7897a30a48f2d57d5e523f0c870174cd6a1053e145b84056e0f7e4d12c9f51cfd7a7ebf263d1bf6b9237758b967aeaf52db9b49d4e05d6785cba4e6cc86039193ec6811f4eb6cc3fa5f81fd72a699185190ac9d1a025713decf336a0e1f22e0c7331fd1cbff056efcb759f14247480d211130b011b26c7de0285dc3b537e5cdeb472a86ee507664cff87ebd322abb0dce15ce7c8528aeffb8976f945553630078103d3f31cc2ef8699a298bcd4a8f20943273e7e3983fe55e014fc148b3e12a933ce929e67c6214e09b4ee807394a82a5abc3894099fb8a467afc004b1b1a4fb55cdf0fb505ee0d128804f9aeec11c557de0e3db29d716ad14ec5f7bc10f3360e50c15138561366a19a4406c823b2f1759554138166253fd281da6a272ee0f3eb0a31352c7ddb3b4fc3552ff84f70a00ea96b81e1eb7eec7febf6c8bd73b4cad89ac7a5884cebf6346927eac25cf8e5638d621240bb6f5befc4297b9af08f3c71202a535b29150eae52eeb0fabc7cf4f37533da77a0bda00c55d09ef4c5eb042595ea628a1d618787c668644056e630e3655de76ef31dee0393fa8309230453fe6be54cdba8031739634c7b593b45da25b48e35f11a91a4828812c7a21c2476204e114127a298bbc0eb40300d984c5d3248b9b63df64fa94c861d8e10f8c0c5677cf72536b2a0c8bb12734fd8cae472c6e030a6e55afaae5f3395db22a463a3513cf74a089df7826ce34929bf977a8409a535224641a627fc5b5212dca491236a63912da47fd253fc95458c7ee77248b43aa51d3f5a2e36f3f58c5d967031a0cec50be05f6865020606a436479ccdc1c95e9750e4253a8e683a5c4869a54a0f33473aede133e56c7e6d85fe96937efe02fe8842142cc933ce9575446b7cd72f76ca90ed9723fa87b9afd1fdd158ec9cff5b234aecece22a0424c78c253c39213f5b8a6538546d03ba38da0d0471160812da0ff6b0645e80e89c77f3d9f6f901c7a93ec0f556b0ede363ee25d4390e7dd8722e3874bb7b7ccdc8238c4117f5c8569f00e8dde376f4256e5205a93caae9e6e17e0d592ce00db0ffac64f652bcb9f1995b6985960207c0ef50c9fa8b2a7efa131e14dbded81a05abc7f8c1110d8294c449e640925c7f99485fda8b68984f66d30409a4429f84d33aff190ee6bfdbc7f5c252262e5a881f275a7c37e5e43ca7316ef726615837e0fc9c4a92f2432079f5fe5eb97e1644c3d1d4f20018e327e3facff75a4e5f3e225c5e6918d7d9985919d51c98f32bf4cac4a14ea22702d24737b1cac729e2a4a7b94f0e9c74e8a9b6cbdb5030c28b120dcd876c1e13b908c4c089d8819ffdce1bcbd15c839e64bb9f6c7b32d6d40f7ef6c86c103071f12792c34dd056263f137cdb691de53ec0906889856c1d47e8e8da3c2ec657335c79b328117851c1b352ba02482286f2ede53df53ba56cc7543328cab89f04af382bd4b45d3edf137248f1164fc89eb9dbc8236b86ce822d0bab1a7931815a5f2e7ca28f5496965260757e3f4a68395135c321a22779bc80d878415050c5fd4f3c376bb245c9a0447130bac7d510f658de365bb88c8f7f977575b416bfc32de660d240dd64fab9e2d098dd93cfb2d7f8c6205966aa664be9eeb5ca5d46c93a73143a6c2fb65e2faa94ce910f9cedad8e0e8cf41d98e670897777e440b6ed9fac75b8ff370b7d0ebda095bdd9ae4fddbbc3c923c0b746463d559b5d620b485d43dcb1603c694565d5f97d98963dbb38696fe16beb87448f79cc45c71dea4a0af06f79f213e5ae2b73afdb264c25dcf433715858d0669a49dcd9871e875797e7df8deb514383015936e83756987c31df098f9c3e1ff32bea5c2adc694531b15f783d48fc73ab9690de512a851a07d4bd93b2a15b84fe836abac0c65653a19577f53b3540dbe5f55b94a8973eca9c312e1186cdeb5920a58162ed2deed9e34adb48c5c3d89079c2dfd09b4c06ddb18ecdb2130039b52ca85145a4550297ef54811a40bbe9b68744bdd9fd82db8a3e5392639c8a40f59e156bc6154d0087e901470c6ce7824fce218b37b10576097e756c16aef23f7eb7d4aeaeec458ed72b9dcc76d5c9a127c71bc4b5a56ecc2cb0e7c2c51275e1903b3dc9c557c987bd1561dabaf45f48fe2813e94572dd9d8ff2b871e4c204379471b01d21f0aa7ce7cf1c37c9bee7e6f8f9784ba4ed54d115a423aa3e2c84127f10f77bbe2de3e03c4dd81617eddddb33038eb78e8bf4818e69e2ea1e4bda49666d443fb6dfdc4d3add4cd4f7ea70aecb4b5e0138e795b19b6ac95003b3e0193de22b27f14802720fd011c74b794c9a532280d8e6a863c4d6bdf6ee9f87816021c310dd2bf60b21ee86a0c23ff9ca31947cbb7723c1504d9ed56b724f72cb42610ecdbad311769fceff820288971474d96ceda97f4100fae7b77a47a8aee442b44a9e5be4571183af38c5a4a11de0c21b97ee0d09a241e7944d84644e96407b00236a3edd1efc76b553ac6bd9aca9c51772e28710047d92f906fb55256411e734759f70bc61b9d9522055c71ced801754bfa0744c1245d27d8009d8af7b8ff36a3cdeae0b1f217a2b71b241c91443aca149c68419308e723daf7af8e2552d041b1f064c19761f95cb2173cf55764fee47f20385a1e07dee792ef585a003e4939b5651d8efc67043ad3719865d74d0e8fa61404731351ab4933f9823f71b9710f026bacb001966c9062fd5e111e28dd687236cff27c1c2a9e66988b670be23054048ee9ebc29304d3ed938f9c5ac31684b01b985bf19c6be6b918e1f975d1237f5eb32ff7b75725670f7de989683c6a46ac7cd7d4b7b050a25d41225a8d3781253c212a53bc214192d266e5695cb2006bff8f3bbd040b23d9b19dae579506dd662b6b9682c31032fe2cf8b3020a246f018c1bd290a56d74ab459cd2dc3da142b3330ca657739786a5a9b49ded08b7d5c4bf86fd7a7aed843ac38f8b664dbcdc13c3e7440b28a7ed4a359c934ca1443eaa8592947eac97d184767d86ee8a3820c9a91f063729156184314fa53f042636dc69280e1a01123c4c6f006301bb4e7f875c899419fd214ebf848e3b5ee44ce32f2a53126df90be7c7295ba0bb224caa45e87bab124990561bd8eb9d3734d7a1c2fbd49150989ac430fcaecdb2f6afd068e1cf33a7edf1f3a96af3160c624f66212443e98771ea2612b523948a848154c46406d82764e8e9486b72a747750d970af52c11d5ac2b3695c67a9cc3ba84f72ccd17db9a1f17997fe280c63e64378fecc6ee13c452a0d080fb8e477172cf6d44689aa2af2f40ee3972d2191d7bed6ebfe37d74e58651a946e2f2cfb485878c820c40bf987e2294d3f460cceac17e3193af12c4148476e1c0906d9179fae55a6ba835373d53f83dadcfde4376a7499f07669ffab35e4fb2254d8ffb3f145789cc105135d970461e7226c7a56b4a16e079215af604a244b4fd3fd0d16ad4e27b21b82f81e123f545a49bf4c892067005c6cb69bf0d8b2fae30d1c2dcb024f6d88262bc82e206502ed9582b3d00f6d379ce31fe827aaeff077e60006b511d0158cca62f333e63213b2a5a54f181892c5a5cf5744271560a84cd8b9c6f06333421406e6389ece1b37291cc25270c2629fdd9b7a5587c4657c598fb0942efa71b01eb29b34b6fcac6aa8350edde8f458d873fc3a1adc1f31d44358b52521e7f56ee9d0285549a83a6315e571fe52e834f93f3654399fdad01141b2b61278d0beff29b0bbc79a64d94ab078a4af58ad38bee0d5580c60b2c46753f2e8973a719464cdaac0973eeb6a2c58542779b8c5bfd75263ff3102e33c4d3a788f5d2bd7697decd460a5f327fb7de91e986a02d45d2ccbfd4ef48c06f40dad2a8127f8f427555fff20ec5362200ba792c71e19318e931a7082439aaf39d4eb8f96eaa7dbcdf0d95a31ab8316eb7350bd9ae0611bc73635118664e4766380a2bbc8c072910ab1ba0c7ed93429a2b23a10a0f3a08c9f2cb99c1370ee5a4ebe3e2a943f332c7f71eee23d7a33b3832dd8e0ddf98eb943e7d05f88a1ec9e3df6b1693575751b931e17b9f218f6dc816a51a8bb9b8d44b4d64c68401dc915fc64b65c379b10310f4cbc0c40710ca6dfd7216ec4a9e4b4e975eeef8862cc6170b07945ce590bb92365d0245f040170dce188c5bfad2fafefc021b2e4a7631a576a7fbe5ec0dde65065a2a17bab8dea3ef3fb326a6ddde7b3b3daa18dce44ebc61e4fda888c6f3cd3f953bbe07a1b07933da10991fa4b431c5cabe30c5d1a30a0ecaee9bd211a86a129318e6ce281b26428be832184549b5fc0f7f385f3f8f629739b0c90775305c39d62b75b8030ba925e4638d7e7275cff87ae31394dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
