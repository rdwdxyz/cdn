<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a60b19e8ec6cf78adb0a2acffff3428e4d8c660d5851d2e2ce432ad7cba6f770d2f14ffadba51dfb070f60a29f916d5ec456f5f2cbcb1f8279640b98195bb9b5d01e4b7eb9ce8fb1cd01b5296616f41ad756a06ce349cb04848e5f3b4b36b643d36f705b58f07322926d485f32fb0c1f923fbe6bfb68ec5edb7bb0744ef714da4f41f029c96469fabee2a998bbeb7cee2196b35282866a587781db823175f237f01e4747c998c05ed609a2d1b947adbc88ae5d728bd87a8067a6546ea55c79367d1b586b464f4a3cb1d82ab3f13629cf709c053d024d71da971b9ff4b0e335d2b7644fe3cfd66138255131cbd5e28b095bee857e98a22bcd503c24dac5a858a600bc893393dc253cee14fedbb905974608f969075d79a3eb09a89626df9771e289bef3e588a53a96828cd6efb4f6bf64f76ff4b3f04a825a9db2acc7882f2d7c3a1499ea8992971b8e32928fd465f62612d587cc57e7db701e0b42acb61a000f735cee8769bb3280701927f693e9a717a255c3bc390278bbe63f91074f31ac7f46525bfffa686900bb411a7879761010265519882d5610c07437eccc3b97be3b789fe8c96bc4ffa1068930dd50f064c31622ec395b6647fd188e5981deec1600f097245f9c04b613f2358ec4ad58938accf9b13ba1e1a7f2b0be7adf044467f66a5a2dbe72547da7b2cc5e87ceeed427ade1423269f0c2bdaa8497dc72394a09b1c36b09876bbf84a1a31047305050083e5e805cff21cbdd43c5f29fbbd1a369230e77874f109367f2f09402a20df91df5b06e4a6eced0ebfdd0b3b22d7f4ecf45eaefc5ae6f36c336bbc0c4b21e617cbbb6e5dea54150ff6a20b5f9930e3964db5a818e0e4b0d41c521da9d66f080b7972e943a3014c0be15432b5ce197aab0e6c3399982a03bd460ecb74dc56f52d330648cc8988881e449093b088926d09fccc152f163292b8bd430160b24090def75d7bfed7aa906a37ab6f031136c80ef560ebb9b0918cd64164724043eea82d39c7c63d5fa4c1582e9deb821aa1fcd4f8c8fa77fd55f57a130e304fa1f372cfa7a695c7bc493a4f89c7ae63289e29bb0b019a9cb4aa37b25eb2df4a4880fe944f64c716521915ec7eff2eb7adab6d6412c38c6eb87375494993fa286690ecf82565c9de4b6624dc7a98dee04e300d67ee962976d2a525d940cf6b35c761407e27fc068fcbceb437f0c7c727e631cb2712fa5e20ee7c18651812b377c80ac31566175478ff1293d289583aac1372e5ec99052f4d59dd9195683d2631de415aa07d0becb7d41b57b1e384908c62d87c9f0a571b36c047789744628ed6faa06a8104a5c9a1bf4da311b3a0dfe412de6a3a53efe8a09b272ce9122abdb9309f32e5ea918d8233ba905e622c57e931df2c948d282c2d03f1a9700ec494ac5c5086bd434525a014422c506e590a7ccb073f4f4207d36fd8851333837a479252e358ffd7758ecfe904b29e8a00deaa21d3c30caad71c919d01b713726b3cf5abac768f266f42e1eb63403a1ce6a5a42d9f998399bf7baecb4d5bdf30b81a6961bc131a4d80bfd5b0962572ea2a6a2fdf675ecaf9bd760b0cbb93694469b90eda30325883f01f1f070e5cd6a1f6a51c390b0c4ffcbadd13875cf8e9b0191e9a0c1000ae0c02586bcb16e41cd7451209d958603eeea2709558f0a70d3bad0184ec8d973ce5f70f2411e6952875ab5037985cc941da4085dd51b6a57907a1402006ea294b551b24823b5db75a00a16dc2b6597d661f66ed54caff4e4ef2cf1cb93196c54171c95d09580808ccc9ea45ee0d99debabcbb516562052c59d8a6ceb9b72378d03326a3d152dddc333aecdc2e493a63e16acfa0a6c35a21f094f5ac4eda2d84008451977ef13da5ad8415794aa3f734b28448b4c297c5ef28850afbefa3ecdd7c805ee30b03252f66de5e07ba432068e52de8fd1576e74f156139c5144a13a7995995eb88f5b7162ad2b55fe4de106e3d62febb8385a2a7c4ab7c7208a26f76299e12fc3c2725ab585e75a332507bf74c93217bc9e9d591479acda4e4bcdb277ba37bd180a1ecb819cb0318c598bdac3e4045464c1170eceb498ea559e542fe1790db3b918374de3dde0821f2b0375f98522aa7e3ae491969977bf424cf01a4a2f032fa74a60b3eff275eba81034ad43df6e0fdfc28e53f925e7b16df31608cdac3fb04c59f57eef938572ffb8a156deb5fe01bd212e18d3caf13781a7735c2c477b45c40a6c9d88068393c1ba9705505c9c1137c4aa181e4d0db8517a2d71824ec0b740b6d8531112630f5dfac8b253251fe3f1d177360cb4e4190bbdf95238c78e43bb32ba8725766e195dfe37870ac1f27030aa10cce3a1d0e1477845299f78a2e1ce455fc57d85cd2a6f85e4532b7726726181035e35dc0410e7485d4a2d2bfa3dc23c4d46345ebe87b28b2eb76c0aca10c215607fcc78e463f6869f0654471eeedacbadb2a1da3de9d1997d3e42f432f3534ef3287b63e62d7d5f55b97c3af7ab066175994a02513c1477977858a0b576ef7f8cc0dc42aa930d3357cdb48a57b8e088fae890ad6f8c848c1ecc4c5762fc2f760641049830f97abe5ce4ebf842859c80e84a5f8b18372d8c3f4be817ce96af6bd6d127844bdf242f3733f2508e08d634ed35f462797b2f3068692dc08a5579847e5362e6f3178e89cbb27c8e96201ec3c4a73259bd4abce78451deeca7d14e9235cc4dc849e8a676a79bcbc45037b9760a37d86a0a9dba5d6be4e8374958f9cce65d325ee2d19f0e71acd8766e0f1f6f7b28969b2f796a789a99e2c9ec86e5179df6b1a7a23fd6f097ac156839bb2ccaa127dc09c3ca5f8f57b7dd369cc9c8bcc9f8cf573048b5ac5dcb4da3643cdd6adf3c001bce23576cdaf5208f4f9723e117324a56f365a908815dcbb7244bb6b39769bfdb2ef054f430c6956ee608d6e7e703cb4f43d25ac55e4c0f65d3bec15c94f08b59b80396f66cc1691028bbd2aee251331a4ad2b30651012752670670f05846a49efdbc625a2bb9fc45f27e4068e581536cac445445cf5b86c3ee6cf48229b1a3785d03c2c5fc29e9a3f39fac74f62c9fdf43fe01ed2ed5d4285620416cbee2f4c101201a3faa7965aca2235bc948dceb2cb370ec3fc96e67cdd01ff753292c0bd33e5989bd12b633d9dc6babf3b9b0e45178a00ee1ee672f537ae8b3a36f0218b217ad5b06152f76e00077c1010da5b11978c617b6ee67bae004905c7270a8dec3bffac32b7ef850a6382407132a3534998cd3278d42654f4c67ac727aaff59b56a036ee687c8a48d517a9ffe244d05bc746c0c6bfc70dc78ecfe503666946491dd7bfb09bd7871d0cf7af4a50792c1172cb30fec33526eeff9d5d2ffde4af29ab9e29929af08c5d6995e7e93ef40ecc1be31115dda1cf8d99573174f9b80cd92e5f80e9139b3556f41ddffb561b2fbe4cbcdcd3bf76aa82e61e26ff336040484184e75c1a7c487b50052822a69fa910d989ab65d45b140ae64f106cd4bd06e474c9c5b5eb4d7138af521c46e7ffe40fa650c24c200da74bc9c4a676a377e094201e27de14213517c41ea37ca7c89a25633f53400d988d75fff6771fbf9da65340895dd0b7c2dc89f160a938eecaedae87b1872c0722f6df9e3654f66b87680babe569a0d6ace5570863a7a3a18b7fb563bd103bc0225887034b1981ebd19cfb70f5b4ae72a8ed89a39ca86023195567cf78d6dd4510548cc50fec03066c97d78cb4815678d11ccf3c5b862027137e058caa748e769ee17a8e0661eb5be22884af7307c096f1a86f3a50b3965dbc64903d75926e1754a5175286d9f88aa48a35de5de34a30ec6e185a54ac0f1adff4aa332234e7503e3540ec69d572e15eba10eebb734d4c7a3b7e455df49dd58858cdd1407f3fba593d84fae321e034d2157e1197d0fe1bc3462ee22a5c279459ad06ac0c3352fb17115f880bbc5a9f392696fa7ac129b037271678f18da8810bb176a46daed9d57d75596b382ca34ab4788b25d06bce13086c6dea3359bf9b74806511cc546ba119f2e91eeb0a0dc5974de46900c11d5204932a6ea348f4b551f16c379a321133254e2b51968b9c55ff11e5832b124026ad2b33cdaf9a8ef4fcd80f9f1a80343a12129adaa2c75ea4989c16347fe9449f63dbb5c08a46af7dc0d6dc28f1077a8bccd8aa7a205c3f01f31c22b2eb6374fd6c54d4066e883929fe646b4e9bb425d96b07ab91adf16ac8be799ec38b63d98d388535e4e15b4c84fc06a7b6f55fc41349bb17933b03875155499c2893c733e7a0010cfb75ef2e15949b236f3812a967b3953430f183b5c7ee6b6df9be0f44ed011ea053f0a28091148731ef668b30af85153461762c3f05f9c4c9efda6be5c1f75ce8fbdf79159b082ec47260ee9fc80e67858f56d69633466cbcefc96948b70716005efc0e35c64f490a3e50866b0b6178c44c2a61b5aadbfb74d4224a1ba9aedf1e1627bb22a27c277db048460a9a3327eb39286473a547528c3e4c59682c439bbf6a4f89b1db44224c0e4bfe1a4f32b1baee90b2b29b0ee70809f871355bde66d27ce81949c831e806055c62226a9542d437ccd94f0863eb207a0fad48b20b677ce2aa605423df8f328e9b2524f0da6ca65b244e7a35c0c4b17e5280c33c45e9e4783be7a2c1733ef53c572b6a4ee42618a2397b87313d444337cf6a50b435334bd878edafc75150cab88e27527cc25b1f11f3dc40c63f5eb2bf361e8d2c298d5a03ab9eb78bbd4b89593d3b00709a977f27e87bf1cedeb33efab4d8a0a41f18ea7a3b7fdfcbb36f7a73cc779ca31a1c2c01f21aa16ce7fd39fc0e5573344ebfab602819150e7e1d285e383c3f30b0f1dfe97cc26b910b4a54af65583092669ad4d72f40113aa134c2899888f1b759a01695023c55a1c9c4e24e17ba9187fe8fd3013e7ce650ba61bde9f04fb204ef0ed32f5e6befd4236aa019411cab91e4d9c9947b494a611888ccd26ac6fba0fb48514ab6efd4907c8f36f0579f652804ca926619df6c468d320e64725525764802c01a5beaaa11103e80b8ee7922ab2c8a51ece61947219a1d72c0346493e4c307445b3b3d5ef1b07bb02cf49705ae56837e5d4f404267a3a47279a83554d9951ebbd4511601b8cd9996efc295ae7aaad7a25c310a0f16a6efc53621f258c5166a27777f5258159273d4e56e75526717c674e82bbc055d9f0473408e43f62ce36d601f1f19c66fabdce7398f9df12ef3beebdf2f205e439bfbe44292396901cfab7e43435499246923e73d2b73cccb8175f091a47ff3a4befeaa1c656177e0eee44184795519567a88eb25b72224eb971bd8df3f571e80781c7a5d000e7a807f1e094b13a403d10b411fde1c11e69e5071a2e2dbcf1015d5652e94d61ca254c6da0bf4d660675d2dfacd8b8bd7597f7e0b9abd6674182571f8c979d2972ad08691649dc0b337cb61bced9a41c8865eee6490ebf53ac4e833cd5fc808310277d5bfe24065d53576117439c1a10d43d5961a591ce77d531e77a93285e5359de5a13077196a08ea5a5e10954a05114205207186e1ac90d59a5c2a6d18196fbcc997f7053eb45e92be176fb8c171cf1c85ffca7128db6fb8dabd8dd871ce2a3de4242f13ea35428b2a4cf51b345e81f6af8641350bb4cd1bb1211900f9c1a70a61664a00c46036b09a95aa0d2eab713b0c7e1b1bc4373319fbead568e8ef259f383eb14bbf6086d68cd023a9ed2dfd6f20f4b9c2f159610885eaf4634337d655823bc0311e69ef5f28c5800c534cf09bb623e8395a44684f69d821be2404cc591f4942d4c9a5551d680796fd0f002d02284a42abc7e48b990661429531ff247222a985c99783f0c9b1ffd2d34552c58ad9251c3a0fc60ea23ee45fd5914335c317a92537f95b9aab2d60acbf077f25db54e48ff0b61d04d302d9f1af90b7e47c9aec3bda44528be5e37310067cae6fe51cad9bd5e414d7420cc1389101e45561102539afade9351a4de874bf593f97fbe90fa559f33e6865acd9190da4d290e295a9a70324ccd099e0ae82ff54e5da0f0eeb3788aa17e6968392ae79f6c1aed24451370fef06b61385306f2867c125865b76e85ad75caf5f0453e70832c47a5573927ee33acc855c5bd7752668995283ec8ad88cd6993b0a2d8c1a9e012ff6a7373197c93fff4fe87e8c67f9f9532b92fac9a1cd1a167c000858512732e5eec8498a3e65e901ae4fd6fd413f366c5030e3b88d60db737791ba08f20ce5303e0b7c5040c13322649be78d235084484d8e30b23273deace779570684d1d40a64b88e200af6dbd837de24306285e01732349d9a3338cbc926c7ac37c7ce7e3053229d02e473d243ed194d827ac4954c30e5a00d7023336287aa97e8752d2cacc3a70711b5d0057617d09f61e4a0649138987fd3b3dfc7d3039d6e859e1ab84936d4a06b4b40801529d95667af443f3769aa41f2be048d9c5bb2172930049d8e9355680efab3a9fde9f9741da01836135cb6c4a2656cb7a85279b9d922e3c2bf45dd6c3d5961490f464ce10ca2ac5a752f1ba6aadc0d2dbef074b28bebae46f395cf2227d3e468be53117b31c2d0edc459073f40fe38f463181bfbbd6310f18fa1312846957abeb11b8829fe6953361e3efda1f1cad5255e549f2f4c52c27e05784bb5ae08d536b06767949873cffc3b92ecbeff0d9300c6678b92f66b62293eaafd314b1e330e595101b7524dce5f86356ae793996dd2c89eccb52ecd0268626a2e5b2e25af4965653d57c73e6adf6e97c0c9ab4a11f3d2936dd287f39028773f8fcc173a6938105d8e3612775f87aaa0e7b54036c4a11beadddc95cbb578608f02c8549a8f0272cf739e6ed33f1b043ed9b5acde326bf97aa25c987bee94225f55ce612df6da812664c6f1ea48a1091ab547cd38933aac26297aaff3d0c078766ad9c1d2d3ea01a81f372c77e18b24fdd8a5f6f4024f2e2f10969921fcab63cbaeec72b307d4f0199d71b5843b94182aef3f62cc7ccf78198f3727ef78f0fa72bd4dfbf9321ec7d17c4dab39216620cbe48c04f0403152a2dc951c8d9fa628f082f76d6e6eb5772667eb1cb969869849929ed810ed25c692f4fad1f3d39dcf9f4f20483f96728c3d1d6697b6cb595f05cbdb9426a3fc538d7267ddaaabed55f710ab8798e4a45c69228e0cbe8ab39f08968d48f250814f41d81a4172e60385bb8b4e70cda3a46c57581a35b0d9a1fc68917b21345998a04ff4485dc50f4bc611a658bee3b70a007b837dadfb1f2a56885ec0f7aac74db48affd22989269e43cda5a34aeda3fb582b9cc685eb1ec1e6ee67675c02080344f6277ab0d2bad673d22779c5a410ee81cf3feae844d4288ff2cd0e9f8ed2434ef861e16bd17405fa999e05786ab3847a753f4152a5016c7ca7f84ee6cfb86f53e402ab83d192b3fd3ace75ec971922bb8a50a214636995265ffb8975e3cb1ba02f85b229be344c319613419bc132b727d06a797097553e6bb0e2807dc3907829e8db5d42b0811c46d71e77ae000c77286fa61469428f5e04415458bfcc3f3b1d499ebb43b20d284484f8fc9a5d322c37eb90a76977273b3af0ef6661715791720178dca987ebe41f314a98bc9419b3f77d63cbb36f91597cb73014056f9f53ecbf7f0f4b058b33f38b2bb0c801bdb8ce2c1cf4dc572ca4ec13553358f729939eea773062d596708622359c1da435f1e109d8de53b4af3667eb16693c9df11f64b49fe57479b4d288047d551e3d0633457ef96888562205b1edf10c876d11922d8f8148a97fcf1d24df1b0bc68ab61c9a982f2e0c2c6bc0e0bbaaf0f542f2e3bd8feafd9cd5e54bc302b4012b22b31a1aed1bfe50219a184b1b5d97b6f1b6017337b1fd875bf64335747118d68e5451c8141a993bf6b104bc4dec8c9476c4d87fdaeba83791657ef59fd5a0dcba22bdf4f1cb6b174e1de023534e317f230696bbf6e0d46993c66ab14d3d6e31874527cc63a236bb7f1e017d068be199b0e51715bcb41407657c98c09ea0059263a9914db0791ac88a15d2d72a723148984cac032589300e2a1a43e941a329e573c36d04a0605e20d386565a8d2366664492466c233c57113abcf3d265269ff853bc3b13b69e08bbf54974596b6711c5c700a3e1e2ce6d8ebd505142a83ce10d7622913c0e24e773c98ab2ca6e15843d5324f280aad824f6581c641d1d2282bb8b263bd71ea37e1b3c693b11906cac97e4cc4d66074f2f527400708834fd555c777468806130e12db120a815af563a2aa33d6cb9f81412e2fa8da4a468a18a853f84eabd4a89b8e3b3f103aa72bed8831bc5301a499ceb6bc28cd8592e66961cf632efd6f576503f46d2a8e0a12086eb847bf55c48ff0720b010f867e2a27e8f9ad0cd2e49710803ddf0d27dc131957354511a76fc4a0aa78693eda05a46a959808d61207d958fe8e71517dd565b5c7d272131b7fc2e56673bf19d74e69c21a453314039a79a2e1132062b4723aacd454bbd9a26ec88cbccd932bbe84aef1b413728bed8bf76866c30f1d4c9d74c83e9d942a7a182c570bb3aaef6cc5cc3c4205aa00826646130ec927fa2e0be4a17ceb961e3443a3ad01185b3570798f83d9d6b917f56cff18a5fa90d5b4afb9c009778ce5957fe71d4921609f683ee70cb7d96ca4ac437e2f7d8a68b76983455ef9cff56788b9c414dc247dd37194dc71f330c1b2d25cde9d98a31e8d2aaec7690db5e4916fd2c8531c5eb0ee32adca033a4ffe196e67c695d102906f9984e8a44092c62563a5bdea4e80603491d689a9e636ff91028419f03a16187f29a0c946e405a81c7491c4540193040aebd32da2c6e259dc20526c2226408a54f43d134c4fcd9fa59217fd26e2bad2802ce1f11963fc621a79559aeca14f0b1db1d12356c4623994141434251ecd33afd59e88b1215dd80cc51c254807f517f4a044a2cbaae4f464b172ff6df17bb9435f01fa5bad1115a3eb920e062165fdcca0453fe16186611b9dd74c87d3c21957210af65a8076cc0299530ad0e941b8cafd5a219654873f5ad56891367d3c9d5cff0af1bc8d7b507ce8908b135777f14b4dff9fba341256fe30bd1aba6d2710fabea3834bf0ad9c26e1cb4e2fc2307db2a4052cd5d3ae2271e57eb9f058f1b488fd6bef8f9622e9f8732cc91178586a004a4b0b33b856fbe33e6cc2fc4fbc4c5d18153ea8544969e72b3e7872f364e3612d2182462434dea484f510aa07b29001718095b5cdafd0bd6980795da4043bb9e3c2598573378a9afae3b09d859171e937b42e7e7aa8372f2141f0137f7a433c2097600df8bd97ee07ed63e1a6fe59b408062223e715632ff4e62e06b80094245b6fda4681b7141f51da54be6a547f292066d203b0f5f1e2efe46a2e5d9142f3779879c5b37c3ff6d7e78da44c48afc5da8283eeec5ceb1dead5ddb1e9af40bb70400b0c44b7dd35ed8e37020d37b2b77a6f404d29798e756f60e34ad9874b97cc053c415a809cea99c96aa27c4c7116dff1d85d458e816285194bf96c6de0a5ecddd8761657e657000f83eb0a3d8ab00541c267e9363694a934b9f41556995329f73ccf1da8f942a988217560d1668c08e9522ef8c5e1c8d115e152628cf1c034c2ea38a925cabad1475d1e1bb27343a7cb2d25eb0067688d214500f4d07576aa8081c9e8a476207b67f4ea265ac5519eca3c2d2848b5c57251bd2358a41aef4eb75a68f426b32f437889da977ae7a6e88a0b9c885e07fa66633396007cbe14e86afeee6eef2a5f9641190727620c057ef6e5caafbd57d02dfab5f7c903b714e940bc6f8c3526e11dbf6cfab98ce0d752997b744e4ed5160e5e802eda07925a57f5532b583e3d1bb253212b4f40855b061fb5b3aab58a9712cde9e1f8b29cd989649f1e6184b38c6e10c477a0568d048d9d3a366b0da48c08c323552677f5e3e3eca318a210aaa166c79a8c6e4a783d56aec64f537168bd4c1c2322f2fa81091bb7592feb3988189a622974f5f75e7d6ae4fd732ce3d1b34ba32eabf76fcc19906b979b0170afc3ce852af00d9adbc9ee68227723477ba729481f3aad45d88eb980312e6b3c584d38021a4ed4ab20b943da68937961a91d068345729e283b602766c74a96042f87ff98f9b5fde780c0e1c7a22bd44c08f083b45bb85e5215c633cb4292c0bd412222a900a170db491689eec52cf3d42ee90a8d8405798bf778be8789c754c1bd9a1c730bb954817845fdc9f0b3838857233fdd9c1b3eb8b13e809fe57e0f70a83091181f5d17bbcff15e75986f30944b1241f2c155393b3edeaa326efb10f76fb4de5a154f4feb12213595ea0597df7dbf605fa15541c8e9b1e316a3346b25f8d62bf316473a5fe39e05164132dbe34a3e143aa1c665b6c4c0cc83a016c3f12eb1fe1a3be89f2a0f75fe1884579cf22346d36fd5fc8bf6d354764381159a6d8df6b68748193422b41042d731ecf6daa9bf3c0cbf97ce300bb27b480f2c876272bd3f320a163c66676651ebb85316ae1ded7161d9128c229ccbedf51fa64cb757d12dc1b40c59f15c9fc5b98422fde39f5a53f96874c7f28411d8c2878e73154b157f90b4fe7c68ebfb2117ecf50248b1eb1aab8bcc87618cdb662924ba1ba81aa6908cda1b201459bff74dfa403575fd0d17082fad3e3dbc0c855adb9aa0bd14a6eb1b4ee30829fd0b149e7579add27260f9f529abf770293fc815d15e7f66d8c466263d2a1657f75a8ead7477fb929a98b8ac1194c800ea541ad2565cf5d09a21cb2c3932b73a19ae90fdb7977f75212cf4dee45afe8fae4d649e6d8db39a9042175e175d3a24061f26dfe1095e4754423febf006736693a4a682631e27f1cf4fad0b09988c01698dd9051ea6105eddab874b3dc6de16f2d31497acd60c5001803087c165db503fd989e6608b834a6d4026d15692f2934117de1abddf9544716b0c16297c2aec62b591ef1e609c209a61973c3bc797aa2bcbf3fa845d53ffa5f7453116c2637c7da17e39838720213bb701a10fb8e9a05f4ab62c4bbf08067e2d2c178bec26124c475d9ee55b73825a54de35d3d7548e74c3492fc5f0ebf1bac4f898eaa5571abd008d8b8828ae90ad5502a6a17227526b45aa65fedd835f635b9a289a8dcda965dd307caabb1ac7225664e3857441b96dc12e276b589047c2181c32092e69eaf1cf0f65483f0ef129efea65870e9a01fa63015732a5173d97c24fdc67dcc7f516b0fe725f8faf84afeba1b7f2e00d2e8745bbd6706c7731876e686f7a0c9f38136e333a9b8f718233308d6ccdb3d585ceb982322de5125d89cc8064f92028d999435e27f4a326650c6bcd66d90f21dbf735238eba049aa68b082543d0797fb79760edd50d7f413e6625ce1b7a50be62c6d17de7d5c87d4f5546266c601a4dbf682844faeab042c572e56df37ef661e61139a2461f41c59c1d483c327afe79d5b5550e979b7f89474f334ad81e99bc7f57e203f0031f494876079731cd57d7f5449432ace2426413468ca5bf3ced7481815d55cdfc7283529ffb094fe68df4490b16164238cd30baa5338d97e5e0faba4c3eb73b6ea9c77b3dcc43335e73d31c4d52a9c5337886a68ca5a6707fcf4e5b3585a193be032332cb1f5a057212e13dcb6ac70c34058d0ca3a1842e9f0f5783af800fb9e42fdf34c2f5178f0eea6c8be61ad5fbeb318190f3cac5b03d2bcb88c14927db88eef80159d44601df7440b326e27154ee79585a32806c0999dad36658304693b1d57b85d3db85d9265dd2681688136a7ae6956e70b6c066ae6f172918bebe4d839e8af8de557e2869fbba5a3fcf9ded07fadfce6773d25dbca7ec8d16ebbd24419a88c7f4232b1a9b3f42b29e69b864906156273549f93b5db60fbcfc84e58b224a9003cbc131f7ac7904323e675ca179efd9983123adde7543e1f316849f3df7c2c75eaf3df33e4fb50d42f9766e3765619eb74033f02e1ed4fc687c290843bb5bd2e3c3d8c3f86a591c418810d9a04783c6247ab1e8e2f66358b679a616c9c2b9ccfff842e948f64e886331f129ad514a6d81097792629ddc72c15d5864bf458f6cdb634081cafea1a8303f7e7ea87206699c3980a8e2c4326914ff3f99893c6fa4f71b2506509284fad8865011dc7e5b58d8a84deaa2ba5d2418e78544263854f9e68dfd08423037870c2cea48d6cae789458c0292605ca60808fa9107b97432a814a5673bc36521d27d3a6c97ac94fc15a4bc2f6f4419be11ef5776f81f7d042d581957c95462ed6ace80370ec31627a8aaa3dd16d925ba645051a0af83234319c734b1f600500ebfc60ad5f25dcd6a49fbd52e04b772159a2f2ec0a3aa48660016dc2f5702d6b66d4a048b087b6a7d835fabb9f019374306383b3077df794ee87c8d12947e29bc5ad890554fddeec1229aacd40025222c105a37c8fdcf52b644218fe830f9148173612f09d7055629c05eaf2473104e5553ff7baefa3b74e25e3cea72a042f7d353994c387dabb134e45661da975e52782b6b3bc899387d77f86141c155cf6a4ba533fef40f90890c7e64181e179da4b2261306d5b50bcd4494a610c92476aca7d51af076bed4d1e4051f205ba9c51676773df0def58fd5d748f53a32329917975a2cf3794ba237ecac7d8c78c70b5874b7f9bde75f3123646af233e5cd6628ae13b6f42aa5eacc215c99ecca8709c507e7343f8b89a87b798d2005694d14baf01db43b96ee8bac5effffb4ad3aab087fc1ef454a8010c226c540273313823dd9d8e66b540ae641d3e62794336baeb01228dbd9b5ae03963febfd1cf66441b8a2ab933a4ca6aaa6aebe08513ee4b5a823554da02551b6db7475c0227c522a7c2e476256cded37e81ffb3c8713f24eeca2eff8e859bce6d853f7717bbc15633772695df2bf59708526703da11f2253d869db2db54404bec77fa96bc2668e85d26f01b4ef483a2eb84385e0551a496e62ad8f10bb497f2c2e9944c46dc0996248ff8d5bfe51f483b52738db460f755594a833c8315943f8d512be11805802c8bb5ac37ef6961e89dba767601e205b7c7bf8648a6b061341d0b3496b84207678967e7064c9ce8ac2011ec428ae340fbce1d72fad1cfde9d6577ce068495753c08fb10d434cc21d9c4e5c87855127fdc6e510c20207fce170c85d5579dd40acfa72f2a2e15b3dd5b77696ba566b6bdde7324a0f707cd5807f99dafa89f1f7a5f2012169d2d9ad97df6e10c227b9a22d6b90b6121b8f4fe070bfb0795e4e22b046603b7d31cff1880085bc304b2f7f9b28b32f6900f4933e633260dd35e2ca0c2ae38ef950bd265afb9a0d4b6013a09bb6936b26c7194d7d4fe1f7f9f74b1a5dbb5f4b3d1df99b4f3a6d411896e423ebd2993263666f4018086e4bee47d95258512a449dd13a3e0fe69a1d936205d77418be1cb2e6657307eceba345960da90b7d86f752c42c858fe2d6392c28dd384d5a3f0567938bd333fdb53a907857741da48acfa3d929defad6b05f181d4d1550a45f356f3030fbaffd9005e36d4b523c6d429cf24c591fc00b362686fb0506bd822c63fb7d76c77fc8dea1e04fc92b3275f25908f03aac85204c1963228ba428846b251b82ca5b051156d83be66c1377aa40b00842dee52d54aaec5e367f01272f304cc049885b4aad0e59306e9da58f8c8afb9720a1114614ec0e87f8bcfc07c2390bce93e19dd6718b57cad11c388b841eb669801c4216df4d1f9f4fc7e8947694809c7c0b3ab07aeb32484a64a5c43d9a81146cb2820f8f903847092541e0db8a07f1af8ad6145bcbcc991bd3be003b33cd0ed80fbebb514864c404ae32bd48c7f1144c16c8bca5794168f94c8e4b889b0c5f278defa14ee11ed05b582557e2d55a01a8a0bab6ad4b433cb14c83f83c11d59f3af1fe7dd755a93248e6a670714e6336d71e52b90609420f20476071dd6d782c6788e5e05cbf34a276db152b89819914b100c1e95ba855faccd07fb436f03c9106dbd88a65eff9612ac87b24a764cde24c46830a94e8b601f81f58ad2e33e39b1f151575c9b83a4aa69e2031c2352338f39a99bf7c6cb3539e1ad415528fca2329157ff14ee89982213b13b110ffa30d4f636611c38e9ad7148463da1499bfa01dbead0b3a3611604c9ad4eb735dd6422bfecabda3b424b159195e2c4d6061427c8301f579a825c1e8952bdae07eed83504fe24c7a8d7391f3a79c7d9752893eeee03536da5cc876165a2c7a32ececf0420bc4ec0f770263c7c9180817f99af3105ee33791bd992740fe109eea13749bb686f540cbffdfdc06036c388f82e335aef28b91b786f516fe1557fcc9d41dbd77dba72ed3433385d0f0aa09c48fd148599e9d0308e5ec439c1a6e6640ae6bb10b85215847dbb1240b3bce534593322b97b4b253af5c29d24434de9ca33b0599866f0a21c96f3fadb80d1d3e23dc73fa583865aa1109f93f0ee3ea4dae6f8f12013b5f0e2fdfd63c3f012b2fb77b1815cbdc27efd157d85edcb7ce3b442c4add9617165b5be551aab7c3148ba2ebbf677fa3f2e88d73a605928bb22f58b18ebfb4f6e4ee1d15f32f17a1551e4bc1b1dfeb0908bff1aa8c6455aa50f32feb40947bf6db0d08a638d69bb8d2d0ac46d3e9005428388dc3c2431c4a7b42f8392471ef9e583b79516b0ab512a41d79efab62031df4143908d7a3c5fddbcbd4fdb82b3a94fbdf3ab7a98de4131553c501b9a3f0ac9cf4cce6c7e01b53c734ba359ea8c749b9a0eeee7b45b6625e3a5f887759ccafad92b731cd593d3fc7b873114a5e50a55f8baaef13e0c5f589a492ade41b06c1c24e24956172fa61a99d227ea8e11af07e61d4b22a2bc7cba2f9bbc3bd3a68aac4431eb6f2df28c604ecaff7b457549ad2faaf9f7ac4390ae1e5bd77e9f4d5ad68e4c87ccfa0ceb4e69ae8d0921be6d660e9d5bbc56260a8dfa51ae7249bd832b0486b610043ad4813d8acb1c105d19bf84e751b69d435866685deb4560558380f7d7349b086134383ccaa72200418ef045bd618a6b23f9dff0b984d12785cc1e14ad7e492806b5d7ca38f5f2544bcd3a3b1b016798f68127de9ac7c60ed270d5ff36514fe691f2f2b6670355cf424dced544fe18d02547600175e1a55727849216385ac5c548c1ac137d386bba8ab6f90ad72e372742944aa0ebaf869d8f3fbf3ef7bf83bccc12dccefd36f4b6c263ef28820332c63bda16ec524e672f31a270f3177d0ceaf6b428e1c9cc012c85259a2e05e3c0d705bb8c9450881a4e53bedb6ceb748145e6f8c36d204517470c993a3771a387a4d0f8e4d0867750bff94f257ae039d640e9c991f89fbc790f5d5222d2ab9e214ecb98ee2385ca509bbc5237fa06878c11a1d005c1a943989f1113344d3aa8c1d72e0a48a344ae65992876e415097acc70ac2b28186feeefa73cab983ceae396dde276ea800118a8095c5b8df937372462baa776fd31aa95f3b95e02a97bea6f40cb4eb0f152f7d07e15db87fb0922534a86dce31fe0f4fcb53c2b07dd5204df10cf0d16773b2219814a415f5929ce867a8eb1943c79a4c93a2b8eebb4edfd2601dbf15b7d09d74c203cdfdacd889e976a696c259f3279ef6dbc3001a86009c052dfdb088948612030250ca3451d851de5899cb9946768416a1faa8fc95fd7b0e22286efc62fb81faf3a8b801647ad7daa493b9d0bbba25e1de823155868bf7453b72bf1ee3fa0bb4ad16300937e7c007822a7fccfe6bcb7f8e0c0a46e0d457189097b8a9ec262aa7a039bbdcb99b76237b07e8875fbd5fe4d54ecf0d5565d7a39925f22ba276d4c6aa188143b1c2385758751adaf308037245b46e63dce0782bbc4500cd35c8a70848643538abf512f71665f92c16e85b39c9d3445f1d4a2e2dd21f7c77450c4e25c416316452eb4d8b452167b9862e580e1dabb11eb8ddcedf514368c2745c147be2c9c003445b42611badfc45020b6120f890cf849dd00338ebdfd6f1dd7cc74d2e098e5a585a4010b3dec723f64b75fb85dcc5519d74452036a7a7f3dc48a057889d75d53e522028a764f5e678f36c901873bdeb31524a94d5495201dde3b83ae481a4eb8b258098c6b6a6298a7400bf437f71d41804e8e3b4c5b160c34ecbdcbd1cde0f78a4e708899e3fe061bee30616bfe2482f5e3a1115758bb3b590262b368cb3e3862cb847442178307b9202b7cce6c37885fcd20b4393b935f41cd962d428b46f749a91579617d47075f5701f5b273196ecdccd4bb39aa5df876bd41f0dd66b76bb2889989531912ff6531bc22be52410489a3c43807d79946e43c4162d8d7cc30e69fbcb777a0a1739a1a940a25eae56ce6be4ce7eecef867b042d05f2f526491a66bb96982a8e994da964f7f04ae398640e42e82bb4a6a28285dff98f6c30ff6230fa6f245a2152eb3c9141e74a6b5eedd7768cc1330f1614d051089d62ea1cbad3de76233fd60a12eda7977d876823b62d07179a622056245be3c144a7cac25a4264b7be8a254618d3f521ba262a047f1d7fa195473e542564806d4afc79d3381b7fe68f6ddd33f7f11412e57cf1c375bab3b6c7b1b8342aced7fd69b1c284885b34d343dadd0e63d8142379db7e124dcb5bc93b4d845c86dd5a567c41362e17d016586cdabc548a005b4be3ecb0390b75f99248c6265a572e01275654a09f931bc9c81a585dcab012b878d7f6b0dbcadf63d45abb4aecaf13275ffc38fd08ab90ba2222ce5272e36f71510c1511164ae9f2b4c3f5122b227951e2e00ebc94a5039ae11637bc591ba238f2f3df89a38a0ab6f2a106a11e7a9b3cb164681cedfa3ecfb7516a3de213bfdda26ed7bd99c45f673d499e10dce1f66a9ff9debcc250f9e89adbd08717af0b89ab11a851764de45a52da2916bcefb374853c3e47c3e93b0bc778fde650d892e21b4c1e2e9a1ca87cdb30322d19b342cc764c09ab42ad42d004b08db12bbc0f20ccfb05ba55e5dd1bbb5d1762542d9c707fe7fae3b772e140f8374d4bdbd3872c88f26e6242c0f166af9200fc591e14530be2047aef59984df0b55593e6975e14d1fa9ffb8fc8060f3a103ab972c405cfb66a46e9fd884b0d36633b35644b20050a09df05e20415cd2d02e28886c5ff0cf55df56a8423722d82ce64f725506fad0459016343520b2863c69a65180c6e7b0b9ee8731008ffd21980f30f5265748c35ea2e11a1c9af3351f5cf5a87a2eb9f84eb3a1783a103c6562b6940749efa23093907737a4dc5fdf6b6126ffdc88b9d025a66b528dfe939260b5f3fed7fb22ca2ef7d507150fc458244df33f248644063f17fafc5e6132f757016c3a9c24c704058d54c9858f714206fea2293d3b91580b312bcf3c03100476412c3203ae78aaddf4e013601708f47a6531db39884aa801ae7fdf192724b092ac109f2dd8baad1060b465c1983b4b4554386adedaf0cb067b5222aa3497910e3d8a13d13bc26e174dc87f705b0cecc78993d88c1fcba95d9616385ae5c23e917f51e44bfd6288cfc352f37a716907cc908430436bb62cce401297c38e0bf9f98a06b33ef587d5eb31f58d9104019ec2f0f5f5aab6f666706cba92dcca3787cba7840c8b7fbcad8e45f5d1cfa353816d985184450b43c7f8350244bc94a11c6192a227f2a9d3dc53c7982abd01bdb154400f5c8996f505c1aafa844801fc65c1efbc44786b55b63631f1248f72e75ec0bdc832ef2b1f3b5d95255c350ed7b6413cae0c1016ce25285d9cfb1c11963fb645592116e81e35600697042839d325a3af0489d82014d8b26a6af78069aa8382a2e24708ef3341005390a7a4feaf911873d32b6dada352c662c2f72581c8f0df046c0751d0b4a5ddf9a050fd959c4d695a17ed5b8612fbb1a92b00e13d55f1638191dc2f74cd994300e65b7b087ede0317af49549de5871429dffb7616af7d949ceca645aa930f1500278a8df057fdbbd2233afa252c01c194d7773ab0297f50e9f240eaca5b7a9e517746cb75eac77bebb8a787e0f88c0b9c205b0ae9c7b49647a7da41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
