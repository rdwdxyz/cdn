<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f28bca35fede5d33a2d03216efce435ecee94e2bacb177b0cef892979ccd9a9c27278b5e0c8e9571bbd7357046af417e6ad5887e9060c5fe9201f10259a283679a9555f4a7faca8aa3caec13e610c47c9446e70b55067ecbbe1e89c4eb69e18e31fe8e4c6a66029aea10e6208b2699c7172769d567483be18dcd3db179f3f0cfe1ec965f75cfa52a884104536e68cde4fcfbb3de8d8d5d20cbea1ef63d9b10759648edf8ee5466860924bccbede93869688221ec37371722330c8de63023414140739ed7a6d0b38472c5dee05876f05098cae27be3e3e267ca3dd42ce35b7de8e4414b1076ce645258fcc3ad29540221442a3e6f6d9df14da00c981a07edccdfc5aea946b46dd0bcc81198e5932be6d70e66ff26df86a06d204dddf7e2b8a5712a95d70e2f4f86251b514444cff4ec4cc9ad0b86a215051abb317e6c9739330afbf77b5d24a6223e2654086e8d0cfc34037b69213a89638419dcfb7506c94cf499518aab8e6b301191e083b14a4c9d0f2573917a9f019c73b7398bd2583561fd4977652116fdba59067ef3558cfebac2fffefe28aebcbb55289f3a57c5f71b0203276732f9f4a09c757f18344e181e37452942da7a1cff49df9a1e3cc0d0e7563a891821cbb6b5c0193cbbbd143fdce64e7a12e150b3f8dac848b265058e12b68faa57f1463346140b9ec26f757a79a5cb6e944806f4f885ba23e8dc0553ed921f2ecce1dd3422b2c9e6a9119436c369a218decc7c1ecf9b72fcb0e2c256c79ddf09c52f6528001de6edd9ed38f23f215f6ad180540a430a02a090bbf6eae237b1acd9a7d657df92ffdf8076b68f82e99c8c973393678c962303690f9f3e26c12e055d92e1be7ea07345fb4ea252596e965b2c1d221689556bd36890589ac7fd9361481caa53cabd21a79d1c96b5fca1e9efebe295a9f06742c4df68ffc29ccdad774d36719fddd7e75da8d86491b78bd7a4d3b554ec7100ff0e75f9cf604183fa50e9605e4a9edf216708305ea48844f222a81f1b8289acd03a7c08b924554d21621335585dfd4b3ccef1e9c95eb3222964024a288b022c53d517f2e171482290899d1c30efee1e798826fc1606e96519466cae4f5c92b1d200ed587717de5cd2621bf1bb95a3fb054371e0cb909b867f8f29c063c60e42e0a226c46322f665b8acdccc006000c905e20c9ca32a8beca206f1d9fb825814be15eaaa7a6f5478e3b887318c070eb5ab5dd27017f0d9a5190a235a2757ad3c37f1d52abf8ba94aac8ab419b9f827adb286e416fa3de19e088c5168fb29ce43b5bc35bc2692fec465fdd5ea4b74434cc0776e5b18096ad73697422a0f436ce4cc8040f1defb77a6c3aec2c71f82a3de4017bb4b80eafe3f4adf051794ea6c0f4a0e0742b970dd55646f10c06c589edc59c397a0e27a296bd6e188a3b61f5576004a729863fe337f90a718ea20eb03c5999bbc1bd69aa575bc9b6b7d5ad89c28ca22593299efce8f7bc941619518b55262feccbb61a711f053e1e6e5758e50d9bd8b2b2cd3668d19b7e06b32fd3e9f45879d1677f7c2dc57b144995f5b137d643c4cb0a20854e1bc3cb3681d2080e92230419be487901a54f5bcd86fa55254b855d78a93fe763966bf2507a1191bdc1c6eb6a06bf600763fad032b2616c451c96a35df6bb5bb2beb0c118231ead13484dccedbc4332595a24622bc26becdc306faaf048a877f13a33c81ca944a0808ac4d21a7a266901e8315a549a672fa63b52c30430b3ee4f78a1d869b5e743dd77611d84da5571345a2201cc8ec326c94cb4477f496b2ef5cf29010543d1754759cd43b2fd1c1a48dd54e67345ac88b0f0b089a8c7f201208cb9e43eb06a77d120212d72cd6096828f2040747ef12135343499a575e49f2d1c1092cdd175f6ada0e5c1dfd1031b246a6c956d75fcfaaf3c270a8f24044c7b5cff1fde8b19dd5b059d0c5bb9a9eb845f9bfad09b4a66739d0763471bcc2dcff55c689f43a86dd65bb6343ee9b5125bed276c2147ac9eb6786ae412a4cecc04a5055b6de7bceb5991ae622ea0acd5d888d4f9a0aab1a0d18f447e34a06354b5612089f9688f674924e3f60ea0f983cac219be95783a1ce1f7ae2a44ec44a8e3af7b7256d21767de4074e51cb607d502565b2839f1b8c8d33a881f8775e2b115bf5b8ddb1f6b1c3315a5b7969a955054c31bc733accf054cf05019f8c4b5e8a1dbed8c43738e032a4e1b2fc019e25436658bde13fcc69e539e2597ea015760cbe7d116a6058be92ba896b7c6c23ee08e476ba24e2b973d67b32e668e6a8338c99499fbb2324e1823027e638646f431da95fa116be78eba66ff7bd3fe3375520dadd8841cd23c02451f60ac15064d6492cd5780fa74a637f4b30dfe019101d8eeed8e9569c0058e6fec967f7ef3a2b18062ceddb57e48b5d6ccea7b3574235a0a1f16e3177ce43ef239afff9ca3f82349dd09bc69c3f682e07969742263e5d5a6f34da46a4861d62e791d417668a2477afbfd36440b49aab693e89c5d5308055460fdf26be158a9d7a0cb3031ceaacb78d77b07e724f38fe8413475a8862bacbcbba00c70b541215b252521796115fb7f060b8c94d9bae54ecba0533460f28c8cc6bbdefdf6d5c3bbb86338979a6c9ba601a60e6fce311990446ee3b36e486a7acbd8f06045c77158e4c482c7a8447a19d12aa0a7f06870c4653c1e29daa323e455d0c30745569e6ebc4cfb2a0cf763e277311e9d97f96b2dccf1dcd7a911e3e11e4320de0471014e007b1a25843f7f93c08f7f9049806f988059baca27c24650daaa4ce1389ca914664bc51b588744bec018ce0526b7e36885f7fc94831d04abee8ddd0d832499d5e9934126fb76d696a394e46432755d05121d149ea5e2c02f472ae3508cdd898edba052077a2eb9bf37e5f5680bfee5c95e8d1d45d7498f293c52bc1045115239fe75a26b3a675ee99e04601fc49127cb73bb4714e5d2f25e513ac900b4d2fc1d1f997e48fa7b53929c4647db34a6a81375c15fe646254d245e58602a036a6917e233d9bb5f57af19f3498a2d756abfd9031c26680f5ef79a588d8cea4771080c88297ddefa9d19e1a7a87a718fec1a627d44fc2e8e7453e599ca2bb97928dfdd3104aae507a61e7becded29b5cd073716f0d0f926ecc9eb9502e4ad34adfed18c6c80c46fd42096406d43ef295b3af682ecfe23d8a7838401795eb209cd5978efab817b64bc0f98201d8a87cc463658ccf8c743d6a6417c8e9548f357c18d4c54753bc727f9b139935c3f069390b11dffef362153f14ed815ff4740c7eb2d825fb812f9c3eb29e102ebc99c0dffe92a4eb5effbecd3882ecb165adce3259f230bea81168845fd1c1e479d2d1f301242489dc93fc20d801a74667d57281176293b07704869e455fc4d58b1a2123b58172f43d96204cf6d539a4deec962ba0268991120b46aa5d6aa0715b2dadf5f47b722284ad8331a56a1909f56710d911db3705b06b2887b402397ace3c44de4a05b679359bbacefabcfeffcb0bbdb7c7f1d9f69361f8b641e4966c7161661e3a96cd442e8abdfbfc9544d8792de6e569b0a8a5a5d3c2846947d310d565ca63ccc2dd830e3cec05c59908edaa71ebea0ad03b36b3a35637152d29e0cbf269f0363c04e55a34317c662d8be060955e8e863791703517e339f7ebf80639bc20f4f3b5cec878fb1eb3252020fcdc541af68e892d8ea58456dddcaadddc88fc5f0d8957519ec759e4e796f40d05788d839eb24f6a928c901962687d81de38d50a0c2bbd5f0ea2506a5344328c370b7140744e517ca5acf37f206c1c4b170f475b0ef363b6ad8eebf3bba3fecf93c4d011389d7d67448c9acba70f63eccab85375e2ec2fce272a2145b6e4a1df1ecebfadfc4a893b7fbf694e8f19ddc607c9e9a4ae5a5b1c5855ef2dd6d7b5dcd5d704c57cbcca606f90d986e2b5894c17b369102dfba847c7994384cea16b133b482d310a3a55c0c0218b00908a94f3d43847fc41f8f4afecf0d0e29443dc4ab774609125e9661437fe09f534f7c9a16bb318283a8bb6acb097d39864575266dec6f7e3785d00dafd6fe05648aea964284b3fd4a0c368bf2e9424c710c5377b5691c7e0d316dd169181bb5a8030d43c46dc07fe594e49a63346ab0872444f8250a236af69db6efee60ac51613b0318f8ab664fed0d18d5556f8c6321798fd3167a25c602b6fd6ac1222814608b4a8d8a8d801499309b46203f4530c08a17d9e90d062a111b63059f1e915cf18423b0d391c5fa989163e3aae99db30350457c85cdc3866d909e5f1f44cffccca21328c04df321b1ae9f96f2d963e523f6a4850c4b1b0b9d6b6d0a0a9919a2cd04ee5a8a31975904e810d86e07340805f868b7bf60fe9954dcbbf456be665968507265b0c7842c7c9681c7679f5728aef85a8a38f083931d0b77985be179d9b088961af14f6852c7316d181e06ccbb5d4753411bd8d232dfa19abd29bed1ab1f7544f593b691e54491cacb4160a382656f7198096bf529219d78e746ab5355813f8d6654ffcc26982a62690f44fcb34315225333fb77436e941f3de2bf33a587b006ef61d1d7e4b97e7bd6fa926dc4fc6ed834a980106b324612c0f29345099f07d7a3c543d607bccf67e0a9e8131a3d05643e5731efe18c4424ddccd33ff359568e5f4eac6dfa1cc55459f064779b4bf21551f6466852930e5eb994e7196d3bad58a63d9605efe1f8a691880f49470ededdb390de224261240073bad88a093cb073e3ed721b7e0a3dc1c35c2a107b2bc8c5df76d3b37997eff41c1b4f89f81f3baf73e0053ef9f9a1c3670f37f2dd998d51ed312461794e7f0796d4a28e1fde90d6ebd177d6ae632efe5847f79cf6ac45097be809f463e95ffad53051f946ecb39cfd8049f0c6f7b94254c61f3b79c632878ac80927f6712aa8c6e8267cf7a0cbbeb83fd9263e1a95e932a2d4bfa4777fdaa86b9e0716db18b98d26e007878a752bef13e46da6d15c91a43b7208054e30aecacae76f281d48b3cab4de8084d03a13acad0f5ce1944b4408fc168d0f181848935b1a55a0b97c2f9f8c146c9a08319885187d00fabaa240c53e04853629dbdb558be9ef7ebbf6218e7fb2390aaca0f3932596146ba1f00cba7d2e832b5e233de5768c53583312f3e75c2ce7ddabb7bdc50b088cfd9dcec3d79f6f4302d1dc559a7366736fc9192a4c3a72ab5bd55a110990b0bd514571b7be7a6138d8c2b1dfa1a6d2f24e98975d56b42a8029b68487596b5e0227bcc04a3c4f229b729b5a6b9e9be1a0fbbcd14e1f29734bd69828d0968a59cbb8be8664c9d11a8c0a420254060c0c3e2a06d6b2628259ce490520ad6b5d114fe07693e5deaca0b654a9f7eaedb4f25aab3dc55c2aa9f654a2474101e650466cb810ab71d8c45d2400ccc23f02c9d9cd4374cebafd72c6c88eee512b13e85cb7acb5363811ae833f3d83dcbf25bed82edbde3dbbb68d91a7ee519d1af1a4e5f0138cfbc42b322111dd3b570d92488e191415c3015a7db2977c57e1faa4b48e4d3249d026b76e13295730dd6b08506d83dd1e1279c4910101c1eff5e5e82dd321117192ab84cd371e162f84c2c92bacd3b12af06589471c4801937e17f9943f56881049405f2a8e84ae8d693b37399199ecc76ef9dc929e8a7ae907f4fe0d9efd1ad1841e244c1b78b434a5ebaefca95ffe8e1016aee94c6bdcd5f11dd9fc07672d7fb78c1d544efc4ad07f3350cc7aa18cf8940240bb93787ef53dfc7358f700ab7d08da1aad6592a8dce0b38b39f267f4d2e6493815cff262bb5450650fbbfc8a71dd48b0df46f0b06df64c96c684324dab335de759411e50c3d52c67892686bd7f79680192e933049664704a1ff32b29111bf752a07506c096207a65a354a552dfe3a77e3b00bd55165bba481be02db7a9d83669d556c94f73dfcebb46db3e1b9e960f26e49087ba3188bca87a05fb96d83b57cc9b3ed07038ecf676ac15f098df606db5fdb54b8d70b4ad695c2bde40e53d9f1cc839e06bdf2530d3c8ba7de68a73171cd4ce299dd42d526ddf5fe9d3b82707e74f39363cb6f38762af10e790c4361e86524b7efc8aaaf613369e4287dc68f49127b4628a2fdb6789ad701192b8b2bbf7564410fdfec2d171c6630382c02591bf53a66363c7b8cf6703505aa520dea3f4f6bd8873ee8d0cb49e114e39dd5a2d85a643843111604c465c7c42257854ac7d2fb25def5d448df4a6eb0728cc09d13e2926de35270751979dde1ddbacdd4cb32e4cd3875c0ca29cd6db0195f7560ad40c3eb1deb23ea6295e0f4c5bf8877d8dc27b53790b84c2337d0484e42753c2dfcc317892da16d21d293b7bb022acf47c3f7f699ba89917e953e9731982e305d7a873e67d02ad780e6667e7972437f64a5e3361e177e5c26c48d96c57917c2837ff4a7a0fce7de3ed1ea027cb249ec24a42b79e0fb8e75320929e618d544c1af470ce0bdcebf3a02f3d89e33cb5f285972d417b4dd9e0d8aa64b99bf8e39d786fc11f13c84c99006e7ef8b45e0c1efe55f7f3f84b1cbe3fa3ef294ae52da89857152148209d666aeaaae5335e3b4d095d692e85f97814cf96c36915224fd3a537eb761c2f905d450675b3792bbac75fe8c1a94e687cf5b4aab710a7874bcb057e7417a4c6bfb10c10020b0f40d6d0ff645c0739c2cbd5faf1fdc7d713d5379d07611c4cb95d04dc0cb18eee9de82c56fe73f6632c0e0b69daabbf984d8c36f9378fc7fcac6447ab19841a09aee44cce9c8736f5f83576fc163b8114c7c59c1654800c24c5a7bd7492711dcfe851c0b6fc0cec627bda9b4424560cb24ad247521aa102e4398d3fbe125bb44dcb641f2a7e683c131f373213dbe3f376a242316f7dfddf031965f5588c7abb40878db2611bf3c2142b0664261c69a6ab9a309bab98f023f20cad95a68cc84957a3127fc0d4926e462f766434938ee06a237b909c4941add5b5fb2b05be2cb0607b52e5d06e5acd52f7ab9443de8dfbd1e6c26b1914df7e37b43704a96b3e569e7776888ba09562b1290f1afef872faa9c509698eb1100fc71fd75cbe8258b69d8028f9cb2093a2b816d6136e10e56b24dabcc4443e7ce3771894dcb913956c18f894c431d38a493b40a059080b030c27424195f67af91c6cdd8c73f59ca3c052aff536bbf079f266e8019cc24d1e8bcd087c4cdca601a21bf74fa0a8f22c3a2155a6515483d33c42594215d3b638985d277f1c6c6608282bf993f6a8d28f678273c920e77894b928eb37ee8054fc45c9c7bb896f2dac77525460aae8ff1c7f5f54048a2ef73f1ef769d2ee11bb81dd714956fe45adcc5bfc00352fc424095e4d434d32c5bf41c301adfc0224c98af638128c3e3f2d97ac66cb234c87e7e68f9ee422d66b6100f554b6866899df342f322b98b4d595300225ac6c48ba63703ca1d57f47930884bff7c9445b2919613417c820b706ae51314c0199bf4675593ad55a85b55534734a36fa747fefafdb061b5b4bbd85999fa8c7193869fe6e6b5411067ed1105e56014d5d3b832ee745e5e7a031510c12c88c37f4adb1a9a0952ac47da7da03ebab0d28f5464306645eeceb8875070f71b679dd5db6d3627ff257eed3a1213504128ce9333e33542f787f0f3c2559528efb37e1f0f52e2c7a7ace4b26c759f9e89c86d3f0e45ed633d961e59324665d2808dabd50c551dc17f9b9336f6d17814db4d7b3e89275d52b9afa34e6fb664a2a41372c55f4126bdc1baea6802b0d8544f225e30c57e519e19007c0622e150ebf1e270e68257cb3f2f66b7a7ea1e29304d83011727614876fd700afafaf0457c4c171b5a1e40d5d8f6062f9a0a6f779b45ce94dcdda6f6ef32776e400d6741bac491220ac149cbf0086a9519372144ce3a652fb8297be6601839794a284fedd6f9246325c0751b71c16213e917025d2380060834ec3c024d4c32a4de3e830424c6adf43dce39f47b4e828261a3404c041b38749d24fe63a90570e8bb88f5780f452180ddd7a903bf18dc7062785268b0f9c6da8f78ad24f063e4eea9871b32b799019f4e1955a7e4a536b9b10e20b70e13a5b96a23991cd6c8647c2eabd0218c48fec70f1aaff09e19c1f86f363a3e74c2b8c35ca39686c1254e1a63f5168d92ff44f8d9e737cc2dd36eaace49bebdd9bb6cedbea739fc6c78074c62d25900d67021029bb827b3f5aa3addd76bf86dc44e1aec96a366e1fb575be08752f561ff9fdd6228ae023ade0fe4696775fc318cc396d7db92dcca26b1b27a40a93f7cd966fcbc70e818a909a56f96e21f538c4747b89438479564e045c6b124007dc98f720a6ad4ccd4821ee6a2590f3860e884dd1bbd416fd4d3e3843b90902ed612112f0171dbef0d889e9c4c61d72ef1528b7ddb663078b64e1358fa93c1b44a786deed0b65f6f8a83fb4c964198ad8bca6627bc6ba7ea004e304a71101c27c5d5cee61be7d008a8733368a6d78d96c296b30a4881b37191cc695368bc49e0495df5a30c538e7e4d3f9791faa87ccb4a41d9e391b2afc918ea0e9d0dd16a00009bfc77cace70c0af7eb018693262d9b8ae5d3e9f4ecbee699040ed4c1665897386297b826f117ded1ce86189150c6d0898395b28c282cd745cdfccbbeb16b48e060c55fffdf907144efbbe536460f55470dde9fab5cb6bc6dc3dbe5de6d4f0b60b6c281b41164e2421fe01a14cd4bbe8771c95a566aea46eccd6f2112e5e562ccdbab0efdff33b7bd376608e1798e471c42c547397bb0236c7bcdcb01ecbee488a3f066cf926a0266638003ebb27f162e40eb8ce69758a3063e3061f54934a18caaeae7b8fe06ade3582d9d9c72236854032df40ae32a6de283279304bd7690166292aa3bbe2d328f8c0deb2f7b05d998eb0517dbb3966cfd000a4e01bd2972a08e1371368ff26edd849a6cd67492b7c1ff6a1e8832446ecde82ba525a15fd5595cb15fcfd43006e3900dd41e740a359a5a79130d7d8d9a4ba141d28ef1a06df2a678a1089824ad2ccbfaa6937ebd32bc2d6601a7613abc09636badd71e022a9cb4e25c1b7b189f7a35d9cc34dd00f235220e803af9ff8ccd2b882abfb7d7973b0ff69b4a68d698c9b8cbc88ae6b6975ac16c363d5905d13c9680036f8c74b5b6a084140cc8ed2a5bbbea8d2ee75b9e067bafd446b8eb6d13792df01787dc05feee9e68f188d6fc1ee48b693939a954911461988c1cd51cd6d7f30e5d3128a8cb6d7a49c8f2f3293712539ef3f39eb8cdc40666a4b1a3578f2dc557bdf8d417c9bf6a47a1e828e7b6deeeaf61a5918c09792cecdf2aa15f9214bbd00a658edd54531598d28dbe6e3cba436b1706b3168835fe32e37e41372683b3ca3eb8bcdb8198aa798d0cd3d4447430ddaefa90edf670d14da60714f13f68edc8190d5cffa37fb7950624a8032ae446791a1f833149c24a020838e34f5b3a69d319dfaef339c2bd19cd8a48ccc7cde49b5fd8f5d54520786593372ae7924db004944eecc80a4634e4274715db7d58f41eaddd7d08d4664a608b1f6c667bfd0db6329a9ada463f7babc32c458d4a78054db8585d4941ced60549b1203431c806fd08b995020cc7b456bb586436235e85ca5336f16ce6a9340c4a47931821c8507ce9a84721874b9347fbc87148e97c5e59aaff912a4eb32762ce2c60396b1b9de729cf1c2a8e115700db943e72b6fb1eb2e041eac2cc1114f3e4521e7cc6921fd2b811e55292b9c35bdfcd584819e67910e8785c69381c155ad07406a0d9d48ac0c2d371c62d64c1aa35bdded39e66a1bdeb39c0dcaa9f33109822d03594c23749567e47f5892359be2d097cdf3173a710ee109b4ab34abcebcf04b0741380d33c5bc8c3d37d261d794ae5bf8749bc30d19d62ac6cab3605dafc72d35c35c3d7449ef672da804fe19140b15dc17d8e140bc5a8676557763d4bd7e055ef650130560b29ed95c0a9daff2607095710d92d58d18a80aab8e6d7a4a2807dd1b638277ba4ac5554e1bdba2d1186b2fad3576bc9a9aeb60ccd7cf7cb003cafb25aad4731b03495cadc59fc131e6ffc67212e6b7ee3f3a5d651d1d2828b2790a9e6daf57b92ea77741a2f1d82d60b8915b0aa962ed6d580cd339b1cd596ce4c22d83878b98e673de408cc62ed1b8b5a1b2c8fed0cab0f63a38c3a1077ca5cf83c0b5da7df5a77ce08276b84f32d1159510bd4cbc2f1c2393cd2869911f9de397d650154f6dba0e65eb3f694fe55f13cdc533fdb4e6bff4e456e6b18a1805d11f5f70b12593a803f5bac34432627ebab9190777d20b50dcfd64f38be523d3c516f6b39df4d7f70b45ebbaea2c51e430c728ba9a6f7f475aba35fb0195f8229cb646b74e6f99ab79004fa9c9df3f7810b67880d9b44f5f256a0f489b72fbac4786a6598d4dfca021742455640afec4760ccfbbb5c56db58a7801b8fbb96ef8d944cac32365b604e9e4bb86b9017a3d6443e1b6ce0602c501ce4a3269ac852e5508bc86c3beba03eb556739c065a00b6c5a49c313b12b6826b87509c122e67cb351ab396355a3017c50202c9fa9f80aff84b0276689d749607a38c345ea4655a23ec996205b90a872ff9b1d2df9bc704031e3a8f2e622be08f2986b4d6f15072eaae9301ea52c6705c47b6786aa851eac0b6ba85257ce7d2d532b1f3446946ed9c0f2feafd7fa67c22f1c8e3a0f86afd096b4e150bb069042de993fe455377b5b6985a674bb3ad60d228e9b6edc36c7c6a63fa6b14302338e50375e04b843f83f3f87ce0f3c3d6b3344ae0f55134f7d97334de624ede2532ba6d3c13f9a8cce87a8f0eba2c674ce8bbc35efa912d912564817cbdc7889178fb37aa0fb9e497d1f687d497cab7c3c8c2397f0fa0974aeb4905d79ea1126f6fe60bbc214be9de9fc8d17ee02a3f062f2020b1f1f6101d840bb886d0cf53373f82e2f2e8e68ebc0fc5674bb1607a38b3c26f4af6c7a540f6baa50010216e292ede83e256d118ed16a6c77c9992cbfa5f785106cad05a706fdc246be836d0547d053cd33c4e5f76356b31e29ca31816873208664907ab7ff766483095e4037ba13de07673f75f180f7478f0763cda9f5fe34f4a4c748de019ae0c0e855ed12c7b9b7b6144ab68264b02cdcc355659d672b0f85c55a98c85a194cf75501f074fb1288bfd189c34890ca803521ea432c510c85a438ee4948eadf22d15f6e4536f279b7f9d72d9dea2e03a444883ea02c938fb5859740fa012e530584a4c8d2c46b21eff958c6d7afcde3f5597d9f41f8d9735fcd0f3c5c5bc10fe8b665c86b1d78d1f8a80f4aeb1ed4ce31831c6cb713177451cdfab6ff9e4e0a736241b22b0edaecab952cb955398d90e1bdfaffda632928bc5756f87dab4e111d6bf9f69712f82c7226443db771a9e41a35a5a874afaa741959cbdebf7e1f0985b583649e5b1ed9ae1f8485f13bae261f4a3242dd65302f43429330c5fb5c1294fced624d1fbf703f0c7f542e0e6e885bad811240f34bfd7b09754e5bf29397b96a685d5b6fcc827c2812bfe40b6554d5dfb924b4015f4bfcd3c4baf31b955e6514008e2c5f529d428d9858ecb55936bbab39eb49fdbc12e15bb97a59885532f01517655e8537733b0dae54c6f79c6be7f56dea87dcf6d70c4575203732b1a996abe09c1ecca13fdb05caa037617af454ad0c5669c0f1bd612609e98fc0f30aff0497d866c5aa3af43394f9c281f2387ac18e98694f0ad0153704e198829de9e1635a1fc7487a71d2d9b2e80c2b61f98efd81b2cacc6e8e65b70143fec3b39b6e7cb86f7a12665f2f6a392e1bac4378183a6087a64102ec44924082586e27936dfd486cec0ecc6361230ee35710fdd2f41292a88fddaed5019a26ccc8a95e35a4edce03efb0c3d81295bcc4844150e433e605da03aff2426cae238fd94df6e5c69c149fe29135d519d44255288b53cfd396f936211811541bcaea48229274971d569fae597238db13ce1da5c2d169997f67ba763871b56c4fb6bd239c0a53597807fef502113b49584c793d505cd228fbbaaaf9c62666832333c9bfa256a8e3fdd211f366abb3d8dd73b798fba793acdb8f7cd509218f23e9f7926c88ae8f33aa27fc8fbfa76e54b65c0f4c43cae87e290abe4a8c95baefaad04aa202f5745e69b35c55ae1aa51082478887abc5757b8e46cf56cac1fa7757d52ea274dd0df56738f40999e04a8fa2dc7a772f03abe9d05f70048d18d71ab43f273a64b55d1a1e49c7286d5b723aef2bff2b118d2970e4c739f7f6f55d0d62f84996a8546e16ad4872395dc299955067de9bcaede5efb0939df517589a743d028a44b709cfc3629e1c87b3306f6466bf43085bbe9b09fac49b52d6ddff75d47c2c936ef651b23cf69f620ce0d099dfd124e8fe9668843aee61d6324ff497eadcc7e26e69c009a37009cf135f9b4b5acd386c4b8447ca05f784f4ca29034e54899730f79492b8f629887f7c3dc643d4a6c7cd4f746daca3f3891de30ee32732ff303c1f318176a7cc7c2a79351c870c42f516d41f4f9220a14f6c7f6e3e3ac0fe706cf15e88324b2b9567deeb2f0142f432dbdb24a3f3560a2177f12082a4643c5cae546811ac5e9037bf16debcb01d3aaef7f5d8b5b21e64e13f56c91af368a899fc2837052fa5b904e8cb993fd61764b0545d5480138d4658fd13075daabf7b49f95276d992def9db4b1b143ea0d20215af3645e7a05df5aeb5b7b1bf6dbc54578fee38bb9bd6d1f98a8401b8201fffb02cd632d2f43dfba728735db0313f47475b8fdf24fda45053c8c8beb54316c9aa46b863a3c4289b93ddb7cfb6dd16d5d12edc3b699fb7fc67dcef1a5fc68826d10c97520031857fa98a89ea3a6e3440d688ecee2abae09d63cfcfc5c7a9c5bca86db8bc6d515c601ef99dbeb7805fa472fd4af9e7289c03a6b13614194c60083a7bb81bc0191bdf1af943df18faaab3d859738205a6d3ad942194466e74ccfca8749f21bbcbc02d8f691731e73e7818d3416eaf83f7b856ee9d2abc0037917f4ab633ecc384d617f532fb8cf739aa8a9a01507d2929fb749354d835cc1bbc696f8853f9d3379c1e10246d019620ca4ed44ad452ef6ef00bdaf8b0b4c571025fb2e444aedf64f88e028b15cb1d1799552c2a464282467f6e5a8c15cd796a0290f6ff3e6c2abc5eababa399b8cd552bd47c53e00b89c3775c5a9b10470181548b9fb6428ac8d42bc8c515a72a1f1121082fdd638a68dbe4840f3de2993142603c77096dedd1905f5cb5a5b7b64b208be9b92fbc693ddaf8a8deca0bc584fc2bd3066791770acdcd14879c7ec26d26dd8f26e0185a20ad927a2e52aebf28deb3ca7320835c6ba9284eb61f3f77aff4aacd44a7117587bb9950321608ab1798e2c821a785fd3660c31764e80dc6ea3d0cb353576f0168cd6e2c4d0b79b5fc2b35766f1e66f4861f376f8a0dc7e41138f41114ce6d8b3bff3ba9430f2ca2c0277851aea063ca00964097d2f3c2775bb55566b3c2a3bc14acf720ee52db52b997e68be62380c0c583c9de2146721d485cf78afe63f220cf3c161ef96c2f721d6e9956ffa9461e3cc1a7fb06353445ae3aaaee448a33d34cc3cd9f1978809f914b79428c7f26d04d4163f985cc20c8cef05c8fa7bebbab285fe4be1a567fba145cb8581d2470ef57b0fe3f72bb01814ef9264ca1288f83be97bc53124d584d877b3380e0de8b81725f9ca0b9e2678e005a300201b3860753ef19cce252c2170a5490e07284b44d9ce16b33a11ff2ac683eb57335afe90b0f816c1c84dcd8d0b75cb9f95ff19aa2f303a0866c7fed0acde26911624c8815f3470c3c70eb188ad7cb760cc14937dea45910b5da57d0ec5751f2d46f2a6a5b7e630533cf94e11f6b4a6acf253a1b179eee9ec54367bca5766235d98bf36125888a23b295e92e55b0db084ac6ff59d446aca9ce3b6a9fa8e0e1fec5115aa97097ac60c4e6860573b13382bf03a17fffb29c958ad42b48c7fb4fde868c08c645cf3835c4620c2c5d2d267e572a2e760f0259d72415e2bb1958d7930b860cc3fe0f75828ed868771f83cf47e2c7f6031a2ce7f452b8322688d97ec073134244098a14abf4ea50e9534c238962eb1727e4ddd6990e1461df2d5a4c608dced39e9818885eb61692c4cb877d16bde57d32f0b1e445bec538c8b0896cfc7cebe44a9edd398c0578fc35c64921e6e1b3f22770a7ea330e25a9fcd76ca6807f58ecd1311145183d78f1080a1ece25c573eda775929245bd4e0fd3a24e33cbe61a370f09b696118572246770905a1f475267330eee353b03e93bb572b7969b9dc90b43f923e77e997768da38de996136cca7ea302792dbcd72feb2e406352055fda66db4126ecccedb7c5e19d3d154acc5d9c6b5615513990174e44df44e9f30e3ebb2206111919443e9204dbaf5fede7da230b4685d9897737e83646da621847e4022f174b5473caa40f8cd05ce7aa44931a624b03507c0ffd2717a3e7d5bb4b0249daca21899d5280b7e6d5c0e49659db4f394557578f2a2ec91a292ed3181cf4fac1cec992f2c1be8fcfcee39f69003faacd7f4e9dd974aa4a9effa5b97cd0f29078064365b1133be6ad65f3bfd95957904a8eb0fcd8124085d146a9a5c335d9cc4fbb6dfb1a1c96bc771ebc0d572b1a079225935205509ca177916fb7a8bc0b346ff582143f4c707890944384d4844609965bc6c17d663456cf5e742ba64201742405560220b8f8e5dd92b3efab69e48aa0c96888c1dede5e99a5164aa91629a586975ba081bb855067490840ff6ec3b7c81733b4254a39b443d8543b8f7ac83c848fdf444560849e1ca7cb6531987513719291d795d58c2794a69d8dc87531a9ca0ea8d992703fee25c039746ca912156317fcc74272463988f7cdd337871d1beafb86c78fac056246e0f198ef13e554704ea222ecdeb29087eee9f4d105eac55142edda825efcea9d63aeaba15edc51ad5eadaf8dd8f0f04eac62e0473e959d80aeb242bb8aab91242db896444ccf286e48a7631588cf1f056a410f3ded4731aeb51908c9c6ffd01f5083a3a5dfbcf39959fcfaf9f8528ec3cf49c525c56750efa0290b3b697e25ef2a2a005e7566e3e28f4e411e47d189177955d8de3d1c32669540a263dcd954af986e1efad79e208c891d4f76aff7741cbf6f4aff06a124f8179683d0a7c769b6d9282f6a5defbc347a41e7a9f2f95339e15def0c4580f3a3ba076247e6e8d30aa5d8c761b42a0576ec0ca6f98ef74b2b54d9a22f58e0bbe0f5e809d7b58d05e3721f5ce3227de1a7b6119f7a10b5c9b65c09ce706f138c3c087cbfdb92327c35ecbbc7b7018e545d671555a1a14db34545b4e65b9166fb5670eeecfb773b941a95cb30bdc029e38d8cfb910c34a8748623ccc94c81fba7a7ad76aa185cab92ab05d911db7e431f640a914101b30afe14a061580403928acc6e104e5068d06e3b76c51b941e2400133fd0f47866b54c0c189219b4cdce5acf7e0ab68e0e527082c5dfab5a0037c66b9e38a0444cbde81b7b45e73d2797aaec63c0adb9330a1adfc8082a2fd156f37dab0dc722caa3206c3c5bddbce772c5f6fcc27b9ced4a209f7c52d760d8e715b96e3275868d9b2c88f4defe1ce60d0e0e3a1e16c20dd77ce4b4537b3b596b6773c8f1630d7cffd6a48b5c32c44e832cb6af0485876c17fa14e6c363e0f57b0ff1a3d9ed4554ab111f0b061f9ee645e3dfd71a04647b85488b26120ee9771581459ca7f727f69a8557b560547e817dd16c9d34a808221a97f7c3b7cc9f4d0c907ef02e14640242a72923b2941114b680b0f831d2531ace7d15230e116d10f36d5aa17b0e66d248afd89f5cdc95145731f9ff6dc0755c66254d7587dbd5131e2350bec0fe12e923e538ff7db46708b2967683b463d9dc4b30e74d43e93933c4a276aed2ddbefb0f2516ac8c9c9cf7992b23f706881ebf792e1012c5242e3bed6645274d62401587c2e7efe981d0eb5acd74ce98d516eda26dc7dbc7f477494dbfa3c6108ccf75b6af6e95b5e4e8b3dcf94255f97395a0671af965bc83d81c914f0a96da05ab22655819e88aba2fb322d2762e076adfa471d4131a30250aa025929ac73e58d80b9fb3e4003e74d6e9fef7939c21d98e628d683b499b79507a02e095240a6710b662d3eb90ec8d556d59d1163a1a2a733c7ad9e61714ebd64777c658b093423f5f75c39f539e8b687a24c0606193fb07f95d2ca3b305e3a3fbb29ad479d19f8656246e31a374ba6f952137af936c4dc8413482ee4b3d1088ba38581670263af49981c9a4046249e77c195033572a4c6815b9f2aa013c84464b1c00e063c2111b2bf8a9dccd57805df455f6f25e92ce47c7b481474455d787c6e4d775c22aa1296016ba6f0057e6fe866449c0635a20757d219e4b059a278ce9b90b411c4f1fcf89eb15e153be4658577a476ff4dba4d437fc9029575d0b98e023b5ad353c39e6d73e32ac0d2f85702729ab16c87aa6f017b658e454aa77afc75d82dfcb88a7690aae3bfd448dca5b532cad01f8f784d95ef227a9393c6e1ddca2bcfcab8019d84616c205fbc8f8a763a4b74ca17d3a9fc54a357269e2029fe5d9eb069623a57d165f8ab19646adea4bec266d52eb9001aa3c3ded3bc3261855d1f868b09f6f685057785d459c8921799bdaa49ebc4b6b29f2d0c28be0e39c22d9a173ac9393e7df0ad069f75555fbabea6805a366654d6a292ebb1a939918e24a08133890ae49eff55d12b9dfe55d731856cd26f3e0b41cfbbe4c1a405a016d9327a5aaa94da9035c962f89801b05d4e9a7cbf2659967342cb47b51e670b8a99d07b9b3758c9967434a85e85d2b4bb7f2c44451834282b0c77e857c4cee043c7ff044bd4078ef45469d008a810f1340ada999e20abc86389f8eca75cfcfa5e2885492c48ec1443d6184db1b70011fc9e120243d44767ee8d6b9e4b7c4badfcb497258deac8cdad9434ab932faae0aa2ece6147ef2a01a65cf549429103e81bec9beb0f2a5826311842fbc4087b2ae5d6ab54327a2a496a9d8aac24ecd0edc086376ccee6d0a1a2bb0402bb6072496f9d2e6adf25fe995e9b03e9149f2df2f3d7b124e0aae3779c13ac48e6d92127ec2d9584f9ede245e13eec926812b44682dad33101634ef2f00dbd399ce03ad33c9769686abbba5d9360db4b0a942c9e2190042b0546854382845859ba9e005710cc2f6f173fb89c317bd30c1b3ef9dfff7ed9849ca7e5906e7ae587cd27c2cae4058eb595f0440fb71fb01ef8071f25250004b5ad8deef7e1b49dca5d8986750b78042a9f1b642e5c79c0e9a5bb54fd354b1beafd56a2f46f5c73de3989e44d8c9a071d36c7af8abdd81b924c29ce42c5e4087bdc0c952d41d6f61651dbb77b423eb19a4f15cfc5c69a3e01de11dce7cb4e064e28f872c8a1925cd5cbb48fadfe6027a460a2e2724166e67b587e9dea0475be9dae76576b6b22da3ab6f2ce58d7a59788ffb67d847907ff9a4931137d237e1bbcf1278f882851625932f4956029b3f45d79c1c94b58d7ba631a4e7235fd90909ecbaa9db1586e0f4882819a38c3c7b3fff98709050b8685a3d29938ba9607bdc8d7d88063fc26154420ff683b1d77692dd758a4acf780ada362312b7170995f641929a68fa2a9ba4d34140867741ff25a5df5e50655b1d8104b014d24bc1bd69fee159e6a44ed5675c3a6c91aeb562fb76ae56d8ce62fcbddd960a441d792fc140011f6f6ea3af7003e2299c1a242e57ec9341e7120d5bd1ec849eeebfd8527432f3c7d34ae35bd258c98042d4c4d7ee27b6361133e859c37393326d9c644e4fcef5090ee2f6ec62f113cd5b5a0cbfa381cea267a90a598daf9271d696eb1c6e6f1e97266743a0ac012941ec0b6dc680b40f4328a051449d42f2b156328e5a2ee925ccb4da891999c61c8e8d8239f9c619ce8b67642bb413f355b7bda31ec28de7c3996780f5cdaa3c8857fb6b9505d6ffcef837ed10d3f78ad213f6d3db4a3cf825116f18d6aa425ad0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
