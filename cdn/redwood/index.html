<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03703c4dcc2ac366a92ceec9a96f3d426f23c9ae8786620d380e715e4e247339655954001ef1450f0af956f726f3bd1a4b072e4199e528da2e4dca413d4258d62a31540e0956c9a344074bf48d6b965dddd0f41652fd1510280aee5161ef7127801fc9be557fb49b3daba6b84d765c4e26562498cca0a21e4aed248f2003644a932db6c166cff04210dee3c9d797e5e2c4ddab27d8bf5ffac538acd7737649bac5ab67ca4bcd4461bc4668d0462ff31edf1dafe3c43440059edc19651fa7d2cd10256e1838b6e9a8f15c3391e1facb7d220e3c706447db61855def4fc3ed67063241aefc57545da5d7d969a4b3f3a14f932d135141dcc77b6687898e79501791c47954f5eb934b44536d156af2d7972be3e32451d4b4b50af0aa21c720f79467044da33d1acf3cfdffc380c570d1abf9111145d07162282b2377f71116cbcdbc02613fe7a97b2a9d37caa62c3dda31232211da9f77aa52b1ba323daa0b260327c8fd71859a05db79434c75c00d4945e5cf877ecac5b88fa4ca0e093b1fa9b08518052e024ddfc14c418869a5403a6d34b80c066c69165d14b612c0587b26910a93cbfd642b772157c18e8f7f1e5efb7bd6bf93dfdf08485d3133a3d7cd8f6176cc5cdc6887bc4dff4fe648d0a324fb20e53539eb9de7ed14f055667bf972c70746e3fd8b9ce33f48f4ea0bd51ac0f542a1c04effd0ce1acdfed884eea81dcba734ec41339a35a4665f42ce52fa013b57479723a839ebb6ee5f9d4dd15f7efc700035f7c39bf3bd3b1ce3aeaf2fcadc3b5afbb5ce288fe322268f8230b9038096fa52d3c867e76d2aedf56800432802c8a9561313cc005da76a6b36516ff3cd4a8420868b3e06943ff614f456b0cef8ba725ff75aa19bda071ea00a331b1e53a7638fc0a30c3da4812145f32a4ed1ae28e42db5d5ebdc5e183cfa2062d7e3b9d9039f1f576f7d9cec4ee471d94226431fa99281abdb0114b4e6ba398060f62d6d62518cfc16db989c6af83c2edba89501c27a7face90ec090d80319e537ff5711d1dae216695be1659e9cf5398c2cabaee7eb3273268646d13ecd486bf81f27099a88e2e30dce1ead32349f2ab10c0294fc5470609dd888f1ead7fdae12a38d738a9db2473ba88b3bb128e53fde0ec5b6c141dba26ea400dc52b7165b3aed3d0b675459efab463f4712bbdd57dc24755b181edee80beb33551e971745b82d123781e1355d59d30728301f97ad6c808560168d7243fdb24d691cf707cda73a518c46aac52c3d4eacf506e418db852d10de9918ee53d77335e4dcf00caab73dd65a6541f1ac66c704c8ef107624ae5a4d143b093ca468e60dc0eacfc483e616d51f45b92837c20194f1df8179f481e44597c3518bb9aadfce8dded3ee30cdf6cadaa845af8b71da2c49685bc5e72710425df99c73e90c27f828d02c62215eefe68ebfe96a167cc7bce7568935ee3e1cb56617eb09e1b0b6008b184ce58c5278d38915f95edde53d37400240e9fc339db49aa03eaefd5714496f1a8dc08646823a98368a423ab9f3b41881c705fc2603ab5fa293de0c295fa44811250023ee3a403cae2ded988782a8451a84aae6a7ef6ee3eb3fd0ce48d869f8a4afc9ab6153957ca6a82e59f7ed462657f5baad153a4a7c236974bb02f89e941f0c20f446bbde875b985e55d67d971a3a3acf90f8953f4c848f1b750ef90a17f5eb2bda0d0063e6ad5189a87719b9fcb7630c4690dcaa1b98a6330ca3e386e36e83f197a77feaf4a654430476bbb08da925fbba58150c6b61c7c21a6596f1cc99f13bd85a689f0422f1201d93baa62dd50caa716ce1bb8b343a88a03aa3f51347c929ec78f1044513597e10248f90305524d7a08a9e7e310756c3611715be1564c3ebbd476f6986d643743c0ff6fb648c1bd41314398e26521a69d717b652a4dc41893bc58c2c34a9180bbdff77ad1e26b8774d99375f068db18fa7f7ec208325c389bac991ed6365ea243790a0078042bae74e7716a07f235c186ac05b6f26152cb56d7fa5a63bcdc534023f8bade2a838d1d0868fafc6b8be3431d4974678584f696b5a3bf7f0cf1d2efe6b632a028712db22c4628eba7bf4e2635ab9fc83c52e782634c7b79e6aeaa4460df0827ddb59892550ca710db8f674cef0e4672f120997a72f17c2fd8ea299ffe0d00143485fd79d45fec66fa6334840616939c807b8c315f0130ac41205f0aa2e7a06ad8fdd91acfaac283c43965172aa9f3daa95926a5669ce0f01cae1b6909a770987005aab8913a580955d04fe4669c961bc666d6f3a149ad923b5dab67fe86536179c7d021dd5d8abddd88fba2f79abd96d4e2509c7bf0bbb93756d8c7cdf43fe8246e0286ebbfd145dc5f6d904e4d21b20c213a2318b4b90dbd0500c5c859b8968e349a715749f4c7ad8a294d99b359444ec9557278f74bbcd5c339fc7d5a8afdeb1bcfec4df60a67a8a740ac7e140e6c5337e11fc1086332a368c8852d9d9fbd4fe43d15dc2db668c9532f8b0ab3994c33c95f646d24a314061531b8e89d6db77cb3f90391771edebb143166f290c0c0fd549fe73536d33b8e2206467ced8b993a844068f8a2f944503a969bc79317d3547a9113bed8e1fec2cd6efb66827ec93145fffce37f2f9291f7d319bdf4fa3a59b600b34edfd39e584249a9e1e47852e8bd978d6ba2bab6630ffcb666cff4f400698456075fe7103f1d7bd30e57f594835fcac636045438ec537969936969d4f92ec177395677067dbaf815e5ef77f22d47122a2ee0491ec1bb4bfd137815d866152a800beaf3e7907362d5b76af86900dee028be84d5d9e87c544ce3be165ff60821787a0ec3c49bc4310476d6420eee46510778b770cfb638c88862e9957b24a71f043a1ced04c62cf303d5541861d946983b78b54545a06c6d11194fda363f07fff6d44d791939e725f472451194e554f5c7c068e8ab735a98021d6084e7c14f9292f0af965b64dd7d6890a8a02c892f4585c2b33888652f2b244cae99f88a070772fb2da755cd8cec74d319c1682479fc7f780de789589a40b1361a921846446f1b37653ca3c17a45ef2ba7d5706191bce3dfc321864603bde714f14ffcc2f57be449b5dc4783634adc87451cba0b5abc3544bc4a42db49a6f79dde62e0eabee7d42ddeb228aabe8b64156b83c86c2c21906514847f2f52ce8407227022e94e334c940c12af6e26c1d9350d3b2f912687b555ba1a608b562f2692ef2a32b0f9be15ab7e80835fafd525bc014905ee02195bd2e0e46f282be9f896716da4f8ad4a0e95ddd6b19a0dcdaa8fa2acdf947c3c141463a34765f126a5e09e97686f14110816e52157598a78daa1b86eff8f77536efe027a1ec9a4c3098cdd82bc0f07083f8f8c5a06e293c61518788668e7d1f92ada43a04b0908cdd63bb4301c556e8959d0039c63b3684c4b758ee3fbfd3df04cd64d518657867b7b5fd6db95ad041fb7db8a7abd1d632760356c05ab1d27adc56dab99b8e881fe7466117f88d4b7c2858aca57f5a8ea0bc2250a86185ea283de974e672fec2835e2a08402be9b7f81c0c91c8405a3f71920756cafe14389980324a84cb3a2a83869fd6e8608fc97f7a4945da2e525c236d2172e7421e19d69b5e5040e55b281639d896ad982e451cd70bbfbde2f3a73df370883368f58a9f3309fe02c272320dc5263129b03b656ea91afbc9c4faafccc64f7fb93ed50cbed30979aafc06b9b6dac86ef11a0a6d7d1ede49e41d8122a1ae7ac12d19c4ee94fe247c69cfacbafd4c76666d9b7413f7d656cfdff7575cd2d7fb67e47ca35bf8c64fdf4aaba63993adc2c440ad5fb8a322af931f1ed68e539d3ace9a486ae0c0417d6638ecc4412b8461c0b73e6487d249e5aec8dc6f35f2dcbcd469d7d5949069de93e1e3db445c285c677796f0f6d669e2f8a87e57b9cfd4185d5c45888b8c1470982b17148f37abbb7dd40da58780039163049eb36bfb1ae9340d22f85a3fe53800e4015dae9095b0e57ab6545659dc51d7ffd3189d690b42461866a4a660f4410d00569f925a570c152ac7c8f5fc316811c76ef2e764ee5513bbdb9b496c6db261a495b24f9558b168f77c6a30e28a2e29374c787f40d7f11cd6f37c45bf077c26c76119695e77723fce72e6782bf31aca21db6e255a5c5656874363e86305a8afcaa9e7ebf228fdfeb560a67905ad94918cb81d844f7201b58f9570e9a773c7b0883aa847b8959f477eddef26b7b2f81b8f66db262ad0a203b44571f600546b9c12fdb1f58b74a5ec703ff8f1ac5e3d17a69f670a9de8e5d596e6102186b9ad87b52d068303067a39d54c9033bbc7c018483745aad34c649928ba62b3d03d2bbd6f2d611fee25c794b140705cc79e73f501fa08354c3e5ac6d290008d6a20f48677465e2de41e95cfdc7c7802cb6f3f27f8968282671a6af4daee741781ae7c2ea40b3efe0fc73c6af5412391bf7c055a468c9371d97af454064aac82d9b1d4b6ce984bf55ba72ea259229fdcf67cbcda0f96cba7e49978e68c82e68c88844be379ad87827d18fbcde239f5aafb5db70fccd381f515a612d25d8f2ec841289b4a74ddaf6d0243c33bd9fe3304d5f02ef6c21305ee5f23d427436c6ba8e8c7dd0ada8a9a832847e6d17e0bc612b50f745fadf5dda9e638b27c270c002abb8e8d7e548c773b877b91177fb3830339c7a25b13beeef92a6a9a1a2951ddb7580adef27fb245757e5140174d2bf9d5b9388565325304f87d33e9115773fcbd25323a248ef4e066fada8a350193d45ee58fd54ae9f90df5b93bab91e6abf53a6da465ff31df6203360c1c21579a51f9a9ad8e20278861d864b50617fb20b5e5722cf5e7f5e318dea5d99a81b070df2ded8b1930a40eef5d24e71fedb0b6fc593bf9abdee977d7e7686e088573ef31db0764b6cf1762ee9d0b5998c9336798a95cb5b37330caa05f2ba41ee47f95d27281cea6362a7d5e698d03f5aa33be4e1cecbbc7b65f42cedfea1813849d2325f2fe9d0f842216bbe9797b22735031ca01eeda5ca2531521966ab4264695a5a9d9f496d922d5a04991f42f3a951991b08f19691abb6eed84cc4866a07fc56dee8671bc76884041140f7a2eec197ea668f0cf663af729d9dc46aa86a67404272471d0313d7d61f60d4776070e0c26076c594be4720a0bb038908940e9d1b154095704adc43c4c9095748782fd8dff18283f8aec211b6e0d049837c7fbfe627a6e4c71cc0411f8a9955933973f3c5da168efef43c354b7dd96c10b095e0cd345a08c822b6672bcffad7596df921b1b61d587dd21e7069b041b25004a44bdeffc92112abdeb89f3ef60649ba8da9f909ea19f3fb937e8587b99083c43e1088f6c5738626d3fb1a1abd56ef4efa5a1dc32160850d52012487ecda198447aac5874a2e5015922effcaf7a9d2eb150af5417fa685c2a19ebb35dd5f4d128c129eba35de285ded68b80a9a6ba2e425249b0bfe7a9463c93a08c27790b02e3309b19d9c646aa26efe4c06efd28ce9270eb3a64b3d958d46ffd28c07dd87af68181789161384f3e876f9d136e51c7907de3127106de40064fbde8668e6ca99fb51a32f3bce0f0ae5c96ed75ba34bbd3e34106b9ce755af804d1cbe2319748eb50658a348940e13ea161e86021ac06284d1d8807bf7648f74d4af802f78c9c650bf6f707026f673d72024608d3e3a3125c993034aca377c9c27729f4184d01fc718155416445681ac56215e2abf38b6533d2c421e1f9e7ff7b410afa777ee08f48aa805b60d3ea08995114d93f5aca2ec9e0387d48732f47b9ea59e5d3ca90d74b57b30084a97346ca9e871b93cf1d6b04c771626a742bb89b8a6cbb82c8b4c80c9d639aa1cef89d68903d2066d9ec9f242656af0db02adec5a1a327c0cfcb1f67c77a138a1ccd9b8cb057acbfbe6d08799eabaf6f3f9bea413615e2f78697d37ec0cb215f5e07f0e368db2dc0caff93c5d4e4179f616197485ea97984e113f9a1ae349a04c4f9e70f0936c12189e40eedb5a4982c46c8b203c4f4348b77b48b9efc916538f02d2432c4cbb888029e56fade33bd675ebf7fd89154df4304a652c5cb43e711d3a0a13f05861650c2ebf1826a8ed03977bc1a8f0dd2b25e630e185b0d06e4287c474a7e93244511e18440eea785639a7859f6da76d8a74c69e54dc295276969327d75d1b4e38f767f5945a1854c35decb63cb32ca230671321f3d555d9255eff8b37e68433fa70631c10286aaab86718da3b9487ca4cb49da90e892f71483c19d595d647d90e65b2ab2aa89585469e28241344e0e06d38d9c8caf0157dc639f1f8522ff49e49de5fbed630b8196a5a825a7a6111d1668be2a68b959f9abc2150ec562d8e482c6fccf6ca6f1de46cc7c04b2e2cb99dca1fe6aa8db0313363e4e1bed7712f7651c764e5ac2d137b8c44af907eba504862efbaf26f301125ffd866c965af8a0282657194c5a77935aaef7c5cd20223d247c415341ebcaffb4a3b99fb96eb57b4b9f50c61db4447eee2ecb5cd6909675f8b8ff68c19c95c9c0298b81d032770957a7aa9c096440516a1f78b1a55836927ef9579f5ca9986c96eaf7871fa646afb08f1eed891c21b9484e9121d2e1c1ffecf35bd0372cba64c9d2339fd79f36f52fe49b9c51013bfdba3176c65a8dc5bcf3c85ecbb8e61c7a54968b6ac1df33efeec6da3263428a46ba436569ae310fb2706b2a55d67fc4a89a56581ecde9ca80271322d93df3ab4b4159154c4108b006b78c7cd4532697eae7d8ed5f520cf6d31d9a4467205db07b577d26cbdcd05502b09c0c6a396f847215a19b926ac43f95bf34e7c41a5ecf8a8234a034cf975c8d2e6218935aa06dd787d811c79f6c7c975b93708e862c133534da7bbd52b6c24979e5d551b31f63871cce7a75db6f21656ccf13e1365bea39853ae5f80fbf053248583c44243159677992c3e3ee9449f6ac751dc46edbd4a9a1b6abc65dbc9c4b512224d766ca6cbb8a18e99dc65dbfd45ace086c93c3ad95d1777ee9017039c360a634de61c756e500bb05df9ea82333a3f5425261a702dd6d17b5544d1c2650600819d14bdd4e7c107b729a95d767b349eea303b5572ef9f5784230e15dbdb7eefa9e1375deeeadfba032d722f2da84e44d0724e319fbbb31b7e8d211948608a804323a39cc1b2306bdff2aa656b234799e845cf87fe3c026dcac6c9ef921ac569810ef8fe3ea9830693fd6ac7cfc8129fbaa9a39e9fbb43979b0ac24f51b3ad56703d45ced0b7312792d630debd75eee682b2e765efdf4c62937dc76c80c2ec30cbec7d037c0f85104eeefd45b29af8ee31c0f8fdb8f495158b665baac694f6df738824da144de7a0cd8b50a61e6f2a3544a910c7baf87b8a3d1a43b1d483d3805ce2bf1b5e6d6efaecba8368b6c5b3dcbd371e54e20a3751376fd236af94724ba2dc5fe05acb4d9c312a749ee80ca71a3cd9a74198582fe333f792a2fded4c7a2b827d7ed5a6e715bdf0c776fec8bc9d80030a068d38eb45be434101a3df0e1cf837b31567026fab5fca9eef25bfb4e08792a605947c6a804fd247a44db6f8da48ce2229a8d3e403cb83052cc03e2ec0fbf8987655ae53d16d70bee38f32c956dd3cd3282df008ab1d4ccee7077ca103bb6f3edf91092c03453df222b7ff58b01e676157e8bc72ee56b05c4e6c51eafe61209e2ce2b218147bf4239fffdaef35db63732b4178c6ed7eff03ff78c3e972d879599fc9f94d69839c9665ab95baeb339d88e8006818d4682e451704e851f4b47dd4f64902464497ffba50f46223a31724b3c60bc553dfa3ece0461f7eeb21653005f07f761869c22642a793d84b7af8f8cde52c464bcab47124a7d9c4c6d1af5b83dacae862230a411681dab7f376ebe41bad7913265c0b5488251c082bec591b0cbfb33c967f3c532cb3ac1030c419af3d0d6a58654c7f6484d6c8b86ce82d74d0af5dcc2ef09459d5e6dad8fc5d4dc21a8dda56ff901b2d4efac5a0688d0ba81a7f67e69473db9f311b36db731e84e038a6eacbb1c547c0fbedbbd6632750b781cb941a78a277d1bc62b35068b5ac2f8422d9376ec137699174f38fd741f85176aed0de65ea5a76e623758f8bbf5073d2418d77e8835c07118843c6865d42ce32f72b90f905843e238c4e5e40ee56fa337411741f894f50eeaa97ab37b52faffc64aa9abe407462eb124aacf2e95b1bfba9f67685c7d1ede938d6d726c2601e8e116cb372b4dabd2483ea8f8cd966d5823fcf4ac061843c7f5d0b2225d94eb7f4c4e5084b9e5fbc976c2dd5ceba6f7294863beb34343304b65c46bec465aee2d4a383eace16ff78de66bf73d9d03de7184a9489603802027a6b8df6ef9e0096adf185af963095fc29224486f6d6d9287db3e6cb15fa103e6d202e19f57b62fdaebe9353e6f623a4cf9a6769dc4f092049c637ddde455f4408ea63edd4814a7d2311b30b94c69a8431d6b11fe83264a5ce5a11965e73fba3141a3016d719677ba06b105b9071b4cc8d89867cd800245b643c44417accb57d9a1947e3f44fadbcde0b49c889e832f3d8d95ccd5c56fb9365e012a2c615eaec7619ecf6c33d3092ce77a53b6d8d3020ce0245bfa07329c7ae0c8625ecd4735dacf038a08d90c1159490ab257c24dfa049de468fcb5ab26d01889b661636c1c5f32716680969cb777d5ab20685e0feee4d809888ea1b058d8e7473274c766799339c646b752d083cf4cabc5b4f112e36439688e0e2fb35d39d613823da86a179fc136ff200dfd97e2b76246d090a1a10c80f3dfe6cf1e22933be1b9d87693828e12b8ef5df5d348d054f01adddc518e3cc838f4571b3d251636bd6d2e0f4648875e647f03d383094b74d9943325d49567e8148c2f965643dfdbcb3b56fe78b3ca502c4cc6e99d1807111e38d18207589003bc6291a3f4e3c779325486cdb4e030929467066ec47d9b9758d92f962494bf776c40da351d35add058b96ac67fde40e7ee26ff640ed991ec002c9312950a1dab902e1839909492cf34e113d9fa550e5bff296bff3954be8de7c2dbe6d8ac3c419947040fb7b9ec49315c7eb4d92669270de08ee6556bfca4d2628bcdb7fa4b673c2638211e8ce771d788dc781d535a1544450d8640dea8d9f50d1c3a95c5c36cfe87273e302f0e0780b70f7f8a5d9b83a0f8c5f0e21e0e61de8b2855476dd3be4494bf642ed1f7fa9d729df334bc31efca1eb8092237335310eb7c9847a0bd9803710fbea22021c183c33075d13f7dbe94df33c1b54f397efa7b0d0dec85231f153f3d7a0ab5d212e73519e78509fe26aefbfa37387e1a14989fd03c5c55cb2d3ddf04461f8c73269f2d102781b21f27dd2b8bc6d2a4c93603d3f9c7260aa8c30049b7d2b43407ce4b9258139c5788f79a96d4f68d8ac8813a640c1ade1e0bc0998d788e2d06a276f7e96d11cbd7a4c96b61490fda883049b5d0632fc9870dc780d346481e704a8e3c2aa7ebc2900ecff05c7f3aacebfd0aac1c6dc9e8a39c482dc1678cff42d6d0b63a8dbe69709dd00a179db5611e4cf401f0774dfcb2749540b0b7edda2ae1947723618a1e7dd07fa6bd42804361d5d086cfe7e41bf80cec1b880fafbe8a669d1ff11ea9912a05c20c65c54918e351576e9e5f742c8716a73f07fb51d5778b5166f90a7337ebc811a5916fd7fc98b9e5a48b3ab3e0f6bdbab3737f948ae9a451b9aaba13947afa137b53ce768e2570bc0b43fb6dd7447b6b13f2dead095eedbdf4e3024cad44e2bfc013cdfa4c473ae4bac10f5b3f3ccbe4b0f2f073726b818b3f128601cdb9126413fb78a2e5831bda8d5508c98eef5b3aefef76a67f444ef6fda78d6fe9e8f3037e970cbe32649006d0a3b20939bfa70a9ac5d44644ae00fa7549acd9876e5048b78f33bca2e23b2bc6d00bc545af0892cde54a4494c56e188c48e4ebb0a725988f1383d865d271b06162f7f663054359b6a7617c9f442e328ea9a613737f6d23f37dac5bfbdc45d953ead8765194b9d57b6748b2aa45a970651e4785803b6bf45c94cab6aed213b9225c383111ec18db5238caae1ca41354e4d9ac511808f73b6961d17980599aeb95569723339ae1f52eb8fdcf7bff3c8d3553fdb882bdb8267d14b465980829d4a6384d8a907a3f3dcaaa6cbb5599c0a37e12f8653289dc6db254663d565c12fd77a85769a8ad873727a0ff992b9f293d81237390c768cac953f0e51a5a7bbf2eb0fd3a63d2e84e1794458d539d41f0216ac14828d0ec27ebdcc6e72c0919fd46cc51a7684eb65ceeb54500ff30377de3ba458d569e6412d266396db977fa4e96994cf5caeb187ada6f5e3a1c65d2d7082335d8088125a8e04314def77e3b6c7e4d0209e77ebaddbf7165c6791ec1c7b7146a796492503e57560a86f98009e2e483fcfae494ce2c30e44a0a340bb5f8375a8b8f6863b5ad4164b376dd5342bed91e37d3eb7f0b3fc6f9b160c928406c0152f2bad89982bf74110730680e506e7ec1872fd52146a157d5146d021e8c94f59d4377f0e50a8da88d683ace6b1a79641f627f890428d7ec478684732e12555301f0fcfc0018a3ffcfb53a711610aec62aaa25ff93d5f970f4eb70f900f52af32abfe39b99c39e96d0e58093873b6007b45b9af86cd0ff6ad54d9c743dc19d9c027789fd15f6073fca4160d2f03e1a0568f44468fc70e45242dbdcb81f0fe20cca2129b8d1f33c9bfcc917193fc7f4b812457753e9fa3adbcf852671d453e3733ab9a05e7d57325c1dd1efa3317550bf7361f00ddc8da991b833a699a166477e8a37b03ed64d1323e2b43ea5ee7b337735e54ad31e8c2d37d9e8653a6dfe939bbf72e65ff02429c89fc350f606fd5e078216b3a7276db7af5a0307a0de05403bc94c0a70a275da2ad61c3722291937b7a39204db2fd4bc75ecf389fd58b0a1fbe8fae508c9aae9abd00f801570acced67096f654212bf4acb36db7a6f37715991a5c594b79e09ae70e6a6293350f22d823a747d875c27917634a341fb77c26228040dfd2c99e47068cd264d3b5b68016cbb68b97a5e017371ade4aa68eaea47af0261ac312fc4e12aec01e7fe487e96633ba5d521ed5f4d78c1c3acf9b198c1cc17551642d0cb4af67a6916134bdc9c51ab74cc8e071e6da5ee1594d2c8b675f1322ef9a09f45fc7a9043627502d7c2c13ab8d24f03fff94f530c240942f643bf792c7e0f71f6b31bee08aa6f56bf69e0d2b21de8a096ad0707444cc290786b42c98c5440a3c8531d3b7d6756beee7ef9b15e5ab8ad989cf05dacf1e389da3afa124e3ea3e3673efc3c743628917f1194e112c27e9600a754b8e5e78fd0c4802ee89f94c7afb776247a01276306d77894637988f60b01f854b4580035c830327745bc8f8ef523a227c847b41032b59ff5f4744396b91d9213d471d32afbed907c4f0c7fb2b33a6223c8defb7656f504b0260e64c0bcea6bf80797ce5bc9566108809db7b7914e777b807903128fab11545ef03be4e43873596d4cd6feb573380750d442aa2a864e3d08347c35035cb21e34b8a3feda56607b60b203511d9bbf3d093aa91bf33c7209feecb29469ad4ca67492aa4b24a036c5fd79dbfc1e8475f85c477a936b37a6732a53375581433438fe6ece65ade59f5170e3fedd2e38cf8ffc31b2149a247a6f55f7b89c877a6c6c49c6f8ed42060f5bed157f3059c4446d1a5791a06cb8f3cb55fc483b8ea90996ad7536a884d937a08e16c4eba8ebc064c28497dc0cb630ad0b830f8eda4f63c74db58c7706eae759eacca8c6eb0f921cb7e497788bb9f66c45c8e8971a7a86173e4cd316de5c1937c1a12a91d3c2d8ae945da250b9536889e122b38f5fba0f98137c62d8b86f6f536c4dae96451b11fc4524f12474dc12209a3e9f239f1616c0653fe3efd1d11c346f1ca002960272165587a369adee26ed6504163829fdad16361bc9d04a10b979fe8d40968c49b431ce06d726b392495298dcd253be1fbe0580c25595e143a35c5dd599559974c60c6a87bc98a472a47303f942f0e1682ae9b8bbe2d6df07743fd0aba3406567ab758ca0bd1ee92c091d01db7d6d86dd277d07f7bbff11881b93cfb62b1e28cf4554e15793d5592140c04e23516bc379898858d4c133939354b57fce9a336244bdccaa15bc9f7f2b986104405744ec21aa514de697ea6969e9babd60ec05e5aa4214f0c75b5e52d359c03dc7f4801a016781c4d4048d83c98d4b5dfd67891ffaf40b4b205a46d86c60d654195f07087e04a5dde949ec4eac454a42ce3669a210cc684162137bf7c03181f1b43b12e49b3f97a1f751ca67cdd200bc35ac6f778d4fcf58c3d9fcdd1e74cd6f7c850fb126e76792af6c34d918e0d74b197b6a5a306fba8ddf819c34fb81f52232c19f83d4e8ca30700aabdb2356dd65ba90fc6c765eb9e8ddbb5f79421f2b53c376b4ab350f4895dbab25837f24c6f234410f17a9db5068c673a910c0ea348aa4a882f5ec9660ecaee0b360b1d33ab09c44d2310cc5a6dc058a8cdcb84cb7261b8c5ee28d176dc509c15ebbbd95bb04d4d2341a4fae8dd5972066e50adfd6a0d8460116eb444c360a4055bfd6b98f0915651b8180d80553def0fbb1847550a2bdb80e670827f21d26d6bbeaebb6c9a092a98cdee9f5cab5bff1227a5c1551bd40b7af2d5a2e53d97b900a2f69b773b231f2074c2500cfa9f2af48fb1f8d7299a510599259a4457eddae41850665a7f2ef6584049fe8659c799f7b27d3f4f4a8c24a13365eb5b3de044fc8f5d9a5a157f295b90c5e6ef05a97d7f2338139cd38b3b537036db297710e2418af674b28a0d755eb0e643340983608e9eaf341a895fd40439afaf4d698382d1593b87a3f740ee1589251d477eadb096ba807cb8d3ec808cf5ad882974afbdc0df34932c174f1e94404cec9e14d7d2a2fbe7d6104e4e7741bba0ce1e2bbaf6249b6456b9f7780bf531fc163ba12485c869f71f815bd4139589039422498a7c9205241ec111d266cb72fffa37f2a0138ba064017045c0240296b6a858e464bd0b053bd2ce9904e531dbd63a64f247f73d482c4ded0e5582699696c2865bad98a30d500691f17961d3df0532fb9049922dddfcef2b0fd4ba594628b356e28f9368bf816da9a456fd5a9fe141f83761d4545a4acd17fb48fceb54fe5452469506dbf2d0ce6acccdc348bd3e52ab91be2e45eb459b09e313d136a55574b1c1425cffc299e2ebde97c482a057a45c0fec4f2fdf00a3a7ed13d288cd91f5413e36928359b6ea3279af07286c15e9e704bd21d75d649e9b1d186af6b52f5dfdd24e744afef0c944cf4076d2cb8f07758846a0b8729e22ecefc4e33064ee9423401065da6089d0a8e4a530579403932b98018dc432acfc0277f5802b768395952f268c4a41c3bed0f898b9a6ea5c0ac42f0e1725142fa4601ec5703ad7b0ddc6559855ae721b95a2021d6a5bce2aaf2f691ba3f6fd5eb9f811d250a1fca059426ef0e8d062309baf032fba2bb2544bf8f0db1722f8c187bde79680fab576287272002ee8aa8f611cc94c6ff527eddeb707919f8e8c5a77dfade49f87df2fb7cdf7866e1c0f19f4be883e407494d81df483de1d92e72800a30193ccb9e80723cbbfeb06d5a180189fab78cc1de770614b02bc4c7cc5b805c042796e50af26ce0b45cf654e56863eeaf4aa061f89f85d172c9b32b271a2132aef0633c43a60e2e703510930f59ed828a38f437689977b8f65c410d32ca76c0aa1764ea6fa94456f95982e44b2c3be2fbdeb4e7c2b98fc8f0fdc04b6f2698abbc4d84c62af5c971c22783e1ed9804ca141a18fefb3b5e8370832f4645fef912a18f66c7b05041a3041a0e81243ad0c04a85036eedadd51ba4615d5a2933197ed23bd8d3edbc5b3b2a02b5b6be2245777a07b07d7c45bea399b72819a2b83c541891f83be9c7153511572e308c50497784c0839def82bf091f7a79c3a52715d336e5dd74ae3fd5b56a151f0a87d498a24289a6610e07da4a5034ccfb8df430cad820b141bc1d13b1f2e6a3709254ab5dbe54a40b5282edee296dbf4370cbf720b4190af63bc0f6b4edcc58927ebdddacb52bb15b4d717897c3d9e51cbdeaedcd2dd9bcd252c3386f3a497d674ff0125bc527807650f1b70dd04e9ae318081cb7c757de865dcc6d8baffeb5679dcf8ea5645ee609e0d511495dbdaac7841e4319b1e4d54093b38b1d74cecc83d5e9a7da3cc7608384f5867c6de15ad51019bf10ce49ba19eed276a5156d1bc4a9dcda74d9dd85018c8b951b489959b894176caf9c0c2852a32d3d1b509e0910a17a699a6bac823db9c4ccd7086555f4393321339b234a8bb29a667a4e21f5b08ea6c8d9c8f6683b77c668996c8603ce6d2a0dd9429e3556bd3b6e5ee48735fb587c1a0dde778bf30ed74fc60eab0dcc3d8d136ceabe53c6374838587b891658546168dbf5bcba784858bd90d8b2746f39c54d716ae487d72f4108d70f3d5d7b90736d9d5b20bffc12f77964fb068c66d5694298f2d0a806e1a5f44e40fd0441f593dc2f1f313468ab295a9edd19038a6370c3512d16f204d20be3db775a6943b3fd8bc92e7ca9d6c0aff5fd6701514813d6a04977ce3ad259c211b1c5db791ac72f2cbecc4618c65ab726fcf8cdaf9d3b07fb3d335ad40a589be86e747d0b69d5460880b317161880780b60356578caf748ba4fb027d377542e2729a5628359d0506c2a683762257093a7564939c293d5a757c74f2e1bb4feddb98276af91d616cc635a5425080bc0c863f71f2869e5904d49db0ca2dd1c630f1f28715f769da31cf1b4d419089b5d6e1c22d1f85c45bb16ffb7ef17db5877fc580f71b3975a8d730cb888ab8cddcab375d65e53d6a8bb23fa5662732619de134338268456cb4536aa136906d3ff63693d0eff14225a75e6a541f9a703a5a44b1fe0020cc3a9812ceff23e581370d8d467bfc945f613ca75b4c4e7ca19d1c32e34147a647d4b7fac8c7b09a2164480dbeab6071d15c5347f726f248901c63d37023aab57c16d97bda04f8cb706f3a1c6ed4279581db04e9547e22bc74c0740fc591f4bb186a8dc32dafbe5adf9668d2470012cadbeb418d798ba668ff06b6251e8ae9d220b4c89514b08624dc26b2ba09159eecf53fa301f29acdc5d375709d15eaec8f8a36c7d9ddd9faafb5a5c63fbe5687fcb89856df0981e739de07212a89da289f2fe105ee4c36c66c87df137f609e18d6382fbea79a6e4cbdfe7193858d348608a8b25760c5be16b6791f344adb652a88448759cc1edc98b1156f931664880bc678f55a68cc0a93ca43bcab917438c0f342fd38a7e88f7b4eeb2b3dcae7c17240276b8b8f9b75bcda93c120b31c6a994fdee56b86a19409fdc7dcc67b138c841a81c71da676af00bdc20c92664287fb05ad3c22058f3aade0441a878ac569b9d6e04d9507a68352eebf17b6ff517ed67e150900df4d6e936a49559e73b5ea02c7f819ba07371284cbbce303fbd2e72228ed4e6be4fd4d0e09e2f303d7abb8235f04f9fee16d690024fd82c6734edf3752f2eb382ee5943693536df5ae2b7a11f6b57330ee181957ba30a222390004b8ea84724b413162540049d24b3485f9b8cf88a00f318689c8d49714450a61bd003bada2ec99f79ee28071242ade3a62615f89f249ff794aed13784a3765cdf2f53695b61e45b3f2c4c81f4bc9b5f635106cbd412b9c459ee778c3030fa69a6704de6aaf78511244baa9f363509d1bf8706574b83afa0c337f382e37547f82175887f559f7200f825594055984cdff60ee5ee9fc92d30e1739ee1bb310ccd11b2c571fb247ad10b1d3a945de3b8f66f53f8a12dd38bb8c30ed1425ada2a61e1d0297cdeb818dc2737c7aeed4feb6cfac5d4745d080a98d18e047c10334c55dbf7fa6913c9f6ce9a64ac3ae0a642aeb1d22ce57ab6accb0d27a5415eb802480365e3f0dccd2fd74d6d81c6b7fad502ff927afd11404796845e87bd7229505b7d06cffadecbe4ea97158307f504c1c2a363416e6440a9c2e230a697c573b07edab307fbb2b0bd22d68a907d71361e3f39cbf322874c4ba121a74a6ac4c1533a6099c39d2c4579503fb53ab5dd94829e792297ce70066f5f4d3147bbf0ad6c02b86c44aa07500dbb1007a15e53ea412193d18d46cc6fa6ae9366aa70a6961adf66965c5d6453156bf5a76227ebbd3b281f4bb20fba00522c8aae292fab89fd0ae8db0817dcd8efbd8f3438f0a126a723545eb8722cf2adc45606e931628a7eaf0bbba85bb704da479b2347fe5ea1fed7b9ea6c6ebcb83215827d568630ab8f6e9f2570a30f51de99fb8e7b06e1c3afa09a73d46d40d5b25e8d3c4b62c59f6359d5296e98fdbedce51b8dbb106ba92ed837796ba3b699627e6eec9361d6210d5d847eff5ccbd223ca686ab9177a605de86ad6748cceaca465ebf20171c0f7816298c40accb511db71d8e3375b9cc8e8af4c3bd21d40a3fc6df11cecc8aa7ab18a2fb8decb39b722e0799921d68e20976531b452393ffabf6bff0dcfb959869012a6ce68b86ea7dfbec2807a6222d57899ee51a623830b91387e90727cb06c15fd3f289eff22d9815aa2358fc02a6f42c1d8f17025154fd4a29b68505dd050d32c06cef28dcac38261e120c6478d51e3e18b3157e6ca27ded1adf11a68116c3a94e4aeaec53b76b73aad0134846c06c3cb198305997d967cc5dd20efbd88ffcf2fa949e549173fde8244c490dd26958e3231da31a4bc7d2a8265b6dd4e61b187a3ccd20c6024d08f68666bebc90af90038e0ea2552bc41f03baf8f456c5fe085a2aee249147fcc6b398b48a227e1866adf511fab7d14a061a41a957dc163e435bb37654c9279f19050322edb817324566c5e1c1191b37092135008a4c9e09ccefcabd9066489895ca6965ff049467168208bbfb542fd72e045c4bb806d03b2f12fcd43844db2c455b1e9b3fb5907a0eb8730b6c766863d069eddb5b1eaeb27b88fdb258441a395670679b4c5a282c0103ec3a5978a4926a71514e7045a3344e027b4f77b1b3103705fa8ecaeaebdad051d13c320bc000cb3ddef622083fb223d888f242d678c0f804226c33a4ce4d3d14ab1d6827f50b542b8ca28a6d9795b70a041dad030280d34d96c55b1333ba41d79dcd560e93c66bb2161c8e737c0c922742c8b78fddedfe38fafba1a0a8cff23e10c5c6ceb9830212de90b6d759c0c8307ebace9e3accd1f2130e69149d7e44e544106ba1ff89a729f0e594eb28d14d4a311f24e39687c18564e19b73f20c24c234c906e107c12519c448e5b5c0edee944ce51769b66d15436959c77fe9bee4b2f448211625d33172aae533e25d56b71763d72a0ba5f01d02fa48bd9dcfc52b21f50d114c51cf4231584e65ad0228542f01438bfb9e65789cd494b3fd025b9cd8517f25ddf9d2a967795d552481e550f842cc90e3bb6419e48d991b20aee953ce5967264a01abcc22ea590ef6e11bfb4cad279b5ecea570b19e57edd8d311c184cbb909599b57ac260e856da06f44067acf48e0c8d007bdeab1a397c8e06f09f46abc94bd2a6287801136ad55d2e267214b1ac83542f5794578958cce33cbf1ab6369b8f34b0128ac2c0d31b0c07eff7ad4df8f9dba950042bc97bf26ff158f8382b916e6f6d9f0ee8202d01ec818de537474a35ae0b78b82dc514f0876c3ec53f3b43ba00cbef4b5cb70763d179e19f981031f93fdce5bff411369ee2d53b2bc9cc4dd47b0c2e09c8677339b7b06eb992cbc31e5305980f0c8843fef91bda5ddf0e9832af17ea68a63891004c4588cc9a7a55f785a7c9564a1eebb2fdb3d31ff0a037a137bda95a41756a13377d60842713432c5ff358732061fbb8e89dbe6bdf4fa58af5fbba303140db63eb13c7417c90ac32e1cb451aff3024305b15bdf2f38490c9baa0962221658d527c96f08ea61087cd6b725342f8a7256bd1b8b7df4aa15858f873ec93b1a451b196010e3607f86ddfdf3cc7f99c8aced10c17372ab81","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
