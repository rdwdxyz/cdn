<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d9eb056953cad04b8215f94b52b40af4266584801dbfc8d01ace0095f57bd9ff21211e9edb6897a9ca6722bd7e6263a8e4c72a6c9d6b3398351e597f8779115584efad741d19e717af93f12481ca5ad1d6b1abe47aabf805ff473a654038d584a04093e6a89a924ce6898517b45bf5b1eddfb657aafa6452deee7910e916f7b4b2c8b36555c8fca4b830e442d22bac3bbc459655fc044c747832494dcae2059e505db9d0c1827fb380cf8ae5bbb777b634778a00f7984490be5199775e2b90bcaecbf3ebba7136a3c33955edc24ba7ac27755cf8179c73f05c5dd7398ee5d99f103824affe20a21c51f9978528a6b2523957a24e9911f1f9a00cd519cd29eb7588164ad465c9c7de2e94f1293d2cb63950a48b3b8307e755213f643eb2bda07d9aea5db02aeb4fb3912edcfe1a97d7ce9f7d647d4db86a7009f2fef482e775771dcee5dc81ae6c7077f5caf111a0b019539dd2f34ccb482f153b5b8c66e094a5da622f94c795760fbbac04b49aee564c5b3492e0d3c75521a866d326c3b2386612a1c056981b9e8184cea37e7535c547c096c3e8145bc263f5e9a4dc9b1c838f252ff3800820b6cbe012cb63f79141844bcffe916840d2cecfe8996ae9605e0309328ed638d72ec07734a9100b5d033a5ae9b5c6c3b1b8048ec44f82fcfe61aa5607e2824d0a66fc5214b478a5b3af0c4c29dbb6f0135782ff1270372d35fcecd5ccc55f7ef993bed513b2e04f4886ec3620800f65352df22e3c165c674377400e7499cdbc814e2e33cc915bb50800ed9b1fb294557e353e15872987efa40010d3b5d8e0701d6c828deafce5d93788d5acda3dbee81a4338d86cdb498da83f6ba4cd8ec9e414ccd08f7faab3f9dc108ffa67395a296b4dec56be44a738e8dd0b11f44fe5a5a8ef61e01c3e55223cd05ff914f842edfde442815e2e6def9ab22b51d030d3bf14c962aafcfb5d37bc7918fb04bbc71019841e4261f474f40093e66c8053752c0bb44fbe14aef78ce8537c413208ef042df3e1a778576efa66d56ee461934c388902eeb618aedc4e4c8fcc0b5307fa956cddbff49feb95f9b04df71b8fa7ffa5c5860dca53807c68d27f7e412ac0672cb3410e9838513d0e3edb38e43040f245e036b57b1d060ba3850eb929145003eec3875873f58eda821cfdaa3d073fddac53bab9c2e0a24b0dc28eceb786ab0b3ce6fdca737300547734411c5335b489696d4e5eb67199f247aa7c096978d3c2ee31e03dc321b7484908ea9a907d139c702d9cc7f1c854ccbf866cf21d3b59ff37aa407f6d12064a4cb222a957fc84fa74c645a4f901788bfd43cebd03054cb4719287642990ed68d17996edc7cfc169804dedf1e5a080d0215771a0291ead39af2ae59af7c684d0e9d0f1c395907c74d05d7d3a08c0f311c638df1cbc4751dd1332e946cbf058a7fd4f62b526083cd654a28c1597880f6f4bcb2277c52817010d23fa3db708674db92fdbe6bef661f7ebc4d9166aa584e765c9ce654aaae28346b47daf27edf3a768410519edaf5ee7290551030b549d04cc57d2c83aad140f702d16e6ba1471ac26daf24a28c7cc1a9e6579d4fed470b4e8ea563bd448d376120304284369ce2bd4f810d00b1458a3164f09ddb8d4c60005e7de33f96955c70728825745fe2ab700399ec9d9aed06c864ad1cd0a4187962c3e0e9f9841f3ff8efb8cd7fe792f0db96f79cf5880d614249877530c8d2f44d8335e67dd19e6272cfbcc1086f1f85eb54760c6338006a50ecdf25486a0882bda7c5fc2d56a506d0f8ec822f5b1f9d6bd7c94517e7651cd60eb53c8f980d9586443da7d5977b4c36817e146d6882066bb8ad39d5721da4cc0443a8ffa15fe12cbc0f651028f9bda8f603221bb8bc26484b7736b55d2db29c71c187b30a5b0454f0ad3154631c9c22fdbafcf1d26a39d676588299f795ff3d60b96d0264889987b7869f6b6cd63615512a4930e134184d01affaf574333d3ff99bda5558a222f6ea6c1500d6afcfd725f5c6d58d9875bdca2dc386dccc52ae72276e744985ae56adb2cde0fdc10d9dc016c337ee167482ab817458578a942688f76a67b58cb8b6879add3c67966b94b9b8c91d5fa7dfd5009431f2563aa6806f55b818ac5a7f15cc47cb10143795602c1a621c8ccda210ae82daba3aab239cc2319705426e0e7bd080d5915669b26d7e405e84e6c9ba32f3826f05b3469db213e7356c9129ae191ea030bb34c16a6f73158026a0b67787136f7333edfb7b29ab7d9e96c6310133b9a00b710148c4465de5eb0cccd69f005d5b5c0f30d5f8300b5f833beeaadaa597614b27e032d8bad0fd5f072482e9c5e1159ef2f17972b4615706bc8c6e2688ead7722acbbf031113966ea402ddbfb4846427e2e7560ad546f1f550fae9fa95553389a5fbcde28573003dfa8410162a4928a3c4eb0c41789cd5172847894d2d902d286b62497d7050bac523c0f11d0810ff3c0820403ecbeaf099306af166ad4e65391a47193e661e6fb73772bc32b272810d4c4740b7c78ba00da6a7fa8b21bd23665ca8eec89ed434972bef475e03ba4b5768a11110d57221af290ab0b9596fdb42daad430421f23a7455e86ff68faa777cf0f2fef9e3dd009ba6c7ac9c3ff317f4d19a793bd0ada446016d971050a506d867f691b65e50bd9701aa0b7ab8111da57ae5b3c250e2cb01a9440447d2292950b0cfeb20c2217d2f75ffe61199affa2da906d18dd1ba491054ab62d4d6252b9f188e7a7f53e4b5e1b1cc0b5c274acaa93e8d7049dc2f6517a2da44fb11cd57c34e76e4bed024d482c8970f7b84f03b335b658e34ce6e700c5dc3bfb563309ec17f2c38713ac13aee982b91ae7bed1160e21fd26f4136c967d567a1417a367bbb1b43753de51bdaf9cfb545fe65125398227e09aa52210e1e827c512305a0b17a99fc994b4e1f4193cf2eda664901a1ff6bf21507f889634dfd10335de7e50aae97890585b8d37901770968a37b142f65c7136583fa8493771d14da6d240cf6a7de7a89f2f0edaca5f2bde91f1fe859d9c8f5f709441fc3a5f657402e3c83e1489b5b384c700cbf66ab1235fee59a664766c3a809dcac1191731f4a574c64d53a79d7705b929093f446e72e49cb18b8c97c8da097fe964d423148ea09a607ff6fcb2f163ce6368daab50c23e84103432a75cd3665eef0a7cc333a90710c82fed4484ee432b5f3602a7a22f71a87797850ac3687cc85720cf3b59ccbeb6ee39bd787f3ef13340d7291fa224bb7223a1d82f9a5bb95e2422aca3f267cb21a80c67fedb53e37fbba1c77387459112e0016f8384417ac1eb28a2dfb0a015e47a41e254ffa7def23774a2e85a0b8648dc09269b4e6a45a285408c28b9c4e76b914a91ca9fbaa6295888b3826d5903b5849b6c477d6f7f8b7faa2a4162ed9624c8f630a8a45b018e91888d169b906e4fa1697ba5f5d543184c20a73012aca440b76dc53097f0f43333509e976e53f76e4ae5903cc946c3f77aa1e8a02922c1a14be721fdfb8ad020e45dfaea9bfa202d1fb93b36052489b19e529d18c65cdb46e6f25a69e528754346c6e186c6e6a85a5ad0904011a05ba71adf0e88d1d6a23af192f59ba37bae6396ccb4b03f1de4dc63b488964a8cc83115590efa2c83abefc628b25ea409456ee03079cc7280d750d7c64dd47fca7156c81616909f5db9bab096608d02a38130f6a8d4a7924a27518370ec4ea95e1959e005f25e586b300f44c824b172afa9320ccdb39998b824174a61e4f6eaae2d8e68c66299cd1acb5e40d2c3d3a0e906d13eff246ded6287c55df4c2d42de3e2d3a750305382c395e31d7317dab32828635b043084d93dcb235be5d01bfd431033eb40b7b0eb07f965b24d60b50e4538f6afc0f50ecad06b08048fe58319f70bb504ab25c23ee42040ff2170db4feaa1eaa4ab8a13d9cb4b73e9ad3e0905d324a103c323a697fe463b27af78985fe27fe75ef340f8eb6b34a4bc1f5e518570c75323cb8915c8449bb203219a8d15f0d4d7fd3bf1da07c3ac6429ff21458b52b916a3b135d2a485327d8c5b05d890c8f204eab53ada67ed82cde763c5d330160c2a656d7fb88cf73036fa54fe78138528cf8575e0bdc1c7e7687e5a8214d8b11f45ebbdd2d42b925d43f646ec79ebb94dbc2ccb1d80f9f526d58e123b893100d6d2fb92e99349986d0b3083daa6e93a057b53d6bf7807c298d5b918c8863bc09fb027121ce6fd32aa1170d52174f501d2d6ac0606705c1078073e22c84062115237867affe1c883ed289dd7483934b6215a2ba8eda1ae875e24aefa44a2d7b9d4f435f4d701c25f475305bb3e1b69e206a5af58bdd2c80149105898c7dc2848c098f03254768664a2063df3e6fcb291d226c6ef9c93e0a4085670a119cde4d1ad9eb4f987fb00f31224c32d3f54aca0c57bccfb9fa504633ea63f1929783a713f2a6eaec3b436a6fdb33c224a38e270f7504610c9ad948435683703351228104449a6176913ee926602489d8feec7aaa64bdb8710eb4b5fbe5c15a0b1c1a3ad6cb91c145370ed70bb07db4291d34430bc7214e99f3d5c69fe41773c9df202fc9a9dfe9f8403162c249e581ebd79c5b782f8e40e39e18216585c247943f2bc2cbc24575954464fa3292666cfe192e365ff4f92d15d56940ad6ed5c8ffd36b0ff520228f84a7683b93b464be885ba4984ff9a65ec1da6af03f3927bf23496a4ac05f178cdfeb6b61648f43d4a74ae145122f9444fc2219a69306ee7394dc5726e886884334d2211aed4da2d9f8db13c9237d9926aff4b4516c5201a161acf743161086546d041c5b026a4fdcc4c0bdffbfc12a0ba2eb693e4cfa9e496b05c1fca4d3126a64e61de9d391089704c12fdf8065e38035d16dcd27c4e39e5d775555b914f05a9807eeb1a9341afe6a41f451537f77a78382f096e43ce413f1b46fd323a8013e5c5c958a8ed7384988adbe139a1755870fb161bac8060d583019713d31464169109631f939687b2c221b43013d863c3d41e7640b4f521c964e56f7eec51328da4b1b204224ca98834a8772351709bca143e763ec7dae86e586c426788450efd2d306f1ceffde8fa1d815d9c5499a29a8c817a589c3e2e7fe92e3cca1132b503d2e071a6077519312f37fd5c15966ccf53ae05f0c838db1c2c2c14e53f7aadc0090a01e5cc6d351525d9ed5591716533a16695ee9f4dbe470acc00ee7b71682ff7b238c3901c14c7291f87a2e80fee7995314ce1e939344fc3aa3b4f83b29c997a2a9a48e5bf8f0bc984d8b8f93bd9552f52b9b2ba97e93fba9b05fb5b5dfed7c087944ef68a91ec14b404925029d55f2fc67318290c7f49677a4e07bb3974288e8117a600de379b70bae125cb94d011156d4b7c9fbc9eb88096d7bc2248255d420dd26f7e4cfe5d225b092310f17daf7f050fdbbd71cc84858d88a199bdf460d0dd6586edb04d706889846afd7ef95e3404aaeb9ef924b2e78b6431ffdc66d63e4ece5bac4ba514e1a19734e00c50cceb86e868bf56f1bcdb8aead5a4e4ad128b200cb9b76713368abe3a09224f6e4ae1ec79dbb42b47fab9e879fe05c6fd691f15e731498ff982b5a09b77dd293abf7d856690da2e07e3d6c446424dd0c981658793cb1f832b369c59be0613b2291a3c76997983a3946bbb07dd4c449e140eff7cdfed4b4e2a755e86868961b60d4044e1d96cb6e8fac7b6c156c9e46ac1e701e2fe999f844ce0a9cd07a9a58c2263ff54f4493cbbf81870555f9de54b01d44185ab662826fe937d46564f00e475e350dfee4733dc04bb73c4de910caddddfc2304bbb8c0e000d88c58786bb7f1aaa94a29842c24b572ef50464b5a5a9064ef2b0ca596f0238f289d1b4e5c97f38bf64d10ed80efeca53a2089d60d62d107bcd822406e41002856b3737d3a1a073501b89245a3cb9248945b9755b87e72a6b15fd3d29b68de8f65da4da3b4d9e72a2c20a55762d24db554aa91e868289a947075031cfec5aed687120980fc9f4accdb0adb89f9e0e6b1ce6862a6c97cabd12bb102841b044eeeb22e6aa5ff517cd5561e12f2f35ab9dc6f1505e7578eab42efd2403d31046cbb93b47512d5705e15819dad1f5732050371f63b9eb3e5499900813309175e741c77d9f2af413ffe9e532ee79402cc1f868a02aca4b58d25022d4aec68cc34bba71bcb600b2284ef61f7b56f8609a3fa3166f15024da4af50b724c616afa540de0fb26c3650cc31ab99df0ec01b39a3c39ade09e0a2e5d1df0ba7f20c941e085d4d8af64a76a7eafa9e698405ad785fb8b8388fb0e94be69aa55a7fd1bfa90113419d429f736e38db9dc40d226516b2ec601bb8b149ec7a88e3e6365c460bb06b89532c413bb02c6c5eeb997dbaa4f7251c67118b244e96c818478c46533e7b694fa2bcc53df1672efa84e44b2d76a15cf3a1e714ddcb3294972160c21fb098a369953f1978e069397ef6549f1442ed64c93cb297fcedef988eea0a1beefeed5e826638b7b2de9f5869e59f1abfce38581c03185973e8ff1c342d0db98e8feaba0d15042bdf77a3c33bc8289a80b855426d9480fd546fbbe01bf0a7253e0ad6fc0822e70747abb7561852c43a0c54031a9e3b34a0ab00f6557961b76c7a7f0e5973ae95a1d3bfda83ca7a3c55af506fadccc4ffb90716f46a33fe1789a992e5f4f25195ee024a875fa90db272a3502e3de6efb79918351adba1487b639f2e0443e7b0dc00d817935963dd5d7ba50a044c47e65a4519e80a285e6640a3ced1611ab182a5200c10f25080fbf4c28a4089977707150a5a2459f8202bf75e6c661092c258e56a09453ab64146e70eaab91d15280433cd69e64359d6d7716ce6045e645d48b0c5c4e01c1e61ba866aa33ac650879c7b0ae42dd2980cbef646d9887b1c0bb6327a07d8b36f435d0c238ef65b39f7380f2493a033bdc262d931cf158f01b0550dea6cf3037e61e7ed5df0bc2b191206624bd97d869bfe55189c3966802e03ddf77665b33520269663dfa8d8dd8486086b5abf66d62e95da12c448996e2ce0eb8bfe741442437a5fac8b56c68c231bc1455876c42399a7074fa12cca72354b60748e9e5410250306ae7d4ff10943523143ed354d7e5ca2b65ae8dec42540fbc5a99248a5503d557895f8826db817b59add87dde4273e1d7d8b645828448b80e8a46acc0963dbd4bf0cc7ef066bbf723914133cfa5ba5c2588f42053a495397f2226f80a73defbe9735f93821f623794bd30d7086938bba7dc1053f1ad2f6929c0bd99802e4d75ebea7b38be007e2e73264bd1072a95cfbae1b872b7b60d9870fc61d8e69c4487ac98436d1c5e05671da49ee534d6a2d6eec3940c6c0471638e939116818ed820225f2c5a1ae28041f420eec506ead4d2d30edab87c421b030e2ba8061ba7850fea5b9a7ecec27e3f00e2818da884680452e39b724c112f56a60cb8fade2d505adaa3f86f0bfb3150249d68a974997037564881193548a8bcf420f9ea715d75b297feab082b4ac1925b5af383080fcd962355e7ed7e839b32da19e77a5596a36888d7ed6f16d51c2a68fb5dc7889f2186cb0b0c69d94d59acb478d09b280f91b2f6b25996236acaee4f0305ae90550f2205ef9df36425c817410fec801ff21114ea5fd3c75a9c73eebfba7c3485bc97eea8c7c807741a4a988c3d2a5715317bce98aee14645422e6c2e2d6501e9f17adfc2179a431908106bdeb8802990dc9455c69fb1add3cb16a8e6ee3f88444b75ac834d078d71ba1dbcce332d879e27a7e522118ec34e9e820fe71ecb2b04833f9fb897d77f97e040285123dea462050cef67c4747f44e5fc6ae7b9345390169bd0f23d00ba28e453574113715211ae4a04e866f6c20920194ed8b1e6614a3cb07ff5c9e44d317e308946a7f8e65f3a8a6d3cc4d23cbcc2434f063b57eeecae8ef5906f8b0748cafd6a66c48f066860428088dd0b202762e176e5ebb3112481b0561e07028859996a530db5ca7379946d12abd8f27956403c561320c8eb72476cedee60a1e15a7838a10141f8f86fe323d1d5365febf08e0e6d90c5129e7540f8cacb50817a6d828cf2de757fe3f7fb56018ba6f2995df4085ad1ef5908b50bf492621b183225102ba39abba2c424d404c890bfbc3de6783a0699c76082c89c16d3af9b21053240ef1411ca9724fd92019293e3dcbcea812b4c2f05cda47561d1b9bb0ef59050675916f09c3779788f9eb7f83d435cc020f95520f409c78bd9b06eb9eb17ddacf336df12fca8e4f4f6f54d9ea50dfabecca26a82aaacc1e00189eb51a76e7bc06f9f29a07121bd63bb630f03ad946d4baf7e85f31dd9d542b2509c798826e6500078105bb38749265ffab3ceb123ca665bd517a780304cb6e89b8bcdf45f4667d746f88f6a820a1e9825f82bc4597e9346905e415c82e6a1df8b0f1715bfcfd586d3bd87801773badaa4f7b32d56c42b2c47178c1512d87d60970c65ba94ff400f5c6314b655e426407554463f835ff810516cac536ac5c177075c401160acd6558ee5b56ee7893e826f1897c19dbbb1e84d38b2cceae924f309a7cb0ed7df3e4d06cb54f0368a3ab1be3c2371c03414dec6e45058dc19440701c45a6179462f5437f09dbd805519dc4fb73650a5cf5e27467e0b476fd8154a141d45387b704acb6063a864f6749ca2fcee59bfc6bdf2c9c9ffef347273303227b02630982c6fac990ed5119ab4f08d11f61bf399a21783fdd11386e5fc8160059926bce9ad8f9177369c8ff71eea4e181845a2902470bbb6e80ea8b2d8837240f76b0ee4cb30e0fe1292a9ded3e2c9e2a156e22d15accf98f4cfb10e7d999bb2de2af808f38b55b8fce274fe56b88b809cfe744e4c276d74dbe57fd640f8582a742336604ad5c84661db2fe65d791284ea9b0d25cc455070d066a2e57bab3be6b88dbb1f6141f9861837d89c9b843731ccc9c8f4e5a490d1ba86b396a1e34037d9faa983bb1b11fa6636910aa8d02b916a0d88bd75b5870ba7c70bb311d7bca749f60e9d832115c1dbbc3012bea29833aec218df05d6b98be9930e29ebb6eb8e1f1c02eccbff574b85c8db99e25a6bcff13fcc052b67c1af701bbf869d279fc84ff80aa59e9b8bc19979041b2e3bf14e30d883a4a26a4704831869af9ec442e1046bcfcb9765faf7b85da5a6b8c60d21d24dce6f9cdc392454aed564ffc3a11001350c6c320ad58bc6dc09feae14c3f5bc350a22be2a845503a2d9b6c41b0b01be83c9281a97318e9d5e951009c8abc830d25fdd94cfaccb64cf68454bfc1a8d9125b27f7c95bcd04f33feb2fcc6d1863977ceb645c69ea6731a2da0feea1dd4a09659579d809ea379bae6fbbe3bbdacc9126ac299ea9f301de5dcfa3207bcf980802fc6e960ed6d91ce8227513771530dd9215a1517cb2676a0b1d12744489d765f89c5a5be5e7ac839da801450d4074717cb1fbf038bd8fc93166a0b4801a35b149d4237f48ecf035f6ae85e2afcb560910ab525b0a8dc7da6075e19190eab3ad6994ab241a4b0e79948962f785960f8629f498f016f1bda734e06f158216c1354eea9ad4a0231352a1a6f252d762ebf7cbfc4f00bded015af1d4cd3dbbe329ab0da55b4d66175029d4c1ae7cf8686006b5428138b0476e48aa50e026fcd6af18c9c87380e19bbb92941809716b154f7b8caec769ad54e895d4c1a5bd6aa7c5ccbbc100e57b734fa8c813e393aa7c15dadd31d8ed29047e35dbd6c3fff4dd2c6f4d45cfc10a20ac006b1d5d4127c6dfd70793247520ddd45429c9e0130876bcaf031bbbb651432d4482fb62ca9ebbb970dc703a2227c6d64fc0b31d28f3ddc60a15944177a91d8d892321aff97cb832a811cf083687a3dd77a22768ad2f6fd0783bdd4a94e91eb824538f6a48e8cce2a0c77167d23aabd4244f381d244a532196f971f198e15c9a814f2b4c84892d22a8664f874637a34db3c8ed76c975254cb487137c0e8786ac84ee88d973da03698f3e60f6bb78767093c6d8d7f66d465e52dfbc78cd0e39a78926f523093ec01d110e799e7d961ef4a0507b94d4143c46987db084b56d0c00a07e558426817f14305679ba38fc514bb58e557fc9955512ff03b010003a43564682f9bf03bdbd4f8f95016d3f50183603bbf64c336282fef62ed1e87c79fdd33ebf91d8ea1b657df8c20c5b59562af95c4def7e6b2ee6aa120c1de95e90d64462e17a73be6340f4934ad03c3becb56f01caa1ae4a6b6a30168c2f42428088d3f26f4110ee398037adbf8a6682302a7805425f87c6d0ac546802c68d9494adad58f1457c0c0bc0a246ab4f5da80b19ca4885df71e76a08a8ba0b185c06266a612d374abc33f4e016bbf4e29a2095d196629fdce5895bc14fb66e8de51a92a16919209c659018997c943c69415906dcf0a8d86b029bf1156e9ea0c6af879f614ffb9b362128dfa57e6ce9aa0d5b90c1fed56d7b31181db7de1b055de1370c684aad7d86d1ae3bd3dce4c83b1bf1efd2aced38faf0ef79f756dbe7b4c9c40cf8988bc240a122d958c04297ce9935327583ecbeb86579146b8fcbeb19bf36728f8977a3528799a9a2bdc45cf0e2d438db2b0187d6f610260f215a495fb242fad62176e7cd92f4dbf2bd00c876d01f81ff706006e9ea889dca5cbe191981f6e6f75ee73ac59a80224bda0805359610d415af5d7901d36dec6d3de547708f9d1d8deb3490853380fdb6a14d91429eab43f3c31561953c46710c5be487a39549078e91ce1d4267a443c6994c68b9b43139d339d1575974eebee1a391a2c095a62a2a1391fb4852efeafe769cbe3e9eb15b20d78587c42fc8949900ad26a8c90d5167ab1e5276d90a0a4a88ee12e9514f6803cea9b9c927af3b20c8c0fe5e1b3f73194681bdf543a1640adf7eba9d91e42bd192b8740617dd12fde5a6a68dcab457cba4f68d8d634951b8b2d1a2afb06bcb4d4387df0748b693693fa91e205eeeaf088d845c016d3d81bacd58a53556db8280b10c9a3b00b2b6676409203e01a884ef758ca4c159c5703d9813542e31e392078aed4a2905c911b3ff9dbbf1f1649d8e05aade7fd2c21f9c00395c538ae64bcfbee8e51b5e7e41cdc432056db303ae7c2997e7db32adb7bf9d77a9a68c13dc6dcea74c5e9cf3969b8fc631fd9211678ba8640cfda06631cb7a93f000b85a29d3700576a7c5622964ea684bf6c1c805bae86a5ab1f7d366e8a1a6ee3d5e0c5741af2667b057eb630397fc9bff876c6a4f6a425fc8b2cad5eec3723403bd52e582ddd16c2066329cc5e502fbff2004a3d35e38fa4638ef625eea5e177da9ba564ebf5998fe56c183f960ac281d66b54e2a65d6538aff159e38bea0d591a03978e8661495c3e78eeebf632d02668051163620a57673129da46f0df98d5720aee02bf9a8d5d79c2ac915871715f3ff0e071146671e7f9a38f9a992e7c10b3e4804a8cf0855dec3474d0d54896b177dd04ba45e6d34663bc62d3f2383f0d5730d5731976fdcc5c152534e48ab73eb138e066d1bf53df3c4daef5d250203713bab20334e277674cf546d9e015541d9020a62fc2a40d8a975b85ad2aa4bc9f76327f313f870d1a88eff165aaffd248c0ee2c5689b266a7a550b58c175518a5748fe1ca7bd04b74c897e0852009659b493a142e8d63c9a3dc4151fa8ff0c144ed466558e94a71fdda050aa8d3a6e7e973c61fb51a903db814a25e4810e41289909bfb95aca602256987a8b019717434e72b2ddb769efdfd87c6ee0edf058ab55d2178a3d44733993b12b655426e197a811eb95beb55cb899ec448f485db5e8a32020bc80209c38e84505796ba0f7bc242d19d33718f861a320336ee3ac7512401c595d44b0af4303f7b899f511142cfd8ddee972bedc86f5c6b0c215bd9cd6c22192b596029172e0595230e77388d6c7be9f98e3669957b2a970e2863451350b97ba6683b3a3cd5dd4c2d71df065962f6bcafb1e2bc68254ff99cfd109a5f27a1d3d3cafa94ddc355a996d68a3b9d2e0728ca6588d2666666288dda82d13b6852ca24f82c2d5edb0e1a4f39ec1090260ebb29556b94e28643da3bb06391554a37714ce364ef0767b2b263d9ed2c31211720394955056d38fa9ce6e6bcb564fb39ac8a5e432a3806e88c8325a2daf9bf57e6855732d3aca03bc715de871e7d188ba59f40cf9405eca6f75a5611c3af86c9ceebc9cdfe49462e006ec342e4e4dc34c6c60f45d69b0775244fe2856bce03976537a103c06550076dcfd49d491063c7f0d9423b44ab7b3b2787b61b30ab5e0f4b0fe974862fe284f1cb1418840bc539d6dbe66d414ec38afc28e851e7ab73c150ad80bbdd09ce5d7d6c0e2cf6e0e7acc007185ccfe18f7821246c33f0fe9991c259e34ddf73ad22f4130d04680c31ba3f964775ea97cb3d57aa4d89ddbb14fe04e0ea405005905fcad6d2c81e835d12316ec65bc1250c498d6e26a7da57947388c5ecbde74d1a839f7356c1839b2dfa97e6ccf9cf5fff16a27eacad1482c8d3429b0f171f20f0817e212e8b8ef1fde7f7bf48e46934ee17606490f106c7ecae3530445bd3bb21a69c8ff163192a9c93312963a845094e067b8ecddd0440d05939a0c359596815724af3eb776aaf089df95dbc72d428dc60748c2d285682f837cf7e2948bba6e58f9a522b4acee97946fb58a61d6bd0ae0c6749c731faf14bd026dc18f59d0e32e526dfd6b2da96ece65864035c0a4cd0bae3fd886f55c1aacfe121bb1f275254c84c1e2145ba40f47b2380354884fae794220cd284425bb263f34d5d2b5ed3abc4d3866d98a47a5eb17a16a5180079dcfea84ee1954c4035a5dc7e8df6d16055b80606eec8245a886ea2ab6f6fdd33d73c13afc9277639cb028f179595c75e038a044e9ed1b980b6669d641d6454d9c095641cbe6e67948f2589a9bc658b27e89a69da78e6375c7ccb95633dbbe4f8dea3b177a79514bf9da04eb438cbe3f54da2f955e96042e4df0b53360a7b8ef82abe9d3ba0cec734adc72cd72ce74df913d587ac678b75f2180e7a758801457fda604f20ecfbe343b3400ceba67d7d36d95a7e1f448230e2032a3818ddc0513e144c05c6e6d06a3caa6256253109b8ca918b0e09e174e330b18ca378e49aff9094f6089d2fba14d504458889a663eec96eaf45ab0179ad9db5db0ed9b54e13432e316bbd85ae335b38fa353a3829a3bb57a1684de875b04375ab86b6e46ba9e43f3626f149cbb0d3696801fa4d4b4b02da7d47a2990cd8bf4d57ca267656fe821cb7b82fe3b6604cd34c05a4f975c21c3e590e96dd68ad6a3f1a2b0072b9273a8bc11d6674a2b7f9d16e1a8b92886b8bfecc8259fc2d975a78fd6461b1d1177ce4032c2afb70fa7cbf85ed606f4a79b45211bfd99a9160000793d3ffecbe6fd1339008ecebf8e650d1723e958f2d868edda6dd16d60bd44f5a51c54e637bfc36d309b5e6b7a95dde1da931b43fb4251f1ffcb4080c9c214eab500d904030737f7f57f9b716c8a6bbf616a9ce20610db6e2a5a9682f43298b0cef99e5c355d3d270a08b89e185439a635e44fdef2abe466ef22c687769ae93153c06fa8578be9a83742d56e22e94630ebcc3a233a8a952795393c737fabd5ec5e4857e702a4ceb7844097007744ebb548e6c5185a0299cdd16cd935c21d138ea09684de9fe1bde03ae6d16d49052b816739d8efbe7b445c262fa79d37bcd42ae0563c3ffb99c047127b65ac75a08dc444f7195b95abc92ec1fee8731030126ce00455180b9ae1edb27a707d7c59d748c80b679c98c039a6a5686cdcae6ae353e35ff9702c28769e502c4d9fdc2c9a80127064fb87c5e688aba945b756d2f16b002c9523fdc104fc9837315760125b6b68937e50845e468f07e0f3f6ac719ad588b45ac5c3623084143649504c943cb200b3d50ffbc574fd413da0fc4d868cb4f57c16ab90cfa8b5d8c1d2835371953cc329a3acb15a08a8d9e93b18851e8abf951f96d77abc7190055348ee6da305224e85afcc739b7440b6d5dc7f0712892638d0021fe432c33209a7e46853818497519ee48541b13dab751d8043ff60daf9b8ae75b98651bc23eedc02f062c1bd065031c471719ecef9d891b2a520e64624293ee7f60db91330bedd00223489f2c8666b7a9477423de43d4eddcb7fd4aeb3ae186b04184620b6d9bbe725ddc8e19261b33177a06867743019bf8d1fc08edd0666c22a317199b4329f3eb2ebf1b35cfdcbf208991654268499c13e87d57b84ab5b8bdf627e4450a5a6d82da4f3dae80bcf5448437e081e69b45ab9ed7671cb3b5b292798a84f94a67cb8a45c90f7982903f1a1b4757da37d27093096aa8fa1d96d913faf811bfd71045da33370c8ec7eb47b809877bb32208fd9a8ad90fb474c9db8f467a7e5c57eefb2db2cfd89651a3ac4cd927f43f539a2f06dc41239efd1d4e05ed0457249f72b31507024176b66124305c1e7714567f56171fdfecaa0667b9728f51ff45f94f1fd0e911d004b189fd782571e44586718b9fcec63733be37617927c82c9ba47e124ae16ed364da6938935ed6c173c7c0461ffef724bf1e0bd473dc189534542b5184d4bc475db91248131a543e52797f9200396533a52c6e4ce5f3a3a228e198318e30a7def42470e048d9e05915e67bcef2f7f17237ce2ff54d4d55429f37f962eaea8012ea2edf3b9e043dcb273facd54f3adb2219ad44898b5ef3a425a96809cf9d0c37a73c730cf74df07fac8a04bdd4d67d7c5c39c8c204154156515125d352e3ee69dc6fb7bfb0be59865a3c81cbd842e794707a32f0cd4942190e6845e384a90c334606c6b1fce792c8059a45b70a41524b992333fdf0566609a9dac403c3738865d322fc16a7a822887d8702f49e01240559ea01e7aa5010e792bf796cc1ba3adc5ffedc68fc1fe3de4c9ee0295bbd360907be9a29ee2413a1c6cd43cb8fecf47233ff809e22c4b9f172e77b4524689eee70932d3a9b2f207da79a0faca837a1dc01cd86d2d9dd5c9c8be80995fbc65270179a341a0f95ddadc81dbd3a034e524208b68d0a591cca2452572865f5ff7812423bdbc82b32a83d108b39b51e2b1884c65e93191fd2f4e54f84b961c0d64313f8b533cf9dc44a70b4759493968fe2a78a0fc6b734837e7401c7a772225080be926d87b4381b54789c430dcdb46557daf5a311ed99d240879156ed9ddc78cae8ca8672d81a27d813bffb594c634125d418ba488f034bdbc3ca724d57326687c5fcc762deccc0614b580dbdc20c8637aac8346071a48c4d407f6e0957d671fdf2affb49d39f3168979842f2184ee7627a133f0b587b9b9c921a7d6b3e18691ca40efa64914a06e92e8f07a78f0a1c133e92f8faba0747b46180688403e221a3d5403b85d900637834bc6a6b31e9c6904f6e6e491e555524e0c6fe33fd1ec873dcec4f8d86b238d283c72cd4ffa9558f0bc1888397bd246256cda6ac7c605d143b8cb2271bb3b6599fb4272d8b7800e83f01dcb799169c4d1f4ffe6229ea88cbac4f608b022a75cd677fe58efaecafbc43b16d0af46111206a94af81ca57e347b987021d81143f784fa2c31b8114b98347517c23d42c290d017dc216787178b4a4927eae4b5188c49ef8f177db81b0b63f94ce3066444661d6c5ab9fc14cd556f292d4b558b4f9997db96ea2d247720486345783fbc5a9193967457140e7ce613e9f6d98889c769b20394b728839112699dc4aece6d8eaddb248bfdd8a5b49be1914c3888b57f0130a5d10cdfc3cb550e307250607bb38c9683c913f747a7e423f1e05c9d2c695c431cc537293df27304157bef5ba141e32eceb283c09211ad7bd659a6707ce7fcb7376e3f20200d47d3c18a9e0aa1915ef651ac67984b4f113c8df72d6ea51d0de4150276fbb9d2422a628725abc4ad1fac7c206cb7b53a3ab78b61a3232c37122cbb646a55d4b53de3dc70a54991cf495b4656009d8407b601d9bc406edb263d640bc4aac7fff7051b957f05f3092ae22dfdfff7936d922c3942acf515dd822e09e88f6982f01e9fd70effef650292af99203aae9999e0ef2684c59ccc97b7670fc202f82c7928f330d72dc0a6d1a9fc68248cd03f826c4aead070a212cd52a02900dd868f4868bd5ff5f7dbd9f60b062446a627d205b0b464d934980a0a7736dfa38ed7941afb4db11e9cb0fafd61e679e853e1bf37d072af47db9c8b2be43621f605b79c40e83dc51c2ee4b529fddd00d23b5f62a6cd106b09d0e304d94bd3de528623d8bcdcdfecbcfd5fe3a4465a5466cba5d242940163e770ea54f093ea35b9f01b3b6cec566242f77f08a90f30a7d51a260a88618f4df34f003acecf7a4c6bd636ff50fb8d5f8147c328312010f1354ca4cadf0a63619589902bed30e8339a37f82354c1423208caf0508c1081f29e80b0de7d005209701fd39587c823ed12cc2b1eb61c6c41aa2e9ee122f2018edf8bf6254052fe1f94d9d2b7b63fb1e1d90d5d9857f3cc91c1c7c215c13752afd479cf230fbcd562c3ba2fab871475fc7ce4a64ed7e4e97ba9263f9b3d0d0f8364a28b72ee6572a177d5c1e257fef94934b4813c1e66c7ef96430baffc7bfb50dbd9a93fa1d5f55a976c95d3475baff11741e4f67d0f96294c11a477c8ca57df3c8014f266c628b2f0f024b04a69c18f74069f8c352dd22e5c0de622234a9dd7d5ff79fd283df9484ecbd6c7cb7e497e10fb9e2df4291ffee95943b0f3fbfcc07100f85d697299684df92d3fd44efafc0642498c2b1fefd7804342ba3ec2c0550ff4bf95099a5464d182e85dfc5d6fe2aa02674766eaa357a295b3fb23f8fb506556bd7e3100d491880855e24cd8e7129caf169ac473d86847b730c2b4b07c72f4e9cbfb1348b1dd77a9f404c0ddb9bd1988859f97167834b55263db9e2fac56b53ce0349448724a72594071c925e0f2ed64da6800129826a5c7506cc7692c478519128ad6853d998dbeb39dff4ecd835454be544e4774d51fc1cb5b72019b20e4cfea35af4d9084180b7c38da81893d1722c4c6660ab357004fbb39c57299a1ed35dabb1300f0a070b068aa64af56fb0d06033ea0697e1f73151135fb8d667cde3e5312d769d859067cda9e218f0dede92e95a506896e99f7442540e5dc54c89450c5a419afc3272086824a00a671db88c72f81753de6bb9e5d478440f1c123ca699bb17bcc3976866dc9b42b0625898d12f9cd47022ff2b13cd82a284deb4fbb62856b3971d572226e2b20a7c5b7cdce4e1052af0cd63af50ff40d3aedd2febb20838fe1f1b20776febb77f99a0f7cf3605a002ca1f169487913b94e82678ef2e16706e8dead54354f6ef06f9b4b08e5822d759a6abf7afcb0e0bf14cc4816aeafe4d52a3634ac93bb6199f91c089cc8077e9c088fb2394805effbe9b7789a0c4e838aef1003ede2f991b729d650a907550b0f7dc98ffe5b7612e33e757f4d9509b3b8a5d2387963cc4ef67a36a5e54b01946951406bb9dde47e5f4418a1d1362e5c53d25f2d54b1f86e380bdaf5e3b937c97a1d379d5fb0d04f60db4c281b9010fadc80ac4074fa0a045a7b2fcd5ef507f7bf9aca2b7e27e22ffbb7ce1ebf1e28229e1da63e4b27105cf03950ae938b35ef35941795d01737d263392c9860752104393a589fc7cf9a38228fd9d713dc601fa0f6ece70443bf7c4314d1f9b3b1423af783c876fbb018305b141042038c0d62a340b484b587637ba9d2cffd082422cd370e8cda1ac6f1d27271a99196a83450afae1f6fed02953e0d42ca1e16285e4dd1759b96afd04e5b37d1269a21084d6a7f3d2aa0dcff1876e5621705595d554967c584a00387751eeb8f55d5edc91c79bfbf4bb50545167706496196a7501d64f2af01f6a73e0514547a8ba2cfeec12cc28d9e77689779ab3a18348a66d2c09831cd43a8b83b447ec22c28e4dde6c75f7b894a27cf4566d792c758ba3da31fafe333e13b37ef958a8a6bcbc7541319b78129f8c514a37f57e25504772629ed944","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
