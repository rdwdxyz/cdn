<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c8b0a87a8f31bb5fedd91130100fa9add0d5de79a9b140a8fca3735189e4ea969a03a8574beedff9853c8cfb498f2a098b0c6590c0cb94ebcffb08e19f9cac6b11854a7508d60f7ead9c377e4ccd9b3123a4cfdef165e6d1c8752fc88bc452016b8f84df1e7f60156f13edfb23038a52d1fb109007281d09a25463064d956cb74f4c3fcd97b2723408c19adf5e82ddaafff2ab092535c4be8ac956484b297149b665bc19245c78a938f495086de8b29c41600057a1bf60f7c98b5296006ad2641985bb441cad6019e8fade90646c23bf9ddf784785275a8c6215452849043c157a234441d8ef26995a14695ea43dee8d25e8731f92a564265d6e6eb1175c75182de4c9bb7c499adece8ed06111b87ee079267a60247834a923dc09fdfa7b8b426f1468e13c2e9a481870026677b50fa634fa9a2b1e45781dea2bf170973ebd83aebb2494c05f689df1b9ec3cdff6576264a7929e78e2801f4c14ba921815e632c1c9b584b6a23265a9af64989dd62a556d82f435c418fa712675b8e8a9628eaae301829ae6062eb8df6a3a26ddaf00e6eaf09e0941ebeab3d4b79a2615628fcf4074dcb1b23ec56026e5f6f3e4989415b0c97dfe8c40053cc36e9f74f42aa0ac24e4b1e9997280e1cc6687a3d1bd1a19c54b6fe697207ab9bcb75220da836d06731e961c78b1979be10449a6dd9941ad5f1e4b072d4710ed36a4178863dcf3838323ab4d37057259fec0a875c13efaea4140d4d92ae6a96bbcb3950e39b375247f2d9a1c90eac2cf447432c5a4f492b79ca49278a1b1ffff708a1c98bd58cdaf2ebef2cd5429d5d3bbe79bec67e2b4469c8d1b6c1c4f3ec9ba3d977e83c393af5381c1e231d188d19a93d598172ab3f8d944051e0b2f564d2281ab3f657ce4fad52cd4603cd9708dc9a02e11e605d84f401cbf6760fcf4a79848ad4f05378588d4c57897da5a9902a05e6bf4623c1b5373d0638194ebac0d089641830ef959dcf318f631cfc9c9a763c511235df3caa57c6cc556f956396c6dc083da2633a24f68b63fd141d787f312f5a17dbc68db4c0ca2146e4ad903b7fa458d3177ca2f53d47405f784d403a1790a8cab9a30873d7a30184f47ccfae74094bec475631ea0b68d7d37fe8346c68854acc08269c68c091030a7fbb0fdcb06a1168c1bebe80e82da0246075195eb529318a4e909b46e339632315f769e90ebaac4efafd9469926708f0d82736dcbf0fce389e477aa6bb6fbc341dd47b83057e628d6838c7fe1ba333bf8f0e7b2e4c9c3cd85e56903251d1fda0392e8788192bf1314bd45a49a1249339ea2f1b09217c3abd21701895a3500fc6477c126199922e55b483d9a8ff9bc6ca72dcc593f0013d2b978339e41a58567839b6c358302d2472f3861dc5c6503bba42c22d8aa6ecd8455fb2317d7d3cb6bf275c868dcbf19a2565af03f99d283be526b348e336f4597291a4ebc6f80ed85bc43bbc14cde50ba841c004cdf3a08f779b3c861c20787263761e8bc058272a6d9db628504a6b12f72d37c5e0a7fe0be404d02ce847e2045f9be928cf420c80de51505e146fe72526328dd12eda5aa7024a25c3d3314de29f88c4c33d4f4b57a94c8a00cebc8ec06760c6a9549e86c3f3c6862f870b183027f26b959e5546c763e208f4709fb92666d1e6a3a09519838018d8a5783fce41bd80ce3d874a5d4eee0fa73de75a4e60d1a46e9e3efe96fb42d3dbc93177b8af645c5db2d9fec1a5752592efa6a8ddf46e73df2274ad92ccc4940c56c3fe8eb774879eb07281ba1d923cd6b798b3feeee265d22b18c3cb7062506e783f833672d57a96ef1a11cff7197132418f745d00c7b9c4aece4ed290f8ba372083c6e8389fc73536107eafd0a0665eaeb3b909d8f79ea815fcfeff3cf0126dbe36797ee0f30ce950398c1208d6636f969399ac28b0f76c5dafb5abbd49fda6fcbad23c8b2c08c4ebaceb6bc0906b928d1497133bc8612119a8ee06accf66029b5d404ee89491a90dc396e382d13a48d0180f055353b885e53ac30373c5aa79f4569b45cff61c41cf67e693c0ab2f9cf2f5ca71a8ea78178ee60d42bfcc31f3b61f072a579f2cffadd4d75d92f454c5b35384223e049ef0c5d2ca4ca0faee07f9e9938c116ca89f3dbdb90f34f5398a6d5025b46ad13ce16e5b4740c2c3e8b5148ff67cb012f860d6eb16c6632241c33dc2a801e1a1dc1870072919fac3abed843d39704f06f028cb1bfadc0f2dfe2663ec5a766e9f90e7e244a2f4c9d24a6cd5afa1a1f86d7e3c808e7148dc08e814b095116d3c29d29f5794eef21db22fd9bc251e8a76830eceb6ccb0a9a0b1abf004b116d7250af209a5be8467594a383417f84379d147bf9117ad306b8d4cbaad60b7122459fcbb15917f39756c7e0df25ae6c897dfb9c269c82b3a2bd133d70f5a568bbc9af9c363ddcb3a8b2240ef469e1e67edd7e1bc3dccd5f0179c354f33e0ea118bf090afdc5ccd35b82157ce249a0078b61c18a2a29b6ea5cc210b0285d1c69be415989829e25c5a637a17aca9e99fe1fe0aaf08a8d341aefb2eefa987c47b901f64f9c7ad11acd7f8eeed386bf72ac81bb23138bc53d7eae14f0dd3a8b1cdd2f5f026e51ee7497553863f58a9b6b2e8161025c5f4d23e03c40fc8e9df86565ca13b1c5a66b1201abdb86f65f0777c811139ce5a64194b60c4e78b704199e80241c5aabbe9861eb1634dc58d2628e1a802ffe4594535262a7bc23f855220ba504f062788b04d995af85c8cebe65a0cc9a771e627fe73636e2736755e279823b45afa20f8fb524e6be52c62a11477cb2cf4acb4424323fda4bf4b0c042273b573ea384d6d8ef1fce41646ab585098f696a74fb8328a4adf1148c256ecfd636b2f7c8d4375abe2ff40bcd0647232e238269cd484712768af0b00717646d72dccf6d9548e9a846d56e17a7ab9bbdcab78a4f792e28c4988b2354acb077082414807b4cc9d37d7f5147ed5e12ab17047a9012aad0cca713f3afb522aacef84dd7fe2746564ef3daa9cc8cb9e423e52406dcf5538af48ea12b81c5d9aad4ba95e95b5cb8cee56e8c59185be43a77811df6cb10b3b2f1ae81c4cfa1236959906055d569e37cf8cee2fb18ca7f55f9b76ccf445d519cc26698089c046acb9be40983890b33c0d46a4a9c86b2fcac1c6b433609d46eccd8a575871bbe9b81923c4e8f3a4af34b9412d3e7c197eb93aa4ce32996321b402731a271c0ea9a2982d054fd1ed2d59903f7dc21ab79fd18a685e3a422a590c47b5762274f54b3f66db579f1edc7afe2a7f23c71d30a7e794bd80e5f264a69996b06fdfe548b5286f31cabfe32b35c1de2881cc665ad8ca87cb63e8b8b4c002e059e9ada1e0d25f502610475b2c56c5812dff344dc953e6ff0edac384c91b052949ae688e33d00768766693c89a9fdc5e066fcc4a69b26c79729292e2e03166f42a712e331d2ece5c906df178a96103f47a5ec929228c073a7bd96c5ea2513accab0198b2b6fa477db816b611c2f8a1732f9d525657dc44c94696ccbb762abd59ad9684eccf7a3b995fc45aa5afb763c66c226c1149f68bd4586e2d819aa7bc1304a3804d3cf050e96ab33c16843770a4556f3c6d202267b9aad5cea909fe19583474f0e006e68e149ec6aed8b4cc1d46a3a85709ea795abca03c4ed8cc06620ad2490864238367a16ac74bd468e15b3f8c47c93de80bc8df55f53d3e8ac6a541875f4af4ba61c0386b7c60b306f90b25f230b99478bac84ec7f3e691cd15e0dd9f5a4cebfd41b5351b96e394b967a5ed4421260e301b3e20073fc6688e639a539ebcf990d78d2de3b72196e34a4d4c770dd98da4535c4141ee280fae072a7d0eaaed2c7d5818dfe00cf0ba3c73b0b6ac217137cf25478d261cf8026b95a0c360824c0ac7b18d521a151b2f4fd509a1a214a444ed43924196b9a3716576353a5d1d00c2a4bbdfb2bb912bc083570036a95221077a7d7689809b41fce4268254affb742c218f885855df09f404856c8cb5e5093e6dd342bfbd917563899339f8b20f39e9bda6e5500bb1bd62ae7f299b8fd688fc09700b7a6f470b118d594bfa68fb339958fe6152f29db1b0e2bcb3ebea240f992ec37b01b785164c15aaf08271452f50098f976d1d2a11ca87deb0d02f0c7b6a20b92a36542fa98954d1639384330761809c08f647253d5ab6b994f1c2bf9f4b8158a0168882b30d55d672db1ecbaf78d837b792a72d853bfc1e1eab39137a6c9b58454e41deda3d91ccf1d4f1b5577dbeade2b165d26689069b0598acb9cf6754a05c3b74cecff546f3f94d048c1a2e3b83980ee18a641ad46e283f893cdf4e569745c0c8e951f860d8c4652c89525160e729a0447af1f5b0f486113fca448355512b88d60d41e0e96f5a23faca7ee91e357c1ae494a1d8abc184df99f5f0586ec85fce647d0a9275b51f41fb064ebd805b8c5c9c8402c5c6b5feccbfe7f775eec035afc43afb7171f9d12c48a08a16bcbefcb7c696fb05ad6f87a54835959293c90709142e0791f7a29cda5b906dba81783960dce44a7e818f0516399231d9a0bb498688eb45e14c4fe35c4c2c9bf8561344801a3606c39584674a67d160bc380bf673109570528e5002b5b85ba0b5c7e9360749e6316212d55bea3592692c6f6c36f25860d7b72ffa0356df827d36bacf1a9807ba066dcbf755e9a82c02a308aed399269652da6123a89b4ea112efa4a82c9f5dd07a30767514152720ac1c914c24803add77e8d407761fbe8fbb70e6c74828b8af7c48b0a45bb70cc8b9549a6362ca2f81f3dac761871991931c3c70468fde407137ba726b4acfc3fd56d1dc8ab9c920f4391b5671a76b4a661f164d0137e865275fb133c215c257a5d1ca5ee6dfe303b2709f678ff6be9df669c32782d42250658c0b88460d2901eca15885285e3020f379f21d554a9e5ca46e8799d2bcd5917047e92205bf29f65fc7c50f7cd631553a3523c9b441dfc336edcd282ca3c4d5e707a8234f99c5a25c06300b89eca5cea8bcd55280ee905ecb59c9d80106ac7b6ad466c07c4f9502560c7fdfad5bd17250abd71541806c3559e9561423a02e9f0ed6c57184ad5f74ff9aa893ded3799a75a247e3c1780e5e11be271f4bc8ef85e29a2c2c6f3f80f297e24fe80271165e398af8cbf040e1fdaf3f3ee97102a43eae1986e6463b9667f6339b61ca1a6ac7bd28937b3b4a32276554a4f5625b1b16f14cd9f94142c80fe600589bdfc31f96b016a8e33cf3118bde13c791394b7f0b5fde364e31b7f27631416ae88d435f599519d92805f415fbe831315f4e39d43c52ddbbe61719ff8aa0c6d9de47dc39617505ba8b63f93fb12136dfe23dea521985069d71499421c104e5e34a6efbb5ea640f0a2f410acbfcfb0e932ab59fa988475f44f5b22197195a4fb995772e8c949f2043ab2f71b5077e65a20840c7088aea1b6ddea54cb99b116b7949013ff198256a1646cd395fb2a51734dca31578fbc001b6a4e5a34eda0de409aae5a129ed9a4cf9fde352b9a26bf2e24d220df537bdb69966104320a61b741313f576c01a0ca85a4712731c55de5d2425b331ad2cba4d7659bfb7cec75bd21a35da4d852e0211d31bc7eca09fbc961133f75cf445dbc1522993b7b9b1b273f383e76769202c83069a63b0d8b317e6260c910718807bfe2b87a866101cd1f6d8a9c002e72fdfb6de975a9762884f55711f63aa502604fa301001dfcce8915689fc157026e83948215bdcfcef8c3df98529d7a1e02a2f02b78b4de6b9ed60f0ac9482823df40438408e84efd317f505fd69906c8af2a09269f01ca9e10b6d845921330daa640e12eaedafd18d190720185946a8440917e9bff233faa2551234aaa915e856c43b8ad859cf2f0960df3e8eb6859643b720e6e0497e7dcbc15756e7f01d1b084748fe0db9841d6dadd1f9468c6494cebe7b44daba30e65b800ce175f6f9902126e965bf9b00b4fab87e43247baabace6602e996b9e0f9f4fc7a098ad90ba9f00fe71bff8e9d39df0ac40b0ec3daadd544d1effd20ee8b259a26fb08380f4705f665fb87aa3ae3f9456fae044eb0d7e5eb1ee2b80b8a51820859ea273dcfe06a3b23e1e7fb842a90a29ac922d5f4b577ada71f474c9b971e6e68fbad654042000d8a7c5ccb0cb208d9d59e5a75ab54e0ce5e86b79c7de191ac9cbf7c6f9e9e81d986df8dd37f6edc604cf6e5bf01556d7475f794a949eeb8effbfb20737533f6ac238e0acb5fe2c91e16183c6513b0c728b9ffea69fa9ca6270fd7fed31eaa20bc8d94e10a0310554dd5200f5164b98c6c80a7044353ea21dc10ce0be069395d731843c327b5c5be8943a3ffeb77b90c82d2f376b251bdbcd023b83d03dda5d6ec0cf1e61cd93b3a1cbd1bd1b7b6fc1af23d17b5567237acdc4c0f255c21a8e12f33361a9f92858df46902b46bdb2ea1293a68f7682c3ada304354265648c354d8dde32471146fe9f61266c6394f57408cf81ae8910aea33efc2638cfe5941cb89404e46c7f27c3ab003d0687aca686c48667f328572d7d55cfea86a85f508c1a021988cab735484c02012f6c17e46d5bf803a8e0062bb35fe1fd8499140e021649ea933823488b55836e64d97b099872baa4148de33600a5b7ce3f8a0ed08accf7438833d6a306f3f4e3adad5e2354cc796f849a4ed878cc071990f63e587a341ae4dc24f9cab28873ab10868fbcc9d92e1ed800cbf74e3a7108e8b42ba8c3c10a270f134e44d15b3bfa218c3ed9d36def399893e99f85bb09844884b78a16f62df9597f0abcfd0acf16e6b86c0bfefb1a6e4c4833c3d0f5c119beecd7887f5348586793bb6ec8a3237b4bf5d6a5f756dfe4ba8546df2e3864091cc2fde3d9769c6d621c44e05c510be0a033db37b4df533c6fd7e26eaa06381bf6e149d9adaf30dbe0e1c97379a796d55a3bd597ad20ef6d7aca56ad8e17cb9565f21256991190d51e57c514431985d35dd2250ea67eeb1b2e9ce46325c3d6ecd5d3281f15e7e8cb987898da5e5e043d64e654e1f65ff7973aad2f04d755290e8f38fbeceab76045fa54e91f89d5a279186ed2c0df7361f1602cc62a0c73276aae95dd35f6fc669497a2ac5a61082ee1ee616691abadd8afd7710aad8639da96d519f5fa4194764fb02c16fa08f8b6ef38ac25f506bcca938c2b6620f40545d7b287826e918bc6aec19902e7b6dd2aae617945be4d6d6802bdf391992d8ba59a46e3e5cc56ce6a21dd717da5ec3a7a974e921e5e08a8e485156d83d341f0410481927168b2cf44f7c7af15daf4794fe49e1f721040fa9b72ff0fb3f50a6512c0005c84d934a3e7a127c7289e977ea20c4d2fe6a9aee4a80a6bcd0d66205410da49154365359fbc0e189968459558501cc30458a691aecd2e34574d39a6a819307746738eeb5b10521e4f6ecd78fcc2af72e4de3fa14e96756b6f4a168010dcb7a620eb8cd43f2ae152d5a3b58fef5b3764d2559a05a2bae0bc1570dc670917bac1c6fee5dec9a33d7812061edd6950d6b709241e49db1b50716100c458e4a77d401526e44288b681d00f6539b19e021aaedbda003e683434ab86692da6af1eeb99c2e5a26cb2b39002480a1a2a90cedc6727d365aa82990ca556d0ab8570494f0641d022746deaf7e4ddd14bd95e75c6a0c7f4efc8186b86d07311881ebb67713b67e59be759a0bc701cf4d7882035b5555ec28115b95cac62a82142f96412f6d6a53585339f73ce407ad870416f0c2c5d2c1e89e219086d7b1c6771ef1bd672b913d409067a0eb2e37b902f7eeacc7545371793c5549cd7fe5d3305749e8974b01f235641ce4aca002857c9920954694c353aed6b3ff5db101e8e5cd713d6ec1795a78eb6857ae1d5acce2eb38a45e8ac6566082253b9b2a414e63efacd459716183ed849503c41837249672f585c696165b18648678c50bbd1a741afb71185e4ad9564eea294f4a812e4ffb7fb5ac0ca39d0142f4b68b2d77c2e4b143c91c18437a0e65ce162b1b65ebc4e06febe07e5e8018b1a5d7d7d728c99d781008333e8aa1cd32f27f355b46479f08a75f1f5c3508c36410f7d5f9907cfd798d264557b94f6dd044742b267bb2f31cc7b92f1b528cc7bc8e73e2acda7fd55edb319cd8c58e3465302c50800fea2dc9ee99a8b31540312bd2c4008b05f48e594dee7a413e7252774602cac8c9611b227618ef786f46017f4445750fc9ce3bd62f572a724f1a756ac4a16281612981ec36c6c346813c837042a39a2336156a241851467920aeb4bbe87b1643911938c057c8b09ef84f2197f988534c0e5641902a0d7cd904527fd4aee3324567daa0b648cbe1d53ea6695ad1620373aafe4a49a08be83dd53629c90216dead227228a742d6390c9ba0fa1ee77d8fc90de5696cfc9c4fbd065fae17d645671fa21edcea06a08a1c4a0ccc8cd0636fca3507e353e70637ff769878b851a10a91cf8c6262a65f3e0b1a8b29bd41f43896d710e9506f0b87ca014c204944d8703c9a58234ccbc467da2d937985160b4e3c1d0e9c54e85e5d004cabc0654230106cf1b69864eff4822758ad5d5c8bc823945f39cc232b368d0a3fed424f85bb57d424cf5fda2841115afda05f7da15d45aa4663e72220ae241d3f1ecee177d0363b0f98702e64ad36a3514ec70233fa4a4e599252af604f13bab83d17b7d105fb55ad801a68c8a3392c1bc4f4510205abac43a43b7578edc78417a5f7d1af878270fc297ac6d0c0d7e58fce6d409c56ec38abfd00c5953845d25ac7f62f4c0a8f42ab444694ddb7e95c0a39a6825f0a5dfa2088e4f65ea7cd2fc1a6453fde8570353b13c69325aeef540c28ee340520f292673e65e413c77a0cb568c2d966b9515a55836af2655a14688f5fec4050a50dff8a890ece2960151abfdd8b70634bac52e631df52a76fc72cbb0ece489c904a16c61751b8b122138b1b6a7c0fc3c4fac8405a56239072e7f77009aa86a3601226598a7723e0c56227cf6a81a5072d2b7cd79fd3ac4a96902fc6bb845457417f11004348baedb0f4ff70a835dda69ca3b7750a5f43c90d38580cc0682927c29ce55bd890426234311533f35ab373874ff023a9cf33c26e8cdcb8c0dcf807c25ee05af428ff100b329102a41c8de2398edf0d7f81ae85c886163eb1eb3498b849d8d15426d96a41329517e8f1f649acfc61bd1595b23cccf0b57707ce002601dba2e76cc3a7d0cc72af4af8211eb390405196f93b0e5f165797eac63c721eff455db3d6b3e983366085d09cf08d0add7cff3865c5a77b53f1ca19ebde4cc27739ef234d1f3812c841267ea5482a488a0966807578fc94cbd6635e771c44411bd5a4528bf569a2c279a8c4776baf0584c83a9a11aea68bb68fcb167b85c3e7523f63f359f691c457af8d30be5ce55e389e1fd305a6de1ea0fd03b978744deeac64ea5545f472401dfdb364d71f33555c48977ea6a38886013cf6e2b940c62f687d2daaa79080cca813c5785948240970f481c5f66a3ccb9baadce064b88671ab429310d5fba3c32eddb3f3470f3eaca505841588f245b26cb44202c3682d92693bc18953accf443fe907a03922c6850272840a707cbb6cc68b6c989378941f8486520c2650ba97c7f78c8506028ed490070f636f9c101557eb01f2e6cf14256f7718d1871b3ec448f48f92c87a991f1048c2a68e0d5f9711037540cf322be3f49816cdcaca201884d6bf7b54e1b861f883457d16a9473a07a5992f554394678dc877bf6a79a6058f67b689b7278022950808946dfeb142d28ed7bedbe9242ae91d208eba28d395438cb4959a82865f14937b896285329600e97266e950db7675f5cdcd30fc0959a577cd0e3a4d3082e69446833bb72a60a025c3dbdde6d45e84f65ae9b1a38f62f0cf4f89ba8842c8801876510e9c8b33fa1760209abb5487f739f760a203044268da37fe372a367d8cceb5421a2fff723bbbef35ec1fcc469fb9bcca2182068bf7d4243d4bf891aa9c12755ded03aa428fa28b633bf85bf6f726f08fadb2b202519b7bb1537116127852f15f430838edfbc9c5b35995c8a788047730ad52ad03b141d948f5eb54b1a1e2ad2cf6cb7f7f6fa691ecff2d70fc5c565fb46ccb9f4e1d69bf07d5500dfc4c286cbe23a5336f018a6864cce2a254ef5b801ef51a3ddc498668f1245fa36484c82d6e0011f7281876acf3e7ab63d29d76e4087a637eb1209e8c345e57c8933f824037269a18c100ce4df9ae037b2caf4de9bc28b49f5dd4c0a6d43760fd8368ed89e8fad6d8194601e79b8e19d8596639b78168f60ec455bc96d99d38143acb5a5a2da95ff6c5a05be89e9d1620cf828819b5dda14be6e41288c8dd589b6696d56b02d9e7172053d453f44f9f33f513f4d368e7c5355e0b293130bff0977c020030bd5369999016016c1bd8732c8ff3481ba300672e1492d709af1d0d745b95872495e4cb6c3d29347706d8acdb6382dc9dbb30dbf100e23728a6cd225eb6526237eb0ec1d02d8be1bbb8c958fd466191344f6976426f535d4535c64f06a490ee3c46c647e050d6c89b89391afa9a9f752826014213692aa0758d010224109370750ecc487583b4d31ae8ad1d168008ff041a93f2544bfd1b23083ef10229c5df598f28d4b0f5fd70a806e335906065ac623b33513ce19906bec8e597a934aab3b3b095049ca09ed06f7f2299b8b355a105a88a7983a09093c466406dcb507ab4a253e3596ac2cc4c5be463017e5f962c7f8e4d0d0dd374ae45130daa81896913b10899ebd698d4f777e59296689c7f85fe96dd90bde9813db1cb12aa8b24068a6980055274928d2766915b9bbf893d3105cb996f6abc6e2c8467b96abc8e25a6a988f0e2b56f8612a330ae3c5443ff543405f0ae12b8a7ccb81a602a5a9e26c05a4dec7108b79a91ae36ef774b187c76dcad9f1dce244ada591798b5db20d5c6eb2e3b43d2e2a0093c084c5279a7e5b718dd12539bdf48193d80e109e4ff28a4ae561a85330eefdb7797e9e53153e6b137d86366495ca13d6ff66d8c8f6ebc75b657303bd47f1697c4e67f618ab0c8925c9c62bc00bdca864ab78a0f77afb387b094995c26f31de8c87e264e56d26e774037a08ab8d30ba2c607c83c08ce84397bceb517dae8018cee6d66b713ef6b823c50539be59170ddaaa247c6f093d353ec4f9a3fd6fc734984ec07d55e8b840f13739ed65cb0ce9e17555923aa879da99e82d2bcb0123b244d1a06669fb8a123cd659d9a476caa4e084b0b05c21f607b73d530a50b27c77923ab5213e264cf75d1869f1a3e2511e15edea9ba9fffcbd268c94c2144679bb64632d1a63a2900b46384ebeb259912368d70123798190b85a70cc749dfdf85d54c486f9fb674ebcba83f579f9619d1b35e483aa891347dc2b9355de1a7f6505ee6a6f34d626508e3192fb106df2927da31a8f56f635ffc3bb244e4ecb8077cbe9bf06da9674183c012138d3301061e4484ec3fccb45b1cac301152cc10b03c9c367ea9a2fa95320839505954e125c2721bc84d4fea64c60522da727fcf213b2cd12d3112a62251f691a731f2ada2b67be9085e916b22e9741ded38dd1bc5e1ed287f9fe5195d7f58164d18bb6f148dfa18f3909a7517c0b934aa068aae360777a1ab50598421a57f1e599fe81df4d0a37066696671c865f37761d430e34edeb74e7438796ea0cc22aecf798be38c461d4a095f1c6d21b24a24599b84dfc5b55187d6e8192109c103c662177f7977ca7dc56bbef6b4211cdd315d486666a3109c1b56010bed6c734fcdff038f0b6e81602773238bee329580d75a4f2b7dfb1779bce668e03c8cb42b5f687095e5f4ad2a93df5c6e8704cb9d2c7bd2ae42631e6a2685e25078468d2d69671ca1abab314b041a887c72bb2bbb897bab9dc6f7c347934e95607937095d80dfa6362dcd9cbdcc675022621248408b8a7c32b423d8b66eb74dfb9adfbcd8e8262fef8992926b289063bb6bec54fc623236ee7650d2f3a0f5b1c70939c63060e990813f96925b0f6b0bcdd7f3f3576c895f79c7e62b562f3881a59310f2f526032a4637866c678c638baf11733d3811d8396d539c642a8492255987e1964cb9e7d498a4cf6f54b044e00d6085ff2d0227fe13acb9211ae5a62811ca76b0668debc72b77be0bbf7ea8fdd8d6592e571a251d568575e5c04a1fa255357eda25610efef2dccc9514c8a48f752e867d53be8b718fffe60ce52cbb9859944082ee74126ff22509c6bc6eb7b31caeea7f4568394c9e94a05f41d47c7acef0e924f579a1ecfa561af8282a5bfc9d918fcff1c47c90326d524e8fb21f830e9889308ac7b23c8420272e5ac74e0167269e7d6613cdb29dd7033b5b55ee039b64bda1905bb4fdf448fb64f99dfe25d9f51b09dac9ad2a89aacba95b2092267b931bb4359312d590cfa04cab5f0eb31b7937fc2737d68d215e57cdcc4f53cb21cc4dabc698919f04be8ae617400de0f6b971d7de5b7e5733d58ef8dcb694584c3bfdd75e527bc41aeeb9ed3c2ade02a1511ff52ba8479e0a87f7fa8ebd75c2002a0dfe7900de7bdc52796bcf16ffb1b6c0009af01974302f3c4bfc161b62a5d633a1cbbe6e22fff1304771a945d11fa11ca00b8852d65a6903b3157a46db2f9e0e836a21a69fc714012a7df2836db6042981700b832918da3d537c58c14afdc88b3daf9dda860ec8495f2c940e0e867a4438928ebd05c43ac8d8a8c543aa5e3ba100b950ec0f7a29c199cccd3461bb2b3135ed804351b97d01b312b41938c9c38e7e1327eaa75cad9bd92cae5a912129202d83c8c1b1dca3c7bf6bc7a4990974365d5569edb3e9fd720f964b9aad7808cecc203174b86d31d350db0eff772298ebb8b5f9cb3e23354c83b7d7dc1d2236983a26aa33ce28f164cf0c4102c7029935ad3142a283d71db74cfd2648a96ba170ff221f78aef3c1a7bbb21567812857bb8614b60644b3f97fcebf7b25a366a12eac299ef15c2bd3ae095d035cc902a666964c4ea1ddde93d1d363672ec2b00c07bc440607efd822f57eee11cf2b22e0cc26511a2ebee8fcf7370fbadbff31e434c378e43a30a752c3fa3fc6514e87989643b39b75cd31c250a63b2a0d88386d1d8bca6410db4d7c187e4700b51a512a74c4a7b1a63128b801a9d35a09a4a27d42f3e06921b9b648ed5d3ff488f97f126b051f3edc4f6495b4b3b814af0881b016c6f3e875f254e12547c217551e2eb5ec503e77c84610b9bbc555b9c841f85ed75392224443f30a42ac4defc89a8336c0b9eb5ef5d262fad06b1010f2bb1876fefb0ac0500e7ab98426212fbcd8c29456bef15c396ab7b3871d7fdd944b970e408a4d3922e966dd35c50d98c5059cef8b51984397eea62de1d8860de0a961858ffb881a683685e23c88e5dae05cbb0404e547a78f224812c51acb37fb91993096350678eb9e622a476baff7b394d9f42b4ccbd52c4d714eb5a067a3744ab9a5125f5034e419be6c3408808d2c6278874623a38727cf18a8db9e79948404b7465d711c1732e27b57a83ce5d611c1892c8550f908729db7eaf5c626c7071c23d532c2186fab3f166adc81459d723cb86d4e601d4a100dad78daaa65d3c372559def2868b9fcb40a8b08d0b4549b2f66017f7f4908fe2fd7dfc908d17106c9c4ac1b9e552d5a4c7fa4d0a12fd9d48de04ffe037e520ee8f0dac80b8dc8c669fba5e27d751f40a87d3216e2aa0cb10435e7161d3b562303eb05180efba872c991f08c59f6d6452268b2b8a8e3c543b74bd1553dcfb63957fa0a320e29b3e241492bced8cea5b970e0c5efaa578a701cc6c78be0e088df8db6cd86b18253bec70107a108f6a9f6fed7cdb38af0cf78202b4c3181e8c075f0690ecd4fd32cedc81041a4ce5bf1086fff9565c1049800f836fa84738a57fafa13f92f9f5d21d39acd0638f36427b816460525d5f7526a8c30d24e0ba109db605ec76149fb41bf7fdf61414063f01d2c55739ad7599b92100649679281ebb15acaad5ea91d1a34cc77fbdf591d65bec040751b9bccd0d2c166dbbe5e26e5ffff5fbeaaa6ba29b3c50ddc57e0fc4eaca6d31245a55285904cd217123b7abba6099c40cb2cc70568859fe7d693a147602fb0bcf84b48e10c4a98eb7786ff948ac133734fe495b56eda35e4a55eef3852f6399a1da44a8cf38063c139d2b27f26958a80f82544f6f0f3f1104526c63a9296beac745a7dc5b71005ec68481d5812baaeda90cd6ed24fa991e2e40082f74510cbe4950a640e0349f98de42f04a3b842afc7db69b80a70bb0c94398f9328a9d5e5d31b6e9ebd264e15073153cf7182d3f4d9b8e5a96f664fd8218bf8487bcfbb9271b198f44efd1a644b2703a0ab26f041be6a998c0f71eec757ea9e6b491431124b9d49b1da582fa7550612a4c9249ffe056ef13a0163b981953985915c1c6c3776fffa3cc06ab7d609ec6d7f57915b7cc41297ea891cc1b68b999c844ac400b27323aea81bc8e90cd09ea02a9eb9b3cce1352020cafca1e1bf531e17309891dada7507c12f14a5d7f8035be8cccffa591c2d5684ddf0a9fdbecacb519352d2bcd670b843d01e63fa1b141f2a81b3a0b524fe04b605af0145ecf4bfb77d9821bbf5d75bab9f2c078ce62e7a346561b95d200e847e4812d38032dad4690dda69ab56d1118c04f1263c5a864d3a017e6d90997f76cbffa8c1722d9edd5dc3ba6349ba1871a6afe00bd5545e6f3b4cdfb97ab5b8c5942504f94e933c9218e690bd1abc60ba938569ffd031436a4e12cb3cedb452cf02fa8006dabef10c855a4b7d6d03e9c94f7d380e3791c482115f9c065d6705de74055f82c05f9c3b06767c41f5105e399accaade9dad8194ddff5323a7362a2a7eb5c75585c90ebc8cd3ad743a1e86ff8e39589bcc9a2a8a198db54554b7288ac93108d6189dfce1df230e788eb3b792a51ad6f61c68a8aa468f56f57af1042ffdf0dee2ff57bcd4df812d6e4b57814bc2bc9dc28832820a1230b2d267c68a2b8f5a42c07de4d2f8fa79d3aee314c3915b471e4c235a6d1f9325e4a6298291968ba1d44d478a83af3b36cc5d1d61b51bec0019da89574e15f4135661cde67a47377315f81ce0d6d4a94eb34a8757f389e76f5ddd9eeb9f0a2da71886642aaed14bed0b8144fe56c13c2b4ab05d7c8be2b655e063622967b6e96ddd5a5c3a0aaa0a9c694f69a0e0344583b0795a27d694fee07f1d61e8c98421674603fb1c5f58ee17bbbe702d5692029e604ac98d1f90ca7692ccfba51befedeb8640a15c8723d70adf23bd86371f66834dffc5554af10faea20dece8ad53af772fde608dd5fdad785f950a98a22ac31330a91c36186591f4b23a85b4caa534aaeb1f2d3202bf3e08baca2d56ca2fd3927f9c27ad965a6be52df557dd84809e334d2cc84e6c0aa305d3b6159c6ca815c1ed8ecef42b11839fefe9b787c6d2108e4b3e797321b238c483f510213466ff393ac4e349cca1a1603d328db07870679d2bbacf2cf11b883da5b25d2796a32f5949e9ec03c5c766fb254cd62d35e3b928e5ec80ce9c0339bec254dc946d40b9e55f0e8447e3e6bfc7cc7a70a1bec9c6202bdb32ef0214c2c155665903f04ebb1bda3e0d036a8a6fe504c71d2009f05030573f0495575b6663d35b147143f9630fc6dbb5b83792b652459d9d0a3db7e2631913eaf19b92cac2f6702587fba6cd361e892f4e81b3961799074bad4f430d314b0197bd38d1ff3cb8cff285aad71122a9a629bc00ffe44793dd7ebf0f35f6be44fbb8da7f36c4560fefcad5214c69234c96b2e7f3731f84329784e03c516bb5e4f29e6d421ada0e10dd2aa1f60ae9e1ac21e8a6833e77ee9cdaf5ded7460c2f5d75a2baac0ed7c0e4ef5ee6d2f39d3527ccbd03434759b7b26bd00ae489a1e61b20eb9be97a9a36851c02f0e278658cc899881dbb23411db16a3cd6fff84fd3ff8ebb3689e758a0b8fec9bb4c648f30cda6a774498886d372cc3047a4ed03116bb91aceb36d945aed0d3ac5064108a154850aa143b987aa7b2eb7695309610aab96799b54fb0f09f68a83b18c550b19a43b563d5a7d7b4aa692e2db4f4e16429c61f3bd0cc8602a50b55dd84ce319910f4975b562cde80eb208d084ee84a330343aec3d09eb07a87c765777ebf876a8ca7cc0729718c1564d3d76d0702ad560f7610b3951668d3b7dd67ebd47ec8fe78126c42a00a54e985344bd032fc78af14fcb2f3d3d3c890219bceb1635cb217a298eba76c7a48b6b19edbc1c76657c32f3515c17a772015ce5c41fd4d4f1024fbfcd77e1863d67042162efeb6b0e97837b2f99c1741a86013400fd1c9b0bbd5b4acfe36798222bc9231d7b39b06810f6bdd08c3a4be23b8d1fe57a7dde5b1dd72197236b73e8ddccffc64ef4dd7009f01672a6a8f93f8f04ae509a4969a25c3afdb64c169f6ea9f8a5d05900967897a7bc07b755359d3bd9465807b4505148ad539c03c908ab4e77364e2ba112a2ea806410f42850879698f1236f6a9b8e18a601f83eb0b08803eef5d81db23a6a9723c790d593706133ba312e3849826e972d5de239eccfcd5e920510e773109e8095e89936309882f289c8361c327156822918d56511e17d380708f3e1b5964377e0358960e38fb9e42e892148250d9f7b1f2a9a328ad3a7755d703d42963d4df3cb29804a75dd3cf23c7c36c1de88a461d4d150ef1f6abd23bc95fa08b8c48b1b80bcb046ca425cf2205615283ff01c6971d84480d9aa73d96fbf4a9ce8608cd97317357f294b2b6cddd2796de3447b503010287aa565fa059d2b5920afcd147fb4f6f6443f7820a4fdfd7f0571cdf122bf7580963bfd0dde383d15b053ae69029a378d04295d666393e3a895a2d738ad2f5171d279b4a924fcea35d6648933cf175fb5d3fb2307752e43c1fc7cd358196b3afe492f4dc851a2ce108a6aa16c7cd0711745b7d5345183753cf26745115d23b20f350b33b2279cf5f0c0817edce5c11616cdad584fe072447d9a9ab79c0e0d29155e30264bbc85ebc5287b297a6c478cd180848f93c130206eaf5b66413f40f363277cb92490776f3eba4ea5da7a4a69b81c3e60dcdc36e61ab58ea9589dd66cc8f800ed5f44f18a3948565042da311d8af206d89a0c2747b72f802554012b3adcc3cfe226770985559109069d01bb16b6e710eeea25431f56f829e604c450da616803d6b02464953a5e0e49a885fd600cff4105ca18ab2278ac6f1843ae8020e6a05e18da01db1534fb4c8c379c07923d1d397259cf6dacf9f35274d4d68c1a71af3ae9d38c84b54bd662316cfac2b0c32ef6848eaff19fa2cac43695c06704a69364b28410335e9c1de3b2c66b82aea7957ff24068adf7fa1ee0113ca30956986fa5c7aa053576e5099d61cf485e052235684ec6a3039586f196c49b148e3652953b527e68c554ee0346e7355d3654926767ad6bab8de5296e7ef726275b8cd3f77ec5c2a8161f41c618f4e58b7fed56ae1029a03f7066f5f5a33e0f12b76b1b7716b897dd3fb119d61929a2985fba1c9f9ea61ab1cd4c07fb1ffd9158236fdff1d47cc377607c7ce6debef40ea0750b1a26694f056e4f14bd7a80d370354402584798417b0b538458a29d11e1d581bffd875765d98fc805f375f9382282c5c3a168daf4ce363c90c76d3b8d57bce08fa1d79699b9ef426e84319cbbe25c0399e0fd9e2360196774d93294fdcf50435543f59d5020e73cc33a4ee8a01ee24dfc8a4c2cd5a2f8d94886a061040b8860c994fc8f2b0a6bdc591f6f36cc504a0ee00160e6968030d4aab6bdb520e11fad01cbd9f9ae421c368247e56cb5bbd8633d876ed1b3da00f8ad6d6826c297b0194cec2fe719f54137be0ee604b45fae550db82768f7785e9dba3022e4681bea75e086893054da9f6bdcde90b62252f99936ac53b7ac2d702b324ab47a034d26833be4b7c1a7963f64ab6bb52cfe5c655ca4bc1d7a7caa7e80e91b3ba54685d4a67d92ea3810c2da689c199","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
