<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60c77df1bd59bab226841e2110fe03e4e8e1db4ddf75d491f2cdb2633b62ae7142919168d29b4bf7c2725492ababb1f380b0a4104db2aad11a0cfd69ce40a5d386a060ca3e39eab081d3e8f55cbac6f698fa47eb43b71832c89b5b69d603fe6978c3a560a11edb28e840fd56cd552a846b1179a9741da30a9465aa0fb59a8df6e2600fc490c77238fb1f1ce53d142fbf61ec6537c505c77a06bec1393886912848c45f634459e67b549852445ffd184350371dc2a617fff1fb9cbbb14c3d1a516f25b0dfb2fa9ab809c031dfc995a22881e6ef6c18a2479486367866282a869166aa4ad0485ac66475d2f868dceb124d5413bf47a544e374a68c172ac108d6551e39daf9769b3e196f79a64791f62454c5c13b6694e66630ff1b2d7fb9b5d2a267796c1c4f976a8710a89cf16e02ed4358af554e47d13120730e140ee8c976690770925a058e7faf21c214cfdd1d1ac5bc9de7e4f63d9ee469b718ac44c9da76c8456301cdfc3fe4863b836f14ff936c56bb4c203cfa22c34b3fabfeec20d47260d138ccc49b70971311c18741d876b01dedf13d8d65c6a1d70c6a3e7711c9ab97d2b5abeb9aeca6b26b9623e6972c20a3aaec12684d3f2562737dfef90d25c9b155a9a771247f9e80d5d474723229b7f33b8a4827b4f1691d9ee36af5d798b2ac7ff723cf48b07fe00867c05b58c03e75964d30e094b24a9c38355fca230c0fb4e1a62edaa0d2f3ee4833dccc8723481e5c6e803e43a9381fc44e818faa16c5f83a8c04450b0705f73a5887ec26a0168e856f92c98ff8cbefe5c5a28c9fda52d8d39ea0a89f4d2b1c5b67494d52835f4fff371c4a4837dcf3f1c334180da0bda30dad8506d678e8903b36d3ecf3c6b2f52dae49db97b9b0687f0ec2c4fe183889270872a1fd345b79ab23f13d4a2b395292af99207ef69a99a68d27e50a664bbeade3a1d3c4dd8e7783d71a0bdce7785f7ea611e225f5c46af778dba2dcc32e46ab4f095b5a67214ed5c5b4e0e6026b4bda096fb7c70ce64ad47774ba94b9f86f139a9723906613c4203ad565174c7ad614dafd1a3bb32850c0888271586fa244585bfcc502fd78c0bb8f4ae707bb9a82cfd92ef9a4d6c0af191b69120bc05d39edc1af41a29bf024ae1f360034cfb363a6f3c69401e6c5744b4637cb635f3ae4bff7abcec324be2fa06026bc927100c9c1daa443c606dd6088a0be0fc51f7b13702324014b0b4961327d2978f8c9f1cfa64779fc4e335e2283912bf3ce97570b399aa5325286b2823c39c13ddf93b5cc56d77d7d271ab03fa521c5057a28994d1014f5b5805ce40a9e125a339fc258d3cb5c5e88b2c9ff2ae7fedd4f7c1ae377099cedde9ac834d1b61e6dc6d99f69f393879743098993db3c2301479809857ec7c58048f6c0221534653e900d4eab32fc19ab465a2638565cf366f4e34fd430eef8f9703e51e88715c61c40a2301be739d7c07ea197a8718f555452bddfaba838f0f334d10b54c5a942220b2247500e1e3ffed05baa80612f0a6efa221aa633c8c1ff05e7f14f767187f3285aad66fda974df53cd87efbf4ace5ff04354e263c23555e7777a68e1edcc5c0a80e00b8f89deecb5f18379f222bf6e9276d70df44ef80c8dc7a73b2e34435a18289b67ff893f286126fad4ffd0a21cce4f9916664e0eb258d597527ff36ffb1fe8ccc5ae5845c8361e9f9e637edd603244687ec42a063d46bf858ed52e858c2da21d8afb5bb18c36087439953d022de981e2cedd05bf7358370e46685564dd45a8b2cf699cf5e14094c5f6800ab0366ed8a0429b8c12db99c48308835966215919dde5376a846b6e0baa351d6a29e647a716d9accffb06e09dc6614da709cb41bec54431f389ad5bde2ac6e7194a841730b60e894cf2fc693ea70fd0c0c8dd0d09d932d0ddafaa3efdfd05da93b4c55da3dcabd8dd89225606c5c907e4cdee5f05182bd6af0f1be92d83c20e75f0923ec5abe2a3da16fd621de56b32b7fa8978238981035be0ba17aa949aee2dda6872caa545ee66e86fbeb716158e2bb0dcdcf82e78b551887a5d58f70df7185720459b893984d2a8e806ee0d47f7b7eeecc4731932f0c7bf800ae04a29f10d9941c159d9769a052f01abd3741396fcd644a20630fe06cb7898d3fd063019c1d806c2c8152f47f7c9f25157b6ddf270030cf191ff21d271b2c01211937de05d7ada776034b8e12480b632ef26bddc24014aec6010c79252171699c4b1811dfb0487f49a0024823002852060fc74a094915d9a579ad03559e218bd37bbc34db8d4899fe8c8cf65cd981c0bf2b1c0b2b94db948e21f4a4e2bd3c5c0789735ecb7e256f84638774b17fb847ea2643ebde203399ad550ea81830a8ec969fa3c99bfe75dfb10d090031667167b4924741e15fb533ad5533fbc290e108f30c31e5c48e71a305d06e4b3b0c800a3f50049cc8b3834df99d73097ba8482985e5e2bc18d459e5ed23ec87b969df886efe245e676baccc0a42a9dc5fa52ed748e7e6a47722e357dbbb0971b17639cdeb994e7ce0c2c82275a384576516d975b361fceb3302b51aea449c3d14718a4013304d4ac4505baa8976ba667e2b59f88a25425cfad710dc17e3090ad427d87528c926c49fde3beaa19a330717f4f00b664c6e31117b3040249b3fb6c0e673717c5638991867592be7efc1cfbe8865e61dbc4e4fea9f660663f86f6cc42299ed17fe05e17e555ab769d97359522be6c519da26de25cbfecb591a92b0002aa18f25578063bffeb3d30ff7e3e28e9df545a89b6e72030e5887f270e8a25da32309ce36514cba9ee41b781646ad509f79e0e1cd780003cd5a43eec653199214a261d739696b91b63765ebc2323a295831e4b5d67f99b5c2958d460bfcdc4a69cf68998eb46d3dd8336615e9fba5c5de3b379126f5791fc9f732a5ad123e10d4b6ac33a1c7175524d52375c0db6ad4a81335a3a3228988e6c186ac08f7e9c89c88b7f8d66ee7391a775558db039f65b8fd28b979e75e4ebce9042cf725d521e5b9f226860a876bff4c11e875796201b68be9ff917d7ac1f2bde9caca3d52ba2ff36be33169d0ceccefa6f56dbe87cf1252abc741b40fbd07da625bd2bb1ff413a6b25d7eb7e99cbc10ad2f0d3b3131c88be134d7a3e30a87bf86b7ccd7a1de78920c496c4b317e2a7ae12494a1c3e6251e73070aa949ffea468b6ac80a55ba6f0e43e3de9e0d63183d669874a199a8f20b9a879bfbbe98aac0f45e0fbea077ff3b7f27760513ab9f9561f59a6d6ae29bdf9783778be4b43400f9b21bf072b8d60d8f70480f8f545b42f44568092b993331d7fecbbccf8c74e606681b0f41e8ee4c2cb9f49231c78597843bbca2a01c68cbbb6f3572d16d7fdef6c4201a871d9570f74cce7f3bdc77eace0b54902fcfcc6953c67b96860cf689dc952598335513111d609a40bafb0b367a897a4650faee03225fe0076e20933a0f1db24a88e26f12f30e24eb5af4155eca0dea4ac03db27018ca0d64c0d9a09fc018e211f8a1e6243fcb6d0b59c844ac048b074bc42ec7bbb72dd6231e052dfe3ba46b8e85b0544b8a581cced039b9342825361c571390937bb72989ec4c1e4695e30d48e5e486eea6f74f2fa9657531716516e320e3d9c2ddaa5a71de0eb933f7143e5b07fd28b9d3428fba119219252e68d032dc98f219add22cd6f7a75cc29c08faa7a967be4e9962173565d24377a1f22bb7c4fdde417bf3d103d862ccf99c9f6e3bf0a31477d980e3e5ff075a073aa9b7a345ea3ea091dc32cb2cedfb8fcd09aa36900410a84813bd0e58c511901e796514d5b0bc9eeefff062137dace1218fe7341f885516903c5a9988afe82faa64f25e707ba2829d73b2a85327c1fb964fb490a3827811d347529c15626d30f0c01b4f051d7d6b97763c44a08c38f8879fd9ad2ce55d39dd2cacea89446c09c35bc901468df78ee62b18d9c590a65678b0b3266a94cead4c5944dd0d7d1ca28c829e8b4c9fbee0fa1b6f79e4e04e48cc5add0e1d15fba21e5a52ae26821c1903e86bdcb73a4a69c9ecfae2416ffecf29071ae2d7fb8f18c32ca43b3de16706916b8413cd7909e7501465c8aafe95988618fc19b5d46f524d49da94b0eabcdfa17390d6c8b502bcdc9ac6ff7b139b1b64db2a0ddedf93acfe1aae3a4c06870da75b6c395672befe5f9f6fe51230817406684601780ababa2ff407ce59363af77c71fd564eff86ac721a04391e508af146159dae50747b3892b97d2ed4bd8cf6ed567588af5936a8b19322c2b56d07048110dcf6f52b9c8f64cdfae0df5745280a7c810afecf78a9ee6d5e04b12ac4cf36458dfde0079ccd74ca51c760b3c6311f1cdf7a996860b99ce6406dd140f4101436d4255c87888aa5b524ab259746fe2af1b77c3fff6901f8d511a03ddb9b4c8c9065bf4a7d41dcdbc9964f6648b5f0452b76397467e29c0c5a98606fdef1c765bf00e0832841d47270aca19a7f513ab415ad883fb807005331dc20942864ef8f358cb9f992839933c772da08e6b5cc0c82d9c786a9f66ff56f97ae6ca924b675a6821a4a5ee118b92879331957da5a23a2c69ea0b19e93d9a2b953a9d0d8de45ae313ad05c92074b81ae092fb24d013688ec549987206b057552bc02ea4660b02133ee86c4e2ae462853248e78258ad80191afe65a17453d37e48d46df7bba1b67307607e0cf623800dfaeb520942440cd47891e895186a733ebabdb529cd8e86c1b1f381fd49285a83153a34024f9266e6dbfecf0af3b66f1d963975b109b6a01dba0cecf06681b77e719befdb8eadb9fc3fd4c4cdf5c2145319d58367670f27942132da68ba49a33846ca621c205467675af7423eee9524dd6a187bdc1ad82acaf1f23a642f8efac3d13816c2899698d5e9fda36a7e7335247597f42de907e31fc0b4d5beedebbf273838b79878a78a65cd371b116b6a5e71fce4c3fc4d6f50aa8d2a4bb6da57b552ef9ec7c08a5776578488a10031a46a065e5c6ab1122f619362d1daaec04b1b1d8b9de550ba848cf05d1b941f5610e509065c5c9b278187205cace1d2dd270d8116b12010feaf46a06b75a967a0573c493eaea3d7996cbf4fe4ac1958cdb3c1011b77958ecbaee457cfe48641291550fed168332505f0eedb341e8faabe74a1d5038430d16902699d1f4dd331db6956e45c009a276ddf40e7411ce4079f7a07ee786113484a3873e36b34decccb540528fa0dca670e68584e759ddc6e97e0cef02f9794920669ca767d9a938f4559fb6d7e87f00c99a0e41073bcd25d218404eed53baf1f689ce9310c51a367cdffcededb2b01d4c643d528942dd9cc5b7394226771a943c557ddd561b589edccfff7d77c1001b0e3fed429974331a7592e535fec364d151ff247e06c34583dc8b1af496b9e08755df378659a1c24b824ef10d3615f0b1ea873932092dccb4ac29013e4fbca33ce4c492761933cbce7a1190609da8f65a249f215fe3d3e285cd8c3919d272c66e6c1860ee63a278ba1a95a5a7c7c3151058cab6bde38c9abab3811e470785dcc1d5191b64180e87f52660af2be7710a1dca7f77d0f2e2cca41fdd1be78d4ce8e7de5f1a02fd6bff6a4ac1476feffd37fddaa020de5104d1ae6a964383f32b952c00d1efbda5a31d73790e15cbf6e0deb113340fa5641248e648e87040290e8ea7b1fedc5a9b4b8b86c8ebd35d28381ce504c06e480210109105a3859053135b46a131268916a700b58ddcfb91eeb9a79b113fd1180dd16d52e12e8ebb94733dbe937ec585cb4cc2ffc44dc1d6333e2b649585312b0bb2ade53437d2779dfa4053b393ffb6be078391b8ab4831e34fbace1cd8665e27e6c71f360f105da2d650fc49f30ed3f9fc4ac18eaa5a800a78628954f1b186cb12fe60a532616e6352ff67183d4d474374f0e3e60805b396d18d1b62927fcee874e4faef224bb1ae39acf6dd4cb4b230da1dcd348cc002d24de4b772cea29ff7d26431c8fe8ff6861eeb41638509855bfed533d01b804c509d40a4758361f2fed4f0e2b90f227850b135617cd21a758d5a973fe7d3df4ee7e835edc7ff667698d925b164a88146fa7cd9c0215cd7dbc1c441d746ea7b67204743581109ed86905fa6e04befb9778ca9036ef2e6cf222210d3ff8325ea1af900279b4ba03f2b1e20aecd9933e91b29e30b661f3892ea6383f380af5e88c36ed02654569b196e9c0b9c5e8c384a267f0578b72b00d1f5796c05d22f105ebe4b9853d3a65a66c2fdcdd080d7c629c7380b3e43a0e46b317c741903fa104bed4b71f6d9819e1b28daf842075d771d7e94baa1465d23e3352808a930a8e40a916724f9a9507afb3d4ada0e8e6d8e181d8c7078b05cea3ef35994d30dfedf31e97e99093ba66ba050b42c0d9a1385b79a6af289ae482042f7257956528f18f20d49654b72ab227cafc529f89037686817338e9b2dd4c899f4b76394ee01e54e246b834701e17eb1746a671c1de830d3f998858c63ac4ca2fd72e8f47f8df53fc1885a5d58b6b1b6a2e09f2a7f0accb7b8f85ee757f9a82dd983f39dd41ed1db53f3c79196c05efe67a66cf4bc5c52d28e640ed751499d9f5b35d0fed94645edab3c8d1fac24c06bb2b6629dadab110fc6dd499c2a815942ef00684aeb53fb51b16cf6cfe5638cedcfaf62703f2e89f9e50df64c5361da88f50a1ca530846568d068930cc9dc69ea09df4ddd3ead96fe02ba05f2f76893778e81469bc4c9ad0bd5fdf8dfc265f0131c1db66cc0675c0d0953946be93bb93003abfadebb3371760916466055912528c58266b948a18626b81fb269577a1e789f7bb9ca8bc5aa2b1c0d9a76f20a68a6cb5973e0a52933291ec1de1bb3fa7546286671536b610047beb7f1f4747b8b5010e765e65af7cf91bb3dabcb3a62690b0d5eb0724a62d8179a6ec572832b0e63ad7b8b4d2b2a6aaa4109a9c9cad5e11e66a639a61d1b05338eeb41390db348e693395e0965847013246e7ebb86a17300ff798af4e522e5badadc78dc6875de46f57f271e5965b67dc4d7d5bc475e1ce446cabe437e77f3202fb9371aefd0c1426b9670ca7c6e3855f60094b41de5242f32921174dbb9e237928e6c13452d4109525a306b8ce0f81e28c0b57189899560b70049c75a6b9c8bebac7fad4b91f2fc93c4f57241c2f0b4427e38051825ce6e9b2e7314a2d0efbd0765d052043b60d1bc8c7ff8bb15630ab196f7864bb6657d19bc4e66650531d986bb69a16cf062a9e83e6a7e726e9554b68ac1e47d905c8d9080441bfa3ff4514915d294c387f537e4cb94ab495e1db68b4ee5a7bc1c15739a48fab81c8c4c474238f1bae206b03acff3ea0ec40f2e8ed11221c0269b0ee8f0193d2c7a259a448159558748875bab54b978b4f7755794a1634cbd005086918e82c18992836815f00b1c9a64d6bf92575fa2bda7e34d0b51bc532daafc1871a7b223b864972552e882a3c4a5c6c5ddd9fe907ea22af16295b1c41e2d9a2da6b6f9d9e7608510697742f4a3d858f98e00c1710476c6e25683e63a51a4b76d9a16c21f5be4fd0798b41559aa71173ea176f35452c5097a0a47fada1b9a61c4d935e30ffe2f75e34b8f2e0bf3aaab04bc7d7b4701bb9c7e2b91479b7ba69de74443d2eb482dd24d2ff27dd08847cd8a84e79f0d4bab55a62ce670c98dfda190528b275cd87e13ea3e5a9e2dae4a16011580f898b739e4b0721590dc805b66cb42246b2b06cdbb9ecadbf9bbef0dc85126bb818c856e1e3ba3456cff9050b1a9b1efcb4a661097fb33d42ab204b42c1564d130192a0cea7e0684c93e7da0731ec0cfa7eaea0619b3b575779c0fc8044580a6fa7660530d9e0359ab22b68d5728928c905507b921311259d8e84addd9111340e326ce28b3e891c46fcfad74d9c1612aa643faa9f3c2f931a2226f7589b8cdd789be832987f353364c1f00fe41055ecd21520b6de9a56e958177adbea604c5abe3fb9d364ade717d66bee3ea47152db49c4f0dca1459ef3837206cc35daa1b81018101ed8ebf3ccbe77a9e72ec5f3c7f1c6eaa7509b7bf99580a0bbadcb52148f2f2613b5827f01428e82a6b571de87ca7aa3a4a98ff4a49161b44b6bdb54774a95763e7fb2c148f43fd57376f607af019e96c9ecd96ef5eb806eaa0eb46166b81a0c12cbf5f48c9aac18e726bbd685f71fb990dd65dc6832dc39566fb8d664e006699f60eb548ef65704979db567d2d1678e3afc416786ee8e9f54af319bb83cbaae018c512068bded682f24c7fb24828a5ce81c80d85573998e5a8e751e2a468820c36fa0a00934e73762bffd4b769bd52502480248afbaefd92f4ac99b9b1ee0685449591faae03344c457049b474928ddb1ae05ecf59019df9ac4a1c5e4a21039d7e6670def293dd14388a0d70d60bcc0921e3192e8bbb34a856b778169536bf87ad83b4ccba8a106a4f61666862549a3fd5bebcdd4dfed42145d03ef1213bf4b9817b9a666b78fa4f051d845bb43efbac6bfb7e10093203a8e76ee502f21192f4b8adb52a4f4139a3fc07f264318501f715d67f4f812d3c968e5ec4b8ee96ae2d1e19f7319713bed113294c4d3283cc772e08a99dc37052a8c1d6e3120843d451792335d018b2149fe2f575e067f8df3f359bbdec3c372210adf81f186109a13441f1f613bdedbdcfea340f508976809fd430aa85ba4b1a24a2985a91669ac2eb2271e261e0b34a95c17228523d043ec101aec9cc740d008b32ca166397a842b340beaf61d86aec357c394e20c5e6bbbe7869e7f8be0c5cf83e98b3a62dfe32ccd970d7f40dfcbd7498aed8cbea54cdd7046e6464d62b83642c24505bf6ec95148c77d69ae3321b9be18f747ae8f331c2eaef4860d3d8dcf0cac0ba818e1f889dd0f6afdd5b7324a8c4747b606a816233647bcdf3e10e29fefc8c1c4f5ec2f61d4c865e4aa45240edf9c48c806acddfde67e51081211052be89f3476570a957035e73e064b15294b720b9d9ff0ccca5648e19a99f870dc7cc999c96a96639b56fecad5ee3fc01fe84ffc21764563a02eb667110d20d403c85a9735ce839b09b6ede1be46ad17e384199deac34ae49c302b3231fbdfdbd7cad059b54bd27b1c1779c49fde6c30cf596b213e2dcdd8f22fda0b8fc08a6f7f83bd39c15d96e03b1353d396f6a8893ff9f65758dc64a38f5035e67524a2334d31b71340d1e89c38b6986a529cd994b0aca06111a815f195c5f9605ec4a3d08b9dbdee9cd5f9adbe2f8be2b1e6ef71022d99afcf3b324cf873f2342dbb9d3f2f1fa49e72e577ae476860bb976ef5ba33f1ae3f3058cded9dc6f272ca56281f69c133ac2078564684661ba0d10148d01941dbb527f165eb55481f997a07c1a77675fc4d263e8ce5b415a1350283075ae0965939956013a485353f1b27d3c5c92f9b6c9c5ff3f60105c4428bfbc5337a93fecadfa498dac7ca1e17e940ef22f663108492b0f9bc6da55177b1f32e6a0968b22e3b1694d1d41197f4eb53f85fef6574bb1992600a5cc8e5bc97f4a0ea9f33e2e41ec52f8498cfd143ee9345a54b9c86afe4d7488550e4135e13ce0bc435900e7341bd13d2a80b8e784beaf84d20598f1317e52f80994e4daa56e579bd3e236aa7f1400c21d463200e242bef934b85bbd9580fc5661ef7eb1c2b640654825c202f8c4f45c75fb3d8c87dd2899490445c9208e23edd873115ba0d982cc027535b68d7dac3ec9ef4130ee958dc574caca21404ec3b470f03e636adc254f89926d7746e106816ced4f1ec6ac50d26ad40bf576ee565fd0be2aa10f7e9cf9b8637d6918678fad4a48fc784dc08e1cdea8e78ecece8023579211b6f5c96c191caa45db91ad029d2a9393e4d67b7cd2da6d23740b62ae6a770068ece96d41c92f48b55ca191ee0ef3c3e54a5f4d973761e7d791c7eb1a99a120ba83fa45e6f5b368436f9aa65d85b3a3526dd87105cde1d2a858bba6ff99f7de539045fea60b5315f88332ff3352ef37004364722357e3ddeb481ff12044eec7c26a3e55fcecf7b1eb7144c41f8b20e4c54704e6add83485de6e25020b9f1d795fcebd57484f4458041e25e508192781d12872267c6caa4da401d8fdb225031559ba10debea6a998a1c3b1da85194593d34ca7e2d4859d302e8af7256b3788d4ecb2cea2ac5901b389642edcacdde48399aeb1bfbc7c7520d7f9c1987f7517984348a7274d54387eab737ea05056baade72fa5d7222a1c5b9f2ddf2cd1be6e1b9082f16725c80618efbafac1b41ee545a4e94fb6c336a2d79f6650ecea6d9e02a2726d233042b90a675b0ada098d4b4980459d72d41108e421c7191a746bfe986d4400cfd4282c95e0a357eea55e0030259906cc701dbd81b9b4ceaa8b7a37ca397212fdf25ec7aefd2099f10876e129afe9bb2f3ae517103f522129ef3a0bd45d16d1749479b6963d8791c82afa0e1e3b97697e3d492adbfd1fbd0dd086efdbb166443866a52d8fb8239522f38a50c89cd3dac335056a4a870f85f35271d54aa973e93e36b644de7bda4c892e510936289d1f07f10af6af5160c0879e9ffbb34bf760eec8a5fb207a8ea4b91440580974716e38f42085b742608694912d7aa796cfdf7bdd7b5880887a870ef60a2827d8f10f1a39cdea1fb4246e4a92df650a0048854b81c25e81b43f7a3aabc4fb863e7d349826e520244c624290f01995549892cd04fc95eabf5c174339c7c145df6b09bbb7e823fc9a19a848b3dc3d71a67292b0282f90dab4219e9ce9a3bc1e367b282dd4c33b37e2a1845e67e6c596a2bd47b09f42cb4ebc32ccddfe7b5c21e67f6e13d5ccbdefca907fcc0c26d8f19b29346282d6627ef334b9c24029d4568d41e64fb1aa310748c035dad7b4ba84c5d16e4c29fe02b40f238ae7459b87688ab0783da37959a84e53d80b180508ff7049080cc6b1742d24b38235c3329054ca39a64d3c48a16584274603b8eea59c5fc97030a9717066e3c3fe64cd6317a3ea6157142a667703a8b2f81582e6731d0f94b69093966626dbbbfa65c2e27816533a94cc248d25ca5aad783a972d6bd4b8ad4ef7b3991d3bb9e03758f27d479ce420836d5f81e50b1ebb21316d60c16216de14aa7c9c8c4815659e1787b5652afd1b5f3efb283f9e9f0b5a81e6478e90fdf10d230d1004f2350ad591fb3d0743daf3261c569f7aaa54b0e5763387fe06b19315cc861c41695aefe289b93fca9c7e86923f235a787945c899a99e4b3d681e804fcfa6fbeae7aa84c804642825aeff4cd8467673a36860b703388714e454b36b5710fe55920d0ee0bbe46c8b5b77541d8e263775da7ade50249e24d86d28286e122f637162abd9be5247672f07cd9293ceaa8068f373ec93379cc1edae1cacab2658d4a8c990c3ef686e379c2bdf0faa5e49a17809771d598a7b4dd41f0cae7ea2bc730824eeb5bdeb61a8079952eb35e55871fb0a20d260d4e074acc3da6bcbc13cce0f0edc992104afb89b280aca2427d8650f5bcb4054a0b6faf6f0be454175457a6aeaebdf9a1a65270ff392ff1b4f80dcd85a919094da4e80e5d8b1bf8c38bacf9474934e01db74791526ecc57a12776bc6612cf42745e286cafd224bbf07a11fbeac7ed54206c72a2d1590cd0485d26c7a5c6f5233c2dc7aed0e275570696f9e754b925ed4de1be939637a919f902022b05f16234accf4b3baa2dd293ee4283162be14cc96b7e77a3843ab18187b395f61214b6cd09b71dafcd5d8021357c21617e95686b047872154185c63e3a0c1e1b7fd4ff2d3888139e3b0c8dbf19a1e3587e9371ec32558e3a51f3b6e82d88768e4bf4c196b90191ef8863cb066ce1096d7d938271a320912616041a5c8ebdf67ca478a8d94987e5b14ad4e32e48fe3ffe9a474c83ed14c1ec895015f5de8da769aae690298b7ece7961a381a87b50730e20208e2006d8456b2a0f21e307412b9c612990d84f77fbdd6658562f94a1ce2db95213fcdf8d645de34b5424a7412b601236a915af956ec4c9a8c946741f8b179554329e3fa54c55cabd0623f2d557a7c9d6e3dd197aa9fd4ded1c76e566faf6833aded6c9f6df3ad25b2ccecff98f608d125f278204d2838baddd844748259f01ecd9fa50edd9fc6e2ba5cb0d134a1d4ba9b6c3395298f7bb3a2d7da9ba6158278b2a89d5a0f71c901483f7ce715b4af2926f3c838134594bd29b8271c5b1c64d2930023ac11f97637599093289b854928b58c05488d4e50e1ab8aa9b6b0e521f0261790685e23859c32e0211988112492622d01b6ead2a42dc806fad08ae592fb99d624ed42df671806ad368830587a006c15dcb38cf6ea0481ef57bbc801febf117eca2da958b92b3bf10f70d8d6f8e0cc40f619250a0fe9299b403b88301ce6913c54cb718be3b5adb66c3b19e33500c4b84db32caaad320bc09a6c9e6ef3f0c98e8c2a2e3063a7a2e8ab9025342711054afe4ac014dfeabf090e7c84038a13e41ba27471350c6d8180fe9578f915e914bfb95862336bd85ddd9d3edd939c974b11474a9d63314eb524fa4868bd03b24dd4f4ab7d29b7f53c71307af8333636a0fc19fcc50eac25ab3ffe246495253e34cccea98af5c6ad3da81a1eb232f59595de525e16be41149bc33391d0612d8e3cac81a96d5bb269de54f86230659437a8601d4920adcbaf220db8f14dab0d2d3358d80c29e3798dc291424861886006fdfdb3af015e05aede7ed5a55cfd9fa038cc0db5b4b2e730cb80e9ee183f8dcaf19023561d9dc63a0d93b7e53bb0c02a27403ac33f2b9ad4d86719a5714d8224f942c040e635d3a768adb12cadbf57ee54f0f24cb823dd67aa7b164099330b7c0a9e6e7c1af9a7098d055a2f76e897eefb9c62710fe1d980a5669a06d729b70235cf709df944a38aaf62fcc53bbd96bd677b274654a788dbfaeec1de922f5ab81fe7424a72c03a6e8c173ed3ee94be4cbb1535d005794dfee8252e9540a42aaf622323e1d8b831d07e0c5dcd9395d2ee27a24204671567819ded11d3d5c1a6cbb8cc7868759e26b4101f733811dd3f18c1fb6d51f0399e3f0a3e13a0abbddd53726578b7c6cc5a1e645a9cab97ce0856ee8b68aed5c66cad6866e8103648c4e7cfaa59fb5989871cdaeb5bae98570bbd1d94a778021ca5b1db37b72ecbdb9bad6d399d0f09a9a0a5848bd8a653209b8a34801f011cd0e09770d3489b0d5b7ac554058b9e208b8e2a0b468dafb7ebd8f348fd620a1ceac42dceb1dafd29ffc1310bf48962b58bbbeb02f8f3e769dfd5ca624979d9d495ef31de6c83a13ec55c499a0336f8471944a78a44219d45e76836ccdd77ff267c38ffc29ae65dfa5a80ea06dc55051f0f96e04c1e0e26c4694ba70c7041dd6825be8f91e68f7762f6a723403c2d49a0149e90be204dffe735d8f33259a1332af357c97dc553891a011826d28d83cea6c6a5de7e3eeba581767c08981ed422e2fea86c3d0dc9bcd1360aee975f8403b653bf10e13c46321238ebf302d27b787463ccbb750a518e06357bd24d6e022fe42b37f76c71d07afcdc6cef2a463149fa0b82e6faa50ff9473ea1e63617debf0885f34e58c682ba5d704d696902d5c6b9f895a1dc2187ba35096543b8bc608912ab0b9fa41a6c447798e2f0c77adf87aba3a6a105227496f211c29673aecc5a9fc7f098cd320bd400b38cb251f7d34652976c31b432a15e378fc5745c628b67432f28c71bd78a601e2279022fb6692dcd17f7f2b9d88988925fda15036b02f1e67f8d5959c35dcf0cb3346ec627234f37393924b80770c4482ea6e87b8685b59e2c854b323c88065e04fd22ef629e32f43701310b9926b33044e03be158025e12c63a8b9ea43bd1454e144fe3fe646722e9bc683da6ae1fac513b271ba8de8748c050e52ded142c1f957c3a1458214a3d930a744c2ab93ff46d5ee2b0176a6ce23dd493201d92e2a973f3a02f0752d291ba04e1e7f5126364f24a4087dca52edc73dea2fa3bacf0d0bad572aae73f867fbc6bed646905d3561f9c274b63ad0c9ca3d1d1a459dc20559e99795618f9af42e6f58c05c9e9c6aa2010faffb601122acf808ad8f939ceeeefa722765a656b7a19dcb6c803832bf9ff2abae500b3316563c8e0dd77e70e582af06c5fb4a23b386e6bcfc8efb7e30be543f4b07d491b1925bc4f51b0956eed1bf6ce1441fccfe693c71621ff94c90cecc7bd203558e4823b172f369001cbbb3b780748a4b0ffe2c9115c4242a107155b28590abebc35a175c84b723ace7acf5891d5b4a8f9a14a32bf7cf563f794bfafdcaeb726844e50f7536abf85ce18cf005559bce7b462c3f33550ce6050447c805af4f220c4788e74e675a7db0292032403d26c0d01a8498a2ce7cdd5255fc86a7e08a7b07caabe499a9f28311348e47a0e5cbdf68055843ee506085a1a8e937ec2442c47e8ae6a3ccc04dff95895ad646416ac3010ad84ccdfb4b459d202c42b2e40e0b298a4e9cc0dde63806c68625ae63a53089fee17a95881ba01a9f5fd5436e46ec5b05f5fd3fc0d2bd511f8ac8662da860f127c5f34f8e7c21fced273caa06eab9ef477aee169451aec8ab21ba89e5ce77b0ac1448d185b0618e4dc26ceaa387e196842f3011b97ade18e9bf747e645f98b97658dc0809bcee528c0743d3a32999517f8131057b158842b7f1e44505d8038d3ecd527001e5790b8689ba05b6b50d81f8079c2d33aa77048f6fe159339968bc096f4058f323487d0a947ce13ab88321775252c021f6fe0f4b91bbcb5f8ad96c51b0e1088e950d8447fb5e4b3949543b46b68290500c72639c9528be3e5a5c5839e08c4c528df92d28394ba1ef9c638aa7cda391e37e13a12797db3cc0a3ad276808f5289dd23fdae268e7a9db464e92430988178f7ede753efc4b86a8704609461a23ce0b486d1667028a9399ecb7ce06d50e58ee8286b0d43cf6f38cf58d45eae2f17d38783fb28d7cb5031aafe5b59acdb8110acd0183716f54f7b9afd13bb2528d3b38a7f46073d45e7e5b9ddaf6c28165395adae03ae1b84606e4773e40ca49df6b95409f1c065d440d618f9380e766eb52e8719aab3d70d04ffba0bf3f09933b35afcc967f1c5a80bb39d70df04fe8705ce79064fd1aaffc86a32521e184e3c63100918d611609b58cd0dce44625aa80ade9acd402a24f9ea70566a9f94aea8c941e60ff5438d5b3574bbe4227c23276b381a70570d6fb645b5c0ebb4124aced4b2a1fed5b0e8e7c70797819ac11cda3276a02ea56b8d8c1f0a14e8b6f46bf33b427b513b96d73b73197c58e6fc4d419f0ac4694c6cfbfcacdade15e7daf4ed085d4aa4bbd411a3a140c1550bc431cfb4802205dc1bb96d6a9d366d638f0639a82cb7e3de000679d8aee2cb7154d94d8b82e4d32a7ba938d06e8285d4a2ac84c0352c30d898d1c3324e3e2be837e285df1fcfe0dbac15190804135576a8cb89eca8da2f6e12fb4f155b93df304b611d69352fe5ebc845bb9e9b4e2292f4e60b4b917496192498f7214bbd2065424ee3540af3906f6af7d9a444f9078e6c6fb97216587d1716f12e0981ffe3ced5af60b9fe39abcf4a664fc9dad34df2f58e938b89c64d8dfc195a2689026f929234b9974abe50680edcbb0579254f04e8cade68854de3975a3264c257784972c716446694055883ddd9e12ba3f734ebcaa641ae8dea239e0d47b447945ccc36b6b46c86f354ef420c78e363d520648d2eaa37443100476a045c8f26a205789fcbdc3eac992a121142a5f356bd19a54dbbeb0437265706bb198819523d67612c09f6cf000bd762bb20157d4b8d365ffffe96f538dc6e6ced0c7e160528ee76ce37d1bc1af5c1a482d2c1eda61e513bdd57380448e50ee6ecac3b11e526320d1a080591ed05ea92b39a86204354590acfae19462a20a1249a5045c6ff7d133916c4c6718bd7e810908ca2446931a5e8bb089b915a702e0f5aa4d3fea25925abb1f200f84f8c49f3bd6f8abdce05f8700ce3ff04a6771d4587be522d35f2c53ab2bc8f2abfd881b98f74191d0dfa6548d1e00c9a5b56af926e77c5a4fe38bc0fde4fd8cc25cfff753ba4cb3c669878f556803cdfe53a5fc354e1486ca2bd4851aeab2aabc01adc0fe840bf081d49bf559b62a18fe3915adac615b55c8b8fc7caecc5c7480aa569ff80d9af75ee2170f94df6212f154f58f6002743304342f21b6af2075a601ba8e05022ca28300861ff1126600c1b13514bf0f9e3852b6352b31c910af4ecc9bc58150590203c3cafe875ab4eb1392c5075a813f98d12b978a68a8e708e166bbaeb4f66c06be67562810d865fdd1315c938ba8bbced0954b2ab9a780aef713f3c5a4318643e60a7419de87d202dcf9a38a778a138cd12083ac22314e9dacb5446dca9d11b022dcb65e22e7525e06c96f77882fe8d84fc32836f3630d3985c6c2af01778f379e5111b2d9d6c6061470388cd2979921dda088317d6b4b0ca2d6799b617db776f3de7acee104b330d30b271e84336b12cc4572b3aa726609fbbbbbbfb0f1bb588a171d8be38241cd62ff92de25c1664e260288454393573bd6151a6b05ccde427f198cf428221d1184aee1742adb5d6177ee8f788d71269692c68904bc95fe3781edee57661a179eadd7a46b5855df6d5a8a5dc0751840020a5b40034459667a63f4390308d7b9e8c277a3d8eddb5e45a39e2a06f2a4dc2ba2af4e5bf3998611e8e478e75f121f177996fcabbd1af64d8808ba516593a24d0ac5efe55804cf57a2fa6b85341005d39f0deb2824dbb0ef6e1831a50bc43bbf6ea51d016be50544bd74bce9c015da155b842344b9fe2c5044e49c98f37f66aa260e88127eaac365195e61822808d2ef8d7cca4bd990b2f415a08327a57f50603cb2716634efdd0606c42f60e0bf0a2a4c33db675024425160ea6f3d4f4eb7b4ad432e20e5043177b60b6de4c41682abed847667a36cac2aff7c7cab335b7a0f106d441914c321b1ac47dbdd028715cfcc6f41b3bf3761f9e6fa7b616c69d6151051d06d28472731afd53a68d8adb2098f969fd69ca2366b615eebf2b02e60f72f37e7a34bb1c77c1daab830f5081627bbe7361fb1adee82c38eb6dbec0c83e59ec9d631581e7837bfa0efe2c1f2488e4916796f0f5f5f7ef29ec4a617ea9170f2884c19c2ec22b18b33cd1379a7e3de32ecb7b52648d78874cad65b4d07ea6a7b90150759f4865b2f8d88876279096484edbe150cd960fcfed94d7377343891723e710cb62719ac6a91e8caac660896804ad933ace03f3f39a8f616469f5180b433678339530178a31353d7c5fd95707a519b26273b53740f8cb2c165f2fa18cf5e99cb53ab14ce3fd1914fa92f249bd7c58e2c66d8a1a2f389e10b278abf63865dfdb0a19abc45feccf4ef6b7d297805dc3ea602e6fbc4543d1c8136d188ad615b3e83b4a672d6fbc7847c4310655965467ac5f4332f5f802e452a8eccd26d7e6d468f0a0a18b669d542f769e75cf1bf71ca2365a13710f9a54b829177573f259c104d389c7a223f17c2e3585624093dcec11b6032f1075ae57d183a6e0d8a8beb1e5a8c7b656207b0fe7a41f004e79ef99096a3c9c6f138bdc8cbc1308cd38dec6600e00d0e62f5fc9ee9808ae9b0abc9a3e80f576812636c1500281d7a06344bb27a076856ab26113f243c8dfbafb3de8a30d59d7233bf0388b144534798796e8612f38ce27214aa79ff38b8eeb41a2d8573ac83981be54bbef76d1ea72721ab99eb09bc69b620be8dfc40097abde44700bdaf588fe8dd42284de682180b26486123b2ff3bc228deb282efbc2f950bc6132d785f9c2ab2856647a58c5008be9cfbd5eb1e22cf7388830c00e6f3988b1dcbc6daa37a3ec3c034f152a04e06d2a00e9cd5eb1ae24c92632e889031dccb7865e7addbf0adfc1d3846286acdeae27b5d284c0fe656e38902da73b873bd9afe7f6b2250b7c5903f7767b50f0d8f820a166eb847a1848525c23fbb47f2822778f50b4f799a8ce2f6757affeaf8ec74623ca28156b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
