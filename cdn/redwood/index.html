<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1142f8939897c4057d83e3f6c81626c55559828e7eba81ec98ac3727156f0ca8fa6c05b95421cd16f78caef2db8983246cb08911d04c74cb2050183cc79b29ba3da55e978f1e17b7867a03c99b433dfd8463f47860402308f8815dc974027c5bce979f4d94af4bbf9bc83047c8d27f01ac9871fa0b298a3ad09c7a1af0d555e12e3ea63bb7336a81613f190b8928376e8c418367cee4590ead746c1913704f2ab26df1f0a4c0848f6d253464c74fa9e913f883e2e8f3e7010dbe8771eb250fa70c78edfabd5a30b6aa3018caf1c894d2557fb01e025c035bd1dcc6b1542433960a6115176a2b5bc004acd7f11eff3e29fa55b218246cd217679e77d4fdfa8eeecfbdf24001aa953f504110c7a64eea7d41a68624a3730cde1ac87bfd4a8b42aeb4807aec0887d0aae831b19f7e52107ef9396ecae1c2b1a73db70d998666e1f7c45ce3818cafaf81bfdb119c1648a11003e18e91e9173ebe6b4feca995262739f4a9ef905148395a0e8e6dd60b912b78a0ccb29b976571f1d9d4fa67bc24b12ea56695faee139d6066cf2658806df5bc6446d32e6a358de017e177bc8d89e3ae6ad69e902ec7bde1ba6d5bc46715b6d5fa06b28e660c83bf0d3981a3ce651969d8f9d56b425470d2ea13b105e6ae7649d14766fd5958d305673902f78118c0a5cafb2fa5d709fbad1fc4bad514d0140f252364e7ca7dd70ed671fc855b5f11c114a84b7df13883db6a9a7b7b14445eb08a0264154cb44c4ec48842cc0788e4dac2a192bd0a61ff9b9471688d3e2329e208fb3281eed12ec5373aaf76dc6950c28457b1040736220aef9cbe4a027e694b54531b052a645e546ea83955eaf40d29204bdb24e7480fe7f2dd99935eea4d899b0d0d5f32b8974555a6f4e1ab2faf9520837fa4ff87e8103451a8b96e0ce846d78fe8181dfd2de41e6f4b54c305c4df9e30a34d06530a4c984a5361d7f8b1ecaf15fd83fd916824b3242d393451b5b5e878d10d7cee5f83f3ea7a6314691e5aa739638b58a9d88082072851e8c535ba34fee844f69bf168f234a2a73aa9df134d6c8f18c9c327a6656b295b195dc0e75aa3c38cf6fbab6055822c7c3564c958cccc700d25c4adacf7e5e9181cb35a9fb7d56c10402632e39c239caeec7c1a69759c0640e4920456f0dc1247b544c971eae793c0bcd61f1306e67e30b3aa6bbc67d44bfc0f5977a3017d39284d7f286ab4d9b10d0fc863ddb9c7b2d14aec064b3ad937ba8507e2581798032b56f70b142a478494ba005d1117bd5cd3e399d41fd4a59ae8ed12c1db67f6ff19d7ccc3f7674778b270cfcc6022204de09ece7a8e8b4e6afab61c843e73e051e88408ff5bd345aba962036ff3eb776d61cb19f90c055478ea43c7d0b59cb36721126e5234c06a3c1625a14566f98f99192b2e4fb706a6b70fb6cdb699414b1d01191ee26c15b8418f0fb929399cb1689429c61556bd87650bd8bd95dc55e065c54f342aa29340c8a4e74b2aed56e4c52caba752bb920b6e600eb257274873cbfacf160c2efb9764555517865a3f9bd738408a3710bc221535936d9b1c41deadfcbb1abe5d815a84f53e1db0f39eb15832ce78dc687148d36c7f1b3b928981867c38ef7398a48ef780f6ed91dd5e72780ab052f6a7092f49b646a26ad4ac596a1f0aa445fdb9cb386c7f6545d51ecfd3b213a1fa8fe802b1c62e57dbb7edc0bd1eb6269c18dc086a85bd48ee1c9b54ab7a70d0657df8c0567aba5e5a307598978ec800e44460a8acce0a032ebe3e8429112a953ac56c62471c755d709627217ff40ae809671b484c3fd5a6177b048ced0a37976301f69670e6af8ed7ad5f735d4ebf9dfd8f38488e9946605abbbab313c14263234b3792de387e89b582ad354b48cad2fe79c558dda54fa22da161b4afad2a2140181501131f9f1156f25068408487d955987cccb4230de574bc7e0aaa2b4635c6b62142aa6d998afb4e0be76557bc2998a762bbccddb1109b4392bc5e07dfb12b939341db998d3c7e73a5633273f9de83035906c6dc43319e8d6b3031aa127f2da2c10fa2dbdff339578df6691cb5b2940432578b3581693a40764f5d220c44dff95e08e9a14f35a5b5e204fde61382a25fc1e39e1082eb6d9f92e6e5f89bb0fb02e65e94f9f4c4ddd0ca9199911221701a84c9bd5e2aaadeb156308ffa6dbd18459070475b94f7d8840c405e362f5e906416bc50eeab7917e7e304717b1458bdd14bcc441874a0483be54da4274f84749150459bc000f5421c65809f3b8efc1ae007294966e03f0570a4e537f50d70f5b7dc00cd9511e049ab6140917cfa3cbf03be22e7d89c2729c430d792202d97a7ff830dfd0a622890c6ff5dd11ed804f4ab6921baad2db9ccfd86cbf44f276a85a61120dee3a8e4a2c0cc000b06b28e82671a400206750f7be4e3086cc0810dde27fcaa72d5e2fd6ba5411e46bb3e5db3d002bf8a043b3bb860dd63d029aca5df8be94f20938f798e0a6cefb3d6f209814cf24feb18f40ad0dd3052c866a24e1fba651d3f222e16ac612af08bb7b4d3df3e20ee108b14c970a639c21b40a700554cfe1b7fd52ebe4d6ed436069fb04fc6bc612c723af43a64157365042c234f26da35a27ff2cee8b62c61c33fb5837c2a3c4c28ae21678508facfa257a3f536117997bea09fa4e8e515ac4e5e0aeb00db84ef5d8c76317dabb2996b2032afd381cfabe97e3a7e19295ea18fe4bd6e41653a95b8bb7467b9a400d85a407409aa1d8f30e6b01ff74f0c0269dbf94e51d18ddc9ff7bfda8637aa86bf803739a0726e7afcc24f3ad7b97d556017a11ed4175791659f40a938e7fbab51b03cdf74087128be3884bd395bc6228ad8108f5c14793af81a3dceb5b27e37545eb20ae53a24aa3007d5cb6affa060243116872dd719d84ab5b848665ae02573872e9f0fed4225ebce600e56d1db4575b9c0e4a006d6e711306edf8c5ff03400302bfccfe493edaa9010d4318252eff70d56a3af196dbff705abd63e9889370b252713129b37d4fc784814bd24fd0f3f4ac16dcdb463a76a3b946b0c03c69515c5d3d3bf1be2bc548cd6aa36f9ab6784b5561936c0ebfa4213ab8ee7a1ad1fc2daf30783ffbdb3784017ba89a39b87ca9a04500fa3faa534a5a63d70ba0fb1ad4e501b8ee2448795de16ae13260ee7c0776542ea3ced7ac1b10e9e7f314b3d0b3be5a8f7363cc8a2c4facaeba51e9d84bfa32a68636a4ece778bd03f2f0abd7ab17442c1094f2889aacf080ea4a1defee24991e38c978e49fbbdc6ae249966401bfbbe964ed4a651d98c04bd11754220864d4465ccdfbf8715f55a3dc6da0326a315c5437a3ac99a85e8ef2130bd15295f7737a93bd1e0511b6663370dbc4dc05eac101628929e7a6571af28cd0b6239b904ca486dbe0919e90f3eece14dcba3c3d650b100261cc2e68e86813355b56d1a3b45dbc2e723393ef1cd2dc3a1a6e84dfe7b819dc8e734e542b9cba7bebd5a96c994d0dde6bb44fe48ccdc2c194afabbf39dfbaa05f472f8f3d741fbd5dd05956d5bb01d21bd92e2a7dc7b605864fd511b1664ef172db57e4f3a8d3a9dd58a382241864029d55b4361891854ae46456ae35d6a5d1cc7020d4a04b220af9f6e99713ce9d188805e66867b37103aae63697a9cdc99e7ac620880073a340c24dce3ebc2a0684c3c12f0d47bf6b8ded7b2f9a595b697095e29ea8138fa0b2aabb9c648070e65721dde050cf7df56d235d51aae5bff26a86d851789961623febd2eb3edf5eba47863e6f3301a83c4ad0771f614d6576b60cd0e31897126f51598b229ddb377a3800cf24084260634b9e76e875e38d7be8c9624a053ba9483f127236799079509c98bbb3b5e16e8dc5f8983e5bcc0ff6c8716411574aa1ccc288dbf1b2bf1273c5d8923808fdea1950fe007345b21d474d5f7bd28e95a02a417ec6a353d4ef4253e913a13750b73b0de576ae48d73a2410c0588c7be4255b3fbe0e5493929767ae9af55c4ea2cc432dba5f61bfa9b1ca38ff168fbd1e6f0641f836142739b23c479fc04ed5c68a47d4198e0ec41694a3126d69463c853b509dcce75890642de75f26e7d083c6709c9c40ee995297cac72d359f3f0c62610e7f8d78558a2330635afae28636953f40718ce494a55b99f4810f72beea40fb68be4a6bfc30279cdaf8dc4f910369623dca7a1886d8bc91b3997462af4340b8cac91d08baf27a5a83ce2e7588b1bfe098be10afa399974e443d4e1e00c4d174d0ea392eca28a7881594c6b6708edcda91edcb0ba026d8f376a0616828f7a41758c19465387e3f199d68c2044ecaad9df78d1fe4a89161fa02f4cb2d6313f7bd1abf3bea978b90ac0507088ca1af13eacee6931b30b803bb94f5ca8593c6d44f3229bf922e7c14a9b82e2d578bb81a422af236e7a92c93553603fa2ea734b2b07a4d749d4162b782566906e5807cc8bba071c0cf2bdc15e361612afb523e63e149727ba11abab27cd408c40586cf2b85fdeae4192971a1a46c30793681394eef20754065fe136b5e7d2740b3332a61069f371a459bbfe911f193601531ed5b5ae3c4b67ed5c48d44bec919d7bb7f0d7256c243a031f25b83674a8d90b37034149c0da23b6da7c7f858b812cc2c5945e0b6956547585b2a5419080308023ce059ec6e9af88bb82257d946714ffa27bb44cd1059ed0f24b4c9498015323e71062d78fdd567f5f78d7fc7f1f4fbf4719fd24fea977aba48f0bfc891fc3e4fd132396d7108448dffb814651438d9b48a02afe416c121d3e737fc752ba53fef8a93e7090d0498e466555a29fe3c378439cd15853c6686fddc40f1485face525ca0cf146dfc083eaa35592a65a5b4b1271a4a4abef6584d0fad2e92833ec7d8fcc87c5f167e3d42cc1e0e36881c0cb8c97d6bf0fd77a6bf15109be6aed872d16e9fce284399a36808a002b4de04a685e3cd641bae09854fb8fc0e921f9b29de91f32eba7fac3b7ba1d85be0b3ccb0cd17f4743c919943a04bd2ee7fd4e381c6a729b9a36d5f08a767592bdfe08bd646252425c57e8f99326aa5ad292d8da3055e05651f8226b496cd839423f78b5f75490d182260e9f785640753e2c1e6341f2b454ba1e3c64ce1469327a526e44e49ede69d3916252fba7c8d85490effc53840bb1822c606470fa0cef17c2d4badc887ceed5dc4a9f6012ab8181878a5f1783f17ad954e1cef28c82d91fb92372e7a4fd2e4f226de2b58c826f6a33e02d02b72b5468cc3f4a07d29a4777ba28570c2813d1851f0b050e75b47fd974585a58850f0639d80e1d42c58f57fb7dcfb3fb3400ab6a9dc137e5f3b2cdfd826d99449b8a6dbf859b72ce24f9ca4b1ba9ae735e3450b98a6093b16514d0eaf193d07f4de3855fa89594738739cf53c3f2e76d5b1fcee252a2ca5efccd9c46b2e7163a70d6bf1e28403fd9352c04cfd666265c136cf16686ddfd15c323e85100548ef6a65a297bcfc840061a7d09baaa93b8a6f73804f6f09fed5320fe598eb026e1481b58d40f7b2e9dbeedf2a705b4d58ea045067284a8993ca84519a94274ab42950ddc2079fab5b58f517d38200264802d5926324486aa710a25ac2c98fc45a05a4441bfa7b7e21a4e3bfe5b67bd5337a113afb8717984f16e2fa8b5de57b7249953183fa76c97cad8431fce5f52c26c5d588e1a648362fcc0a8ea05e3b3c6f18898e7fe6e570a335ddc26719fe4923d156f9c58a419e9348b823d6f9d889d7b246f9caefd77e291f210f11d34cade612fcdf338dfeb74ad350d1699d4e67637e46d8ae4a8cde566be6f8087235b0d7a97022bb09699cfe99eaae47e11740670029bceec5e89c667406af24b9dac16341298c1e1410d5ea9c02a6ac1a03b5b296047065adb5bfa1f2ce3519b97209616149745ca4117d5e13599dc1cff3b152a34b88641d3804bbaf0f08275314fb908de48988d27c5ed9da2ac1eb202285140611131e196e4d11d3864ad184bb6795f07f03418f06aa44d47157c02e24707b4f3ccb0d2370a9c679159bcc76885db8bf5b62027a38b5322c69ccff622d6c7c53b930435a1cecba8ed1a0e11526e85ff172a32e1bfd656403b9c03b9d091416296f9bcf4df596a041f955681472ca2983aabfe27bad20a96b2cb36021a02fc429384ea2d8636fc48b3022fa67440614019d8dfc1b86b6e5807239082a0b223ef835b65460438f3ead94709a1be98c7d3221b19b99670c98e0b8d4dfcf786efcd57fcb2cd3ad5a3ba43cd33611ec4401ca4a0fcd2b033d277a692c0d5118c49191cdac845356d35e763ab09e503f211310200f46824d72345aef3af7317d510fc6b3095e19e6114604773434fa9dabb17ce52906cb1e208c12553105addec394cdcf1812dc71de6b979d4fa3dc1c90c82de03ac2bc48eca864d5410c0a73e384b67bc7679fd9874974bf6f9848c1798268c24376ef3b4a2fab090155c2a34171b3a7bd31bcfd2bb22b8926bf5c3d98a50d37df5cf7ab418a655f3043852f36845e476812138040d5e8ee35b309891a8346877e6c7c0c34c2e59901712493e19881fa1060788fe984c8ae99d974d40bc46deb8ab73e14a8d54824e795324619e8f384c34aaabd43f1e0db271aea95a3db1e7aec44cb0a1660e7525447762cac9789aec2e4f76ab351b49b4fda35a61802427d2008609c9c948dcaa1ce9a64a060aae446517e63b98d8ce9a0c5e902fb1df1946c59bdcb11de04a927d14eabff9de605ca84b6993af56dd9f3d8a197d00881af3101d32f1219957b3e12aa3d67f6fe0b87bacb1ac2a8e1296a15c49bbc2d43fe441c84d77f88d345721eeeb6ff07bc40496a410803d62984381271c2cdd2957a2b64e26f4f0d4be560030925837406d78123fc47b391d186cbaef69ac75c891a1ecbd8655af61e40316af636f53bd97404cd4786408b6a3a7141e53004c8343c3903f0f8a55d55b5932d135400f8fb15fd5d7e5f2f8d5222b1b6cf3dc946549d54745b992ede666d572a63c2aa23952b953fd8f6814aab31e4c89eeeecb0d23dabb7aa32798548a55992d8c7347e5f6059226c02789d5242e65be3baec156ab7dfc6c9a6faf8b58132a5725058ceeafc2c531dfc50a2369b7a4a6de65c782aad90bde4051616551c7cb1d9a708ababd1b1856d302d2dc2fe193efb338d2609ed5a8decb5bfb97427528fb44de4d86bedfeaad8d5afcb9930b07b78b33b2164ad823356a2a43681211293cfd62f48e8d62903bd5e09c396a3e510ad8490f8d2800dbfa9ec228f67d842151a98968d9b60e9fc9be803ad53355d2d25f4788c3bbd53b538163b272d8582f47012b3dda2b6b7ba8044f45834149c52c60a47e395df1d52124bd092c4c04814c2e096fa25827a35a8dc765859c7c6c64f36f984e56a41f2ba9c545afc0e20ecc93d2231d3767b970bb928ebd2a5c76641d802589993cef01a25724e007caa2cce0caf287019d5f38571e832260f282724cc4e18ccdc929110521fbfa53711399a8e3cc35d52d121e0f6947fbc029184a8c93ee3947b6f9deaaf4ac7949e352c16d6e090c08b3aff61b7014931f9eaf1f9c101af398687c8b1af8e7e28b094a6a8f1161fcad3cf7ee7935a8064b36c96c0420a50b90b4c5b02fc11124c30f38e4f4263829cd8640139d396cb046b715ba777e29d8039e94a75c7776681b4f105932e3ba7008a61707ca5edf812bac469a46ff660ae9f8c43b56bbe540dcfea04d72ae42052215d17897df7540963f5ec17e7a6b662dcefedbac17b2c147a9ddeb1d3fd33c708e18768ffed41fd066c0c311870e6f85f3b1dd0cbae0b90ff1f6a6efe84212130a953e12ba8a48ff188644e571c92dfb7f9819159ce953bbc1162a19a21339c24a4121cc465df3201ad3e4c3f6e3951ccbe054c0901cb9424cadd9b5af6ec3d61eb4684602f62cf8611318fca202d908ec0958e9fc9e5861b599276db5fd957076e4efb2892074b8c75f4c65165d59660ef3da0035079cd5723d36e194147cc4e13a5a7f995e56cffc73077785c811c00d213ab7626350cd609c6f671eaa96cb1bc6f330cb995ff16bb8238ea10ca161511956757e33b4be6fa877c14d79c8828d22f6b20555359ec01e4c40097c5e61c16c3e77bc5cb4a63a4ce3baa2d6e215c01c7f3b529d98a1b9dc01cc39737af3ad503c103cc9cbc6455d8d13609f73509ff25d5ea8c48f1f57dfe7aa4b4935112c0150c15b15f3ca6ce07862484a524884751c7058b0624c082eff77a33af6c26fbbafd98b75b05626d710460042b742c0e60b5bf774e6067dcca9da458a2596ed16f347ba48eda1bc7a36a9e07467887c918899e623e87e36089787f7bda08ed05ac6f2bd20b6e9677a3a07dbf8399c4da9b9f36f1b84b87f32026c72e934369d0342c6f2fbffc027d304a92ce405cc7490fc8d73a0ba7c5ba8dd976aee8a054a261c73d763bd27c7bc5dcb0368b2b4e6a01cf6a65863f2f8b65d15c74fe02fb9d445ab1a52f9f2df93fb3a1fb2047ad60584569b3ce3e4fe9e652c8814f9e11d14e9c8017e9a7e25417041ffe3b0e720ed870125803ba93033d9b03a621ca8513bb3b196099b020c237477a46dc2255904237c7596441f2a722189a04249a154093771e6a2f0cbb1fd1a0cc25a1b6365935a5c42fa2b8eca2e0b5431c1b7a80c3b6ced35d78dced9c1d540d95676cfe7c2ab2eccb6e37830d9bc304e9ad6c0ab9bc16934b2de60e8814d83eeb5f07c2be012931cb91e9ddde139d6c4b0d2edb3eda8826c3697a5f51d10f94a317392944d8f873ec210694f2567b158ebc4e8d0c1a8e046a491402dec3e45a6d72e5a1e87aab48248cc3021c82ce52a02fb8e44dc2715a1f41fc16ac9321e9c17459090ad35b2c9fdb16f1bd566adcfe06a6b07974f19f5d5c08e0e6c41921ac4aef72077d86bdc9db4f11e4981b8430b22a039b60df218d8b54fd003dd5f5f509e7c0289c0a32b43c208083093698c47dd9d1d05e5c5380ece1212ec2d6f45c5487dab595976d3ba5b65b317148c8bbe0ccd348dffef3c8c4554a261ff3b307a5742af7ca519a7196b23a8da60cd66b467349729e2e742799f4cc3a67f1b0c819beda7db11e168efa96bdc518ff9b93b7f4ee8a66c3aa087508a641343b4c1e55892791cf28fc288a6f4fa2761993856684954355d3cc00d668eafa4de27490edb2af9b958162fa3d77fc4f255fc2319972009570156f77d9451398674b0588b3297fb82b48590057f00204355a85f4b3a83a9d5da5405387178ca02f30549b29697f1df5eec8566d6043a870c4e3570b9e5009567eeec84958579f9c058f5725e99986fa06950c73e05514216dee5cc602392f4b2c69036fa0be01fdde9446fb2beb7326d6381aec61397dce120ea5378e8e87c581d1130ae868a1999134746f525c3d05b8da8d3a6e5e27f308dc431767fd90d9c977a22556139ef8ec16de35a32045348d23e6ab076575fd4355c90d2f50ab7bd6f4c708dd73e394d04c743817a2266d20650e736896d872fab5bdd6da92b634a306e4ba9a54396db703d18610ff8caea5c15039dc46582f0203bacc94331b951436741672c310598ac7334fff9f37f1670944b2871fd3b84456ff528d718abcf02933705bfce9fbc6f0495532a4b367b2db1557ebaab9e80b1fc5a15a1fd7a91b2c0914b4d9849bc4f144774f1b00d553740f06e1d0a422935d5e412c3e60287dc228bfe69706f00a5196653895ca390762497184b329bb2f7eedf0027fe9534b645df690cb9dbc162804dd701595f453af6d222daaf66b137bde0ccd066e18efa18d6bf80d6cf00017cd2da889f9a9097a76de3bbba5ba263de63ed21d40c182d4ae489ba5a59ac51aa950ccbe2ed7f4ed3d5837ab1c0e85bb342cca375630a1cb4a92ead0fdcf5a66a2b3b8da82f91ae59df95befd0f4c6b01b4a6d43aa1b749bd81eb78d7683c5f8543f62d706a23984a68aea3c9114708d2fb2fdfe69bc382e2b177f47657b70163f886bca2d152fe6d7247a81457e567590c4780b9d648b64b55279af3565af22b5b20588d22d0ec255897331ebfdbc989add81cb769abf3bd4378e88218da91485e4b5e1ed672e5bcdff33c54b0560e916c30bf600d49804484900e68771c3af02f2bd55e8335b78f9dd84ea6062752011ad7461fa7cd3086771a71fa38ce1878575def2e3c4983b61493abed9c16d9d270ab236a04757cc16bf25934ed1f4cbf76084f37e504bbaa376935b89fd8347b6281c6fcf2dd189f820a97863ac84d750ab211dbf76465917ebc36243dedfed3d34cf4fea9ca7df970705874e3b910ec961411dea970e77150f8d1e69f2c3bece20c8382c5019d7cb01c1be66f27b5f6b57eab2338375c42ca09068b34012c608d59148cd5e3e08b39c20e77e8938ab3925d59d2086b5f215f1ee881de4e17abc97eb73c30d580ee603a080734bfc5a65ba28bacfc77aa7800c929cfe88dd2fb05dad64a291be4108699ce258ce9affb6093ceb82ac81317f67dca9d6085c27f3a2c4d1940e1265a6d9e47575c4f73cf16e76e058f4c74151391c8a3deca69a588c3388c0ceb2e618eb666d673a3132d950a0326ea1b43c82432e3cd26fbf1dd3502a43587931129ba2bfcc2e4482798bb16760d5a8d958988f1329c0aad8067d21d3d00da7030a936548581b23d8e26b0e0ad48d50f2010c0bf468a847796c3d028620a8838731164b7bbe76dafb93d2e22538c1ae69d49f748372db16bccca5dc330a813c0562253df3d877a8117a4360bbe948ed55756901e61a05dafe2aa529d107336a2f3e43b23d15060536232351833f9677a606812dfb92144807052a04c1c07d5fdf0dee29069f9eed92c4ec1e07bb5f06a7f18f32732286f432edcfd2e92bb1d0136b942f633581f208f7ce34cfd10ec659b2110985321b11198b402ebe03ee2f5cf7626b467ae1e39f09c966753069062cdaa4f573771273e2e6050f288291492344dae592625b3e2e746bce8e777342fe4958733eb9bcfa840b8656e49625bace91eea8c88b33ad14c7f0c8a8d5eecd92500dd56fe6e104773f4d1e5b2d10ecd71b22fa4e676375a8a2ed69d3097b03b2db69889d6247370ce517926b8eb315d2051b1bf6c41850588c639c9080b384e693bfc7921e6022c48146c56d4cb4a10b79c8171d73e03169ce2eb66e8e9b93ef62c37edf67a86963a4bde0062c87705bb4d8ec839bf7fdf2b1903ee0627b24082f1fb27908089a5dfec21d98395f005b7542d1210aa31b2b4ab0572cb0cbc38bbd468350a073edc5c1850a694a06c5f1f716c7d7c74362a5fe9390a8b28991e36b7e78dba8b4006072c3d2f5c1eebbeb4c1b4948bae9996da0f8ace07b38ebf40cdd0b2f67efe773fa32a9c468515e3856c78bd198a17a023a1039945e8b3b8052d54a6f8dfc6f8421afaa9112245268600140dedee956fadc3b015aef240b80d48e6fef0918b1e5e43a5f3d75a4a7fbf7a707ca6d9390be3f363a8cde0d3187954bf0dc6c911fea536dbd916f464bb110657ea17bc63a982c71f965e8b72041a8fb3af99f2e73ddda9f6e372738fa606dff560bb62ff87c8f852accc33e7b50aea33fe7747957ce1e90cbd100d69a56753bb5c9c6b6c7b26f8289fb5487054d6e212dbe8e6a386c93f9fdfb103371340c4b2c8fb7191e763e8ff6128e4288522b598e80d4a45b3d667753b9cd25bdedd91e9117b95d2fdea344c6fd0e69a00ea8317c0c610629ec01bec6dcf652c9e97fac05a499aca2f6cbf362d325470a1f64367b7a7d275746718129d897e084036c1777aa68936827eb4dc9f850a59bb39202b796abb7f48a846aef2780871499fb81a43b52280f8320f735d065a2b29d35feb5ae43ccddeadec091de71dfd9cf650312a4d81c777fdf945fec55c5e678807c7f7214d860b1665f4fd06540fe94ebebfa23b185cb523fbebe5f27d7606c9ad21b8835a84d8db891b1e884561f939fde751ce380690f90a438cea8c952c57e2242b02f3e337e22ffba27a7096a61bd7917740219185014650a1c2c45969f0b5b588101681d3ec35ffe7fff79abdcef4a5afe53f6a50ac5a6c09ad268f9687337d91c9625e8844130bb3fd123a05d5420e0e15a67503f001fc3cefa68ca6380e0e368c0f75e2ba7177a16b172414449169c22b1d140323db78916b58354de8dcc89e821a932ecf86065dda3942fb6a8cf23243ea0cf5f684fdf782806bb48cea9ed625ad2201f209b182d58e0e9069c636d48dc98764f57a19b7dd0c676466b4f4dcf51ac9a09fd58f9b24efe0c2ef6e1cf62208c60842a05d61a45d21416fa890a01e15ff4ac7db7192b189e33a9c69e37b2d1d6584fb449b2fe15aa2c87fce3b40d5c53060a33d8ed5846e0cb61fbc2b5769261afac42bc739e7230b339d0ac0ee62755d04ea5b5bcb3d9053f41383d79cb9e34fc2d9c74019b84c1bab627dd577839d4bd934124cccc49c1946e8ea2fcfdf5acc01bd9c8712890a8b408ed4b12c7c91e625aefa1fcee28bbea99eaee282ae755b3e4fc9bb95a943c076532da6f2381de9e93227b264ebe3d77a9b556244c6981b94970967724d7234f7d1e291026e896e628ac92a0e9d2fb4d65fa085bb88837a283c8f5c04efa7dcdb1bc1670ad846de27f2f3a6322f74b6419bbf4c21fd7eadaf214dd3b2a783e74a60e5481c8f0913daaae940ed408c3bdc3909a055b9d2d56b12b201228b07def7413da67f8ed7c62211794ae806bb04a2ba646efb8f7e1b36da2b792f5f9114b648fa7db212db2370966740d6a651ed13258a1d5e429ce8c724d90fdb83c85f45929168367634c8bed2a8e4a6b04958d5cb0072649aa41d977ba44184bd02051867efe9dc44ff1d8024e9b555f3a62b7ef4208bf7d681056075f282397a43b5562bafb886306635658e051ed4e0a87a25c92ed44aefed2c3062d6aff97c539a2b52843168345ec1884925fee7e8c78a2627913cce343189b54795c44f3c127f4a397209a019556fc5c083e0f56da7b5ce41b7052e6b11a9605a89b0f6834b3d0bd2d178cc792a4a5dfda538c83ee6d7de6b2558e31443099e8e73cf15476e804808ad261a1c1ad0950892d347f25540dab4f047b2720ef9706b16a1a31b3761ca594ed88155a30548f646128f6968d472ddf28731f438f891d4d9dd7e6d0574fa5eb408a4a7bcecef09179f153997659693474d4d56344dd9d4312dcd6f6eec6eeee9d64c07af3ee04de098b5b1f180c5a4b924a9e6248a4f12f178c6133ffe7866a541eca6d6a86d74d92d0864895296aedb00f55284d97c4f5cbfd880a0a6f7e2496e24a013670ed5df0611cf04f6dd75b3db79c4e50a126b460e8f8449d7e0a53b253c760c8cb38624ff3ba7d5357106a11aef89a0db33a8d69923a611e395829d112ef8c2782337993d6cffc8b68fd6084370476acde981c21729433123d21e1915e21e9997972f2730a3b5842047dcaeb902f2a14080819c5bc0f62489da1cac90dc71f25b882efa3975339888dbbd7162b2eb6bc18a03db376c9dcb2f28d569225f00bef37ec30335e0bc7825e1e4b4070662f069d6c8b2011d8433f05430f4c65caf41ac4a9bb17a10cbe0ba4016ced33b7d67f93f126a195f3d4901cfec967ef85863e2c69193b9588da303e33a553179ccb9e99b5197c879f6e368f38dcd05158b6e32f15febe2da00738882570dad6c59a62fd8e7e5c7dcbc7cb9fa786cc7e6b8a77a4ef1f012122475d4c2008be376bbfd6ad36814bfc724b838de332e7bba0fd8b98c39a50387b2d1e35dca5382fe2e854df2d0ce90eb981ae8049e2305f544b71e68c43e378fa2039bcef4d4c75d4e0777fe98e175e0165bcba7a5e778d53680151d61c54694beff6828e7bee2de264d12544a423dcc81413c157777d8053337afced141872bc36b14b2f6f11ebe2d154a98cffc89a7c56afd00415f2faeda0020e60d1ef469dda50ae23daed3b7c7a2c4747546d126d2f2d56265008176c6cf6baefc72447216cf0f5f1eb6d90854a1949c22df4a18e550cf84d245bc292e96f35780d4489a8ab2712fcabaff55206a92fb432a480efa4c2277c88ed6d1f915ed38b329afb45cd8870181a815798f9ce02cf78a276ebe1c8c0c174e74255ccee93a434967902b9ffb6980f904c0b02417fb72a1f12d163e84c92c8f2853f729a533f3145aec4577ab17a9c406bda750793fd6347a0bd8513f56e870e4a995358c1a4be4efc35822d87d26e0a54785cb345916f657a1bbb8cb793802bdbfcecb1f04c0bbf097856e5cbfbe0221efd043ca4e08b7805d4da28143cad5fac5c9d8f9da88459078599b348111056290fcd861a6e6524a236cd1ef13383da9a68544b6b5e89693903a137185bd0cd83a104441a1a66e24827edd2052f1a6273b41d8068f82aeb0dee65d65f8743a1b680b6080466a20ee5ace51134d576df28cc46c0fbe60d773f52ee32102e9d6e03195f9d66377b23eaae4cf3c2f1301b56db94b2e5ffe1a6975f9e56a5a00f73d69cc047911eef11f0f409519f1dbedeb0b62aa88af24cc5217923d8e3d90b315057b2ee46c7c5b7acd743128a94a31802288945baf61f541b69b2f71d735117ed735c0ab5b8f1de2209054dd0e704fa5ab3efab8f158677800b6083934faec6f2b0be2fa9052b8d172899146b0b01db6262b33623bdbc9a5092dbee6ae26cc603aa4dd755eddb8cddc4d08a42c35105d31755a884703ee49745499308ff37d57f2a8ae9aed16268894b12170d25934423dc3426f10c7d014c07e6de99efc075116dfd3d543c59b294159a47b843c1efdd9b5526b2a5e66bea32845872d19b69f8d943ec80c5a53d656f1eb16ffdb3d3f5409252ef70a8c2799b18ce11688ee8dcc6f75af326f1225d67f3a9d2a33a83d31f669893eabffb0bc300673541eeacf94b0a4b1d4b1bbbdf8aa49447a123e05f8d3eebc2557aae4d49d62ddb60f1716acc053ca732e93abc8fd7ead271df6350b3dd72bf6089a69dc1812099c674ba892f32271f6b6ec8509b239f7780193b04f9b5c28da22611a3b1506f001be719a92c2ffcf0cab86c9ca1e3ce0201fd51265abf69a2736e1b7f8ab98a4f3f494c5ec61a5eb46ca4b6984312d8779edf94d891c335ed5f76073c6c69f30695827e811f621bc40af9834c0b4588e7ef41ce2edebaa9a30e7e078d3c14cb850f78fa183bd0b7679016e4332d575df85337bd75069a9f8d4a33664d78b06650b72549285f831c4cc90024952852f2ddc405cc0619307b12a64cb24bbc7daf1426d387fd809bbd62dd642d62198cb434745ed12e91e1180d197e009fa0996b9ee35750d08c7df3b7870da39385c4c224d1f596963fba3884cc9dd5b587be086218b3fd4e3ccaf87385c1b726511ab98fc1e2410c0096d8bbf402f9b785f0c6c31365dbac92d80a722897e4d9f19b682632b8714cf3a537f1ec149d993a7b6a9439a0f172be98ca5177c1c92472e6d5ca9fe0f2f46bec4e25ee23dd6cdc2c5d5db09d7a61be7f138cccfcad4a19f2f6195f7cd79600e09ba6287ce0a49067e93bacb9ac45fadbc64658b79ded2b22aefd38897ab0da48a3e35264e71d0d718266b787e21d6c83c1b3cded6c7552c909e97042069741ce1b2926c6718bc6c3717aa150ede4b140bb855bc0aa3aada95df31032827e3fcf986c345581ae4fcf26dbc4f9de2e3e61ee44a71663eab42346d0776516130b0800c264c4dc7489992bffc424fff29b11b3d7e1bbc55bf86bcd27528942694a98e7cfbdae5b73da8702f81c028d55bf0aba3389c8d1e8c072b34e4ccf382b2bce3639888c9f0d3973334b7e84d4a493d8e4e3e0863c84d3d3b4b511dc971f1904e3275ec21418bbff70d95a2d50e93f3ffe3b19b882f070773aa57de8b945989bba2e9896d606c99e77107917d794745fc397aff4c8743dfffdfcaba227af15de70118aaff4ed8c561f35a3a26b21ba6365667f5220c5cf7616a6187b4e306855eb50cff28cdac09570d45547c2ab7ae37ba8137720a7e2fdadc58b59ea1aaa0c6b2fa873d3da08cdb908d077f6bf07a50be15dd0479708ff2a8ec4cbff21999018210bdcb98acc43fc90041b6f1b5b39c22e11f47298372c64f02f82b05e417f78089209ba200763b00b281597d53ef20208a80141d469eadcb6dca4f51394a821ba89f26e7ce5c4556b70d145b1898051bf1de6d2539150f23cf95a306bafed49e77145de50720fcbc1f34fa824f88309bd25bc42dfefdd254ac0dc38c5ada6c48b82d536d7701bc0bc3805b4463b0680cb7827508062d0667543cace47ab83834b2a246891108116dc5aff53f7b660b83528224082e37b53c38368eb23708bcd86cb678a61b790836e91192fd1bc1ff368e9943b1d22cadeebc5d0641050aa037b31b34434525927139006cb2c3da903467dbda36fa353ff0c5d57e8aa2c3d93f1cb9dd74a3ef8011ab14ecc6ee766104d64f9c2d35f2e6218f879566254433beb484aae809aa613f1f9a2f363057a09089efb0b17a6b89fad159dac1b94a3733933640af870c31b0dc863faa6dfda2710f9ebb1ed63fe2d829ca4a544c63100855a8e73015b4384e8716877e7d42d40a2012e2b5a75acf2a9081c07a1004500b722c04afaccdd0c4ed517722ce0806cdbfe4324bd0009424baee34e508d1b720f8a130a1c0d7a37938bb05fc9db96237fbe2664219c96fc20dcaf717f5e9edcfbe37482ee7b51980b818cbddb48a2125fc9744bb2185722e94bb9f44dc1d6e5aa4e4daed7fb69c3c076f11bb1813f3b2ee0d0d4be56452771f6eff3535da95b2a78f9b8043fec443fd2d423be71e0038f38d07e95bd218b1969582b5bb2c27e518dc315940b953f47d712822e076e1c095070ee4f8c2f8289df86e123e8084f77eb1bed947aaf4a225b31792a1c20a29cb56544831a11715c45c88d93a141dc18f49a289528010a70a6ca30a5417ebad2876880ae37bde9851288e68b861c510fa2c4362a132b7d7b74d9523a411c9671656367e6158be4a2ba7d419bce0fbc98dff8395fa1f69ff6e403ef8c1faa645aef6eb8802741fc13daec1e2dda2f4526161976c45dcf9a82c448cc66cc20df4d25bf837aad41c9b1ddb2d5d1725a2db134c28147bda90788a7d376423e702f8a0391256832a38f5f55e4f1a4c242d7594d3df7653e7cb1f396737f1e1c074e56cc1684edd57cb008c92cda74b229de8397a89dba28029ce047077721371c73005ede20908c19388abd4d4beffcbb28f720d94ced704ca21fdce904107307653e61f35804e84cfd04fea1a0cc8d3e0d7177b2d8259c0f8d38ceb5685dd51ba92045ecfd57ef4c444a9e64656e6990584ca742ffcd0148b488a97d9ac5d9e8e80dc035fdad84b3d501a508e8fb28362ff932d62a45dfe2cb022c300aec6655fce05ab80f084fa0c9e6f04d8d22924fd5eb9125add26c49752a849a07c7b3ba9cfd93edfac13fedae46f8867012a11a361237cf2067f649dda64217a3c7ede1e634d570513f70020ff3ee408dec06e492a951c891e268f9128a07f9e6c4ab7596c2208c850b89558ec039803179ff44fd61540a6ea73f250185398fc4be1e5fb588f8172c31d98b4d362ef0893234e7826bdd68dc0681b6dec25519ef6cb02e11a8f19afe15a779bb24309ca29ba05938be47d83a3f2bc871581abacfeaaae4a1a4a99f601981df11f92554a9cc699cfb6001b895b26cc6af8554adf15053884906092ef3b536f7604479287318df7eef8b335d7a8a0e88e3ca986e495a6e7322ec31d3076c891fb2f47bcd42d3670977855c3a53bedd4abb7c8d7b7a0098617e545a66b25d414376660c9b4a1f853a1de8b622813e8540aa5d320d92849c5fde22ce7ed1f86cdc6b46e3ea25c0e6968222e6212d394972316b89ddfa34c1bbb6d2ed6bec61332a63ed0d6f510891a482aa7b4ec8390fe8b380a568b270070fa71f1f2c68fc898ed66f448edb9fee79d82cf861ef7e7589debc2c790b6c720037407f23c40d93","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
