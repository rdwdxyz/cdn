<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"07a24d856f70e8a253360536b14629653981c0a6a3b7ed66e5dd2af1864b68ee112d9627227ce5b73004df89110d1a573aa04b999c28c7ee3f1fc4b522643a5adae0b9ed6fd5d507dd1b8dd34f9006605ce62731099af214b563db287a31e77b50665680a86e841572722097bde0c679f5adb33358cb58011712eac273b27b8e44f8f3ef4fd2250789bd1df55f40b45d3f06d18d8fa83d66a29b4060867b52223b905ba648c8ff92ccd08b83f2b4f75e51adf72924c99b5dfbd942b4d7ebddfb5e56af72126b8434713f4e261fde87727d5dfbae24e4cedd4ce7ccaab044a4f61a33fd18270aafeff481babdbbe80c41c65375bf9f5bbefbcd89f5ef147d79f83b0208e08a99ee69c9748c7e8bc979540b73f189fe4f4b64ab4e72f796f069c5b8182155935b566c056a59b82ae0dc06e6bc0fc48afdc7650aa6f7f6d62d8c11f5e4bdb438dbf30d830e87414ecf8dd42cf5aaafe815453ba7b69f1954c2e72608a402c1786300eaaf9cb1d75c55ea79e37f9332e0b406fc3fe2cb82b1b2dd89aca134586ce302ed296a8a8dea833a5277a6eaa5ce7bb904d2dcc78b406e3571d7a34e6cc581881470cf3900c7749f32ab6dad4c93af2da437d22903b5fbfc6db884c3c0b456c60067e3d55243aa8695c7b23256d6151a058d3c5e13daf1ade8ec1c543c4e5a1b467b8c5c27163732e978253c8727dbd63b39ec788080dff18f73c033cb621618464b380a61fa2c36f8507abdd6542eac19abd202ebce12cd367571ef510b6a7203183142f93f6fdffd48fb423914cff7eb9f7d28583b34dc3acd8c58fa248c5ce375839156c8f74d09f75bb85b72e3114110a71532149a4e138fc711315650721009567f419e0342653d0b9a8f0c8086d1f41754c1e818f557b2e8c720774662d1f0b3a1bea5aebe1b64a19639869d1b1a8367d08851dbf76c7ca9c44b3693630afc0fb4c8384d96b14bae8ae67a0e0d9cf775300ee85834f0484a32e05e83e1373372ed27b03aef1545a3aabf7ae1ffb66a59259dd6496057a331570aae031e1559d38415e3a69fbec85701996ab6ce2b94f9e2fcdd4a2c8c6d60ddef7e583401bbfba828ee5bf965c38ca30fdb645e56b5a67966a90ef8a22d6cc9d7e95662e9d22cd6c4bed45b75d9b35dcb116b5e00bfc094c987c5ab52b2b5068f86e65c43fb572a8062f0ba3412920b7831cccb16f89018e24d3085010c9ef560be96fa9b99ce867c083618a36ba24bb2f27b4c5eee2c87529cad24064ad0de1fc8f8e9674a01996f7202af9cba7d4f6f9385e058a370ebe002a03a455b3a817cee35bc320301cdb434463fcd529c5524217d70a73b0a0771c302a3833ed76b2f5a46588e0ce5f1582bed3797dd152f3f906a43420df992efb5f43988c01c6dac4deee8474c8bb88dab22fe449f2fe8503df57590d8bbcdf85569f7295a4f4c0442b894afc79cf8ff256110d4fcc7ab669426b09944e7e6ba62a53bd5fee84f92e6bf062c3cf6303a308c9486290293cf0e27bfbc695b3a68f843bec25bb8a7edab1966de8c689115411d6afdeaf948bc18080db69147c6ad8ae6f91c919f34c9e034405be64e591306c8a0e7844cd51eb0dd8b96cd8efb620bd410e0d9a65a6ae00496334545c6bad3a51d1356a5276ce84d7620cdcd41c1e755738410b32386bb02ec3b199c58641a1fea4364efe2858035ec003757ffe0c3a382feb0a36a8e99d3600c05f90716745609f807138ca17b147403887a324fa8a9690edc7c933399f14d81c4845e7102b6590c32ed65ff273737c3bf12e073515480712e3aa24dbef611b8f37067a49eaebb20e0ed09f231a39696fe7d0ec1e1bc6b7b47f308977e8918608008ab4c4405e4a66bb3432406d4e466fc77f2a7a91ec603b960273385968532a2fec0536008ef8cef3246db0627dcbc492e65bf5bc2ffab319c3743558fdd9a4a33a1f072891279238c5bc7b3e4b6b66d951d9df9339711c2f74229f6a1a6cc0060640dfef28984c68390079c1fa0540408e546d88a7b8dc076be23aa48c7022150f9865f774373a2c9f1791f7e6b8d01994a6d4fcbd334678606f64012b66727b85dbee5620a9500043893ed2b0255da3e719e5fdb7dddcfcd0a9af00b746246c84840ca6561c1b3878dd8ca13e6af195e2a8805b4a9b37d96daf0b257eebb108e9b2557c5af85f24d41a00fdbb8ef182f3239fbc0b3ed1a0014fcd69205ea93c823d7666c2b663c0cd8ad9a4ecd2135726ab943bc4841de7e551fc660b57fe3010fe13bc678bb630f83f97bf6d619936ead09db6cd39fec6e1e0a3741af2d6bb856dd59ba77af148fc89b4a37a3613282007ee38afcd3020b7e3f88dc4b997703c26b4f115143b4c051ec1b9d02e09f61afc21c6f088655785e388fe7f6d62091ed1bedd0ef0ad5cea866edb71e64dfd330b68700dae802511da4e8eca784a5c4499efc3fecdedf6fb4a655540aed8cd9504f8b91bad2523f715af2532307cfe738f55526b74dfb94aed41952634141cea24f7fa22088ebcf85d29c39e453d00312cd13b80162909095b33f81ca27f14f7ab4ad00bb459a9bcb5e7ac16b3b7d12714a9a828e81ea13e3490c2b31dd5c7e19a290e7b2e9e5c6b9e37cc67014cfe60b2a12ea432940c736a0ba829f5e8166317150aaba6f6fe67d7738fffae4626f402940869883c8322b7fb91ba7efdab13bd1ffd3bba98d480879ef7df7947e30dfa974db537706832efd3e3b8f8a5514351eaab1a4272eaa8bcd85c647067a52c2e7e782001d8ba8d48bf87e99145a23b356adb1a80c0f6dd733db513cfd9255d9fa415cbb826dc6003f9029d033496f0aaa2274ac52ee96192b231df313cf489f9ef262df37e33940675dfccac99edce5ae277e2ca6b3d68549735f3bdf91d0c53625e6acc74c39b893e4109fc131a69974ed3ccac7a5bdc17cc3d56594c36d8c4873a63f5cc9a5bb2d5cf324acf6e3d1c2b5ac9334e9fdbb3d53836d589e4902e03b3c8abbd0c00eff434c96e0ec974958c3efcae9a37bb75325358a9c958b1481673fd10485e65de1a22053e93bf480659b4015a37e7b01e633ebe6e8d9e7fbfab47364ce7a0db41b72eb24779f169de8180c850e2c6efcb22b6dcff7351d9aefe2e46540c2aa49635882e1220939368bac5dcaa7001e1f5a206b337fa41545b515fb3608cace903045312b0cb75e64e927a92297bff669d3a3b6db5af34900298fc69c9e88aa03fc6c8b5998164af51f6dd170ef63a15c94a6c2bc90d910982563c12f25b17feecb80de94607931a5a6aa09fda20a2c1a7950d51b0a5e02739670b71ebdd65a896898d3f11fd506a10a403acc406a1df406613653a0d3e8d74648c6e3aec556d8e6c6b1c1ca311d62b2c6ceb1cac965992398a3d2cbed9cd853c6b894dcaf82f1f81828fce4e496096a9e0dfdfe5e2579b911d55ce77e34b766fc34b834808bc8b8a518c8055be35e4793a33bcafd897e2ba5215d6e2397c34288e92c7cc2a8452c3cf17adc8af4d1051cbec68c2c5f0ba20a9fabdd413e51ea36ef82edc351d725ce95e20c8e95ef98063214052c91b1d490321c3690c3a43efd9f2a4b22d3795eb09e5f23d3779d74062c186c0389ca6894e460058d9a0ba8493dffbe3a37a8e4f36c9f9c885b4bbc77fc98bc542f44f2bbef589a9cc19fddc7425a2052fc6a376d38cc2663611ac5dcd3acf0dda0a57036bc3227b30f3197f751411fe4cc8d5a5f614ca61009e6a82abd1c0be9a86c4ab999c35ed61b32c76085c2d5cb43893ade1f8ea9f6f761f0b64c9bce0c78b94ab7d8f9ee2e31a631950b2c609e35699ac1ff70c82d5be691724f3ee2505e761f75e78de6e12192146c8ce3f2bf66bf2727d9d28961078f41f7e449ae2d0def75d1360a6ee5f49b231aea6869ec0e5e3e535e10f8a76ebde7f65be55d425684afd71176c14ffe127cdb11eb866118124d3f93846ad7dc7675424a32ebb961c2786a4dc06b1d2c8656f7e9a6c2050bae543613ec5005c12da4bfbcd0392aa1888922fd3395ef0c32d7e4e737818842e8a63401d5a03ba249ef53363613063f5d1f484bcad7fcc7b58f6a06e7528e1a5d8c9ab41aeb5242e1ad28a369fc08991b256f8aa99f66e3073e15dd4fbf852b7da55c18a9614ec78ed029e62e5fb5001bbc0aeedb32df8a625162be2cfbecb1d4a8dd18a043a0aa1ed9d540106f55dc81abb4801d693ca8e1c273e504b5529c28271660cbf3bba1e0de94c84d0db1d0eb2188aebf4d8d78b93a190a71420756d77845c6d41687fa42f44baa571b495dd33a0ffe97e22be95f0c6cd147720b649a377e1a599df1b57364ae39032e9e23ea1f1dd8e0f22963b52719181bd2ffb30c7cf47a793a6a7b4954a4e28c8a91e2e2207b2259317fba7d8340bd35c1be4773a1bf077a7707a0893a7b9581a7184e94ac392c14a0840f1747e78836c92ba429e575a6789a2dac64938a9215d22fbc8783a105d7f9d18b83006cb0d1487be43d0000d4037106690115dfdac0b8d8f38afb69843f3a4b7a460e048988031971ff9b254a05a3c18b171ca70c0043183b3d721d009aa25a28a062972790d1d65b653a80e1ade8fd51f7debdc95e8bcc972f9e127df24365bc8af15fa71b8484b9b1249e15079420a4a90863dd898546109a9ef405b3c0353f544aa393adfb30bb53bf19556861237e5708407b0d9c571cd3103ee8d8d3e63933734564feac9ecbe72dfe1bc0c634af9a3cfcb7d088604aee7a9f977c56b8c10ba2ca7b05da13da6c8fe2a462d59f1c81a6b17c580be955933aaf33af490b117ea01a2bc099a0b934b8faa6002f9278a58dcdee5411caab0a5fecc41192da82588a7bf18a419f6b731cc181218669d836e17c2576f7e8d86c1e1abfe92d850a5d7472e1f06c4566d7522a4d22d0fea94fbf2a568674fa5fcebd51f572de9b1aee7c617adb196d31270260e28545681cf833ff405061414efbde2079dd6200e8435e9205c63f163fcd46c2c5bd63b82daadab6bc8cf358c8914e3e20bdd7edf6a0b4085f4e292638d505f57b984d9845b1ae5dbb66a39729845074422c40850f81a696b03553d068f7709434781fda3e45e040155eb4d18e1a6c1669087a8d6d2a29fae9769e7958731bca2d54c94e8ffd276a4dc159d6df86ac81927588272b215bf76712756efc8983fc80c040d3c5b8d7abdc1aa072e6d0cfc7bcc11aff873aa9350192fec9e45060050492ab4b288ea9853722a11848c1e83060bfeea8881dbbc5c57a91428f102ed9f6308d75b6f1ace7c16067f82d050f59f4cf3ad23b8e45211048f32687107297a0cac6570ccd80f60098c1ffda9fb17067bea7ab8880f13ad64cdd8dcbbd32c6e774903b368bb41df0bfa08e8a4cf3ae25bcdec32727347c2b6c44a63a9ee1b76df94cd6e8d3e9593bd9cf4b8884cb52a5f053ff23ebb73a583dc0f856403e913f857ef03f57ae6dbdf552448646e09d832f88cc823f9a513741086f2322e1fcc575ea6c1b815301e30955050f32d3d77d17a2a9c6da0733f8016349f00ab1cb319c156471b3dbadd2d843fd08a37bf39e9f801645e2e44ec57a32e5a6124ea2611b403cf96e203890a3cc23a637cc2b11cf7bc10297dc0ee38f1e42b6246b8dc8d74e3f56df3a07ba5b4f2df6492dbd5ba09476aeaa1f2022864a419d45be4165ce4a8d58864910d2a853515a865682fc879e97e4bb7496b435842f5b0046a51233351fdbcf3507ef6e7420c072e7c3bbddf3c2314b3349b1da15dcb514ba1771137e7f18aa4926261e5ac41be2b9a767f42445ad07f711af7c910a028a55d20ebb13b13c29d21019139a76520eb325ad30686e8279e1cc2d31f5714916e86f534f7b209f739b54c74587c8f3c3a9665cfc13f7180350ff83d3370c0e574e91eb1a0d39e95edce0045d8b8da52746d5f9f05a9c4d7cabc25e025805d7e1bff3df7cc209a240a7e9d62196d00d9c906740a1272602ef2150aded0aa41d1f19ee2cf61970849ce38a6e3dbc949524e11a73ebd4ee13a1d4c3d3006a9a702ac8d751229e81419496c677af3e3515fca3d989e988c7f86e03c98592ea65f0572d6ba35fcc2dc8196e399df36fb5be8637b8c2cb0a1531ddbf26a3a4000e5cd48828b19ddd825a174464e0edbfc363803e45a691821c61ac6403f36131140b34ea04c9c95780c5badf52e42bf103fff0523d10654df01e7b01138ab78132a99fb71f6b53c535f4dc0d0e301633da081dd6f5e5e88a98d5eb30295aebf673f66b1d01de8347404556e260213218abf3f263eff5cca1b888db30b2adc9374b98f38254dbdbbe255258d4fce7eb610164e0a806593728cb2fe2e9f6e6a8cc25e05f84264ce0e5a472b7922a46602919aa093dfb7d39a6318488ad8113501b3bd1f5bdbc7bc80f5d6a5959e309a2e52c7a56cd601d8327c91fdb1b7fc607341f72aa653119db807b05891d7431b50dd883d52eb184b36216dd2d0e4c5a5220d306432da8042a6134f7b5b8907d159540f0a98a3a1d60997683f50572eddf3116f568991eeb25b43667b6e2f6e797add058eff0e7fac577f997e47d0d6dfca30067c022461d12d4c30fcde9ee2c986c88d0a39b4db0b1fbdd86ab8acc11d8c436488f0cbec77631eb4c857594749c7175d2da4e88eb34929be62e11d43be56eb9e7b1fe58459b7aca8a00422471cd1e924443f1b9eb125a423d50b1a498c6897b6273fbffd0047820e23459d7a9278254cd34e11d57b880eafee668f9ad672cb0dec7563f131d48c80a96aa193c7c0190df7b3ad969b9bd49e442770846a4e1db3ec6598fcc521f588faa63e669f00f76f99263a14e9fbbf397ef42f618af5dd752abd78ffbdd2696fce3dcd5ccf115d7a4b26ac1cd31c69de560922a92a2bc87290715a89e3dab845d32d02040e01b9b228fe90b230f4561c3c828d6053f571eef2f622d8ffb28f4b69dd9459fa503e7e4530f96a45cbad9174d267ad3c3a2f345f0492f304b313f7134fc17c16959aa31d96daf26a0b16b4f6274f20af81dd9419f9a6301c9268db797c81fddb2b6235f96c98fb3f45c9f8ce57b8b38417d0485e0966b48222fcbc431014e648ea9bcfa0b1330c0541c276d4c0d305dff70e0a5fd452595a4e3c9fc8552caf56031c6fb894812ee43549ab6a12afaeaf02ef2c8d6fa6c47c5d19c5750649d94569bc14228a7fa17a5d06b135c9caa3063e27e6691339da601cff9a96206ce60e32eaae1ce17e8e63291618ec9e485ba6a692f3832a4f406d0e1a8e33b4c2840b7f3b7914f1f54a7597d84fa646f70c71d0eb994433ea1a68b14e417cf85838af97140f63f034c5d8e7575988f7c8741cd8ae51dfa0061fcbed4b0bc86ae4f1fd0e809e8917c010778931950b472cca81151d1cd7c1cef07bd4259992232632574d01a604a724d1cbb5bb04774d78b68f43893615889d6beb2b7f564da7a641c7a2821178cbf1ac295b20e99fd756f1a80a770d65e27b46006a588f829d2613f7a685e68d488f196786ebbc3b7776b790ac331154f16fb54451e625e5d7a52a15869382aea131aa645ce0c0d839a66a2183c0e3d91b6fd00377f22507630983558cfeadfffb68b12120279119c6f8288e747fcdd6975a44f856b6f958cc12b2523c824a296852559a67b407caef60ecf36b26dd439966350036ec58b2cfe4a61cdd4e3858a74783a80cdbe3ec0b5bbe601e3171a5c2ec8d5bd0746c1fb3749ccc5e8f0462e9fc11f59c56e8efbc9f3e7e5b44d0cfd4c3bafbb2fce99ea468d1eeee543bd55213399d3ebf317e68b217b5ed88c903ef1501964f61742c3055d45f2da3440473de17e081c386ad709764d86690b798b15613d36c76d4caad5a906aabb8da00b2031931c7d436c4df31065024c5345f2d9afc2c9ee9b1bbecd8cd268dd938791dbee40405d2fc4cdbdd18c3f5ef64c7660aad11007938796066a9e02eee713e7876595deda1850061e0ad7bd169a99194dc5d385590b24c6f6a5fc7c44c1473af19c86a7a825d6628fb42779334b879e97548a5f298c1cceefef4c07193e116c3a8b120becef37773e2fb05b7912e3e6757f7e933496eec8b5ab0f0a0b7a5e175f54013c6f5f798b55c6225364aa08df2dfa46724935db88b3f0f8e5d5f6d990da1e2433c95d3d8eb96b2ee73034aaddcad72c9bf4a4fdc0ac7b797c9b29737c0397c53cd97e2c2359a353fae2992c01e9f8514a7245aca6e49ea215d45b0257e2c8415b31c3c9dd250d47f7a577edcac7815b367f2bd056725f0500186c50c34e8514926ee731b24dd6d25309b71e881d24ce290e806be58a508de44a8a8b35cccb19e95830e968e98a9de5481c044de9bdb739e8372c801404e60176ab456f66f7f3d7d3417eba166ec6944e9693a331a00fae8d64338740f49eb01208b4e77cb9dd4c026ffe1ea1501c5b4a744626d5df82472f5ee9a13ecc59b20b392ef3045aad65ac0b2ec596336b81f60d6bdd2ecfa2ed49a5b935d00e35736d642105effdc442f48029590514ae315946695313b68f0f4331432efefba4f97ce39e4c8d2508cd8c4664c3f2163504a0ffb99bf4e84eae7e8b8c694c9e4a9ac758cbd803c79207ed17bb2673413d208fb60013af83f71613bb5405593611d31c0c7f8ca18175b53fd65e8316dad09c34c91c920dedbc866525ec9cabe5f5c83e3a6990f738b9ffcd9d9bcb102613391f485b304907020873e6a162e594ecaf3c2885286b339d9e43fcd41f9afd140006d9c7499bf8eee03f60093e2c0a44ea07601f530a98d02cf54324d6e16a640728d790b2a45aeed35d689ac4ee6ae359f9d0cdc37443cd8e3154f8507a9536fe83d7dd03101ef0ec77b322d09ea7c8eea85cf4e19a0972eb9b51b281d74b5794a33e851a5bb11e377f22c29661b59fb692bb3348f3ad53360f2dab7e382b5d47657514e92e86b4c7a35ebaaaeacd6645473c6c1a4b0127aff8a54bab9c15e3d86195d823977783cd2634be22559827dbf48659f5a716553aad09bde1148c9965f8c5fb4a410763463bca98ddd4eb84462ba7f0c4ac67cd8128978e89da04f8add2a111763beb128a457b1854dc00ad15b88da129efd249f7e05897010aaaff09fe94593509f7af77377278fd4dba2b6f2b1589d18d71083ed06b60224cdee1a10970dc216c8447f7fcd3e36de91d3870c079dedc955b991638f26ad29a8fe8795c608409f2d5e79efb879233e1e33778ae14707238c8d638c392a1cc39cb147a47f7fbd2a66aec355a6424a6d4a62fb9e2a6423ef447f3c62be60a8aec4ab93076fe929623519fdea813cc64cb7b6a4e864ff0f703c093f0e476372fb883d5a45dcd42f15096919ec1dacc7b0d2eb0bfbbf62a92ff0258e5576ab6fe838031ddabd980d1f0e97c69546af7dc568c72be640f27f2c4abfbeccc30547a029923a9a1c1f42d059ee7026f5fa73d8ecfdbe878f0c1976f644ada66d9779e214f04c765b39330ef9e9352a717dd56f085e18a5cc070be9195aaff9144ad7688c5e54e773e01c5ab1ee2e41f70bec0f41db30586fde1b06d0520850cf33ec6a3d8e8c040ce51ce798f4eea829b2fb2afdc3846d345743be11aaa462af139d460a13dd28ce1930a20eb354b294382dead0306fcce9856da1d82f8ccac6d50379ea4da2fce8be91b70ce4dbdf1a9aee11514ccfb1b15b6785a76713b27609ad7b973fad91601f9188b6ab0d9c6e8e4b5fa1846bd256b053cb6451ad21bca8045f46b0e432f57187fa0dbd2ff902bd114c0762102c4d4905173866e698febfd2a7c03705a74c245b36ee453e6e20ac896a8a4bb0102548e75aa15df6ff092e101170f0bf0cfa6456c1a2da6524970e61754f0c5c39d24f61898d8a330d2e5c4b154c9a22f37f85be1ef982b58eb107ce077a22ea579484953fa527d29a241488f2560ee1a08311233b3d7518ff71664879f83f183862da0c412a64960620964aedca49791f90fdd4d0b0101ade70f1f73fe61ad03915893d6f3d35055da7953c193d5993eef8095f51cc62aac1195b83fd275e855eaeb6488c4230a594c446825350f05a723dd0b661fc28d9bbe490d8a2d0b4ef4e6ace906e0cbbedeb5878f503db33c8bfa60b571c804f2620dc215be8384cc8199f67d619a83e9d545cbbd9f9cd7c65c0ca77c59d178bb760f5e9bed6c89c5f62a5bafa0aaa1b404868a525a490dbf069a3d07ef2e669f915291fc193c86726577f37a06bc3dfb328ef21d05660b295f45ac366c6aca5c2a733f41fd9d5fc79c0c90b2f912d6243888742335c62604eb70c742b0b22df5df0cfeb7073f6bfed3fcf95b458d176710fb295ce69afb8b3272759e028275c9aec1fb36036a9f55d4e1aa4cdf78b19a43b59edaea34ba87ca2de5cb5c5c1475824ea29c8fd8914fa088e1c3719a6fc1117d1f7d9e132657ecb538040cf4ee92b32fe691de451598092e63d6dfa0b692e2ef6109c5c9c7244d75dd4e4bb95ea4e3107398295c13edd16ee5d05d6b01e4be9a32ddd7450d27904fb3397e31e821a4b0498be98242ed53824b50661e60a62675507cdba7183fc0b9c5dc53705ca39c0a84d3df226d29d0b0e6083c85decd7dc50753b52b04b8dcfb7c48229f0b7b76f2838101e77a0053377a60cf5caaa18ed04654f743d9323275018630f3cf198a6fc75a07507f9b7b455611782bca648a43a00e5cd99481a4127dbb805a2b19120a240e18aa0bf1f79958f7ab6d7a7c7ac073543a0d62dfc3264a03da5fa16b69608f296b64a17c64dba54e99735605b3ca7d5180a22b4c134b28738a91667b0766e1ca4795d8f0f4ed612ae21dd5647f4a0076ff137bc97b371fbd637ef8392c4a575e3ca2c75844293278e68dd031733036cbc739ca8714a71d2c6ccad5cb83cdff4f9d9c65ad74a32e6f129872d72346ef31d0815351316351b32587e5ef6cea0ae922c5f21157ba7480426c6fc8a77251cb48f67ee5c6830aec6529a32c6973de4e9762dec8999beec0ed9390cf421e88ab97d10b4f0ec464d9a99236fe7e8ef3a5cf8739e9758c3638b3ca99560786448d4686f3903b4c63b9764e38c219ef49ddde26a9c2693c5bc4ead99d662a744d916bb7121ac0c26bc63662c6348ba8325be388be9aa74c85389043ee4f7a50bb7661502d5e3b46b6949eb4ad4b5a49165aaecc7496fb3c680026be63532c380c6a7fc151648bd371cdee389c55dcf064fe245f7a46616014ecb996791807fb5b566502596790dbf7f13ca2e417682a406c236abeb494ee0246e4bc41a23986c475319bed3518d80411149f7bd359fa8be4f86e1dfcf5968cf9eee97253ceb70eed684ec43f68ee6e99e39e4e78c65a3d61ea92b2a885c3bdba69233c2ee92b70e9f44e5bff9cbd0afa32d47a984c101d408273e9d63cd47c9e93a5913b45334f90a5e2c8dba7d2a5fe2872f262668bc728bd05856a4923c21738d377c598e76bb5bac64d27aeeabe49eb5c01c76bb5978b5298444bb986eefcb9a002174dc147cf5e7aa55b82ba23663cc3ed2749241ea537ff0b5fd120b35fd804ff8367dc16ee1a54b1dbeb9a51c1b6ad821bc54ef2459f5d4fe6840a9feb6a675c7aee95138e07b4b61e56ef99fb1a69aec70b7c6748eb0ac1449c125d89d3d96e43470939b3b8e5c8164e8ab5c3311d6b4c762626174bb7dd5f6d2889282180a2da21095061c131c91b520132de371c3bc58532abfe14198fa97cc3243805b5b43e6328bfd9e2d2ea496f6f5d606a77125b18d9552211030c8b1f739d0fea03fa17ed72b7a45f42d7a7be919a315ea368565fb400a0e9fb2654a829cc572a8e26381edb159ddb4e4eaf551eb519b43dae848ddb85c56f36080c5e79e5c48a7f17d58951e1ac620e200ad9d804b0dfcff85aa7bd4329890991a55fd6835b027422353d694d60869acc43991e35c751b0b4936ebb76612576d2406122b9593a7f1940451c066fd793f35eeedfb059036235ef41a479d2744ef703edb38c402ef4ac8fff5ba77ba9ca92e88ca6186e18face069aec0b37807433a544034d3bbfc9c64e3eda4521189157db89778fe80b0cf412e754ab2145dfa961d648ba5235fa899357158cda60cc79351a5ddf1a925b816678798de790209d48ffedab5e3ed459a7f5867c4aa0ccca62882db0c3766b9328cdc1942b53c2aa6ed5058f6e78e5e6fe8ce4028cf09421be7302222e8255689e9d53806db1685b7f09541266ba8915e81b977acb8b3c21a8948a50bacc3ac6af7c9864f080c8971eb316dcefc63041d317b7f51e2c6c3b5a93ca6d00ad76dbd95d9eadc575724df414518ef7718be05bd5b26265cb8e160e8206c5cfec0df6a1d0fd7a6b06aa0a7ff9de4d5367d51c4544e0d4e96b48695ebaed126e7f29680b59cd285d878481cdca8b15e9046c15f3a68d2fdac3f558022ea47ab246bd6d64fbf0193c353912486974d5777047af1fa1a9ada58c33401dda9c5cf845285ae3ff888c3d7baf0af5652a2ba619999e19762d587ee3c5359f3c8d6092f7b67c45c587b1d9df20e190c9ee49e9bd21177074bcefdefd47afa8c9853217c369acf2784f015aa8e4a94784e5b34a91d57437df95d53c5d0195d0acfadbf54e061c1d1dbcd999cfa5b9a3a98da9dac4b0cc8c97acb94bd61371dbcf7d9322cb6d1961a03efc0395bbcf13e0931083e428c9143d6de43c100fa82d2a3427c0a00f61da2f61b3f9b6cdc9bc321bdb14d7764b52e7e70435dbddbe7c366d69f189fe9e89d418ded1c1b9c9300ed8a0391115dbf672bd645bc3b2b44377d6c3d865d9c0ae98d5d5d4198b84263b515cccb908d1e47ea5d9db0836df98b7ee15e860b97ee31bb1c5e6bebf14312fa1736ad1c007b8670e739576cbb99379ffa533dd79fdc13756758a4f0d9bd93d3e539b6168084f017ebc5048a0edd4a160841db366b8efe99ddce5024005d1cf2c3475247e06df543f417fd9f1c1b10225977773bbb2c7dcc0bc79875c11939b895ba4caac703c5ce35b63567aa1383ca63cdcaa8fb324c0ece255a8be0cd459e03764a7024b75e179186e46d79e770970cbf667e8c048595a53f3e93328b5220bf3529caa2677d2da5d8fcc823850507aa385f11322cbb6425b2e8adfd9fdb958a9b2d3d6bae45231778caa67713d727db99ba0659f1c929b5f03a4fa1e4ae101195c5d2bd328dc32ad8b96474b6a262b11d7f113e7130d9967e134b26ad009c83633694f6f67e95a8a7dacc99f351995212688f81ef7db05dfa8106bee5fd4299909880b4700e3ea2ecbda44396aa16160f6a889a9b6767eb261dfd2d59b1add941a67d3288c595080516979c56a1ba8760c8d00fbfdd5fef785dc4a65ac59085a3b201ffd435ce878bb751ba54c7ce33139315cde2d9effd3cd89b167a5d2e20a050b399150d02dbd0459ececbc68be74b58cca67b1044426a500530dd7a1686d7a7f3c0ef7513a4877d3b45ca676ef2c952c5da73a70dce712344c3ac1fbdf49e2973f8b3049844521482fd689da0004572344c008b49713a403af28cc33d12158d4e3ba01a46dec90da5d67f3c7c4c53ae94120e8366e029f2ebe7b9df4bfe8a7c752e474e3a70bec138dc4dea82b159cceef5fec98e258774793c98a72f9daece66da0dd7940d26bc43becb04c40c006ff9b61cd68850df1ff4be8d1cd9bb297dc927ee7c1240c179dfeea75b61348e7ecf7ef80cd9773548384b108da7ff3059be7724c27980811459c4f8d5633064bd3676b8d365aed6867d10e42fa1db34700992c29a4f746215581c602d14a51b768fd6cfc2df4af31c4ab8d3b0a297a56142043228e52d6d14818035231ae9ee0ce61d4ea6ee3c0409e74e2205b28c4a9babdebcb66f8e713ab27270f1c8dce758b7da51c4891e182dcb8109b70beef565368cd7501103c5bbee82028e12152f2bb64bd25a76142913ab627b57abc7ed9ffa1d4ce0c6ebef236b98a36b66c483d1ede883cdd6d4581b43670f23ec8183c4812a9342e95ed3977750952619c54e33ae7516e672ea607e69b5b1dbe63e89e57baa75a33c619cf48c33e6fb288f8bea21b91fa126e527a032e0de67cf6d3cbce03ab31f479c63e3f70cf021c43eaf62257331760923b8c5d2f252d40a4287c2feaa0e50bc9180df0c97b4984ffec0d846709d2719c7443662a4d0f1cefd61b3aba282a1cd891be2a7091bf1bf7fffcc5cefcf0b0a8b78044c78432538c98c0df82c789bb710b0bc4a854bb9d74ee5362da9d5902fa1f83653d5c326e1fdc8509133f45848b48b2a81eadd23d782d5d30cd288ac034667434b512f1819495c51310b725bcb5bbf401c91c7db49712ea6996085bde90a74a32837f49927afc28a552ad992c4fb1d416d6a6c48f6c518c293e36569a1bcc0f32d5ed7e72a514ccf2f6abb04a5296a67a56e2efa856c018bb498d6cc3d4c836bcf025f123f377887ede7091bea87796a4916d1687c4fef27d2899a9b2401025622432790b262b9a342e2141a0b5939e7fcf2c7a5aa49b057dfb5f0caccc196b858396c57ba60e7d35fcad71e2bd3f6b1bd845ef94127d425c7d0975436adb1873912d3fc339cf57f1ddd4fe287808061188ece997e3044d3272aeb87576a52c9991fa556cdb9d6b65eef6080733d2df206fb12582703dae9ee92b2f05cf363dbbc4a38292f8485c9e96c4d835895f0bb3877ce6bbac9198871c5871bdb33a2c942a0841e83981194df094af60679a133610f3ab446901672ccb32e6aca2945c6a17cbf8c0d60ee72bfcfda59bc15207e2ea7e12182b6bcbacb23dad29d4cc35a58ae786e7f798c41241657a07e2d5c9721c8ff84de31af69cf95007533b96e550126668ab0bdcccd1175ce5125bc711653a9d1cac532df0d918fae8887e69a93cd051bdbc862292ec7d6fe26b443d06a1296a6e96838ab64f0fe6d67e37d2b6158178f2f9e1cb815f9431a31f20bae687655f7d9b41de75a71223f2a571e99f039dffebfd25afdf197b43b8cc9c42eeddc7134da288e273df8ab27683b5dddf0351eb0e97dd8daf298fc17d4422426c738d3f2775fc28cdc4e1ea2e441de59c2b68c6d53e70ab327af84d6e297ce9c8a71459634177","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
