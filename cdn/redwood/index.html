<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7aedc66b87f907f6e881a5d4c59870e24488d8ca7b9a2225f52f4b19d455757cc8590d4b41ebc42276c6a1315859f4312073e40a9d37529ab5f807e80547602fb64a698911cd475cf4b7258803ca9a96cb2c907909211d038445e9b86becf62b17ffddb3961b748f3fb84f7248de7e6467b45ec8e8e0c13b972d294528178e785e00314809014db6b1d40f38c2d798f3b228a4a069b6e8b8f17de4fd2ff9c60590cf93da9fbdccb2782ae77efbcb9dc94916bde3107d008f11e4bc9b901b64696740867c9e9f55bbbd0e3562e374b1cd7fb168ebe4446a3ff0914ef918d766b786c2d87682e6c5421a447f96f15667691ff19652a4d91fe1e8c7e87d8a571f253269211c1498ab401dcb2b73a884d5b351c4f0fc111f35a33c627a584afe0b7b18e41b70cc40dcfd2f3cb4324226a7ab0244c310c58c8753be4d73c7b21ac2955b17b444cd83c082ef69d71ba99be27470d2965e2b68fba8e72615f76c5227e2e5222221b6e0f6b1548dec39025cc7810218bcb55943644dea349c54e0ecb81155126c819c9035b2fac9e0324d9efd5ed821ce19c105446e6adc00a89586098c1b9cbcf5ba5eac56d10689962a0cc91c2699b3620380135950bce97412a38e09993bba8a21e0236fdc2cf30cd365625d0ce2eac59f07d42bc33926e806f03dcaeb5a3c1cfbe098be2618986ac3216766c1407751a7cc27dae7f7c438b900af9bd7569f8d92e9c055aaaab42c23ac9fdc45713a8f7bc96326819e0446d83d4de674caab099eea9b44676ff94ac26f65d597260c61ea3d10206f3dfd70804480b0b43d0d3519ce03a736a4e9f4bd87e614e00de3376d32660293ec9139554968ee7bd71e33acdea06c766b7b86a8ea4afeb948a69509f14166e4cbc2cddfc777e86605c43bf6d4eb69a32bddfe68f1a02170df99b335cf40065c0553a94ffe7bf445d242cf3a13adace40c9c6bbcfc90aca0e40848a9cecea5e4d46ac2a9e099f9ccd53146366690ff532212e717c1c8815c26126d3342898a0b0692aa4e617ee696a5c734bb6ce773c175c11767ca7702747c6e3c78a61cf0539e647e3e980c764119a776e57baf428bbf0614be67ff40fb3c8d083b142dea5cc81ba99758813a3e31cf91027868fbdb8cb6c0e606ec1c9f2e1bfb9abee9d3b7e34767ea0b0ffe77a3ab72e8705eb0b4b57b72fca1ee39c2089a7bcb02c9edf6a24c8bb90829d8c053696bbfeb60b8c9aa2a3ad00e2aa8701efd62c5a65a603aaa8e22fe09a89e4f8e40288987a71f9caaa1f5cdde291440397920e3fa0586df2608b13980d07e3bc3d8c637c5f37164c9da3d3d2d04f7f9c39af2e90cd1da3eeca255957b7b676c9e1a06f631850f4f5fc7bf78d2af4947193a15812065578ac52d8b7df1a951e7f1d75efd53d6a26e9b64217bd1effc1936f4da11c98a0e030b0baf7ef3fe7fa57ff1c6cbbb05f70d85453db5725b72c4665aa563d68dc1e726c86e5224e19293d2107c763bfea69fc154a98a77fe3441af07142b06803350d36a947de3229c49faf4668f2868174fe96700c8b794cba8aa03bd2d6442bc777ef974d1eec35a706a9c672c560077db872c77c9213ad0583cac2996d26c610f70c1e4ae122539f2b12426d3664cbf7cbd691d7d0683c01f661266cfafbc98525ddfa8305daa2218c37c0601524c92e1beac25f25238738d34df1e9b10927b90087d9c1e490138342fca2d098a47f4100665a644e92727fd2a1d417db8c783dde3d70cd03a70cf5abc4b11c6c5aed1b52d06526cabcc898bbbb1240fc6c94d06ee023923e1e40a1ec91134bc47e3cf07e4468b087e178578b1fd734a6e13ddda11fbc89b487b8faaf3eb924f914c9ca73240d621b729c7fba3c6cbc15a100d0683611959b62428e7d21979999858034d37fb38d41fdd8442bee8d2b94de4c9d47633b3a6c41c852d29f47f57866f21aff9b7d43deeb35fd94bd2add02b6a1b07487af10d037fbfc540002e504f818677d7e08f3fd8e5717a8a46412b01b4fc43d0fad6a05cb983e7fe8718475d0e5204a3bc6a5aa58fb230ec3eb4abc7fbdfdba404e0cd054b1f25be5ff746cca7d9d874e6471d7ce3c39d1a85deb7692d1c23cb51e4c3ea8b286996b7f97252665e04781bff444f1cdb56742745190d2044f9b578c86195d8841e5408eecff00581d57cbd36c54521223b3b4d6bed27aab3a5731aaf8494296c2f9b850404b0a00c13aeac752cd2ba1e87ad7036f11e5d769c4c3a788648fdb1471668916a97918b10d73cbaa4ca2d2c392c62194ab3398c9efe66c9f9fb2cae2e92239942781c1970795dccd30b138597a63bb1c4e268e5875aa7cda6cdf39f1726b1049e3ed72366f71d17b18e69f3a582ec84032001e780cc943fd35f487ca30ebf9320b7d37c37a85d1fa63ff54727248b43dc7ee561f2122858691eb49df805cd95515ec7429165c1f98e083f661998d9a812afa72d93438fa5092f353fda1370268700f93ee529a13d6159b77c5f5a37b8c094166d82166fb7258528088010edfaa39792ced7cad748a3aa565bcacf8db840972f4ed6cb846b0e0d2ac401d837b0b0b35bdcb2ff7cfcd0a93ff6067f6acc174a8b3a0717e2256dd1fcaa7a7efb3f2db9bf07b312de85d83e6fa567519ff71f2968ea620b934a6f680e3f72e1a2a824ec7be49d7aee5eca2625d9e6ab6f8e7ad451d49ef9599d80fc6cd185b7e20682a4b53b38486f212f9e77ae7b6353edbd07d46e3fd287358ab3fd2378ae9b0d6a690a904a78afbb6d34941fc300d973c295ed08822eea2c25a7c752dc0ffd4ce52d4f84a0898f16fd3c654265f7bbd1411aae8be94bd400abb71e8152953b49beed578f67183e5678ccbf779188bce2e1740ebf368cc61e7f3e97b7d397c8f98cac214c7cfe7175bfcedbe033b02d08656a6413adedb3b256d3543b82f0cab0546822826e194ccdec7cb4af85d6bde8ecad7cbd08db55b3f39d3d2e99b65a7c0093d606bbfda9a8b2ca24abf2e61cc1ce27795808ca8117fb80d71db6b870f7b93d8a21f92c898c0c66303c237ab4d57046d0a4b47ba09f0c5d01bc68b944c95f43bc7ec356014b05c5c5b4daf95afc482a767adaa755e7187c2596961fc90f9d6c1cf931ec8da20e0cdef9e13bce764b4f80145e731dd7879b3088cad05c0d71b4e53f18c3b334acd2674aaf2598994d9452b1c71b856f0c1afa0424d2fed0e036afd447a713efe9614e4f71b2551293e1feb1753d853ebf8d9e41bb8cf372de5c2e0fb7ea9fc5ee62380584c4f0ac2e272e5ea9fb31089979028f7476cd88d220111f1d6f1c9b0332a120dc1087066b033d7d48fa0c986c35e979b1dcd7bfc130dfb0f874c8d7ab1f50af2abaed6dfe45848c7127d0e0b9d980db946636da3caf7f0cda784e956a6b60396ebd4fa375e2d3ff7a51e378a91349ddaa5bc1b630834dd95c3f0c4fbd441c4c15d83531b1c178fe12528e7507c852a98b7773db67031895ad002cbe75bf631afca8af0201725c05ef3b752095461f0f0c83b2910259d6fccef2d4f0c600ff9de7e555168223c514aee137e9bb0c1d5ed12f9b2a8941bad2f9bebc00f04c6d7df394c607f62b374c66e88f30af3ab540cca3554933a8b5d215f958a7e48dc029a4fcfebe392b023cc30934d248a159a256dad49e51f4a8be8bc54aa8a2debe0a42e566b10be7583839120856c9ae39e74907c716f53babe199c7c6fc015adba894d11c5cf5893809d2466cc003e2e4d97adf7b3aa5f6a90d35fc3d84ccdfa339e532b9779d3af5b7626da24721a55c4c11603b6fecf4507e64e9364f41b30be2c158d4c789493891dee3d29bfd5cb2a83266415ab75489a4e383e75e99aaf29a3975953b89d2ce5e340c4545f6eab1fbf942581cd732f8fc520f7089937409c1c361f8f302a4d09f30ae413e0b56ef5e1117b10833d61dc3400c042f0f152703d6d5ce09ff701f939ab94f3b50df72c3b07e7841f8e5acb49709be1a761cb772fc8bab03519547aee85f2e84dd065a3d50ea41733da308965273c1f98f3b40635bb2b17f48d8cb21b793d9305d759d43953a9a21f150ede2d89c51fb7bbd0beea74c60bdfb1b1179cbf1823a0b543a01b3d1b72dc4894d75d32549a0cc4553ab48ec0afb7b29b7154b55c61a7771fbf3538db9ec96a126bb67a297e18b7502b8b1139d624f44532ed80e9da5a9ff97c949e78afcc4dbd2ca929ce87af8813ad3ab6b6ff80cf11d4f3925d16ed525437871e7559b5811d1d26d51619f4a147e1063e78ac91f6e002c636b2b44ec9c6211e5ce2f57081b354308d48409deca0412a8a1894701ab84abd227af55a380005926683a96d8528dd89e54f5545c09bf92f8ae999157a4622528e8f794d0c6002a9f0dadedcacb7e6f7f5427ff12fcd527922f51dbe50e807a239c03c24be6b2aeb7f5dd0d3aa559677ef8301fbcc6787406f12dbf8576d4b8f9a589c8e114c34b8edfc6d7484233a13c75c86e87acccea19d6df8e161b8a7c0f001f7349907a12788af9f10e2069feb6cd269d1427d3f4d84ae182c9716fb7a3331177eb7fdaba5e778a67320e8624d26a6f1b0f6becd243054169c719dd0665a04f0c98b3b2e0fc5ad13ad054a5e1c2735a9abaaeb84a9f8cd3cb97e6e0255a0966e2776aa68d5ae84a7e1924e9fd27648bee033df4317fd15136a37e63317b4446b2d6f825bb98b69ea7601159e770f9ad9f6106e5bde85df6fd000ac36ec1e8f9fb7a27cb692f351add04c6c25d9b3f5be7160fdd5d2d58c0a2db1ed18ceebce1d1a26728483c64b6e8e71ced90517b13e090ab0f41e101c5f6ae98b136187d9b5fe0372e98d22f98a6e4c1ffca8a6b51f982bcb9ec3b3904d4a0110aabf9a0835cf9ae06aa605175b2847b7cf9946042ed224858d083fb80fe1d5e19eaa4303c917212fe9955699f1ee61a5c8e9679e8b9b64c7d1797a7e2b339797e6a9076f1ff791ef49b369bc5fb4fdfcaec1d4fc8625d4cf4550b93fe0e721f6f8fb335bcf3ad2216376f55cd201351365f2ce591903fe50647028ca29ebdec9b61d58c26eecb91debf7acd1675e62b233f4bae595839cd3d354fdd099d3f202a541564fea1af7d4d8239c81526595af5aa36f99b74be49e0c838719ac2bed6eb85b9b81989043fa745d7e5af86c97919832ef5d4283a6ca2c454893966fa1f9c5087f374bc2c27d29531a38d82c531d1fd31d2e45767a09518a65cb05c3c381426ff46ea5ccfe0417d7205d0b46641cdc91f1390974a3980897eadb01f8c9ca05b8faf09ce8992859e5212799145ffb31b376d3e159541f285dd9bec4036f2e891274d26f41acfbb877616315dd8b1b9a31a82590e6fb6fd004bf6b4fa55aad32fee7e25229f3eff0906bc5d0675d5e221e5cc2b34f2057b5fe49c435282c4afd8bc2081bf913f7085e5c2c9f7540b0e07f5ab8944ba07fa92852f1dad43a2a9fc40cfb79c451f8e47bdf4c43bfa8de67afcfcdf62a2d2de73783c43927e6194fa19f908192979439b6f84de86d55441f6ac6553d7f1ead60effa2baea50c919e9b88d90405d17d9ad17eef9f504117b4482148847d2093235c5a94baec8bf831a7a1a7d0b8c4a4076c5fa97ba590dd379843ec7e71e2fce4676482ab6c285e2dc192951039be6f556c92921335241a6ef810464786eb27f25e19a324e43d93527650257ca0ebcbcf73fb41a463db1da315c309ae5ccb0aa6a67ba8fdac0e7b82da3cf6d2a8bda30b70f665ecd980094422bb335f3a10a9b47e689edd7c1b85c8d74c8529cf1865e63ed43a3cb7eb07fe9ff18492542b32c85f48b59007ae044f8e7360e61568f49b00ea20a6315d55c4c8cfac1c47477c2ba488801861e9a046fa342115ce8702df8b66408c84c5c3a7adb200281c2c4e0912ad895bcefd9a6aafd6df7b80e392ab2d76217026d76a551aef84723f2ee1aad851d844d7a78d903022859948a734b38dfbb9a33191bf14ec29cb8788bbfb994774e538b9e214743616db28811fed9ec487ae3fb4a48e943495ddbb4cddf0377a43af6768353f0370b6373091ff4c38bad194a605fc3958eb57ed98b691ba35a34c31bd32ee914716e99ed37f6ade6ca6648883cbaa2cf9902b8de5b7248e9a22dc49329fb1d8714fe9e7627993e45db549a557d966c229c7c31a198e827b44474f6d244146b492ddc193a53ffa94297ddce2b00b6a492ada77329dce6f5c4b7a63223d6888fec4f381e2be129c662f1b66711bc037d47590717e1b5c346c1ef03851f89b9cfd54ad9dd84259e7ae97fa8c73218f8e030edc6a285bc57c890696ee81d2e93be2c708fc8d0615dedc33d06d537809c9a085f5f986a707e5538cff5958d4861b5d263a108a062fc368498479fb0ee576603f2ac460bbae457f19344776de201e521b8f598f291e1346a04d73f7d432d36674bdd90abfe39afb814a988b92a3b8dad3f94a357d9a01f73a1e3aa37590836cc6178a246c4ac220039afe6317094ab650603cefa35e7993fb3e1f615aa88bfc5658f0fb5d10780bacbe4597dc246cb6634ee36514d8bf01e8669f62b5a820024df41a80d0f24c1c494714d9a96e636a6f4dcf8c6dc6b71075ae1f9bb11054d9734deabcad9fe8b6f6ed7b104648b0ec92e00c5d48239e3f47e74b4ea306680d949caca34551c316891fdc7beaa8f0c4235aed252e4625b18c4e9f2420fc91e7a8e087f6d92866e079172b0d06992531d1c9e50d914771f6189c265603268e80169995c64ab50a9829dcbc0972bcea2bdf1eb029eaaf7f29195e557d02806a24e625ca91c08a1a9207e97e199a1e83a28d7637842aca043b5647a80b8d8380696c6af4608b1eccfbb3d13b5fdf66f913fb02df367bdc8cc282823697730fa12d291fb4d297006d3c42c77a51a42e2f5621990f3000dc9dadd28838d5870727843906244ff9e97c5517a9c4fd4dbeb0fc5c22aaee2982209f25b3d85b0ac9dfadb2600d56ca3ef31d6ca179173e8e9e469639746bd0ecd623f6c7315b3cc31bca26c1bf0332054146ac574e79f8d0633907412eecd8a4188ecdec2f3ce9f680fbe1c1b0e374c3f8904af82f72be12ea1a2f8ee59010b1f95ef03a4fed26c6dcf7a83e150d051c6949ad4022f492aaf0135ee08ab35303cad6222f441ca002d38ff0969f8751f86ac72b388b032eb1e776c43bed04d25f36380fe7f4571db99a97e0832c1c11a46f5f732ff6b8520df331350c9761287ac7ec5b3ad5f591ae94f0f997aa903cc1c5eebb035f41c424b6f76ba2bfd2c2fa029557eb0ad3345c5c901e310d577a4191a27b0be61e820dcc2628df1ca4f9631104154bc6a6a2e2fefebb6df173fc85c7b9811f61fc6a73c15bc7a02af3ec372c6ca9127413c631b65c6dd4294d7e1ccfb556d283d7d151d3fe5454ab241ea5bb569ff5a1048eb6e49f166103b3b287fe5e7fab64b4aa2452f253e9c78c0a299b29f9b5ac0d334444ed53ecba6b8d44579d2f60bb46f7e5a7558309cf006711d202e640e0087eb91f4a0ade381352614becc2468d317f9288e0f0abff0fa099329b05473a6227483c826aaacb30c4d0dea4b66952d52d648ccabd0be436b9f26c0f641bd04cb7548d72b50cbea8e98e5bdeca624961acca7316c348e3b9321440bc1474be3d4b3146a1b9bac9e8537d0ffecbf02ce6c84bbcd38d0063ebdf9eb92ad9cff545e58677f55e8084d29c02dde51717a7b83864371b7bf165034d55d1b1d925900156897f2f6bda109997dc773a22924cdc1dfff30c08b2ecb75e7aa7d6aa94150932c91822275c3d2ae3b1b8ebc2744d523a09ee95e16e0b788df83080a41443ea1165cfcfe3b768718c9f8e5af09546c6c6950fd39f4e94c9d9e46f0bdcb7bf66ada1234aace41876c7272e9e7b1f931624405298913ab6db67850ba962b712db75747ef512e2b93ff7d240aa0faf272eb7abf32742c90f6449c8ea7f8af1baee245064db9777905b337a9456183bb49e2658f01fc9629330a4ca212d940771c6e3d40bcccba9b302fcbb34273dcbbf559fb8203852ad27d51f618da5e1e2405c5431e3e057f5848156c85c4bb177f8a6e30111f24b8dfb66db711c6f14f5e41c2658a3e3fbc8cab07d92e62d740527bebe91d8d847f26af8777e7976fe0decfa8c10ad56f0b3783880c2d699fed47adde9abf3549e9cea0f319d48a44652e13a85af893babecdb7be57225d15f95624d43c20796fd6ab21e2015422d0513900ad2aa8c38f1d547899dda5fb512d623ec1c8caa936d501c880d5740d95f819cf0b1aa14bb85a4f5f38e567f8d0190ab73325c883394d5a9209e44efa692b9ecaec243529b55e506cd1bade6a6a91dac2f17a7bd50ab9cbe967d0106dd318e8436edcf0c067200ba007752f92efd68b81b361570679501c53749f38188666434c16c25b423306a9179ee1716204ab3e7ed34752df47344c9111e6d39cead6dd39c5907821734ce080e0415f98043823b67983dd0f0f71a3f35e653b03707b2b06fff7f6a56d36b2def8f48c9dc6b81bfb0a20215fb014f788dda7a62929628970b93b923e4af78ac455d209a4a8315efb9e275bbfbd60a407d003052e14de42b0cfab1937f61e1681cf7d0b3c0e85a183c7affd0dc3794787d678a2c7041e052dbf3ceeb4c322f2f62cc86133de2a50fd0b1c9ee3c60a16df6921aa4bfd37dcb1d04db0e011a59c8befcd74cb9d03b2a59303ea9accc6a8cf27330f1fee12a478368fe332173e1361863a67798aa23a7df3152b3630303ce4e7f51ddd53acec4a15f80d06b9ed20a0f5d8854398d24a8ba3241c92f63577ea3218a58c03719f9229a82bbb49ecdbbbc968408ed229555ec7a2751d42a43cb3cf4709bc48e5df4f1c995b8540c5dc60a4cba7bfdc28de1113a34639c83014e5f46e2b63d67f94121c6d45a8e0d3405834c00f417107d3de401bb213282c067e4d51ca9d3327a1bb259e5bae3f41936aa53187e00049a648d6fa7db8872bf6ea948004530d72b3c17c95b25bd02e0ed188ae2bdfd51566c6731ff7486fd13a0b7dd13e7f1661296ab9a6374dfefb837c1a7f8b541338dd3524be4f819cb8cca5ba510a13b8e259819aba120fdefd58dcbd64e0b5783b4ae11c7bb9e466aba02676e09e434328c71c00f72c1a8e24fa2abeab6a5d74cfcd208998d3c0028152d425592a99c2db18c181e642c7f82c0b56278706c5c4a5aaff5cc7c00a5685c6609632f2dc512e18008fb414c80cf98ce8135f53cf16e460d06e0a7539b44398358539e143f9abb52be6659b18bb9fef0c8cbd770e73e06f39ee87c5049698e284657a7fc60a4487ce2b3475343692d64ca07e4cf4950643808e39dc306ce3e3e543b3f9b0bc24f239efecf65ff64820f2d49be69a1f4ad7f6493e9afdb7af90328fa73ee1df0a8f6232389b7a9bb9de343ede38ba507fd0fcd70c47d39c906eab94eff80138ff40b030a805c55002c1a453f46aebf8ad5c2791e3c429cbcad2e6e0dbb20976a52e40b0fc49f6b811a1ef0ce06808fb29747be60245360e6d0359c2717dfe3e20e63bc170606dbbf4c55f1c4c4e744ed9193d1e01b10defedae45a9044a8c83e97b09c1b8209716b162ae38f5ca611b76165e28c088f9ff2a68a7c5d351b10e56e22e54760db7b0e7d3f3698d6392d37240daeab35176aa71b59ecb4c4ff708ef2a9f4728c22710fd9ffe21463f782cedf86a7ce24fea5fb566581634932ee65e38c97a7af978423b9f15a37879390c340d48fffa3c5d8542ee7c0374c63d1c9e6c5aecefac74eb63df60f1773db0a1acab5ed004506e50313557f3c8840725ed00c20fbf560325e35c07b45a19d067a0f9479390ec719d07b830e8d72868a2dbeb1d36daff8a936791bcf45878a02b39e3758b7155b2c0674552dab436d76b7cb9a1624899d1903df82bec864cf88e7ccde8d7c4b0e361eab44c95fa554db37fc58aea8e5da083f76364f13d7feffadd5b7b03da4fde9d966d82653ea7626dc3ca8050de6693de96c0ed13fd6d8be998921d552a2570670f1cf20a8e65cb1f6ed977e88e4891556fbef2ee9a10e941f691f7ccac7c205153869239eb9963815f0aea4bd36f0b7720fcb07d3f6651caf8335b9828b5a008cc7e7010ccc2962f5a5c8fc9332dea721f3ef86d2839182adea83d32bd7a9a4b1f6188ba7418ce6c2f1051ba3eb2b1dbb57ce15da916d2864a45985053c06227b49d144fdfeebd0c831c517af79d5a1341d752407ef56c18263b11ffe0dc52179169c616cd212fff044c302e9ec910174cd5410e086386e2b1f70ce3d81c12783b2f1005815b2bc35ee237a9f6f47851cefcdfe477dc1bba845c9339ffdeef9998f6e36816e9b0c4b57f913dc8c633283bf90c490112dd86f24150a599632a1657f0352b9e1b6110cfbac65ff9331a3e3c422cc1c22095fc46a140462392665ff7e64168e1066cf5ef53154ef74a5055a6f84b86969dc7ad2c37878c4fd9f75d74759717acedcd277b5091b579e812da6247fd678f0a9da5158b4ed6026144c886eac3cbb71f0f484f5355d3052e9ac3f591f3bda7d1489b71e112c158f3b571f3300c79f80e5de34d4cb72ba795d91f9e85efb7a24a5c184a218c8892ca58d2e0fc7c781b1ecf3900f3d0f48cf1f694d534cb461dd836267f17659e917ac1059c04bc2b8d69594c0e502133a6474996a4282104a34b8e18b5686b2e9a6dd541625bd4518f6e3a94b0a064b33f1a14fea068e1d892561ce07ed7110a14e606f295e26b335d5e17d286831bafea5b0ec9ab5fd1058b60a6d0e57f730ba85d04855e23f9cfa902dd503c53d0ea4cde3d36f02e7cbba3a10fae69abac3462896f5e77d65e17367e1a71c1e8ddb75f59d130cd8a3050b5c77937439118591a2ba46cdf837cd26a4032b8c7ff5fc9546c65c3590dba83a1991f62ad7511b9248dda8d4fdec67b0e0f2e0aaf78c10cde84163006d62d6d11f3a6616d09ee23e9a5f8fde9ea4a7ddb5dc075f63b945b08e4eaf1b03996f7ab4a131e409ec733d8ef4295bee6a76a987221439068d9eea48bc80700396b069aae3c930902b927d6d31a32369686ec2d42fd0942aea1300a5ff10587a9985901d5d1f33e30b9d9c6569be70006e5296cc165d704d07f70c55c53810e18d90ce75db35b4dd3e87bd26865211710925942c6d688cdbc071ac1bccd26642aaada02569a196fdf0620b9747e4d631dfd4b9c3076956ac4ed8cfa7b184acf4790b89371dc6c9510abf904b032a342cb979004f679d74709ccbc07dec18d9a50b3e82ff3b5e15b27d52490aa806ad65f528d81c063d5f4f2196d3c373416a951c708635f8330e85b445d1ebad07503d6525e5435957124eaa775e83d5af660ab79a6e55e034277aa2e61b0d287817b9d1242f268a4b58a515763f7029c36f22e2a84c34725c9c9f09abc989d524b36035f61bcc48244b0048045aa31aa3b07021b0e9f3d63e6895af55bea6ce723ee7b5719c6d3052c8c23a0da588e7235c9ead118ef728d5eb43df746b80172aa517c6bf3d7f0fcee9c3a727e280c1f1d2d982f752026456639f52e529e6d090bbb3cef18e5b34b34b0df274553399eeea9b70b122bddf8f328408fc48e807fc8d089cf1d0469c71298957c4a2032a71eea6816bcee3896a88d1d1e3ff077f07917a9183027cc991e132ae99016aeb61112ef2bf64a0834689050caad2a900f5cc21f48eea23fe3a46bc8c1308ac8a8657965a109593dfe825d19af587960bf4dfada04d5e9a7bb0607384bf4d915a7bfd4737abd37a0b936e941e3f5df89e97a61f4f16cdd123ca7ba54acaaa80d3b1263828510f109754de5e923b38200ab828f58f47186733b20cbf581e7097bef1e9a42a5133596a66574c318eb956510862fb37a8fe0a54a7ac91efa7eb7d9f2f142404a10d63fee430d9d22ebb8ceab9c9b99d5e8f224c828370c4e00258058f840aea17dd94cc7e6fb7c42811e65cbc250aaf7b075741037358006bfe62792dafa929a2e69c1b4a312d7a8051e221853d10e0c374bbf402d06a4601707b8420d7c5cc7cbc9c24547e31254f3c7724746f27e5b9c68ef1b4df59a589008e6079faf5268797aef31629c1b6a211a1e122a9a2e5516b1ead5e635b30e3fab4220465d6b4d96a0449b081b89a67466f6a7ee2ed696ec0a1d3eb96521f39a40ccac71680158a1a2b788fd34a369ae564c077f884638fc0f1c6c43082e66a4af7568821617f342e7ccccba9858320335abb852b19328dcaa9f20984168f74f120256ed58884eb746d00625ba7a96a5200cba5d96542f462269cbd896101a6383afed7c3377deae17642359e71227552befbd076b40860ed8b8d7bcc442512d36672c2881d431e9e4623fca22ae1bd726eccec3f36dac2d437c03b3e808450c9f251fc12fd43dd5de7e12d75f86745159b8e6b5141d53ae1c925d0a07fe51e4f763537106c5e856f4d288b8a419e297018761ea50014f62ac2cc805705768cd5862432e5bd139e59c27e5b23e6e48f749f5b498e1c40822390dffd70811307f13102b8386b7440f76ee422d12702ab4b5854410c17a899adea4bfae94874aaa1146dbeae6c601c952e0c5a41a38e3296358ea4e55be2d29b214619cd6e2416ea825bffd721bd0eb6210e51335d4097257827907b3e749eca736422bb11a073f3bb9034babc3ad2a047035990b73508c87b5bff7f03cae83aff579cea8d2a004e9ca86b5c772e5b3b0678b84bfdf0907e7ced157b0914a72ab9a3d7316fdc8f54fa816c50df694bd8e1ac2290d2970a9f0011cf5978f076bba18801968079fb80c969ec69d18e2c3913bedeb113225b3004ef44ae3d5d6a102e69f6e39d0240892fd526b2824db3208f8976b7b49a14fdef3820f8034010fc0280b4d0e9df9858a509bf1d0d4459cdf35823690ab8e21eafce55262fec28c85a82da928108b44cc09ac16ea72fd74e6e75a18de104c1c5abdf0014d88e2ed4b5ddcd68408eb899df73bf9d64b7d6499c51553505cd92e490a8b3068c95b2f9201867c89a9b7bff694dc789b33f648da748a4744866b32ac59b63e08f1bfb018f573cd2dfcf7dbb5eb51def208bdcbafd8a04c9d20fa68ef62213cc1a3ec1746d0e35d98e086a23baefb8fd990553d7358416c47465d0a2d5b4561af195979a8cd89a36527a273610955efaed2b3e37a81efbe35b482066da35738892bda4ac877346ae83abd5e68d8384c04ccadd41caf4b88157d200b8cdcfe7627162a38f889863cc027fafc8bb66b51646149d73253c1010b689eb3ed5e2ef8525574dabe830eb902c128c20873f79020ebbdb9ab7188d5cb42d3ef57204ab2d55f3543119bfc3b3eef3405b9cc6d07890a4c77edb35c16f6c0769daed8bd57ea2ad19af78d5aa24b4d8cc8492893f0d2fd0ffd85ba4b7301f1f32554d487449caec8312d643fcdfab9636c8d8be272e78fb1b2dfd0677600db30df208d52e7d0005ba4e28b36c6a4a14e4a9bc9f92c4515e5fdca135295b84e08b172d056fd540f46a733c6b52a9ed1eea598488bbb6e973f8678e7b376464a954490ae95e03643d27452d0532494357375dfa7185b5adbd0d0de0059068cf1d2fdf7e2e9a21cd7b1d9af5e842d283a50416c8212481497b1e116fcd70d53bf0d6149b6cbf2b8f3ef6a6682de09097233eabf9a7ba5d4b6d07b03a111407e32414454fe703cd8023305cf18ed202062e89108a6e89882be03203f6c01a74b0a8f0c65476c821c101af3f254687d93e52230a63ef43e675b5ef76ca6be2a346797855f5550223cc197cfee9d628fab8e65da5af4088322f1c968c2de94ff8350633bad7a6badaca8a54e0ef90a23a0dddaf9307b6592f813dd9fe89211c0d516a53ca8173f03f98c53f38ec2fecbd649eef8758ff1ed31972e453e62ae980550266eb7e56f5bad09f03b8ab4f526349ca02b1660f2b8362300c4aa0e734ce1c3d73acf40a5f5cb141e6c6e1ce7604a66cbe57f12465ddb0d3833dbf90e60a5aa68a3e5d959721a7c8cf86006df02ae175335d84ea50afd4806ca047168573f7f2e92364fa8d3480af98d185543cd0e3ef13c0334bb2707e64acd39fc8ca37fdb0be2ba7edf59cf5349b7b0c7b6c8d216c9156237829abac67d811d6a12dc3d8987e67fa8e807b792c78d9c29fc15e27569596a91544a764fe3c75a0892c1e20513ded2c9ca12b9f8d88a588035d56cf8635472f06ef1750ec378582694ee30e1783cf4254bae1d3ef18b77735b08e740b42e052af7ff82599a7b516e355f983fa80ebe0df281937949a5dcfb52d4d8fc9270bb063bc9b36aaf4c7b0ea37c65b76b9c45987aa30eed9cf9ebbf659ba7dfa9e67941143a20207203270d1e16de9b43d63987983d35cbfd99816faa84255b19b2952e002b873c5cbd032640250e0ebe70860be5e2e87d856fae43b2a29cb397f7312cf04d4d09a4840f99f7f86249713dac4fbca40d0aa45f5ca1dd7773a2789013dfd8abe1c342d3c59e7e9d5d1e8603eb6412731ae58061d9c33a348704b60020bffffcd5ae0e750880161b45c12307aa26934908640915994164e707a20c2f1d4a9604f6e5ceb45f2a51d11858f11f0adedb21f567e3959d27900dc7f231083b7c8a68bb16aab1c322318fa24567df4c1f9dc9372692584abbcddf6499b1a7a05ec68fd0ea04299da5d83870acebbddf7dcbdf9792b224b4a85b58eb55759e80ab2c6419ac4f3a511efd234b6657a2d2b6faaa5ba151db2e95f11e619bb8521d73fbe0e917da2f41e82e24f65fcd17d914c21aad03dc17bcb727dd2f6490394e8b1f33f8458aeef4088280596050360b2fdff61f806464b26ec01e471191f61ef85b42bd2cf715317880509e9b98b9ac3dde96552b46a6c7e9dbb16ff76db298ed5d976fcd8aa85070c26b16597b1bd9b15b0f5b263f36d589d734559d35782a8b4f2ca900aefcac84ca2d07605f45b2748837214a9db4d8da62ae4723c93578aa55c3077188afd4eaf8e2b31e11e4dd9407c110ceeade332d0d218f4ead5643c298336e5713e93539aa7943ed90f0a6ecb00b7add04f6be4075affc34c9ddde08e9a33338edf886093a79b60729e332c1cf4fb8cf8990d8c7db6a807afcb0da3f8a8ba72bdb023d92b3801c0eb8b7c439dca9de2ba148246c1a3e9f98b2a4f5e15d431155cca4dbbb5d2b3d2c0fae56174aa837633fa273c6ea465711faf3afc4a8261228a09382858eb790c014000b85b0dc2f1e77bfc4c2e903cf1d6ba20f2c41e9ce249b0187d1f32f036c1ea137aed9cdeca539875e2a2504b5a1262f60162c4c8cd932154332f8eb8273cb5a2e0bcf3a31dd63003117001c8ec36e93f3cfad55f9719fd6c096da376719e77496606181ba255a23e2f1be7572cc5a6080890e6c56cdb2f7b9c252e0a7fa0fbc545c3f8d897898e3e82b128ff289f209191feccbb2b9b9e35f2b00ac58ef3be1516a96b7589bd1c873c94ad43631f2aac03d41419ebda87ad862c5b381de379b5ff8a6cdbff37d72b80242c5ec540864903b1624dc387e4cc9556ed33e2590f780393a05d0476d682fe5bd43afb0ab37e671ce1e51c19b21daaaba44ad2cdbed27065db49d4e554c35f954c73318af8f58564f23fb3e646ce23d16514539de329949656a7efad5ea8e1213fc62b27ff2ebc50559bb23d412b27d77fd503f03811358daddb464557026507e50ee2defdc5890fc2a5c41334ce4c09b4cf9123adab76332a5c50c0f0c36bfd09c5703ad81f655e3f548a4d67d482e0ab3f6c18c28740ff95921d3b494b52d8746ff392821ba8da715b2b24c03b96bdab9506bd149c299deb3807219b5d7500cbb081ceba37ac135da4f42e3b5d5eb0165d872af4304e794cd20aa3f7dbf6d3aca8e661673f2b2b9e59396464292fb912cf14566ffe6e93e853ed755779c28ebf11f09adea9d2f4c0507eb4d6f5ff066c33325defb01579e4f3a5a57aaf8621703a5f667788fb5bf5af6faf0871017a0ba43a5538cd1f3d686821cf739387a66f0989e708c3c7f6e1666e462a87aed3c338625b9b18eed72454dad6800486091ad28bc35697d59cce2e99f4ab8f01efc62677a70c551825609dda33dbd80b8f8917058dfc52cf03134c258eb5025db534a3f7a8f216a2821367247148c0d3ca24567b71587a984ed39dbffa4d222a19aaa3f52dae29aa9935667c1fcdcc508008c31fba8a81a358b0225a4a2bc47d68807d47f7a7ed8ce603c42617b77ae97ba7c0680ee447026a50b73b5b72cf3d4012896af40d3285846e307c4ec9583707a6815758ff413cd7bd1594eb9f850a44309c2f5a7506ce42118516d15ac9582a15bb1ef61b1650a672eebcdb834ac3fa4224216aef569fa7d26b041ef61cd69a7e509fb20c1a63a9de613ac77506290b9acb4d77777698ed117364a3316717a86fcf407b425137aa6f65e44d7e202b227f168b6691911cdb90371ca8814b00844b6fa55f2c597d32810fd8c2c2d41c56e41344cb98835296883d1780b6aeeb621e8f70b267a00901c5d745d0e2f3cad5664af0af4e1e3abe57d52cfa1581c1087858fff9e5efe254da3a13a3407c2d0c46e4f020141194c752f85ff0b731b14470f84036a1fc7376f94b87dbf65db6e06d40251aeb3216a9ea8b9ac1cec7e35f8b4b9da9ebef9a7b8499939aecaafa033dbf06ee862c5375f445f3acf5151d9beeaea8b5921d2b0a7f2a577f22916fad191b3b72e49377c2c941341fe04b18f6b4ad87e628e85692eecd83c6a78746e282f42b927b13e0cb25402e402142bfc359a8fb36fcad1748ec2d7f79e29e935fd9229357ac9acc3e5ebd01025289b2c94b64db6445e372ff77640a695018c8ef9d249c3e5442c32ffa277ce23049d7b855b17b5a74b340442b8530456970b029cba3d469f094f8276250e0db458a03fabd92f09859398b909594a057f94b85714ef635a2f0f6f9d3bc8fa8b2306f92d9d543368ba8e41a82cce047bad630af5079d030011130a3958a7acd4f0293047dd315744f4b08e0a7c89bea628e13cbc8c0ce64d9e9da083feff1f1470145113d438fd0e65829560066ebf0fc6a265707d711d8a3a93c65211eb5dac657cddff93e8e56cbab5762b6b3dcaa4d2d2151ea0b3516e3bb9e48b309d54b91fa9b29e7e21610068bdcd882a9110137056bf1703ce3e82b692afefa85eb6f45ab817d496b79e2e50323ab8d0ff5df2eb85a48d2d07b48e99236321fd73ee7ab4b4db8fb53b55c923461fe10adf974ad45123be49d58a2a352b4a2e53b70cb5bf5b7047bfe0ab32e0933c94f5cc3d9a3684aad617e908c1ef55d58b48e47af9002db01c0f7dbae32f6e0389aacff4afa57f92b8583b607ef0540105c3f928fbf0c5c3e59beab42de95cfdf1b30ab0f516f5bff88e655b53dd4ba405cd0c555edcb0ba97ebaa571bad2054493ec391172b73e21253c3804e11e5bbc1ea4822c178d58ca3f8a620b1673cce905c65e77386db2c6c44a65f0fa8eed229cc446e48500bc6c24566289399e78fdfa4f1d7790d51c853ffcb3802f998290942730fad0d70f132b82452b14c18018cc515fb7d1c12981aa711874407b523ebf994931a6a6337fe829aa87ce165bf90bcdd6cdbf998ca575de13ac128c0b88901de7173394c7a3ca8f4d34e0a4a2c86f82dcd81e2227531803f984ee4599b9dcfbb1e1a5319b1605f1c81d86ddac033b79c889186b5e2e931432ca5c97f3442e78e53535bf18e9e3bb5738e6427a1c357be7380aee6bbf16cdf6e7779006bb037504f6c77c83d1b93b191389986631a2198b709ba442b7b1a855a5e7bba0e093576a35f2f76813182b9c3b26093ab681f476822b53483d0a04b62703f60109884263b0a3cece8ec3bf9f473ebd4926d633d27df7a8521050b2582c325e6f0406ac0967c1a130a741781373b577f2b16a0c8b0cfda8769422b994e62ebf67c960340826184757aec49b10fffc68edec9f1f03bcafec8b893f08bc4de7a1716dfa4c55435da38ea24f1334","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
