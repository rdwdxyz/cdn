<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"310bd6f221e2dda382bc569cba8ec2547aafb300df4c986d55384c7ef601bdf961d36af9d7cc62bd5af666dc703ae2b6d7dcba23f22105c75c130a727a8727a3b5a45759a0170015229299b6c933bd4c0f2c970d9e7aa49693bc775024fd2fbbd1d30567774f9e339259d23e393c0a67fb1911446ba23e16666443cc30a8b8d98787d7b175cd4bc974874ef9c94a4aa32e6ea843c7fcd8f40bf46ccd1bbb4c2f1c27200efb058f53c63be256a72a834a8d6c7e55309d53dd703351ced8ff35e04f2fd80d8aa033f11e8e86abc86cdb005c3e2005fddb6d372829e2a83d59f26361aac9da34f1e5afa99f69e4ef78907f926fa7b4dda1d77add1574c81c4071a8a094bc60cc227c9ea7b882d71f639666bfdad8bf91c283b0d6445341be5b6aaf9f41b1d6f9ec471deb3509398cd2da6564e4a214c10db6fe2aaf19e70da91a80ee05774fbe8576b4c7e9a2da575837862aaf7c0b2b1c9c98bfe36727fd339dbdc31ed4e314b6982a94401c6cb91db94a80d9a4c90f0035cdbf573b9a71c04e76b2269353f0f5b40bfad5901a2112e791008279b06d47d24eb02b0b599c6540fa840dc7bd94d57737c8c43728676c606853eeb6d214a4649feb54dbbab7c0b258b8a9eabab9b2148e54ee42550eb3109f08f69d33cf3c7c3492745c3ed68faa8d267a14f57280a984b04961688eb78120231d74f64de29ea9cef943f17d4d7d61d9255bb749d8cacb2b840cf361de4e0b6cb11561578f431dacd57ee6dd8dca2ed0077c003b6c29fc849b3ebc4839ca51767c70f7fa412c8c367b721aa8d32d2e568ba0a03f161f1f9e635169fe539ba53f443901aa9f26b4ab813d89f2b9f829d41e83521b18f0a3bcfde8d1b6730ae1e504706c965ad6e252e7050a8cc578c8d3a34b8f548d9777386fe5092241a30049e25bf6586e9fa46ace0a348bcb832a2c59fb1a9cad929beb42485dff7473a75e7f5713f322c41a0fc58a7d4c9806fe11ec8464cf5f58c7d51d68bf035a42f9d2a06dfa58451f4fa7b2bcc5719080ce3bb9c0ff56bf4a595ef814df1df9147a04219d33dcc40ac37807b5b6080f28295784e6c0de5d155414c152aa1e6e0a08b474b067fe41961632050258fa9f645570e7965117dfeaecb4382d8fbc83ed6334dfe6698b890ce2c8b04a327ec921e077d8605dde8fb9ee4973cf04174599c146e0e7a8e0b9202e236b8691fe702b302d52546af4b884e71ab78c32f712ff7bd513407aa695ef5a0be38d994e0c9a06c18eef6eff2cefe74490529d41dd23aaa26150d4493f35ea95b919d2e02d5cca555b06cbbdf384d69f69a4d88a9768ec6ddec9c42290c0f6c893b752ce4421baccf86d068929e4b2e34722c81b8842efacf2ad0b4fb4b9cf1f3bdefd1b24972ab3affe3282fc6c43281e2e5448da2ea1834dff345f4cbcf78c938cc852e79192bb9f3dd0a8d1caefc0d4aae124b57973ea0862abebca94d07455ad4fb4030557c68ebdc2a811a2f8369225bee6f234c8dc3ce8aa1a9d50a9b41b90a7556abf3e98c02ed24f2971092f9f203ed98ad5df68947b78eaaab5977252080e702fb34e47c4c1434fe62fac3993989ab2e37699a05cbc4d8fb7ce929565f01e6de371dc6ca785a8d7dcfc5ba33ce40a7b400d599ac7189a3add9ec18f389b7e2e54211766954798d08bdda36c8fd77dfb129ca6a1903cd456d2c9bcbf7a72cad9797a05f1ac47f96ea81d514208b2be4774e6a805a7a893cc50f65805b3935d2050f6b06c6e9244166dab0e7488b73fa09ce0881c5ccc035f8c13e1f520166a1e11bcda908f0e81ef7ce03c0d791f6560e47881db820e8e0914de2fd5ecad9c262d6c9ac5c77dd26b407966a8227435db9fc733c5e8dab584402354018f0667c15eaea1b37247935c359e7ad3c5be3b4d3d19e7e998c9cfc2baf03fede0dfde4ce5dc2445d9f62580c5aebd709f35aeba64dee1e03daa9567e8f5450af06d9e5f3147e243701dd7218f9d1789ea525e3ae0f4626f6de932b107236177a3215e18777ea8cb20d2d8761440c8f69bc5699b6677694c3e8be20d4391168a92e25353794adbad0dfe3b59b69f30567a34297cf2fcb1d436503a5b2d5d53546cb3c7617da404b07991cbbd84fc1b8116e46590963be547d368d78965978af9ae95bd4f84f9c55a0d854363cf97e77f4bf2752e837ff9c64773ec618c4f565a8982ec7854dd937846fab4e72bd5dc4a06ee4554df1699a2b330a66236382c4068d50d8ec3f3e035fd15481f2e059c7ff4da58650a41c0f81015255013127b0e6396cab7dc4f5d985daec001f97ef33d4c59776bf08177ffd5445312cf0d29c8b32bb712aa1c2b0d3c2c375b4cf04f1683c441359335bc3071ee65f7fe3ac0e8973c6d0a8cdb9230cb3ac8f5e09f095455cf60743123b4a87c04b8322309b72a59dfb3f4b2b216ca0c60c93f1978cb235e95d6fcb140d93eda30addc866b66a7cf6ade5adcad86c71b9334e4635070ad529ae0151957ff36592cb42737f83e44d73ee305fd01c320a63bfa3ee96f47ae03fb8cddf1e68a0b1951bfad3c7e626d3d290e4eb9c00597b2f88c212256506a364837a993fd2abf3562046a5007de973b7194cf3d7e0bf8ea6bab8e47d56c4a22a4c1215f3b21bab1c45f62f8d879623a766cf1572c3e7b4c633db7d2d02384cceb0a2096b5521ab75f789556f88f5cb14f57da5f892700865f6ad1f1af0b472589f930c741ce3ff29fb753c4c2c3a207b51fe55de677f3288a6bde47092683271654b1cc2685808b487033c735c1e33c09df8910c3fb41538c66fae686c2c09863c5ddc57643606eda5d0d628c167026acec1c9aa5d6a6663c99e28e5fe74121dc6ed0b8376f7de5f9b7cb9efbb9aa71844f98b975e70500cb41d212b81999c721ec1941e9a808efffa0dab1808738f846464a7ac5e6adc2ad55465f8dab6193c3664b601682a36ed64b5c33be54c5690457df65e28ca86ed7aaac39f7daed94f85ef92d5511b08293927458861adb9df08d14a4d61a61d33356577d7627fe6e5eb9586eb60b802c7bb8ee989c881b4e9cc9d478101933f849682bcb34593156bcd57e309b9032202ff89e99b2a3d9c0ea52bfc60df1e2e310448c905105d0c7a906d37558f7f08f61793c5b95f687ded4fe3be37a343c26a24ac7ea08dcc10757d59633d861f81737121ccce10b9a76c07b6f9d54eaa9692bd3e5cd357605f74e8e5e0186bce48233e8da04435611d0c54f0f47d46196bc3767874c25921abe64928b82bf6a9e6510d9751dc504058661cc73c0ed4ebb2df4358ed024a20829f30b21102e59e8d687790f37d5ebfcab10d37e4ca9db9b11264af272365074d3abf8eec093df660359f6a551403350cd5d1145be063451c5a02730131af8b3bedefc051b2099443c2be296b23a10423091b3ed327ba603c52655a21532086349216e659b12d06ad34bfeae8eb0936269d241a49156e9b1e91cb5e01fee07b6575bacf2a2010f22da0ec5642c4a39f67913efed74efa84b56bfb3a9e1b0f1557e496b6194c739898d2c04582529bdd7b36ed0d2e9f6a049b881ed1839934b4782213922d1f6286e3ec884c3cb3898c9c4eb47d4dfa1f41812061792cb0ccd46c4d07e51df9c5b698d2ad30011b18151f234cd063fff704193b13c1e795254b8f921b78ee733fc8894ab3a7d57857b1b204578f70e84cfcb870277ba4b4bce8a5add4384bc4a842df46c4c67d07bf9673d483cefe6106a546ee2405b8b95d9ba2a8a28f716125c376335d0d01d2f0d4650e4b308aa6c284a550a3723cc698faaf3be1d28119fc5a6905def1d4560587d08e2940f657cb770448c98af99aa02409f19ae01911c8f438a6ca0bc5bd8d6df0c90d4968b8b98b04dc5198bbea7b45d5c77edf13ab26753564e163e1d7bd49cf11f318e426793dc04e27f18a26b4a9e712e4baf3e8d0411d3120f223bb904a4ae0c88e7caa2c556085726c72c18680553d6b0ae2f0befd0aebd6ac9a19c922eb7150cd9f4eb439c0d5de8f53d9bbe80380a4dea2a3ea876f419ba405b5c1d357edb9e2ff45184458a3af09bd518fb20847888bf7b61e88145bb0d07f4aa0cbe235858fc7bb939695ad99bf39b1c330702b40e5cc27359af2b3c4fc850662d3beada0d0c9efb7b55b7f4fb612820dcec674b039c486bf7a4e695d743880d50e1fb33e03c2d8108d60654ae4806d97ba925369db542e95fdcae0144a0f4214e1ac32e4da37ac694fbd5c0af3b8847fd005cf1567405858dbcca80d612fbefe323f08b188243e0eec1062f8deb642157e27d6c0c1aadb587f1d2645689a4293d6414eac6b1f2ad6ba83aff4307f50a64201a810758a94609d6ab88d8b0b1222717385aa06171c49597e407ceb3ec961b7b4b6bd73884687d5a41f661c5556cb984eff6a42f1ec48d7d50020e61ad4f9226cb262fe96e80e6ac35296fe030604a6e0fc751af57fe9f84e53310d7e4d4d10f17c907c72b5b51ace76babcfe8f54019150e37904688b53aa96ec1f0d11316ccac2ed2cde38f0e0ca2004e65532ff0e43cb85f97109fb699dc495700e4d0de30f3f3d0361a270a27a97ef619c2ef2177f8e14e58011be29ec2d0bdfa7611f3a49cb792a570fc3fdff44022af5eecdcb0c1147bd46c60b34229c74979880e0146d7dadb5c0f07a2f698cfac1bc770d030951ec89ca14833c98d5a33b96eefcc0e1b787a21a5a34a5a878032d46c6d4c20458ca9970f3ac636f7beaf93f65693900cf049663ce40dfda07f0353b90232d4396728931f750a9b25ea007772581c050d767e6e8c607f9fece00de0ea771b893791b3a9fc198c011bdf5e1f301f276efe20ecca5c6a86cffaa577dfa4c4b7c14cf48a47af6d2fa101b72607510dd71ce5fd81a9ded71849befad58e176d373d91bd815a5607e314a5e830b639c8edf2d15d7141a2fe89ae68592a892f6e667a9a7994d62bc4c9fb4f65c5b9312340acb83c411de63ac0eb08ff827e152f77c79ea0c458ea9da733933fe7865b2292880b8b746ff88f96a1075fdbda91d5533da2b3d7871fa5d972389c309522413e6cab35029ec18d455e589616dff54fac5084f76975bfa11e42ec12da600b7da66be2e7f5ded99cccb098ac0f29841e501b9dd7d19ae3c1a90c71a71e2ff02fa4322ee407703ba3b9cbe68422c08a6339f04e7f4d58a7a9b3aafa600320e9b6c4644e781ee8c0f700b46d06300242140151209e81a4d397c4b27432705efca0bd77eb4cd33451475c396a1396bf1cc60f2e19ba6e53275e167ad05042eb47eaadc9acbb0a6bcdee459d6c9b90bca56016b02af63de274769d676276a1c7980f42189a1821d00e6d4d2a2e2f0f8a23a003c028a8b81767b6d36b7384623ae2bc969ca83fbb315ed59817c28492c25484d523882c15ebe23761246d12e66fd0ecd680b9f4a959135f54f4b1e2bca2db4dcd4cebd1f84c5c099d0bae7ce4d2a779bd141f623750d3cc8b654eedee77b4f41a88351f06af70a33d9fa537326fde7d4b0e8752c94795569b8986caf9e3226dfc77170157d1ef37c47373acd3fcf69302afaa173ea0bd4a5f4ed9022079156a877d5343ed2bd40380240f3e872f71ddeea2131dc113accf6f30b722bade7bbe05bebd5b20fb34ae5f71d5dea05d78f2b56aa621bb1fafde76546329278f11e1bf8072762fddfb9c6eed99cd2747f71463bf6d8c94e5608f709dc53476f0ac377db1668c3c2cf97abf28a574e596f2d9471cfa8595bfd1a0cc0f6d2a6da1dfa4d743cc56bef9e8a369763728d59267bb6a70586dca84a7f425c0243900f497726097379cd6356cebc98d646d2f3afd685d7bfd749a60a2a201044b98717db70112d8bcf4ba3e5e28b45d20813dcbaa2f16108e8dd941e6f0e9cfdcc329d8f79f1877bb5033b020d0195739693caa8ab92b9a64bfa2d924d93c623b10c572525895976537b6b129b14a2780448b2df5821e99aa3e0ea069fa7266b8b06d059c59985fbb34b8ac5b2b62c5b88ac6a6d4577e70120b19782023efa92245198ee8c0c9ea60dc5379c672534faa42f0937922f8b2ca7c1981c267db94ea8e55d467ddfb34cb7f7486dd561c1c686ddc16b9911ad0e90a63d90dfaa5528695c6a9797fe956e710ffd90a9de54c0cfcc36f8cca1bed23d8eca3db438d4e0f21357fe06ae97ed2412357606f2d66c0a03921d6f364c01fdb0c39f5af6da57fff1926fbcf353693e0ce8e73907473c006c737f2b5d29fed9f2fe4866a6e8c985d0f17525398094122545e0b32d591d1df955c3161a786baa3a6e48a4aeb15e6572181a31578a175039e6bac8d118d6c59329c2e485991baeda5b6e41d2d0dccb142790bb469e5e89f240aa4e01e36d4b94c1a15662c3e190bab386dcbb35abc7d1bf12e9daaeb1f892576f1b3e0c7c3811faa28083d674b06c22d233d9dc1f7da0d2b22e172e16c5fe86b39b06573e756e8428bc4762bc270b59fe7431ac25a558daa0e7ea32702aea6bb3fdf0036ed80112e3d98f627528356b60f2565ab6ce82c0cbbc375a990c33bdcb41c20ac2c2f181a7fb0b0f190388ee82f1123aab95dd54e0bcb1b731445cdb9d6bb64145e9762326a1ba9c5b716954f6e6d0a6c26626f5aa9f10c107867187c905317d08c19e9b0ca96f121a5942aaeb4426677cdd64b4e9bc8515a52aad6ee2d9729a711741b6b737127aea670da7863370596d384436ca9c4aee86818bf0af2161e99c748baccc9ec7ba3fc95fa18eca26c34f018e3a6235966e0086ca6e57e02334f561fbe79e9eb75c626bb2877f73837c5404115a03d53761cd991978e7fb1804a2408c731e73ef7cadb4efb1c49b79cfcac129a966552da2575703b0d7e708d43c16660f8473425b2f3be1e774faf555cef2d309b32b917600e2273d5fe9fae2391248b64ad66e8cbc2016bcd4b38d1c7a1904e71439539328dbe6917db919615a2f4337fa4acb54ee58f36ea72f0883c154c509a4d493562c65c615745d69e0520fbb1741645db6dab20de37d1dad11d9cb747828db2b7a1faca0f8233a70509ea011e64bb7476fe2cfc0b2e04a5d4b712ff606bb51a01c9fec8acceacc5e9d18e3be1a6f94ce380654f29c31d2e69688b74c64352301acdeefffa02bd79a640e0c846e589e242f604ffef291c1a9a537e717ab229208e5c2f13e27b16b5afd77f28976e4f28be691afbdb3cd89993200467ccadf27a21a820bc73242bc0711c2ca92d5792684395a5056a50b8eea2c8b07fa27fdd258ec827f3b649ecf05238f84e22cf6cf8a9c32908c85d7563aa2e41351eb50d96f0b46ea346a3890cbc429c76efe06d0ef61b0b571bf7f45826f30c9fded8006043760ebc69d12deed70b998bf9a5e9f6c8f72b439bd86cef1c1a63fcfaa09e02184437d03f88fcb09fc6c8584aaaee4a298f4aba360d53e80c984c8883d6f67defb358a471e8a9ebf6bc1631bbe983ffb12f3bce7eeae0f1351f47bb32e6879dd72b3c9aa5a64282402f7793590ae2918338f91e7ecbebb650c09ffa1b718e62b54f9de04d0d7cd2bb67a068f9dd5055a757fca77d9462577d2aebe5950e6d2600c516f84a5d6fb418b8855284c9f8234f7c935da6d1d8c055a9ee9328ab5b73339f3a3a60d62175ea2bc3a8eb2d8aae0bb50fc06dc9abd7f213b4153239d05fabf3115c651421ccc38ba936f6e3595eed82c8c11d1787c8d24f74d1367e3914fb0c43d9f3b1267bd3b3f88aa534974f6ed2ee0837274ae5b36542c8c26fffb1029f0b56e8bba3a32c919d93628d8f92199e0f4c1db0fab88ea7e5bd21bdea70e896ab1f9275f97ba3c7e4fbc494a1985924fd718c671164fa910d1d802957298fee47a63f554f7b2848c246ad1fffda6647d0b925f23da2080224d6bb16a8a77f3f4bf6081bd0db9e517f39ea1ab4b2ae55f1ba91ef63b18172ade166e0b50c4c716c2d99a1cf844eac4490d53abb7c127e0ede037c26898e0e4dd9deb4a02b42e2c9bbc18172b59bce580c0df3c25cdcdfded6869390e7e7fa1d4d4cc71d494a892f72517407825e0f67e8f0ea9cee9a06b41a9dbac2dd19e1cf9938447b83a0b6252feb3f3dc6a13332a9b6d388fe497cfff819567eb1f18cc474c22d365c6dc724108f0bb22762ab5438950f9b3b95b0c4e7f09aa791ffc59ea312895774bf42b8457a4fb727faa17655717e39b5002dd5a1104e7352551e4ba2e6b89cdad68d8ff613b14fd3a4445ba23b3898e8a15974261202fa53ff72406d3e8a97f95632b38abaf01239c0b0e685a6325b940d690f20b4dc69ccf966fd2691df70d69f1b44c631651a2565efcd60d48fdc5d1d4fbdf4498a6fad072688912cfa71b4a16d67d71ee1c56330609dc6722fc3697825a83f9a613a3a2ec3fc1e4165c42f3bf517702e2246d132d2f2d7f4db927cb9e95a293f054b5690bc876bbce5b1befbc3c8ea6719c520f04a836757a2b0d7dbc319fd96d9bb520b75a2cddfb64de87d2bcc1fb94e39a1b4ce7c78d5aacbcec355f00b3d9db4ab0dd179d15303e3471c8cb3eb2f387eb3dbfec3ce1839ff4be823a4b2c93f709c80cd7de7d287b2d5b43685be262744cbf3d79ba13361de085d492b16d02312f8e78c65940f299a853d75c65b178e132575b5732e50cc817636d1512dc5597622e960f8cc6d3c3c6697d4382112fed73c090239d9f32801452840a17989db496c173d20e8c2f74d8b6d0edb06d05233dcedc2ea7fe4f2a7e0ca08d359948844899d677ad176a7dcb834660aab575611b8a0333eb3547427eac4449f4b30347a2c42cf358daaf021c025179926fdb5c8282cc1948e0d5a5df2ec69ab283b133f81d68350b012b9e4b2e30f046d4e67cb723e3f7cc02ae5871bd0490c2467433f840afe962f87d6dc0345353ab20ccc30d61422599109549d9276f81ae3f6303ecc3cf3b4138de564eebc74b9ac77ef2e5ce5b85ed7cf5cc9e95f8f310dfde73b8bf85a6d4a307282a2abedf8cc39ade12b0c7616470ebd964e18e25cda4af38edc1956f977928d37a01986ce66f435665277435b758e482d24e071b9c51301be26786194d254da11315b369e8b6e1a3f5fd0ee3224f9b3777b965f212ace8386524c5b401763fe2f36c0dc652bd9a08de9a8cdc51d448af4d853e10eeece3606bc50978c775dfd65d0340ecf63f0afb7d26ecfd485cbd078f6fb90d9623275d42494754de93824f01b8cf986257225b5ec7f150f7458780ab4c65d9beb49e20a187afbc93a3209729f549337fb5f43c4c1135700fb5f2268c933d22eb8387e7e8191a34d3a00320c5339d921d91cf746885074cfc9e356906854e5a48c376743be3a47975f07d41b406bcbcd1b60f86fadff15167fdec004067353dfb1f45af5002e6f108c7c4caaab413920a322544e5aab93ca7666261c8b799551d00b008e8c939a7e1685cd3f8a1c2a04d69b8e99e260af436ef64a04023ed73d55569f622733c1ea136e0dba0b7732e3d1b71d8b66be4d77a1cecbf9392b35ced386afd0a7eec61be279d03d3e6fe0195d8603f73bb1e464720db41fa8a71349255921a440ead1782d6d43722c34873ffea4a43e4ad5e4f590177b31827ba66100a7beb86a611fab8b7e96a4adcc4fca9cb861573597ed95e4e81ad65ae1f5aa2c015f6569a57a03d4246d73eeebd6db5efa73b0d6476ece73fb59a9bccaf383b9f0af789c76d208611ffc4d106ce3a886ed79b3478e65112f44ee7343c0daf42794525f54b6e5ef5ca725b169a8e0a3993a366cc9e78659fd710c096fea893f9e8798a59424d7f7ae982e5171580985e3f0a1c73bd4ce008fbed9dc49f2a75a95fb69611762010945b31fe0648e20088587775d6bc16bdfbf58014a3bd3d95bf14d65823af2d53671a35c1ee12e62b3b33a2e281d62fa3dac9c827efb3aa8225c8024e088fd9971bb7bbd15edb3f50f9a74ca78789cb0c28616a433440d5b8b6380c7e159b510558f867677cdb058616ee79b974cb5ba7614668b9512aa6b8f535abbf9f0ef9666be8da4b533f92aa8f45717a1a566150252e020f0c762754ea9261517828c03a8b1549707e73a1a5704f06edd6a251d76f6189bfa8161e95106043bc99cccfe3a1527d4d60437a122d1238d8ac0ad452e8fce0012e59bf09be4c0ffe8ef1083aa629f4f137485d0ccd7338f5ac1d483d06703f5a1b532bb0ba151c786665bc610532678c92f76dd165f22bf4bc8c506bcec4187f69a909b68dcf2f36e7dbdc6d9e2cc51d7b7a1f3187103cec90fa08a99bc05073694fca9bba66ff35097b7324e39198fec22ce048991aa625f86f971889b273236bf380ed40465ce11cfc12409dda396a0c5eb45e9597669d59e250b5e8a11f9feefdc0d7f88fe553429401ccbe567967aa70f9747986f5dca06fbfae30754c1c47fe797e2894a99c3b6b8afa0d8d907b40449d623610cff8a0dfc6a629b838b43a4cb58c4eb5bca60adf8e3e017048b546fec8f144a97b131faf4c3874575416592f9a83d7cec60ef1d53b66673d6d5ceab2f461dc00eebf96ae5b51b807ac55f232d37bcf981c3ceda3e62eb3ff9f954d27723fd90c4537f25a95ca3c13c271f938d9c969564ff771f68fd6cf0eedcafc77abd9a10ba98a51774dc02b9b2309d1e71bedc167964db603846f7ca211e140e1482f1743f3dbe50ddd72c59af960661935377d44d2cb814fc3a31ebb305b82aad2bf389e5023ad999b8a4426c4edc4b67c8db81076f1468ec817a617cdedf4d9ff5072fb523ecaa401cc3afa66800fd9b375197c656fa72a5e3c0fb4995bf13d7dc7e869b95093361c4940dca1cd8ff1f41cf50bd1336f62981059436680aa3eb86b3ec4e197bf39c5db369aff9349ab8229801c272e6f60b6baf54a6796f43bdcb5142db6bdece27537306ee81c612577761de13b2fbd71b08d4d37b520706103b863afff8f4f7bb19480bdffcf9fd3ca3dde89cb6dcd39501f98d1a7ebc29acb41c0ff7f47b6b7445d75c087784aff3ae5e79cb004323c3ed61bbedcfe00ae2323e4ef51cf98830e17737531aeb5a13e3671b7798b19310001159b5a9ab20130e1e8532c157288549207c190d57d8481bd2e68113e6b2c38c0a1583bc309d7fedc958a3fea7de1a6134b0fbf1ef46fdb54dc504d50f144f958de0a6773ebda0af1dfaae8f62a9e798969c54cbd904472ca0dc0bb860618f383f04cfa9ec8e4429981afa491a8747323ef8d59f0754ff155795f2e0ad774b3b34f96e04dc3a3a720bb9dd49b959e92efa3c47799c3d0003eeee60b2dce9fb888f4c0706c3ee07ca7aecdbe7d34a865dbde2cc120bdce957c125e1507a35e4394e6ec9d7c8ad01ac6a3ab5b13442fb681a9ea9626d7d0d0d2400065b8fe4286387484aa65a2b3063244133188303b5b15a9cd242e32bcda4ec56ec421f85f9d9064dd1c68f2979e31c864d88f7f026408d80a4a1e5fda591db3e274f00751e8d0acb44351aaffa562b16ab7d64db4a3ac6e64e5e22c3de3bc9eaac51fa7de381d78b60d71192eff616c29a3879cb42289f59989ebf4bac0b5b906a34e8b85159982c9755312719fb3534b344661e745c4f9a3c28c6711f9cfd59a53ea44246685200bec1a8e5f8d0c45b325cd1e9150f26b5b75a1c97069c47c8a7fa14755a9b086aaebb76aec1f373dfca0a0440e144674f1ad84624b4ac9d1789bb222e6bfb719995ece2b4a4d651aa6687db30c8eb2dd514a15bb8606f08c6cba8277642f3ef8131aac9fcf41dd5ac923dd1b78812eb40dd15b3e032c24a5c7a6e833a39bd7ad5ef064c47ee02b631e9c9acc008d33f19357824dec9ede8bf1444938f6a8e7e8711dcac19d155defefed687b1640db7aa1178ff6f84fce3db20630d25b2f9d86c7641f9ba23819272fe0044870d6aab77097a1cfba8c361d1005b57c8d0cfe00005aad5a382ca606c3aba2fbd9b6e9d48e9d80f06a62ed0478cfd7b600c2fed43d41effb6b6d4b8d1e018993de32aacfe3a62f836b5c94ea181a0b46db610fea1771e042afad3ca44764fb56ba05c858f0edceaab696972d3f2f5bd15dbe4bbfb257c67454f0f84b98ef94e93a61e449c8c3bdef0fad3120e15a601212cc27ff0259e6f4b2eea51ad11ca82fff06b7eb8a48c88fe72cd2276d12f37c55dadd8ff3c76b07206c6e7ab5dab90d8a4d69876ed14e85bfa4c6e6a4b7f8e478bf1d8e4d7ddd9a5ca3b48baf56280ff84ccbad944414b766350bf1247f60db723be579ae5c77a8cb5f9ad2962cddf54748be8e34c2fbc6c1f6feef1722716d441552b5b734d4ad30b06c4ca2a347c2ea0dc8b51cd81b3060450034d73957fcf29bdbc285d05117acf636fefd02705d36f778128208cad6f0940d05758e0df6d76e6d5e2ae3f6f2aabc2027ae13ac15e396df345f1dce7bc7f38674f23a4c5461f59f58f1521ab533736ab1e3fe13c6da56d79d2fe29e24a3f9c18e5e11cc42d51922136ca5d68b46face835d61dc07a800f244855dca678153423f083e51265e030b20d258e020be447652b5905d70b4e2691474264d7d8ff688350b0228422a6632b0b37e4f1507af0a95ad8dd5ca7fbc4ec492e0ccd2ff36677ece76b3b5597264d790dc703c3d59e0c1b7ff3cadd153f60d4aa3bab4e8ba04dc2fb689002e2dafad9e13b066cd5c9adaa451bef2a8de546125ce1a5aa73635724bb06375263798c0780859dc79e8350d4fc53daada30fc7380a624b583cbed766627fa2d7c79a4f1ed318feaeca7f773582b24de0201a0639368f4bd8f6b2f81ca33a01e331fcb5323777b97b1be30925b2042c8d5af8e95f73598fae431dc1073b0fc0c37104a33584c2ffdc7f63ae95cc24a5934678447d100920c09ac68ce7876254bc183b04457d5b1e51a3c827399a9681babcf3118b83ffe03e66817ce6a9794fe115c5f0e892eba33f23a1c0278b53353cb96126ee251708e8bd156805c843245e335812a4c037b4614b79034736897639d79184d12ddcb82e1f9fbdddf43f071bb6a662d8c128677af78da519040f4b37157c10e69da6b1046d1d0d027ec2febd4da99aecc8495425ae2594ab75ceb77d35df8551ae5babbebda5f22dc17ae6f03000e84d5ca79e137560a9eaa18c18754165627411ae73f6b1c51f8bcbae749a9117afab1fe853979a46585a36e08aa221b687a04a3e37d2e78bad31b6cbffb23980786aeee7c82e83129ee279c7ae95e731a0ff76569175b9c23a8c9f8b463dc8db93c7b7b6e26d77107c78d7f39cb9008cb6bd3bbdba8e86fa1c1046dadd246fac8b6a6116324ddec5c94de166ab48de035cdaf884cd52396ca58528025aa903c1f97503e0c7a434a54a5aab97336eec967fb66e9d01859356425d940f1a51c605517bc7459dcdba7e6ee939e998b4b6ca13024396a6833837ca9da875db31382ca4e15b0bdf9a1d213a174018b880cc60d17f672923b3c4da0827397fac03d25db2fd0ebe7457c3bc5178e5c5b8fbe082bcef9c262fac2ff7cb17aa879d8b22e6d10b8ba01d52ca57904f575def65afdcc17030c0255486c9985004c4f978da67a34f2fe5283ed0f419490f84225b75f1f13a1d075352d77a023248f8ce06a0686edeb2f853ba2e0b22f8d617a330d0e6bfe41faa9b26b055042cbbce53236c9bcabe05507e421822cc4fe1effa9f585b830ec77c4b789c00905a402e4e6940604742e09ce00c13974e2893d93988cabad27756eccc71ec81e29c7f93b12de7ab485befcea9ade0411cac22325e8b560565a2ba9afa47248c5cc0c5b27519fe3bb93c0878efc24a1a7b7273f652d04034f16fafac28fe7b2881840da2e668b884355a0ee83e4d5d606da0bc228a2e83f1f041c14f91d988090655e6185255acb756ccc27599c9bee4c7dcbcbcc9353a172b7c0e71140b1337a6639afff66c09981005d2277db05831091f776f7cab18d4b7603192b3b9a0961a55f220f1d610a8b90977b593e35250352c7c44b557925f9900c75d73d5d717d284eaa8af954a8613033c36f833e448282d6d177c334d9fcb82aded939e4e55570d7233528ccb3d6b4da5a6a3e61dbef849d05509296562a0b5aedd22f50f001abc0ef04aeb1d958e2e2a04523c4add69d0c6fcd2b6a4f461730c013fb451858ffef395812b21d04228dd7401705376e8b37c5858a044b25d9ae758f790156103c642b32eef349368827b1a756f602ddac7851a5ea74611d71d93808349dc5ccf76dbd3c176c0f3cb79ca3a4ea2f2defe5de15e997276fa255cd49f34e510beca3106da193d2a0f0cfba523a36223c29286cd1dec573922fcf90096b11bbfeacd30d3f860bb0fb0a1d4d5633fefc8a58800ff970034ee80eb338db7673182e5a93533f9c21449a0ce81c79b15fd47d6f9a0c427f508a82836a47d342e5d4c3bf628574d4cb1d246f18e89409493a4e7d175155e58017dc5c5dfdef6ed6f65c81338a329d47dfe4b7cca148eaa515ed11f91d90c60b2fd68072a834767d85cceba04b5436aec8a24bb6934e8630cbf539120e3cc592549c322b53fbbf6513afa21cfe418d45c2153ea90a15e56653baa74219e89896a8c758393f56c44f25c89a73c30fb00eb127c2f89fa7bc0b69e5e15fa6a8393075cf226101dc9429dff77f667e435c56fe04dcc6affb55ece5e9c5b89c9b1cf1b7c4645961eb35dd4ab469fa925ad900eded046205e2212b869db86be31e6e905a53ca5ce1cd14344d8ce29b1c6e3753a81ec5fb00e75edd0e4eabb1b99d866e426c7fe36c428a60e49c833341d85d82be3fc9e709f2133fb523ca2f8fe6dcb408fd0e00fe85132a260b2728b387d5348841c26c1187d962509a22f2fc7c4db73764938012ef76a16f933b4cb12deeb2c8720135966ac0ad85229fc420bdefb57ff596709076935df937bd04297b1d3bea1de18a3def5d62573398c9226103560568973633fb0ce2ef0ea368e6612b9a33b98d05b21a41f550635ddc67c3a54d426cf2d29e67a05d0d2b187433dc421687e3d2771a8d710f45804860243d646ee974b61046a4267693b0c9c43f7ecbf7a078b7c716698eefbbf00cc3cb6dbd3a996b157ff15cca598427ff82775675f425dced174e5b8311ad9bf47cef50ad8aae0f0b14d37ba849f2f8fa20fdbda01bc73e9c8d565d311f24f7a8b1760c5fdec58766d3d632e0ec466bbb363d35d3082f5a9a2b8a950ed741288f3cb356dbe10ccb7799e15f5ac4ee000b6594c434397bd8d5d8165443d4628765d5b2b823e9140cb571da124c858b4683f0d7a0412ba0db41e7f2dacb5c86b47dda79ef882fcac56fcb32583e879951dbc11f899298e3557f2d99748b41c8bbd465744bff579f217f1d4cf6dea1fb51cb3c3862ab91a2a326bb0a4c3c4ec53caf6b4053ec50a520fa656a00578bf2bfe10a4e52e83552743f2494d0ed9a18e5de7aee1e102c00aaffcc25faf43f7bf7e8e4c9396739509fb93adbe561e1ef25fde5cfd688452a6d64251d57027a1984b7074c0b7ee2d8ddde4a6f3cf5044e8d38050dfcc781d23dfbcf9c896d90fa0bea7bd91639a82b236c3e3b3de2f633123154acc08fddd65adf0effa6afa3d49486e544be2d8edb8df7cd0a11048f48fb2412c6a367c7eb769c7ef8daa9b424da95181fbcf1fd051084f2751923db2a19265781e394436cb23886b6fa1742ed22512eb0f8e3a18d4f5f0fa3909d0158d19622fa3020d2d56c8438f79763cb6fe262dab9cf7bb897c1f62c4c6a7a21faabf8e7e67e8e81c8255e812c493cf5511337979686ff725bfce4ebf2f29669ab55f638030c1316b9da7578429559e977d9f295b79d4a1300f0ad61b88e0a74011a6bda619be00bb94e323ffa0391f810c1e1ece90cc947d6ffc59800ffac8b7a25fcc1ab429029d7dfdb8d65941b3758441a29f1b0b8fdf6f8e9c73348f868425d8251413ddd6f8140edc31ebdcd91bb2aa5bb142ef86fe689242ee64743c5a5a69bbdad3d3e08f49f998373f94292089c8eb416bb22e8c27ad5ca0871e3882e55babfe512ed6f5db73cd14a6f6c07a6f444395d26d6b992a520818533c6ec583eaa446ec265e7b80a37b9c3cdc460e6b952ac60cae5a463f7f0e8ca51c22f2085623d2722da62873478d1d053fcf384def61bfed68c3cdb981847011a0afc55b9ae9ab06136110cb4bb4b4945da849d2415b324620cf1d3976029079d28686ced343113f1e8ed5c28d4889e11d6bd8ad86e040aec49b5689f01c7a88981af6ac54c1bf7cc2b8edb5cb8fa548448d80f443bed8a32828ef9889936f6ee1c0149a171a00f7d063e6dd81f42c40c4d283ee9be2f22c02aac943ec737fce30d0a70bbe1306742818a4149ec06933b4f65fb980a9c22aef5f7c6638a3fc04b26fb8a22800deca559081f7c55d1fc46fbb037f58fb8037ee353affdea445dd9d0391662a938aa3c1c4d830ab43e189700537c7dab2cca0a26fc9e858716a2061a9f88df0d0bcba408bfea4bac722e80308840dc32a4f8d440fb75cdaf04f6dc22934c3feb3e36939577cd644afcd647f5a98e6dd92bb4bcd33427e95f69b8ae70cfb2ebd0a418eff78e1b8adcb4176f8c0794eba054d1b30c6e09c6f46e3930835bc295f2afb04c7b5580d570fa0a39ec1f31408f7e43c6b916f27db62b6ead74c887df0a964bcfc759100dc18843f848945a731b5d60c959b10309b586596337f0aba35d6c4f8b74e3217c7d38ab550a535e289b23a5122310c7e1e66dfcb618e81eead2215362f174917b6002fba726b4237a0555382796df62c9fc6945a61a5ff9518717315b5bb536fcf9bb1301799b17c517022975e0bcd4da20c128adfd2801d3e2e591f03cc12d129c9a3a96f2afc11836bb705369ff1444311438fab49aed80b79813d6662211838ed067331f005092415096f46315303da147f02426e46bf4628b53252c8ae14d3c685b39d06a597b9b74336d55af1293a82d5610e8983af16fa113f91aa383aa132d3a4eb2d655473a29f34897a6d026a1e1311fff7ca529c2f2dcd046bbd0c4ea2c6a68cbdb38bfd62b8f16f88129b1cc081ad000f7a995da8f9fb6f7e77e3b103cd8d94811605f1ee83baa4ef310fae56b7d74a52d56773625b61edfc58d06a7e20f5f4ef03e00a8c4480f44998709ff0cdd219be38c2913f5f96bcb718aa6e30456e52d266e70a515240030780d332099c6a3c1de30d2e76a37713f4ea86f67f151caa19c9fd68005a8795eded0fc9258800b9a9a511d01cc5e362288998a562f1e2156dfc78124bc9cf49038fbefe08da888d05e6e4f9b65cec07650f8d9d78295c549076564cac82ae157b6748296cdf87af50796cb06d826764df7078f3540131466f732f4e28339bf7a35f3d6d509f58ddc02c115c2a72fcdfa372e32b988138025feebcbdbb14176460ea16b50d995cb4f65df10394d664f3f0b6f4f87233caeccd7fdb278997b796b57d47fe5786d2a19eb727ad721e2ccab5770e0033d73a91ab43877f74b45991826d42f4005a13c04501c31493c88a35fd06c225e5b564a53c68ea351f69e1f89d3eecae1a76963cd699c6d8372c2bcb0c2df8a310d1ad1c61590c8e10a106be4516e6a963abf8187a27388de4080039ec367706fac7f7a6ddd099d7ce2c73c9eee3472ea0d383e90518c6a296f6f415e35ea81097be6722de734c237ab4c6b738e923af82fd242194810ea38240c7bf39c926decbcad2f797843c0d001191e22572b3a06a0148e62b6d0f3a0bc12ad6a2de43d711ca8db8e2e78a9e30ca891991eea6068ca4856ff7d4bae5c00134f834e9d155e3debf5d92ecf2ba946f3d495694dee69341515f675944826999de5147c93f5636268cbddd5ff340382b913d509f182ee44810b59840db62a1cb3d4cda89422bc2fbf8286d92588da53acfcd3f6942d6b9ac9142a397023869c5757315e84b6df0df70e379b42bd062e2ba2b9614804a396b170f55a9b8ecb4f69f4f68a08e045bc7e25e77d458c0c85c555cab4ddc5ccc51ac7f77fd21c49379adc6fd1ba2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
