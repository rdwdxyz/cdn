<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"322d2b8cf226bad16f2533c19ef1b2cde99f3bc37827d364e8a934f54b07a8db90f2241af48625d14493b68ea6c86e4538fb613c30fb72767290df823e0fb94038136431e309a75be9a36f13a81fb7c8248a160ba646561bb08674ed51e13b99c4cf22400b25d33862bb17c0e29e02829c45c37de8e2e18112d8fd21933af1dc23ee5ef2ecd3fff8a55d0cfa63dbb6cf4d8afb5c915f5bb7515727b0ff3baab00b968634bef880822aeea98b8b7701644d8ceeba12756863ffc99e5c347f9ab1fddcedb4ca8d494a78868b798fd0ce4d8a8b98a778cdb1cf7fec7a9217b05661c79f2c8be2db0836c5d992376909d040c1cab6204eacdb951efcd3424d2c4bdbcb23e8e7d3efcad7219331d91d3619b6c7ba955c428d4ae7e5e45420d0bae7bb478ecea941d83a85836461317b501270283a06f7e00c11338833f624c94dcd953e2a6896e4a5e04355cac2bb7682b820ec4027b684c4f5417c565f8f3df0973da0459dc53f2a6c1b86b463142b7acfd42dc01463488cba8848c78fd8f4a7dc4ad1be8a1c9215b2283a5a470cccddf8852caefcbd48eaede74f0b11fd81efbe269d0a3aff04e1316a0eb13fe760380e6a9e8498a1d1cd6b3b00bef75f0246e6a3755b46470e0e99f541f4bb213d581adac15e3b2f289d3dbf20e1a0aeda916c4882022930e22b54fcd8d2dc1ab1d068c4c0f19da9fb31e78182d1d0ee2377b69dd0ffe75b71dce31f813f81607086a2adc58e575f406b7e2c2a245f376af8f8129c175a398ded9116452b4d1335ab807e3567d31b8bef3915c04fb6b33a60e5bfe110b5256f6a0510bc9b207216ff13f94424af8fbde92af46bae5f0a3c62cf761ae63faecc691b372a071fd66b79bd7e67c963b66b617dedfb541bad229cf6ef60b0d2dafaad3ced734f4389d5ac77cecdcdc39fe793ba52b9d6944e78777faf9a6956b5247e412ce5f85b230990c6fddc659a55e03529bd826917298195413931c3a96e5c21e798a2f7b8482576d82e7a265292dfaafc10a02da829fe9af26f9f784f2e67316c1f6898475b9d97c73c768db83f4b21d313ca111411fb9544a5595e26bae6df2bf3060f5438e935b4b11ddb4074042fe716a0bf99104ca1294d5009550bf1726d7883be52b7c8a963977905ed4413b83ff8e7af7222a23817454a75937d4b15f1ab18648fec0c396148bbc56d84d71d4f5b98b1eac575f7cea9bb3eadfe442eaa3e4d4b9a5155a1324ae090aa5fd6ea73ca769bdfe064ca79b4ce835d4199354bfb39cb7f80996bbb224ace6e84279403dd74b7b9e4fec400aa7eaf4db2de3e16e2a8ef467f1868122757092f6af47e605097fd54d2625969b5ec9edfced8bb3148fff3d037382ab7a7afb16daaff8c99af3812cc9a1e9f59771e6e97dffbfd99a21652dd7aa6d11740c014024516187a92f4faee1de501d7f6f2adca727588be493369a35d4aa47ff6e5caf1de957946501615a9d74546a76a756221bc3a3ba48407f80e9666ffdf1edda8c8e63e22c8b56f8a2b5a7b8e5edb8f1ffb3d6ade8e87410c7c46ff29463424eb505cb6a0f513f0a7627333ec824631b923cd7327670466ce0cdab51d7f53e83265509a110b75217293a5d7a2330a310de35a7e0299e39c3787c5451e31425e6a7105967d21080fb4ad78d0ac4e5bd5fc4d981db6ab3492f626b6df25f15c99823b92f4360871a5121ac820c519a92145cf2b3e46cf8d2abc06ba384d84c7e245a13a0102bed6bb1fa7785aa5a92758d171ef0e9d680af40a1c09c99075159e41830cc42e30556b255ebcb6e87d96a9acbebaa07807ed576cc8ee01056929da0ca1dda7555598533f4f09030b24049f94a5406b85b353cebb8f09fdbd0bd56e266fc24e0a5b756c0cb37443bef2481d6545ab27f04ab99736319a885d35333774e9053345e76cbeb80a0f56a09ba959ed8686d2aa1e8d26bc3370d1354e2e313cac35e088abce61c57471770bec5cf989243e5bf08f6eef9138358838f80a13ebf586370f633b66b3668ce66b447a92277f17aa37ac8eb2accbc8861d05cb488fc4de39bcef3aaf88e2dd1ed98c5e83054b654c5d827fc90178ceb4d3af0a8763af3ae5194493d4c699b5f1da90cac0827c3bf1a1b2e69365c73b6ee3ff64f3f6f9c87e5cb406bad76b0ca0d69f5bdd035445b19ac2db5be23db3e2ee165b80fca6d95318cedfc9d2ebbaae9a8773b29eff914f0e219bb212a94d4c2d03c2c96763593fc64eb2728f2d3708e2efb2d8642b140968b3f546187029c563fc200b8032a27cb73b73a95ad9655b3f603a667f00336570a8d479497de75ff98fe6288ad525fe98c43219b27cc058dc5d51ff5fba5b53a49d8992dd704fd4ff19e1f11e002d8b43c5e73bd4c2cb42d229db914ffc2caa6af7aa52b1b8c3c4461c8186c72ee9f876f234201408441cce9a84ff4e3b8279c87a78876a4d00a5c8df869ccdb20e5f1767b064c9593a7e95ac15f9bdd676e135ff49dbc3929a0c22d6af31daeb95f7e04a7808c0614b7c8f1ecc227416274b9576b091663bb19c56572c2d9f3822579c12ad8c3f1e5148d35c258170927b4cf5e71c5b3734678b7e556342814fa480bf63af9057e65be43b3d7f4cb1193a28464e78a7eca42b634ee1ac6d795a18fa41111e70137dd293f00b1e4659fa07d9e1c71e7ebc55c6dec762682cfa4ed2a6bfa1a9c7555702918f8d593239e197eab8448e77fb0e0cf396f6bfa4552011ac3a69f762e7d376d56155183a9490c2074ecd920a9c5cb0b4a3b2100589ca6a24645f18bd70314cc9f00a288b83daf08ee6fd846694604db6da3fd4bcb365fb78ec43ce29ef87e1171b83adf3cfb9d6d130803d88e35da1bad5657de1bdd0628474f5b67ea2d4edb46ba412551af544b0f75661f15b63ad471f4c2018c4bac0a699313f516ae73ef42cbad59854b6779b4e651c620952777fa78c25092a9df408ec4e3ec8f910a3bafe89846a893be7ff94517e9f68dae6c2d0df8875916fad69cea782eab545da67fa89b5e29a917b44457d8a6716658a4f4edc63c555084e5be124e7295d30e9d6963033cfa819db0ae39838bc9b1c0cb6ba3d5132fdf67b02bcfdd4b8942b36d69e95af37c8a1b2adbeb42bc796a2f8e04c4090e85ec2276a9b0011590aabd6ba6fb0071c82198d30c552fd83dfcacd01b77c2809d57289bed5b3cba5e70f7f7925f962fae357b47e5cfd3349dc05937cc1908df3c216a48eaa56cbb15ec70e8b7c84569a583d9066653c3972b66bea9bd7858785fcbe9c268f4df43a48ddc3f3cbdfb65f563d2cba4a72135d2de457cfd429550b8565a46ad61e3b90774b1fe35a594320db6664ea0d46799ff6d2f6e19c238f26664a3208ccf22b4ddd0291208efc841c44f509e65e1d8bccf43b0368eb484a3fc431ce7da044ffd44166ca06a5756b854eac48f4199dd86db95777c420770f86abe4f7253be178ac13172403e71b91b0873179a03e2ebee941f6ca3be9e7f11f9463f90d74017e5eaba37ff20c4645b1aea658eccf889caa3d300978166f8a7c30e08c0cef2e1f6389f6153c340259cfa21552e3c3cf01eb2b5f4809cc5bc490232d30594dc8a4599fdd648e02bf847deed58099e16a74530035d0d96271b543b52bb481b40759cf33862191f6a91b2e2724b930369c3da13936a971003a400c994dd54d775948c64e4df26a8e3d3b5d25f1c04bbf2c65d81b0c472ff925cec417d298c8aabd8137f9c76047f42a8f12129e9c0e248b9e3c2913c6549f3ca1aeb84d4f14aeeeed47fe01e99ba09eb94bfaf865f5c0574d8a03f66a5100303a02b4f2c800bf32fb01d9cbb9198418ed6690a2c7287d2801ce5289976d5fe30afdc0d417b52136f26a41c767f46dc2512faf2d4734759ca2ee184fdcc3b7b3f2b8b01435419ad3d9df1ab678ec0441c951050c88762da1d8b64e512689549aff59d76a7d3eff7f5a323173ec73b5309c1c16ff27e5af000fe522068f238df87e481650550b44ed3c03b76af31a5353085f049873b78cd5d0d0f59a96bdbfca0a148dbb432df76777528b83e515e62cb6d276d9ad686726e6306a7936c5c5ea2bd6ffcd2e7b7e08e3779e7aca35d76bad4eafd90ff3f40f36093206b10f6484ce2087b9cc3625caf79897981b3e9514b6e3d2438b034f32ed229a2e56420f6a666093fabb15e17dec8bfe8f52270c853000f01a8599a0610fbcdca6f2a8ce33bb01068c927916c121dd4a5f08f828aba98a2f502d0690608148b4b23e81e87a9e83c185b20b653be3bc6ee212f104a0f4bdd72451715f0ba812bd111e20fb82499efbbeaaae03420c032de917c3039f38fa0c3a2b816531f6ba7dfcbf2d8f2e8888d75574463fda14afee60b6fe8dbe914364e9fdd0bc4559b9a119414077da003c790b5b0cc719b678702a2bd17c99dfd843d083869340d64bce0c828bcd67a12c590b53f2f231a0178674c5851c2a6d6e9309db9e9ef8de74c379116d3792a0fd2c381e2960de3c8a52fdf1a729477a0ebb6cbd9cb3c6c8a3c3b51f8103d949fb41af83436c1992c884a9eaf71240d9bc6ac0e0dbd7c8c029e41402fc1c538e64efab211dc20bc3627d556a11ddcae3e739729ac7a5fca9dcd11c043224a76741d46c33ba6ad7963506cdfd1b1f7d87cd10bd692f7f11831cb5d475c6e4e78a245df1f374ae87957bb059c4961be84b9081272b430fa466319a832643830b74223191b772f5f9297f0b320505918ee313633c2019f8effe72ac9435d0a06eaad355ab5a07472b483d4e7d05ea17bc4f39ea3a531017d65769d80765a50e0b43cf648b704b0e96ff7cb7e4210c4f7b0d5607f70644c8f4c457fb6616177c59d59fb133b1199dc23916a180b4c407ae686deeb1bab9bd2581f1f761e51c5acdc77a1b6576545b699f6111a849c16c235f4ca5612eaee378a0a51b0c05e6135a8f7fa68d508e450b50b42987635647c236956e83ffffd7d54990bd47afa07a043a8c94eccf80443e8cf1b494b91da992aae5c4c4c3d4f01e8102ccef507a19f57c6015930f61c1a4695ab2e3b965a7c00e56fe091113968c9ecbbd089f35e0efe75174483b032dead724f0611ed2e7b9b75f20fb7ad5b90d8dafe348d8ee83a3d749bdb59481f5f5ba490bd9392fe9ef56a8be98a01c340d4d492fc125e3cb7f0bcd8b458689873dae9c8bc29e14e9092599dd0e985f4bb19607c9cae627482fa87183acc21d9bf21abc24981b06a413a8eda1caf796d8e1509902a7a170a3d1390186a851d3587d6e9f105b3cbeea0b018da3ae65e26ced709e8a977f5f2b8b5cbdc5fe2833559db2eec13054172bd21193864fdfe44c8a9d4763f9e1a22fc1acb0ffee83d232fa208cd3c9e4035bdc2a3c785f9f318dc778ac881a8bee358a6f0a691824141ded4e46d06690f751463482c85bc3784bfb910095ad3f50a8a4098102d9a70a697a9d6bfa3449fc3648292f3b853410125cf7ae350a0ab86d9c9e3b2990531abe38d02a0c8d120e3720170ff31b10b4f3524b7e731d8009cb4069a0248603893aade597c4f498384d8076328f90bd5aa4dd0c302ca2283d2cc0b4034566d5db16d3b0d2cc5bd3b2447655872e16b649ef53969166b8e5b4f4d89b5610762e21384ef6a63fe68a37b81cfea00be1146b716abfdcee2c190a65c742806b7a3ee18b580c5fa0b5e14d6af36422959cf4fa6762e18446f536ccb732d7f98bca9f97148ee3ba8fd04a10bb120c86f0d3b517ce8b622197e3ee884e0dab7ee9a1751f8a6e05f82fa56dffb9964cf45da074930a0f60e1c3c8e4a5f1bb6f7f4b7d93a2f48c7d928a5aea9a1b3d975d99c14e85bc91785cc25a7f6107f7604923b18b38da236632a12b0b7118566b1b6df3bb8c05848a370f8d168d030cbce07433e02863acf3f56e38e8cbd3c29134231e7aea8664af0c66a3bed9809cef82669a77afbba2189fd79cbea26b5f5e8836e55dee307ea307bbcda8720aef5e8a85ce9dc81676e0a36105aed35bc6626a938c8db02cd7423e6a0fc337d00da33cc4f895498dbf65038018930f25c91b2acdcb42ccabca56437df99145ea3b12bfb1d0b3a2c3857148284fe2cea8814482f345e4c65d83cc5f3435683a50689900ef0ecd94cdc00b08418987052ac5c5ad049760d493b5054453faa8bd8fe7bdbfb15be23ea7841273ed66100c831ff1e812a717374c42b39e5ea98e09827c8384964a02ff4680c3e41be6f46df588703a6ffef38992d40929dec95772371fb3c6aa97a7233f550f85f944fe9e5945019abc34bff093873b4a34cab17b34a71660f8cafe05794dff458b6d421f61e4662ccdbe09c85427f982c75acf005b7a2a7a4b98b5416e1481ffaeb941bb46bb49934a2d371b6c99ceb11149b52393a38e61e08899e6117436f52239ec9cbf565f9d2416a5b8b8ff36006f27945fdf5319069f55cea7685d2f580fb464f37028ef1daccf7616bbf6edc249df090ee4dc59c3eaf990be7777a54811f54657c797e287a03175ce652c5a0b639d668dd4b0551fdaa820b82b92663ba2dff8649436d8cbf94f477f41b504093e53e38cfe07dda9b3bf0eb697daf9a34690b8dd16f7371253546074eaaf1dc9ea6b13b2fbb87c6aa7df422671bb26837515c8dc700e8a823484ecc93341909c6a080f2a4305846eb5c8416bd1fa696226fbc01b480a7e7e46ea9f02fa25ef3c1dc50a457be039be288424946b6f04c589404ccc80d69586e12b129f271abe4ae366ab21b772d22505d2c56aad1626e7788cc5caa37c3597fe8468d743e2e14d48cf5310fb0e58ed29ced24f237277caba9fc7c7994b3fefe90f10f09f6caf19f268f2c99ce9cb2a8bc3d6db5c583bde5a94c2917fc7bf11dd8f166506cb09e01bf67bec95cbbb5ff26c444433a7ebd86e69712ec2467393a9c0249e5388a6b5a4cefc48aff0c0106cba491c7dd095f9211423a526139c605fadd65c3586ac5be99e2e31d24fb37701a27d797a3d11e6fcba09cffc8337fc290812d7011098c99abbbabf1b83047765128300ba9e4ffc914679a8410d4860bd95ee4cfca85403fca2f7d3abc6e2bc3ca602db8a08897c71592a5df9f18c2562dd2416c4e9227b49625658e1ea23df910a22e5a05c73dc949f080dfc16661e5feb1cfa515e2a3f54ba1ec9ef4316263d215e197e1468b0a2cc0cb8da2a4f62d5660901c4e42c06615315a3b73f3121ef047ee159b62aa7d8a0f52375cbaae7a3f5f1301f6d8ac812187e6434be7a7e51f71e374031fdb50348c2c89342c3ef56498f3c5cb813f89ed0e4ceaf23461fcd3523f3991214ea1f43e3d0291c3d30a9cc36057dd46ba34ff39efaa5ddc4c505c0c1a31b74f6a52c6fda5260638208b6e169c99f08d70c6ac7874b858b87794226c9f37b88251b49ea1309c875dc86851dcafc4d4692b18a4bb3c305deb89975e0544a7000d3c592d634dd0b525b95d4c22510439c3449c8a3acb50e3b43dfa8debe6184e53b9d5c6cdb895df91a401395b171cd9af63fffcbbbdb61378322ef3e28090ea3909adc569df7510ec503f9e53af43eba90d43f17ea8adfecfb80c600cd53466a9e5b76d87714e8f8f4b5b8451eda7a8343116717c0f1daff1de0d814e98c10596d5a149fc10e734b2dfb1eeeb6cefac33a3c68f272b96db66c53bfe0cf64bd4a0d7f765c696df29f3ded661419e281258a2ab2fab53bcb300b8418a31f7a6435fb716345f46bd49748ad901f0f9078ae7dc46603ee90e9f0eff4016410494fb83adefbc4aec815b268dc55dfcbba3d8dab5034b6dae9bb9ee147bb27136ca2d496364b01561b52151a0e5cd710c322f260bbbc69508ee6661cfbc6627c2cbb01534a3355b805c4add807f0d427d856d98a86ce33d21b34644c36a2a740d359417f7859cb6f8cb354e424b050847939a242181b88595020c32b7c8cff46978374305e34cb2e7abd42719882f3bbb0788dee494c0bb931704824878f600ab3fdd972738b9f343e31f235be05d79b3f078c1981106f4a4021e961bfffd58dab603a81483ddcea00e228f35ada0ad14aa9474ac38eb0dfacfd3f5d541ce2ad49dc51e2e016b0875e022fbea5acea5e423b83603d6b2a35a3f88b290477b8e1e2ed86c1f1c1c22cfcbbba9833a4c996ca2b73d2a73a5ca9ef7ad621e82672d004609d3b1fc5de5bddc02c4448692adc92784e99ffe150bbe3818fe18a55be559dce57a7be39cff5c3512122cf748eb96ae75e0e12bb8440b56d58c339061187ebfc9c7b0bd390fe6ee04ad23f3468727ae6593f54939bb763733217fa511290e9c8979da1d01603f48488332aeeadc6f00f4d90f7423aacc6eaf2eb20c39ac089ce815d768669c7ec6ff1d7142769cc2138d9ad493c26c413b43bca98052742f0aa1fde4b3ab4d10066b71e661a2703a3182123c91a3566e2454c38b347c939d348a653cedc61640ee60c3743cec933b8a06f61d5fa2fdfd7609738aacccfc970b4d2d75f334f27fdbba05c95742d47c2f94534635d4af47ed46ab3082d4ce5a3be697651340ea8d0b6bbf47c530094cd403879d17f5eb34d2a40868cf22706e37f1cf6634a2696b399b13b590e333346c35126fb401a8904d98d928c3e75dc03fb08f0b6d4b13caa33b9ffc702ef017c2a573b97aafdd7ce9f523b9dabfb68049f62bdf7f7c062a8d4bc0fb6b2f6fa2064418c9b472601a2038c2f99bde3b8efdddf5d015d1e860ee4ff8d05ee9646015a5c16e9519bb095a7254440e2f46990e67a91df763e58ebad88a7c5a0c24b2d43ed3ecdb9aff5eae493dd5898d717593bb18eb5c92a4f9e89522563b142b991a338dd50b80d2bc1e9249663ea2dfe4f605176c9e506d38f2339aac1786f8beb2ea89a0e879afc66f227a81bf42969e56910371dbaf5acbf8a6011c0bc062bf4c0e8fd0a41683e607aa410696211c4ee34547816551a547cde8d1dc769ad95a131adc0798fbfb685889ebedb1c05ab66745048de06c192a79924d7d8c3fdd8e06d855d32e3585668f4c33373a39c180916acdd6a439c4ac09f9cfe6760be4a1d524f14c3f59941fdce71b7b902167cc8be5c84d7961abb242c45a2674cca56da877f5e168d9c3bbb8de8fb9f5ad67bf70f1052e98959a31118cbb74a17a9264e292ab66f78d34cdb520f068a6360de148e3497ab756aebd01ad1c91fd109dabe32d2fd1c66aa817dd8efa2b8b3d1f29b764edf0a2b42e33e0e94fada1193895f137234b6267035b7ae7e8cd6ea15d53600378126e2b7534cfb6bb73ea43b3047cc9f5bdb6823af95412cfe940b207aa3e8cc27e505155945fcfafe6f5239745f0285b41a149d3b3d85316a30a5467faadd624990980c12504c3398deb2fade8bed8218eb9eb4e47bf899d000eeb77bc19d91a31a3f84aac601f15927152a67cbfa2ac1dfee28a9b45936f4e808810a7e4eb01cc973b039e12f8a2e286c92e1828c9c6bd2d6b234bc520d5c482f77bab8e7de26f2f921482c95605dee7f2e1dd97b17f8fff97d5c94e979df6e7a9f880b3b9134a41dda191c5d8dab4d5693f2bcf27a262d0f790e69e8642ff8a359618f10bce1efb13ffc37d6c33b9194f79092b3a973241d29fa02beedabdd99b0848fbedf39641f6a6de3a320877cc2d98a784661711d7a5aadf32f6e10c57e782da9b678824f989152b01449b9ade75750e172f02d0803c3cc51e676f81a392613fabb2adb80861af4b83c29d9b7c23828aee6a1dc7a5ddce67dc89b68ffb5d74061541c238e9a6085198f1271538a61fedb289ee180e6ad240f6f4197a63df595b9df9b278c08ca88899bc045ca4b1720579d1a29d614eeaae712954f1982e0b70c65b4ab55fbaa63e28177ce498da436ed915e8d26efc9a451933d6276c8185c0712ff1dfd9fe80e429f4317eddb5ccae37068f3b23249c92d5b7e4f0642b83c237047963d5dc8d4df736eaa8ccc5b2dcf66acb66a190de272521b25914b2f2dddafd8204f8afce0c515669533ab225660e3f2f94471f0627a11d3d2a2de3c1ae7c4a33bbb0881a7c24cea4e3cdec1b67d10d82e8e0e91f78fc980e73216e7d307a33c62889155796b0cf08073202e56e243b3626c406679797a06686c822e9fbbb4b0a3a956478279859a38b1cefac75d417f564a7fe06f9fd26758b79cbe29a7dbeb70c6eeb6ad1d078265228251e30d2d06dee99a8ee958307add54d7a36e357766201421cfb516fc7678b3a72b65a099ed0ef8ec1479b9825dda5d4d7f0fadc548528c1f80911d092a9915f85a4bbd62a5e389e698f3995c0253cee6fab699d612057c9a0c632270e6185153baca5e1dce9a7a3edb47c41052fb2dab48a5f4ebf5d6acbf1fe76d7a0a41b561ff328046112cd2f6f3d8707b10e7d113b29af82f3a5ebc68f128fa2071a0c776b31b2071d42007c9f486b1cc662726bf50bb84b31a435e09853a1fe642ab10391d856c40a532ddcdf111831de5f96d403f9863f79a2bed3b87d6bf48faa273377408fea68d67a60df35dd9f049eb1e30764c4e8659519b272ffcb408b227c31a1a5e904897306796a18302f77912044747c377f40b270ce77925fb74ef7bdd3aed0bc788df5d2fd5aa8af78cc23d923a4ca603b94548b01799a800437fdcc46d9e3e8df4dc074b2fc20779f14a296e5f9e53964c836160504dd3f7b2a5dc40c17f00839f92f72b985adfee084b2580a965f478dc996df67e07061955a1690bd38f39d4ea9f3a73afc8f415ffecda4e4ea4d9d4e2b9a20159261a2c489396e467958b08e2c5569a94c2b3f2b4cecd5e2bb27aaeefc2b20045bef55e12929e031be1df97494a3088b688f09564b0e4faba4ab547fbea4a062df7855c1a49ffbd92275fe2de9787cc4afea6a6f9c1e15788ae9073744b68a41c1e8e029156105c3945fbe04561fa6f7e3821b0380dac35bb16302cd2a6f6d28ef0fdc2bf7e2ed6604e1d2e6564e54a0267da42fe97130f2b8bf681a3a9ebba3aae28396523d6c3d30eb120d9b662d61c188afad3419867edc49c426f4886a359e1d224d1c12c1d96e970dc4d6e8017f3f9a3fd41c80b84f92dec63b9e93184ae95c0fe9d0777928dd92c8587540e0b1f1a98bd69b6084b8992ea0cf17022581447da1febfce1534be96e26a8d9db019c2d27054fe6cbb307c9b2545d9e1e4b5edfde3a92e8f706fa9c556ef10f22476b8e2fd2a842163cf84a6c2a3b5e0f5cfc987c52b5e94af5338235f46de5ed23de32df03192caa563e0508a48e648ea3e984f27a46d57248e332f837ee702ea2bb18d66ded98729c980fda53e8fa92f3070a67575a52bd36faae32ce40024f5e4c06fd731c02f345b9eb2d294113abf98e17ed145d5151eba5591ba1d42aa05038761b3181b4011484312422307b348ab8139af6bd3db4feaca9c5a69b857a50bdac9a88686ed3597ff8f73398935166923dfabfeb7a402efdcf60a1494fd91416dc6188abbfe36db56a22318d7a83b41e59113711d1971a728ed77ecf4802217d29efd6a698bff75f981326a4ae1ca5d80390d747b3c694aed4b9d8008d66f76d38030f8a218c2a18d3b5e9d62705d2ec0c659421d791ee26c90e1384f60b8be31cd408530d4126fdfaa05a7f7fba1aadb2fe7e820e7ce95b9891d3c6286045b1b7e432ce55ee483a849c6aecbdd13d9909293482944ec66a2e8bb02a97402fc79767c56f73567562ba7aa47620acb8b9b643ae491bedd51f2cfb94709feca63ab1308e0a9f4f3806cf3aa59662b8a74d356ea2e0481bfef3bfa530e0b07c3bd1f565673311ec54c9d36f03a48d12b440d242a834af062a0b3b91d3d080fb3a6197d65e6f549b9c641de2e6923749b89850bd8b19c0e443f365a095e69c0b97257e81ccee1a56756da382531de1d924e786f728c7d36915f7ade04b43c107313d36f92517856e8059ac2c1cc17e5cf550e837abcf582a818617b0a1747092a53d719b8695b8e28b207ad5d1e82450e9763446ce60dbe9baf7ae46cc6bc20a6fc02bd78190ef8d23c4f63f02a06934f1ac7e641c08ffe08b0c499b60fa7cb0d36cf7b11fccc86691f8de01e1e812f1c9ad553998a7bc204f46ca612ec2f211e3627c99379a761f169eaf847685c2612dc5eecaf57a760af82ce4fb29b7be5a73d2b1b53aa898c859696ea927efc554c7d82d750063663ed80f89e01dab138c0125ec86deeee3d304429d00202156ef32170b601171ce613ff859a78d4a1753b261f93984dfa4e31773b9630ece9d2bc421d72a28246acfa6be5481a0e72430f6bcb9d84bf86ab3a4ca7c4b10929bb26ce3895990527d20c6211e09c1e857c292bc3e9be421d5c6c46a46d571c3fa315b08a74245c56eee949b6a2b11222ba99ffa19af802358fc6765edd089a3397d71e81c606c02f8ad362757fdde4fe741dd1592648f30d21de3329e5332ed7c328ce4d5d487ac31e88ffeda390f3b1ea95936e40252d82255ed20867d78104d6c4fc73731276aacbb41b17df4c991bbfbbb860e1734a27c20582488d059f83ffbd57bbed4cc5c78a39a75b21aefccd7339cbf01f3d5abe272c2fde14e1459534e97e60d36acce39144a8c5b22a1de6a3e7eee6c2dba7e36eeb0672226554de3a81700a69fb84ce857184de53db238432fbadd6f4688514cd7c275e5678465aad56d5609684f7be8fd85e9de170ec3fa85eaae628e850902546a68e2678e6652a75918919c8c197ec335b8e1a0b60ac735825b00f6d366881fef4bc02ff2092d9cd5a62f522bbf90853bbe3f894dd36660576319f8a05f1976618b8c963a757124662e294f66dcd6e1ce9e4701f8b15143ca0952194da02f3dceb1638ef20916c5b38dd92a206ca41f5b19abecb5a6b4c175a716f0b3ed399e5a708bbe535e34f58865b6d78ac97eabbbd66035da76322afaff7507bee60931fbd5ffd2e9c97c146d8eac4c87aee0c2f6977bcb2b4993420f7baca36d742ebdc3a311953a890bc4bde95f1ddff9d7775c65ba3bb9f7309846a31f9105a84aad7f5b0f0b34e6de85376cf723d75cb07cfde4fe5a46ab95f59c95103625883a5554eaecad96d70a05a952100d47e60d6b257174e3098884a0e6911ae10ad23d965dca77c6ec21cae0755a01ba3e3a72163e139379103f9aa3085d0c8a24d18965d34c54e4d00b5661030b3b78255d8b078afdd695a0d4212f3a518bcc6059a5421ffe1fd3d560a41bc67331e0b23ecc7c7cae3a1aa69d534f708544d5e1c4a1b102a46e1e2a6754bc648c72716ad315e336aad288ecf304f15fe329edea3aadbc6be4a6072ed92f6b8a2535029f0eb12295eeef687f2ccfa09441aaabe247ab0bf2674cd12a1e9a0c31565ba3df9694a30b6db863888a4f9f1e7f689f4b42fd9fa07b81f5b5e7d51b8234776009177e76e80ff37dc999a63ec4dd19d7e39d0d99163198da76a3c0256293b30be4ada105fe8176155b1053d15c1735592c08d4bce634dfa8368a8f1d9303946018f8f37adae115a5853d271c0a92ebf83ff26366c91ab922c14a9cd2dfff896297da488b3ac471921ec22b551cb59a6ed7706e18d088779afc3b975d31962633722c5f1f7503e1077ef2733a01c52f43212f8eb49e1ad43d6cba1fd5b5907a5f92ac78192f2a2a9a3fbb2bbf0c35c6957971aff9c3eb40f4d10bd3014009b9cf827d8c6dd8d8d2c6027c507d6d214ad848390c094d16cc3fe3ff384babd0db99acc0a5e98f12ccdd546b78e5c950233a092fa46cea397b3bf752b6d5415f4b91b6b6399ce32e79600afcd23d06ab16065ccbd26f0b4bad1fb99a2859c707fa3dcbcb3ddb5800cdec9c0de6f645a97aaa2e3b368546b7e96e359d6b411214ba052cf3d5488bb5e6bbef8b678aeb3ffe270756e54597419a784bb4633e7db4f2b49292f0092d1d01f1a7280dbffbb12df66fcc7f437f1cb8001570cf27efa7d9352071c5941d375ba6395e695c8c76361ed021e0e138ae47698dabec7b95fb202070e453245a246de3ac32ba51d6a8c074fb5c747bb53787944ffb325a87f60759678eafb96c736293f6d0a3fbbcf4336f2cdac0a95ee667260325843d4106e72304b29e7536990619fa00505c9455aafe330688f9f14a5b297b05d889a10bed4235a27b677e52d4f4de1ca33619492d555aa5a09eb6c5b01887e1bce9d268bd0f7ddc1c2f3983c67c8cadbb9b0203e064443696bda3000941ae8aa0ed3908c43351d41e05991c0908bd8c3838b9de2616de437694baafb15c021b3395bb2553bd4fa6a5107f45a98c4119a375dcf37e837792d511ffd1d545480ce71a575554d5e59e1a159025b47a83b3d746262e188d42a8dcb4d1a92e48d8fad8eb7e6782cf476785fe96326ec55fa99d1545158b9e2b7dc7fdd0e6356e66c15a1b650762bd0b9ee71517a5c89a0a9870cf0f2a42296eace784fe335bff2afe57ed4e9e5416f2ff87dd198b9c98490c5d02236bdb470c765559baa2a4a6c4ffa4d0ed8b798a72743cf9446a5c252d356a7c84870f5eb2e13421687479153e4347aef90cb40dd4bb070b10ce439e5a4a8fe6f7893485e07b9a50c3b0fa321f361b73273f4513cfc51052c7db8342330e91249bec911fc1a2873a24dfe2d7b3c9c24610eb33d1f14020d670d0cc5a12245534ac77a2ce19509ea5db6f56fe8b860ab6a926ce10e64a295c81f1ee4f4b01ceba1957fa98c78ec66117928c5164fda2652fb3ec5494c507bacd79a50b213cdbd6015d8f62b49788355e660d51c1853e580c5aeb7edb263ad6a7e0e5c63ef794f0ebab5b8cfe4c610580fee3322fde3143dfbdeaf68c407deb2174222e0fcc9b311038b4aea393a5831ee4bad62b7c21e779c46a6d8b8dd7af8b2cdf6e640683f82767af851e5abb828442036bf3bc50682b0432c68c21776fa18f6f38a0d2f1018d19f68243cf6d8f63da34a20d2a820b3945dfef158d936da675dea950bc23f73742632f143caad7bffe077a335aa05e77e20b627e5c86f01dd71f67a90b1365f953fecae116b82ca28655fb833cf5ba8d62592f826ca591f11e08d3306252c60fef60bc2b9300c45037672e2bc692662fdd84d9d64d3773f83bcb11c9e292e319660edab85f63137108fd3f6281cb2dc8be442a89cdd8ddcd6c0e39e391c12cd68a939a0d543213dd187a1bdf86ced81c09ac4fbd74effec3a4e830c4a8f3d258898ec7c632ae0efc0b46af3bee6ad1ca11353357dbab8ea55aa6304c5b4c245a57c60c46db3d6b270e3083c3649e19e7ad7dc4f7406e27a3747b2cbfc94dde1fb962b8503e3cf2214f93036985ceda06aec63b5e638e624a417ec07ec34de7854f2e819df666ab32d8da0f451e9c8dc7d86b4e967ad404766036fd3ae04da41caabbde098dd47a0b2dee9364eeb0eddadfff4f88a9a5c9995d75d13bfbd81ff3da237c4af8705544ad023ad3881a2efe68301e1ad75f6fad0ab1768694795c8967924735a76697e52cf24ff25c6005fcb82609e93a59a18dc598a1fea5478d47852b515315cf31d6bd2a89d77700e012ca36cb19a1d139cd6311a7bbf0a6343dc13aa98087a0ae231c377f179ffbb3dae99f2cbbce497359a6717c9820cca6a62ede0a74d5db784062e5e8d3220db0ecdf4543d4cb61c68e369e4eb62bfe77fd035fdf8d98408fed58cd12e47f3eed229d62cf3fdb94c24e879ce9f01946e69f8bb1d381085bd64b6e865fbbaddc950c5a411683764cc14100b253e875475a81de0f0d8e8d8eb91a4817759294bdfea498f5c6728ba7c82120b0f92dfb15f9bbc3023f196bc0714b00993840b5c78ef418a5cc5f370c0ec43df221099d7ee47e8cc923f069f6d5335b5a4566b18f326ab4fd07651bdbd27f71481516505e0f0487040745dff203d64b55952a0ea653b0d19d7efd26c95b4f3807616ad30ba16bcd0124e686f508c0063fac00684c07c35d2bc6af411d60eec4707cac4988653a5a0f7c65c20421cb5cbe85cfc3809ce8bfcdce9ad884d92154b91e507e27dd43348cee217347136083f156b05c30d5b8368d7c0923169867d78b95ec555c1b7e831b9f7d2b9745a2917e6310b566a65a43dcfc61b3ebcb141e2871371521bfb5ae4bac5964c120c83c190e96cd48074d1cf874574ab1355b1b78742e401ea4ed6768836c4e2f75a4e139a4d6e7c67cf800cb5635f4130f2ba4cc3c5d498741cb393a6d2f332947fb7f9f5b8761a286dde9429da0550e33930a3d60b6bbb2afa4f87f376dfb3559ac3fe1a6114457e6288e64427875c5368a60afd5ef3ff5167402d10f6eee3d34fba9b9cc3c0f2fa881892384f24f92d9ccc797b460d8b22d661ed562e2171eda24126e2c9d332ec5c978d6818f117cbbdaa59fd5603dc2ee67b9b1355e47dbfcb848e30034f2c298d2c01a1f66cad10153aea2d0bf3eb90867d59741f66c02d9d06b1097e0d2f490bab680bbb3398680b449e6a27198032360c5c6b1bde5eaf6db071607bc64b8ec2ae2ae8e691e7f4a0eee47d2d2ddd14fd2862ec5488bd83cc1d3486b7380294f96227fbb6b59e3985ed5bfa868db2762e29cf5095485bcd5a20658ffd6c759b30a8b83b14f7a34e4ebcb53f08aa98055a04d3d255ec5be24354a801b2a0fe74b89b19f849a6550678f6d155be5e8a229515e1094d894cf389ad08e2e5d8a0aba83cdc3dfd65c71f20184a26a7930047aace4dbd66fcaaf560fc0130d1069c375391f9f96f31c596d04c087bfa5d4f71972cb6b5337e35603450a3e8e4a4c4106a5c7542ec1b1048118e76658836eedb64f9ea4dccac204a8a2aeeec8a65ff1988c9571fa91f4922826d901f10e5cf9729b8bde19d08e28d1f1827368f69774fb878ccceae590e5db604c36e40c4e819d5c4b3218fd1fa93971b35404194a6981147624fcc1d7e547ea08022e68f3cb29dafd347a7d2c4eff5cd60d0936470587cea2e6ee2dd362d1e0c0a501bab648b0209f92ed6aa213a7fd057d2efd3ae7da86ed7594b0dadd0aca986bd544d665b548b233bb56d4c62415801c76ab2a3250731bc513623d1ded6f85096bfc828b6554c71ec4ea63cb02d7ae4e34377b576d1f7ad8027c1c4fcaf0af4fdf979e7c1af582d0f5209dde4cc0d3ee0b3d1ea47daaafe1d438fb1d1594bdc9294c2c20ca43e49e52404da09b79e25ffd2acb882828616c8fce3178617fef2208193703741d1820a6d5575a18a75678af6f3b7cc7d52c1cf9dd3950101fed3b3f44e6667aa1d95b7cae86852996924fceb25f057cee65bc496f479af78b7c0b74f0cc673cad751d43a890d0f48d28cde0fbae50a7e87c069dd334ec1469f7081d356822bd0a485851ef9aae346f8d6b4877ed45c9ec466e7ff1f143519b6bb7e359681e2e2132b6727e0028bddff3e81903b2af81131220e6b6af2b0aa76879acb02f74c90054024fe7be603cc80b1cb016ed2be041871e449606828868f69209eab5cc1d0c1df259e6608b065931b447405e7c0a068f94c46d649b91bf7e4b780e1ce47357a68814a7b7e33af572e137e8737659c881f13ec92dbdf1aa3f9a9b95eac51182798a4a9971e900f784f8551238e37d147344b8cf65c824aa7c8b08b4846ad8a677ba7c42eb73888c3a74a16a3a53f18076abab9d89308d0c0f388a7dc64ed1818502f355b9fded7ce18451ba866269921ab1b9ce79ae923b4d003c0d30ae7ee03d195996ceb8c32dc0e0515bfbd94856ce3377e7b178ef724c465018d5e5b6259aa347851b37982e08dc10e70f272b671d7147c18ddf002a7c50e20738f083933b7fbbc3eb3b56071e9bcb687096e0359257009894c86099dd39049959c1aab2b502e9640a8542245abeb6f3db5a293894f9e56565b2a94aad9eb18afab41db789315206ef39fd9d8adbe448cc4ca6be5fc0318cdb5d11b15b765d2d92e66efd14b066617a400052d99338921293c1796c5180e416bcb05f46258d25602c293c950d9518a1553996c5fecbb4a04017f2cec8fa9ce99c9faba30305f56ded01ac832ba1f24d7443effa44b94ba068e5c3571ba270567c20","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
