<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1aef35eadde2bf063d5dab7ce85e6f635331b842ff28678aea40f5951fecc3f4e414f5fa032b01dca9376a3416bb3cb6c2686fa0aa55a089751ffdef65dcef6fb1ea79ba3cf5517fafb154e172d29efac93d4377a2a16885ba42a16150ffdae5d5593fc0ad76716afb52a6f0261be5c79012d35e4339a165ab2ffbd24877f4640ca0986cabf7bcae9c92b2181214b54882f6584cdc1be7090fc7b75cd2cb02332d5ac97722d4ca2a2b64755258c5329a0376d5043caa7da584205cde0055817d0f1e1f55939a30f302f573ebd6cc17fd4a2ea092d2782b198870e913a1a437b0e0816cc4ecbc9069989fda3fb235ebda1eda1917c5f21519e3acb457f2087e57440a72dbc3a0c59af9b84545429ee73848822c67b53cd771f30bd14ee497a9e0f8db4ff01bd006eafe05b6debafa9785f64721c83ce0e112f3163ac4979bdce2969c165ffd10a5dd4674cf2e16472fde261f328ee9ea95615f6c6868049ce4374d540a83ec1a89375ddf6595f5e79676d43d5e04a963e9b5f2f5d4f085402d5cd1f05bba4b32e485900d0188a20b06d1db930c270aab2c1d62c472f9ccaa97f410b3115db5841e29bec4e55994b46ba055a2ee8de0cb49bc36090718635cd1757c338d67d48680eff6d5aca20a6eded06415e384eff744853eec7c318775ad5287facb0fa709ab3de3299c722d40a43bc172839d3e6b85ecaf6537dbb7d228065c2db3fb850577f9f82da16d4c179b77cfb907c2057038c968173068a1f473776a285df7193650892c3cf2d7ddd473a305b613682479681d04168c052f894c44c5d14681b5b16b2c1aef0a90c5f344176d8512362c3b8e29256da8ba0b3704d1990467729850d1057c7e14307acabe06f59e77f184e7378d879ebb87863ea14e41e21f510bd4144e87111f0786305e48800bc589f543d830a34f29f654e90df0e8af03b70e233b40ac75d1bd47314df69c5352733607b601133a6c16c97a3c00bfbfc480389b6a8ac5b67a5ca927e84bf4bdb6b706f179d5f002ffce4dce5281c5e0732286cb3822ad6a6eebaad5a71953a6799ba0ee093c511b5f7d87a39e47c87fc1e5a34ea59f2f7878de35c5384bd1505e72ebcd60b4279f48c36098b6c32ebc58f9f249e316a8d7f9048d9dcec8ad41eb50013c47ce4639f892dafa2482562fda9f5e8857555a73bde7e65704f01d39e89b5549575dfc6da6069b144807dc519f018f973230d616f0178414fb26b183d60d2e7d4a923edc11cf5a1f420998ee0a2b2cbce4c29564babc0d5fcfafe44295f6d827796879a919ff39771b8126a6eec1d92a5b3c4716e5dc4d27a97a99c0ff4a5c56f0d86c08450b55b9925ca9e257c6674218538e16d9bdc6f4c9ad46e0ba5b3b75c4f9eb15c674944058f46c57dc7bea102ca6b3a49bc4f5f734da9b042992da68aea7d5a6e1f39d40d9a24b2ddbcd9a86e206ad65f9f822a401408e2a0d4884e411235c7fddf0dd488f6d5a934c94fe092af7ed91103561d156e79fd62bb938c1ab008b2649d0e0c023cc85fcf150c91e3a18333a1234eae531fce9f4303c4f0b65ae05786ac87669b871c04dec8fc93c02c47a759fb27545deaffa8d6f0429f45d6acd2399dd411cbc42a55975c55b652bb7165bde44126843b571af4ebde52919d6951cf54b13013dcbce68a16b03bca6123d04b9702d870b24a3654768ff277d4159c6a234587805511795092e95079127b2b31e9a42be47467e2e3e4a37f5bf990b889b753f4401b7380c38ad76d53ab9ea320b155c24aa6eb6a9b6b6ac09d7e72b71aa8e018ef297124cfdb8339454ea69c7d158c959e9b35099173f0d6df15db93f0cecf73c0e3c2a955f14b9fc93dc21c5a0138f229d08d710299a069fb4c6617db5171afa7755d356a40a62873016b416c8928c4bae6a982793ccc9fc81be79268f2ee5f4fce20be60f8e095977e14a6b2585f255bfaeb650195cf1bf97e4d91251310785a91ae2ea7434355052c24131f5684c7907ff82498ebfc1af533fe3e3bfd1adc02762dc9d220f8d937a240c29a872e137fa277c1090b6f5fde5375807fe4a362222d3340bed215c5a0c073be3043136784e1f74840cdf013121452744e0d39d77c0a3c7c05320e2216b7a5b4e84f2824ce3251a5122730d6682ff05ef639c5fbe4e6eed804dcfd8ad292b3196efa7009b12db7f8eeb03d245a58807df79f05b4963c19db704fc5bfa989e809465822b4ab67f21a982d332a5ca492ef9c3e44136c48306a3be838b7a097015c7b498220cddce18abd18adbb9b1f595897b577f93c74a4be4839637f03dfae4f500a3c008f97292c66c27643222cb899ca9bc9e9727df084f903a5a0b36b4cae5295ba03849dc3a27ecd1d26530416a67410b06e13f3856b3f880c494700776c7ea0d51570a6b2733bcb1ffbcaeb7a105b8877164b45adfdc258ad0c5308758e44b0e1d02683f90fa29d1ad4e64777530aea8160cf49d77acf0b339828f76ce2d16f19c4f25640ec2361b519c7a36a62728cb4e90eb214afe13241efa2d45d3a2b488d2f27881b655838b69e3323b2d675a9b78a27983d1ada4d29e7aba43c468ed66e2169a41d34e8b0dbd919fdf92f57a69380170258b1ba72926adcae5ae687aa314c58942e23769b11ba5d76493ddaf537a6cac1fbe83b038393c44d539df94724f2db378f045622699387e7f798bfc355bd9204be9261f51fbdbc5c1267a8e83c600a212bb4581dc099e1414508343f15466d66188e226ec47ffd5b94a0dc1c79557ab273a309ff66aa80107f02b4d4ab272b746fde8a0705201cc327dbda798ccf03225faadef85d0765daf5beaecb7cccbc3138c2761d2121f62199ffced5119ef1ac1ac03488a5d8e5b9648c944799dd3fb1dcf57323338fbaf5ec173426832ce5cb473ef5aeb186296b409e266698fbb887a90750e4365b5a3d219cb5d597143cfb6f1357cb6c54af6aacee3b537d0e7e1c9baceb63ed7501a0fc88ce750058f33e64d4639baf4d17ae2ed2050202a0182dc6a156445ad9110c8706af42b3ac6909f508df3abfeb26f5d12097bbb2f93f9665459e03600f1e1db64159380d8e29f6f6a20f95a9c43cd4e54f303040e885816bc1a79327e19145c0b5cfe27c5f3d2c3b9b4210174a3819f33af5a8d3adaa6badc716a35f8b7c37d65d6f3020d3bf7ec9af9ba451e4bfbe4b94faa8211ae5183b78a9aec51894cba8ad03f75328aa456b29f5416db82629d7cdc7932c1f4725fd28efe0afa79acdbb436bc14ed490d4837cba497fda3bc1c8ab41dca1649dcc7ba0558fe6c8822d214845dd73efec2551a8d0f00e587d903551e8bc6564cc6364b4e67ae3f53ba41d1761eae7269a0ae098b2a2e80ca402b534c142f5e171d8f094e211326df49a3c4aedfa0a985d5fe2686d5ef3d2df80f606f70c4403923378519f50bf0ad46165bbc1e9ff966f8cedd15ef243d76290f65a26dc3f92cf56729433cf08d9e6771bd86b3a57eb9156f89d747afbe17b07ecf4069c8e5aeab324c7fdbf3cf8262a7a14d7b3fc8bfea317e68b604aec2f3e95fc340586c0066c9cfe72af99e13a8ae139d360fefd8d650bfaf97b3e2e18a70a202ee96a8677c6d4c38ad5526bb6e87403cf4ecab3c6055a09cdaa0876eee673ad1d704a7fdec95f3c91e0a496ebf213b38012bbc017f672e94f95dcc416c08632c47888c24e3a640eb989b099a0181ac14e934528ca40352b3a67031a9db4f04af7988b04f4e1d2605152bc55966f6c409440a8b4152ddbf264f0e88947b3ba015fc12fbf757c2262968a165f4474cbdff0e8ce10482b09db7a4f01def2f2670d08441e1662be4c85e9ca0bb8b015487979840d4ed2eb8e08072ca4c82c3fe98d987a5492e1e2f0444ba5d3fa6938300e921ab60844229b1e9efda55087ed583a14bdb4af8bf9ef190008ce0605831ff573b388a6b811ac448743783369fc1a10d0ab2bb97421c8a8ebfeb4942485df98d504d172601b6cd1917f7844ae58dea808177923e8748cdb63ff79b3767dae0985e46c410893c37f25e1af1e58dddbe93b416441adff991fa7f4be19b7821ee33ac3e75a85c3bf29e0ce7d9a1a5540d01ccc3558b18398fbb681a2cc0b9bafd4bcae26f1cd95c9e09fca31168f166f3f22bcd1d0e6b55f56cd58b4b94f19e21facab7d95309405c38175192180ce9f131b95a5ff01cff6700f8165745447e41fdd25c2cbcd5d4fb3389f38e98551bd914a691eb4354d20ed464e35748d425a0621191f8d613298265eda1487501d7820af958f88a85a1b095c10be3e61066db172e5e89f4be8271f4261a5cc419ebf290da4f42fb083ef2eba6223bb82affd21ef31dbcbaae530584952b0766fb0056742385227a2f7f3b7963f5a15f79c241c8aac052ad0eb810e4773ef0d1029a7d38a34528ddfa9c3320fab566f892643ac64e8a9d8b43026f8945fada6c36dc6cb0c874901f83fe40d507b488aaa6f5814402d8b7782f981524fe25f56b9d2ec9e5d1a4746a30bce625fc2c1e21c1ab1487a2c3b16f2816ec68344da9d2be7fe0acc57949ddceba4d99d4af40f1151569b026531f8ff208ae912a08ea1f2c458db8c9307dcf921087744d3b20031c1a7755989f3ee10d7bfc7478381ffcf169f030d2a926a77f58692347ceb70a15be65af66dec15deccde79de11f1e582ff239476c40a4199b1457559e066d6c2c653d2143e93c5c9a2c1784371e0c36ad5970488f79ae90ef8ad87b29613e97b87a72e5471776347d0734c5fceaf077fe7b6f9e0239bc554ec0f949a3a0b08711371021e8d2c5a0ca5974881f8d8347b3a9dd75f64f1405994341464b024349e1087e752e4a8008b4c1ad9ba34963f433bd46cc8c93a77eb38e35c5201778f01c23a7bd251776d299f5840e6c61b54368074791f4eece7b7dd4106699086f4dab288d88b209a908de22d993519cfe5fa043c5a9e94959b84201736dbd84a3a809ed9cf1445ccb3c2b043b34960f319f5961b24724e35e0b8d12d3ffbe4584fd1ab9e07d68a3c0582e14e6b3ef4b41664cebf853ec6334d608ae8774a46f13f6a1bc2a25f4ab44210b11078ddf4b288c1a68e686b35cd262516342e25774ce12670d1416365a51873d7fb1aa14403a61f62216cdfab340dd3a35f9457e4f30cfc439aabad8e493aff7c526981623ad00022ffb10df4f999d71f526d1c30cea630e5be460425af1931538894efe9ef3c0a46d0d496ee01e8001a8b770434d393b41c03010cc789f47813ff8d2f36305f09ed6b39b67a32b5bf0cd99745972123f48e814ad0e2ae58818f074cf5ef2e12f8f10d1227a73211af5a5bc8df26e6b7735bad5f28f37084749d479d7d1552df2082a6d2baf1de01c298077db4906cbc26aac4d3b44ec72f2687d5eb0f728a7f077e859fa2b375da9deb2d259bd87a7f6ed78e71a96a39edb1d1096821eed5af741f691e0de65b09066c20c4c5228988d841d453e24c3c290c3f33ef76c95837db25b73faa1f92709eb047dff719f62093db73006cb35b10bf097391360001cb50c27de4e17634d18e617aa39bd80d13934d71097540de42be530ffcdf0188e28ced00682e913e07a2f8ce2441480a097eab4dcfadcd5cc1914a6b63262813c1b5635f1944e7a6324c04d5bb05eebfac47862d9faaa22530fd74282f6322607a7ec1703630590eb871fe22b1715534e5c4cd71c0b3a55747212d1ff436f5b06475b2b7d72576cee772c51b1e51e0c1a5746eea03a305364e5a7ca02d0c7319bd2878e7d3fb603a00f931938be885bc2ac68a8659483a33c9a546633e95d6d37bd4e41e4e640975f2bf4e31a52941cc36f4b258f7129e7dea4884846918d7a2fdf982bebc63bb230e7b7f0ed3976fa788e1a4db74364f7c67d0af6069b506ba000dcd69dc4e165332a21c91231760d6ace721f38bc5110db0570402d5a27a5ce7b2b154f33db9fbd317ed798696f021be4393c4f24d869200ab7b4af0c83618e0ce2805dcfa72d508fe466ce243e71294441a654a113e92191319435a7b1381c9d5580bb3684cd12d33ca1659227bce87c1dc153c6af503b6506763015897238580ef5fbb6b07064cc4f0d00758a48e527865442a18812b926a504b03867c9378b1984eab310183ed5bad40080f7112f38e908aec724bef896b1bdd6618686a80d095c2e3aaab17bd4a8c914f46a05322fd34d7d7b62980e2fe9837711b293f0ae72a4b884a32d95c26758000575f7509908c0aadd78a76acbec81c7efdc97713df2ba50cfa213718d2d18080bc4f72a831ee51571ca1074a4128435eb2818d74145d45b5ccb9a253d939909015557983f110b30d3934ca2945ef94c329e24d2d2fada0868c53eadce848a6c7a1cd9f67dbc2a8beb914a86b59a5af33c264941593f178235cb834e2b8c0c7845cc618ce5110d1bd5273a6522f42c70678106b749683e29a429777f674752831e9cb10d876f29ad7ddcbc6b361187b7b85e780eeb2a10c301afbe4e9a09d8982885713c0a084bc29e4c3fd55e98df1bf42f2690f95a68e9fa904d5693ee2add81edbde90b4ae9e66d5168324badf2878d49cb98ac2ebb77234326fbf93765a650ccdd6b36486209ad83b0ac0b00c6ef1f32c4eea479a99529672ace5215adc2c2d1dc353c6017b5be7b159e6d3dc0d69f32e779f22135f4ff8794f741185c024a51a86406c44e6dec00006b563c0b22aedc7bcffccaeae9977961dccbfa1c76966e712c327d13223bb4a9b2f3e61aeb380cb8b379f0a0cae9699d86177a92fe9af7cd0072d003c166f73f5e01752e0797ccc172c6118ec26ae021fef82cc83cf93f600ae58f88a72d6711823049a50440a14be5c41412ef092f195117c90ed7a6ae76d7dec3555f0f8ed4b3884b707427e0ce87490c63c148b28e65c33030e74c7b2b7ae4fa43f5dcd3a4792ebf0b505aeb2b71a84fc5be49f6c25f019b9d4ecb076292e8983bb8372c837e87fa08811ae6d8606b1e0ef0aa7dacfcd2dfad7b729cd21c27a35b3c16bb05c343ade4732c73ee9a4ada05d06b8429ef6b23435f7f6213d2875601535278413353032d0fb1e2a3095bf3e93aa945c6290e4781e7cc9db41cdb6c8f8069aafba321bb50b20dccf081a943d024018e22258fac3f8692692ff376866319eda5829b56a3aa054e6308736feaaf90d149a7aa51c93df68e6fd4ad08806fe485bd1a6cac5e9ff18cc4eec4795e38944a8e10bcb1d87d67a875a27f529a11d62b69fa64aec7e8b588879ffe39d3c03f4b17d37e3d57e49e8312562cfdd3ae0f426f997fb8a6db721d066673b439bd18a7ab534235bc06e897d11de7d5d99c26d130ef84a0bf89a4772c4af46c285e0707be328f807498caaf14c39830aed4d7fdd05ed8b7bc272083c1af06e38d544393ee5016747907364acc60d05ee29a07ef9e46c144dc0fca2f713c9e514201ab12e32b6718e40589cab50f32e71539800e9f3ecb62767fa8e481bdaf1380b4567c66fef24b04fd6ab838b1742566807036469f79fb3c7fb0a56328763cfb2ed3399609c91fae652175190a38b0ee4962eefb68efd2d1e99ac020a22bfc501b3cbaca45331b7f646f190fb30aed2a3d018bf06f162f0818e321f0f69a767c2c121fd9bd722da7a6326441e4481da54344166faf94e6d2fe4c2a8d4ff9bf79f7d9614c65818788a807fa0cbeb35dd4f31134cce4332e73891dfb2c19e112d05a11413b41991822e63c33926b70968e4b1376540d47cc7b46c10448671e05f9e91e9b9f5f44d281f4ce7c8a7cf7e3764c84c2b2daf317ba5b6d308e4fb23163c205fcdc210005bcbf2b07786ee940e81af062ca595e162534622e3c7bf62b4348841980d1239b5c64225f93e561d038c30227aab1e3a24ecf734a939a1ec60ac05e3c1a05e2b6327f306ef0a1e9e898563d15185f2ae9facb8097557c327193fe0a7d1435a8e04550111020dabe54f9078a5db0d7b50bc2b872e69be64d848ca0c781eede0f7e70a2129e970b5b5a7547ffd45f9df9231cddc1a17896ec6590a0040df259f460744ba716763060a81373a8effd1e0d48157f70127b28d8cf1dcc2b7033cb4e243a0ef6661286aeffa19fc816673ff09578e43d5cde0235a9c16b46264c6c2562d8ad2a323afae954558a0ee2c80b8264cb0c052889665e23fd80ee54aad66ab57d702fc5edb6fc1fd351a68deed1bcec1e13f8fd26705540e860996ae8820a0982f380abcd2898a7c924808da56950018bf7ccd727831cc4d9581dd3dc6b128b7b49c8375802b4b80f2242817509ce862685b43610db491f170fe2ccf325a5d9c77a08b5e62f18d41dfcfe7908e263eb44c872fb9b8e17fbb60b970164a95a6ab28079b8e013fe5d61af7a85669a19183e732daa67ede7776504e312c53a6c767f9cd34b9da6a7b71bd544009c1201e9f27295a2252c63d779c8f0b575c215d9c86ac0ec316d351e4ad68f4b78259a9639e64960aa35b4df9d005429c6dc9799b84e4a1bd5ca20ef40efa0996d815500ef17a7ffa60ef02cd3dd7993c19b14036a7425ecebb7283d54cad3b14372bee07018aab2956709a35a7ad215674e1656fd5a9f353c84ce057c49309e72fae861c8b67c119890818f9d31b6cedeac7574d6e4525bce894511cd9353a5481f1b995f585efa3d8c0457f09abb67ed1b0f6ccbc9726eb8f66a533ec607162a69b483d9885f4a113f447b56102c891ac2657d6b3a5fe6580b05bd41f6cfd1b509660a669f31d4d6a71dd2b499a8ea27e6406a8a2591003f59fa601ea9a9b7052801c7ba929d8bb2dd497c7514d68edbbc7059c9700c98cebeadd8acb386b6fd9fab81efc679d8f87ecd7263ec3b22f0e450d75e29ab13ff782f172fdd0e3978a4efe6303f4c8fb451a65172136d5b3a5eeb2788c7d5b3428c162964de4e80003539ddf7fed46d7a6955a013c9efa666b586f04064e9a84464831f1f3dfcdc82b2ec277870f9acb1f9d7a44a702393a1b7089ea463451bbd514c958a865727febce562357f90bbb81d2630aab75e466146becebdd7cde841f3bcdddbd7c422110bae8ad587ce37a7b9c22a1fa19af81fe7bbbb06c2fddffb4f6652437bba735d07ae1ac73d183a155e30cdfcedc32bf8d32edb78029329ee0aae8b719bd1c8c91c19260a650c927a04aece7ca7f7d1865b9c6faa591fbed87560688d57ac96b074fbdc5716a8d299488e4d8ac7ba696adf81d75aa5caee64f52b82933c2dfb21e70127765dc4e3883d81b365b96e16cbacde6fff675bbbda3db9375735c1f6e02c7d8800bacdce7355d40394927059f5be2e585fe866f698ed7f0e45eda8d9824fd1c144f46ce956d9aea8cef832cbff1f823681d081f747080a4af83024a5be6dbe58f84cd31c55908773ace4b8e23199257bccb912cf0a6493dc236ffc9062d92fcdb576c3238094d6fc3307b366ea22fcd6d97884f6b58ada51f4f9f898fd559f5aca777b01e92d4fa6ae6d6c849ebf5e69891d3d35d0f84cb32cdb1b6787205c13bfdf25f867810ab1b8e74531234dff6c0b093a5cb84e885c5d6a8a96e682e3c009e79a68f79b6826ce80bbe37074791dc76bce204d85a8d9c95025d5029ac7eab1a44b691f510796f30b1d875024f08fa6855a683f35750030ec82220bc245d46aeb773a8430315e83bc0b0df35b43f90f14d77a3118093e03607eae3811788ab2457a9691a9230a17ebf77bf618212b73438666c9f4ef11026b87ef39845bb8fb173806c2e04d261a02a7999057d35da19d8b48c4ba2364d1fb8507f27d593f0751bdf13b5a04d52a59b16e06efc5fdf4d46c50b3cfcdc7092eeb0077db9f027c3e195677b3f979b2d2a7fe6a252b4f1b921eb482cc3e8de4db284a2ddc41ad17c6390211ce6dc1132a2a69b74aeddb27c294d9d5a31eb899115cf987028a4a106eba870523190d5a64012b48358dd447410c58214feb64c47baaf6d8f98d3ffc489c0d9478ba32d775747ce2ddd80da10a000aaee03b473b7d6d4446ea70a579435dc8e8d25e372e87f5390acd7520eff67da922290a237a6dfb84ae284e7dac238cff8f86d474e02154ed49ebecbebbba4c79aac1aeab231a584aaba51d2f194080a8cb47f13bf65c2cffe1f1ff13a3135b158d3888ceead5057a50f5821e577081849b4bcfd7ee8c246fa747584b01b6d1dd53b61fbd7f2fc18a614811bfb92dfbc96dc973bb7cf7a9b46ede30392e5e204b56071b0e63a23992f3460f6ecfa15607ee679f9098937e27fadcbc4f76df403c571fd6d979c8e2fa7f4a87c89329b95e8735f0fe42af7058c3fd8a2fa0551a3da45aaa6244e090e9d56323c8cd2c0fa047331bdab5c777834d63872062abfb00c2b666affac39679a56cf0d884afed4abea7ab9d2d83f0386effe9bf62bd19d13399392afb30a563154629aeafdf5363d8436b8d7daab4f8e80a735b25948f05e6dc9c304d5aeea0a9a6fcbe5a5c7a11729c0b75ddbea7864219efa0f25b0064fa4c7d103f13674755b5a267e72af0d980e5eb945d4b8c4f123cc7f5fd14bc6657b811d02239b15c5bac4663c09d4f7b0629e9a0ed34127e3f95dafa6aad3d1fc1008286f909c684ce44e35a311b18fc2c9b8ae65407344504f84ee9e76b1552627bc632fd63f71655e8ded10165378afb601a3b11795df921469d45f7379af33ad2263db1aed7a36e128fb1c3b84ef97e43ac272b158e55199b4e29bd86ae4417763ed56449633d83e221c9de5e856e518b059a930ddba2f82936fa84d8bf62e49da71970b675c3c6c7dec4c2ec88dcc198d47748f9501510e16b479e1ec1f2e1bff1a0997201b4577950ee480aba45d5158361e6033e63bb5e8b1e4673638d85b845ba354661f84294a6c3b25ce276cda5bfcbc22490da7e1d655dce73281812d6353bfe279f0418d33da6e9bdef4a528a93c7b18fd13d1b0654d6dffe6d67a7609c4bb38cf769ba661beede90d9578ab8fc5fb57aab43e7dcb59da37ea639bd9ba8afa6d5098c89ea424f1714dcdcddd81cf08a351f102701d0787a9bddd5f622b98996d9392b7d0328da50ad87c188d0fed4fc4b284e6fc386b787fbf49431574a4e360b1e83a89687b32752ab82a11e039a83877d56588baf9523c7d7ab64fd2cfd7cde7e2bc82bc4b8d371b0df52a1ede78e1fbf62ae9c72eaff703f373dfc0092deb50ea7e6b72e5cba113e32a17f95d62c75ce0c36fb59c1a6f67c034039eb530ae871158202daf3cfdb1c46392ffdeb55f83abbb2851e338632e8f17259785e860a4d99af176b684910859bd0d2e41f56f6060edbebbe7ff8f4c724abf3f28087b97916d8172de21164c4f6c08c5d9422c6a716fc4131cdd6dc527d1b77cad615423f82909d9ba0b30a340275294d30b27b6e4cb18ecd06f721c7ee4178e1de34d318b1e5236a8d2395fbb6a51e05cf69280a73101c07fcb410e0c2b2824ff1b1a2a16b0a2d2d02b360a96ed8f5af63837f1cfd25ba16dd5ec86ab60bae7eb7b666a4b27eb44fbd20a76cb2b1125b62b907a87e68a2f85683d53ec840bfd6de5f399de73893bd01562af4a781569fdb154a9d40cfd4cdb05195cb591b70589b872f470cb2ff8d9a8be353b2685bfaf9fabe3f0e723fa6735b1a61e171f1dbc1b9df90d229e1c105d91f0a7394833ec31c55e4458ff17da90d1ebdd2b8185eb53792343381de2b9a8cb18f996af1bdceb9204b4203d12def4a6af8224858d75ac10dc1e98b73ec5f0b481c7832cf0f7ac8e3d7f90c74ea0c73d752293a19a1fc087005baca1d4e8f0f5fa56a3d3b56f1dffa410f1733688e66cd8b70064a4c74cf997bec2c792fe1d426566dc6feaba2628c14655abed7bfa9c360eb225e8229fab5c557f5d38fd4d6e56fa8862bcc61794421c56e64ae93fa573a8d41ad9d1f47bb1d5bf20689d5f379e73f68157096b7a6f7fa5c25095bad4d19fd1f4da8f52230a57111df9460993f0f6ef93574437ff0be54c35031132836d09b06a565fa0aba329e1e80d4d4163feb87ee96b5e559cda898e444090a1b837e3ac15eb004df92e918301b6b8c6c795e0e98bca5dab2d5d142f4a5632874c419316662fa17897bac980ca5f27de56ed0164be0bcdf34099af5d768b2daa81584ca6301d39430bf636efdafe7c391e464f3425a609dc918dcd6f4125b835d4ff9365b5d723bdcf831b7309233b59d1be4cacec015c45efd44ba855087d2714644d1e7920313ca133e1684c2fe674a7b9bb54364f5ceb4fc6c3edcc4423e0dceb5fa7590602ebea8b1b54f06045a21db778f0e03ce9df1686930aa204ddf93a245b7f6b7c7b7cc965b27b1ac938ce216e9a9e4cab157ddf90db1f6cfd6a53720f973e64d62e73ac0166cdfbb81a4d1485d40379f60688dc9c06b090fc01d726c2f9786b763b5cc89eb6eef6da67cf291a9b5e48e67b003579e235d9f01f7eebc27a6f8a55771a156e486b676c50def1ca87bad0ee2264a199d2ad04b96ece4eb833f7e050e025d278a37d8f52bcf4a83e690e457eda771c0b0054f932efcffd38c1cd63613887c66e09f9dca30dbd5d25fb0ab3cb1bc89b842705c10349a70904e9d1c9afa7e2e25132800839761fd91977e03fb47ce1bd0fdf2b02ae145a60e37f880157f0bf24e4a6e9acf8bc3a2e708c877418f1d6a9325fe60e93ac39f520c6e0de67f621d6bf7e6cbc991961f1fca6b7cef71b275c089e344e3d349137206cfeb9045d9cc4a8e42919a38f889def9153fc670b5315e7c6b0bd6f2b373cc10612c6aab35b970c0836e2bfc8bfbd72448c7f31ad832c4dbaceb67545e8f641b4da0e09884e385cb174a2387312784de0c64d2d395f6974b63a34cbf0794898b9810b8abb1de8685edc46fec20337c9e51f945556b07848140a7ec642b488346bbdb1ae73b41a04317844aeca9ce3a7b14b6f9ba4de1da996093ce2f75e3d7f0ff9c6114c535ea5c151b02d30b06886722c483881904a4ac389461ad2d1fbf28e9cc86c1cfc5eb66692d63a60c983af83e165c387132fad7e1c05e74ef9bd28ef2f379981e8ab04e5cbc4d1328a96281c0916a3f87b7bb8e4e32915bc213e6d1928ab9846a432a388c6ca9636cedcbd2be166667220984ac321137a6b2372e0285588cb8ae44211b0852394d9acd7cc4bb71a417688d9a81d60e9abb91430ac3b14efe8e9d01fd2c1ad5c80f3e76bfc9618945dc652c613a26ad1770a4a482b82d22e8fe267e01869009eb52dc6e034835c85b38d401d10eac6cc6ec40308660b32a33881e80403fad09c88411c554fa440e2ea7924013fd32fb5d3167a96b8928bbd4df27ea065141cdbbe556714edfc8f17f9bc3fc2ad76cbae163c74b83116ac1523dbb9b38196f14c629dcc18792c2617c9fb05c75a859a8ce3e94e4193fd3349083960c1a199d8d89f9ecf1f01c67e2bbdade1d152c639abad0741c922f1d034e0b50bad1937af8a685a426bb179eecfdc0351f96a96ee6ca58182d1f202d13a48c479b02f8a0c2e57dfaa9ed4fd3964871041146c8cb2f54d042bc1e9f1cab69bdd7c31b5b8c546065829f43f019ed7c4083197147740c8ed5c50ec01403a38bd2f52e695dec7fea2f488ecd2218036a8ef5978e772b403ce1e9448caac19231b19b5afd975eb7a716549f464d0dbe8d6c984f38b362930fdfe934b71194294556e2510763acbb8c47d55a258da28133faced8cc552e2b87e1ee0093ae58b0f4ce0c618c8c29dd9be376249abfce115af1113f7dde2ea92a2aeca60724ad673cd6cd7c979a9242356071bf3a2f2f6d0572b4ef1dc0ca96cd4c4ecd5c5ea380bef67e7d33005f18f8e4ebc8d568616664dc7daae972359aeae416f420400029b2f399280c66a9e6911b518b45ee311cdb177116929653686c04e966702b22e3789d2c74fe38fa2c35fb851f697492723492c6d01d3d7dfb68425f74d61264b13f4921e513a68201e2c1bc4de11f549d9d17e02455200ff97ab2dcda7dc23a0669c03fc549f257ff4a56e72f466e638780dd2ae706fa772be61aa2a5e39dcbf21f9f558d1644565a1dddcdd67fc0ceb9f9225e7e4f3955e0b6b5f4b7c533797babb1d2f3a5a46605e45af137c151832d9f8519a4297cfefdbdb159673fdf9aafe86c0deb966108e6b68d134e400b38b7c0d1bce135b15e02779123243bc9ee9bba348e9246b77998c1b0cb2fb4bed1d671d82692c9c43b3898b72637110a5f03fc07d3ec70ba34970ed5c7c9e22b6bacf5ba8145582e683c6a2b24c3823e172b95c22ba2ff427a0120ac39d7388e8d3ab73ab4416b1e4fc88d087c47f07b896a4e3d49db4182b4c179d7c6c8c73e3f394059f840e30bfdf16b3e403eac1eb638f6cb423c6c6ceba463c2fff2a639eee9efde7b055c4dbcdc4b7262d075add678d79c5420e56490749471d9e9e9ce2c0c8e399b0c121c8c19075d94714f9c5bc13cab5f059d477ef81e2d0cd4d590f6284443a2c396a78f0f5c14503ffedfa35fe3137422d48e25ea788f08b231ec0240b1c989a51ad29bbf264c5331fc84621d99440e6dffc12264bc4d99e7ea437ed70188a9f008f0648d440b5b2ca1a5f20358f5ff06a32e07d33fa4c46df1428240452099513a908104cdfe8529d58309f955eb556506e4bfe4b1c84bb750a5dee582d54bfe82ae0a2d98ba7f3aabb15ced05008548fb56c4e9548666f9b13712baacc7cc528d04c42e8ae17a8bbbecbdd7e28dc9006c49667869676492873b897c71b1f98296cbaefccf31cb51abda022be6f75617912f6591ba4150a48f4ff18f6d3a55250c7c9ff2a1fb75421672fe806ad3489810e277fd1b80965d9504e0ac78743343b16e54cc02106a853371cfa3f69fed096b3b4bc1b96d3fb2ea7edb829c937306ecb6eea8d3baf1b90a3f75704caf9d713516f39d25c0674406b06d6ebbb57a17e9538e38867035c108c66edd86d05dbbf047e9249c8184d810d13316b1e7a0ff850bc613a8fbbdf8af6047024f7205b9aad43e2bf32b8c12ed95de9e98236dc5914ccb08fc39752ed323b12b3ad8e40ae26af0918f77e965c9b8c77f486994a0ed31e6c57dafbccb557584d8c61207d99cdc883016e746d441f5ebde296d9889d996d2aa3d696000aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
