<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a82308f81106b3c2fc9f99f7842de3e949674d7fa4bd677d6e3bd16745ae7442a84f987adae413449c81aa681333b4b13f4123c2b642bb1edcd100338355b2282951376d1eb1720bb525603db8caa474956d6851428305a16c392018562c852c6efbc6b9ba3b6ccc4a13bedba614ebe1d15851daca26cff89ce06b1d8d89f72cf9e5d25dbbd585ce91678630b62941b55fb050f4ec00dcb87e25ef93b103daf7146780decf993f7013d093c94d71b8cd4c355bfc707bea5e35518f9c3cf3c9849636fe8e13aae45d5ab79b174c0b75795e35451ed2ff37d48dd1a750998dfbd80e06669ce0f3f098b92ff892bc78c4bf51fa317e955ea156a600cadb7ac66f1e9394974735101577714bff67eec7540899d79c652e95c616b4f33f85a45e82f09776e99ce14e2347224c13af76834d05d7c912e3e8af5f9c4f55632cfc736723471104d017c9ba9e082c9bc99d5c3dfe8336133466bf5094e1f9ccb6996d8598a678ea32c7f8fcf553c29a3c8b0a00a02e9678cc08b00065df700747eca80ded2d270c18fe2f8f51369e104c6184d0c6cbacfe389880211defde9a4870d21ab6d79384fadcaae47c39dfd310b083c4b27e2f2107977b76d6738db52ca44138fd9c828b165f0c470c788bdfd884217cb85ae9b20a03fcb6cde1f770524b76f991df17f4a33a9c2a709e95188eddb80e602db1f1a8c9c5a3174a16a79bdfdb1f6c32cc73001e0949a7d910655da4dacf620142f1fbd455d183bf8e2681396625ba3c400c824b4123ed074b2e54c39b58356425e5e6359dd5968236841699ba27ec2ae81412b88df806935b7bc40add799a613a4400c79d49077fa915674ba3c22e83ced1414d4f4b4c44527eb30fa7a4b51fef305c70fcfee8d0a2fd0bd1e2c363ecdbd1ce77337fad42fb6daa4e191c25788b1bf8106c7e77901f72845aa966794140a573b1ee22f5301f32869e8e9e2c3326d5a4a02c0f57b17d52d4fc5c53b7514f81e3f17f908c2969f4a79f01ec4ad1231226937d16de29184aa573ce53f94a2caf2e74c4251c4630d74a054cce06223f3eb24c36dc8e0f87e0f133ca0e52eac0515adbc41ac543e8cca57744d8b47364220b9bc435a298ab5a839d93fd95439da37a16bee3e04cfa3545b90a77104c4cb89399bd1575cfd986844e40c061004cd69fc16f40af174a2478b764be3ffb0dc0078954b31d0a8247e25a697d4da96492a57866e90fde29bbb5f5e723a215c4880e627db7f575a19707174994af6cf426240dbc280c9f2da2e2f126c22eefa0b44d9efc8b0744a5186d7c0fe1c41fe45d205b7ca203c161309963e790c6de7ba10cf3e4d93d8ddfbbd5586287e038a3246cd3ae569b3948d59c2f5724b03647ab1eb6b48b9a9605c194654d8134a5d34fa7fa3c4406499da30808d76db6648037723d748df7767cf7fb22f479ca4ff85809c650b40475bdbcbb8c15360a3d97154276d0052351c6129f84e09817c0050f18d892131b835e7c3245555fd725960064e2ae3bf75c380056f2600ea43a0c6d8590a6c0995a618faa8acbd357637eaad86a7183f88a90352eaa941c482411baea71d52793830b72a4c9536c85d2988ec114f57d7f474d171c8ffccdefd9892e8ba5d611a7e1e959dcdbdf3a17a7ba68085722f91eccfe0b0d1982f80ba74f91e69212420d35f94de04a048eeb8b21690827493e4875ada8556d269b83becfd08a2deacf0a4e82e725b66796feb2dc407c2b685a4a10839784cad4170b09b3258dbf9328a01ec69eec613f9610041d166b1d5daaa14d403c79e86599810e427630a45233de665623eccd2f5ba9479b058fa4386f5fdd6eac901f4ced6624e5ae09c6cc669bf595326bde499f0212c4ee029cb072bdfa6becf95f516fc1b85634cbea91fe3244425b812d760ee8683c0a51b08f45b99383e81c0aa8ea22d6f1b961ad3ef74b7d380de372fccb0ff4e699a9b09a15d4cf3a2d1d7d51c409420813b0b0d01c3162a4d17c3af7c25075a4f9801c103ea0518f27d2350e8d59156e2fc1250cea387e8d0b0ff780df72b9d6788762ec4a9304ac60ed13f84b0d0fcf08386dda98ea1d8173086a8b18a348de7b6993f9608f5b86334637f014c7173c10195572122604c7bff976a116468121fcf731799a70a4c912fbe0e2ae18529ca8fd039183f57a288d5ce2f1281c3bda0c88c74f6891f82b05e0bf82666d1194060f68d6fa9a53db694273197bef87fe79d5de6d429461743d5ce92f8886cadf77e922f94383eb21ba28418464ef40208f0ad91e75d4b7be3fefe8f60346a5e44f2054b9d593f46af7e647b00c502766a2f70650cef0743468ea8089bddce8726a316bc64b5268e1887ae9cf6299c7e9e28b012c1821ec7416e87ef8ee3d0bc4b6191932958402218199f787b8dff7c92fd10f0771eda7f323b9b9e6a77b829b53855fdc699826cb54391e3de042237128727b92723d2fcafeb82a7ca7958396ef6978795696ae96b901804da59cb15231419b3d0fa8e64b71d33efc5cc9d4be2256d1a6868a3ca49c7a17312611f15f41c46bebd74f05ef956cc3fccc0d2802ba687786699f57c516359107dc419fa2169c1715b447ccf24c3513ee4ea695528ad46d8db1556650f37b4da48cd4693d57fddbfd7ec58d36c52a1cf26209bce10b45e445a769e4a34a0f7da1af3b8f844bab424d09809aa4b2c32ef918e822c4f7c974107f5f478f4a7b2826ac5bae2fcdafa0e14d2db2ab77ee8ea6a9a5c157b90a9d4854570d5c3540a7aea0ad4f9e46b7edf9dc9c437dfb1e469065d9e2c1c263d555aab17325b33e3f777ade4dabdaed031638fac45ea51ba7c70f47efa8cdc2aa67cbbeff8df95864cf2455039071a65676f799641ecad6eb2c17f736f0c3e2ccab4e305b9e3d3e26f49de0be91b42599574f7182a8775988d7c01c0bdb180b30c2119e31db9781eb31dce232262b3d6f9a114f958297ddb66be3750aaa8f19e4dc725f408792652298c324094e2de609d572fdf87ea0e560e16c0c926e10e1cb701922c60cce670de6d5cc0bcf9842e49f26034c87e28fe53cbf1adc33ce3ca396d44dea692e85d5379baa9cff0c79eb8c2ae9225274bc0edfbbc851ae15b55fab008bf4769ebcb0f8f5dedf9b473f14c591ec625a8346d1176d7c74d266aae1526174347c527021df1e2fdccda205e1f73326549286cb8612ce904e162ad9aab703e9d6157bf995f3f4a5729dcbc441fdc6ef495af5dc256412a844e54304cd23bccd96a77da20e7348c79227bf4d89967dc07edc050aee4ef8963bc890106f245f10238773f0b6ada3d64ab5b5b44fdf476723f6ca8cb3cf028d8425b9179fb629307c2f2953319e96f78eb3cb12c6a42f3bce90185cf122dd8ac905e4ae08042cc8e931ff698bd87dd00e59c6d9fa84cb3030d4d44b50ae1528bfdcb6b13e3ba4469b112097b6cea012c90f829310be6faf4f76b6e4452f9b20cd19485ffa93b58ae2afeb3ba26a24b26d99193efb2aa99143778202eaa77ea66f29d2354546764d33ee4ef13bca873ce369d56c549b24544168caa9f94498c7b4d718e0b30cf447032def57079ab9532cd06cd24aae996b63f873f4679eda5efdc242921d4f95ceaf5bd485f9e7bbf717a69a8be273277923b0165d740ddec1b5726ced2a94d1195125df4c58a8dc76e65921946cd9c8920e4eefac60f93b8cc194013f81f6e4da7ada9fee61816e4080ac76674682a04cd7948ffb142db8d4e3dcd9db79dbb000b0d1112bb80f353cc6f1f36b737aa65e28abe50f5a8d1689d0d8cdece031f639f88687fa76bb66dd99b890cd8d358e02c53b61071979f8853b5f71110e2765121d6b9e8a81e9c82bf80ce67309354be9d399827538c3219cf402b1d6fdc9c5fec08b02313056ecb2d21e4fc2a2961488e8373f19e5bbd94ca793f0147d65d049dab45186024f341ccd4d77fe90edc62eb21cd64aef94c35e738b68a23ec2c824dffa86d605e30cb00a9d4bdebec0e77391e37e8d9d1c062864318b7e46fe6208e7f2bfb10d7199ed8fca34464f91ecde8f1d6d771fc404c2e8a58e43002fa32d80d68bf8ce5cabb897faa76f58c1043edf2a7fabcf996b59447b7fc01cafdb7c0ad475b52279906102a637b3cf49a1234679f3909af93f3fb320a871cb626818a6ed4f2c5fcf4b4810948ba9dd155167d59d02a6407a3d25cb54815dec650d2546d87be442a9dc050f997eb555f2b0af1dfca2847b099a1e4a9f4bc8454fe6b820d0617c531734793f5398d8af44b73d2aa26fea70cf504eb664232213149f034c06704d5b4032603f0ccc9e88b9997a5d538cab66ee4b3f73a0f1d402ee5615ea33cd798102db3b5289d858690bd1ef87f6b2ccf180a652f56bbf4c34c3dd4d5538f5031bc11e58b15ec15f0c012630aaa4d471237a8f8c01ea51d8c4a8a83e85a30d260872a1a72e9117a657f7e3576ad4f0e86963d0bba2ca5363ef93a5625f25a034aa2adba986a807f2c954ae732a4c4013a97c477b9a7f1e00e75bbeb6a590da39e0b9367395991cd2ede9d1fef340fa118c80082dc1bec000f9e395024c8aef6fc8f4b39e3a2075d189f9dd0151c4946bfd8b703ebd75e9f4047c5675ef624439ba00863cecf5bb1ef6b850def47cdfc4dea168ef378f7728860de6df313b8b0dcd38289c54a96f9082ca5c9783078a498df4d63fa6f19d465968290dc10eea594bc48e0d8211d04273d80ff039e8a1694758d587b60ebf10a0ba21a76e01fbf84f868fc6553cb48feadb0423b35300eaa00353245bc4ff01a41968e52030f136c4389f153d8517b8fd3207290fc7a553f09804b3358c8aac4ed47aa5464bc11a3944ad1eab3a304d7f222583fadbf70b60ffdd513bf024d075c1f824408f67833d3da2986dfe9032431641c1b0bfd272ee9c88d25843d0b3244b8418ae03f22e02999d46913edd72a3faa2e54bc537575a257a2826a6733c3b35b4df2009410171528e58cef5942e7f25780d65b6753f0c553a6f1888eaac22e7946bbf4dc8853b2d451b3cbbd6e32ca22740797c05a89ffa5d77306fe83ddc8599240ec8acfd9e9913066532e263a946613067769ede36e36e0b75ce781754d67a8116ffd6b518b2029aabdb5c61ce651f9e77041f92a6dfac6d3fc203e9c7f139aa581b74f1eac8fd2de50d8d698a6c9749fd64130924a085a79dc27e6d3feea666b1e915b5b7e68133983bbf2e0a3db6070d113407300d16b46a0e2e97f38b57a7794985b93674946e62cbfa538def3090fec6ea9089f3bfa3914c069ecf260b4eb7a7c7ad66b119e62d1a6ca9af9a4616572e447c0f87411c44842536fe30b4adb92763ebc81f8e4a82785dc77f92c9b405c94b91c6f93e1a3eec6a4b0ee6d934ca6e7e2d0db24b0e77831603d5c2e452aac9d2320cd35c671a8d4af1d97b59082fc6340383bc404992c7187bdfa6097dde242ff0def94e2fe38fefbd1da9168517efd1a7ce3f63731783b9a45c817efa8fec7856221251f8e6907223a16dcb85b84381e9271adb62522f5dcb2f7484d773dacfd268caa8158c08c8e1bc603f00f4a37e8b39a5ac66c94f91513bc243be2fd4e59368ece07bddc228e5a747bdccaa6d3efec54f06261203a38218c85be7025ce81d836db270a9bbb0f0c865d9356f16f7a1114b497b01ce280f5d0cf1a37c96b4fd647bc67721c4c9593db54e8af0583d5f971b233832aa32252ab001ae07e016971c2e380fb8ae0700a301532cfabd577d18fb79fdcccc55cfd82aab9a475709f15c51cefd6327ca4a1c53567007b979227845251a5bf256b2f9fcbc20020980f40e6c62487588f36f7bb2e3695f30f985c09355cb5aabfa5c4c4197aab99057e814afe0a6a253913c8e43af9e3464511ae2921742dda495bf0799dad44bfa13b4980ae67d783f6c9fb6dd75326c17a6118191b9ea7d5b91036ab76d75659f1b4232bcdd10ad69ef0767e98afb66b165f080b6fc01a8f679262c77227b39638658796d1272a3c1fe4cee793feed6c60e1455dd1c8e03978e3e3441b46df9e7b29140681eced65c1d4cab6863dcf2eb6b984a20892f543e09caa5f28085abef6fdbde35bb89c7917358f82add7aebd93cc33932c9c307de743b62369573e68a59f063a21f28103564846e5797c85fa0d4b13de9521922ae70cb094fc5186e3ad9c0637fabae2ef5bd4892f745675141fa1117f1e7a01453e5cefd27b6391ee9a98b880e11fb329124ed3aae5959803c0341c55346868fedb5d97fd252ea4c155e2e5bb28089e08fd0c9858bb7c77675a97831551db4d669fd39ef9a10904612d1692e8cef0f3cbe2cb33ac0da8af3443ac624d35b65d0afffc260c29b1bff109024b9badb9059951dd7dbc782e934af25caafbdc17358ed939e14a232cac1f7c581baa3e6185bfa12b6bae6992181564b05d982a6d7b8c36566689596ddce3e39f058bc55212c93da165a718e02d3c56fa0eb64e7ee79fc8750056a9a9c6ffbe0e0ae818352c202b9b2dc3faea8146b4ebbd4ecc6ed6fe9881a2af8374eb474bf3c7df87713adebdf862b0f70a6c8788cdc5315e936a1801c77d1652e0d1a4d31e27f04d63720806afdbebb3c6dca991db492ee0ae5c21e39ccd7e7dd21f72ecf3a81de5e59fcbe94ef58c98b397fb8004c033e090467182a7106a91f535555e387ee37f16a9e06a1c1ac601ddc8321d95a34f15675a3361e2b81a786dfcfa0205666fb6a04964dd317f649ed9d4a74ddf45398926a04a39103d7a43bead379f866a5bdb9cd5beed9fdc4544911b7606c99da5f035b26b1634c83a54d648c13959ca808ecfd0d4a9d4cc5427cabbcb461a2a6801021fa640b0889a5ccc35347567bfabe2613c203209434287de143c5c9691d1b5afbdc1ab02cbdcaa47d1c84bf4535749328eb2087d35596a099199b2f7fa8d527423171d2296cb9abaf5b45eafdb9d0b0cf28154a3867658be2bc1e3b6bf8edd993ec659cca0b8face4741e9915629b01bb54599231895634570ca165424f102468cbbfe80d7e90fe285f6960a350bad652caf936e25e15e39e8794ba0767d60f51088a22121043267004c4996f25fa01e659351529985334beb04039cb8f0c0c6c1895415d246e4158195101cbc5bb4ae0f568c0c36a8c55fd4f45d8c36d27911fa0514c4655a50a06b4130f3a26f4a5faedce45fd484c0e397f92263748a7feee9884792732b8f9e8c4a483e7cc62d17ab80abc3e4b89a519eba4b785ae751dee3654abfe05d3afe1b2b5989f132e019c68b9a0eed59dada42ea079e818e590fbb8ec379fd349cc95c722925e84f5d31a915cfbadfc8bffdd81126c2f9e7da758b3dee73401fa386748f480470fcf33cdb0068bc3fbf54b5081e1a7a5c22442b8207babfb0da2f5f44dec83daf4cc193405455df26054ee1f7005c6ae2d9bd9470bae5114a2cac03b870ecdb7e6d44ca43304c95ea1a030090bd5eaccdc6ee9d2090a268b67a256dfcb7b06098db96c100a40e8582e3c6dfec5fa69100c31db4e0c538c14c6c268212c5d748f67fc75c13fa9d9eb42decfb1ea340c92dd9ae309c41435be873fb7d769010904c8023c77078f150ce8f97847bfa0ce460de5813977806adb1bff14f37b8a95f7a677717343c6d6e1dde107a2f1e521396fa6e02142a4afe5f45bd687689752bbb151815ace0c4e175418ffdbe33a0fb07135bffffae288c584593e7568560e37c591af5fecde7898b2b9dc58a2cb73332562b5ccf0c76db1bc61826549db23f97fb7114719efd53a79f0b04cee9d9c9ca94b8ca4d006dd7646ed27507c1053c50205eab3d132f9627cdb827f4a82d0a9e3420feec1f854ebe9d12e8ee543c839466294ac352d212e7494c1a79ad7ca52b027d63c82c07628d07e4c9139759b63b071e31be0e823d9b4e7688453311f062a2e6fc056565fa6267a72d64199af9aa903ee77432c77297a3bcf0a4cbfddc20541bbedc29c28f599fc5a4d9624eb59bef731faca2852df032644fe4f5bdadea14b01352efdaa4f1b5990adc4113364b38eaa7b272a6191b48642a70d56f665f54290aaa404a52d516ee088ef5e2559ae545aab5a7f7af3cfa1fc277759a7eb4327c1d6ec1f089c6dfd5dba6c71ff71ef1e2b31f056f486ce325004dfe96ef28f3e1dff47547c807a2f4a89887ed6647b0e46682f8d13d1e7cbbcaff7e9c5f54d3989b58456ecb10a92df5b64d209c0a194dd13419d2d5d450518a9086c67c6136e35a7ab8aa1f945ad7493c79c7900a97d8b15930400472aa700a3f3de48e2c75ac9cec5554ec01affdff5b2b3c6c6bfc521fce5f5e2b9097838d5b3c70fae597b57a23fab113efafc531229ba69c30f559c68c96bb455f0a44b986a5e6d7715eeef65d1e371663f734988f8ffcf8d0b9d3d081194a04cb1077c378b7de85ceb0d8345ad9c1801ee97a2dfa0c7ca0d4c13bf051f00b1d5fd3aa2ad93fa2df262e8716d2309b5ad47a269df0a4c922194d3be55f4731c47968420ff34f66e2db6981c6844812114f5c0717e02e4257b43c0229b3ec239a8dd6bbc1b0aa1799d124996671173a14d6679c96e6f2b74fdaa201c8bc55449be2bc954f362d7a4f970aa57b7c7d542def16d14944bb5f75095f725412fe1affd159ccf9290aed16ca95fcf750f6acba94a8048140eadeb9cbfa185b5e503df6f5a41570e181b069a98dd9aea1fe3f114741cae05c2e4c44947b08e6d6d0877bbc61093ce93a94c6f17ae397b48e0367c91263fc9622f977d8c3ce202a86ec24a17b9ed76188ca945aa415d35699af8490a1415c8892c0bdf68aa304633057b5e9e752a6188eb6fcd066905e3fa8b0b95ab0eb559eae49a39b3ed248db6044a1c42be982735a6a3f3199782523d2968aee98425672e8c313338882b5f6d5b785e0423544f69e53980ae778ccac1057089e1e3526260ee9573afd191372b698f36f711f2a4ff333fad6cf7c2206b9b906b5defab6c3b71bab5d0333f0bb4f3486e63da8d075bd4d1dafeddbe6cfbf3588a9b361228c44a2b108f3c00891acdce4fda19ca7c1622f18002b0b46e08cca2603027079cbca487e3d26b45a01d65a97d92a17073d9b6fa22dbda17ee119932126e4832829348da7063140448bc28e5db8e5e0b7612919209f5159e75fd6428fa8ddb8b65deab524492c3e2e763074a5fd88cc7b57aa7b539de894c5f3a9fac15d7e2f32668b912b3aac5fc92f6b78a577a212ea6b69ac023be32f4acb01ddf3455a06f6dc7e2e4d7f37103d50acfadbfe7e44c47d58340cd129f6c0846e52136d07b7fb87f7892a2bcc649e1d5e2fe9a41f3432a7bfb47ff6e95b25967d68c3bf67b22919d7e3796a41cd66dd520bed66c922365d6a75aff198289208ff233763f1901a06f70ac1044daa5bfda77eb523bde35c919d329e3090e21ef9e8fa6cb8a79fc3eab792384951776c5953029a7942850fa2bb4a89c05544142b0acfc5a5b8eb92736f11d1f48569b51bad247b0a2b3be0220bfe3d058917358162ce8123c33a062e8c4800756541acd32c120e272a538ab1f7f4a68e5d167d25f8f432cdb7beaf345687a6c95a5ea83baf60b7e65b9c8afdefed39cfb8c21cd369217ed01d559891e9e19aca2aafd8a8d2cab736501df3f19b5bac335e7317e18ae873a11a610e2c427fbcf50a5415ac956ecc21d872073b027c7cc9a2e7c701f4b54f39bd5efac1e32b4d088f60ff06856ae852d0b1447d7b0281ceb2a236dd79b27b3b1c41a7332f47d04b3b9fd7f0dde6fa3a866cbfb4a9058651c22fe0772402f40add98dccc0e96bd8ed225e1e49bceecefbe335399b7bd7329bc5a3dffa9eb41e8b2e20475c6726c9d0c6b93a4ff2c23b6d7d1d1905553af8180f18cf753a5e9a0d52c3f19d59c288bca808d258f645a745384f8a0ca96ea1dc5198f253179c756f5925e42124f1aa664d16d9bb1e45e97a0f22c6670989ab6387573991c23d0e93e8b4b60abe41dd67c5f11e6f2bea2922611c4bbb31dd6c6478d7cd91c5c861bf546fb1f61dabdaef6ba04c926339b4a46516d631a632989cc9672c8fd72c9cf93269f78e74599a59239e8ed62cfba91a3c87073acb0d218621b424b66198a55994938c15ec1bc2d971fd7d8d35f6ac67ba6aa56d3a9fa310c9eda8debfda3becfaebc15393c79479002642a0736610ba97285c5da051decdf507d6d337feedb34e0c729c0cf93e515887c459cd9a20d942e8cf0106bd232d3d428f20709df1019a296a0cd0648f65ccd247ba8cd30e7620f3f5bbba4693ea960c3cb32cb345cd0705ed628589825546af12cd4fa9220bab170098324d63bdaba2aedf0eaf9c8a38c4397f1f08c7edbab27a4f700a7b2d1ebd88108d2ac27130c5dcef4d0e258dbebeceb0de46dd145c3f3d95c5cad39e7660ac7e4f04a506db746e7b6d82d70496c2c787e33af73109ee885dbbbba64f8e895f8fe720a5ff4d79b98a1a3e43f5eb0625f91d24dfb15626a35be70f4d0454a9927ea0fbd57a023005d4111f758cae7647590d643ee5a81b51eaf686ba49d47ecbd5992acf4d916df878d634d3def40839335ce5014916c640317b8f17bf6763912b3ad8b4c0b1e9aa9dd59ac698a11a434e159f9361e627330d1846f1f54e1a2d1cfd1c621a8ec23dcfc6da638298d6c5c8783eb60d11fa3e37b1b3b46bfd7e292152f3bef3d1f707ce2387563385f3d7ead22c13e3f7dec01d938b14f9ac42f5abfacf724a5e713fc70f73fb502e8a051427f03ed8b9baa26bc8b5cf9781a096c0c454db23b1324322a0f8833db12f4ef222ca54d8326b0656109a2a2d2fe4604065feff175f574b0cf71eb68db5b05a9936bf02587f24aeac9487c71f2cf7fc376b36ed63e5196e126fc65a08eed7f599f7af828dbf3755ceed74abab5ba66a731f3f081dd01192773c11cfcb4a57086cc8b388b5c2d8a1b1a68e59f20d8dcc32ec5dd3a6f10aa123a611d555760ed4831f92daeb192a759d515a0ec932e8a6542cd91a2a4e1f6d902a46dcfa11c46f17952a865f52f4ec4c20d3ee27a243c9f2a90e96c93e00aff81d057b7f50f04fdbabd518474d936f06eb64f4399a25ee3667838b3b15c8667ac61050fe368c53f3db84819503a5478774b84634af15b468fce0fc325179fc103266e49746a4f22fa64d54bd3bb7fbaa32ad96a5e7c66ae89dbe91771ccb2eded24128c559a389d41cea2f7496a19cc67fbb88cf7a201adbd41743f83f14b354d0b27b4c4f7ba5160982a24685bba8bc8c471feb5ed981b39629422d54e513f2ab361d4f6dc4b6072dd48a61cd57d3fe0917cdd43cd8d107c42f14b7c4bc910589b037d0ee2d820d12de5e2ec1b7a8fa3c6444bdcd2f9908b7f99b85670a5fd0255f4342f23cee4f9b38a6937d26284f77138b1ff9bf3f02ffa45a8c796edc9edfbeb6a1d865d754b099189e05524f7b0569e60dd685734d9e70d65ed11f44a554a0c2788a1e061f0055a4b9a12883517d90916c0edd3c7474b4737cb6ef41a986fb88874b2eca006a66bfe7b5fa97e1ef1cda69c16f37f5b190396ce5b3dbbda6374ee224e84c94eb91b6aa4431694bffcc8a0a062428a01885cd77376e432cf1b34e3a52d5a3023732d708f9ba85342487fceb8965e6fea613f9af2a7a29fe739ab0baf31c35e7c8bb3b90492d2f60a728d08be0055803e1e7b719eeef09f727c4e5dcea8ece93429dd334ee1d725e43b225b6cb9ed7232751b0910396532cd4bc72b23520ea4a75798419d0088bc3d37e5429fc4db56bccb97b0d42ffae75aaac8771ae2be409a94d014e6386b8e4f049054398205269751602b78da8243ce7af8025338e2c47e1a7bda3eddc019f405c312c81a70925e061134f0b5318bb06d2b79393187a11eb13089012de2743c3e8ff2e87e0a0f434dddd75153c55b06fde490c0bac0f2a1ce8145769a5ee95f1b4fc0dc6472bf797a74feed87776bcf2d2a16f5dfd06253e655296d21b657ace486e56359f10d876b82da7ed7ecb08c54cc12ec6e41fd76ae2c5d72e816601f34aa36a587d2bdde7ca865fe040ba534ed500d80166f6589cbd2a39694d9fcd6c0272a8b1edb3bb34ce0b31b221277b4655d9bd6a66bf07a12b21bc1d2ceb63d81858d957cca16784bb4d2fa90789c0a6f0a4d8e41eaa0bbae8e5c8a77ddc1f4d8ea2b2e55faca63f421c7dc09fb806765dbd6dc4f088e46a130ca3db88c9799b6c7a94bae2ec5e9f154c50bbcec889f84ef0a719e6e3090fef5dd839aa060f5d02ce095d72ba8f0f6f852a550e8d37a5a91c602dce73e585e809befd5cf76e85ac9f7b9f49aa03212475c26c963f5c07de1cb0c123fefc60ad948777000c3013d63b004a0ec78404791b6e7706caca50ee2cad043f5cdff065a6d1d9f04077bd7c940ba4b17865a5b1b7dbacde0c7d66dbc445ab2c3333d7eeefef7623f3b806d4702c76ff036fc4edef2423f556c8d090b8dddf52f2a4ffdfd60446609542ef50e0205113ddb01f087023a37b93ebe82bf324dc6bcac046010200a9bfa8dadbd1e007d4016d31a65c9f115b5ac8c10cc434f67b4184025f75573c405a059755a8b3ae18c4fb4d0c4e1c92586534f567a545dd6ed1a6d761e2bfb737a17cb40eb74867dd2dd1dd56284eadba0f35b7a57723e1d25ea714328dd0e1775a4a5d192ede09c992e842c4faced26c9114df31cd7f77a51f1e5ccf28091b1365cf1ebf20a9a1f2db1b1fa1121393ffb963e8a2a8518f2cb599e112810f834883f1c4afba417b3709039ff8da5f2be8f5524c9ac48f9156e07d7a6a8cd482e1265b0ee880883a7cfab109ef2793cfcd0ecfc97ed375ad23f542fadc0b875d2b56386f56989e7f838ff93b0eb681b0689b846774e2d17bc69db77051515a0c8bb43a25e0c17ee11e61ee7543c421283e03117c46850eff4bdf67dff1b0d141fc223484d026d6cfab89d9bd8d2ce1491861d3a11c0e3da61a862048c832f7cdfe3d70d19b1eb679539762014c3761aa9ee8ba9c7c080ca9b2705f98df9ab24bb54ee1b4a562c896c08b5dd813465ef100704a53f0ddd0f139ecc80e8ed277201f5facda6293637923c15a7eacd1151911e22646f3b05ab5491086e0611508e9cce1c4ca20da83ee02e70ccf69544ac0c12689ab7a66a7532d141d732e28ca4a5b6f8b3684eadee76f89048f5c5cc9ccf40dce198e37d6ae227b11bc8f4134929a97f8d44579c0c64f92712cb3402180e62c2a0bbf343bfee11cac841491fcd94d50e8338c3205dab4e0029cdef29612002de1b5a73d97419665a509facd76d3799bff55ede0d6148959198199848bde9a845e478ad4161a2c41cfd13f3393462adc876473536e87573b2ac2a2a14a8ab2ad2cae6c70189f8108a9df99f3d8d44ad70cdc7e1f75102c679c2f150b56c829860557ecaee7564f07b8de5e0f371c39cfce982f46717b51cc7e85d1c5c77928829ef9886045772e933cf478de9db0d54240cf67759db166d87ab9d266c933a062f95741492f06469fe1cff232545822475f4e39e8879b87105cbd3486bc9e7f101296f285f6424bea3377d6eaddde35d981399f07ca42c90c9c31d16599e16d6d85f242c5358f1421f93506e169647ba1c535220a9b89bf9fd63102cf4f3b213f1576da8c933761daf1b9600d80ec1d70e7ae8afd40a4e21ba00a01284351b96acfb4c4003bd6a4e0e099c0f1658002005fa487b3a9467f8be60acbd85b004bb16ebd61b854156fb068b73a6ac827bfc61efd4545b0f612b7b1cbd301428424a31a51b84d6882593e9b664cb9045895bced9a7c8cd352d0c86dce0b19e44bb5ec5c975781c79bda16f80e35d69f5e59aa26c035cd08b398d57a3911bc3ad6abe1b19f3e745b5d1e30326d235993dcc0e0d6651c6c364cc71129c4b4c82307552337e9a8dac25f7519c06e5670b91c3db6cc712be027f2f1794c8494dd62d9cbfaa41345c8f67b6b5c4d5e4694d201bac8d48c5089d00f55673e14c9245c3e432d8eaa4463c3db7283b3505797fbd55f36707ef75f2d06d128bc5f65b27d238a63cc64d5bbe88996ba49cf66d71dcd0fc7fdcef2556536129d8a69be72553f2a9284864330277778897875e7ef7a5925dd82fd54b49618aade88a72f7e3fd64b93491a257162cbe9c555763054ffea78f52bce76f33672eb76bb12b98c414ba01540f7af488d6388b3006fa2684edff6739673a95901444ca3e19a4a3a736e7ed27cc7da28ff514b2f755c19d223e715eaacd9a5407b5757f3fcb5cd11a719ace9eb040f056fbaae3724d41a157c1ad163db29eac5e2a8d3e10b1ea3ddedeae9a7343009f339fe0680c9d97192bcb5b45e8ead25699e459b1817481cba92cc1d1b09a464aa4b8f6a23629fad04529a07c52c6c3f458f39ad3e100f3700a94513908d0faaba57f33819cb375cfe287db86eed3f97df8d613f479bb8784c13bba4deb5b90d22bbf20e12be84cb0bc62272cd1b31f0361b6409bd7a0e247006480d404af18fc7d488ad21b1f1f819809e731af0ee4813f8ae2f5d2851949438be1ae841a79ea62efe01f25dc6d3e00c134870c71bcb8cc3ad84fe9c1d20c1fdf4395559822f76112fc054ee463add7409e626534065b2a3f522681ef615c43ccc2eecf08f99f0c5490fcf128156e32674cb132edb814a3b5e1900ef4870702049d665b628e3d3c77d214e5aad928025e54b6d1ed4842fcaf1d7099065ca3bcf52c92c9ce8642bd8f43478f000654c81b11eb7be86d75f55f90385bfc09b61634d112f0294ff9b8657490d97d5b3599d919a16db7d251ac6b3fa70ab3482f5e0e479bc92c209a7999961c8351cb298dffd60454bd83ce90875e534be819e484fe221e93104a7259ab2a2a1108d293518c9d5eeb66d73263085bf21ffc03aaca56ee5b46e4a4f2b94613b1066861ca5a4aacca250de523e899ffab476ed54fe13ff381bda55c472fc43421a15a93fa90728369e9b7a416c9e062c66c78b55ed5b37b3baec01e29c78bd196898a886667866cffaa1cdfe4e2a7a00d57e58c9d13c8269ea7703b243a6285962a268170401d9485183352714f5122b18ed570b9f3241518bf7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
