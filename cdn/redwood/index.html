<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8c3d66811bb20e1934e1254bc3237f1101b3df7a1ddfb47842daaaa45c53e1a18a9dae4c29dfef0a650e3ec3bf879b277d194fc7899e2fae3a7ca7c3ec56b676cbce443179373c92d639d506c49958c17ca5ba209638bcfdf73f057fed1702f5975eba3752ff4ae3595cce606b87cfebf56ebfdfad74a83c3ea2221fdedd92214d256fa5f04046d7624a11079adf282d099b6cfa116cbed73fbf38f7771aa3cc1bc0881a0a5900372b6c17993423fc7ac51155ec551881aca87e3bf5b973c5536a632d378bbcdce21fb53045eefca45852f5059ffc57f2f80b5b1558eca8446a8340d6401d620f6c8168ce9dc591b80a3a84131529aff5bcf355121b40b09c743d3c7de3b8395a32d90d6e0c449f5acdc132d105f4d78345783a22990489abac24e0be724f219356e7814df5208f828bcccb0cd31a2316701b337906921e94a9d792b09f40c3009ecbb93702cec9ee05b24a4a228ff48ac2899444804c249de21df7f15e2ff87596ebcf88226254ba5f268209e8eea7f522d5f54ce6119e70b297d75d52d02460cf8e91af7b8510155257111e72b7fe183c8d56c33bcb8d8f0e3103dafffd6a55066d98eb56c93a6d55acd935930cad6e425d05c3e2d79d748c3a97f07bdff45425ad9e6c7a7d5d25f3f02f5fd030aa5264601a57f2dc898bab919f11149ee5e57aa0e3eabcefa4f266dfcb2e2f7b657535752ceb4aab5b4c2c11d73374e99a1314f6583be7aab217e9d62d6bf31e1b5200c8b2e7a9e2b0b8e1aad8863b02e3d6b8199a0b959ce47a052597704b0eb509f403e10e42986e0c9b0c489456241d187c21566c224af562b40f5404cd7a80bfda801e8db079500ce2312c133d559a699b19bfafe5bff866e8813b6e2136bb2a0fb6c425820218ca6824218c72c23b7042945e9e222f14fa1d4af230b2486a78b6712ee43573aae8cd4c5e24b1ccdb9d18b51da1cdbc08c32260a77f47f292d4745477d45f8bea68fccd18e32303d9b14566ab965ba15e346aa3fec9910234fade7119fefb04801e477e0f9467c8f9f5e185449ca345dd7005fd6b526fa9f649c8d32f1ff93f08ea6e8dd8978730163e03d16f727f3e02e9f9abb17cb79ac4a32cb72a63a43473cf3f99da18eda3122e373b0d3430a13efb35102a990a5f2bc9277ebdaaaee341fa028a342b5039ec5df156f662fe29d68572d367712e4b541e6da57185811b06522890e00714ebb2ee265aece9324af9611e94c25bd5e7388db52f18fad9b0babe1a3785869ca9b94c1b0e6292e8965503e604e223efa66bd3586b327fa9d7551cf69173f20e85583935ea52ac38cb60637412c043089f445f1d039b069bc00daf10e6cdab4fd7d292343f78e7247ba634a20796ee9684b2c157e1e38f0d07b47233b608fc539b4b6788d02e3e4a3243ec78e2c124292b4febcf7ef777f386fefc2cec95f7028ae278a1aa91a82bccaf22b01df43e33f2ffaf88d7ebff24d1c9d68abe940430c0e2ec0858cda930cad92cf151228ca800f2b6d60bd55e8853ec73c2b76dbeece6d4503f025331744641b939104e60add795a173da006bb65f124f29aa6854d0960e4051979ad4fd15c6e85b5c639ba7ad4a4b0070dda5095555ea834bfc9c99846e5a75fed06cd9f48bcfbdc123a44560cdb72c696e8eee85a733c561ff8d254fcaba01f1707cdc43e3b148d1fa73be40df2dcc54b8a55d4851a0721f237cb0165c848816151a114e010861c10ad321621efef022201b48e1ca40415dcc11fe4b5d3a4ffaa10f87c4a869093f2c5e6e80bcf02001d7a762508ac2b424c939b1f15075dde767375502cc38ae3d8935b3b7ef1eb93cc9e89000d913b8631cfe8300202d83e0c807fcb60f489042bfe30d9fb5c924712ed9f72aa124f391dccc622cc3f0b2c5ea56cc0f02a98027c93a6476793b50a9ca76d0706af0bba15bbb95afe3646b578112b0b509d49f8110d0fd43550ea89710b6724000694bfcc4fd61ffefdb81753326cb80ee0815a758593568322026f55e90459a80b344c331c6c3dbc38a0e79f796c0f0543678758360ee5af3a483043655a9bab39a5004d28245dcc227ff5b6c6904d30851b1765a00f1dfe2bcdd163fb92c43129f5e51ebf767b25a313e21eff3ebcaa90ae2a4bc56487e81ad25035ca6262013f05a3f17e5de4bcf2abfc215ceda5415af97e93d0cea75f2b656467dda39946d8d549b72fb95bec55d6216f00129915bcf2167828726e52bfd640cf287d149753e52f98554f32a084c223f26bfc5451d1f55f1569c678933ff6b6abadc3055dfd36a16cb4b1f2664a8d9dd752d8a704a062ab1d339ad6c93d383d71b9dbea1675775760267db52e4ad4813de3e420f08350cd83c9a30598ee57dfaab2974263d7ff37da0146098b08fb7dacc01634bfb0237ae2558a316b4655833f52033e0c6cc0d276059c02d8f787cfd3483ac268e203229bd10050f9aaaff504bbe45c45ccac88b94a9de23b5f68369e762a135797bf080a92bc308bc54faeaa59d6d84422d62d9a705a9a711355d94965e1cadcc7d34136aba047bb4f58c8fc51138100b8177b5eea7f778409255b9f8a4b90914f186db59f34d691ec3b7ee0389112ff26559c3cbec8267503da5b1ed4efb4e8d043225580ac5690e16fb77b651d364c342b587805229229a7ff16aa1b092b7139ab2dabaeaa403764bfe87d5b89c83e381cb4418106ab2b151e642926661b855aa491a0b32013dfaa1a9ee0827be3646551e3a170b6b700bb808311f63431e6cf8175b264992a1374685a0187003ffa5e00d2259946d19729c73911349787328c91630057f88279d6717f584a7544b6e339103116f6c98a388e22aad044242eaa556a4e5c1f7f52a09b64c2849ae04da6605bfee99f3567910bab1d28083c895fac437de76b42e2c1ce04881c9700876cab72f0b409031c7436218c821c8c960695537f49dde724c551ccf0b838e783d0e44c4524f1e040791a7516d1531404d713aefa73f315593c4081432523bcf98d3156e157b056f5f407220fe5c01fb2fdc96db59b3352b6338c7223bf22fa65fc5d77018fce0dc2e18d8baded1771569c12416331e9e356916d434bf87b389ef1a0ceeff31faa3c7aaf92779f360a3fc14b2a7ad43df3fe7cab184aba62a073ef5c4a95270ed4478347eeadbb36027046b2d7b7e2ea3a00b9d42b398d452534dc741d7863e18322d101e93dd52fefb6d47ce13e06e43e3e2afc5e2d1aaec4e9c4e8ebc400c24df5b68a9c5547885653698c97e7393e6e1278d7e1ceacbbe9b8a93ea09651f587afb2440747ff893d453902289a73d456a436ca92c4a31b4c5e90f84aff6fea262a05dedfd61ace2ada85ac1ad465d616a9556fc3d31102a019df581ed935091fbbcfb27d2118699e3ac037e1e37b4ed48523b39bd0723426dd1beab1521fa6e5a1b100f5c4ed217ec5c6f1cd0bcf49d33094357177c3eded54be57283fbd2b3345a4429c265fd22016192718b5548fbc72d274eda9c91a243147a0a6a5619dd22520c1df09b81339aadd32af5b5e5173be06d3442f185e9c38ef56e2aacee1748551cd03b143390351ecfd47bb00689169680da5a696a07ae42347887f280eee4de33e1c081baa1c58e8a5c4ca9c09a82043f6810494fc2eeaec143bb5bada265a6405921f87d5ad67adb1e127b5a468bc5661e5b1f257274dfa13b2c6194c9a89970b5d672feb1a430835672a16910b2237cfedb0ca7e97fb5b42664ee12cda3a7f5b986074d18295e65b2f0896e5f597da5e89b884b7d976b06018af37105e1532a5b48bb8304b8498a19a233096d4050e66e53b8794555d8a12e567090b7d9f9d2f9821e73ebe89dda31402c0fe42f8f2c63bd2020125874510adda96fc1433e94e1ad64a16d437d3275cfe10631ac48fab35dd09e803fe13ddacf09bfea9ed92724ec8f0abeef8a55dc849e2ab8c2d6d0f6a5e91d38f3980651ab3c5e94da327fe6f98f4250c46a6e6eac8701551ecf6b5293f32083b47b0f3da1d73b305d271363575c57fa5427d829d60b8ded07345271371fef824d2c2c19e2de55d3914a730f28a84e2c3bc6c859ef852f815824132e96dac5e8ab44e30d372b367117ad80b37a6e59b0410fbcfb094c3944b23a3dfde57ae266f40ad8fda4c51301f547890de5e953111d05d76cb859fbc2ddb7c6bfcff8cea164bab2d2cc0ca939cbda2468189eae50a12af9481ae465a1719bb0e54a3448b1600ff317b09ecfed0a25073cf5a638b54028c2fd9629f1f03fa9febb78b590d94d2c4c6eb13e4d609b1b9ff5fd383387bf2999f87c449b2db7ff2105e843088e3c4501b04762d53e8490a12ce7f0e3a96f516d3b252e0f66279638a66ba9d7facbf00b72f6b233571a04c58ea7bb1723063badb780729c8bb2d53a9e0672a22e8637a9a461cfe87b701bec397996ccbe3049067dad4baa73c76cd6ae47ca73a52572037f6becaa0775855017b3976bc1404ca88f126da7dd1ec4a2ef7cbba3e4a4f856d94116213555b856d103f7685308e27b89a21833804420cb6de6489004493b710d75774bf03b7af3ebb0713af64a2cb2bcaabea3c68e777941e93d4cb74080a19bbfaa16dfecbb541c7c6e440ce69c46b58d08b5959ce7eee6cb16899bfbe0af6d67cb1ad57786100ea28a13802a53b76c4098e8fd8a647b08fb29bf8a30ac81985385bf01d9c0052ec4d9bbe9de54a1d9f68b9c1aa2cf782c248cf45812431b2f8affca8c4d0d665850a50b383cbe9d5b72019ef11de305519e84e540df1fddb1cf70abb103e20adebf4bdd033b6e82d75780ae7db3b7ae08a17a4c8060fdfbbedee5de21b2fc0d51698ace0370214032fac5bd0b2b634d9a3f9a845fdce38875faa118b77e2c68eecd0ce32dd6388a8c9eae145058ab887a4b88e00b255dc0de4a9e007cd37e26432e96e2984a54cdda6030f55c26267bdb22d1ffa08bf238f93f794e49acd243b29d8be32912fa0763c8ecca0c95bb1e8437afcfb74d4b315e129c8a8286ce463b7c33e26eed8a6d3b023bd425dc28a1503f7b8289b3c0fb60fbed756a4cc2b84c0831cf1916588290cb25eef1762aad9990e894e3b30ee603a29b1103aa5f1ad0da6bb237fe0ee6116a5942689ae56d00e7efe41b7044890f51a807735052976d859b4b995786e705944d7f84673eab4202b9d8f894b6489b2c5253b5f31951e3453ce624a40e904d9c1b4ae093b508c4338a43d3b124e9c3232c67076ab6c063fb69dc099c7d9913cb1a7fd98cf5989723802b9c342cbc828aec6165667d0e045491a7e6e68bd514bc789612b685006a871bc2d1dd199e2332673cf6c0a07001162df75be8f7cab9f666bdef2fc77cc6fdc71b74ac04ca860fdf050cb1fa4b129ca75c72a4da962d9cbaf265a63000184d597d2ec25725ac748333277e2ba73c58e70e1491db14b34bcc477c28e4331597aac35d6e4b8666bfcc5da0c64628020e60c83d38f55bae9939df62412d3d4b86263c1105894382eac037f248dc100ea95e1abb8bfe17d84f513febd616ec180bf20c0fe7999aaed2f331cc861202ddcd9d58c5d8746891eb97a2085ab5105fab8699af6ebae747bc0be96149bd0979da288c09083811f8fa918eb849a2ac3f9a23cddad671566253ec481f56f7437ac973ca0e804e8e0c9e2c6f5b7bc4b3c8099b949bcae79898eab0354f41e0ef19176f315fefe463b52c8bfa159cb52da8cb63cb5cd08cd29860ced61b7a10d5e0064756e2094c759e664f6779352a8634f73a58a7234c393ad024ac14d702b9c37d5ea5d8b7bdd08a05cda1745f9745ca572c2da0db9944e8de6973de51b4838aa561d256f122158fd76f1ff94160637494abc5979ace1d3e75ba0df03c7955de3a9d1c45d0f67519fef9757d45bad0ada5e8ac96d15335911894e3b0a36d78fb22b8d4ad35e02cf58e987a9389a330bdba436b83de9239932a187aaf1d19a82d575501d2b025016f2d4903850e71fa6fcbc8ec6f439743abdf49c32d9274ae1a802c62d238492c87d23b74d3e60c47b4b2f27d4cbb198644d3728f8204fb57b03f8e36e4de2e03eda903c16f684b8fdaa23972067f9986c9eec4eef6921ad0697e189845211920c490546b166e868d76ddccc257430132d77ccf065a61ca6a5dabc70e5d12479dc06dc0f4b756fadb798bf18149c82efefac4d0b5a10d4c740e2197c360e7a903f0b2e75bd26995f58e0d80f3588778febf4f5ae04b5a8944edce42af94ce175b030630920ceff1ed9b5c8029ab789f2c239ac39fd1f73d33a3978b803a8a22b25612b7138ba5a178327a28cecd2907f21882e6f97635809dc6e929c3e9f3e9c25704ee237048b5df38d1b2265e0e75a3d56ec3de4fbf171e262a80790513e2a43b6840cac5bb0f327dede1cc8e186654500d42b4de1ebd751716c43f6ec7190c2836c7f5c30adfd8e274e34c36732bb9e21a87eb8d16ad76c7a37cffca8536ea269844c8028ab9301569960e602e2eec3b0ee78cdf229f8170efa9d68be80f76b72a1aecc017fc4bc8db3226801d43644d49e8a4ce871e5270b33d2140b1bd0db6a23d090300170e5c32027fef1449d74d51dd6e4ede66f070b1a0aea62ffb82ed98a833000d8fd1cdb202c5ac1f5b58e3e19a91d0e1eba8f04bbcd0f57260eb085f61bb937220215bfb4b14e28712fa06710f5b55d969a0fdb266fb400edfb95fbc4455be55ff5c8bb3f374153341ca6f6a0ffd21d247271a66b5f5d172c097c8d02c879563a93d18a6b7caaa475876079a8092ae8ad8711b44d56f96f63c447c1d61ebdaf8bfdee61eab7824d2a482e1709fbbaa14e92166555b4db3ed9f16c4613d199e860c108a94a8b3b30ef83fbd54ec6972f73a3cca53b53e27b81914317cfc634a2dc25b1a7b64abea4df4779ad6d1e2a7d56949fed02f2b3ce74ce1b0bc87af8a00f83e0a15ecdb6bee684fb56dbf316fe66378a32bd0dcd7a64d55d978b23dd4fe4f82028175df5aae3b8d345827c06dce9477ea417693869272884d5a726f99f7b31947b005429221e6e31e5485ae1dd250ff3fa45609d73a22b565e7ad958e70af34d3751219141d8ec4d5345ce41d5349f26ad7003e5cfb32218132318e1cebf35a390c5ca15ea81c2fb338bfaac63ca6c90dbd0e0dc93b88c046023223d4cd1f5d21e79eca4a58231c70ced602fbb28e0bbaf3843d40eb579022f63eb8f18786e33abe4ba43fd53007025a6eafa296420aa467ea73a7e2c7a5d8e9884f88b65bf99e7094feb20e4aefd8751099251e485da78d94828ccb691ae67f2b1c6555d04cebd226f68f089e144190c3c334825a34e84228ad757723203ed0565952ffb4953beabf20ec380bab7d36fac50daedc4532e820db3313f670fea3dfaff91275f4809b05db5fa6ee8533a1774a00139e464e3a22083ea20e1c85cc07305d282b48e4198ae221e496edf0d23f31503fc01eceb4667969cc042837fea3e5fc53ad2f2ae432fecca96db525e2d36959027deff574469c90a54a3b0cfad369e18d2cf5fcdf14883165ed38f7c10bbd575ea8b34d53bb353b79d7e9df5785bf8ac23efbf9f81f2742d2040fa0b9c2d874d553cde6fcc9079534c0bb44dab59a8d3042700a1c35c03dbe0eecbf596f064d1ba65f50005fa5951088a302b32660d177a370f9ba322235f529274e4380a77f4753849dd6464f4d8710c48677f1a22dcd5de428c8c4b8e0c8eb05866afed7829404a54cbbb5ec4d13416a5d3d4b382a2f7c2227998e4de674654e30d35b3de190bc90da7f65e9458f18ac6fa526b19e0ef9d1f3572a6403bf9092760c532484d7feb53391b2022f3c134516cafc9f92f7279710f3f5b9df7c614170682eae9e2bbacb7798c58b83cedf7a965c91d88c94c04375d67975d8e1148e63b866033dde9f6b8c69a932718764b797af9e7de40ef29afc26acd7eeb7b495333ab0ef77fcff4a9b9a9e7898948256c54d6da5f12e65b63a34c6e1c2e8eb840bb6398ad796b35e20e012209abf7d681316713dbab44d0b86edf28b16d3f953e519c9358e84ebf01c1cf452d2b620461836b412d66f5ebf758ed6da2078539ec5cce1237dbc2e8fb8a51226a227e9e4d2e4f76a44f71dd5b00a9cb21fc9967916a66d7ce9ced5e61d93c9eccaa197e4f800adfd33e790041db35d825b3796d75b155d397c0475bd63bb8efa04f2b1260b70edb908b4168ad3ef1290c87c0a2ad702f51e2bacc1f5cc1bc508677ebf5d6970c0b92137c0330076b7e42ec4172aa02071da40d506142d50d8bcafe225ccaae3358eb737e2d4f1850d1a9ac299d49de96ad95922897c9c8aee933bb2527742c7c7a7b5084e7745aec5951987266adade5ceb4d2471b4e94a1288c2e91a30f2159b758756f4aa39df89843a706ddaa1cf3ba11da077952696bb82ce1371301fa60e029c796ac5f9da2f4c8ad3424c1e49e743c34faf3761353dac572a8b3facbeaa86b4a5669efec90b0a09f84e2e7c89231eb15c4fd5cb2cf32357650ebd0d18b00fc084600aeceec9f1062afd41257501da45f0f76c87b974b6c159d9c45065489c56e1c46e992188c59694910ce27d880f5c4e99ab549388a0dd4b9aea1a437af02b7ff9776aa5be0c5ac2f67d694bbbc1eb563e95c57a64f06bceacf33d926c3d3f5d1d7e387b176ac2b210ed79218ecf9be2b5d8141338da6f4fcb518ad506773e31d0a41309ef403bf42921e22b67d027af58c17ee29d1c2dcb319d47d70939b97b113f34b2c020346c08e8d299c527523a3e19a1db29c9ffa8ff5485eeb772252024c5cc6ddd04470f05465bd1bcc87298a3aa52c09a7bf2b3703b71b929b4b50e5ad08f37d9bec3a9e7cef8199ec3c29ceb060f332c697e5c9cffa15f2becfee4b4593b02b4f4d3a1f87953576b910d9a9efbf99188cefc068c8c089410debb0d76fb29e8c2f474fddbd0cd46e311e9139bfd558898f3f04098576bbbf424449e977c773c704f3983f1fcac26b000a09ac48ce644aba49ac86f9005d046c4a6bbf65e39aa1608590006416c5d193d51ce229d9e474378246b8bf7e612c7aae43b1412e098953a90254c4f03bbbc0f63d325d48d155bfc31195c9c0fd8eb29e2d4a655550c1b50940532c13802e02272cb26250df17d5be13c0070765adaf63b9f18de0e5a22b07166a0595961d09b4080b5c25374d574b2bbeda5e1199ff2b9f8d5cf0cc285946b50fe74f4e63de8ba4522db3494ef039459c3b07a8b288e8b964fe0bc609188f9abde2f1e5ba7349348b8c4add66cc5fc7e8d54a4d17a82fd9c5883609c0c2f34dbf8b18cdb3b5efb7f3b3a08cd6b53c28cc9be0f574000c701d6e6c1f5c8b84b7a0d349263fa03a8111347b4b7a7b6d3f6128c7ffb4905e051db63bea03c69095b547903a2c04e22bbb5d387c87af99e21fa631e7ac80fcea81f19e90f748e5c431584c8c19e058915c0bd4023411ef42320ddf271d42fe72023e5316b0c0bf655ffd26dccda039d7d30c303692cbf8433123676e9ec9b193985a1b426c3fe7107d812da0d4247285083071a637008ffccff0920faf991e91e94b6aa4b59953d64eb0a40f59c6dff3d793f3f9d56e895f06cea94afe5efe5ba74ce212c881cb9933e66893e8e12e03191696a24ccafa5c79103429fbf9cb72665abc1935d84bb371c26067eeb691c976b02808adbb247fbbbe18ddfea8566ac31840741b52f1a00e9ef3f2e86fc1c6f2dedf8fe14bb4857569a6a12d6ec5ccb4351979eb106542ff769adc598687fd33a4ac523eda0f1a16f67b8f54d4613cdbef4f7784451a2e31e0a814abd6fd7a53c782389473f17f634e277a4e124a4de62c755beb06dec6325b5012e48cb4c573a65ad650e7a9a08e2d6cff31fb97c7361f567536f576e72288ea6f8c5bae756951a1654a1133a2e8f0902623f87bdf637ee0b1ab8ce818058d5476ea2896731802a7b82678a16d4bf38b86e06f8e9af664273322e437c71efa87e892f511dac75d9b6a6ac1617296c234f79567213d46dcf2931a16b2413727d4485546dcb9781f89e0f758ef84694f74273a2381208ffd27cad3efb0580984785fe1b3ebe44427cd89564bdb99ad251783200eb139ec864540852c91597178274bd585d9ef9868f8998f13d2f05be8d8889b6ea01506ea051b1eb3ff230a56629655f33eb025a7e8272790d3fe30713aa0c9cfbffa3308af083de9047e48c34180f5a228cc9e7b2ef1d98c46d9a442690af077a9dda6c71165590dcc0dbc8e261c5693c0ea16148f3f4060a172e55c77e3ea588d1da2fa9d0227fd4533692c9bf507aaae3c596b3c7e0a2d9d2c45454aa825314478e69d731f5f2fcd269b3cdbbba83acb646b05b0610dda814e1cabfab166b443d5e3702388421c5dafa7d2ac5b3b0eaa36d201834306725b78671da2d8ff10d16ce0478a2a4e6d659be210e3aaa4f5d429516c457e35fafd5f0883214f2f1a50a020923a878560a6eaddc0151ffaf7650d40de5e51474dce2e8200349072e0302939dc78f1639f773503e6746c826dcafaeb8aa6876ac29d2a71093dd45ffe3f98c1874d39d1aa13bd8ce0c025f1cd7695610bf59387bdcbf83b84cbf13d39ddafa67852576a241f8073d8b02700425944fedbda515d1c4c51c67a3d505a5d351968499d472c663f56d1764e99c9e3967aae2a6999441f1533c2dd099588bc0c6912f6524f43c4e562474b45479398df4f23b13b2890db6148e2705c9f17055ca2374503e01f41e0a76f31621613653818cfe4759b73f3d3b7a8721aa5fb615c42308d47f134563296a745ec055a8846d05474225066d7a4586cabc7acf97032f3a7b2cbb9f32ddbda9b3b2e1e6d9b3c2e8fe3b795ef69692178236f4100d3b5febf9dedab3988372350377dca888f330b523a95dab577d16f7b36d9c9e210490173073e8f046f5815bc2dc3b9dcb1302b3bedd6911adeb31a01057e37525fed54dfd1682e1763512f2c5ad82bcd0669129c1e3cea69caf25225fef47fa104a55c5bd6d8396db7b6164deb493d7f979f9f937ba87b76d39e60b8bc64fce1648c9c01fd20ca8f0c2fee488b3cebcec1c74e364c422b1e484ec69b7fccba0719f208ebf46b01deb0c8a05d3ef997c24f517f535e21897862e3de787a9673fc1426e603f18eec15e89ebe9eb281071c62e6f86f79ecca7dd27e4c8b1d0da7a5ec3d6d5f00e365c16173531df87a95e8835e028da8fcf6c17c1e720c2866bcf69555b9e5cfdaaa02630a085fe9398360808efbd441037502269c3ad2f8be65bf1a5bf37d946113586e0ef32e846ff390d5d4899455f905997fbb86af9b4ad6f67df1699a0f4cb2b0b6be1b18591e4948dcfb26e35e5a27c34915c7f0b0dc19ccd0b0b60c8200e85458f79fed6b8534896bff3a0d44196dc60945c6fb5ee40062b82bc234caca937b9dc05e88456a39b2cd48e8c33749413960e89dd495ceebc59317f19b8f166116d3ececb6d989b673eeb114cd21cf6c331296a3dfdbae8050803cac1061982680972f791b2ee64152c8079d442ea7800bea0013617764214510d039f7aa0a4a2ee373bf7ccab7541bbdd0d389e4203ca03200cee7612a37522d9b714609e37538a61c9a1a6780ff91f7bbc5ceb06069ad9efe725859cd765fc8ecea2c64624dfd108cd62983e4fb9c11791c610f500e0ecc47948773a24592eb7839efa39838f0ed6428b6caffb2e42d15d6bac7f75bfe42e84b283572e93c9b790e9992a51abb62a13154fd4fe300730efa49829b56d864f2088df11665df54081c160d60fdbc87130053c4b7041eff8a23a9726bc9592a75cb3d9b9e3a1204e87f76e6dc5bf6f4ee8a606516f7f8051dd15667bb07cc27a26bb8a1aa5401b2299d2b005fe8e5303dc6d634b6e169e1906944fe4c26d392d918f856781d2b4efb368850819c1febffa4cdb35e7cfbff1172b6f850ff1fdb1ac0f42d5aeca367df70c7607f90c7abc36dc7833fdbc391f5eaa2aee4beaafccb8cf005e32244695190c0bd65f7535689f72304b516eec679f04e71345fac623c1d26fad1de7321851bfe97a3244964834b7f08c5e67ce4963f71eef49335e3ff3c5d36d1fcdb2e4680a120dee5cd9c70e9491640188e9386862d8d978e3b4810d9c84b53418a7741cc26ac106f662e86e1bcb2d5b97c95b032eeaddcfb32e629080930fe1c7c83864ab83a1bb960ed6399848e271d7030bef1a6afe2b536b30c178ce01578af70603ab4f2d7cd40f73d20d519ef7839f724ac1874e8e3a427210179a24c02b499ff0fdee08328b09003d72b0aeae95366417f50567e5ea4547c95bf6be064802bbe6fd59470f3fe32175ffc67fd186e3710b4118f0170b17e5cea6cd7f3a0c8f6a940a47fabcce4354072d15dd64218d105623b5cf4fd0c93274a76ef0b0e0893b5f773f8e4c74194dfe5d17b2b9369c90015080f461c77fa350266f41994de7449903dcb8942e5b47dddc5d63378305c98d2f3a362ecedd6a7cb7edab9bad2c8ffdb474906819790652947257c1be261baf3a481039a88b375f317303fb0e5e40e47c8182e3049fbf55467c64c7bfa1ac469bfdf78787e7c395a26dd07b658ccf9457bcec9401d6f3d9d6b0afee69b8a451ff72730daa109f468081465c93247846c8f9842cc2c01f3bf02355745f7dd2280e8c045b9b2a751b2ba9e58974558b0b3141a96f732958a25db700cef43bf665fff6d6a71dc54482d63da19ca102caff53613a94a8cdfddde3b8753e8e073bae6163df0f784b9b263a17b4d7fc8842fad5ae9391e7f3d7773eb3241fa4a873fcdd1b7345f6001ac4715298aa11c30a2e4594fd7e28746c6da1cb552a4fe8fea5769c4c34511c1c8cb0fd21d98b4d9df2f138911c9c50f80717f12422933b2aa34cbb38fc0c41a5f3f4268e0843fe1e85883f0f1ba828a8caf723e41a0c301a5d6ff3dc74658033ced302d834cd3c151b06eb692fba6be5a35ac7b5208955d26d97e59afa7199c8ca7c4a55b25b2aefd54ac05deb3981dd913f73a197faec6415703d68bcf2493e30973ee40f77d150d31dfb00465185eee006d1387666f33027a3bf4c93d1dceb107b13bab3743fcea46c87103470ddcea27c4656f0f288a52318d33a0331580bde779c9dc982784f196d43444b050f503e46eb1e7cac08f74b834ba3ab3d2e4dfc397b6ff4b7a62c69371f51c61d7f80fcff7d879d2b6354acd03d491e92c4f0cef91b92b163b55192dc8701a0ffd30172b67f30deed2a6993807313c260f7552a4fb20f6914f3948cb891534f68458555ae2b1d7b2551a53a5952f05609f50ac8bc868952480783733fecd609d08fcaed03916b9bad8c2d2ae5aeb015e3648d7f438d61d7bd8f8060ae73adf08b6dadf089f6718e1b17b9d7020e8514ebd500e6302d2c75f7bff0d81462e45adfac973c939dd469a800a83fe6eb21ce0d1c6cc69d72360482a2271c3a92b9cbe18900f4554704d19d7ec3425396d956b9ecd794c1b409cb6481000c65a87be41224e038c238e5036ba97f4aef92ab9f218a36a1617c55b6c929a5ffefeadd7401348e29360026134c791ef0ae607ea5568deaba6498c76e1ff561c9a922f18752c5586bc28652743f0f24f2386a5fdddbd5fcf1a4e9a17378c843e77747f2b55d389c6c3f7710f8846475282751612745ce39e3f5cb79d56753d90906fe287b181de15a572ac761459399c15ffe6e59b2394b539f1c819e3e65b5045fff686bbc97e1fa19b28820102fa161cb604e05670229b2af2ce0960873a063494bff0277b9674f991210afc5fd4e654b6bfc9ad23bf8627c7b83feae846385b7dd1ebaf6ea39c23ef83c7a70b4296a2a1f174caf3a2c90053ff25cc6fd36fd2010f59b45210ede71348ca5809b98e6fd0cc5ec4317bcf1ee9cd1c37cc43b4961eaa5f9ccfbaac9dad7aa4ff58f9255b64d6bd087410e8e18e9165490609069845a6d64b1743320ccdf0e3b867b3209af7dae5bedd8f27344e7153c55b2fdbc855ab1d280849bc8c610aa04aec5f21e49d0e2815cf85cd6276ddb6be64c7a4c422281869fb12e3821c2350d816a196f7bcf2379cb3af7f02d7de1742c34cc7e6f85686278d75dfbb68a2b29d501d2923fe510dec976cf219c3bddcdec99ab3ea25df2c8a974ab8edb6d0c7eb51496f872e231ed5fe6f8534776b2e93e10ee564732c5af3fda8a042b410bd94572c23a40291dae6ec8abcfda940328fcbaf97bddc9b9fd7be9e9022e6c893174679a02f161269441cbbb9ca16e658c95589a4c3e384a053625832f6f61cf658567dc285469164f0d82cf4b1cbe07cb1c7eb0b47497cbcd96aa101460b4c68dca74d38a8213130a16f61698da2e1b14eddc11b6decab068872541a0c18654bac5f818412973083c73c2da8e2d334fe35752bb9ba69dde7f829cff61fe50611f758ab663dee255f1ae5d7096301ab40575f911ebe88624fa2219595cfb029ad291dd8ef91dd206466e7238b1ca1e37298e1a635aaa628213b02d24ae110de1d0a76f84085dde5f5e1830c4380e2d10a99698fa515c346dc63f38e267d322a3495b9f67854638d07fde5f722dc59c733c14e69555bf4adbea4e6869f0b88dbbbf3e2d678c546b5a2459253750cc135c95e4f2f88849ea3265cb4f19acb8867d1ba1bedce878a78483cb128a2abb3ef85403e08b3d16d696bcdf8ab99972cc8c2bc3eb7c0e9a7fa2a2a277e5f8cbe40c2e0c358f950fc5d7fc34920a7ff4c4d9f847179b542f873ecd1e06f36d8737efd5fc08d22e35ebcac81612a0dd79ca55a02b4e38648f26ad85d88f375ad96cddfa59106222580813afda85b4895122b5f0e21d7f8e6bbf76239808dc682ba9420a3cc59b6e93bcbc5f4aa2293339a267752cdb896a616152486ce9918a6b7e2cbcc7f3f58f4ce4b6af8185dcb0758b72bb43d93701084c08c8579b547f1a191301f62e5f7c474c3b5a3cf84f6a7b29d5875ae0e4a294204469fccb575379f8ed95854d281ae7843d00ba9d48c46eab8388b991fbd36451a9732eeb03e0da58f001e23109987b256d44cbea94875187413844f2c39489dee26c08a91b1843c55f044a77fdf114465ea91975ca0280edb9198b842fba5f62c8cdff6e17e2ef88e1e06af4b9b46c5bc4c52e7e1c2f4ee4ca28ca586fa9fb1e7415b1269c82a719edb452905e96b5b42a72fcc007ff3c242f12011904710db872b7e62b7d59208b9330d44a634e3e09b546490cdb5f05d4bbdddfbaff543b50d2287fc171a1515e74cbeeca3cd623664dbbb7c697c318fdd8ac87697bddd4a77f31073210bf56bb23c1dd70225da542bd72d1540a810172b1b86da091eb95dda5ae8d3c54407f646bb96abc79209bee0cee7168351db3765b1fc5989cb954e517a8ed1b01dccc469dd911a6f41a20c0394574916c69c602950f70d05394de72b53b823fbe803ff66cae07028c2f4ef76487b155a7b5f60dbb8a1c09f46e7e240b7a007ece993844a592e05905a2a00a055777e97d82dffa711cbf56342c99b796714a508cce13fb34041f5adbf0907d08b8394968b992892da40dd7404fe0408c4521d883f9c1b17145c27fed6589dea9f467586b48028d20ac050243e3cd1028746dafca13fe7670f8831d5066843e8b7169af3c228884345a967fbf63b93c82ef43e4e92d5fc4fffa6e68518382268e2235756c0ad0760e38ef2dae151a7cb859b404f339f45f357773daca10550989044ae9a57dcacf35bb30df9d1d16759f5cf9633a61c7c05ee8d57969cd804b87213623936ed7166959ec616466105442ee9118754d8bf445e1cb48c0798bb6d38f4b2a65975890f76e8ac05dbc42ce5a8818eb18f02b694b81e9bd4939ee09ccc961ef08988865e030b680a94d4a81b4cb2ad950f56bbb3c1a889398e3136bc29ed19ea656cfd0ada5590d65a887c72deb5126bcacd73fbb5d423c2bfe0f9112f754eb81c15bf6d39a3d3121096d1dfb3731e50669984a56f9ba6784726190f8852bcf79cff59d5771aca47ff52ac945adf95d2c3c90418f6c7647f6429e141723ea23be44e92c862a864e40ec0bc37152a4720c5e2c43c5cb47ebc1b4de053bb2b0a92ced4fa48e3ca514f20a3ea5e73e438ce88dee8a53e8321b5f1087a92fd1862cdaf300be55d07b4f71cd8f7c3449498d19e4c964e4bd369c6dcf5b83c89ea1503e119cbd5f0936fa363bc96378b06d6b4aa266d7c7f22a6611cbe64efb1cd0f9a49ec1cf8380d01643e3f5562c819f6ef6c7e35d74bbe101b65def98f94cc9975c5dd5eec0471d311c17cd29f3e767a9cc5e0e9d60c53ec10dc23c77586bad38e59e5242336d0039cd4db9c36add888cffbffb1df2ba2e890adcafd5df6af06c937df4409b736fb63fe331d48d69b8e2158463457a4ce3cda662e825b3922f0f1c5229cbde50393a1f87e65f450b1603e6cd5c7ec47daf104fb5ea7144b7301e220db67cf64f1b992310c85fa2cff4d744ae6ff2d6a334af5bd96327463f5c98c2959d6fe5c960f0d1926bdc4738c6075bc1e387fec032232bb20b7dda127fda5c1675aea5b737f7ff2ea26d2fcd91ab89a8cd5a38acb0b82359c572394b5382a21990652b870327d76107767a357c395fced5018b25d1d05ae40c1001ebc5e91341f230de3f3ff61f46011c6b20d4ca6220d0f1ff42ac328b84e1c921292920513ff426e396d217d46ca1fc536a5587357709bff192282bd1539006b461280d3b17c11255348eac0edcb87703b145d1db9223d9ffe5465c96efc30ca91d6c8dcd6034b3672041e4ca14de0d0fa42a2abcdb008305970236de00f67ade8c4917c2fe33a89d0dd522874f380f2baa0266ee94bbaab12173cdf5f930823ddcf9a4176fb10a2ea96e6e43244fd673380be2eca45fb1ae0d665e9867494ca96434271f096f1e99ce74567229a1c8e55953bc1931d9cd8dfafa630e5614aa85088fbbff1cc52eeec134683cdfca10c5401002f59d0572f75a9485392ffbbe8c587cfee8d1e1ffda4b01abd56278e539862917ac23bdb6fb01098203ba89119f55c43bac991b20119f78ed6109b34fa8e2548fd90d8fecf1d9f73e7c790cb3e8de86fa226c0a5b152cf4b5865ac27a00f8a9cddebb820175413432d48a921b4026c666cbe9ffee9e0f96a58dc3ad5117093a22e561d439ff1b8a44186dfa0abfa3bc41be3a36622f1c553c69a633716382f33c1d7aa51ce13f93ff1b54e96e6c59c3b5e30006f8b62e6848598a61b8a0b8047b51078e7f50c33a13fb17200fbd9d15bd99073c08e94dccb7e8a0413c1f2dead891a001924fef46525f91e8f6fab99635861458918f89c16bf6d0d296e0de76523ed999277fde19050650546ebef5db8a8e99aa4d3c7458d0033f22ee4b34e76edb968fa12d7f39fc3d2efb7b8fb88df541c2b9410cc0c2f027b6bf6c541142f530c59e2a755ab150839231185f340851471d8c151fcee9329fb358efa5d112baa1b690916027d1a9dc4191e6f73979a5af50f99cd4fbcd61441bb5c55f30d9263c1ef9d28f0aa193a897a2280f059d6d2cc357482d57bb935f0ddfeaa4fe3e88eea0422d64508acd45ca45788edb25fcf7c1c673ccd36eebc84a35a4c5e7a656d67eba5e07ac1a66e0d094c9dce74be18a48391ebcbc96a0cef9102b7d08161541d7d18b02c4783d3ba90a9242622fe94a80b3b5d0c4eb4cdaa72d34787482f5a8520a5fdd2a2d97e98fa5cd2493a92701434ae36155a01e1315065d61331df2c88145f411a1456ef03d34e5e2e8faf7bce748b968f3fd7d40102df07f1d76d551ab526d5d80fd2fee77f5e43822b6a9ee4afeb98fc5ed479f0f216e01d6fcb194ef120fb8c2660116cad78641c692443625f2b0be20722cfcda683beea3fd4768104a5b1a2da990e9a3f84784964c44e3df93b16fef6b852ba889b7c58e12f10e3d352ec0efbee9780ff715d244035ff39b4f03daa0a0e98bef5c21d535ab4f048bdc9ecbebe8bfb0f37c99ce2068d06c1f83a4367","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
