<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a73afc61b63d9f0800f8ae291c92338259243b2db22ec89927c823a3432ba830ef9ad2437a36e043b5ed2b3bb3915b6fdaf8706cf10c07859ff5dd1b9d6af9de32ae9c2fc686b4a6b0e9d79284085fbeec8b70b508d05c2bdf28a624b93ffa55cdf0948624abd195d6eda652d9354c8de7105ff848e719705510f27a1485a893cc50c5595a4e673c646dd61d2302282dd4a15ba58652203ed9ad1e5a31842dd853aa21c6601659dc13331c7f2d90d71d53c32dc0c45c54af2519eef6a62c2db17b6729f85be36b5d3e93fc206b67ed31f7f6dbe816f152b2fa75d4076c71ddd35a8db4704bd36876a7f375d94eacfcffd4d6444363ef7b73578ba755b51cf91f507b913ca8c6ac22999e087cd0d36e18026961739e9ccf3caca12504199687d20d9366494140f76edf64cb0c42528ce4194cb0659b39ea5df2b4cfa9301d1b59349bf465b8333417eabd8f50eb511e684fe83b4f40fd3c23a53abd345fc2037261854b73aaee702340691c98a750691c85df50b416a19ebdefe1dd8d510db778ed2fad708c04abd6cf6f09cfc4a672968983d4db082c6c9a0363d563393f273a5318b63ef320267d8e194162cd6028c611b61436d62a3058ad14f97f6d2f5dc2c0c00b7a719c3941b2e77a7acba52ed014aa306b2718653d001748f92e7d2d9d2d7b025458e32d3d59206c14e4076b2007e4bc59d188b9bc8c61686771718a362f8bd2b6f931cc8052b90e762feb8a013e75b71344e5b3bbc82704603b2480ffde9d161e725138d965a6b80d58e2ac67ee97c4f832ca96f65a8c7ac1b14c86374a4af21d2f98694b9e56f3c21ce6f46f44f67c00baea246f5f1c315705d0effd68aeeb51d27e719ab74842a5525174573cb6b766ea741bf358f679a992d5b3a974742c10458c2b1c573d1f17f706400b3a75a62f613c9f67b4ed1e687eeaaa2898aaf6525b14bb370a3af4c8983bb5ebf482d9bbf24fac741cc7c021911e43ae03c6bbe4516e7ed975231b2112a3f687e132c0bd568f00d299e76cd9a59d6e5838a6843a82fc798b56815729719a972b539ff196ab67dffaac4970e65b96615a2d6d399cc2ea670dbb3ab2ef4870fa76cc430ddd3e75b06ea5dadc9066ddba5ead4dd6edae358b03f5f0435c72bcfc14cfc0cba720b612a9611c920db369b5db81988bbb8e5c28f28cac84d185c7c1d372c386ddc1d7cc716a095499dceeb31b264b29ece2bbdd28510204883ce9381ae3de9f219a478433b9f8ba43b6667771a96c31eec847019a7268094234cdd3a946d0b272eb4e23c5f7fb79421f70966a2ba591c3e018824bbba04461f8161499b2380d8bb126fc3a639cbd1b994c43aec49314fe1df05d1467cb7d380efb209eb5c453c0e24094e46111027f700c8e4fcf158843cb2565527eab4bd8dd11037f6ad6442c4975179f8d4c7e761887cf675b87a83f99ef1bfa986af06c45a0085b30e74d8259fc6b68f67d99ec42d1f7bf1a3a6981ce92b2582d48b7d3e54aa9712a06733d740d0f8cefb95b4ea6c072c2f9a8f336bd87018a0fad7514b93280258694fa2bbd58a798f3a437156e4d5a1512c9be0ddad8d3f774173dbe61707c56ed7fa3aa5408c3fc12232715927efbcd3cc44ebc9dae58d18304da49dc5cc7a03a68054481c0c927926e3b54fbaefe5046784de1a966ef17b42e399fb3aced9b701d8d17d5d40437e888d1023b2d51205b4c1a2d0a340328df0e3f1b0b67a76d6d1d678763b46e40ef17fca188c712331e52df09791c786742ec4ff0e639a91c5dc99d8f3ce74b391bbe90dc13938b8541eea395cd970bb12a98f26a9c9e81e9179c191c2204b9d01a58f558c995c92a982c4940389f1f47aeecbe2d47f950eaba899390c16f83a1e746eba249fa1998d3be361578ad75a204a98f8cb69295b4ac53f2ec32ec4450f5899f57feff2da8c7655c0d5cd7447fd7b1c9d7c96093406901d49f6fd0d4be48a2cdccf27973866a15693f2167dd9a376ce909d4c3d9f058a2a360b257760d8aa855a309dc15fd57d65b123d46762a296849d8b56ffd6db9ca3d12c351d1477a8f3ec2dab1b9ee647310b4b202458adb34163e8d7ea91434814f77f4e3e35926a9d688eacae128c66bf3eebf097f20bfef7f1ad618105e1998845c82a78e7cd99391d4a28930c3bc30407bd9b4cb048ef613778cb955409e8aa3dc1f1403e3a4b6a58787ab316cb0c6e219be93ea21fc948aa90ec81597fd208645fc9ff96afb6b73e2d9c1a46ce62dcc6a143db57a1387d5d317e193f2c95e1ec83ef24ea35e4c05b5a29ad221b338428bf3684a7ea450da1e5c40c86e603d54d991f2badc0b033c07cfaa8db08d5ce6037256dfedf177f3246350a56ea36515dddae8ed09bdbf257ea73b21ed011546483dd89afb0f499cff0cdb4b85d2f05fa41030a816f9f92825cac81aa327d1841c1517260953fb21ec8b9473427d134831a750035c9c0878830a58c87ff14bb9d4d0c9df95d5a68332e0dae4e9474a353ca32b02ed92d6820a0baf3f4a4b6625ed0aed7d694b6796e46ddeb37d160ca30f532ef75980e6badc55ebe11f70517d22b2eb5a46c76c2b656f4e7e452420453d07cb7eaa843568ee35de22ee08722dac3523ce311e1c2b447891f8a4b125015319258ec38a9bd46ef348e20a628832b5a0d4c37d25db6a15bc31e82b53abe50a5b2a0592b06658306418b4fa94a9f7c5910f735080b0e5faef0afcc0e91abfdaae6525eca5609c8f5520f042a2068dd49e80f3d002b6899e92b554e7a38d6616a4396339c98eae9d3c1b76ca6b37cc503cd3df6f1597d2ea617635193bfeca6b25b2f4453f221524f0cf2d8ade20b550734a5467b6e89dd7f0796f3e811153f30059675d670dbbe055617157940a8bc26d0648d7a4983b4b6f88f5017df144af9d5f0d1810a6b17de6a3205d7c9d26cad52346b48bf80cdf6bfcfa17805eeb7f316e6a7171385b3f6c3cbface8670041da1c93f060f7a6af529b7d2541c67c800fc31f277654d4293ff1fba2bdc21d1990f1683495f5c2f0cac465e84ad151600a5711db4ff33e756892eccd12b332686a71aacc8e77d623332d657d4d804dc39c919cd58bb5c37d7de1df64caf8a55af1c2058469fa67870db7328744a3353f52753de49af6d5e59ae310dfe2446cd8623b28627f7bc11749db9398120995be1cbc11bae401cab0c1978a1bb71027d91b37a1a8339785a248102dbc3a9ef80c057fe9b65f764ce3cca3b7693944ac37a40b6c242c7a8a846dcaab852b2625ff085348b307e01f98b3953bc6a117dd345abafd63488bcc3717540b57168103adcfe56e8aba4c292eddc0e3a69a926c7a74f8875d1c358a515a701eb33cdcaf47ca7fc8a4c7256f6d13c32c040b0827eca8b72cea242f18bdaaf29773ca63bcbed9756c0d00406b3ca56437b676b2412728204647603e025386be144cc169d6a6527040c3651f49bbc1c3c97fd62067c410d7b6f8a6080cb9d41b8e653c07a1f953b3d805437290c674ad01281cd0f5a785f2a4a3dc64807327bff0d9748add12de144eb81c462fd0f0882494dd0dd704f74dc27fce357c0fe6281d5fa7098ee417fe572f58fee3da15eae4af5f1edd8e841403535628eb2bb7be276512f6dcf50ef9622ba4cff0440b5d48ea25678eb5626b5dbaff87a5b23e2b77f6667f691cbfc91eb693399e56df9f596129a3a42ebc08ab23cb1c6e3bf8d0967841ba8ef4359b8f771859bd7e17b571183600da54645a918c028ad73700077f4c232f66ece4a1678fc71d24fe716c0298d27aa4b00354fb26bb5b6dc3557be17ca05ee381542afb36aee0a6ca0ad3df21b0e6207eb3955cd743983942270071d532069bfcf0df15fb651fa13502515325771d37003b2c7fdc708cfb8e9dcfaddc93c2399601d32b06228d18e41860c681a8eecbc9e5c918110e532dc0cd9b9be2b31b2d0da9bd71a0e787c294c123574b43e8c17725c45d0c7ee9295118d264cb7db3acbec26a5d9b7833fe70a7913eadfefa7d551691b5a259feb87b35d42cfcc775be700911209cb6df3687d6bb642a763e0de7ca93db7806c209b4d784d50ddf6643b739baade6f7f1d770e8100b50374f1446981990aa58de34ff3361cb05dc6428043c623e61a5430fc16f0198e8db994aa078a0895c659897a750042ce04079f35a9c84ccb6359f2c94de707a8173a09c55dd986f32d9efc08b55c84d3311ddb267de92b2f269a146e719efcf451da614097db0d016cf9bdcbfc47d93b80a5a7fe648bdb40cbe521f5a46a4b611ce2131e37c14107a07e3cc83440524e2453ce92b793c6c5995ef52499fde3aa60087b739c73c305c9e942a7d62662daef888e1afd09cb6c4495d5ddfa7d3a8560e680512a6533612d3f1e4bb2fb4dfe8edd3113b34b6f27ceb52fe0d7f8b82928afda7ce239a434c9ecd9bcb5bc4f7f29bb622b54f09178a11c4b0813a4d056b2b70294c45c00b048fdb0a9963ff311be35b221fe2fe82cd67a0e59be833c3e69a136dd4cdf3dad11fc3d16d56e98a8d9c7102ec57b1c47c274485a53a0cae2659c4e602acd153ca1f3ea5ac6005f2e1c857c37bcd13d28b6f07e37aee723c96254f28392df9e691d7ea348ce5222a17b5fe3216bbb9d653588f9c411853cc18bf89d860069deab476111846e0704b105e35966f230663967e8006c3326233799ab1512c498b8f3724280c73bee5fbd7a2f1d496bdba09c72d5f14936286a31cd5d465d514945418fb1cddc7456534be8fc3640a2b2e9afdb049957187d113a804f57b464feb21e71957a8b27772648d185927bfa56f37a9c6bad4889172acde76dfa55e9cfe924711360734651565b2fe13264c939a8f8672624fc73c079168fa6925f50a57d1a2259f5c9e4c31552e0cfc6d9cf53f54c612953941b3e5c723359af57a44e894a794355ae7a8bade43654433e55c848df269bccd7e6f6b71c9388320aa93b8cc6173849831db43f42b620dc26b5fbda71b03128c592c674bba607849d411912261d4d635d61fc76f2c41ed22b76ed9990a8db2b6fd5aaa619d20e08e77c216ca1b1b52886805a6943a20e183a4f9afe59a9ef9317e8d490410a1e0794e9d3ce662c0d0a0f1a576828ef18d699487f1cca46dea44ec967abe94006b93700ca83aa7cbca7aef20d2a651cc4d07304b992117564505015f8c4271f18133054807a75dcd2b40b9bc9e73f296f2e7dfaf79eeb5342276f6df70b70952b88f57241e46598853bea087d813eec386760ff7bf7f55bd9012afc1649f488d7328a62eecb727d0f27053feedbfe3fb30f60a9a199291980c32b148d49b00c070ab70f108aa7550bc5901218fb86ddb4178ecb7a584f0e21c0afd9ecd8fdb31c915d21da80e300955a2bfe5447f256ee84b406d6d08a4c96a0adbb969d6ef9f8ebafd5e7aef447f27dfe62e9d13b6dcd082944cf24a4f8557fe98da8749c323fcdee143389af927e93fea1af2ec368199e6f4bcd61e4a149017e4f456545ca274fea5f14ca6e407c32e0174978322294dabbaa54272eec6cc05de3275dae17b46b47ce9c7823cfda29ec6b60c24b872220de08832f6056b786294efa3c8938b1221ea4a49de5ae81bf9e23bc6c597576b364940ca1fe5621c32eefa9c9724fb1bc663fdf47ecb30487fffdd4f7705c8c1ffeb06ba96ead6a9d3ca71bbd98972506fad044b6e184e05ca7f230ba79cf15912e8ff701aa5400b2a1e2b52ba5881396ddea55a09bdb0da494da7838b3729e72fcd89e75625b2314facfeb3c38c36bf26c29fbd895990575069f90f565e67e3742d0180f35ab004e642dee0e1304273011e314b4b14ac6d84658a8ecec089c009092929b4d83da8a8aa6a6d1cf0d4fe12a0aeebc55b34da5e68a048c2fcbd26711c118be63c15a7321fec082ad681dcc879ff866fa3a6aa8753f239072d24a606b4e38a4faec05f89ab7d7e169c3ae73e53509b80f0a090210f997f7d0060b0ce7898b9e0bd9a937ea88e4f8cfc1d21205cccae58ae40035f055a09168b27c2ae66a4aeb41d3bbc6d2cfbd6b1e0642e26fd5b0ca9d890ffe77e73f79aaa47e7246f18be75d538cb711a55c07b57973c39a5f93ecdb053e064808bbe5733d4b512e0c2b20af2a03ca9cda78691071ab9e6829f5c643af628dd02d38e550af67629fe4276068865286f623d5e3ce8bb6e73f0e3d78f8e58ad11b37bec3e418be8d4a9264cbce8702e0beacae758b08d7770380d2f32ac6dfba1e95ce76c3ae82607091de7d7e17dc06aa8b24bc89389abb5dbc00fdb51a378ce62e233bf91804507adbd9f21f27528c02c46aaa27fb06164b77d061565fe0d82cbc920611552ab511ca10f7f99007c4d5671f3c53790250f284e97dd99535097f79dcba05b21a349c730f496b07f403b1f6cd739aa798b794d20391a6d97926dc6bd118992a0d1c9f559beaaded211a68b4fe943b1b7ceff3edfd6997c031dc44358e159bcee207c3090dbe96236f19a01886be801c86640e9d2e4d91f245c4a16a96f2384422cf3eebd50c7b1b2a0a62a2c3f27b62d8e5921a3444d38fe00a947c150a191ac7bec9054ad67d68d2affb043f08362c7a365a591cf8a9dd0deed44e78a68bdb51903714796dd6b45a401b6967f3b6ea194b16389e77e5a257eda03b7af5a210ee4a015e793a0f35bd7e8211fa47fd7369bef7ee3d04cf9c997996de71e8e7af38f0079fe9617946f7322ebeb7fc48d8482e1b093fbcb5933d923a05a809fbbb0a91265fb9411211d984984c0ce7c0b49f37049f8a4672bb475c33edd4e2995dbcb26a79c9f9a6da5c9e9b035add7accae3bcff723371c0e2686a7bd1c988de71826e88a4746ae3aa896e0a42e8f4e984a70828be303dff0effbcd1227d9d7db6f0422f191ef6649977cf946cc6988725f48e3e4e94caa5944e0f92be1038f323ce51bd6bec2d08cf479517d0ef7680561a0010ed0404ebcfe59ebd3d62b052fc070033312759582f6a97a579b506418a32a22264de5750d6311340d21e8a3843823de57c9cf7485224d48eac48f16f713f99dbc4692a8b06d2625a24cc178f27e4e618455206176a206d9c82645e519261e852e4b6ee246e78dda24e322823fbb3c230613e8b649d2f9a7128f29d1deddd01ca0ebed2cda43ee44b96973d0525f81baaaf26094ff4fd51f0f86669d92a75f8f3fce01bf72ff9376ca1173ce4b6e1e594c1bbe4c63b855f8d25341235ad57ca9cd2e24c9ea4de809784be2204568a4b2b4add180e8f45481b7de13ba58330512543a513af533c7bc5887391df000b71753187b5c09ab7e48f4674adacd46525df67b3771d08f68a6f76582c87348fb3dd6c28070ab585a4e9d90ff20d4bca702fc1f8dc72ccf717127bf0688bb8a4780b46c129fb2057c0a9067841d254c0cbe6854fda67208e7e97c48798d9d3416e90808c12505084f89b6234cd453368ce36182b0160c0e00ab769b4d43e919c16445c4d08ea1c19b6e3a419d3bbbcb6a1159bcf9685a9314a257fbab08e343530cf8f53acfd01d26d7285f245f32761f93902ecdf12a6bfeb30f710aa19a7746d733c51d40a19ae7f805d72e853d749c1cb2c5baceba9300368aad5f0624f08eccd874b791aacf15c5b00f3defda5be2563575103d98273daa7e61458c87bb5e5821b2b1b532ae28a216bd9dea0d62f791a5199da33deb2598199d1f867bf0a47e06c6a2c32323abfea66057d05723c081c438a4500a9013145a1bc690a7ec24d3d3f3fa248b18a087bbfef6b34b45aa36a6bd9cf1c014aea3baa16367fba72da5ad051a56e98e60e9354edbba8423eb51a56d868f701214f6df048ebe88869b9830b7767c089a22ab109e3eaefbed151c56cd55f664e4dedbc6675058152d352f0c1e1fc0c3fac7e5ae7914d2bb32afd6b7b36d377919da79a11e9cde690414544e8e3aa21787b485a65ddf41c7e3ed7cc90b5de69415a68789bddbc183586500fc972574531e40484d4ef71eb0b3104c0c2c372658a1865ae0680dbc035320e0bf9c055f501542c4dc57d5ef0065d39e33a9c72cb6cbf68317c31109041980b7f62c2d38a3d3b5cdb1adcf41b10208e735ba8cd38443c2cbb3a55d2645527c3ac5299ee17d131c95648d4ce75d907eb5cc78570148cb8cf58f5c8e7b358f4507dba57f9e13493b20c53f7c78605979fc19295a53505e9915ed8848a9513f9e9ab62e95fac71f6d0d79c49efc2fd90732a13ab7e897316354f51fb0845304e95a3ea24e377fd8d09f0d91787ebd90e68426c5f8c726d787053bdd9137ae8685d68b7a925a48e954ecd7be57543a237c3b8558f91677d7f86b14f2a4045571f6234a6544a575a9dfdf1a72a294a6b05a13af707e68fc89e711681061fc63ee44356adf68c7000e323e107ee28a7d2637a6be178affedc9ea9dc417379b937f4017577f6cc038f801b2e1a45c35d3c4e935b118ead77c59f2545ad5c8e2a410d8275eeb8bb5f140fc03ee4366a5adbe26ff9a5092dd3867a0f5886ad338cc36a6fc67612077663899ed7951eade916f0fc0eeaaabd7db755b4a66756d64aa1f05accfbc18add7ee85965dc66e21db4676937ec3def4a3660fdb84fd1cc17d106be1df7a54c683bb21e1998f254b0688b4b3e8bdccfb83420d84d33b7d87a18fb3805e4b23f30b3825df7b4eba8c7896923342e66e318d5bb54038145dae68e335728091f2778653db7d231fa36064eefe994a15f66981b0a26eb78212602b9b3c519dbec04aa33693c2e4a34cf661b222be45d30de2bd241724bf2cc133be5c9e718c9fb30c779b7fad5b728edbc1dd6b2721f1e76f8461308c1024aa7f035df38a805390b90afc36c42fe9cb4233bf6e9664f0266c70fa5f73ce15f82ced226b3c67ad70372a0cbfa83a42f44bba9a9e05ad0de409690e47d4cc46afef1df106c6b8f5150432284c39fc519128080a4c14f61b9cccde5294208d92d7ca59812b9a6c898cdffcbe039e29a3e8af3e4b3a78b3bdd500717b46c08295924a08c323a9eda2bc483030900f5fb1254b5c6f4e21b51661369d4357360c6b1fe46d16617f7e43863296989831e4905c6cc44a79bc54348ea680d0ef5764d513540d103e6e341282a041f7955cd67d6dbb3159e90c5ca504fd93063728a2bfa09dccbf4e8537b20809671206dc32850e31c9f7171130d4245d65efa0b91747d8304622a9afc1b243993f18aa0f3e105acab4ec85abd0f220530d4722daea08eddf7f02dff61d5be1e6cf1952c63ad8d7eb8649f82d341898cae4c27b12d40cc014543b62cecbf79e50096a46989bc5fe862df313904caf8ad36990ba37c334ef24afe99ea1e8e000e6c0c00245d5c866f673e15d0158942f7efb0afa6b4605c7a4a1131b096a9d0cb423f761568c5da8638c619671afa5dd460351bb0ea47fd53c8f15e2beeccdc146c9541e80aa6f405fe31f581b1673074346818ef5c0947305ce53036cc22f3743a04c99adff239c15038e8dce4a9ba4b7dd48e8f5f6b6c4dd1ae6be9c4fdb523724275321d7dc9c8ba80524ed4c26e8dba3d2d5c8c11265cd4697c823e32d434e7c28ce5fa8be8ee3acb6370c3e921906feeefa1c6f901ddfec37ae43b905d94bd25c458d42d193b11635653bdfd338ce3f715f602e8b2b13631e880f33f209023930b3cd896c9949cf1de44d1977735eae583a03cb0985ea2d82bfa1f7434a14a4a1f78eabeb781e51b0840b35e1d50fe03621763b9a85e389a269fb015a3a75f77de91f29f1ad1c190a5ab738bb886b89db3787bb9f15c2f12adb61e082cbe85b09be6cea7bdb9255b2cd6341e62899c2c71c32b154f04a4e213bde0eeacc0840fe2c49e992e24634486094462e8aca9e727b7e334ea101a627a8a6e01349bcec731c498d4af93d92a190ad3dbf507e89490c7ea8f777f5928ee4fe867af073fbbc73cdba7031c4180e77562f00e51add7f699b081d44cd6f4762141311750ccfe0131124e1a9bd4cfd7a5c1ef48f6e7a11c159bbd43ec8946c6996c5ba1bb59df562f7b6e2bbca6b57630d1bf8c6495a740cc9c6a1f1a16913cdc801619db19553c8c8c54a9f10e93ae6edcf6c080e0e6074786e3dd51c35250a5cee68d341da77ba9ec6e019cd445e2cdd963e631280773b6d04850e37410a45a27fc82fc7056b2aa5f1e309c8a957409d5e02d1942183fc46d11cc791ee52e62d30a1751cfb464dd12928a6a785304ee49dcc7e8058dbbd854914132b3a44fbf618f553adcf5924f98d5a2ab39a62f69a70b80d3595ac906a34a27391dcfa0c353ffcdba300b55982922e47072d8dbe11f33cb40c3057d4df279c7ae768fc8bfef768a0fb6d0cbf2af83f8e772e520edaaadd7908dc9fa86607e0c9c9d00c6f7f84a8ad19b99565a247eec76c8e255b99d41d77433893031993caf0b2495460e6960fe59639a887f4e7cfd085d23005677c1c11f392d659f15eab85d74a7f66f796d5720ec7eeee2e4992420a0adab53ee75c14a53337660bbed5210712836bab5cbf82921aa2608a7fa89846699b34cfc8f36fbb968ebe8ccfa1e08ef7ed6cef044561da8a214096c666a0865d27f95e7e64ac4347e60549d663d012c8467828d45c3cf8dccfeb1990b0cc3fcb792d0dca32f09c7c26435d048bf1d41750545bf529cf19bd62bf71ccf28a32bb23fc30793c42071eb31bd14b89c58408248e0508e425e2a5e7bad9a1ef467d6f97e4638235690af314153b6aaf8184d636cc168bb1886adbff469bc8b02490d82510192eb9c275c4a7bfb229c72ed0db6b8311beef152a51bb3fc65949f3a0d247b57860e7b6ac100506726d884a1ba463ea0f4b345571619db2da14ef74abc0182fd46a569f5509ba1e13f7c5fd50e7c3495c9edc16947f4e596aa27f8a7bfad0aeaf54ca2fae2dfd6d0f282f5daf24377da44c25a2e61cfbc4e82a74c5b6ccfbe6c98a9e546e4dcc4a7accdb4479df4219cd5ccb20c76c6604231e1789d18e102d0494f9597ef2edc9f1286703b40c00d4b8948560f32973d6c27e1d1577dc11ffc829cd0e737b14f3f9c87e9559944c368a3cac53a9cabbaf94e4220c0695f5d4d87727912b7011292bc78f347790f90452ee137a7531486d67f6a4cd3353087e0d4d9358a0e72da884eb1b9a7c073e20c56ca4937bf0978e00820c80dca37c2c27e51419cba979bf7b78215f9bb4ed689d869513d3dc03eaae5c3c58ae909d851cfb47b87d083303996917b71bb4a2f3fe9aa73f28d3547bc8af5269372de10546cf7a25bc7307eb8cb48002bba7adf8c690c8e72de28d7b06f5ea3a54cb1dca5d484b3ab8c52f3423094edcc5766611c7745cdf2d7f8717baa3bda38f7b4d925801ed5984e6f81395114523d7838c999815d03fa7bdc79e044eb76ff151bc770ee7d6096267dc62cb14b87bb8f4d8708e0b13072b30db1de9c934ecdd60f5dd873280276f0020448f5c0daa3298ec6ff8af49a294918c66de5d58872441b4714881c66f77c52ab21dc99b73d4be5dd373c520b28f74dd25315a75606a19cc110da87e2e7d31f05102231954f4dd24d67da419cb3f6cfdf483186fa52c13bff21e938f594d82ede721dfaa171743b4e1cc88171b8d7af48511abdf12dce88f6da4ca1a2e78cdf6563ecef944bfeade5f5f6ff2431384a33fa78efa59d157151205863dcfd6e39eb45a3d499418a3132559da8dac6325e584aaa91b7cecbce5e53e0d565f060ade74ee2984a1b6c675c011c10f17b01e5097b0370147358fc25d7b5fa32d028eb703b80be469ebeb616a445adbafc3d7c9632a54429eba3f0b1acbd45d6086e3e1d5ff0c4a0b84ba2c7eb15c2ac767ada1068d7969d1778d2c1b51aa634f85257ea608428c95a5a043c4ac2a7160c9d628213b2ce6256a350dc88382879f5fd9686e9f1272ff2d14d0e65fd0e744bde1aa3c4ada80ad6b9699f23c8a0e46353afc2b4b99179dc9d68a9bb6bca4ac02e341f281179431695a8ebd460dded2f07f11a4b630739f2826695682779e1aa34a3fd95363386b92fdfd8cb725d6faa5011017c52a1dd4837234ed437a0e294eedc01f1631b0bb0a1a5bad0ef76780515dbbca44ff0b5bb36e4d61cad205ad1732aa7929b36e910f123c44fda8a12d8ab6b900d118e4f67a6f1c594384680aa935df13b0cf99aabd6a7cf2a92f5946525a667db2eb9e79fa888d383fbfbbb9877153d74fe36cd7bb2e8dc9ca69579e3509abf47c3738d93f0e56872a2586947f3b09e2f46c3abe02beb2c6a32c8d67ec391270fa6966242b9bf367dd1726d077fb9883a530215f5d03961e0a5ce30f81076601be5fe604eb1582f0917995bcef74d21fd0ff356e107ba9823858ab87f7f2c5dbf356693e5409fa58d8d3b5803d6e7116ca4ff7181b5e3aa484e8bbbc72823b245aa0a4dd769796aa4d4c6883bf2124259db4ae5e458436e0a53a0c144c102b06aaced22b6a5ba87d6dd0222aa1cd81636c6b27717cc0369e7c87c7360b38cde67494bc7d01fae64c1b702d57decfa9520e9c7bbe456b6939dac74cb1c327659c01ab8311e357232f91450f93897e4c50739221b6742e4870579e6f0fd27073408a586c0c40c0f13ca630b8c5cbdb19fded076caf8f4d565ea67d01823208923698fba3181886a1edb80d1960ef4e9800b7f18c763999c87600bc909ca04e45972c8b60cde38e67b3a8b6cef32db2e9acf91ab36ec15d94b3650998428b3ddbef769c3725572d509fcd1f020b4c2a7cfcdc2a27304ae040819c4ddcd1215b957072b871af467aa72c04b5e1495214ddbba58795d854e5ce7a7e79236b58e66ca04bbb833388a94489162a4847924d6effbb18c9699468eafa3ff474844824ad03ba93ae5b4afbba13018079c05c72bfc1ef2af6012aedcc72468a7f841d8e0a4fdc48a1c382f6df02aba2049337b6321c91f59558a78d0aa4f69f127d930df5635688ea90431035c63b6338ae8da699b6c532e906232c09650045ee4f142bf1caf7a0b520fc42f3efa5c811c77f547e7848e5c9e15ec3a44725aede6da5d4fadd3ac3f129a0fb747e86ffbacca5bd07643e2ab6812ad75c1ee01c2cc1e9a9cea4050cdca76ac8e796b9cb3374963a4ff9376881152b592f89e09174286f676184777ec41c8508ec381f8a7593c704a9f2c4847f4efc9722efd08ef450a99cf38364bcdeaa6a193b6f11d01717ac80cbff61a219e3a648b83a91945766fe41223d930039e39b0842e4a56e589c8e837d06a3ac1b635f614161628ec1430f59e0e7b92be97f4f548509e5bd091e26e8f8e4c3bf0faf76274913578c05ce22372b9d2a46191e55062e4a4f40e870265ef2358e8320e3b6f8d32a3ffcf77ba1fafc50b29faf27a07846c2ddc3c52c493c1f306ede81ad567a2df62aa3b7669c681d1254b3be6ebffd64041b222cb6157df41d10aae4974e8cd3c1f28ccab61c38235c681fa329332d2a5f74d45351e575838953bef75f8475e653fb16691c90b6ae250d10d438d5f2a4f6f006172bd0aef362354990d0fb65e89fd75fb60355eb5f63eead7418a8753800b735cf6d207986c017abc59169fa2049e90e775f903b5a6c1351c42ea4e134938f0195a9b82659dd70ccf5409d9b4bdd87d58e522fc962df99cf5c01c5d19501ae94f8bd28336a44571a95febba2dde24535b40806d715e5e3ab4b32fa4a2616020424e1ffb621d663971c6049fb8276e778af836044d6c6af4dcafbad36ad8b26102a4bd3c21d5d23f8a5991fffcc1462f5f36f4f2e404d4ecfb3a79fa4984e2d106b1f5063dd440c1e91027a9cacfa2dc22669b85916b0ab62c7647e369e3a1910c4338ca466ba7873eb664cd0dc0e02243da9c67bedbe035bb6fcf36fdf208d135c0f8e31a7db00d555f012ae480f1eee22e95c5c0828b02cda9aba2deb66347e009189d83da5629adee54ea93ae2c94139a9d3fc67b334028644512799f193998662aa19240d387297da201133f5bf6b2edda8263b0c2db1f111519aa8be99316d708eb20d26f736286f805a7299d072de84d3c012e0aaaecb6ea298263f8bf69abd473297ef5d99c447888b89f2d99c838aa82dd6a894e9914e07bd38569461bc6aeb553dd184cfde9edcbe91643fb488fbdd4d62d652561cf8868f5120e1dd095fd6a083661bb711da49e042fb62c5566fe702afd2a73a9ca957b04da82080f91cbb89cecc32015b9fb2c965ec2071b4bef13788f96e8971ca089d27c11d383a697184af3f6300f0169caeb8c2dbf4e5395335c484996b38354ebd1a2cd501dfc08b973bfae2dffbe5fc57d7ba55d171d600a96cb8989d2bd71aa3da528e034bfb9924d2502eaaee16426901adf9de8187c7decd8f5221135c58d60e65241bd1aba2dc7493981222a467487ed878c1766d334f27ce8bf63dd63c757a5d57c5923e23c5b98b317525828eff18655231510089af245245d1eac84d37d1e762544934b7479980d5129e000850bfc8834f7d6a0f63cc1baeae1eeb01a33ac41d1528b7e3b8599f3f0a6a07eb4224a1cca670ffd457ad73bfce5c74e452957526b6547d9aec896601cb8be1995a3ce6a6c245d622210d337bf8e1f1f380fec0702d96635bc3e91a60ac8b46db863b0a41f34dd3e441efa35a219fa25c39ec2564e30ce5d9000cfa97f1c6973fc77fd8367f2d2304f8fcbbd875dcd3e3096b2c0cfeee059a974ea40e1a3751adcdc2f5e2c2f958f2ee31899dffac6ca0deeedf63f573fc8151c221080529a4b44636f22a8bf75327729e5bff02a202e452a92af8f3a9d21a77bc356be99f2db496bfe29c37a9d3c692cfdbe66eb38917145ccc64de4acb252c078df618cdb75eb9c688b1faf006134c41afd5c1bb56642f4fb4be8929e80d27fc83af9db8af1ce7f0a867ea69cd46f3794371fd390608755c24c7f5ced0838c7fd30ddef9d82f444ac877b83c9a4a38ed83622e55f0f19eb32ae5250414aab0dbd62353698c36b4bb82c91b3c1c674f32a59136effb7cbceee5d93edb80bc3ce6536e9b3e35fb6b27815bd428c1ce9103ce2352f437a85db4626267dad8a9f9bd8151ad6e5fdbfd34ce52736543641c39d7928aeef1394aac245cc6e796645dcfd4145cc6b9d48745e9bc8be366060e1457f5056a1aaf622bc78a4b04fa2eb60d7c6b18532dc9a562060741f8551e04c52ce1a08cf1489751d1e8bf9e61ce3fd98f2199c087482eb5d04df40addee2944c757cb770d6c404579a9a78f083701c0aa874be47d99b71b9947ebbb58f3ae8b35680f472958268e2955c4e1eb22209dc12fa5e2ed11b1eb39b25605003106ff7ce71911ecee3e5ad392962ae312862f6c59d98bfd0c3cb3a57a1a807256822627747160c19efcae51a63642037ba6b18efc73bd9bc7b6e07ab0112342dc331d966f5f565b9b8d2686502f246e790dfe60644320e7f1b336b20e35403cf13a72f893d4d878ec3236c97e01a23a5d22de0f233d1a445a205134d7a993afb72068a601af61ecfc8097601bb583382b1d7fec7148f5961b5b7e36d7ff9c2edf6da71224332e931841919624b31f27775f07187a71d40d0c870087b641b78df7fa18956f01640c9dc6909cd0cc6089b7de8c612033867fdb5e7ed25157f6241e977dc0f279e78fa23b28944904083b135d2abbd80b04e50b30af91d16c1e9851b7715c17327fdac799c9a6b8f52eeb822680f13b257937e699567e6638201328eedc76db78b67f8e98b9aae8a5b8e4bdca04d61db524a8d8a7e1d02f047225f996e420054eed104aa513bf770320b391f7c6d44435320fbafe3d320160520695fb8a26875ed49646627e62880851b74627f20474e28de34d5cd75f8c4a2b7726569a5bfee99e165cc30d819652f75f256c46fffb995243e59f5b966df18325581f766bb5d222a1ad6f65525ccd907813d183dc3fc2aede6d7f2f2acd6e44f5ff4ce7c09a121ba192bb8e07a6d9a69477f0f68232237a0a21636f11cc87b022911f0aaadd1f1a381ccafdf3d8a15cc3d190af2a722abcf84a713fbb097010ae1331889b822a4ec098cd94fba7e3fd26f3a98e5165362cf99bbc8167cc752e3ea7ce1d9066d3b70994a80acba13d77627f871735c45288612547032e66716c023a8e6ef3da22dfd437eb5e70201e04bb44a5059b8577523b257959188592cc33127f9eb4d3b35e585d8fbfcdeefe3600beabe1cee1f4d00e6db5da758b9b74c06a033943d17f75bdd2efa80297aba6ac397294231945aa063702e29c630ce17f6f69f6e726e477d944fc65aa126f7b02f2694fe5d3634fe95d549838e0190efe3f8e923ca83010a3aefcba6785e9cb8d8f263f0973f27f58112c2d0fc4ea9eed99561057d7a2b3affb0e000a89978d203cad26b04dc778b3e728c6ee04c9c13c0737b7d627be500d8eb12bb26177c7faf7a5573d754524f4db7c4c6a1b4873403863551950da6ba59e1514c5a335163c7e7875646c62a0bb771dfb7571aa1c6ef94c4c2c7cffa9bfb71e735668b7f678b6f8d037d176b336d622d33c5272fac804c0cbabb0e3e583478c4445c56318e98907d3e51157c7d6342035c87fd7a7f1093162f3230730fb12d9f2949d24c6054d2ca7cc53ecdab13b876680ea1d4e5ca9cf980c4fca762255720e67d8349e08652ebfbd22f9a702aa91a0266f0fa327c12b6344d0dc041e2f1663766b594566eeb5efd7a7e255a7760b4295c5c2e05fe8ac1557d0b51de33e78c8fd7b555579a4fecea10753f0a091efa7c62511b38c06c2831b5513cedea6f3d051083e84caf6ccc1fd4b0f8095a1925ceff4e644f9ffccd6cfa498ae6fb8b25aa5a138978270e2b4154bd8936603be24ef8e186c57c74f1d4b0becfbc7a3b56e478fe27930ae5d87a4a411de10c17d6fcda6a824f17316d2b84903256e2e6c6172f235be1f19443f39425abe5a309ed13d85dc03c03c9b5ad782a85cac4330924020537d8140741854b31b22c1333707bdc61498d36a8352399dcefec1135686653c9a16a5dafc45ac423c15b93d0f35c86d7d620e82cf146155725f08ba482234147630e4e060a7ebd411a6fb97c4dfe4ae6011a06eeddd60fcf3d2fbda026ab6022d7cab6bf4c2255271b51354ec64532445b4b477a024e2e49c59fe4c19deab1c56f775e46e1f16b775ccdb9473b201ffe0ff22dd9d7b51afe0dd23389c582a89ed02a2ca793f622c19b0da30793ecfcfc19352deff5c6d9d916d07a4098f65490f7a9e749d97f4bd65f47da34de3bc0329fef127d657b424a993709737730d5cc835f72ee2bfdae16969336eb94ced7dc2503b932ed9bd40698b31be9429fdf82c4fe65d42173bd92f62660cbdba5e8143fffec97b55ea33688f7ce62440f0e88111445f32d16d88b099525f412fc636ed472e687a751f3f8105a7ddc89f7dc5dfc0705b12e8cfaa4d078bc0d09229ac1419444ae6c14da78b892f716b54ff20f55a8c910cf181f78da7e1cafe92e858acd4c2d29a8085355ea7a1ef5c329d8fe031c889394805e60cf0a047ad3f94583e869e27d9e4ff27b8181574b027632bf4275a01d4cbfec9eb8060cde8e7662906c1bff26a1abac9ac4674ae192d2ffba19aa72dc10c7a9151829fb1cf74eb4c2af2f2f071269390041823e6280e75f7521321dd8666bb2ec3479f9124a06968f16c5f7f48c1b04c5676670427020d5458113fbe75f5f4296bfc3113bb65ec5eb30282c829e88c9aa6ac9872672322239c15282d85652f9b4a0f2a7d9ae244aedd298b1d3b119a2eb9e06d74836ab3145bf26d2d2b5e19288f4dd505acd48e585fa6515bf1e052f6d9eee7d1642caf20d3335c790ff247efcc2f0bc95fed33cad14fcdb57d950747f6f166b5a2bbdb46246d14c35b399783f89bf3fdf7af909b5204bcae7f34de4158fb18af73571721570c33b45187e982678061e9e80e4125b7ab8b329522171964244018d93e625c08bd82e6113e3110f96f999001b7fb2581835c431b4c1710c369cf6856b4c8f58b581cf155fce33137255020b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
