<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a9e3af760dadc38cdfb91f1710b014ac5963f1cc02e9b345e909dda4c7ba3d6b60979a70122fc36953268dcb4394cf42102dca22bf7900ba737742f6ed55887ed57e35c4860f6c2246bf71f5019987f385f622e7c77fe3f8f029293aea1182711a0b3644c5f9bc2e34613aff892470277ed4bc59c5738dbb42b17ec612ab79ccca847eac3554f1de0963d02daaee62f79cefa673cb600f6fad1b169a7352e1343b3c7a7d1c0012e5801daee1a0bc790b8b96ffcd3c20210ec5cb599e5ce24100f730b2d66d158ea285e3db20ebfbd8c70ced7a7d457513eec5723c0572c1a7dc273a8511ea533c3c6f2889cde1387c975b301dfa6ef449fc354f1d8f0a108fe677edeb820488c19f14ae246671100b81afc0cda5ae09ca6fc0860695d8732bf10045db512a32b86603deb23abd671a287d8e08d3269c2935e66a8c806f2309ade2bd2e77f48ba087a4bb286992e217e8009d20af4a9ce43475e18e31b161a96a21741b4f37b73845fd9ff504f8e50cf457e4596b9cfa3bc8f4c59d073e263421ec5691c34269cf92bb72fa1e081bf524a7c5f505d0a2559982b64c38a8991a5e50d4befc27e1fd64e00608497d89cd0c9c9b10a5912cd5bb56a9beb95fcd95a629a6a70245994e0a7a3d05a3d972a622c7c809c5f1912a5c68eb67a824cedd72001f62a3bb3918dd9adb6c6e236f3d45122477f2f0323ecb462483d303e99ed6c90921aefe47742bcb62d8a80cb64970cb159bd241f3d791c142daab09ecf678e683c9ef1fe1a74156c86e6010378e9bd5fb1a7745bc62f9f429a2c3819f75ecd63e299db35575185c1aa902ba7fd7e6323ca56cc6f706dcdd772c5745c4148c225145985e4c9f32df236f12d90d4fdfab4d9719539d08c5a6e78d9f8d945a8fed015612005928049e70607981eeda7d3641a090703760533e20ea5d5804fb71aa988e272fbd88db6331c3dbfd30e638894dd6c80a07073d16eecd44c1d51ecb6ef1f07662887530ea2105935441b5a98f74291e5e366514e07ef4a4a01cc6390ad06c595f341c44422cba93005d91fe3ea30ce7b47fc23ab3890b131b4bb65e084ae9609dd9c70dbf84c7c108c1eb0c271e39ad9fd1c8a5f08f24d93dbb96c4acd4e4d1d77416b4d135b20328267cee148d8e85f12a714c0d861fbd51cfb4a803769a763d1c8e9cbf5b80b30009e95e41fd3ea6a477ccb3cac1961569e48833aa876842fecdf363d0dcda5ffe56091f64db5adb881b4128d6f14f5595da88fafb16642b0535820aa4da2da98287ef5d740d57059d383fbc227f80c691661c3275f5134b17b8036e0cc6753544f7286d8a833b4c1a6a02e99ea3d9af8e1b98950d91f241950e1205868060b335951d4cb7ab6fd3d2595ba8f236636b87e9d32174dc109549e6c2f66f2a35313755d33166337b4e1df2f900daccdafec0f97148b5d0e659ab55f18a52d90a3feef29a6d0551a389ce0ba711cbbc8b631ffa50977061dc67e41cf9ca0107c55230112b534fffaa3ca6f319bbdc482ccb6b88247574c6db35dd524caaefc296246d9c4627453615863cda57fd41c82301842f8ffe31480cdc5653ae8b3bbc6b39b04c713617d242ab3f6cf42d56646fee5f82da79568799ad3323362a72b66a82ac33d114a2748374de9694acfb6b43737d25f2141557aa9dd40651a17ede711741b47d63ce7a2015fc3758adfdd59dbcbb16f1efc816083fd6a53e13feff8602204376fa6aa25e0bde6f98b370c16bf256ef4b74b2e10cc74f94e058809cb504dda554028dfd101485be82b52e55a9528e1b17e59c9568b2e0feee9c9f877220be709878e05870920fe53ce4b0a417fc1f38199e3b8d17ebb7143326692bb1505c8db4bc1bcf1ded7e6d6f140f498d35d27909639dcbef2fcdea7e3c0adb095c2c657f6f3d2b3953ba1276233b10b545c268b338c05497c6f9317effc6cb5f68bb79847412e431c907b59a29a9599966fcf85146a40ea35c0f6b8bcaa59d188ce25f136e63d64a47cceb6a6cf9c415a5e3d80f44a584328c4a1817ab7fb37a36a0fcf03e004089c9f1289023a5f6af4b23a13c7adadd204f8cf5acb9f46de1834ecbc4b3184cd12e797356a7985fa2c72df894bda94dee41fd2b89329dc42c27c4aca727cd98520279beacbe8ee620973ff8556936104b227177d4d6731cd21dcf8c09c7e53f916e54dedf19afd13d9dd4c8395ab149676f10ab37aefd6c8644753b6cd73803c490b8c8937328503dd18b22f9081b97ce91c2106bb8252ab19d556d16cbf1e04e2483c08bcdd64ee7b89ba1b345dc1fc010afbac6ebc985b3ef3024a08ea6f437417d9454eb489ba8a1a03619313be07bd194b500a62d5f7d0122bb6d246d90afc7097ad7cf6ee4c01ed26eff9c880e9f89dd4109636e0280799b667ce54f6b43d7334d581c7bae5330d7d286080e94b0cb3dcea430a525855fcb779b907b22b1c4d086a076a6d7728f5649c33493edc605bcb74624263c2a6a448309bf998707de679cd213d355e1d4f086b9d16f0ea78e20d4837d721b8d4b14881f197c7dcfe450edc3c6877abab10bb2eb7f86c27ef23703833c422a397993d65681ee690177da96e982fee21fbde2ccfbcb7a15d11ec1abcfb53d6ed3f6913e41a7e0a3facc80095edfd68e934e45ab23b6fc6aa30da71ac0d9b6c89917a18c50ea8a557c423d7cb35abd9ab5412284e48f0c4712413572f3f3b376d859341442919f33d7b2ac38f1aa39f71ea385d79848a3a0d0ae794d722220e83d27d52bd994d77694df36e26876253418afb138a9919cd5a0d7f8119da0907519790fa4ef2055a5f0b3aeaac8185b84ec5c51529280da4ba0ba8481e39f6445ecc67f595730d2dd17d04e7339877000d4dee107ee765bd7b93aa99e65c1c8677b5495df0487bd51b41858db9fa0a104af76d3d3d5e0529c5066eac78da6093fd6d61f287cf7d65a59d52857bae0e5403f1e89b1fbd3671cabaa133f5721ce3bdcf3289b72d0b9ad73050436277bb87973f9a36962cb08e5de0476a9a9fb45a472d1fcc249582f8d5e6a4e1e9a33c02741df8a48f630c0486fc532f6ba270b13d003f26492b86e6f00b0b289937ad0e1da0c5a5f2fea42b33818d5a2d5c3d21f6581dd6be3809744200e772d69e11d7dd4ed18602f135c1047a9629f5171249ffefa0f1dc30b22338f7d9deadeb0da5b357d2f7a25ef2f9704156e732298976c863a964c6b52c1493803fbf4fa45fcc83385b3d659934d6f7a5054876fc79d6c0a3daf079153fb850978d478d22ee03087fa84867fe6420d949d48bae1c48201b9aab65f0bb94a52e1da79aabb4f8603425ac6eb2a967e2daef4e8d8ba317bce79904a22bf3126740fd80041e74146d41087c6f149fbada1f3f073fd5eff32eb8c1781815fe74647376baef9f0a141a25418011e9a0049e32828ccfa94df3fa9439e1588fdf0e48343f438aa2cbb9b8c9482944cea67b55b9b13b3bf18319aa121c3ba3e0d68916aaf275d0986c7c61cce67b5b3170cb9790331ff56d3bb4516c8c304ff2617586e88662d50da78f6c340e0d342ef423b08d4962811fd1a23cf950c742e88eb8d7c6f988e1289f1017ed4a7b0ea675f332e683c90bf82d47a41f0ad5c67a5679ebd08ba53f27bd0c185bb10e76a0ae2cd02169fa778b39839dbda3aca1b43860b3e3442e1476fa7bc13852340992cda670596162d42cdf27aadd33d24a7e40055e79029bfcf70c37d9774f23a10162815b3f32478ebd57a22afd851bd50aa1e021c6cdb57b292a9d6cdee86fa9daa684c8315fb581f80a4bc52dcc927a0efe027f0adf26fc05eced69d8d0e4c2ef3c882f7449380d9d659343101fe6ba3e4fb529cdbd2ac49d2e21a278fbdaf7080b8dce123e540246e2305f6a8e9fe7d621bd013c8dddef2c74cf096953b67fbdd2ae4487518166427e97f83f7c1e6fd7ca5aabb26f9a9803ce56d7ae3e3b4c505567a6cf198d5ed8b9486868d1a3de240facc6b004372a8557980de41e1056cdf370b669e0573851700e960bc39229a979909559829354cfccb761d13492fa034f562c9b6db81d2ea934ad8ba19412b13369679300e51b401c91703b8c077003b46e409fe33815fe22c628378630411c712e4b4cf421828537ca4dff98c9d85c44f984040b8cac190fa9b61c8aa94153e9358b5544067b150e67a1ff3b56fd9513e43613d628d1916385eb9a4261bd9c96857cadfaae1316ff405823899d070487f036a6fcbf71d029146149c696156a47758cc86b0e2935369b8af0c4aa1277e230561720f4e182b06dfcc4140248902009247392c2da0ee89749da191f787109718825e19041fa7f9fd026f43367162d55bfa48150fd739ea0210e559c81f833bca11933474e369f38138b73c299e2da04abb665f4d467cde0646c876a15b808fc5a650d1cce34cd85b0ef315a217d3409be2ef85e31a7b002536adfa6b9dc60b4e0fbd736bed04f94dade0624694f91b90a0a8a7c7bd8b6b4ccb4e5f53451eeca4803193aa23bb4551945c6c67b085ad390f3ca70b022f77c97d474a773bf81d84bfbb85dd15ae23152216ba94199801feef3e1b92c049c0e68ed22cb66793af3655554ea9d022265094b53684da97b1aa7afba6be72e17f39837f7c9ad3b715b03a4f741f959678bd438406b6525ee26c671f8c40b704af6a6fffa5bde57cdc48a2ec33d71b712bf698c8901d3c23b10a05ba53e6024aad73c8c4fb2a4a926cbddc9c051622a64b43b7a2e4a1c53124de9ea867968f5aace4a5dc2f5a1fe4ea0316c32549760061f64db00372eb589cf7e084a9216a3bbf55a742613124cecfd947b67a1db009ca65b282367c5445f38579b02ba6d2ad11a8d1dfc1903b3ce095fb1cb82116ffe53d8ad5271276007ffd5900c04686f6558f812a12d0f3c13c6c5c080f71e905012ef4f05589b8abb463d2ec745710deee391428a0f87ee825ee17fce69336a2b11ef619dc30a4537ad975a5a762deae69c246ce8fd0d96687b034c1a90105d883398da4b2b8cbaea83244b9c8fe56e434770877b883ef58f69d9626a0171ffd34c6f7abc925dbcfd930c4187bb8bf28bd1972fa8cff9eabd24f8bd2de0785497dc9650c72ae8eb484018420771bc1b5bea271cfd08236ffc1a31ef80f9b075f834ca18a10df945bd3bed8cc11a86af457efd4cffd8b8d237e01ac844460d03db91356273b61cdbf33e9c2ba3798f4840dbe5034b013cd342c9a31c24d047239dafb4048ae38a4d24233b88f0492a26fa929deac6422107cccf282034340d144e5298046475da41fd5b15c3395bdfba2510dd1bfcbb25c23e2f0f552060cf49c03d45f48e058120a5bf9ffbcc8a44c576e4f6b798b84381f44fc9861b769eab156e71d40a8e59eb15c5ef9563d8a11260127fb6bbea92844c2732b97347d1127a36166690bdd69e6dd50aa4dfb8967dd03f9ca797c5ce1aa98f8ebd5ec63c339ccc83f814eae029e54f41f4ea221b86ded6b34cc984ad311faeaef2fefbed732b7c7a75db2d820d07011ab148c476769f3ad3ac9efeb66f0c80428da5e13f7b569b419ada90e02a94dafcb78a00827ff8df7de9985d05a2f3b80e6fa2170d706db4697e4ab6a3a5f574d25bd859384482949f6823e63a0f1e705bd662e9d8950ca24041d4763d0978833c987c9c8eb889c06f67627e94551bc5b8093c0d2dc891841d1da768a1e9fb22eab1555d5479e31e767bad032a87052c1686a41c093cee48984001287a069e0172bea1ea2a730f5d893d08fffd149798ab1314998f4964a64c471a5bb3dc692ef5d0756f665588630ff53431f7b3fdb1c8524037995a1dfd49ab0572b622e67399ba05a07d3baf02b1622f24ea255814fce2c6cd5518024d00aad2ffb3a3b766f6f257ee632b5a3194ef3e2529d44c3366deae0998cc68125f45a73dbcb7bb81651a36f1f2e251d2d80dd9e7fbaac0366ac5e0d6ba15add2951d351f5201b92eaa104ccb4300921758ae75bb98414b903ee52e9f709bb1c3ee0dba5edbfdf6ee32d35aa3b98e07237b14f1b974a42ee0638b1ce1542abdac90c1ceac08a01e6a582dceff8af268242331a64fe447e5bb1a33c7e7388fe7cd56db274b598854dadd2d3a18c875da6ff2ab773c7a03e9d9c8b02ce8be3778296ae5a45ef30f2a0dd2c54203725eb0e7d2b3d1e4a01ed838a879a5167d7753a26abb6c106f7ad49520c9b2aacf21ca0ff4b48f7e59c1ae866da9febfd9269373290af6952dddfde0cfe329d4197902e02d7e98cd93b11b6a2b3402cf6516ce6a6062e5fd496a8d22ebe42d416b7944cf7a4207bbb2c1ba700067e1a10f6a834db231c7a61102fbcd6b3392a4bc8bdbc622e37e9d6b3961143b7f0de5d31c8ca5364d51a76f9fe7edcf2d376c1f2697ab9a27da7d05987d394eb5f998c42fdfa9ef91a3daced21cf0edadca7ea8cbe263780aec43572aa579b021db644d8c14e09019905c8a3366867f29b28fdb4642d39459bc8f5bd78b0fe98b32ebcc2ca3034acf16b11431b4eee7d9b763a83436164ddc4f56bc39f902fe175530d5cae46abd194f83fd1b08a481294d2244d1d48359cd6e1174ae503a1760adb5a0b62093bf586adc4f9dff415587256d4c14a0288673ac4fa7a5a6a8f5b36fb6ff5e98f4a00992a95c3f315f96954c87721e76dfbe33d6fee3b77357d5015ab114893e771f490db5d9b32bc55f26e2fad015e8ec647aec282e253e589c36723be9133a72c8bd33d7096dadc4d1ea6026fbd99936d0a1d4a608241862d337fed93a691d0d6c9a51088a9c222f4a804898ca379a3c57cb22b5b56cfbf102cd1f475210b2e46d47ec9a53f421beebfde3a41941d18236d5f76285c765c3e18a9356288a69e815ed8bc6a9f7567e75fd59d4ca77fa1abf0c4b9c20930bd31b02185e18500e99711762b03394e1ed1a21032fef3de4069cdcd902fd0106c0ffcbe62579f4a93754d075bfdadd6bb5295ce10c01bf8cf6253ec1fb4f4d5365fc2e1a82b6914a7a97d4be1f5f69d0d704cb8cdb2a667a98214c82899173ecd284002d8bdaa7545acdd8406ca9f7d8000ac02e8a7918b01504a9cdbf00f80dcfb9425422c168c1a7653098d0296213f34aa8e2e6b526baaed253f53961af277f83c61062f5ab4ab071aa7b548d7bd30334abf67d623d5486c509712c93fc7b19f1b27a74de17c63c7089d25c599dd4d1c1580b0b9827b638977da6983723d46cf515a638735d06e31d2574ce6e84a4fe62e5eb2127e7ca93ca2037afdbdd0e369d2cd19e5090bcf3fde1a47c1704d157d70826c862bcae1fec9089793ec18b51ded9401691c7aab9a117e158a62d2ace78c205093b9c7cbfaa6532cc3481313cb5af251a167869a7b78424614f16db0de4e9723cdd054cfc76cdba615799d2878a79bfdeaf5c6f91988cb49297945a0f402fc130b00e840e62c8b8a9876e35e03bf7ce72666410574f67305393222a167e31f3546762dab38ae0a54c6c2dba1e9cd3fa437bf188d5c8e471c8cd4286b2b34aa9b80790a756d67d670e853d2058f1660f8311a8e9ba4d15f39fde756f26614724a76ee582538ababa7efe35f07ca69c64a5883abd64eb32b63229bdfaee4ebfa634bde37f9b99ee097ad19ce930d057658fad8f9d8992fc35c7a943d87ec8c43dfd3147642c594f7d64a5d9ffd707cb26289d2cd95615b61a84bcecef9389712b885e5309da1cdd1a07877fb4ed4d633009b92e63d43c192cf0028ce6f9e1fdbb12e30de63a7fe0d2e5918fe3503cb8fc74a458fd0c42f0cab898b3e77d18cfbe9dc664885cf4bf512678f342737ba78ee6b3204a51ae3d3c46e84af8bfdcabe6fee53aeda8aaecebf23cb2c5d5e69ad1b9b90595a66f382b22a8d1fc9d8d4c3705cb8ee3bc48aa8083f8269b900d964aa2e1f1bd64654762c5cdac97906496c897aeca81e9bb6743f7fbba868aafaaab5b8c91f1dd2ff9c40102e24fb889e5d134eb295a29f31dd41dbdc8b458abc328e9542f58127afa1d0cf3ae1fce03a682de5f760510946558918425dc754a95a0f4e57e5f2c6bea1253e00a203c8c3b280916b50d2df2f9b0546191a85618dbd058c52babb3c0e3196bbc80b9471038866e4d1e31926d6e1e48914160c23da0fc38a024945f33d6174b724a9a661b93b0319519292ab6fe767ace3e68d6578f8ef9f0ee251e90ea69bf58f12cd1dec53e43821e32aa358f55e128b5d61af1a634db592c1a56856d554013b3ef6c4d2f789f07fd064fe4b9afb78dadd2577f8525a5464f1f7aa75e10234ed1a91c46f07296a71bf8082b1613621638bb7a78a25bb727d07fe0ec1ded65cc33465f791662ec07e9bbc37988cb07744c388f7a2f47cb2afb03717569d2bd8ceeb38fcece29fff8bc7bc69de85c8ee02d83d7678e98286b7a2597d569794f02230219068c137e17cfdd831f530cdad4e540906c002ae506b07a9dc21729a218c944829a6a00e4d36c5cda5b241694e8db63bf94ab2cebfbdca40c64e0d446ed660906c6b649cd984ff27b39ec40125d62b9771a67c6807bddaee5d7c2018edf9836bab9c8331b4151b849657a65306a01652b5fa62fdca4127ab9a1b07bf07796484a726f89a4b2594d8a05b51693153ec5e3a5b4e684d7144001d37a74a68db4c4f4fc070b9481ae779ff51276eadf8c7fe2377f7f4d0a551a52416f6056044a26f27d47b11b71449a63078066cf67dbd9d693b65ff1281d34495e41dc0e090af878f34a7dd254a90490bc24a026152be810b2e3610cec7dfa4751d9d9d2f5839a826f20bd93a00569ceb8a5f5a8aaace5b46eeeeeabea49fb9fb1d29297a86730becdf00fb74fda9ff3472647e9ce12b0d18113a185cac9fe55eaa40df5c5601e6623983fa260b380619fc24442933b519c8f8114a0854ccccb34cfef2a56d9a45df44c60aa8c068ad4a44d43a631a10ce8bc259a6b7f29d570c2f6592da356e486fdd2b09735ac30db9b477b268bf2ef1fc8119bf83b69c7c0fc3e3481925b4e40f9c515ac93bfc487e7978484fc33095c8ba2b20bfee669750f7c1db431bbcbe05db7b0ac0e4ca9acf11ed370a19bb1e7694c56f5048000ae2d10c47f777aa289553ae3e9b0a60b16f43760365159be0198d5922c86c860cb23192b764420768b871695754a882632aec3903ad02089e28e57bd21416bb79c757410e6483150326629a2fcf541d842697e0bda559ee3a3e0472fecb7945cb1623e22c1451c1ca7ad419c8e41246fabb4641038a569a60660ae436b4ecf4efc76e6c0bd295735648df64aeca85bb90a520022053b9b664ccb76a5986fc4c6cacedf89972fd199266c275c39ff3b9506b7685ef0117e9bfbb6b9240f7c361aaa6d48a120bc45dd19501f6d9b052bb1b46ae69c81ba7c1cfa4552c182fed6aa46e7d5f9be51acd6f816b59e808a2d6e05c03c3c80f65b4ec25764f4d765a2814c8c556b30413043c6ada77bae83ee4ed27da72f0c21c6a0a2fa678d1b46fb0d212759c40021bf6e2892f272cad6b41c17a7d83992084986cfd118ffdf129527ad4f336513033a91ff3e49cf7db603c2408b7cf20655d273c8dc9b2e1c0016116f74f7b12f641e378dae32c21591326ec4b79abf0888172426d7669a88f689c672f1ac3726b188d74b07a56fbbd0bb85dbc362a02e18e148325d7cbeeef0ff82a73df6493778c0756f4e8638893b181737e8be280e1da331763dd7bbf6de056d12798c2c4e10cba7444ac25e38a773ab2c5fea37d39f8f08eb3eae7b1af0ffdd0a4059b4c8928e374320a838f1d3b4fc3203e0739306f4e663b11bd15d1c271ef4d519090ed0eee19f9ef6b501823d843df4655575c6307e69f086a216c56b1a6a10f5e47e4d823e5ff7e6f9aba7ece0f9ac8574e505592a0aa3a32403f0c88cc8d5db0e709aeacdf40552a771f99cf26e7680159f0e2f3e72cc9ea5d7868c9194f3bf79aa8dfe47a1d641f4d7c769cb6ba395b3b7034cc7b0672f4849e5ca71a5d65f3de515ec145c70868eeb413e904abb334e26d75f534ffa31b999aef0c00c5f7d3d13e89a935bb4f8bfb24cbf2b0fc010164b8e00f6ebbc4a94ee9d9b9ce1ca518e11209aa4d5b2e018bec859ef76db5f6968cd2e911cd5ad953e8ec8b7533c3263dd39a8d5719ed1ee5e2b31ee663c11b4fd7f4865443d783e81e6d2cffa8db34ee9345e4dc9c0049ed3a326134c674807bcf4c850ec11a46bea401ab3551e897cafdb8347d992dbb80761a3189c23009e515debb71e53ec9783479c83d640db295b9590779310b1c693f19ff1fe69ec14aad4e1d1c1c9b6664487d7dbed48c0068185544c349610941984ffc723f8c5089aa82800","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
