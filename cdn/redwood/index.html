<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f7ee296a33793cb3c3c708f93cd986e3ec2751deba4995f3fdb61ccdeaa52f290d92d82e4e4c3b312c26f0ae7cc7f5035996ef508dc3c56cc7ee32ff0057d9a08a7da53602567ed9687805905d155e8311ecedb85c00104ceef77bd60bfc24df42e8c44d732c196edbffe528a8bf1a35a4f47e7d8e51d24d25455af960423d8615263705f420b646eed95401b98cdd03aa9ab91455b0a47fa503cfe4c1d3f9ac865e9accb82f3bdbc5e585dd7a66a20e69440056e29c1b6c127bb3fdb2919df8f10be5567afe56dbfcab00e77fc4b51d4cc27c69297059bdb490dbd4caf2c7eab5ce2fdc97f33790c64e2ae8b49d5ab9a008b27bbcb394e13c4c2ad28083354d357ca9f4b9f4802e59036b9053b61e0a1b3a62502eb0c9a2870a349dfa853e94a9ed980782b2a37066b3797be99cc376bfb27692014ec7cb7902af8817601a270fed389b464eeb2adf4818039311d9ed663b7db1b038c92099898eb37fbe8698b6bfdef25985b90265200030782e7e19d5545df6276667eff2ed6f71fc2fe3cdb6504eb29b6218609ea214c4e1374de5dea06abbb4649de4cd62a0f7e73da7dcbe92bfde4eb5ed9aa9d6b814bc773d2c6a22450b5bf3ca96bca9ee533cc24d705e0bd5cf43fc148332ddbb1c0a1bf2d01b6168fabbea55acac1eec5b6d42b76cae2ed17927e277470587f92ca63cbe4357d2d18847e8a970c55035e50be6cc8b79faba228ab8e63cc6e5d8913f79a98d5b60b69274af9aeb120077ff1b169c928c24849885ef58018b07ccd357f50377efc52315edf452246eebad6d4b000a1917c7d38a4ddf367db897f61012912a7d59a403670f10d99b54b938fc1d5aa520e14532ddb2481e5f7ce543a9942e6babacfde2619ce23fc79e098a0f19b6d606b063c1ef1946e44ea4ecaf927b4eed2b043fc5d213a8949ceb9fd0b2e0f46573ed456e92582d6a5197502cc20dddef1182108729c1761ec636d93f55ae60a4d303d4a044faaf932b9db1baf846e90882d4392061c4e7be4c5becfd60d7a0fa8ff3335b2d3d154a37d29608f05c5860a559063be19a7c8586114443c35ae3d04d0767d8d2b733b5e8bc0d355561ad096f0c2dcc3c9362f71ba60012c5ca5993498d4ec123f706a978ad0d06e4ce3b8fef7041a1199661b94424627d2946a99ac473236831cfe4d573233cf399c0904a2521ed39e7fa5cadedb382c1933c48c0af7184821f9a808de981618766c1196d2be8ff5c0e963443c21a1ddb68337d5a71006b62c156d5790e3971e03203ceccc15f92b0c3312d06b38d9e9aeb3d19f34026b00b6afd59f81d194047fc128ef2caaf4e78321721416e6dc0d0a0a4ee4f8c431b785c68d136aa8c7f2474eb1c4e43b23cfe1ad68dace444794f3b553384c1385c97e4c72585453bfada550d2c79293f24e43ef1e0247a7f154b4c7482d5164474151560614fd281ce3722f2e32d919dc9f866c2bb19d73837e72e8998ad52b89e88d6a8e2a9dc3354125ba5a36609f9d047b700c1953939513175da752109199074bd324dc0c6ee4f089b5d03ff333381aba220ab7648c9d2e57a95a08023fd1db78bcb314e97fd467992a05240d6613b0834cddc6c5338376806a83012dfd23447fde399808bae95748fc66c3a1d018494c1a2612a12ba644b522607a6431711577c3d7a8349dffa3cee432c47015a1d169e68b6dab2b3cb6336fd9a3bdfb0272fb7283f55ebdd4903314258a156994e0d7145ed8f802fb762f1dfd669f478a353f63ca58a7441a56828059aa1209c114ec0e7b2b9fcb4521719294e4873bf85f5b84cfa28bc6469b4c7487c53880268ef7d4ff595266a350f4f1b26c6454ce4c8cbab19beaa765945f83c41697d624d35e932d0ad85004fd96fa6476124b5cb7db55c773e438ee939ca9f7fd32ff10ae228fdafa28b7b1f765868929e52b9c3c45c687a4416e741280bac86abfe6891ce431d11a76274423c982a77b76ca25ee0824876c1995317e5b84fbb1bff33b192b0236039aa1e40e951bb6fb814a279904ba3f289536ca3460e6f8e283618739a48df820ae061136ab0f65baa44f4ce06eecd997f71678095393f946f475d1fc48283f0e4772acbeaa89eb1f93803811cdd12852bc4db2861ae8b5ac544cc76f413b72f53f2b9ef8751deb048e4eb24ed5d1710ff77a054df355ff2e37e07149d5b9dcf3ab23ce8f96d437719ac1e92b5ab2abcf9f9f384d86650a914328630109e22260ab94782b169356c74fade77d73240c6b9e58a6a1343eab1d3ddc98830d364e08aa843992c31917bb50fd9dbe335f5485037fea174911d62b521dc6c8ac13d50fdc1e1e32a5c4a2b60458e6075b3302bd7aaed915ffd6090aea25d4377b8275fb0bd3e5301cf3b4999e2429a83b7618efc02fc5f4cef3c669247e0b066ff58fc7df7ae24e6feac161a2bf4105d1c1cce134bba2311aaf431477e5352ca9009c564fb8809cd2b94c99b9eb72a446457c12165d0ba04f0c1395b3c2799ea2c7195cdca54c1a8cdb6e0abf62629b36724bca3df63cefe51aba285ce9fe541cc860eb9cfa4fcba504dd31734848c8e0eb8dc8af8567e07ae692f673ce45747408299e66dde7d831d9e567720a18f7f172b35ddaa108a655dbfbfe340c7bf36b8095edaaee569019c1af58b6f649190a64d4a2196a188222031e0f71cf71e74ab3fb45ebaf3814b06c6415cfd711dabb198c03b136bbee5a147e4f80b7576edcda110c72841e83bbf73eb4bf39268a04a6d3f06f65fcb3e77f35a0a9d383c90c88da5b26ad95f51600cdaa3a6f0dae17f08dcf10ff83574ed36ca8562a50a662c100c4aece7062de27bbf420455ca798e8f82c637ebc670f2f04faebf9730ed50036baa4bda500011ef1f1b742630b70329832dd77c98198f7b903e96e81f826e603881cfe5e7d8ac16e60dd5b0145ddaec7a821e16c8d0b93a960a9efea1ac91e1517ff318d61b08a932d22ac385f89f12ccdd4c908049eb22f2d9ace36bd6c6b042572038c36cf2dab739e4a7e181c0b07caf857709e1e780e48ad2e59adaf0743cda8326d107ec14c1c3764ff435612741aeb9720be627b1723ad1f98a72c66c263015f7198d72240d1e2871daf0644dd0a73bc011147d4a909ef20ff4c62d33c9247a7ade5de3910a57e1e75133333a362c5c3984b4d10a444acde53db50e5cd502f6044d0396057bd8558f4431314373d7ed4783f3d576cda0475b5dec45e7ae00b9296c6e842dd0e38af6a08eb0a956f819b91b13a34f8fc48e084ddb0c4f96e653fc62a35df42c2439789a133a556b74294f23ec19d2efb15d481127b05a599c3d92cf4e7d04b13992d7788e939673643714c30bb283784e9b1f27db919237aa3744c472482f51e7acc0b07e9679ecef22ba2327690605b13cab338670c608b90a7cf3cf199ee452f4f54a23868ab62113fdfb81d4c55faaec6bdf45b6ea5ccfda9e53beaffbb86dec1971285ce37d3ba1486c0f79298daa1d2a589e3f7554650591e41c9986caae01ed07f3296bbf1302c936c5ff1f5e7a17261642538e01ea50ad72a09183949c3d112b27fd37dc040e1daa0b5d7c3d2d7f05bee80fd45712cd831a2cfc03603baed0eca0ab087067e9e652933b0fb2ea3e3c706de0ea9ec58477653ba93ca5bc42af8a7b30eddd72c10ef98674f3b02e7130684b8e7a82b8ef7bb365be2c6a85b5528427ec42a279ae463e7cc47692483a7f0f29a4de1d4d880fe6dab965ed05bc9417888d46fd86efdf65084ddff544a0aa39aa9b7067f65320ee078b9b217eef3fa177f0ab62288783ffb75896943073daac805b2964dd268742d7edbab29459f9f71911544b3ea2d6b7b751adbd2a213019333ed58aca49ff44874779ab252c9b82b6b61615d7151b80532945d54e9cfac1772bcb25454b1632fc0ebd9aa434c928701f3fdecdfd7812216f24032b0fae5974d1220ac961b48f99ceef4f9a6ec7d1ed6815b1ec2deaa05895d0855c8028965dea93d7dbe567f54c8267206b455a6122e80704d49f165b8d59e0d71f188bac56a4d1c171252e8d61806f4361b0263ba333235052fa2d3ca8aa6da0c55906be0ebcba23544bb5888125ff4cb0f980bd90ef59e1f3058df402cbbbb5ac9a4a0d11057921b0272228b717f79f29e49b4238cba1c4f682cdcaeebc9cbff63e94b6fa1acbf15f3096640392b13511cf8ea16f0cf38e564d5da52ad8f3904ed096260366e46e8893eaba0b92bb83a1f781563f71f20f7e852e7f43df7341cebe978e0cb792b623c7287cc561d15ea420106a6a6961e8c22fcfd6e425cf355623c8f064dab5c876f0ca231319be73e7721318d1e6977cef6e98f55ab68a4cf79b6462bd566b870dba169f21408c11c49c8ea070f44d6a18a2ceff9610ab275c363f26c00c260606676b8c66fa7cd859c3376dbe1f7ca8c069043dab83a241690e7cfecea1e0f59e9cd317aef5f5b75ed9c903f228d102c2764c662515824ac28f33be2853b6902716c4d8418c1752d9b7fe8ae20ad23b3bbf11036296dc5bcdaea1f44ac8c673eeb9b19af0c9a3689b0da7f88f1bcaf71d9361ddb6d466dd17e76e0f5ef3c9b81fbb2b7545d97f2fbe3b7559fc0dcc5e4ba79af34c0ae86b329559ab3b8f2f9dc382a189dfeacc2e3b839a4442032e0ccf7b4b596840ad0ce7d6df2d8e99eb4c3b6e0666df29f47d4454173ea1ea527e738ce3717113857019063eca6010199ca76ed50ecc85c397b4a5159d0b68a6879ca3a9babb68a5ab58e119e0d604b23c4ccbe5d1b70a5a3629ab7efb4c59ec66f984a12a3289297b4f93dddd81880ca0bcb87d7de39361b78d07a71faf06ce38c9a77b664e37b17691bdb2d48f627d9d342baffeab2a4fdc308e25393f53c4f83176453bda9342a5a245d97b9f2e3378b5dfe4211e886d85a62b816663b0e4c151da91b704e1429cd2af66205590268f0dd00779204f8c8b941d117be37f332cd0d0a998f15c5af0b73c792f9a0f3005abc319a9c01df111ea096aa3fbc1b6e038039e83e146645c8bfb12661a11b21aa1008cd9060af703a3057723b95cd69f6fa5aed7cdc72857573f283ae581b5091ac6a2ce6a5633f45aa5da88fc7554b0608da88329a1f5bdc23c7fb433e70262258e3bc40dfe905fdfafa28b3eb69a549f99d00f389d37e84140f75c58dc4e5668a0b931c953000c2e9862d4669326924eac9d151501e7502c605ffe5ec6ac27aedf62ab34bf60cd212bd632cc04f451d2e226193fe48e770efa6be2e460e63093f04dd6ca2dc17a4ca5fc651363e6ca93bcf5894d7564c428a56ba1585837153c020ed87d455deaa2740f5d46779da1808c13edc1d93e1c84b4734e14d43d9eb106b745706c58d07fa080c903bcf4e5e74949dfd4b8571e5063d387a466e88f2507391f76e6719fbf04692224ac268de523d2e45a66932508308f69d595454ef4ff7c831197575787cd523ce55ab68ab009bda18034eb233d3e225301ef4fb86317abb9262b0606bad143822666e71467af57c791975566e2628edb0239d20eb3ad4be7af2440cbd2fd85c770f289dbe00f096c20a3a0a08e24b4aa81aa93eeb0d270896003a97566420cdf0beb887b3772f9f058f5ab5b9d1690058f0e38001e3ab17178596484fff638bac6666acb4ff1bb2e545767f1427cae3db98a7cdcccb10d236edc49a6feb0709c899d37639a7c0968767e5b07341b2e2a68643b3bb5f2c22cca59a46fa9a0c2c3b56cda33295f09ba03637252822e1624734f05da93e5aa48e8f046f420bbf6d2da85a11150f599283c0072b7b61eca5800986055fc03f88f44ca57228b109c6857b10a23660a4a8459674b59f32ad6ef109aec69d103a5eecc4626693a30913d7b16bbec94054df0b769f188f5ddeff9066dfbbb9bc903e7e72ad4c33c89eacf3a32962781a8c180fe5950920fe9705f362616c7203075ecd574e1a28c2349dd9c47677691189b1811b6008184cf4dc04f1cad08de8c2ac4b07af5268f1f16a25a83c98398f4a518ce997c0c9e60b8621956bde8bb984f39655906e9e6584677bf20bd1e8152936a2b3dbb498c9114c0b202b3f15addd6a4a0021ed37e41104a41a11d53b45378e7f23029f4937fe68620f9fffb70bbbc78b27fc6b0a8421c9f5c242eefc19cd4005a091a3bd8869268102ea0e4cf6127bb3e50075603b82e7a9dd20ee0b68502f4a30892f0f8c5823875ce65dcf3cbef11547ece876bc16dc7a87f54ddaeb66cd780fee51afe3034f31578d6cc38e218e350d2c169c3ce98c40fa10bc21e4bac8c7fb08f7b4e27bf8832bec11460edf122dc6ed19e434bd3d05b9307a3cbdab9ab24e8f82d465e05e24ff2416785339f30edf303938e5f608fd0db2c9971d35ad952e69faf2e5b2b1aaa735f49baccbf2172383558e5946465ce3383aa67eaf9a143728b6c28edb6f3ba9faddedcb5c1a21ecbc86a83d088a6d42fb69745387e6691f7be6e639e5f1fa21ba791bf6532d56276d459c4e78a8a4b52f8096545d3e2d9544afc0072a946eb280cea5fa0942bc4ef4da2b4f9199596732b704a2ae872385185c86208481093414687619bc28d33ea5deda6f113278c22a16f8daeff061be348768183bbd786f59b5ed5058f601d871d589534af9ec5e24ee74f2b8f3bf87fc37150544b6bbb630e40248b72097262562710ab79044395839f92e4f81466d25b08b6a264a7b0d4f17d931906657d09180bfecb8b52293a8acfbb54e36bb4c399d7cc6c885e1a9f49abeddff4f2925e81f2967c0676184ee5996a670914918bbaf699c137a1e8fac2c9d050cf7c6df9486adec2bdb077447b08cd5dd03d6aaffeea6d3334d08c129cea2f169a2dd05904b233f796d1c8b3eb6578c578f6ca2e9e43042038a1eec3681c04c24297d77948970a6eb0718c666189b67c9dac9687441e9132d2bc7e647e2f8db296b60e771708624973c6a08f8b5a86cd57f1a0eb61870fbd2a41d9d1506529d2c033b1e75ff165dfcf6c8b9960d6e2c05ac3730b9a7b3ace826b8843f58a36f4fa9b980390f204e02c67a4050329f9a3ac0bbe3976feb004da54ca5ffa5716b8c6fc6cb72c470a3c0be771caab05d74eb0de74bf94c5305383b793515a9911c0235d1355b1996349bdd99d0a018959262b59b226a006e2e0d815599ed3f04ec9d73b0755100a293c845ad950f18420215f817b8586e970aa4a5ccca2abe0506506906cdd16c52fae41454825181d960b2a151335b38c44118e8f1e4c28ba44f7d1f7795eb97e5312787c6da4985b988002822be513c560d3b6c487ea64f4bbf0389a6c1d6fb431b3e4342cc36048caeafa7e2719ebbf4a27352bd4977b00c8b2b001d39b94ff10865448f681726a26cd71290e865157a3ff9bd2fec29865981b32ebb128df908c63643ff576182da0a16e7af52b5786500fde456fc399b39b6a8dddfbf6e0942cb13cc66dadc303f454231b192b4ca88ce3b2730ed32c74e371a48b03dc130c12744422e1aef4d144407264bfeaf1addd167b05880051ad24ec02685055516952210b6e0b0b38f8116e25cfacdeefddd6c316fdf2a5f7d9fc8ee4f9ddd58f8152aa6267cd5710879480b2ea2780eb36b9ba58180da5a47393b5fbb95fe06ca17748b1fc28cadc37a93dd3239de08f89a1642e620a4eaf30cd7f69117ca41d67fc2b6e0cb36138ee6317fdf9e2db9672e39162156d0af4b4a3acd80b999949828ea2d7b913181aa4e548c1ab70309a199e20347b797539f1d6ba52f86956b11c8671f5f2a4cb2498fd424e647b08ceaf7cc9b1ad9e042a12b0a62c0c09cf6869beae9c47feeb83f0df0470a5550a45a744b9f756d8823b729507e1ba831daceceeee38638d61c523cf2a5bf77ab42e3b63e40537be22535135225f6b108a2ae20ba7b06d59625ec327d84dfbde926dca71feb429457fb64511259d2098212c2c3f819f45967106029e9b5f1f6299f082d1e806ea4795c26a99e62eb7bd7fe352fe2f4e0ad71ad1fc8bfa06a9a33d09bfc82550817d516516abb73c7ddc21e8475312c6d31b2f21f44fda69af02ac30e53e17c7e2d83006221b3ce3c2d7cc8e776bdb537ca4ccb6f77bacfceea8a79d97d439c3b92da62053c8ceaf5e3cda941bdba0fbc7f321ab470f34b97a8ff62c9cfe78402ca37be8176932a731a9e0391c60fb8a0dc9a35a09d7b5500f2a045afccbdd3fe6c1e7fc6b91390d4af0a197b6d8fb9b768b8b6f1dfac2dccb265b4fe2dfdd26e030f0eb831fa240e4fc5146620966166aa571a57a2cb2dcf3cc8b9c40df9fcd14fdf44c6fa0d6d5759307ca5287a1175062714093c563e04b5f5bc63bd46ce9dbd165620fa957488cd56d813fa3966b16b16962ce062182ae8915d73c5fffd227ff8428a7cfbb4b6819b8f21fc69feee3b982b612f6e634af0b5c4054991851fa53e32703cd48cdf0ff6a05be11288a9186a79d474f04dda1459e367110217c8d8c9b1674aa2b012a8ff055f7c4daf1a716f9f82ae2d02f4dc54661d9a8de2e5866269c09a3572e612a8c475de104254edd24fa9222f85b7ddb63782f04fced5ebdffc329ccb0d65ef9bd7946e3673b10f31d1eca0275378892f123154035a07b905a4c0121017b4f6a53d0496b45e0d3916f963d7429a73803da9d818d8b5a603872b7d373fde8777f6fd99d7bbab022435ba409c66b5398dc3e2bb808ae054ec2ffe1187a39e82d2ad0c7e1675445f4138114523abbc56f9ca2c887b094ecd2643706bbe60998e67b0092810a0a5ed7ee46d0a2bae9e0b8227368f648af64af1471ddba7d6ee90c3f85d27526135e5d22119737764dd11994a457c3951af46dc3158414c00e30b1ce329f471f6a1d00db79d213f0b4affd5da672932e0f3b8209367cf525f6bb24006b6f9bc9e441e58080b2cb75bd05defbc4218576a1bdbc64022cd943fe3f9ac4ea2acd438ddd8d2f52c71021d5fa78658d6d0a2868d6fa491ab77fb43946297ffc1eaf8c72472ea60815437312e5a0436bd3cecfe187eff4921e7d55be5f3b3db1907db91dc823a92a4c07e1c0e19581db1cf1a50774352002e25e81c916024df0cffa488acecafabd9961d6e35779e8a920c668b1fef21229a6ee9788df28311e0e87a7d74962343b52d26a0290e3972a376ddffd259f70db8192f33b83364b6a441083449f139ff12c63d33279c6a2d9bc0e459fd59e0ea86045348b7bf715a6dc2a0f892253650d5ebd75f0f4c9a064d759c2a198733b3bf6eeba27b4fdc52c6e2e752eba011085a5c2d0b0995e9375e5a0d9b2bb68d249d81880f932627d766c9ff9efd59bde851d3849360a23b6f3038dc37be26176a7813f7d5211c8df6b3c2d21ba021954d9fb61ff17762665b0eb51095056d3cc4398915829171fbe96ad807ff84e261308821aab018297687cb3d2dc7fb31fb77b43152a6488a05af666ce5f5a8589138ce4e6748d42196d7bb03470158b0b71de6221c958b413c51001c731e3700eb527816d70a585cf149863273f5ee202303e18f42c4955a791d98969bbb0236c2765b0c30fe04aaf767d1f71c392fc09c1c6232d439bf3cf5e6eddc8ca530cc8813569169b68d544df8a8a5678bc0a681bb64871a86539199a2604fccb27efc7a9dc85b507cdcbb8d214d68c9a5a730d681c2d6272c24c34852606a231283e537807bff7c4200515959b079ccdd9aca4eca3c272ce02ecc408facb8776f23a2a4e849c9bd79a2f6adae6ac87b2f8d5648a425d0823455f6e21fa4a7de690488ac65936bed8538142241b87d7e8f1c23a1c3ac775c3548d17381262d04d85cdd1d89d6529d397f969b4531116436a9b02299ab07a3fb4f469bdce5572b6e860ee80cc3689f3dd9f5b4db7d3c48c018e69e94332cea74da7703f424cdb3c4ea423693d4a79254e041e36aba1b53ddb6a85b9e5b6693d816aec22cc3a6b18ccf61b7b6c9fc7286b5d2725a509714c87cf747733620f44154f7ea041a0fdab5853b15d00da24389ff8ec078e1684be8f10bab90e42dd76410fd913fd8943cc019962523326ff6733ca7ce5a7e64cf85cef53270ded8a6bb600b38911ff3d7ad8f565950b78d7ba51cfa34c15e67e41c196311013ee95f82db3f7562bc0e43d1c66c43c1f9c4e5ed5aeef5cb9472b44fa5d147507758ba7c3d487266977cbac497981564240fa38a16e064e9bc2f31ffcb5a77e7a3ad71e0bc4b684948163f8f3563b1366da9c09a2f7da8d1d181778036ceb1f18c7d12be165672e3c5cc1f385ff404bea652857f20735dac2a00250157b64f4a34f62914bca11ed1f66ce986405584ff5516a51e5cb538859aed0a8d097becd8ec09a4ba80841b25336b6aca91cbafb562f2d96c7d5aa7013d233bf86f77ebbcb96105539ed3d54191747f3d0f5abb93480f83b7501bd27e9ebd0237c0b60024c5801a9ee3885f7032a074f48788315ae6ecb9ca66648d5af5b1c4632c6ef015930b243f9fc310659b98b75c13aae733ad74a0cedcfb1987d905446405344f5186a36f0540864a224a8cfa09dde7b58cec9b87869172b803bca3670816c80f2240f2c6fc0e1a85535341af4db04a5ea125b9fba95bb3ce80f9ea860d07e1a3efd202036b63b4ccab42de6764abac537cf5eb85470113006792a551ffac81182242a0ba1fd1dc8499e240012e9ad1280e34d53bcfa6c407cba0f6d16f1f2bf6b2c7e22b164c05d15dcf68fedb218996e222f96155dd0fc5ee4cd5eacf1b1c95a854d262ccedfc4ddbd7977861673855f6fb38cb20776810233be6222a6e7c370fb09709f963107a571630eb77f9b2d8c9a63ca44679337fd2179ed45319f7a2188d8ac5cf147b4e8a5138f0267848b2e623900524fbbb7836e6e32270dfe3e284d5bc9a8f507eb74f31eef8549a9117adf352c0212d1036f8ca7680bfce98da6acbbb59a691a2d482511b1ce25fe4ebff480ab0f4413331b81b2be80b18aceb1007d9cc2dcf109cebffcd295544610b72643435f2834a15ca0e0ff80d75b869d62f42f7027c62c0bea0a7de89b2ecb3ed24fa1b51ce38da02a59adb0db1e908a680b2493397a0f2bf214b29799af27fbdbce9e37b870bc5f2e540d7f0d6a0bf8ea89b20ad82c3103378592c21943a9cd1e52f6e01ba35956ae9e108706a145a006593a158333c5a685141a9c5a49e6b93bffa4ca7941fa600d931ed1f37f474974a436986f577a9ee3ad21ab4e74e588145e487857bd9e1fc5149149874271340d6e3da40bc05414ef71c5cf19c28a71ff2b78b74c3e54c2210b5484d426eea6e4aac9f8ce5482047bbf5d1219fa898fd4ea5bbd0581eed6b0c901458eb2eb9304c1b63c6e4ee423b0b76ee1959694c5f8bcba29bb9c439f54f0a8e5644bf3ffbefbcf690a7f9b0538fedb76ef9decd7c0a3c081aa4e2ea21ef22c4d484cdbcc8e5c37e00b0715903719f7e1321d0ea84858de8b6c48165a0084edeeb36de2583f552fe662af1a223a689b515e76b7a4c28408172625b0e0768ddc4551df577b6aa96335ca9e26c0202274e4a8b28b09094ff6dd3343c09754c4fc28cc4dfb555f6232b0a90014dfd1e530ec55467f8e0b987e3a14423a9521c5c56be300724a32959aa1c1d2255dd446abcca3d570fb14f2f02ae8d22332c974f38775832610f8e9d4540e6f2a03cfac4370f5d76c0b115104fe03819109e43f1a7782270bff3ab71e92a60dedd84e6b67898418678840fc017dfd1414bbb7168a5bf30f139e791e7be3da243565c8dfe85814f1f65e7e61cbeaf4917565eb852aa57a407d17cd3c828e9dd33107a871ac6d318dacfa533f953b70c94f4e5fd9d22acec50148a0e4f32f05c6612769515445df3dcec12be0b09803a354e26057e81e6f332ee77082a4bda7b2246ff005125988e5faba389473b2084921fa0c60083aaeb50331de04d4fbbd7f29376916a8f9a89c3af753b6a4fb7f99ce5d516b7c6b7278b601f5f65b5001ce858740505b830bb4eb824651e519717dd4a8ae50c17a6d776a6905391afb2a22b8684729e474970366a60d186d73d17b1137cfb02dc14e96e73484bc46794b80992834129063a7ead254c646e350928a73d6836d416e29b86d255e27a4795d35a21747ebee7c605102be6339b033e369d35c5b7c8931a97c61e9331652bd78db28817e146be4ef199252b285b5de0f99aae4e84f4919e79a8381522d2d7f8b6369d48d6c79ebc78adc32bd6afb8501f856be05812cba35255c02d03cfa75dc2eba117816c9707a8d90351e2ed312e496af1a135a8f4536c23cf55ecac28b0dcd78fe80469cb2cc92206382d1a2b0eeafc53361b9c5acdbd035781cfeecac845de29a5d83a1b5e4840c709fc9df4e316e15a0bac51523c8bacc96a3c7284339c134abeb9239e4e121fe8165efc6b5439cf4902243a14de22b6341ebd226f62bc9c97853e7c0739d7c6ce27960a6446a69c594d62656d51d13e12f84cbce182d65bcae8d9492cfdb95c29529fd8c1244f22a12deaef4b652cbee51633cfe95fa5c3ae6fc1b6b90c27b5f5ceb52547b8937d0c7fca4d36428e5bb5f5e341b6fe811c29d7ef08a27b02b0eb184b18b36ce12d609fdf03a16d6cda0f0db31e1ea775563896c357cd746d3a83cd19b6f9dc87fd20c3b40d7810d39407deb832f8477cc8935f3a209210e643d885cbe08ce462e66afe24bc8cb5dc30993b52c3ee0b85bf8ce6c8d4fbc6e0b146de53a1709105f6868a2707acf847d109d8d7b3629d828581359ddce4c0f1b005d5944d3065c6a55e077a92d86b07bdd2ac7cd287f511b42e039db1bd0a3531a0d46db29cc1b8dbe3003bf8f6c76ced050e6f0ffc91e06684562175445b4c9857ccc7c35adee5c2b9eb03b9e88fa587d68c1b58d8458482b6aedfbf315123fcbbbb7219ef0a3847ab2f7c438b0dbc51c37b49c83c84e8809c1b854b5c249c75b3ea7b0ff55fbca90f0ad02c6ba9e27b064a49c79555e54a4a1079f2e2d2021d7124d0d9f460be00121946027f1fef076e488f72138c952820ce1e19b0876d2191f9d8a618a899d6e3973c43546234d939b58098642bec414928f609729acec62a91063901334aad7cef9720ead6c51ceb675b6c546145ffa3456b2aebc71a958b07a2ba6c4fb914f71e823f84483ebd69e8e9851cb897d649139b61acbcb257e29102742566043198f054d65ef00c49c41b83177d99356c98dd42077d81b22bfd32c19fa6c0420d0160ccdc3bedaa6f399116d55d837ec05b67deea8ce9b640759ebaa7d748679c1ec6ef3a1799222d6b6ce64f18ee69b65310bb5803dd6bba2c5d8904496b6770ff6723e6c23633dd5e4939aacd987df7ec5bf251b3442b04288387939aa33278c757fd7f72bbebaa6a613060450bca85ac34691bdf7896d21782997b629782fad574ca91da48ecc85be5ec4b267b52c434766ab69de2ce60f8058b1acb638832104b2a40189b623a97334117d5e65d6766664416170382dc25b0f7c4e64eeac68e9770d85c5b649699f4e2db3ed66ffbc72f0ce6df79bdae4cc63b1f6b391992ac99968baf638ed2e0f830f79a6db61bac0f3027b4bcbf82d828cbfacee223514892c31fab3e400d25698b39dad22dbd69d12a799d73ea95ddfb5fae1cd59e46228ccbe7bd5e4bded7908684f0ac70a145014639819dba191542384d2f644d710b0374e9856e4fc68fdde1ee3c5fd4aeea3c3504d39883c38cd63ff8a4453cd0a7d2f7b3f6e44b9e84add33694a64c9455b67d3ea56f064beba5ebea9612080a0a389cd620dca260d65a4f729b35a48a0933c443af9068c5c72c60dd2a0c262092e80a113e44817e2d878856f587002486fdd6941d07b6adcba9654cf6282501f628161799a51c3629133e6f36c5284144099354be40cd789762ff34744bcd702a49886c38cf824fe159876b3d1134b0a50e28fd092ae55c16096fae10d8e60238da67de626e53c5be0bf84d0293fdf27445ff09ce22288630879b7975b4d300f07a6f37f1dbdccc6390c0cc43626bfcbac19ce5fc60cfe7de615bb09924d3418ab0bec46ca83736d1306a090f4a7ecbab09aa5ff931edd022a7cb3aaa93526a0ca857b3799b6600531077b61d1ce307a7d22e5a5859f39a796b885d7e47f2fd970de6f547927e49a57570931582669e213ef5eb245b5073fec7dd194be581b58d65178ea05c630ff18692ad3b3aa8c9ca7268370e357d4cd7c6032461677d7f3128fc7692ce9b8d075e7e2bf7a198b9044e8ad0909fd89c9e175614200089c716bdd31d0b0a7a5ef5e3a4cf07e3ec34ede7f2701dc3817de98b54795042f040e34bb8aff55cd3b7ec6a5550f64ba767ce437fd1c104d154963f14d2924eabdf80f35c39d440451b91d5e943189a7df782db3560ad4af447d35f98b53598eb2a6179eec65d0a92ac06b7c9c8370fbce874dec86655aa89e258c7a7b01b3507a959170f3378f8f9f5b57a7233b3a36b6fcd7dddc3cd2f6bd22077314f24d42b4fb636c5538f7773bb6f9ce2807e0afac04f301fe6a36b213e7aca46933e6997c167d12fcfe17854e71c9b690cff471d7f25fb2f86bd1f2c1d3743c278e2062c44671eff000529784f6f6592135afac5b5a520139643d57a5586a8750c2b84bfc92a5cc29f5e917054ddd044da79dc9f5837c734e25e267fa7123a5f1a721f226c01cf09c0705cf7d7c53e279627e61a61fe2de5bad9092eb813a4a3b6ca873545c97c3f83466d0ff91670fe13cfbe750633273b5d35256cf59cd9a6bf32564bc240188568952b802c9c1c24061621e2bc5db94ad8959241c2943ea947060bafe618aebeddc8a022d73151a76af96ad9968ad15527293080cd0252462740bbcc81f74b2f5de15f4e497fd742c42eacedccc3dec1a570013cbba4b4847aa9f5acd36d1cf2e17dcd3a716632c5545bf7c482ed7578d71250d7bc8936f43de69ce3387d7a82700fe7f6add6d910c5d39035cddf642c8acb8de8196ca17cc006c0404e261e60eba2400f7feba7cac74b00254e8ecd04f3acc3d744d58e46c08a9a8f7b1218062fc6a888b9f48b321351d11375eb69661407a76b4aa45e383ff07e89c71abb3493b9bb580d8cd90031051cbb8b9b3066e161d26c121dc17a144b6d36d2a05e16f6cf4f2b37c35222494baeed88538507f244397bbbc7a9542fffd34eca4b702aec2966fd2fcb1fea22d6b39d7c45866585e892de0a8a3556ff4fea7a4a9e58bc4e7ba8cf2b7422915d5454932215eb2396d21fa7834a66dec0416ea59d826b4a603b32018fcf278f25813d5a9ae2c7b35f2bd5df42ccf80699f0022d5429c8c441290662ee075af3b1d4b855bb0f739caa8da8e44710c0bf80c043e14577394d6fbbc4d35a5b145bcb28e11811d9ddd146f7783d33c4f95ec8609619e6a0cbc8e8eb78e0baa227324ee4c4ecb2b81ff2b780c799f457a6710de11c112f99edd3406760f66eb7179f4953a84050f24efcc0acb4b34e979c1e20dbaf16c4bfd5cec399ea218ebcdeb087de8e8bfbd33f58489eb628c63344d59d0bd0417371c95ecbff8b790e59db8ab9a9bdf061934a9c5eeb1fbe8db4f5449c060cf5d957763fb85f9c5f65a33057558c9677751b64924c8d051dad0696f4f4764d9054ebe0b6b8e649539c7cf37392ac100d4b47172f7c76895db2fd90a7ad69ea50f844799f943169f253a037c59426755334f356d8d3d1dbe7a8753d11f2db5004fc23f8178bd51ceecf012feb18b758e1656451bbea54a0a70a232e54123d7f1e942793564d1bc91f5a76c6cab24caa824144cd5d1d38e064b47c7e157b1300a37de4908a4214f9a7ea9449c448c535d21368dc36742a3e7467db33f01990e5cb5ad1c0be64893b6e74f7a8a56596753511b52381a621a467fd07a420e913b5ecd9490a93594e3975d2b8cee801ee0d6a3fefef07561b98240c8bf714d9b4937df600567a1ec941c27e9da43fb1455dadb68bc3ba08a2dc8d02b73209eb23409220454ae3acfec1d939b07a831255e4491544d8dc55808ffe5a04cb89bac2d48270fc7aca691d1a75922e079af0b3dfe34ca78b0794a0eace7bc3356ec3e7fc4e95b768c3c1b8b1dad249b6c00e7ae08f6cb6fa8fe99d4bfd9a49c1a4148e0fc154faab5f34cc5430e705b1d2be743813ddbb36b18ce392c8da8e39fa9b53f808bc3d92fc6e110428c65ef525c04681656368455d2e68512fa1d04495209fce1582f8dd446ae77a43b372b197aab49f5bb5578084afb8c4a3af50784420d8ab03dabf66910b3498d42843c7fe0af671a25e512c6e26cd607d14b38da94efd4567907c0baa48ff8752e3fd7da7e4637d270ff0939f0114d7ca6993d3fbaa5596b0f1781b22022acd5f7a6bab551b655af4d7f02ccc0d9a2f8e037dd021b90ffa8f1f1f5e828c5f6e8d5763dbc5602d7495fb6d769f2414029c683626bccae9d3d51beebf8ea0046b73ad5d62e0322db680d9f06db96919bde3c6a7d9855911fd7402d1ffcb20bb47a07f7b7b7d595abcf11ec5e12bffd7451f73dac29b29bf4c3a83c20a6fdb19d01538ac8630ecfc4ed37038086922f79e6567cd2a34109308a27ca10515332ba8bcfa72a62b241951ba5cdfb9d08e18c49222e8ef69d2ce333ecfa668a1e4d27fcd49b1de7bbfa3c3c586dc788ab9078a0228fa9bce83f227d8eabe47a343b880b97116649ddfce76d3cc6b7f77cbd8bd4ddd9ce7285200671ce0f6f02b233914dde7946c54cc2313a4432385e3f2b23705075c6c23bb3c9b8445c8630e1408400be2dcc69f937a2b1d329e77c2c1a52fa170487383793bc59bcd59a9b3b744ca30e86d73b998b772af39531c6df0e86851e498113a09049fe595e9026236815bac55330a5fd120d3e327a87657b868ec54c5892e9ab1a3f0adfd405e0c9f8054d7e08df5198e139f9ce4ad4f170bc43a7b88eb893521bad68e903f81c936b9ce59b6cee5746ca75d0c2f6300294c3f9ce4f024f762b7ce2a2dbf81f4e54732cd8c4f2c96f19670f83ccc6c3e5b7b58119901f918b08d0487a01c501216b94d00a1ee42c7be94da443c8985fd9710b52fbe46202b3ce9f8a40947390a4d8b27cd4ccc1f73481eaa98bafe443fce6b6dae5a5b0dfa6818ec48c290280d442c4a014f0c91a073e431d3ddc8d2e8e5b214cb296c74e22dbc530132079bf3ad756ab273da679ff165f08d05fd3f5bacf51e2f957985d812ed4cfca9deb32446ca603c6ff6c9ffac726420c6c1dddaaa66d89497f4605f414fc67c0fb345e5d616299348bccc08dbc00b04aa20a73467dc833472866326466a139f7a6e179b6aee925dfcd6ec0bf7a253bb49d7974b116474845dddef71db9105da973fea04297da02b0080fc66f7c0706c9debf06637cb98399e30b71ca26220891a73ee231b19c4fac4b71f9579c9954826345608661e5d467cd24e2f64b84e06f6bd9fbae30d288b6f85eb6b5bdce1003c938567be220947b29dadb0e203e33a446e68da09b3ec437fcbc19d55d8d4fedb62ca174e0305fe3f9178e8f311d34f1cce03f479850dd35a66bf8fd25573bbaab3fd07bb5dadfac9969100e79c20e45d0f4c745ee8c46cec7486790a3da3382f06a793f22b8a26b057d8be8408eb2b2ba20b54f8cf3fa3b7429f3424c5c202a5e1d0b0ba2dd759c80982cc400519cb22b6bb2be674ce3baea59726ee0c8e40bc341fc7598b0b8664f04e97988a563cbc32b9e33eda22fe56e972ecd4a3060f2663aa87ae6f2ecc34f39901b9ff949cbef05e516cabc8169a6651ac921264ac9c5970e78ce40fae45f04b64ea60960fdf51704ae4456e0cb8b6506cacb9929fcc77f549b50cef4853b73a0bfc6535b1ac2ac26fcc0687159eba0d5a971863297d79b8429552182def677f2bd5ae7a0b1ec49f531afd84e9e20c762a382a760341774f014a40aec78f71c30351d098c5fec096e21f915e827dca815bb1010e0b0d775fa5b7853fc59db5c74abc6523d1b28c080ba4be84d6d3801f422e216374bd24b8c5eb619b59a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
