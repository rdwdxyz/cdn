<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e013f11bcd155be97987edd362f4c76f4d96e031f314a387a49c866900e6ee3e6c3fb9917afe5aefb66882fe4017d8804fbbe5365aad979170a50066a23219f1f1b187737d5fed130429769a70c34022affcaaa8eaed6c8e9f8e83be279e5b4fb1fca03af6a90680980f1510ec33f5bec5fbaf90b8ec3d2e5f8a5f03498447eadac46d7be043740fd54ed6fdc5ab6cc0f2574f2325d13698bb90886c2d729254e0a819b53bd7524d2ba9af782b0f685ea4161c97bed7cd579b4e99afd214c63756237f6eec8606352eee00216120b47393cb3f99f987813640ffb613ba51f56f7884036994f788c7f2207cee23f652679b340343caec11b3e20998387e50be82a141b3791da0546df6f71fc9949f84aae33ea74f8015543327ef7efc3a6d23b3c762f8273e326a3298f2f9651afe68ddd6dbde39f46c0e2d655ade814c445a473ce831fa90894efb10087dfdf8af5b65e7a91d84d33713b665290586914f32a3da6c5eff7095ca84febf204154c2b3542b230346b732ac469052c77d2bff08af290e975d857400033374af21d733350110503952f13bfd93c38841a6a1bc881a1db1cbd9b4ab2877314e6103e21cda67603ef6517d18fb9cd6304b072c5f46e0711701c81d11ef26e37e0eed7e83284d932c3e441d9ecfe115ea573215692793a4a6d68fdfd863cec1a3e9a91acab7ec3702d2b58901900de302d76dca98ae9994b012bef126c0bead052db9f22ce97071df41b270a8807a629acf0eed43d4b350385a04a70e4b8c722457f518db205dfe43555d87460863813d56a4aac2e08417ff46cd8bddc9419293fa909d341b4c4a79ec8bf208d72cae4afabbbafc090c7149a4651439a66dd2656d255f0ef28fe70831d8ab0ed31f949c9592ed00b644595e881bb682fd67c210262848ea77de1a2197989eb649761b730a0bc0d4dd09d5904b37c620dab710a5ac26d4d401ed0c94281c9c73d255c50b8e5ab29a528db228d80628edbfb1625ad0009be9bf773a899a7c98263dc5fe6f803357d0ee432d0af4598ff92513edfb670028d32353887dcac94949d3f4b310aa732268f1bd43c6dcb538bf05bbf78c46e193e9655010ea92bfad8dc3014ed61e6d0989a3a0ab5a24803257a22b65cfd665521de5f87183ec542e628822cdb80c6317b81ec70c20357de5400ce10a0445c3dce42a46f4a9650f231a2c5d2b170223c982a2907db427f72c72e95723cb631a45473652132043c2d6bfa9f7aeea2e30fd9b2086f314728ca9331eaf02de4b864bb95052e7d8a0b9b69ea82f52501d05aa7e0b1d2c39eccb92a2ee8213d26bd6da773aa37a6e34892d4a31f0f9f31c138d539f08f5d4abd36230c9451fa24b263848a11e4038befd6cf3cfe032c3a1c5bdbffbe98ec96e4bf729a0ec1bbaaaf20a8703f9e5908b4d4741b5d3742767ded05a717c88b107c35453b3eadb290fc948d1685f1f194df3c90ac1e1a5972fd355c063374eb70170830bce88f8cd78128bd3f3e9d52ea33aa5a9d38877bc7b0ed1b4af0bc519be1172b8db8990d5108e7e02fe24f9db4097e33d8f43175ee94808c129caff18bfd437dfa56a562bf30e4bbd801e49cef4303cfc76c6b0bf8fa1fd650b371b074223d790883e01ed068741c7e623f89b955748665ee4afde09b9769b42046f619bea765c11382680abd6d82b743a7ed4c7bbf2ae2b2831618a5f9d3b65742d21665051812407bba3fdd29bbf06a570e74b81fc8f6b47429ab7525fbc046a7a058be2a5ac0884fc4faec0928747ad9fa05ed94e3cabcf1cc15ead5bbeb70527197c09f6b73fa3c292a3875e3ec25eb1224455bb44c712aa38904628610948478bbffd251113861d63685e60b0f81c934d90ea70c1129b84110a0cca0fbced3dc4e2dd356d738710690284aa14d9e6e0af8be91761d19c9fa13c48f1399c75922b32427e296283b9f33ff52c0eb2533468f64514467a6feadab94f055e7d505437e2a457a38da8c50ef4bd0b643bf3ce0e33b9b9a7c1810d84a91be0b2789619bc88a8391e0c2c97e4a5afc3a2bed6bc3edd082d861d711dc5437decde8508c5c865bdcef317808f783b7346a36bd9281b1ddd37bb56dc71c0fd11ec2145087d3dddcf0752d891401e5c8c81e1b5caf79c9f64976e5440aef4d0b0eedfdb83e65e1857f29875ee1196e6c7bb48fd500b4720d59f9888be1ecbb8db6742906c07a3592ba4a7a2893e45574e6da5aab760e13c32f0c7a1a21c2a24037ede9f7cb24a03cf486d6d2aa157393dd9077370e94fa72917e4517a2ea78f8aa581a711d14cab491378fb78e12b6161765eb89ac0876c3fbb0fdaf0bb0a57a178fb0fc29b5fd569caee40a9ae5d8f19193b2764a22648ad3d4a04186c3ad2262e820549ed0510673f6b5930315d5e013ab0a216a47d92f85c4433cfd28b07678081b95f74b1214ec5c6648428ae4d868603b843cf4097668817e3f7f9b447771ad922379ee47c62fe17f866ec529bd411bfe63f710c67530565096f9d7da36b6b2d0bed9d2b25cb1fa9da206c291da1d9581202fe9e0906e805d1300768d41d1e2202e34c1f07b3550603fdf984547fefe16a98173b1a7127fac4b9d43f90c01a62bf9dfff29264e9382a1a19c041b2c164b68f029265d5b2e3d3ce8667f88efd09dfcb400f3a73783538d2000fb75cdf8ecc6655fbbac8c1863bdc08bd74caee52a1b902c68e7220661dea9f2a466658b2cdbaa5ac83c6c0679f258abe84d8641aa78fb6cded4db4163f2e72cc5fc870d798afe7fbc72b6e36cdd591c7530104a6ab7348ad47e5fc997770141434797730848638d82aedc42793917b9e66c16d2c56adf98a71c90d52650c14c5eb54f8ce8ddf9e8a728072ba12abf7cb60be3e8b0b4813caf71da6e1991bfc710284788b7636deb32a64e534a44a47a5e398982541f6c5957721cbd8aebf847744e75f59bf5f0321772136297eb1faf13eeb9fd0f55401b112edbfa8e938ce7d8ee761df5dc963d7bc9bb8a0014f0e1bf4c68a02c3f35b478924958fd81ffdd2490151b2b7b280b55c21d3cbd3b174573a7558c42dfd8acf95403013c81766bb38b54a577bfca657d7d288f880da5ce33edb39b712136b33b8df94645277c7c75e5f650623c4c58adbedfa591f5bab8e090c872da33d3514377a45ab1e9af0f6722574266bc4296deaec6fd9c4fc86d9a5399ea4adb6f312f9bc510ece41d37c11c6aaff37460575053b193ef4d46ec034c3864fea2db605959db5221e55f63e19444532c2a370b765715ffe5d73d339115c49caa1cd6706103e370457aded900cc3fb450b9dcbad5330b2cfd16e9bb2a3cf5d5af295b2e945de43e440cf3a0fec14cde8eb7126c6f384cfac5eadc086edfc6e6e6f07c24bbb2bc628606a85318862fe99bd8747e057ecbc6fa57039ef773e875caab6127be0c4f45ff4d51eb927035787c61daaa3d615944907c8246bb63003d636fc9ee6e716e7ff66ee096417fceee482c0227626697a8408e6d3d3de67ebe15f7c72a2b2d4113341b3b03a62b3473c65203d5ebdf4f80f9b8401a8676cd0f9ae700d6639f20e8856692ae663721e3dc31586e374d701eda321a5fc66c190b5601c769fe9af4c06de5b6601001dc7dbb21312fa5f18da3852db510dd38ef79581e7291a13aaed1a2f8b5380b573ea1f41e35254b051bfbcf57c8499e23693af03d4628e5b48f3e97623575a0f289bc3cda3d77833292779cbddd82519075e042548965488c21643354fe05bc27f7db2b58e264b7da6bd7ab0d60e6d9ddb6a421ce49910c849c4126cf9dd0e75540e8b27881cca3a354db2628f11e63c87b27bf0d10de7954f92f16af8fb00aa7beb73a92fed03a7bc7f4f1d326da77173b55f381b8b35cb589f8819611e6d72f5ed634319d23681db359838e393906f73a6e6c8dcfb7cb9a15359685275eefdd4f31841b7f746ef8400dd4835c92b3e7b932c27504eddfb8498d68a9635dcf89d597249770aa22afdcd143091ba2979034c53f3212014633ebfce69f26fa679f616a5dfcc2476e7480354d12dde1c34386de7ce70c561bd9b72a89638271e878bfa922ef18763385a3beac5c8f29b1a2d2010c68a4e65afda656c3cde9459420d392c9c01062331bebf8b4ed504b39ce3858359b4e6ee6586d360499c2f28fae6f1c606e374a7ac3e120d0a5e4cfe38b1c4d818f577e815d3388b01eceb85e9212dcb838d7651bbd218c6ad3005ffe4bf30bbec0ad810eee93881e448f388034cf99d5db7fa15c633be76779a58416171a5dd8256676a1144816c7361d8ac825b29c86eab2e04d5c97b2d145f28b495eac050f0458f53acdaeaed0963ad2696743d02d43103ecb6510d1dd37ab62d96b958221c9cd9db1e4f049dd88fd61a38296af8a66d2c657a60dafd0a7e8af496dc6cbe4e2a0bdd625a79ee05df74fae1860824d814754cdbeb982ae59f5276fe7e898d8f54265ab9a89a93e4c58a38a4e00ae4c595cbdee9bf175c27d1868f209819d455cfaa73894d4d55c44323a1a197ac6ac94029406e9e9dabf80475c2d69d493e211d383df2f9196e270125ea2108e5c811d7f9ca77ce0c655947377a52f49d5954fc56fbaa934398a85ad06f7c54b4d2afa445b44ec6f2b9b399927529c3a3dafbe361f9aca49ef4fb22bb928e6145cb32e91eacf3d9d40626af71aac1066e14311061ca011437c7d4442dc0a58b27aaf41dbf16f4a74e2a66a396b3a09961c2e99d90e605ec3cdbf2b039c15fcfb66ce16492335fbd85e49b5c5a5f7572077dbd516370453ecd20d2267533fc680aa0185b990ad11db7a3c9b33e598a3b406a025fd48f1e3f7209995c2276dd152cc89d4889f53bbabc91b24ab8429a721f54268dff82e627a1e1f7ad4130ef550b038a96f4a438882585bd44b1872fda0b171f4533214f0d3faef2941a1e1cccb04c375611eca8ee3b0a396ae8967fda832e407aa09889e58327ed6c18b5aefe270b847c9ff81a2e801eec900c07d84711fcf987a7021d31b02d6f9c0bfc3a1440f4a36e39605216b6cb03219d80b522010270127bc5e12092866ddc4d2c7bd1b931f8d15295e50862da52e820945c406f54062883dca640738ef29de1764297db4a5894adc60d7d1a28b34c8e7b3cfc775639dac40c350846577cf8063bdce63b5257d63206fae49628d594e94816189ddff3f773c853c5e60faab374a673e47537ecd4c5c264d0dbc87d3ef4bd2e3027bcdbf138450573fd2dad6db0cbe25ec089e55e4b7e5c04ead93ba053933ce72bca96759144957e1d50d37df1662f542aeb677bf129c4bf12e6d22b5631938b0d7113949e548797d1452a0db654cb0827d1adfd17e94b5a099cb2c47be4a332f01e7b929dd5b2df0e49019b3e3c7bf2eb27e69e2ac1358d353fb0093ab6d55b51c73a9a73fe0aa440488d85d9a05a3849e88bf3d7f7437cf06737f4c0fc71848b8c89fe11840df342aa29e712e4b8dfbc5141b9dac5976f149e4f90c7518d5d0c835ec7c5221225f056fd42bfb999eec98671517a6f34be4f622d77f28a36a40dbb10c0f4e934d67846b5270ac2c1620ac38ea9e01e4751cffe19535eeb0e4c694ef6d43fc3782d5d81a4ed063cd06656cdae2f98f32b6e2dbaec246984551b3d34cfc3bf99a74675d6530666584fcec4c6072b290c50e2eda5137751e5bf89b7a9810d722ac2ad7289ed5997c87c3e0df2f74023a1b4ea6aa843e02011a1441ec0ce2341e8176202c3e01e4350d09cbc4fc6d038153652b6d2d462c97f1397db363276bbe64e41ceb69dd9f33ad2b1dd382df153a33044322e3ee839cedca2c37f8a483dc8b59700dda733320f02c35b715b2fe9501f11720d98ac01adfb60ff726de77ddbb3cb01f8188291c4a4e4a7c3f2025b78464268912b8445c5ee99d8dbafe27bb6cb091190c815a003954266cf4475dbd190592f4c28b1ddb2dcd43fbd8b621a6d5d7a73398ed81be5ce2b3d642d52f769b1281e079d078340f41f68c0478a0e22476f710afa0c2263b25b227ba2ef46ef225fac663e338ca21d9bec68efae0a8568aca21f8515dcc0e60b3a6f96f9ac88b49cc08dbe34f9b6671e5e9067464ce0f26229a955b52423a7e651674625e950af164df2c95919b4a3819f96c5dc2b34e21ca21e9b3657bf7273a8731c1d15e771541931c3a43534b95ed43f6407dda5652601921b343148387e3c657ce35a4bb532dc28e521fb3bc7b52139361a6e4c4c335d3883312e46586d9e29f640f425dfb4359a0db5f7d6170661223d4cf9a6243c4d80186f5556ecdfe95e5d86d8de165f761b8f4b6b93d3e060f48c79ce9d972f4adb1cc62bc97bc6744e7c3b8bbb70ba9871e4d6f507af6f5aca7f55d29df2b07b10f9ac926e447cd5974acf791f697b19324ed0fde0c4eb9256c9f13862106ab01e0111b7278fb3567298df5f54baaa20d1826ad6266c160f19c6965e2cb015145d74c6389515b31d8366070cd32e767819667f6497f4d88c3e2f587893779334560ca6df5addf4f61dab6ab57a6c0e927a996855be346d958c8d744dc29c8068e207509c05f7a92c2de096a22fe34ce7cc81aeddcf3fb7fa0ea84bc36b7e10f1fcb5134d6b509e198ada2804f14bdc10a1b843e2be40fe0827f8da6bc4f1ab8d7139733f0a2a9295ba7e7ecdd48087f03b98b0cb3458210e7209f87fa699cee7d60d07740db9305e23bc519f4ddaef3c9b4f526e432115719081fe8449d53802c79f063bb70ddee1f29f009c64717e9f3866a881bcd09a577b30291f388efd0cb865c4cf24f4cec963867caf3afb8b51b2c14c4b194b78c9b43fffe34efbf1c59398e1a77ed1c71aa384c643d8c577623a51ccc88c8d87c9d406437159f0006b592d03fee410414045f1f119b6393116a90e15df771267803c2d33db36b355d8bb145968ef7b60e2c99abb869165b9736ea451331b8a4201642be73de2ff9142f5e2edd4800fdaf504ae3e72247fb4cb8d0deaafef4158c0caa33e336678e75159f67aa0f109aa6a38e0bab109b473f1b0974d81883339b320075a785416330ccebf7da4a71f301a32033090fa8470612745f881a2264909f0ca3fc58aec44eddc97f76c0ffaa08fc2225b8607801adb176c086f977bd11649b910ff32291d8e20db4297b5158243130a0459911bc16ad33463e1d3a95ebd2ca70b063d8f1e24c19dbf045c722f45ffb27079859752bfd0ce65598dff63c04dc6f94c688e85ad4cd5e02fa0ef0ea9772d9161b4430c494798793d382233ddeebd372a6a554f65ad58ece4e7a2567cf18c9242a1f98fc57ba45e26c8a2792bee33ae76944c2d2d0daec07c42e325fef76ccf0ceb64dfe88d3d7a4eb4620553ddda73fd25bdd3077af3d2e1e50822082705ecc93cce0ba1efabc9ee064cfbe5ad4acd23965e200c77c8bfb7e48296904550a4cf51b49d50f417413b76e4a8047766b714d45610780dc47fbfb6a6bef46647f5df5a91149df8f2de888ed67d1d5847563ed78f5ef329a50a79597484ca3d572f7401224049b2162fb04d890a3325892ba3ef5df4bcb7467b9e75dd5841b0b83f943e722c853c8edb631ccf46ab367b9739cf1746d3e78ac71ac13903f25ad33ec1900db3ec02f41813079f3e25d5badda7595b1592f9fe02147e6f6abe51ff062e2d59f4a15cb49ec910504fa87c0c6f38e4b700cc4fd36fdb43028cf5799bd99a0bb87acb21f7bc1862a9778108723d7b0e55d1f3436e080c6be5829003b9a98c2b5c950434eaefdc420843d752e46a5144203ee69cb87464713f4957cf562e63eb6d149a29344b5cffaa6ed709481e9767c36d46e9a8c69d1613a63ba240fd80af946b237e1a55c2edee044153c184c6942f116a762f4af746cab8c03a13f5981401e6357119a25b526bb3ee054fcbd1cc72174d7d7b943655adaad26d87d365d1de06d7de2af295a271814be2d13b0b134b70ca66b44a9f0d6d5b6525acb717331e213e09b881d0c82910b6b1823328d524f9f8c603fc3f3e1a1811a8aaaf00f8af3adf98e19444f578596dff728193b441f5837844a34489932408b59d1f09237ed8725603027243fe1570006ab4e74aa0398f67a069421ed7edfd104d7ed46b1935b4deac07e6c847f7257c8001db6b554a58b63081f1c850e4028b00ed14431dc004302058d447efded6d3bdf473dc5579f6ab6c46ee93177f3d3e238fae6efcf0a2a1ba5f9dc269399a696b62f5b900bb867bf78495d30c79e8bf4e5242688b10d0cb16a4e7708545907bf6889c94a432b18006e0eacb1e8bb69d4ca6079735cff9935efb63a4b90a3a5a9ac9595d53135c2dfe87568ca0682a4c00f5938817eece1537ae8d20a509c74402810269e23da84cd6c90ff121315c99df7681cb708da57018445e1519f38727394dbcb0b3b6fe9d14d545305c487869fd9aab7b14631ce9849409a66ea3bd524ad2b8812a324ad73f1e50e77e48863e4cd6c0029f6591cf083076ee2972cb161403158f726f36a4a04e4a8a1977ba2f3efeb307e31d6716d3a012b7752dcf10c3090aa99d505241495762d477144b5c72d8520265dc1dc0fa5a8eb6447a5be193256d0cc3146183a2ff96c236923c21959a0b483c07a098e6778abbb170e91c85dcde1f581f7e38c995acbd7539d1a7684c1ec92ed5d391d0ce4d040ca4c1b9079c86b5ac7a7f3784c799f3a91d2dbdb3701fb92b1e74e69896f67d77a5a1382b82d259872b7f8bd8f14e4adfd94161a019d8abb4f41d7f16ce5eb0a770ee1d9ed012cd2b6a51205ea397548dee2f80440a1244d7a0f73045097d8b5875c1b0669548636a92cfa9059a7c46d455d326ed8bd29d4488deb2fba8d8dacee27cb385b05d221d91ee47254c7eb38580eede538a69166ed07c7851e6a2c47c8da922ac6e1337b9a492f934503deefd586608f7d3af1801645be55e2b903436dfd9fcb5f0821f9fa1696b13fadfd679ba251f0660338acb70e1b792fba6dbcfebceb450051891c63a3b80a6f8c6f385ea423cd4e86a9a691b7a879fd1afa79dac35a8d13905eb53844e5c2c3b0cb64df47d0ed7b885424db80e3345fbbb2f3c6c4d93cb848eb08823948931832a8179a46c6903a49b827cb11dc22a2f7df02e4d2c0b389b6df1dc3bd9927d45e0dd2c9e8dbd9c86f5eebf2f8b1fa1d398eb3f15e28ae734638a594c5da788baff0654beeb9898cbcdc5d981a72a23790b9372967f333372dd65dc651643a82d4a766044da62aa28bebaa6ce435553afae619340895382cef9426817ba6b31ff77b78e0e08412f80a8b95a96f0725a3585c153918cb7f34f55f1a8a8c90f6a08bb4da03d284653101edc3952c89a6780d12cb0fcedfa0365b41981f7f53942b1e3f4b84fec42ed8f12c9a4dc490497548544b9ce682503d3667d8a5ef1bdb8b1fe9e29b3435b9c5d1c21e5ff5946665bbab16d04d6b4318de061b1a5cf152c6b5a15f6e6a0f575483630333961d304fcd33e273cc0a87037f8eb1af8ee6942a7120f7f0f5668c16a255a57f09c59c4a8e0872cc98bc71c30858bde5e4c4d082e68c7cf7256ddbdc1121df5a096031b49fa90ca65e49f18363d321bed6294664a8e96c81708a7e4b6005e62956e66517675c741a843fcc70717affe3cf74b68a8aee3844f8dd9d875cf76579614b1d11a7a87dc55ac25f0b652f3979ba7a81f633d31a274ca0a6b7f3c28fdf90ed694a45e65b3458af1198603bc36c3deba9c0db565f5df2a9dc4d16d508d8f11def737f7cd1a3c2f333460f1b1d1840f941c20a16691f33fe6a3dfd5280e76dff1a1b0f8a970ac0e47207c7b04eaca7225774a13e255f408991d33f8e8b1a6f2f9e16545f188b606d2f8c6d4f5cb38180d7eaa17e7231b8b43909ce331d3238759a56e4ff814bcde4691c0f40bc39dc73f214b91a6d7db8308e107ac231e3a4b54590da6ad10944edd0bd83c06068e6cd6f750e65e5847a2ba4d816f9e19df1c779062fde72ba53fd5f4a63355d168976573f0fbba7fdf0d8a1ef4f128899e530a15d58b30dad0bfe27996be0cb651f1045ff9ce7b2df2e980dbf1aad2e55109c22803094d278b42912fce3d599bc1e6d697fc134e2fa38853742ff4a7c91a7a4a482a63ab494e17c36a47a667347cc0c3ed73b2dd54fc026d9c004021e9e5a4d1551522c486468b7a2f3e5eed78d66337362f25e06b89b5af7f0d3556de0afbb5d8d7dd9d8e4f431215c6abd14a43a51070a089fffca80d695d215341a0901774e967b5514e9b31cf80bc6d7e759b9be83d96439e3cc5de1d05bc95efbb6d7c6c7634d396d4b244b8d9a3b3b8f7924294bf57872fe0a014f4f054384e46588de8e5c5f33491cc33db18550f86400ac0112fef5718c82d7ad377083a02fb68cf6f1cf5b615468a3ec54493e7de47f3f46eec423cdb933869c308280ed8d451e996d7133f3e8554978a42713786a7b0e9fbc1caf1b4710ef924e722be60d82501af352e365b525e73ecbc94737535865355df670fc1bdeb3c85b5b56d4604b75b2f75f30b6bf34c9ee1b51f0df6580f268958136b2f0c678849096a359d7989a70900ef84050d0ecc56de4eaae9f3321df7648c5e98b271d4c05bd42f48d2aee6e0caf926c1c584cdedfe59bb63be910eb7fef2926b73a92563dd51a2b2ae732818de62bce10948d4258990617f29e8bcf17697f25edc057f30ff3b369b2dd7fbd4faaeaec68c9d208cc50c5d385e371d5092798eb1176fce41262ee7b92529bc23276bbc92a10c3dfc2186d0b202473ca26aecd35189d0cab9b6aaa968ef1e2699ff0c2782f82b4e57049ed27ad3288146ca506fd4d35fba7970b7c6aadf26dbb63003dbba8ccfe880d8b6514b7ccf0aa0c52d3c6823d21a42e3d293b54db06fda909423e67a2ab242ef914a8b6600d92caddb2a81c9ffed503a95fafe39d7a7579e76be6fa9ac6881168a36c25694caa963f8995cc028088c12ef11ab4a6af9e34888bd17d5c55bacacd80a7967c0a6c0df629ae51063f479e2a2ed7690ac7cbb9240aa48f9e0f10882ee64da443cc264c57da2525121425844d91fc4d769c04c0862eace96b8c3c39016b4cb9e50659929c42276aa549a82ff1aadd9dba9fe0f7ec0be63b109d3961f3f58d9f085b97e70b33a4f83d2af25cc968ae3155427e12733c024f923a77c8c58ee28810ffa1d979b30db331e5de3bc5fbcf205c7ba7d07cb0b81c973068fc56ea4ef2c6df330fae701344a603bfdf8011705931c828e287bbc055af4aa87d97b78e9f8825132615d896bbc2b39a3821ae4e7032a37df0287b191d4c2ff6c3b74b1a4ec7e57a9b3ba73e8feb3623f057cc2a316355dd67a850003905e2b3df01054ccd59c503f2fb5902b913b93e87f754644e9737f816399f528c268ca7b41fe04dde89f8e41bc3e47eed8e3f00a8e88cc809d34e8a4f3925d28df3d3580de74245759e046599f6d04af55581938c849a0ce98c608ee6dfbc527392476f665152a6f4780c8d4e86e76a40cb30bf1e70a636275081c77953e01d1ffa2aa230e17780a2cb5ad59d41fe69eae7024eb63a74ac6e5697d7baa6682b4c5b3dbcd196e95f8ba3bfefef4b89a0b192c96599751bc138769054410b53e59fa9b88c9863b8d5ad4fb8d64ca786d5f2464e5fc69cb55d45e009c17de621606d894114ebef4c94beb94195e8aa10b7a08e9e2441f85f6eaca22e198d939e5ccced7e44c9e15512ed40bba680e9d40be4fb6ecc46a182984a4cab7564b5320660c3f4221061ef1af765679e942f5928b289b1e1f127871af6bc82f7755e7d136ca6bdba4dd58d9c2cbe9f96f3e396184a36ab8c4ec5ef20d99bf320479def1d0f8e6e14b949cd16682cc6a304e4f3a80a0f97b64957c5b159498ad78d34a58de51f04af4a88ad11eebe8f176f8c2bf5353326c94d2151cf3f0d8d923c7d255cc7030c0d17a7a26cbea4defbdd4f564d98804455a771a4d19da0121671ecdd001637938148cfe507fa995f789154644f5a7316bd59c237bbacae482d9532b1374c03c5649a754994229450dc1e3b1e735375e09482e0a02d951620cc363349dba7e9ca603d03bd47935b031a424064da37b8de507e735a1339c488632204da6a2d1e0de39375e1b4173f47c7b48b481ade7045cc5300d71abfe4f54f19746e3f55900237f01ff64d652b8a81c0ee5a8f08f7139f1b1fc281fc32c937dd8e4580fae4139b1d27597ed2a448fb6047a4783bfc54f9f18508c9c7f006a1d3d9456bb834a378547bc9f475d16a4d3517f73b9f3cd6adcdf8324521121d7fe6b66b8eefb0513730771aba54b44ea6cc0ddf6aefef4b5877ecc5527131dfabbca265ee63402b347b80be397915992dbddbee8649c0fe1e4c6928e44e4826c3a47908b2d1dd0569f71d3dbf172a3ffd37b3d760e3d3f8ede47bf709e363e5e4c7a34e5210b011ce4c62a55353688e0d1509d1bb3d235edaeb385b46e1f9ff8d81de85ec9e3a753193dfb3ca433cde51e6739aa10cd60cc319de657ff5397f7c15846dbe34e47fe82253413b0d53cde754dc754d796cb3821a5cd0ec537ffe1f77ad11def70c5aed930c2a339d159b4185bf47bc3aad1c07022cbe32a7a988cabc3f09ebd93589b7a9a85062766c2755f147df93af145092a9c42b4112f852457960629e6b68fdffbb5f56f6d462108bc0ad00ac6b951fadf570782c8547a8e3f95f6e5a88114a19eb38a4a4a5bf99464747b22e1b9fe7421f213d9a18eeeba085aebc7c27cb2c64d2541b87ad5b22ea5e940bddbb1dd8274c070d49becffc0e0c9f91b6e14f526103002fced335b0e7a10ac77d717edcf5b708e4a05433c38424aca4129398467364743e7c2ed4c96a59f05c8919d2e7e8ecea225f1b474dac369b82d38a2d0210e3dd93bf240d9fae94484b844bac330b792f05062146e62c8a2da9599c6dcc6c0fa9fd8466c558ae2f9132f51502e1c73391e0eceb27c713000775ad8f90e993e199d3e249edd754f953d639999a27c096f9fcbbff14c11644bade141705cfe866156d205ac98f46301d2da18feb30eb190a210fdbd32931a72c4be060d28c98e37a5f246290afa77221c1e857c6a1b60f58dcf10adecfa6f72bd8a77531bdb98bf6689e0118a19fdaf17023c2a45dae69055e612c3324e5108c0c6654d7e5e3addef2066ef1d9971a5c9cfc732dad799927e1c4e81e5578a6ebb67c4379455c4be48632a92583df2c989b4a5822b6bf6695dcefb69609ba2016445d7dd57ebca7f8e8334801e638a6ba12247b674f8eef5b5cca173bc36bd795b2157e44b0c206e31eb87a58d40c4070faaad2d6e44d131647630662ff6162711fcb7b2584ca02c15dfc42d837eb8ed342a516e91f4f4c84a1257be5bb60a365e15082f5c4808913af04606986f47905bc3467eee1b90b83eb942209596a336ef92d16f7a2a86794f13162f9ffaccd0b641ee9c34258c7b33fed8f8dc37ea472d464d0e099befeff5507fcdaa00170670f7afe8eae8fdfbd71ead320f010b8f6b7bc7787b75fa6a22a125d22df6d8d355e0ed143cf0c60b3d87dad3a5fea9f1f9cdbe4ffd15e3223dac19835e199dafee8ea66bc059a0db1973ba0ba03dee52ab5643efbc0bbe3de8a07ca570c3791a92a6b8af4aecfe2264e1487d8796197d778a88db3abc4b7d3191291e64a05bc1f4ad323ebdd1de3d4b30043401fec64041187cb7637829d6ada08279e4643485b0a30dc5dbbf81022318720bde49ecdb12c2a947471b80d42ec382ac62d79c18db90a5c89cf3eabb89d3e1606a62857a7855c70e0e52f55117704f4bd2009df0245eb12aa147472e905e88abfb66a09314ffe4375caca2ced59d44d83df473fab7d62e4e8af0e76b4dc2473fb0c0c0246357f85eeaa0e9b704f1f7c77c38cd973c91cf6f0f9670a2c0fa728f8b755e2d772c3185d2d7dbe0e67f33e546da48688f306f49ed95bc83852a666c3fcc2f40d15eb5a59c0f3a672c8dc3c287104b16f91c771ce397585dbb2810fbc5dd6ed112c02bf0cde25e0bce25c92d5df151b9134e50233b5159a2ab46b0a0415de407de52361e2a6258b42634202507466565fa0692a2d8f5db78ed55b5f14807778ee7b3eb6ad9f1179aec81987ff27cbe4c46f87987e4522c1e59c29e702ee653998b82a8e33a64d786788b9d706649d324aef08e89aa13c34fda591f0e003867e08f3472c461f03bafc3e97481ed615535040a72e4918b404319399cc57d6bb926e9019414d32dab48b92398474ef277af4e3ca7232984c5983a9afe256829ac28d594a4842767f0ec8468af422d74e7fec08bec0feb0fdc348190d8aa8b9a63b8e2348c084d1579c2119d29bcfc427fae6e02dc821ceba4fb5b0463edd76e510b95ba650a35fabe674d58eb6c406ea04ef3a728c0641abb83d70f0b6b05d873ee8d1f00885b1f6a365e0d0662047f41fb3548c464bc2f2366e4e229fa0e05fcc1768b219a09c2c7432646f792a80f345fc878fa110968cbd65dc778ccb8370cdfbb8778c52b29b3c4c36d3bc8f71cbae5c3935af590c848c70bd50c44768dd0fa4f4bb077faebb922438a2b947b1934bcfdd2f9cd89cdd06e12a24b492c0345bc5acb4462c3ca32801e3ce48f435ad7c0507beb32fe05d694cbf6f19e4b52d5ef42e760ba88eb134995644362ebd925d47dde75df3b62e346ddd29cd599c50c6f298178031753e4a7938bf6a5038dfbc24bf7384b4e6f388d022264eb9d5fa541168096418e5ebd1fee731f1b43b8f1c29f481d35d63989f1fdb643e48d30e475db95deae4e13e7ed2bd94cf6debcf3663ade62c3497da7f39927716eb47ec47ef5beb428f3dbbfe01ffb88f65143a07b589d92fb3f8a7c30cefe0a1ab53174ccf3d1432012823522c200b3f9aeddaaa0956258f528c1bbbedbd52312a4da59a39cef2d5b61474b000b614586c33d483beb3e67f7d6ec446c1bdeaac49abe65282a4320c138b0a4e7e1e04a7457de79736fa493b15512761b554152f6cdff079c141871aef0052e249e97f4eebff15e463623f496d4e029219ee7c769438541f3fabba31090b4e642b6891f1d5bd8301ae533d44780ba86eb3151ecf46ee7d30a2d15e0dddde7f5da39716a2af5d636326e3ef3ea1d09ef46d3b7aa6817a35c62ab535f52c5979f33bcef1d8f7fe6d2f27b3f79a42e854252b81ee8f74c6bd38fced341b5700ab88db37a57bf633fcc5c401d4d5f25fe3f6869ba637da078686c199bd85e63e3bff08f216fe9bb00d03a34492d4c2bd8547bcdcf02ea80ecb8812e321e3caa65eff7a1be53740ec3f850e94fed4eab2e9ac1cf32944c3c08a9e854caee493539c55ab4b2944e1e0f63ea90f1b026d41ae6bc06b00ea2865ac168cb98e8211d7e581790094c05e9e88bd2567daa6612f5270d8a522cff069b6a683e8be37670706df050165bc674f50ead7409cf92bf34ad3d2fb7d805b1fcef87e286e5b0ca4e52e2e337b34e4baa8ded35ee33d47b8894d37af738cdb5d2253462ae7b0304601e8bc3f0f4ab1dd66672d28df5e5e5d6349d35924787276c6091e6bf71156cb98ee33779104b92cb8faedd8ace7c56ae875351033f6972e0c62dd86b9cf79d773f87a59ba6259058af4b090998090d299f412322f39ef6120fd766b3b63467f6c81bcfdfde210ec8508ab1d265e098b37d9969f9dc9b6408d2e2d606237b811d83c4e9107b91eeeef6f421e2f514555bf1862ecfa44fd17f8350a45e203bd2bb20ce1e0664f47795c4ff383a41bf4bb6ed8e2a9c61b618319004c86819e610486da0378890cd4a33bb90809f9ec54a3240845d08cc8c2218088be95bb9b745130c1b298bec7b54ecbf5643a9eb4ab5c44a6613fc3325104387312becf8055850da392868194504e4f9a63a1e6513418f78de149ccc8587411c66aac705771b499df7965044a31cf01917eab1fe78bcfbde1f6b9c7375b74f05c1cb2f4b17e3f27295935cab0bb77866f76d25a7a29ac5375831591d5650fc4f3446e5f43889bfb2dc6767e62dd423cc2366275e61998b1e456bc27a0936fee471cbc1829e1d2d0b16b9d58cceb950ac513bf9f70e09aefc3955bfb99d8ab3eca330699ad2fb7b54f95e2f375fd081455dba8510fdc23458dbac9d490d0e3698b2537e14b73b5263f3be5aeb0b0014ceaae31e4fa81f81e7211d9b43050036adf2742d62e1dd34f82b31ef73ba66f947497bd65b578831e000f09e0ad8db62fbd6d1990508ac53f4f300a10a9b0419e67af262f45ca959a5beaf909ac148df21ce1b3464145979062303cf0b086c58f68fe2ac7f2cb143fc89245a650032f4f966e726498abfe8383261cb2a75eb34bdfd68ca6b4d72ac5f837651711808a75609bd17fdfdf73fd30bdc7233d23047954774c2962f834afd97650379562c3247fff220c621a6c8b3f1594855f059d8e9eb3e90d819c4bb46a0ddf89b95abdbb6c6194914048b75dbcac5d84c265f8a648e95f4a628447b239c723692f5b8a6b02dff56b718092093e3bf091dacc0ba0cf2c0b19f3abacb23b9a9c6941380af6aedd3fa52fd42468e2a7cdbbe4c100e9bd21a79a034917e9b2ba82624f24650802d2c646b8d629c43cd4fb32a7d2a9a2f5b2cd0ccf67a411418e56a2c0f2e66b114ce7031782dce5661c2cdb0d4037c6edb76a770d9079972b4bdd85e187245cf9b0f19da2095057c10c97e4211240e23d18275d9120d024eace079f770c4fc1c9f509220dc43046e67261c8036141a0c7fbc311f1bb5808105b642ca3f7dc5bf66dc81544b2497bf7f1d6ffb59f865f451b44ed8751f5d72e93735cf1ce003fd60c1d99db402e3527b6edbcdac29a611858eeae059f4b5c9d81b01b2bd2989d38da5542da27c94d8ef1c815beccfd2a673dcf482cf1ca13ce3732e2713f01dcf48e2402f22064ab62b3da5d0f02d6778f6fe9169ab97da7740a69fea1a3e41343273bd8ff2fa2e1f0d97ce7d6c963ac81d8c9420a723eaf42fc7cbc4974e7df918fc64ef44c1b027a5a22f86dadd6774a388f36b20494e2cd9a398fd1f1fc9009d2480f521cb0a39af58144dd3c0bc89b6b3751728e8ff4d8ec421320547868898f3705486002db2d3841651054686ffd5d61f05e5a7598e672d771336ebc4a4fbe6e0ca73e1e949b7261d31426210110de86c18c7455809920a4b1fb5f264ac6ecbc15b00c4e795b6eaedad93867c294581bc4c5c3ca92945bf7d6add9c374060c077fca3fa2424329d056824147aa4e8848561bba907af4818c0f8925d5e5d7ccc322646eec29a64d9a6965b88f182cb39e2875fc2edfc3e60642eae93905290d2c56a8d9cd3862f9307e8b238b05b41a3ec52f25d9a0093d1d36868feb8d634103c09a5986794d7b6aacd5b923cc21a3f14911951a9bf7ff1578092a053334b0888c8f2fb521e17195e8b7fb3f10f59c1c55b4286a69a281608a08fac5d754589dafe55334317653ab6b0e5ce79b9c10d5c298bf0b04a2bba4bf024cc9e96337a160300748156ddc172870f2575d3f11f9eb341242960a214520b1787136e42a85887cb89f62f4e89f4d595e3f5dcf42208c87787948bb610927656243b62d02e2faafbeeec64d9f3a4e60af3a716b25991f8b1cb6762b9a9e538ec69dfd6e61e0f66bc196241158cf40702c2ef27559e55bb841fc260c6b00c7e81dce46e3b43a106f7b1355d0f0b790101b5f2d9cba236101abe197253192a5aefce893f83ecc790ecfd71ca616ee1b476efd965e333f10202d72bc08430d1853438b503bf16364d49f17dad486e22b3d606dfe31859232fbbc63122499dd46bf9e3fc5ee5982002b34808072a0c4f53f85f3ecdabb2099316246317463ddd176605f533ed8d74161925a83a7379a39fa5272fbc4f1b7930adbb56a9de1538ccce7ffc95a74e4bf329cb2e0f10866bed87ba5927eb59c18d9dcb139a640d1f2ca759942ef5cf412ad653617d9ac84c5534589afd722ce52cbf03b4a9d61d52652498786201f3b4c8ffc9ac40964","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
