<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41b29fc653eb2f2e92d3376d3b54c1c2f778f65fc3ca56908d9f7d921e0a421e3fb5052ead5c3ef772006060c9b6f1b8d72c5553c52d043106be0b608544643ae9e8b12428970a5146ea9b28b7b725386dfe4a377e14456564659bd7ab4b75322a7abd69da57d694e7ec303ac82a452f8adb818ad8581cd8f143625cd6e1a3bfcce231c8654dbd3579ec30b9227ef53d821812f8ca5322490be7f4d292121dd449611a69fe83cde2d9d7b15c0d52d9d1a5b1e2c1b99fd838d0892ccecc74655edcc6f1bcf9da9bb48ff79640fdbf3af3a4582a0a4feb50926a6128bc7f1afd520acd205ee3ee881dc724dd40cdc23485eb912bb26c6e175acffaaea724b92a69aea708675659eec55dd6b5980343f41c64f05368e77b9eee72a240955525359d071edb97d31947058a0f5bd2fa86c077278419aa2c5daf2b56c8cb754d1ed116bdb8b327a6770d645a667fc534e4f3d74189828052467df16258d917f017b2dc8f951080f2863f341fe3aa31739329bb2002953053addb8d7322b13ce3e547f0dd837bd23f36267195b0a725b18fa66a092685fabed1acd3965be9e664c638c3b2466759a12c3296511f8987c48351e0493d0244a895654f148aa2f1d72db6aa0f52676183c1fbcdd166d7fe5b666b7b1277c309663bfd12986966f086a32260d69ebc3253cb74552cdb105773ceb08eddc4d4207cea304ff3bf1a6cdca0d133832578dff74ab5d11741b03d1dce231bb25fdb31a9214c694d6a598d6ad2aaf592b46b6e82e0f68c4a7b94b9b9e72f02d5a524584c7bd6a02d115fb422440d69c4995c341b19e0910c52cf1b2cb5a77c840c3dc3b1d8436b4cffe7404e609d92fd399c27a14d4fc49565180f533ad823781713ee22a9befc14de7832447669823c62141ae3ded7941c923804bad29de04ff2e8f4b87bc24d64dc769c68c6412236fc2ba1304df02352cbece09c28d3669a4d35bf3d3943a7575a368d8715f5d5a8c20090ea78a9a42ec54f2e0c7b444ef3d50bd3dcea760ccc5d60081329b4fb49bca8f3186683a7c5ebfce9170ab8a3f95aca8569e23b090527f188f00c671b1d25ffcea8a3ae1211a48344e7e82092306fbf576978de8c159eafd1b2d2fca5be5e6d6cbda8fdc86a6156897f3d9ab6d815efc7c529dc0198017e75c37339aa940a941c550de6f6bacba1f65f81a23d04d745b5b8caceaee0713e8147c921ff572e9519108adf774b6a288f35e2cab3796459a9bae871db36c784cb1314ec779dba6debc2bd6cabacf795b9cb161e15ee90167b823b09f096552d2ee1b318d6898a25e087303ccc95d3d0c45543817aa9f072fcf29b8a9eea9d3c2be36c6bf07223024dfe10ea1ad682c95801a74fb788098f3312aee47688e326b5de9806eeba57ade98cee40a2e85a59621c75073d3d0c3bf850d525c12d778fe1eb78ee2c346d1bb30480f8d72f97f9945fec59a034cbcd2b9f405874a2366be9b4b66ece1ec72c0d7cf5e839cff3621593c8d91fdbb6a84ed346713f52de76768a1cceb6690c68b268276acc0e5e8ae140ed797e23a48bd217f13209daebad03c1309f95661cd75dbd3aab1910b6a523e8d6fdcc6d1d202eb593a76aca096305a574d8fa3e4dd394821fbc56c0f8e17e336ba68e5b94995e8628d42bf0fc36406607874d31a2aeca5bc100336894a79fafdbb11db38c30edd58d72bfd28ab35fabf7cd42c6375c56f97d31b3c75e1226cd2506cf479966bdf701539b02404bbf69a40a41762b6ffa7265e35746e5d62f6c25bf189f106f7ca6ea93e14f9456133233c69c5821614cbf47c298a74998e6aee62a9ecb33fedda4f866108b3d13abb1a9c028b71e2a25cbda40d6e451dd6a628c03f2024b8a6dba35b4e5292696edbd9a3b7c3b5979092b447192b359ed414f0d35b4c4a32944387121edc5c76d6c5ef31dcdbb05f877d3fd4aef4ab3139f34904ff3966d0c36771aad3c811f83d8c51fba896b4a8d74d28b414ae2ab650b138b718af71a29d971156e6598f2ee777adc9b24192486cbcc6033c9cbf45448a6690c80f539f804c4a7e9b5df7c068a4b2c7ce36653df2550d6c5fb2db8becdc4c0e9ee1d19d0c9c29ab7e10d61d33cd3964f797bf43f65380ef3f036eba61d00bb45afd4f387299b58c328bd2bd865e0c2b37dc02b44931c862635212b18585e8a97d76f7ec67ac2161c3e43f02380a570911973ceb3473d4772e6008557c065bc3a3afe932172ddab380a40a39283d5550cdfc52a9e99f04d30161085d1e08c31d2feccf1bb668cf8b136468ba3317ede10a81c6ab4bb35bc4df2536582328376a26c741fa4eccbdef19b93d3b83decf30720edb81da4f6b76a678f3a7095ab530da53e739d7ca1d3e76b7d40c34ca500cfbfdfb0061d6724da910f735fb28f90e4fafc79d6ece116db8e633f51286290cd8add1ba17214e0c66d34f534046f55e8ef2bd574014e0ba15ef1ae4c80cff989562512afdf26a1c65463b85a5d18edae3b75e0c9feb4e8a627563cabf2095c785aaed898fd248fe4b174e95e6973857e894c5cfa963b8287fc16154192c8a2e5351b221b2d0313269f2e85499346e82f22db10d8041f14892ec4322ccedf18a23ae7ba6094f431631c18d349e69a5f245b0614d8c45412335ec92e041daf2c1ee15a94c18c5007245cafa81c073c452bebacb9d6b16447f20826bd023b286a6673534acb9d28615f4e181c0ca05c827a42821f177acb48d3c0b171ef68a40f05910ee6c4fd72dd06e2f744c9cedb7c5f485765b5d7f693fff2cc7e98f2c577e1a237ed67bc6480418e63307f1681011e3e2dae8454bc3365391b695aeed08845446f146dab9abcb209c2ef17a41bce1eec0a53137a5256fae025f6661ccebaac947d3847d529a3b0fb016b8dda354f2419fc7c29b301acc497e10774be32420ee149e515ab583143226bc3e99e73ac632671e05570fea439472950a923b31be10cc9b2f7fd9ffe3eee684c25c58f736250d7fc27493c6233c6b70fa4d5a98dc59ce45d4aa85f1aa2571f2581d261a56bce9548ff562bf602d2922c835554827f47a85f4b468b5795d3fc1e1b6582378835e85bd1ee376cd3cc24e377dc642088ee60bf3062e17e36b75f917103d76b70b354ce1502cc78b29f9ba52c736158b31114f9e25bb157fd77a81612949358be131f01ecd546eb87b62b865626a13683095f830e206ef14dc8f4ed3e3e25062f46214373918537a495a8ea2828b8159a7830950eb24032bfa5fc2ac15d020f8070e37de836775d6335443b7592335a089bd0180bb925a572c01d1458f44d37ab0c9710ed9a8543847117a2090f23c8b400f7d33834b086fc095c8c29ff0766bb34df342ae86fefd4b65be27fff99b451d55a19011c08bbae57466a4116984aaafe10b57123246fcc44a408e1a62e370dce85e0d6cf5bc8599071e6f1f06b4dc839707112d50182913f9efc7742df9193d097d664309ccf78ef12a109a21b7fac596bb1a3205c25115f701e624a5e413af19ddbd28378668a497a86ae5266eb55a1d0f6ac37f31d08a7fac2fa270e4b1ee022c9b34037d6eeb7abb8e18ac27df4c8688cb28b4a0b41457c90b60154dc8ce6fc55e76da2e7b1c1b0f33a57e91d42c98f0c00e56628f48b32b2373b4c3bf4d1b9004d24d57ff79b5c1b49bca65b4c803b69eecb1fdafef7fbce91e992e3d1e8834860a7d90fe638b8790a12dd9d30322aa933358e5ca372bb9143b6807f6c2f1bfbf73b32f964befd628e1759884462a9f27590fcd8bf7967df2a792fbf92a2784216c1d7df94ca66dddbe956383d5f6b9427c3cbfe092ef6de908cf46c1385ad0b8d94d8101fca8a3ecd9f125f4811ba73706a7dc717e6905dc53559678054b50bc309eab18ce2227aef31f3f4b82120c00888724838447a44c1c6df07b15f9d8b14f60552e4f0bb1e39ef76175f0153e7a45cc585c766745aa8a92b5361b0d511474c74a7f11a15baa79b0ce57f90408556603d5f02d383873fbea31409786074111e7998b03cfd1a29d29594ad6dc078cb09e7d2bdfd74d61c3df08d82944b2fb29afb821ef17eb9977b30aab6bae0e3ffd6ee50aa5fa3f45bc539da84389cfe595bed3a0aeacd48f42a451991d923e67fb57b359f35102d98280a70a7ceccba080ab6fb9bbd52e1fef97724b1edb5d20e19953dd564c857e2dd45f5b7db28e8ce83c57ae3cf1005bbc08da6f26c4fed93790baa7468b5c8c0cb8ec96ec4fb84a7d9ceb926310be743a489241f9b35b27e8f6b361688eecff4bd7e8b0722438989eba05ac48ab82d99e8b0b8c3f2f71eae7fdee9b79f7d10c830837c923dc4801308c30cba3e2df0ffb9299df2f170a4060d49ba39e4c1b2dc75845a0c2638f62d2f0cc43aac6babab695a9ecab857a709ca72af3427017e65fb267ee449822821c8ee089041aa55ee3a866a9c7b586e89442a42f7b55f04a9f32bd98d1e8b9a805fc6357348c63e2dc449e954865e0f86df8b53271f846ab66d65644107af5e392a083e345e362b6fa64e699973e669bb248312a781546765bbc2737477f3d4b56c3fef2e6ed45886af98cc95161de17fc471b82eae7922bdeb496c49d07e01101569a98fe1b9a4da508db1dd240238cdb19b0815dcd4279051a86a4875b79e22900dc20522c4bcbc040a3e0d0f0a5c890f24c03035975953df60b0514c4d897b95fb3775e45c1baa7d945e2efde3d2db88ea7eaed46ddb5d616d0cc13a86e77257f8f46a4277506e75d072689155bb4efa0a0d60b8ecdc8d49dc842ed42a6af1104a93b0b3a5214ad6626a5b523f1cf3234525d6424be6061e8e023ed1e2680876450bfc571eb5bddff61fbe3d28ccdb9e1e8018172224e220202af6826b6ddc796d4407d5f2e966739a809649c2d943a52d38bf669c6e69c16177c2d71f2cdb6c690b450342524a8153aa571038759310f899ddbec8455cefd7b5bfd0be6882e0018d9e93a40f16d043dbc490d27befa04d141548a7959e3ca8b2a572097cec3b8788956c2cfd7dffe04efbf36a3bd7a1b1ae1227900cb7cd5c2182331e74f7562f4a21b2d7f71d66d0bed5705275617b7d725a32818551ced687494d5eca23b77d013be6fb52141c2290b8d5aa316c469d239489efc24162465e90472ed99621fa29f2bc81b0804b31b3c8c7dc56fb39a4126d3844758bf4140993f53e17cad891208f861baa72bed7e7847ce16a0e6a67c7379e53835f9613ed42b56da04cbaa29748e01494b746cfeb5677d4b02c0dd8ca93bc2950ff279b23c87d9f3a82e147c583759816dafd519be5d8df701eb1b25c2dede92597d39ade5e30eca0a10b5345d7c6569631347665dac69bb1e5dccd6bf9d3c637e6fe33c8ed3fcbcdb708c9f0b9abdd2ef85c0eef77ca102867d3d47fff24567628634566ebf4a8fa3a3daa9a97a738cb2d9760b1c723118981047297991ffff42a1dd7ee1b90ab23917ce2097b77118a7846097049f3b848d42906fe8a5d2e811f52c9ccf1cd5c123ee945eeac8af4b4155fda4ca3183f43847fac71f80a49aefa4d7bbf6215680e7d926083c441df915592c6d13412fb4d3f044e7c9c82ec4704fc07043e519b1dba0e8deeed10365362ea3fba755c6316488ef1e4b6388088aa5bae6919fca534771e5df3cbf82db08d999aaedf334e7ca8bcc08367f833987f9974b690ae6c33fa7ed21fad97331d28bf7e4635c97cfe6926445486e5bd40306882d84580cd1cecfd65e4ebf90689845e3801f1e2e9f3c45e9fc75443fdb0a59e2b56eac82f165af44b2755f106ea8b82e76ce32de78921e1c2994e8ec9ba3edc96e18c3a47f53b43df05780dce51dd8eaf5a8943642aa06a27d0255019b9c6412cbdb60b7cda7d14424969469b655bd9b6baefb13d6bd8dd5fe33e9720244c1443df70e9bdac9206203e805463b18e491982f5d60c8497a475c4aa31810e92ad20890ff6c824c92962b6f9a441486b11d92e42408a447f7f2d8b8355dd1c93d34cba70375f812e8ed8df56fc1e4ad936a88b641f3dc10aa4e25b1886c2605a40a3d208b6520e73dce7418bf1632d8d5fdaf146be74c777f200ee07b22d33ecffdb0e03d555bcb07a58473ff8fae7a8c8f1e66160651beab0b41df7583ce81b34ea0c65542bcbe7051f7bbe2185432f03a7950bb33c394567bcf3d96fcee2aee9b05f5a1e23b360fd6a9c55754d5c74ff7781e01bd0e5689ff600f4d9c23b74ecc2f6d1afb9e5837325374a936e1c82eed1860f1c375d294eb515983e8c8104bc81833af952885c584c5cf4fae6b31955800a814328a494e4832d58d0583ee8572983d271837a26f4201fcace476eae5102d95e3d48082e9789121c912e964c030ca3a664956742cfc2fe3b12eb4a949f6541826ae2b200d46ce9586ccdb58c55c0227d35ce3f273b6d92c2bec006106c1a38b9a71e72bdadd981356e5584c1fad4c59ee6a303c0a396f3908212529df35fd5fb022954e61294a9c82e9c7217763c510ef9bc3b045a2ed30d3624dad4a45327d4f0575520c07c76c2149477f7471d04528da1082fe093c4515599a6019a1e5663c3d5e25ab05ac46697a2f1d9f43904435758f6d9d7676cc1cc09d521d1df680a73fa593a7c803f788b3ed9b71b4c49e9b4d2e5c6fe927c84cb3f449ffd13ef47e08d5e9033643954634abd636415375ae51ff4e387e631db8efe90f466033b5c6b59d62fe3c24d9c884b019b03f71ff85b52897824fd44e477ea5260b7aa2aa451fc62f425e29d758a0b56f0ba79bee1549037568b0b23e37d373426ce9e19837fd2b37f5b1c34fc04849c2cd5abe571e1f93435644ff0f47bce7fbdf19f1dd6533930e876d47d077c28ba97836e36d52ce9995fa04c45b4cf8a3dc6904a420bc6eeb90776a7503a18d5db4adcbdf23f903815a296f3c0f5ba7a1c6c138deebc9742f0abc06e18f4fca88710a5afbd7709db8388525730c1a8682448fe96cbbc402d9ce69750207ad12010dfcf1bfeba8e4dfdc9c3b35bd2cdb2957f5b32e0d621707ad495289ff99f40760d013fbb675e0d2a64eda33b30b938982a20be026b64e231c71154dcf92fc47ade089e1ec5a9a62026def9e40c9a153870cf26cf2ac7ad34b0484e4fcc6337adb0ac684c0e2b4495bd1720f41a59a83ee1aab26e61bb625704577a11508c12c9a7f9704204f6437a8b51ab4b781d821fde257e3faa35f0d438e911dae58028458a4252241805a9e4a1a1629cf714c738f50591e897b76ab0073358b00ebd5b44df94536fc4d4ecc759561f8c07ae201d75a783ef11e9061a65411038b59f0839817e0e1c2257025bfb91195ef46787000a39805a560c23dc56213c1f766ba54eb5ae3a1a904d493bf18dde4cdbbac650923ad7e5d20245c99f0c1a81a31cfd22ca0735f63d472bfeab2efab8a66ca6779a5b11fa05e40d0e26ee33eb4c535f9cef53e270e60767d3e9380301e63ac74836ea84567a5f9b2da2054abdfbd300546a5db29bd8a4c04f1bd16d3f5c97e71e26413a4aa2adccb0d8ff443039c73dbbf29a651aaff57f09a8165222164ec534242b6fa919dd52ea1529264d475f3e2028efda02dc7681051d09bcb4bb5f3bf01a8042f8287a40422124dcfc212ef7f03414b61f250856d8028749811a3d68f3dcda37d4caab8855547c1b72098e6aed08e6dfb7c571d7e64280384a37db9da3df042d11eec766e3be43794fd6cd9e4aa66c9cc7545cbe511f7eac69ac2f30b742c0d2e79f668bdb4c7acb0e0a87910e75c7714a77a5ffce18406fab408a5a338089a93d0992e9420bda2c34c230110b0fbe61c511e33713f5b35f59041d9bb15f9e49b7129c709040bf94501c074a8664d537b4a648ffbdae9c923438898ff1b79e019d757ce01c48ef7bbe743af5cd943a572eb9169f3cc492d4eb904b43e89f6914998747ac471f8ba3c415d2adc3a3cbc7faf91fcf9cff1681fcfc5792a630d95a752a0e684fa92f85ad748528a41d5a2825bea9e1a4d776577ef0788166eb279c87495a5c440494bcd83c6a7d7b039aa13b807303a7717f8caad703d5ecaa1d25a80580d0faf9ef8a4e129e469bf01a23731756b5945171f92aa15b7a28bb0ce36b9750d4b036d33c77d3f61dac020c67cb04e5f2483fea860920f1c51e09a343cc52251d41cfbf54fc96eb224b80753733624356f4c869e0e3114b4a5e234daec95aee9fbbdf2daf6f4238c27fd50458af5188063ed4321726d59f156e1f7d55c860d93c5ea7c1f05a19a3faaa15ab63fa12c7b841ac88409a034a2d83c9fd83f54680534192e8871b66aac5f04802c7371030521e34b10164ea2c0205c322adf0ae44f4f753016422176b43cf1a07d858ab4e5ff16f51785c3b95a9111f4479286766bd9ea94826c5a4c694e5fe13a795bce98a05328699150c9b7706bbc9fd71a6b470fee036156716a742fed973ad4afabd5008bd622bd5f713830d875cefd04205dddf611cfecbda21083ad7c8b87d9d3cee84d8923d1d9d46d74020fe019886b0a4c3fef7e39962759f2a6ea7cd81a020bcb590569fe6fb23721e7fa3936a9724ff7a5db205a61c110fce06448e6c5346f52e1c5555254d8077fb3df28077c7231c576e50827367dbd5ebee928b99b7b75fd217412a4365297e3bffce39c5400aef35094b144479d64bac5fa6e3ef2f07148c943790b1ccdccd8268805b15c406db58abbb44ff9416d71efe8c34fade898edd30e31d988c64bdacd351355c1e16042cfa5a1b110c3cfb45d57a93ba328a20bf4c4f9e2cecdc8f081ffc414627c13bcedd4c606042ace159884457265b5e5e5cada8da43dff4a31fdbcce8fe6137449b305a002c318a38e25b3faec602a3483697842d136c5324a8d0263345de59b32f6744905e93dd879d29d25a44bbcdfe4aad0126400780be1db90124489be01794a6d14edb98836faa8bf040159a3f0574693c21aa6f0381baf77fdefccec0e7f1bc3c8afc789bf15455d251e0d9c4c88b484fc3a6b810851f1ec54d1b80818b69cc624e5d6dcc1b6c2a93c38d4bfbbd1c85c834ce69a35f4e5b99578cd108045a992b5d5b280028d3b34bff4ba7bfda221c899b469858ed0545784debac327ffcafa2817a1b80a0d724e947d5ef74f464dfc7f2692d90b1300062d25f42cd072b9ae72fbaeee908af739727d8cae9c3f32deeddcb09652306ef2bd254f1c10579c38999f47b24d2279b3c31ec2ec3adb789d46317fbb363a8f63badf082e9edcc26e968afe5cc6e7bfde762fc436ae6f1f7cc51ddbf0c933bda78a7ecd16426bf476468f51867c6efe2ef17cf86d52858b87a1ac8cc9a0b16f1f824ee846bb89d040dc19dfad3f4875f6444ad854ddf062ae519aad6f4abb1c04b06a77413e48d116f01d19c8cc17a91512490bb8d2b2eafb1f8f4dea18d2aefefbe45b715efc672fb0b43db1c82ddccba449db31eb969deea12d6b420e6996788d9da436236024eecda40a3f15596f2488007f1efe5af5f2fda28f327f15a9444b66b6a26b3f627a6f81e15097ac510ad6ff9df0181ba6e2283e4be8cc8ae56cb02057d9c205c4883512feb3f73310e5aa40d4a860dc820caca4894f2f3fb688eca11c008fd00ae3006dbdb60c6b2f8874afe0b7578fc9e9375929dbcb78e2022d3d1eefb3c2d982666cbb6e8276e62f64af1a790c736649e59fc090664da58f58b19d768cd95ece1a569c73285b09474541c8cb5959f45dae716151265f6c800d30095e2c7ca8d4568327a5ff3c8d48e9aea7dac1fbb05b020a9d3716e7b0fdf7bf52dcf34e829e878d5a082709974fbb1030df671586f7eb0df10dff334b42b86c565fb1ec072c149092d6570e9213ed548810a8ac463d03dede110eb376be5bf90c9c76fe855e1fdfb336e9b44e99bd4b3bd3ea1a3ea6841cbb64f157db8935af7f63ef273eda4c88e229875986a84e0146d65bf7fd364e1646b6da8be24b5bf13bc720dce3d05bb001b99b738e113620c8deee18aac023a1251d1b4e287ce1ed67f028af668a06ee865b1b9f7c5e1ab4a6dc2c4e556c75cb741cc5c8cd0bd77421ae34f379ac8d92d5e374c28f7910ba5dd1f95207eb73e43e607b865d8296eed5377fce7233f84c0f08c829f06e8ae9917012482d11004b1da2a0000c180bedf80dd5cae3fdbb1eaf5ae4319b3695371c515e8444891e3164abfdc221874afe9958257b2fefb27912a4ae33b6729b06555f9eed5b89b1aa5fea68a3a2ae8cbfbbb4fe1704c8ee0cb0c13d655e65093d8178197f887d8f65305f002266f0ee3e7939dc04ac17a859daf249deae61cc18043d62ed924f0e0cf0f133f815445930725e12f526590cb16b13500c028ee119ff65ae39b030ba0bd5de41d37f5136645fd89d9eab7fb4f00fae127998b5a1adbf82a3ca02af5f65735a125d358c038a1cb39a33e005b85d6d4fcc0c3fdb259c04d58f5fd76ab9095c62b47794ae7ad0a7d0205c4d777f16405613634e1f7f76e0389811a1d867743f0c66c21a1a1aad31fbf6228e4e9f9f864f613b88f41d574d23765da4f55878b46bb0b3912489360b61a6b7772acd6f4aede58ab33c6eb79857b17a65f2f12b66b9d2712f12313a60857f16bed93cfeb77f20422442ee713224c96d22589997b70989e362f6a3a9b5dc288a0d2739a42bfeee00afa1c4cb8b26458b7cd452b936478d9fe06e7cd625a48cae0ddbf1d184e6cbc1b6f9905208d299e3aef0066ce780d27b82b3bab978c6247a515e1ceaa0e53a67b690606e8298b6b08bf1334fe5ce0a29503825a37ba322ece5981ee667e51e1710add7b5fbd2bb356517371bcf72842c20927f2fcfd95bba79e3e0d65abead5a81d6ce071e43a902b5e2482d0d176b4901d67c22c7147ae58dd53aee5ac48b0d948bbeac96df6d4a9b523e96e64ebe555544c3a38bd45e42b4f2543a6f5901dfd41a4d6642efa59fd93c10f5b11090f4b5f9260e49c646f6f821de1619f6cc71ca71177e6d9a5de4651d8b063afd6a9e0636daf2da86b1e402d05d2087f4abfeaf7b45dd346bf68078e1ea7a2b847e97659d8a01a9ac0f654ab2c52e5a4902f77379736966d83fc23c37eedc3f6c77bfb95142698155672db0f1b5f2e4bc07b17e739042c82eae51aaf84397d9dad4c540e6627f9805289a0e1da087caa60b77d02caa5161c73122baf5d3ed0c57719246d93e3bdd1e062e9762ee6b122d3e24e6b89799329002d7e68da8bd794f44476f8e0c44d2b27b9f450bed280810d983a43f7f72e712f227266785dc428209af4829916df403ebaff29ad6a26b2ea59878b3ba7e7d54efa6fe6f72e9b586d09d12c08d1baa64159b172206c064db922a25ca38ec1ed343de63115b61952c73262da45bf18eb5043aec4d2c1cc5d8215d1723a3b41279064d30bc8d71648e42ea8a160fd1182e6758e9dba7aabaff8862decb1da5ae918f0b584ce09f635566c54791ddac683e0a6f2db3a056fe664c57454a19a8708d9809df946ccaf37c7f7ed15a13be0e3821efab4dde031ffa0f9adbd90ee38932501410fb70cecfd22d8a5f7b4167399df808f7694384d0e2c6c7568cef5016bbc6c05f35c38c19ffdffd9783b90c3baaa90972fa61f872279d9e6710b37b16d874c804bde25d2a8c88417ce973fcd8adaa2d5419486d0be0140340b8b8963dcb31d59c9070e5bd90d5f8d5673dd7546c30633207b02d8ad332f459643788803fa6910113d7d4ad088e8486b76a35f9e21548ed929506d58414a84f6645c9d2dd0aa36487b164edcc13bf6bc9e2ca3edefc90a38eb1130bf6e4f6c0249c78b5595ff25b22a18711bb91eae0b16d86d8cd200d1c80a88b455e1f9061677a0602a103368374bb23bc4f735f12fce910f18b6ec9639d895609bcffec8059da33bbbac5d7cea8f3f915f0ac9dac884e218ab37991767e88483274aebd37fe47b1ff487f875c742be90531814bcdb9871efb6a9830326b603460da8b703a2828681300dbb2a42a3367e5c6bf2c6a7aa6a4407c299c0702b93b06f2a4ff17691d8bab9c5dc89a3f71cc44901ec3bd811e980c016b311977523a225eb2f2efc4b07a01b3abc6f30b088cf9189e23099eda9e065dff5d20fc77f3356c7575097a19a884325740a333fbd691d22ef6d3da2cb3dcfd5b73ea341fbb4b58807f05c9378229211d25a8365d0e6591ae53bb3e4da51c635bcc40f4e196e54dac38ca93bd1769b4ecd668f046b2a8ea9a2583bd886501591116b15f4fe3ed83ebde606cd95e603050853899138a9a743499761bf27a6210c70d30a88a325666d1e492e7eb1b0959b63fdecc7125624a3e3864931963f002173aeb388f368a33cfbce0bdc2a1ee85429f0f2484b8c628575b0cc5478a6129f82a536b416f553909039f39baa32c99ef50be5e172708db82fe844c77cbb1eb22b54319cf9cf36bbdd4b8ac8aa24a266ce3250cc6b9887ea2b9e9c4e328e8e7e186c104236ebdd38a5e9403779b51891147f66aa2216f7513adbd37197385e47dc12a05156386bfaa6bc46cd1e6d746348a81ffa812fc2097bebd9234cc8955bdae005b2604c6f31722ac024e88c0449021689b197bd925549650e7581987d93828bff1cc2e9d227cf87599730fcb913b67385d5a930f05cae68da65556e3f08d622d98584a58e1c057e22a4b86c7f7dd9388b9e566b12b56a1eea1dba187c3cc667b5ee1a0e6baeae72d6a361a31e79bc965a002031939a567c572ca5c7d203373462465e9a2a1eadf0936656fbc6dceb4fafcec8f52c23352ad819c3c69ac09d90fec0655c0564ede76475ce15bb02316108db94dc938b5aea5d648f107b16b321e0352af1d6319f19542485e691dac8752bf65805d2dd4f744bddc55836d2977d33a018b14694f93ba832eb98f876313ac3cec686429a7f170761cf331af65cc49c8c849db9aff404dfd67479b68c87fd5759e63b6e9889dc8e0ae59ff94a599ef7741acdb86514d6166f449b2878b84834520e2a67645f1cb469376776508184ee5c7ae3a640338d2244949852c0c7eee5e9231bc233d7d6a893afad141b9654786e715be1ee349eb1972a9ddfd24a30599ea9a40971a9440ef122332ccc2821563a079bd3cc5438a616a7809cea99082cf8800048a5d62a1487ba32e66a3da60b7d56c6d87f8dfbc4ed28b330107f2a9212937d64d1e012c06a3c3ed2e66f188ba21cde2485b688101b9603b0c89aac0a299048e1e3e29a74a175708ea54e97863f23f012defe43ca5701bb20a6e856240cde961bda70e1ec3ddf30ab9c3a2cafce9d8f1caf261fb5ec37b2e70e14dbaad1d600c0b8094aecc5d56f5738b906b1238456aa5fcb284cde375b73122db9b5acdd8a2146966109b5e5e3056f924204958f5771f7abe95df05dd7b8824292ed0c787a949ab712a44fe349806d2b83c3887f08e22e57fcc3b6edf037beb68e539350b4ad890b475f3f9a640850134e8ba25da3a2b9006e2061b1cafb4ef973f2485aaa5a7a83a78216f7679c43a009606ed0400c4af57d467d23dc4abd4ca8be10efead3cb4266bb4a85e5e34c292089d2dd1487f870f23ecc877b04d9664ea2fdc6b335c62a40ee33d7108ed7b61cd27cfe593a5663bb23998a91eb6116b60b2d6fff32611cd22dc56c9d57526a47056538bff8745e27fa1fe3a27e7dd99b9a419156f1e26616a25a7dd327b6577a8958f7ea4734a921e20e251f5bba4fdc0ed2e056dc0e553308fb509d200d4f537f5160b8b775a461cb06b08c8302207d288a1e2a57fa60a8e617df7c899cfb4564f9f774f9fd3b77f9e8b6661e43901caf8cdf750e5da5a7b01e381ffe71bac3d1772867702860f13dae358f8727d5c4178a1fb24ec696fa84f0fa00ed7ff5525cad1b8e234aa99359da9840587a92f5fb4a8bc077ac25cf151b4ee0533488accd3ce9469cccd5bcb19cb92e438de1a16f6cabac5d277263a7dfec03929f8526a1e1006b94a60ed408b5fca09f6ae4feca29c4989bb8a1def29a5c2901c2ebd428d888a3f2aa9f38ed575b58097b7325371ea2f446b9356157b0f359d0636e048ca251e7c8103f757986b4d1e5968134897d38b8e42b0015af90d3707495093ff0e798957d1faca0f240bf70c9d9f8981104bade81960c78e1c774a6da6e31f834afe5bcd02fe9d2f5008576ce4b7e67c0b6b2522ce4d560d73cba2e84daf4d20e78a39f95b4557a9c9f31e2737ac5a6a696d42cd5f5088d7a53a9dedff2696f664add117306be91b9932ecdfea941d4c7042b4fb8580667c48edb8a3ffbf0863e85812c87f19a3f01f8c175715dfdf17f3c6f7713e50d7abf2b33130a802d0a2e46056d52dda6a2527c5e2a05abe4a9d6b7fb2aab4d9d6d04ba3bce44d071b1290f9ec7110d6b7dad6d7385fbeeb428b4e994a324a5220a87340ce8ff40fcc963aaa4e002263039be2c8e3dab2870b6f88ce5551419440317a8be9b10f0585e90528e1bea96d6fa51a430b3a3168fa6e0ebcf7d82f9de037959860c2fa4fcb3c1fc7eddc3d38f8ea062aee0a74b328119a3ac1e6c7aab45ec30bf95e514631ddbd02149d695580b4bf03891b7ba68902c3b48e92c78e9f9c36bce37bf79a30fbd2ee142bc4c05bf153bcfffc76beb4cecc7fcdf625efdad4b3690b3b68cae35ef01eb80a3a37522cc53bed05b1634c9406771151260cfc59508caea3cbe671b360bb8f06b534e073209a40ba7fb7e1b808b6e5534befad4bc6ec61bbaf5ebfb583207ace97f54e2f99d4503298faf1d070121037c8bda2d475bbd12b6ec366efe633465381f505944dab8db4c6c1bcb9b00c21169123557363ffb150097838abd7b15baa67bdd4452b803e8553b37575395f15e8b056cf6ab38ef0e490f0136aa738fb8fc4bc9620ce9627198e125b2b8ba16220fed349c2d35dd0e416dc7f5116958f300ac435259e89c8bf284c65f5af49cdace7730450d3dcbd76f5e9ffd337c3cc5fa1f9e91a693b1111cb644ec27a271470afb0fe9bda3c7ecd86cf5a50e65a71f2af92f27cba29fc75b604fefa6a3f486935555dfa5578022c46b05817bf89a7cf41d81ddedf6cb1481c873eac5af16785ea86ba2b1d4a97a70a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
