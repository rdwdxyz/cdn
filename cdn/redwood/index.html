<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96562a2479e9376314afd9214522ab736d6896f4019d4caec0a8d9974d6fc3311e701f0f6e2020f29b6c49eb3895d8c5679b140d67c1e7107636db77855966b00c3a04f4c1b183e9ad7eb8a22a8e829a3c253bc8f7938ccf998abc899977c5f2f4b3f2cd32883216f8b794cf4595e4fe0f326f0f13a27acc6f99e7604e90d2d91f3c6f65e78074eae6ad39aa62f19706c32a6aadb73cb9617ea0b701c72d24fd114341203a4f57319e2e574a0605c7e581a8dc9f81bf2069895cdbc0df5b07168e5aae06b7ddd53544befaaa34958fdb16bde7c28db8be9e3ae7991d4847f4c577f2f2e39ed12bbd0aaab2a7206b0284bcd8b5511b6e9dafce299d9c7a9357655f9706c34638dc059465337c3da3eac30ac0d3c5300c47c0992ae9a972e4341d758ef9df2d2dd8c7640836f80de7d47efe4143da425b9504354046d5eaf32ab9de03d36d7114d4a94374649c02b5e416dbb5a474116dd447539f9646d383b1731a9cce312eeeae37a836134c2febb31615ca86990ef0a9411d611b0ba45d1220b31607f2d78ea6162cf60b410aef38735f5e8b8680d89506cc72529b62882a09f6ec9b800f603e136a8b6395b49bec7ad0648316fba1d5a9fa678f5e82d599be16572624024692eb6d528ed19b4f103cb1be1045a1c017ac04411f1b0932a3ef939e618c8d9cbba8c9fc8f6cfd065f3fb70ce2a0108661227c198ea1f475b121995bf72d99514ad52fb0ea907f3f30a9eb4856ca1ffd22d26dffeb2eed8250eadbb6b7ce6e54e7df26e0bb85a41ea15fb7bba4be48e015983a86daf02b5795c4d432d5b2e67d49f7a440f6963c97424140538da6abc12fca6f7ca399a90306cb5c17724d078ca9f8138d9b1055f0aef80420cbd6aef3eb6f2b656465e61e288a3c75626757e0a08e83da75d94714c47091e2362d8d92b9adf6a5bb12827fc78f564bee459b8f938ded7c186157e1a5e58d14c1cd567da25d582e21f3d75e4bfeb8991e88b15e8297ef5217dcf7660d9c3e823e54b154b21cd833083eeec976a650c20fff855213fc54e28482c04ab780e6167d0853134bd4888895d67d95756ed30ba180c1a264b4921bfbc7df779cadbf0800e30462ecee457b452be1ab2a0c2f61744d193c6b73700b0fabb0e247ec39b833c23b93fd21219e1dff5735a5232cf222c3fb6e7b08e21971e023856e99827bb511b815c2d89413761c295f8bd553f01dc28879ad58abc3e2fe5ba871aaf5de286f1c304e3e2502b3458a5ec399978bbbf690ef5f4f9acc9ddace0b4215411389c967e114424b2cf4d1ffbff8210745161dde1c9b458736e28ff9dc0422410065a32fd067aa8c2e35afc10508fc29732bfd11ab702cea19a733c946aa547c20e407bb444b2b0f296a62d7fea0df4d43470a4c8f1d57feaf6a69c44cc162adaaa4ee5a439fd5e06068a149767a2c43bf066d9c9fb53f6c7d7c865b6587e8bbc55e6d5924ace6d55c57d008e2570bc9c00fea985713278e385600ea6bce0ee7fb53c336efdf700fa76ec05e3c8aa9e45ff3a720d29ef8a3ad9e0aa18e20ca308268d2a1ef2a9b21ef92cda7c44d407ad09bd25a48841f4451a3d346cf308709d0c4a5c4530c5630205ee397ac387a5256e55526377165ddd66817552a9aa5fc53a6244c618fc1320fdebc58a6daf82e3eb72890d4384c854f19f61dd6fff8a36f265f299ee943daaff253f98702ef977494310135ab1135afb43c6523e505d9daad1bfc98a37abd7246a772ea9dfc1d69787a9a7d8c346d8c0c8910157c839d66302baf48d2e856a1deb4f84863feb630314cd481a6185c0dfbbdf50c5b1931e271caa296d06fe07aa0faf1382e7b97a425ae9def3a0e40f88c158b8236b8208b55a4dfe3ef4a3724f65784fb6522aad93a890887cae03e2fe19b5432a52c4782c59218a295aded6098c490ce75e5e0062abb3c1c96304f67a9626f9d5a7c446df92a73d00721a8385deadfe7f7300ebbf96e7c3814c65b536c46f07f9d5fe719bdcd426de90311a06188380d9db5f9353fb4fcba01fb7c5f9dfca93a8f06cc05dbb9d7d75dee766706b336d50147802a1d423b3ab77a5dd58e191475af4a8abdadacc353649c1e3c742324b4e0aee6218eb29821d9b945272a75c0c7c638bd22bb504b504e124ab0a09af61ef3cffd1bcd41e3bae8a684689974b46a48b8b26e6ff7215e672dd657c6c3787045e42a6612f34be7a0bb995e8dcd195e751807f202cd3cc9818accc32afa93d30e72ce6f1b703e70b4008e047a4660f5792b4a8299974529abf0cfdad07cca250ec2927df293903b5d60af8456d7cc928f5bd46b07398f72f42e0ef79ec58de9e261d08a04628e0b2fd1af5c287e28bf2199267e0504d5657b6b8cdd31812875c048bbd1179c5a55ecfbcf56c3b3e79d098086a5f52b89de1a715aaed25d41ba25b08386d8ad296f27a84bd4d193b1267f1b027d51f57b78e44913e58cc9f393cdaa198e91036354bf767143e751cc098c70bb46519e45ad1ae119c7e4d99e1d51302ad93473f54b9711e5e186cef83b99d0003d36f0ca796381850d0155f0c6b415d86ea9c139403cd65990cb3884662568f7e650f00b0fd9be9beea0f3f62bfa2789af2d16890d8456f89b2e211955b82e037e8168eef9248c12826b672daa19ccb724a8c91e45f0664f4e91dd02d8c8dc374fc17f1f47142bdbaccdf61bf5c3d25e6404e25303751a47350e536a7ec98afa613a3cae2ae51eb2f1eb9e5cada4e537cd36377b531df38c1217bd5af6511e70412c173c45009c6b67c8690ef8e732c68890ca1fd1b0ace26fcfda30ee2ce25327df5a8256061b2cb620cb338d41b094bc565dd19ca54c80848f78635219ce4f2baedfc8cf53cd25eed5d87ab0788a1ea1a12c93931b9ac59b3f189ed04a67ca13efc130745f60f20046a5c74e4e6329d67668c8a49dda5e20d2a7502cc60093364b9d185bdc93ae1f3960b4a5bd69262c1270b0a0c78b0bcd42b1f5fc728db8d8ae1d7f6b745ceda32ff0658179b4ffd566de77dabb252bf0e7d22bce27c5ba0016530b441b3b7dca39b7a8f36a3ad1a4e4898f83a57bd1368983af81d25cd447f09b1e4bb975748948e3c835dbcd876c9eef20012f203e3aeb08a4429fdefaa94270fccd98b81aec9106dce2aed4864f87717cda4351ac03f8da3820571567dca1d75c9b302fb4bbf3216a9404cd7987d1bcc146b94525273a0283b1f281aa4c2d83315601a9d6091b6ddf4eaab9b0e9b81f1bdbbde163e95ac34ecb1a0f5c3f0999966612d3fa0660988bff60c9819bb5717b8f577fb4c287e99d3d746f9b73097018d06494e7a8825a45b1acd7f25313bd73a071b8e0b58d527219b6cc2c18f3a3228d73a5d6ed149155cd85f069f05f9329bff2678443e6455274ba6d4afce60f9ff043b974d4fbb79762dbbe2ece4b62771ac6f307b4278a49cb6f467f0db073a1dedda9d52d4e391a90f6fe2dbd4765331919632fca712ada6f23afecb10c6dc581ff3ea217ca5df479be7d5c9c427a666d2791a60ca84d327390deaf72c4e994ff6169dc574837c725f324f55034a70d73a369e89957fda52602493c0d571666647fc24d5f8afd959a8f2dfad1faf8aad6e6f752f84430e29f3f220dcd599290b7cd2834dd0e8d41e10178c7a998031e9f56bdaf3d9a94ef1b47a6fb5b0dbae536a4d835f09603c32d77203037a327e97ea393b71bc4e8816ce0a6ceac5f45fd3321b92dec4d893bd274e99c50005902484a0f27c205a843acd8943708b45a9a7ae50be197d2d02e7d622bd7021bc2a7bf3fe587be0fde93ec13e124aea416c671913f2159dc6d91cef1d6d40228498647427f62c0f9ab4736f387b5a0c3c43f3c9210e10e2a8828dd1b27092b27689bd6fb6243c2280a3339e9a79ae71975557a17c563867275c33060bc79bee4d3c506fc61af1931d413c442ee4b4827a4fa2c0564f81bba510078c424beb4b5cf11440df8dd6bae5fed9c55bc857848c26ca5ec78d5a1aff2bb7c597456beb571cc75c8d7469c61d600328c5b76305055abb59a62b379a0759bcb068276e2039637e6d5a40fc38252fda213bba1e6864bb1940dcc1fe9524b8ea69b7ace58ef6970a76b8fe8497c927d3f9d3d2019bd18bcb37a5be6a618650c0a7f31eccdefc25d0dc7ecf2a6f02389c50d12ee1807177c9140adcfdd42fb56d0d22e7917aa9d1c0b1eaf723a231fe3e16a36bfcf66dd258b6c8acc13d546d35a3870cbd4ed06069fbecef549a3ff089b15ab29ed74c5ceb1b919ee8cd0fd8e3e152b054b1d1c65c6694462bdf43f2b4a03754fbb8deb46c3b3a8a4993a90fac9ea05e01c20147f900e1ca09b2c5997f5976c01240fb0a1c9e52adef4acd134a66bca5ca696b2c179bf4f83886ffd2879de604c441fb02477564503a1d314d6eac797f766d18589979b894c9373e90307199f3f10b95940c14e4843193f0dc3a37cf369f65554a7d184bf7c74cab8b0c54fa5b9b3e37ccbe25bcb7b11545704e20f470225a8afba000dfb22398bc033f643a7c16c48807dcd4314bc0470f6e8a127a785d3b2da3e07ce99d3d172723895c6f7f419f48114c1206e67d91b79c60a3a423c23060a1019e8df852efe767d5f75ab130b69264af5f0b0682f6e106b3d8831d18597067a04a1bfb8aa4a48ea130cb45384e87b7fdf789481d7ac38d118ab9ab16adc6daaaab3d381569b39a318131ebaf4dfab300afb22994172e494c03bdaa33fd4a5de24b1ab83f909a001b6e58dce3c81cafe43760b2faa5a5a54c139abdff9470c892035b088046ff1f751e9cc7e266277142344e4eab539a783ac17acbcbdaee936183beab771d827487e4944c1ffea2d68a33383cc201f0faa30385c2000459740bce98b53a1d973f1623d10af6be60aba657c8fd7e3b717f8637a696c3aa6634c5eb799f53441b540a01cb2d36233442a9528931da10aba3154aa0744e70dfe023b0fd6a004f8007bd62f5427a9af08815346f7b427e5215fe654d46125b4cb215a512e2cd041fde1ff86c79766383a574ca7ddf1f872f35c9a6f6873f7732c5f316136fdb61bdc57aca0fa2c5fae9f4d4790e3adcf0d2b32b37e385970bdc88fee043410909246a159a304ba7fce7f19fc077abc3c96042ef039b0023b233201f8a45ee4383b86c298d422fae7ec3dd7415dfb7217e56fe79d7f0ec24f31ce3e7015346ade4452d7710d424d183bf84585321dc299cda90d132d5054a4ea7e4e035a597ea7d36e3f9742bc27f18317618f5e99619640c005758056ec52e0be150e36bc151804ab7300c42024bf7350cb1b5de50065bdf784bb5b7af6e1931427a666463ce5746b38c2c9e747d6da187888c43f55558fd31f9a890f6132297ab6d172f9d2e9599aa7f7e88bc2d7d7646e33a41dd7363b7d7180ccb4ed0ff33bfc5308be028f439de76be64bcd19fbb86979b7a182525b75ce1790d59b126f17bde73a4eaf334e58f82a4e7c7d920a8f8c2b1f4ce304bc27e73c2f099130dc700a8c9695c5c60685de77441c333d991fd770ddd0aa2f267d362ed3aa46c80a4ee75b57901b4bb838826f505fe1146082b10361b5624fa804f56f0307e72fb1ff90dd3a31b3c011dedbf975497aa132cea5da9bbcbe6cf07575b2d9935b8ef4743c399bd903d5aafc7a37a601e6e3a95fc1b69fcc7072890e7f313f36d2d1d3b8736c54b6af4c59e72fb61d87a0702682af1352c0533bbe927a171af1d47068024c2c5d32428c3d680de70a237d8ec83a43bee65bd8865e6e0b858e3408e9b705e5c330ed74ba23ba60994b41a54ab7979f17c188c4e4d3e966aa6bd7038ab35386108214fef8bb807b56067103be6e79e1ed104cbac3e9480e646f90f27b632b6dccccb19a8c844db64ada8f141beca4bfc4379d7adb0a2ff3ea7eee55bcf42a285188844c28674e9fef89536d8964d19622501c29ffd1eea96b2f1a2b93278cc1348393ce1d118472515e9e518329a96e01263de7674feb027956b1e5088cd302333849abe0de4124e2973e4390204248e208e06cd64518656e5ba2db89f28e2271f9a767bb93e2c7c0380264893103f610f37e65475efff6bf508ffa0a61718cd231bdb144b3354fbf95a4a92adcdb75fffa05677d960bea0ff8d2f5b8436dd73751a5eb848234127e792da825fcd8e037182a93ee70cee4bb539092933a3b3eee466bb260b3ed6d6ee3b31c54bf8695d75dcb7681d3d7c143ac9c85bf4a280964fdc6a73e63212f766bfa619f1316659143b4e3717efcf2a4196e5979650441257605502c4c8fd6ad5e8d6b136bc16df0f85c09c1939c18b711172f561b1a3fd40c6579512ee79114ae60810ff7d0c283530dd0f5821c26a21aa50947df791f95eb4287323ece6d8d62f7da0141ca3cbb4b92c187b5d22efbff53ce6dda37cec3cbd1ad32c395c9d9b0a54b8387d87d104fcff564f2c4cc6b2751f06db24c9c50720d05ee1b9e89eb680b867e9f1ba0308709ad29ae21f74bca0372f0e3dff010c7f7189ae1e3df768eda8310f087e03b4ae93ad2f894e97e1f7b00c0225336b7c11a64e45d28e10a7320e9a86630d40a5b1bc292c0576ca324bed245cd70923d596115052c36bdcb2c644d4fe248c0013f13bb35ed474419585c514db4402a609e7b5b00f1a9c71657f8c46940206e59b3587f8559b2606abe2183034b79e23f9285532c620ecfddbb3f339626be4693c1c539ddbd802c38dabf5ad9796cbcb9177f0924a44be90b49febd6e93f867dd80aff9a0d4dc4dda50810c52cf14d091766d8d86465ccb14aac632dc3a4352ef2570164dd82033a4de3a8f07ba7ed9b7a542fffd4852e708eadd528ee4fe8e612fb8a4c7cd70e20e0bed45ffd1c7427aa7aa4b83091934889bcdd8fbb7c7defbb4612cb86c0bc6640dc92d00665429ae5032c2ab11e1baff755e5b5773717832628780e6fca833d841b9304e083cbe5951e7880a955f23eea1e3c9981a4f0929253efd3ea7b5e9c7b5303fad32540463c9a9003a51722a158a409e2f7a193bfd8c9207477690f6c7684bd9a646372fa05d5e3b80783cd204f51d2bd9e793b6d7b8b646331a70c34839840bef1cddd16883b073cce4f006bde46fff2f3da10b0a4de35474dad78fa33c573e86c846186d638d8375500f3f9b342fb408c9c79c487bfe4344c6712787a736432059d315cb2d66cecb90b7e47a7b60c1073e1b276e3c28447c84f2eef7ad14d3a37e6e448e29bd82c20debdfc2716711e299e2e79b1a9504fcb97f6a138d0d08a673185ce8247d86b43da4aaf51ffadb4b6ac1b484c399e4b4f7c49e9ecd33be484dfe1cb3f7bb4655616d7f6c2e2d0e48ed5e698c0dc8199a05cbf353cfc5ff21867ea7c423ef4a6999b266ae16d2abb352c5adfb86749e92f9fb94932b66c73d69bb8f3cdbbf9748a245bdf54dba7037773b12c54ce9bb7a4a31da12ee0c20c15a631807527cf02f6b853a62f83857eb79f6079f86bab7055b677b4ef4ef460717352dd8da4d35dc17c92e36ba7e38e975f7021fc548a7ec742528720905af4e9a0327fd84f4ced2f85e3185a8dda406f3a31abf0cd6db34399a7d097a2ed1c17460e1afcf11123e583b8de868f7d6252cd9e341897ead1b1ceb29fc6248e5b8be1531e573244e9b275c34ceeed14af60a34ae488859542be4f06e56643f2eecd5cda0d7b45525350f2fcac068185d95c417eed12ca5c4e7d9dc53e2fcf766dd94ac46ef8f07ae2ee06febdd36316ba20dc36017ed2265c85e7616c55cb77174f2cc002e90993b8718e93b6f4cdfc94d758c10db00c5b317c8e82935479ecd67f80a5ce7c38fc9220d23b0567ab08962028915da6fe9cb74e06716bb62d47af1d0b7d37fbfcdfa022291c34063fcce47a0f1b550c2c769b851f8fdb8d6191b3b034c1f1f3815613a6ea915aa823657b6cd09cdbef48ed6472ca19ed7739da56c2684c58f54c949ffd4f786b9e011e038ac7a2eb978eafbc5482d608fd1318d92d2f5781d879668f32fca6bce88d04bb27a2955ba60587be64e2a0631cb04373ad47e956ed51124c1d0acd6d4ab790fe7d4fbc8f4f59ff4ee2d4b950ce2471a8d89c4d60c046cc6c65e2683a01974f95d7a3a234aaac47b10dc72308a285da9f25e226b800528154cba9b01c983e599f313f53221cb665c932c46cc1dfc48e0f577226861e35ee6f12a693b11c90e83bab88497f5cc6b0fc6cc1bdd406b14fbd47052e586809078de9901f68183b780a538b3aa26d6f9459c3f24717a96f978c6b46e570d5174ac6b63aea116e6d18d8d75542eff9ec10b3bde48fd4295126828d25d08aa07ce9780481a6c803e88e67f6d8737582d611bf452160c2699fda7ba4083d7da09f4a1861a33456a270851c2cc5b617b866900a6a95c4de7ac81cab6c1e37691145407b37493ececb9b63fb54c1ca9d1fe3631f757b094dc566fc5120943d1f5f15ae9c9fe31cba0b2ad41a3dd85d7ce1670ee222904bb28384f1dcd84e7375f10bcb681573bbd713af6a155159f15117a97975a78ddd985aa8f2506581b01d6c134e1a00b2efb5d8a5a03f795932ee22fe5c1b2c3ba761118bcc30d571c046c5567064165f8aa5d360bec9739b9f17a27a5c406c44b825b29eb40f62453c535a9db6321b59049d9bde09787705bd9a50a857e6641722237cc349e12677e863aa76922516751e995ff506e4fee20207890e3282c16b1001d853bc1a47fe067a729516ed943e56aa09abe1e00c08065f8c4bae071172568a925729cf9a3e2332358f96c121c09aef4117e26b4e1e95210249445d7e433a26696e330dc9b41c6cac98f7f04cb2ba1f524a9d1f7771942e657f0e788619453869cfe5d36a6b9ef2c1c9891b8084cca78f6d0b75a9218042e73d825a57553e9cda0db1321441ad84634122f9b3b1ac0feb0a66a8439cf00cbe714be428a306eefb0c2eb6a728f4d5e05744468d92d200da28ead9fb9b1e4deacd56fbc05cc89f7ba94537f85963a9fbe992003e233bc712b7dd817441ec83db7dd228e50cb15afc130e19af7321bad43b738865bc284167b1705cba43a3f2dfd8f19b118a9c24eaa071e3d963a4fa139dd5c5417c1759832065319c1056feb1227b3626409d03b6d2edcabb16284d7e6fa55feb6a1feb5d5dedb247b6c7ea48a298399902da363c07427f6cbfe643e7ae8e46f53b839a3c29f7e0c52c71bf8d43caa91d918301a914b88adfa7e2efadf4c71cf83e073a8b6e7925c36b8ffb8257e90e6b3d3e356f6997e877867931098304fbda70208cc08dfe2433164211a923716a9961291a9e7953182b84900e9a304558cd2e7dfbe66f41da8083bc7a8268ec3ab9252e894e9108d0ffcffc04852a9026f9a1f2877bfaaf3acc2a20ec02a084c2e2bf06985fc2bc4dbdbd4dce4a367755f8e6e5a39ca06b2a6c53a3626b0aea472fef13b2646963dba247d52aebad1113b0066afb8716da796180d85cb152d16586a648092539873628e2b6df4ba979fd11fd9dbd9b3d9b3b338d2ed0c769161795b2195813287897bba27d48062bdd756317100164e35ce56ab600476ebf83e33c83c35376c4352c0bcb8f2c3ad7aef6dbd5a2ada7b159d54118f16d944142fd5d9b07140487c2c80365a7864b84a32105903be2f9df8d976729a06571bbe645eaf6b382eb0d08ba121e745fe9773d1b73491a4ab0a88b56b8a31021413944fe1b785c433e4a317d5faf6f34ea1e4be70af5761a79206279ce8eedf6e7a9a01db91d1be3d10a1e98ff18491751a3fd02d425f69b4a9794f853b6e0682ec1402190eaee001ed8ac00c76bf034551231620e2785624143dc4a39366d49c75924c6da8a91a67c16f9375d06d8b7dbbefbc124d5905f7301d3300c6fc9a74341207171ad105fb6f019d052453ebe210e738be38013c87c10a2b03417429019b764f0197f62cc24001b020d33cfb0460f08f4fcb85e0a6f0ee423d7013c8b3f77c76d2f9ecbf76ae2a5e6cb5bdd70dec59aeb5b154fdaf8c37fec97f84e0cbcd0b39514726e8395f35e94325e91cb4fce3b0b1fd0d6424605168010db55a72f5b946e2fc9cb1d638befa3a31d8ce5dd25b0d1e312e9262fd8116f9dcf98c719c7897a4496a1be48b96822759654a58edcdc76dfc92166901f9126cc4681cb44b8c0a548003b0202c933f5f1b172dc0dcb1ddbbec85d7f477f4937a44b99b40a398a20b8d714193ac7189dd2749795df29f7ec2efb50545ff484b50325f9afe907aa1feb11210876ee4ba292197245fba5ace1c4f49f12b9deadf057c5285dfdedc7626e837f9410823c27691bbdf15b798d764f4a3b48ed5854314d5cc0dad2d22c6c8261a6dfae0f9da8614a376bcee41d9000688b642c1d5d4cee1471f06f49f46f89d74ac1279dcd555e23dd43a3b1a63fa0f33d5795ea0743cdd321b2ff2d9377ec0d2bf8aecb1adf919b5d0132bf6a04cf213b41d88b917b7d9a17b947d203e9b7686dab0532ba6af0ebf18254cd4d69a785a470568e53ba176d9b9e373e50ba2cd09994181cbf57d623352f6c35d14b0a4f043afd4ac85b44b5af009dc2e16a8176b65685b2b162da08d75b60ded3b6727561891eb5933eecbc32254cf5c867ad030efecdc5833e5b2b53ac06dbfaa2a0c8fc90b8377c073fea095ecad03a16a94a59cd1ba9ac30af0e0b8afe0041709a2c4a06bb80f2958292b8d68b3f23bf0de15e4bb72af8a402c37c5e0cb93bde9d196df993e8371460a5d27cb8860c23375e5ba8506006b68f26b8d2a77119ef7db7ccaabdc6d1d495c76c1cb8735d565092fc853c8d070e50ba257bc9d637b6645a42a9ca14a262b96c173aa53a6fee7ab41e0adc02671b4181172724e717b4dab8f3c7dcc95a171bcb049bfdddc6ccda53d886896cd6201fb6b0c6a2490f753ea26b950be8ce8849fc089bee79dac9cd5199757eafc964e094ec39106dbbf55d688eb6e26563cb99e83142bae731f6903a43ea40d22df85ffc5333c1fd11f221bcf8927b6646a1ded12c1b9aac92310ae562e635378f06a91248c708aa3227f2f295f250752f535a9bfda1be07dbf4f48a27734e03900f89be1342fdd1581f4ad0090f029ff0da2622d7bae012df303dae5f6f3e89c9a2ef66e4f26ac21427c0bbf3ea0c5c09a40f5fc5813cc1f93e7838a62e3c8f15f8f63a4ff11dc0171030164959d8161c755cc4acc496d5cf7b357db02870c307d25f5827a0a0da9fec5f0887ac038c7ae1201f8ef579274636be17fe098d1f64b4aeedfdac3d781b54af36457c2e7e0e27a3adbd05c1872dfe01926bedffca5fd7ab2c82655c0f998aa3d202a04574e1aadc10dd399181573be089099a58cfbb94a36b29c799798eb4db6b087f51977cd4f92ce3661289ef74e10e9871193a0682783e4fb3ad7d972f0f0577a8b9fcb0cb7489e5f13dea9c315195433eefc7085657f1ad637f1335578dd278e4a2cc7d12cf600d236611cfa87a7e261690cc7f2d8c318d9f1594f34ff0560b74f49a3ea248031abafca06b820cfa360c2ccbfa57936a3fa63fe45b5f912d38aeca2cf82594804fe1aec5168df90308d89b379cbfd4eed4ac69e950c928712a8ab6d1a15867feff15b43c1feb73ffb96623b88c8e858a3cb74817251e2f8ad676de9680e8f26ad834433865109e0dac9f35dfa9c5aee34c0819f0bc9803d6b7af8c4186fe55d5bab38c41ed1906434160d84c29fe0541e40cc5fd3c934e3439a03095714a7f263bbe86b0209f1e66d5f04ef22ad7ebcf75fafe0a1fc5a304d0f63d9b24731e4f6e810d0f405ac0dc6ba3eb9b382944c006dbb0680ccd476e94629febc06ca498a79078c968d58f2f37d0d32131782fb419ce80c5568e30c2b264d3a8f742e5d7a745ce49a07671d4b80ca690ad6140179758bf9361c0518d289cd089404ae43892f58b9f91ac2093deb227e46cd265d56248ca04bf0d7d9bbe4452d689bf6a80a2da15fd1a71d7e1f5f88f33f6482135f2cf6ed9e7ee05cacd4777cd9d9536482fc3f5b1bcca1cf4e391fd4a41689a55b53e7e57eb56c052790792ca2404d60140bc8c161f39d7c01f4708205c757c0f2f33b6c1f617c540c1effca5134147ee6e353cfce0f70eb9618d3a1fc3df919125788847ffaf69addb22fd39c4341cb2d7f80528b770eed676f5df3ff9d503679a9b3b3f85a030d886310b0422f8021a3cba0c4938d7d86c8898c7c774b5a6f1aa3ad017afcb25a1ef2b789fd76906bd68b010dad9f4f5c80d579bb01c0e63c42b5fa7e26c1c0f7dae332b0fa75896db349378197ea07e2d5bdbbb48adc9fb87efabfaf766e077c0ab2170b51e24d572c7ee79652cf015efdf2ccbf2cd7cdfabcc6dc51f674f0fdae98006dcf5cc2f506b3c32203e009783d41dc85f866d70e474e0d7081e22c443549ee5df2c602cc92bb6d84ae3faa11b199630d403664e043b0e352c0ffe9388b319731b3afd9540b1bd5a939c5a81c416b614cb2a59bd52b6712d99e25f32eb3fd29cee6eada9342b10a1be7bbc24c5b63d09bb3066bcaa45ce7ab1c1d796b61a31f7e09615be5a01dc12901a7cd9ae574a7ed05320f7d1f0e7cc552afd4350b601b0f151875ec0b0a066344c768db8a6a613f3438306d9b501590df21e30816a2d24cd589ec76d6600761287424eef4f322dd3c2d9003a3a10d7d032a6b3083503fa02999e6cd78ac0e8805baf28c0ebe653cd3c248b8af28f9801e9aafc6ef30bb53a90f4259d22c581e55f5678cbdd963ab724d913eaa0b49ae8cc9e309085af6f6694dbda8bc94f51b7d81d6d1b39857703be47025053491aefdbb3a11be8e6df57d58ab15afd5f80d1dba68eb89110298cb3413fe1a6048b41644d2b2036d65728186d9e50a95325952121b4ddb7affbf2c4b86df4b9015a6cff948bc6d5f3bdee6291759a48b9afc3dc13e5688605c65cc1bfe1770b8f8542e97f821c47bd191f656a968030ea9540821b4c7032b68f0f9baa64ebed2efdd527b2b24014f72cc6ebd685f8639531195b067c4c57c1b863a9c2bbddf3e7baab42e77bb02d4e43145579d09a6f52027b25149d0e42de2f00b65ff354bf063aeb5b647c318276ee69ecebffb55f3191fdfbd3e0f2956a14f4f05f7e1ce076002b4e7f692914de2937c7061739d327fab584b76632a308fd45361a71006bf7b30a90929a199faa1575e930424a26daac0430b0975c3b1f60fbb082537fecf2f30ba30902539201638bf26f508f5eb5ebd6fc66e2b6386d09cc6e5006bb33ad5ebe26dec0537754c25d60b4dfd62a66277738dea8c60e6d99074569d9864496ec077538b0d5d239061e9fe39d38940794ef5c8dc8413fdb645a0b9a6542b683add19a2dfd9370819cc930e69b5417f9b4ce20232625faddcdacd7a8bf7615af302051326be2258f37336c7a32b95bed6a2f8d3ff8c08afe6813830e0b687add3df0bf9a0e9abdd1fe0ecfcdf632086d1703cc390002a479aae88d42694103d0fd51e196997e3b0f53d3a963817a44efe0a17fb463ab86087bd3159a0228359b6f91140c536d4a782390bb416d2c8dfeff067ba63d19c29e291110e245d511a4ca64192ef5c9f724c2aa24e4f7a4d5291465b893f379086b311e25ec520216bca51d9031500f28a567a6589d9f17f78076a1d5c2d07d7171e2d638b693cbeb5aac729488defd18ecd38c0eeead6677882fe91b7a9c190c1b76d3aab35e0e30500b93d67b6e58a568011a82f3011451c26a32f5cdd21923c58e37a20d07070a6594df20484216f1c2915e3124217ee3105f924de850c46b17fb9e7ca4c619445cb0b4782c5b1d7d1cba1d8b4558bbba90ed4e2c831846352b9ecad2a4270e69d02d8f40ed6d793b0704d78450ecc31c96a8bcb8abf317dbd4de7559a8f4e8fd994f301027e8c52584e45f418215b349e5d99e53dbc25d6baee567fb92fa1afc6df02d5830d4113cc00f298c8b0a3075f4787868b766c7b83cc82b71d40d2ad6c8f46a4a5af07318d2b6bd7b4f2c73be379cdf55b3337763e671cefc0ceb675c059c9792efe267fa6f7337a8d21132cf3916349f6d1aeca03b7b6838982e802bf1fa3b56ab7be3f69a7dea20bb050c21d2af8b29f52ca9b9c5db25bbd9d9db5856261f9aacc6db3da9d5fb93c52cea31e5f3e59d0c0f99dd6e515d784b6cdef98426e6b6912d6cc2244e820d53764a4209a78de140dfcff7797228dff2e9501d4b7d3b0906f22002f1ff04edbd343d0901368207f1597b862f158ec4511ae3755fd9c4e407d1f98af3afb7cf7e987a6861783e4bd9a02a470a0c4f97f5c45c2706d8a2eded7352aebb2ad3c6f364116df9471c9c9e09defcfd1faca81edfac5c507fd72649e191145645b5f316f1bbc3f7c7b58369a05c8d0dfff4c4854ce54582b88dd75024f314f7a57727cbf9917912bf7f97200b68bd3a3c19e23228ea73182d8b1921cc921d1e116ea24587a424242c585e9660e40a8bdb6227af4e2199bfdc17c4c2c891ede84f9cf47d07c11bd0694fdb074daf1e8c47adda2982d034251feddc08bc85237a0553d9dc48f854addef2ec58f3ac604d68d2b7e313d6aa31d70189b3550e493e9fe45197bf0ec1a785c5da33e3d237d856a2a28edc7df6e396db399265b4776f09f7fb6742c00960b1d39f1017395fee12d979f985a7c9c116f8906cd838c3ec646c7986b07a54a4351d987ec928881433898c8f46af1902832aff961fb5cda479c307f1ab58cc3667d9f47e0d25d6f9935ebd5c3057dff490423c834ddf6dffe4f2e325a0c41b1aeeeb72fb45221c27deabd790ec25c549c9799e9d61479a4e5f757040c54585dd571cb28a90e043c57867020753f2a2e9550c798d4eb354708931f35913fea2bbcc864932cc771659b87335aa4475d399708620085ecf73b5cef604e26614c4b61735aa0dab534cf042adeb4f8464b96f25c1ddf75fc7db93a9c9b750985281dd508aa3b230367c19c02b2200aa3f5b37fba535e3acbe7f43c842a3654bc0238edee41f07d8894b66ca3866f129bf0b166e0249ffbd6392852e3dda3ea0c836970df976197ba26fe504505821c58efd7d66e330498d3ea4fa9b3939a8ec2455d04a4692eca556758cb164bc7f4d0ada9e6a2b7e781b781bb777cf21526998c53691660413714891dd06bba97fb22b3321b327b1fb9392cadd44b1e3658e6b131555c365a57865110fb20d531189ce89a3549413f920af1baaabba5c6e9de5c1a1b3e257815b6a102c60b453d6adb0a70ecde3cd6f854c8744417b365a905c32c9d622513e82d19b6dc21f610f24fa89750bc4c56454f7471d4ce637d5f8bae9dc124368fcbb1114e503aeb611054ceb05a3fbe957869ba3bd1e6fae6374c7e8516e63cb449d86a781f6a24581555c10defadab038d6730417b3fcf0f664b0141bcd9d99ed0a31d0d7628c7cd2a3713a972d1a4b756b696ca8d012c8492ddfc6962a4f9c88ed7689ed30700ba4a2b800625d9acd539d912fc88047714b6adbd6ff00e635a083e14c0aa499c82f00a520b3b230e9318f626c915ec28e5d223b419178e0070ffed2951a1c02267d6a1b20752311f2998bd77beb844603096f64b76044fc49f7f6f369faac5e9b3cf656f20fb9c09f87aa8a144266939c75b2d7d07b5bc6b39b2b9d883b2ae71a9011b83bb393223afa9c78de9549b4d2530e773112190552e16ef374c76b9264231b3319fccbaa3ca69c9977c2c4b5c50ffa3e41de26c1a74dde1368aa4285f5bee05389744ba0e68c51b099bab22ebb17a753e500e6e552bc1b5e464bcac32aa1680bfb3d4ad6bab015d68354c0eee6e1e9b8ea160cd32312e9aa5ae86d024a7cfef0358a1ab1a3961e3fd0f0a0085167712ad0a40174176bff76b72787255bd8b713b9e977b121e6f65f8b315390230bcb2d6661163a339703729c5074d35b5752cd2476086a8f71f2fe4855b7761fdf3406a91c1280e69799ad9481a2083bb1a21c7e91b10eb98f97bc4959706263cce2b5b760c87c71b4f2e3905e9836acfd8ed326ea4ba1e07fd6521301edb4cb55c7ac3ac4fbdd8d449d43df602630030408fd26310ebd1b95459f7a88d6a655d886f6b4ae98481d930dcd4f0eda37a28f6a1ed002a54654058823dbe4022e911f6e8d9c5dcd7984d047586b40c57b26c1c7b7ce1c41454ade3d732820ec600b5092d34555310e7cd20bf12c8f00b986c50ef95585f1424c8abc65df1df23bfd967ec29c9fa1b6084486f8006d856a73480239a3da831c86dada766ae9a1564294d77219f1765d07112da97a3feb7e979e7996932eb816b5f8200af409c825923b5280c11e610f9c3b14a8d7780eca839f257708dafbc63bf09f7f780886f9230b19edff4e35efea2884f308d2f388c25a55311065b3d5766a3c5634389327989f7f34ba35f64d9a2b59c52fb2cc15a03e4dfc745340a40d2b97ef6e71dbc5c6a69183dc39778870e55f78fc673b5b44550fe49918ffe2f033dd4596235185241f028e3b89e059b033d04343d19f1adc99e9c4552856af9de11d79d2559fc418756e314d5a08a1657e26e0bdf4347df368ddb20e89383af2e837eb619d4e9a246b94cf5747b53c8127f34ed54bcc280b1c59709b9cda8f6fc1a410d87f7bc17d8f2af28e3bd9f6f0492c1cd4f387e6fd83fb58eab86c8aa46e6cb8b3c316dfe628c552491f5e5ff20cdf6c26df2d86b0dc91a6eee667ea25fe176c96d386db06f7257879d46e0e588a8c8ca2a6d5b2193ebaa1667ded3525367519260e81b580e5b42e471ae377f7dbd6fb2fa6853d832232aa54f52b1690839af1ffeb6c5480184a3cb6c8d677f9d37c85b3bbfb60e74aee524d53c56ac3f87c6af704d7e51a40cd818ace5b8648ec8c2c5cd20e21b2e9a926c1d18967e83a2002f2dd15e9ddb286d3cb57555578b9a7aa0ee09263e0f3c297c420268e9131b8df835b6bb1f7ac87196fbb6fbdf38d7a5242ab6fdc68b5a5816955dfb87fd71784fd23310506ea45d8ea148d0aa16f2109c5347cee4127a5b9c5060d7b31362af935540d648cf28965132b5e39680bfbbfc1d261d7f2afa109c0fb9909a3d96bf6fcd9e69c4b6a0afc241d60741711406ebfc8c1021c7adc2a835f7021aac2a1bf36d9f6b11fabf0ce1260ebd513e3e58a75f1d1499c776696b3f91ca64c90e064d0c98503e3ab168df3747209a53556fee38c007ef1903b2a75f54de87a3472032a9291fcc2250e685e4e5b462349d0d7a96cd3baf52df9574da9277c5eed2c30f328588ed477b23216e81c3d1a44cb9f357665d77b915550d6fe845acbe7a0ee89de51ef120d658140858886a338846b67962f1ff163330fbec50a50b375975866b8b0be265d82f2a77e6f2e8f2f7cc790897105e9d414b24f1324762791365456a020338aed2d200c129b05e39bcdd4055548d04598ee4ea59decd8efc3a6aafc1ef535ac5716683167d887703b9eb767a367da3168c794265534616882f96c8fb4b5366e9d4b972238a020ea6294bd358314efd74cc483d58fcfe691b2c5fb53cdaaf6bc403f568d8180f8a66dd2e300686ab31a08a0af52b82688b9d31a29e793f20b3625dc867e4cb65c2c8732c13cfec4193348c76f8a50859e14d32d0af35be8bc73e93af86d1ec4167f08946e29325084dd7962cf8123ae82975e2d3d5965b16912a88dc2b23fd4c85a02e08321d784e656a4707e6481dc7fab5606b37e1464a90554bbe6820e7167fddf99fb9f7cd8485473ded2f5cc8561c13c210d91d10fc400076531150670113a265f5017520c4edc1d99a1ecc5c8b4427309fd34f28883770081f0ee842b3f62a4667c72787824eb2e1c7e43466c146369dfdcf444fa8abe56041b1458221db4e7b56c6c3edbf2874614639b3fc776622ddc238399cf1f2da90e33e61cd2e2346adc2a0d7a39e772022220be1f36eccbf32d80d6bca42672f9c818d433bd6f88192855f009512ac3b6e57f2bc3b3aab2900e3e0baf43d00775bbcd4d4a35083a82671b565a233cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
