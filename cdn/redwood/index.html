<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0755cc6e775d66fbfc282d0a609758f6d250f2b052d684842f40696cd04a38a692a9528109b365c57e387e019501e48d92e9e735a84f6b004e5a7e2ec12fd434d71ef903d229885bde9528eac79ed49b994b5eb0ebc515fdf701bda1d554c974eccc606b83c21abfa288f67d00f539d04517cbce1b175512ef93722444000de0fe7a74ec5c347f29e74c294bb8e973a9a5d316dc9ec5105ee57c100245b812a5187c702f44ec6d29cb609da53adaec8d41d02101f959bf79d6fe535275daec310853ebea2f857159ae86e6161d79f1fffc1a4e86ba5ec8ad8fed68afec7ba055ca071c4fdc48f198c97265dbe1d725cda4d8bcd11d6c9a7cfd7c672b7224dcb37f299598179605fb4356b9b53a2ee28e6164471546e36e14ff654a3339fb54d079a19b41d6ed1faf864a624d961ab304f2648f3b91df3a12e8b2a9c37d6e8fe24bfb56e0acd21a32fe8b62d44b54b153b77b2e214196201556faea8030b089b1bd1906edc9d4fad6b15777c411375768db1ac709493f0c291efadc73506565244ef74f957ef5e373face5af7bfca11a5bedb9ebcb4b22bff8f72127dd6cbd7f99672fc9c366629df599ec7632267483e3213a5596126f5f429f6abb02f1676c85234a5e5e559550da2970d94d53612f7c5f487d06a8ac90a6fac52d56206ad977124dcf967fc0b34d237462c3b5cf547a30a84b27386162a28a5bcba4819e5d62d7a2ce3c6e0885617713fb0ee99bd5f259d518a343f97a32196cfefd086c3146e9cce2cc3e7d7f22010cf53aa3c80e842c3b32986c15a14271ab8abf8e511e0c7aa5273744273cf10245fe32a238d462181b097c8ba2b1b19aba740d07d5f9a83e2e4a4e9ee8141a7fda47295708e7c1adfca7c5262da7002337583e27ba99dd60b91434536d5c418725be81289b0d563b4fdacd1100899d523681046cc0d2a6e1455d57e1f9e4581dcd1d6d9b671c205939de004d1730b990d61dd56f58b483b5d4aa8620820485a9b54bc982e3c8095a21023fb6e225a888f6635c196608e4a44e2cf14d4eb76776a2ee7b7a58a987f1672bf96857cba8dca6e6e0a4cf517194b134dd2a90496eef351ac354e550b7edd8e8dd2437eebc256faca6adda308f8c1f08f01d25c0bba6c6454fbbde91d2db08e57c5e5cecc56ee79ba6b9db1bb263904f660606bd804bf66ddbbb48ef27f9913660d4ddae496f6fdcc9fc1bcd69390ace86de3e439436b04e7f6f7e4978b1e2986efa7e9f1d46970122503ae9d84e5a5ce2a691035e102fb672d9de2cf239f4cd1f0c7214f24bcebf429de1d9591644ffdd669846c93ad2da5457cf598dfa98f346b5c77187d96a6ce9fb412f6be150c650f3c83270554d2e52cb0e0cc56f2f3e23018e5fb4804db08458f6607839d9b5a278d49a8a717e652fc8317ad67d202a9d6dda64ba8b98e00f6788bb764eca2a7f77b1ce6dfe83b0bbc0f2f933678b9da79405c93d268171ce144870c127b62aa2e9e905146638eeb60840ff2641613377ce570bbf83e035fda1e9a5cd405b32c7b4b5c47b735f0fb3ddc6c83e51670fd4afbc7d5b99bf73a76ce39616c50f0d796423e22a9df1d13ddefedb93638fdc63349d5c6d645bb0fdc0d6eba9cbe6ce9db741c70f90806c2bfb73142e3176815ee1bbb5223a07a3e370cc72dc99036b521a6c3b67af6c26ee51ac409e9304c752645780b96e0817159d29134d11f022a9d3ddecf70e690b3437843ab5a74ceef24aafde92aa6a149c65f330f85d9601d32c44f5700d6eba4ba7be09c0a5827275c77223ea15efff00bae4b93b74a7d042128be64fc393f2ca9379c9a2247dab96aa1a29a6b7f38a2f602ee4a03a55069f30c8603c14011f569adb8a420bbf827f6683ec18746978a0865452154939f3ff81fdec25ee3c01de7bf31bce1ca9a6cbd859937aa677e57a9c9489699bf9e153e91755854d84fe2e284c19440bc0120b97ab21b036c067ca1e4561f8b2492ee1871e530723a99eff4b96ed690ef2360fe04284393b55c6d3a99ece4f34a00f2ee9afb97839dccb95b8a79d569027c87429a47c794cd6f1f45f3630af7832a70970f16ffbd3e61b89730d568eb758a1900b656e24d24adee88b4cdc957afec4369c6e456ace5d7a1daef4e250361e25dec1cd74be1eaad3ed098552ed35d8d5420bd3ea231e459636a38730aee91bcf393b6e9bdd3504752aa9d8a36da106d0b71070580192b8d971e41245e968dc08990f7dcc6637ce9ddc4c35b5fff9ce5992de712db36dbed2571a337283126cb0ed07b8147b8501adb7a4956c3785fca20ce79ac8da45dd8c027e117c953a24f128f8395eecb25d4261e11a1f2aaaf962a37747aa4224ec77f37d7a6c08b965a9fedd8fcd3332c24f99a9fcdaf6cd522d85b52585addbd9003c6c6a65ea677ae1b4d2daef37a62cfb63af8e7ce4aaaac06a0c3b235bb38ad7a56ab5813ded39f59578af078808eb2d04901e80c715ef59f2d987dc0e922ed2e2c0a7873a8dbf09ebe85bccf5e05de05ed8270a77e798cf8a4b3ac1034f79f041f591056dc7f324503edc4666e7e83330ce180d9730a7374d484d1b87a895f24d255a55c819e8be1aa00bcfc4104ecb160969a9b4429b5a9bf3c358edd03d6b4cda0852ce5c34aa1f4b82976492ec8e5be900d6265e6d0965062e2205b8ee61ff7d336f7c7ef317674208d605db7332afd35e0df9c8bb79dba626864d13758d572835a1ee08636a9a1c09dc87864658d88bf80ee51d69336f677bea0d998bb8b3fa902c32150d153a083fd976f6c9eff517b345ef64ea2d25078713c3700c6fdaeec7d9c6e7088712f8181214118bba955a1bb871cb08a8846297e4870aed948402795a4d96e8a99332277182b79a54eb0314fc9b3b83875c360110cacb738c21338c07b6608f13ee4f501d461ac3e29d683d5fe2425bcb12704db10472af445b88ea8918ec003ab68b83b7272782dc117f89f9e78d999c98c070217af8df45615c9fbb1f7c1b11434b354ef702609b05668cb0d1f268483d6ec2411431e8db61eb70a50dbe06ea218644bcf85a2dfb8893797d99a882fb958e85b69c6de3c7fc1e655e9d3052eb52199ab92151ae924e184d2b0e2f859333a3b010e7c731d91bc0296a1309ecfad969d2b039f934013fa105a0bbdb1ca3c915d4ad5d093580178a29fa789a1218994930e15e446cb6315ea8deac80fa04ff5b490f2629b172025ce7914c2658157704859793e2fc64be3d24e37ad25d498a16e2910c538879fd82da1f48f394d1c936caf175b7b73c78aa67a729859db32a11e5f6e472a977dee5e4420acdfd3189e92b8510ee652dc2d8fbefe80014fbc3cde17de4d56abfa3c516b70eb29dc7b971a9469a77254397fea623ad7f663db220ad73a125c4229005f7b3be830ef6c9e5654d03b33f43eb379da661b60f85a627a5e4043e852918dcaa7b50c2fa3e67f417ccbeeda429a88c65c9e2abf6f5249530ae3f24b56f20520518beeeb17d18588907aff78a04297c9292e2f66fe0a319c3cdba14a0a11c71f6826a7d055b64bb0d6548ce54fe8ae8d678c9bb5c40cb47762e80eb3af4af540c71c6d84557cda8a50a29881cb74f84fafaab74f294b2a2dca3b5b8c5fe95735e027aff6d6b7120908516c2929510b8749db0aa8e317c2c9778ca3a8e8cac4e1f90be7322a5c52d30930308ee85de86823ec36e1bf6681b7ae5f9390d171dfcb27a6c0abf37f51e6bb132092f10c5df97578d2ed515006ec4ac9ccccebe8de6dbaab6afde4ed264525b24dc9894a5e7faec247911f39e24ee6f3b35540f0d75cb1664c3d52d5cd128bc733e56ea260e33a45493faac5ec31ceb0aa92a1abc703acff9736f33b3a19236abbba3200a467f29e59da29381246ec2ce96f4f3cad69f48335f3421617abe9eecb350b7466badc0d235c69033a0460430e54b8d80750f0c70fc4198580bf41d23d47ec882e3e98e7c52633714c642c4b50c0e432ea697f4ee3f54372adf79a8f98e72e168df52678dd1863b475c1a8accfa66409efff2e716d629044773129fb438416eb6a951dc759f373ec25ff6e589cf9bb8146909b6394f6c52dcd8788aee64a8b386536d88d4608d34e1629b850370735584aa4e94a7d951b7dc6c50a8ddef3037cc0fc5c43cafc4b4c0f061544aa985cda9614b9250811ced4310a68ed60d65187f93869632535f77941c166c1ed70f8731aa2ad7ddc2b55cdce515ea29e63ae157cf86fad8a2eaa6bc64b7f7f5415e5a3be2beba45063652ad19226608d44bc9b2499424e3b74eea81801444669c4dafd658818ff40f4952f0412117a348cf26426638712efcc9d8c476d0edb71de9ec03b0bf76185f676d616b1f35d3b8217e3fab67638a557159190b913194b0a5cf86d4a8ed65d10ef32206103d757570570175c59c52307f71732f2a7baf8212711fc3680030485be5fc09400c8ee8de7e723fbf4a717cdce06fea249148a5c28200a4cab56c01f1b0f7e7aa4e46ddde5f31b7651feac5fb5763f889e4c30bf1c507e4514879ba1bbb0c87a9835ab2e98f6b326c3c87c9390585d67f83b7ead40a4890a08c975544262628898d4155c3b94dd87fdd614ba1c3b42f53deeef9e6eaca401287745266a8d0dd544e6c7ba45756e38c754d121e7ae938e3786f8fc8544abeb7cd7c5075dca3825d0284e617afcb8e8636da7a763efedc83f081b6f0ac013f17441502574b9cd8116a39af51f0dd318647f44dd92835f754a81b1df76af960482f35be42518609ea5030f9680aa215f1bd366e763abb85107acd1e389854225227bc136592bb6d0973ae85d6138d3023a32d92b166517e30384c5c1f9373afc17158c74a07ef47759df62287f73fe05c1e7770408558c563f031931566ecf2a049b3cfb9f82aeead34baf7d8899c44cbae9de03209b10a7273f8ebcd18cdeea2b081f941a2546e57d3e5b75bd6aa1f28b2353e27b572c999aee143655504bd3169debe81493c62a3cfbfc68c55c5270c5a587565630976a2704254bfd98cfb1f5ba7d888787b5d405c0c8ac73ee7f48a299adb3e67f12a377ce2924c0937a44b7d390e99686aa63e1bb3905437af624bcaa6b447a44f237448052e0ba7768bee84878df982bc7558ede5d5cd23c6019d55077de967839bb536d75586855db8527120afd0e69a847e4ec0731526eb11b3293bc60f654d68566c5ad27fc25b2f651580e485a7367f9aba0ccdef7956f0418073f7053231fa69c05fe122e909dfd44184744e2d205755c3e765d77deccb1c1a2bbf479b44d01c51a86c448e7a1a02dc8cf05841cadd250bad856bb1a7bd09868670e4e8b9805649fb95c3bdd748e5a072afabc8f14d2e2a6e8377d2de2462a829a298e8b74e506696f1cee0fc28096258b4a770495f3610096c8c746aaf644437617a4cee4b2b8263debf54fa1cf53291bb413a25fde234f8f8baa07bee030b14ecd40068c9beeee818bbaefcbe2fc52ca22f9e443b540306abe624f508382d7086c7c5d458096a2d3752114c030edbd2a326243304489d8787e387cf35a4d6c8e61247791cd43d811132a8a6f7eaea035cad5acd48949f2074da6a212327bc03a1f1b929366fcd459080defe3433a9e0454662e97cc46fe5587b8e85839067ec5373d4038b238d1a52c4010c4e6ad9df246e4c7d6186a712e38423131c8440404deb17087c299e113ae5c57fd1309a91b8fbfffd0e0e24d2d26e7e8025965369368b70147f812bafc5210685045e0c8c89fb1a672ec3aad9b4987aa93ba27bed609b114e1f83b8c1436afa27454450bbaff59542c192ee7f8052dffd37a4796e8fd9cdaa026fe90ae0da48cfad324b02205a77e8f65bb076c4037642f1a8db6b815ce93651c1a532fd5d30432ef52b1dc31c0e4535a80dcb459bfe85579edf7e860ca0fe5bd18da19ed0081099e92fd52a4ac08f93282f94f23972a6f1e79e426b8200b9d39988d8969789f37206878e270998f16d4d92dfe729de28da322fb0fe77697811217ac5e0442088866e799c280ef179a81cb0f1575e0f8e2f0141962b2ff9d39706f020e2a752210154adf4756307f980467ad5cd80c561967b3f39662c3bd04890d3d852ee5ec19ec88286192a357b4f8f9078ab336f68b5054a6df4aeaf226ec8fd9925eca92268838acd6201f891a54b85caab39f278448b9f48ba077e8d027cff8ffac72e9a3954ab7e76ffc8b18371d375e1b2987262ebca0ebfa283d905b6621b5dfa79a7f2cfe5a1c47ee3c511434e5df3999e936ec27046a10d0b1d81e1526957e5c9c478ef9085be23dda1934b7863b918044dc955b45d51006bfad65d1d3553cc80235bd36f216a3e313d338432539275a134478f33be8be985aebae8e3ede216ff33f3802120506968c04b81fbd3ede42c75456afeba7d7391fe629a73ceed67d4528430e724c959785c7262df0e6a172b0d070ce1026a26ddf74a1cef15d6eb72f0cecf431713458adeaf8b8f253e5c3575e733642566afe0c943ac76afeac5d6dabac42849524dfeea3b449faa24b9b7ce66f3677d62c8040008d20af8ca776439c4fd8ebc0964238beb48580e342a591f924cd97f5596a1c3382bdfad415366c4ccb4e7aacc13907d9a4c8055a9bb8c65838df3b477b1c90fdfc585dba656ec8b39da995b812ee4466c9e5ad16533307d74f6ee46c491e8cc4f01cf86d7177b6d2d9684b79ac2033b4aaca4abfaa2a9476f1ea30b6f4da0453275002728f2cb93799204283af00c0cfaf5603c09cc4be79d6ef3f7296f889552f7eb54bfbeef0ab388033cd88d5483684b681dd6e90059e787838cb5891ea2d88f2f9c6fe24d790bc20cbbe029eeef2c6d4f659f52b634e0282f560d2d6505e327395ae9201c077ab27f00d9335c6286b195bc36cacf231f13121d6ad7b4c82d38d30a90219f7f3903690ecf62c3f72f77d7ff2f3cb6ef14a150bc24cebe44bc24ef4172fb1834a3816f845c398c3928022c23640152c7f65a8275e908e847df80ed9b9b0b90681781dad59e216cf4c33123f7a521e2cc1e82350506a3f0c5809959aa60230937984991be212da8f14911360b6fb767298e3ff2e85482b54ee858b8c78ac3c72af4797ab3d7562e4be9365a3e447de53d46c12fd105a4684f083917743d261b83ce31c2d4f5d541068354ec15f1f8d2d15f8e9c286c0ded433b6eaa52ac9b835a20f95504029c11baa6871f47270935f383e94a57d624294b6ac533a2c2f3e72b56c77ef53ffea38c7bf47894a1c35ffebbeb9b4a1654f9c9fe1e8a58beffa7a4708eeb98f97505b0e3a15788a307b16577b4019c4f1df867060713b20712172d851ba7541a245946ca084216b23106fd0735542b2ab4bd976d125334117464c0fdc656f9c6adb2a6a5034d791ae10140329f995399e24f6723bb675b9dfdb800fea24c528dc8efa0e7729009118d6feea53d795afb20e8fb99304be8f93c72adf416a48b88ef60c82795c7f1cd20a55c5c73974bf890e44bb658347d66590192f2e7e9c47e84871714a3ec6320fbfffd37b25538e906ec5cf1e7b7eb303df59a6ff2e85d8d70fb30ffc7abebfc3d5153f33c22356995260d0c366eb33e0c90edf3305bc745762b846347fed911ecb96a7d17239732c5950b34f708d543ed12fbf1e8eade6bea0d35dcdd44446a4a140b5dc6452244373c15b9c0f2a09878bff2b3360dc598929ac7a3ebb33a696db7e7ca29b95c3d3ec55f17cf03157b68d8d7fcbf0d94aeb44da8d432e0b7953e0c40c44a146a5592e50eda7769737a5d439b33098e79212a46a9947697348f370904cd6269b4a1989fb2dd0bf43aa52edfdfe120356932d9595b4efba05aeab9aa90b9a1bdcd398f2ae247a9113f30b2b181118360b1abb4f1e658d3f885be4b9f3ec9e6b9017ebb080f1af178d2c43625b88f88d314bc8d8651f3bbe184ab036a23bd433efd8b9fead9078d96d94c4be25442cf7e36e9e52972fe84c967059a9e1b4b444476d840f1c584b1d76e1bbc0eb6d5791b7c4186b7fd130eaa4ae98ca2c0bdd2bde5c970950f2c99424c1e1f11427c8f889a4b361828843dcf434dd641bb6ef3bc1c619deb2511a522c0432f7705cefd3580f76df91e85397244e0861c807700f667c1b70f13abfb8f800cf1cc59b5e0112922d51331d7cf3a015c341bf3e7b5428549a65b332c493e8af6d6125d1244fb0d6779fd586e5e337a1b0b4f50e9c869cc08565f0c6b87bcb88da43ea7eb5c8f93e7734cbee036b2353b38133013c797900564cf3912a0239455ac513fd75a078c53368b37a60394ca816a51c0b5ca971b5d91557d59f3954430768a41f3e067219dae7222c6aa5569697ad9096788babedb3da833747b1ddae5c6856df2703a1bf1627b44877231fe3329d12ae8a1f5f723adce9128d43a2ee93b3e4b45c83829ede0d0750f5d8a783aa1e9bf4b93b1371de7477ddc83702d520e1486bcdc41374c89c9d76ccfbf4ff198cdea8e1da726b3f0596d6e475bdcc4b33b504c658eff612753ad5ea2e8221dc34e7194e99f1ddee2dbebaaf02e59152f5d9270b8070c6d49312612c18d2ab72b1a806c6b4313072a89a8f77746475812e3f4f3e243a7eb9a67d8592b21eff48870372d24a259ce3d4fd4326a4141ca445de778b5ab97a7074697bc5b0533b3e040fc82c4af7684025340b7b60cacbe7ce1790d4557be065c6946a83d516f4617ec84f78eeaba058f3b5af16dbbfd50efc82a5078b1e3130123a2e3fbe19ad372875403781f4ac401028b73026fc3e790cb0d796c4620efb33f609c8a654acf10584414370a32e77aa0ce622ff6d6f9fd7286b9b5122dee2141846015e2f87db396b4a1b0eda04c4f7f462051b7cf245c69e074372379c1165f4277065451103e10d3b7adf9b870cf89c20e35a5d5e5813cc83b2cb091442828dff79fc1158e86d8284993c7a7c1c9807b2c6e179443dc7c74869f71787ec466228a909a485ce60c969c33e8987d753237da5b69862cedf81d3ea8b6bcc56cc92daee0e5a010cadf8d5de72fa3ce91074da1187510e04cfc33deb70a7bf959ffc128d5e48d2abc48110ea61c18043bbb52c335bedbfc5f9fcab86b24ff43c54bb7fb139083a175090f219a73720f5f2229a05734b6ecf15d8e58bc35dd91a8bef66188e8de12abd65277c19f845f56013c86dd5b7c1f81399bcb091497bba23a307194632491b9b402ca2c3c24f2b1b8380d31d988d1ded886e90cbabb28a16d32194ce57f6721e7c1adc4af21b991026a81886a82a43d192b3f609c63316d55ed9016bc03d25ba25c26645d7fc1d5202379d4dddc5bd02156a8b527d339de233081551f86cbd9afe657db78b37afc17efdcfb5ecea853e57644a9bc2601ae49e267d3f1e54505cdcc38daf0ffff0d999b7f47487fd2f7f381337114c13d1762d0e9368a56f06e1fe404e3196035c8e3356471e123f61fcac9b4a97af36268ce8da188df855c879bad3d330d8277f9ffff8bf918eb2d5063fc4c6ff1e2cd76e0e3751aad635fc4041d06ff09962f4bd3cbd092270a1ceeab870125e5b17f3899a22bee4b8a83fbc19b26cd12e45772c2d8e8b5357bfffa9df63765e9f0a4396c650718a15c7107c8b3b57e58bbe792ef6569a483e49dd8f61b221a12132e1a1c02a92165074bc8cfd6964bcfca1e34f07587fdf0fc6ecbb185bdeac21ad9832106bbc5687383dbe4dee3df1db3ebc3a4589216ebd0ca1094772f386699703bbfe4ce9a17dbc3e88d78c75a5fc34f15d7a3b790fd3fc1bee8743794f3a6b263bb70f5eaad5cf31cae75524ee03fb8f20d3659fe0792441034f11e6c533f3f0c93614a25b6af3fb76dd01caafce25c27b5101132b04d87de5f497421b7754aa7e8f535cdaac2fa3909f101593b988130ba27e2327ec583fad0bd3e23c9d0960b2d44d131b7dae91b23392dd24a4a5e435ba1e886a2fbbe742f11807d259a667ab0c0f0e8f55de71af6e609c83045cd6aa4063284246f54a1ce97e8cb51535b3f4332a291fe825e22c0ee0b7bbf915b3f2baae9a04eca88d55cfe24a71bf9b69138a1662df172da111d6b591ffa4d071ef2119750e1a1674a86712b369d7e810f44fc1c667a2662fa800df1194fc60dd7673234d2c1da154e4dac5261c558f66586426aa7fa23d4a43de64c5e873ad9dec58b00c53dae2ec0ca15c0380cefba27fdedb1e695ffc16a5f4e74f7b6dce9b62fa4d2dc906dc7890cf48c1656452ca625af8d8c8489d356b0c777cdfda480902dd07b83de86de8de16236f2f6a152620da5bffee92ff7a5e83b63fa77c9ed7ae52866bdf9e42a950af04b2682bbcdcb26f459a45a4ea35f960862d6307cf8b059b3d47a09e6b35bed74df407d2ccf21ea81c64aba6e056e19ba1c9092c7ae3b419d1ce243f2455f3a17a0f6c6598d4431c86e1157cc10e1aa07f263c917bcf9f12314f1b5ac71102be057420e79f688b9c18ec4d72f9d977b8c537119acbbe969b088185dbb44c786b048bd812c0fe8a65ddca9bb007f78fff81ca2dc06e0fe196e9ce95586eac7542c4d947dadcb60e9a5f68ec4eb9e3906426263d0db10146e1f5c48ec96efb3889e3602869818002606400b3fd687de44c26431ed5ae7e94a9112323795a52afbaa4d74cca025240b8fbdbefd7bc736d0c5ab9fa5238e0126ac6879ef957ee22ec9fc86906309fd14489959a6c8e73323ed42408f22802c7e604482b762d5b0211d674c3128199bbfc328408f092f202302a7b24e51c4933820207a4d8712de1aeae3f2a1ff40f6a30962c8757aa26cc49cb2bd8669d6a57e7971228d935471352889083deab66137e5de6e8595938cf3b0c897acfa4a737892d27522a92c80852922fb808870966de00a34db223f0ba1aafa2667379869b09b9a100e66b4973deb6751c870332e8e52366accf406b1fae0c0054fbc96fb4af7f38d8c14f3b72287cfd77edb91a2734aa28594a6624cbc89a061864b1c690486aa0d17d3c724369585e278870972fd199c71216057186eb0126271eef95d8f4e99eeec71891260545c5ff91fe8e9adc1ddb29d617fb4720836ca1520f0f4fdb35754a4649271eb08591b91b62e95d913765d77d0955762c2bd81d26060113f5ea6b65ae7592a9da36e5f59eaa5ce7b1f52cf4dc765f1bdbb5a2104eb9a7d6cbca450eb2a805972e78d14b93aa5dc4de8c43d155239d49ecea9c83be308cb729c8060758724e71aedce2c6b282c1f3f595578424d7a1291d5a80943213213e5b585f2077e680137d5e2e6989f066aa5753b86f3afd913e1cac99590e5bf3607906859560f736d44c35cd4d241779941044004d2af26df2c7be8ff0ee00919d93b0e993bd5fe253e551baf3eee23197502810ce371687023bead03b315347e82553f2dfbfaf20628c0b4e794b97bcd885c0733436042246d5f628c9d5ecec785d7479c775a0988f787abf1e9a5358316142a40b53af82bfe1a67eca7933214e7999f29a62ed752161a10bef24b7b4d2dce1f036b11127003ae14803f68b481d4806b425c9f8fe6dd439e9d20b35af4422f8531b133fc2e1bcb4d92047ccff2ba150b6ddd0de53190441909700f7a5c5f922f4fdf63218092fe1db19b0bbe3f44aa067d27538aeaaa4b451c1e8d3cbb912a9c5797dfa009fedf0608c52e1e8e7ff0476d715bdcd63a16ce9994ee65e355ed7dd48124f3127fc55de8b32515526466289afe1f5b98afadc7540fa4ae7297e0315097774af089f756db83759e7ec8caa51f48131226a0faf64f21d2239c3499d0368d31792ef7fb442f9371e66026fc940db9b0b6b50ca49f6474b468367a20039fd7c666044c7f43ecabf94c44751c8cbdc75a97fc4dc2edd360127828424ab8ed87873f20193c957c241567ef9caa75323cb255d193703028353556aafb7de2ad0ec24a1a59a42fbc9cbcf517d5b757f8c105bf83205f725f42955dc11ba4552da9590d2596f4c167a3ecf189d58b4e964a883fad516f7ffa8ed7ad13a5cecc7e653dc5dea1a16bfcb345fa2778b3d1f10cbd3fc5e4d074324e60a963f0f705ff9d7e2a5eda2ee059d899d75b3b127edbc994782472a65be4e4459753ef7b57c1c6fee1f3301f4c8bc9b58662274a9393a14bee7da8d2d7c9cad76d501b29f3cabec955a4541dad6dab2eb8925c40cb4f3bead40146c98960345a9b3a3cad52e8b5744db38aad0ddc0324847c2e8620b5feb96bd7a89fd7a90bc5b85efc11da1f802ef1c1fa8e04dea0e431a3bef14249dd351f4e542fc7a7c1167ba8ca22b1b8d1676091d80965d12c610d4da9aa57fc2feace7781b1ed160040646c81d693db5aee2e4633e2579dd9ba94e364b93b63ee6db696a96e31edc574ea44adc071a00e7fa93bcd974f889180f138a61907fa6e0a21efcdbf0db45824f04575b6ba5181f0ef5d84c89024758fe54012b419b17a777347dd08fb776d991944bfb7a3a7efca8aee5f1ef0ccabadca1f78b83493ef3b19ba4002968d135acc143fe25d7610a66ab1b8e20548f04bbc0c1561901a293233bae49c3460c79f852aa0dfde76474ae131495886fba6383d2dc96de733919a34e5d8af1f9e8c2c7fff0a979934acfc15404d60cf816fb5dc54e1d8bf8ff0f79d0c0a7ed56950f4f5a099d38fd6ab6cb64bae0c17d071cf8a7fd540de4aef94f5cb2235b094c221755071c57ae8c86c840dd6771c1d068718b8362d862645f992bb16753ce3429599fceb6a9d387f00305ae6ef1ed30549757004b784cf22215bdca071ed651cf86b50e73ba7e17ac72ed0ce00016ffe69df2a89423d62fb6ca6144ea3b2227cfd5b35a85ee72f8b0b56a4561b5850497b886e5aeb0549a211e801e3571d4632015a6809bea58c6a62718c9d16d9987db47e1ec096d700490e88453f01c23c72415dfd84a53408e7e6db51d5b85dd7178272c90ef41ea604461d1a6fe6d3d0584536450c903d6bc744f651d881376eff5e2792e8988ec9d94f78c5642957ddd5682d5768fd22c71dc93c51fd725aadf1d3705299f758eb415cc9216df0417d64498ca92464606cda922a00f676b2dcbe2b34c8482c33314fe67f46275aaa58c44c41483a8ac5c12899ba2d3e640d5c1b38eff23150f87214bfbc899deea13e1c4fcd19d27ec31979ad1274edc4ebf815c67b20556156645edbec2b08f0cabb97f0abe4de263cb3099fbf9f83b77c6cb817944976fa81697b7ae58c43b6488457ff6e1d0cce500c54e9f725ecc212b778309f4d809f5176c810d8d3be065fc5a6545ae587e8aefcf49444e9810d9f49c0047454dab2723111062e34a4915542e68cb57e49c6b5dab90023e384ebb9b2768b3e18535813ddbaad7c040d0579ffbab957ab7d29934093e2efbedd24ed83482d9502be409d00bbadbdfab1f153b18fe274168e4c18a7ddf7cf824c5e1bacc13cf5130087ef6562e7a86348733bea5982cc6b99a8fb718fe6bd8cfbb3d1d98ac2e7c258a9f13a8997f798e6361386c3c781670b6f443e38705c5cf287cb924ec07ad1a6a49a6e12c3806ea4ba3350b27e28498de0efd077435b32ad92169b62566b8bc15c63c3b0854de6dde117a3c06ecd93615643d16fd743052b0d769a261bdab9fb55c5c61129716395d2718d99da3f53b853c9eb138e3c825dbe3eecdf7b6988e5dea218759391ce0f6787a364949768c2b8e560ec40e1731f5e89fa43dce663baead0f48e44e17f95d0c967e8c1cb4e91fea159ac6c16e7e81a2cf34b05e635010cc093da195087365c6943c5ff3ff1c0713927e9ee1ebfd4d775557340b52900c20ca2cfb2d240601891452f60a5490bef4a81bf49fc892ea4b975052cf3c6f9513f3b3758add433095376698ba5ab6a170b6210584ec6dd0503b72f1ac0acb4866af14df5b5978ed48bcb9821b04474bb955fbeb74a27fa55aa8ee4b384510c10432a320573cc908d5370204a5c16a9738f8c47d2b266facb0a23b485c622d49253d03d77e35a5adf2bd90eb750fb0d7adb707bb77930fa0040de853fd01556bdae72a5d07f1aec77fdd6e277053f484234ec55f6533eb2572e333c36bc1e90aac791381c874c8fc6801427f2711f53ac85518e0a405de35489c33209090888c83aa0d8f37725a6e60f83755d6f5f548c2a05a2c91da2d12055cb264ed1f13234fbab6368394179020a5e443de893b4fbf0d079f2bc5183b58c989dad7aa38e5c40c8e4ecd3bd7a98a51b57117fbe28c3e45f668bdc8518c0b36f6010086e2e0f305fd4a27f740c16a870eb18ac7fbe9a10a7bfc96f27135fa3f64074b1db72db06f7ab604c470da7923256dc16b1633a4db5209111a53a342230a8eeb42f1c59474f5cec2a5e03a55f350b32a7d5960b1ba53dbbf3c46040cbb275c5aac48e55f745b8e81f9a75f319027a7414e08f48c578ecbb5ce7d193049d74131d574fe7ad371aafca340b4dd9d13c52af93cdb4003ea4ed726162e3328cbd3534e1b5916cdd2f8d36a90dee028533688508cc97472c5e909bd6db825c0bd8a99a6870a884905ffd37a351e28332b4c9c3d60f5c8d62f222c340f674c27b335650a42f06ddfe9b8a52c0217581bf2868928503f1bee54c81440b8385bb1733fd871cd53b88774a0be5e1a5e1eac46fd1d4624aab0535dbae7b2852f01f4ba33807f9e1e78abb80967a834e56156859a55450c1063843649b75687f5747a1ae2aa4bd7a512f82ccbfad3675d4047b8a4eba600b2f1625c29cbc74838fddd901961c4c37fc440d542151b87c0ea5c081b81e9a465c0193594c1ca71b50bd4c075283f9029bd76257d5b51267f9a9e8b80abefe8c95cf8ea4e1e4274ccba1a679dccef51204130a0a8e5bca369a3312ad21120d640d125818ecd2df5d1b83e4a66aaca14fce60829e4731a9adc27a2070ba9433278aefc510d6e15ea1d3844e5fe953ec67eb2e88bebde1badd32ecc270232111607336b65bd105113a44a982584f19f60ce4986bf3528e1b1baf584ef011213392893ea3015fdef58700349bdf912cb504d29f9f6c96fc09437a69fcda35410a8f198890bfce426aeb759e04f4e701161b65b43f4f1850b64799e29ba14bb013a57829e36947a2352b735b2a7de9fb59051cb4560221eff3792751837024ae8e6cb519f2957fb5b73ecdd1af33a668313a567536edaacc94cdaf99d4f1e01c9850cab4642e74a3da5b57513ac7c677a66f1aa051069c53e2a78b92168505402c62a809805b38bb485da00338ecf4d0232dea47407b8fb8d2a5fa60783eb0f885dc9f9cb9c3268b067cc85cc7a3bb0f2b1ce76283a91a9d5b2c812798100715de10c071c6d505f9495a56199d770f2394fd7520f01d066cea5ab4cf686f49301b9563223314a6dd65068bf0b7b86dee194e35962cc9b18c5d489bba87695fae40b67813caa32dcbe9f64b74688501d1d47c4532d469b87259d17140e92feac69eeac59cd1393b3be6da78ad384810da7c9d8db186fd9aaacf7f237595c3c970cac03b5b27099b087687d1ed4302efef013582cb04c195620388407c7d3bdb9823a0eba3ae7a4495bcdc647e643c92f10c52d2f5edf5979878f4e46ec7acb4263c1f8ed075419baf045fccf8c31982c79554cbf8a5652857dcb9ce687c3dbe12ca04584967526202970c70206f139675724ddc273f4e6195c9a7730c5b3739024b788baa28cd8a0b9c8cf01188ba8a6adf6f2fa7379abe9635b1f9379a4b9397afe77472441d77ee8b246ea3b5c5a4f871f33fddc88a772343046034007d2d66af65602e03583fe05f37a340cf349fb7c6f27b7310d277d4d025d991a602d108b19d4c0978561224047a3253e30a605542bd23ab44f7b19cbd357cfd2fddf72839a9c8e70ccb7db0b7671803b04bbe71f535603eb6782737343d3641b8a79c9ac3692d53b231b2d414d0ce5fc38d388fa3b74e4e8c0dcd8a497ec93fd7176aaef30bd852c46ae31e534f3e3f0de3dad018eccdf3f612adec6088d01b58e3fb5a2077d907661d54b4733c78124fea55caf4dfb378e78fc5c1889a3133a41153b5c4b8587393974523a3557a44ca6988a0598330e9972b000757c195c17e296060e5ef2fcfd162d08a0632bb007c677984d2fe5aa145f679257e8b21f279a8bf9b988311a9dccf1077b1183efe37bbb0201e19a495d54e59cb11f15c424d3a008528c81bdef1dd525532f722423ced3af3ccc6d72059ace3506cb4d988a1ade84271fab27b106b6bce9ca0ff89f073052a6931789b3ad0133270fbaca757c22cfaa9d184f0ed161f673abb341eb8af2bfd4becbb41f3334106c7e8ba375a25a02d86daa818332e1c301bc0fe8fefec115fd7f647a46b28159253ed6a79b9e77636afa83ffd6748fca3441af9fbb2b31796818609b057e1b6cd72e4ff2606d339f19da9b2a17268ded845fa7a1c842ea16f233dc64e1a2f2efb77b7951cfdeef930484bec096609c0a4280d1c78ea20f551f90a899619e0a64feccf63aff2602afd5ecb7d57cc132c91af6028b3db75506881bddebbb6898fb4d0d841d72249733c1683391f4369eed41c08f18a7d4f544d99ad82feb8398249b1db2475d638c8dbdc7beb66c0c564f0987d7c579b6182da52da054bd3e3cc0ac400eadcf7e9d10c31ea3bb03f169544fa8adbaef3ae1c73f82322a863715c19dcb367aec2a80f5ddfc11a54d20fbe6cb91f9a495d9f959d5ef157b8888fd633e93a697ff316a59b85bf7ee75fe77da0d5f02db11e56bd29fd1458155aecca7340bac2bff367def14c9d221b22b529b726f7b583ccd566f588de6bc0cd507e8c1a0e67dc403cbd8947febaa716c761ee0d47ab306e14c6b822936fd6ed699cd3e8d088b6ef977709e4be43bac50a1035d3ea4f90efa2451f6daf7eefb71c74999c50d5c28c7c14c9084a6b7d33417b599bb12c94ff8ab12a789362b4bd5472382a8d96ec923df8420b9d3d17141d466a7a18df71a3c6ca984fbee8af8cf03333fe0f6068a83f13fcc1cc949354022fec13b3c445b8e3e376a5369a11f891c46bf2785a2e69f2df50df4ab770d43dbb3b91638a4b714187248fd266299cdbebe6d3319d92cab22810650506fb5804dfcb5456f56fc5df88c479f5861b3961c70597de61d6df5c3e7377edd0535f424018b7fff4320c89775c0da6248d1625da2c72a395ba82ad203977de0ac01be90097f48fbc9fee81734eca5e8e87c4956ebc58e9e75b7d0c85843371fec847ab508a5fd23b4f5cf801b295a26d0a6fa472085552b93c36689ccca7e77f26878f522f12785156ebd719cb6ccb42132340d7b747753bbf5135bc6084a094be83010b43d3937f81bf1e98fd7b9dfb4c3b3458c5d552c2d43f798e621869374a9d2dcca91f5920853ef9c09a0e78736467e2d3497d3905cc05c020967d2916f84139774958cf2fa807c426b9c59b697fed6e118e4e858a32877b8b84dd5a54a54c32ae395afa9f83ada112f44d569c7d194b39ac7d2d0a93b8df4dfea258e1d3140d616204e04421cb40935330b4bb761051769380ed8bcecba5c966902648ac7cc1bfb973bef0709dcddadf1ad406c160c5489cf165aa5f0f58a149a62859df0b3e83a152f652a092a98f39a1c6b38c9d64b7c36ee1c2de2e5a38e0f4ab69c9ece0b1703b2e49cd15f713607175873f75fffda79c2084778165242e626e225a6b4fb07822e0236af66b2a06cdc70a59bdf43b6769a5429da874c662271814756b5e20e49d299f2ccfebb1dacb5d31764ee31529317f8164bc7c22d4f0091c5dd1a24ac121fdbf643f59f6100290afcc9d9a58f98648b5ab82e20acf89132b17f76c9c71abb765d984b2bccb65f329fabcfb527717f56392eeb4bbfb208aec46c54df751925e3d64cb89797aaad42a4a54a0b9dbde12f26e42431fa7a2db2762c9e65203a1a959aad186fef623005168f4c20a8629481da50a9b8ad6232821bf0cf26ab75637f8add36fc3b1bf8233b4ab74fc233c7f8a23866a68b0eb3e49e70216585dfb045a2ab0738","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
