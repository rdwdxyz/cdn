<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ac56e7b874c090ffc2769ff2124a1538595f49bc778e3c175443c8ae8117ccdd3095e4595d8ddd62ff0c1a9e6ca64a6c581e51215f7c23df9fe0047699bc277e0585e7c0c224e836d85f68025ce83548d5555da3067191b1707a8547390b65a89dc13c570b53bbecd352df6e78e796aac4241e239baf8ecf1d583864fb7477be5697f2f58f5e1eb0ced07dc4564641a329e97d62a2bef752f7b53c592c4d6c78d6c1348086d5b0dd78f186ecea6e0c828eaa064a8f4fc261e3b87456a73a71043c2fa97040eec43fc63359647b3d3f12ed577016e07d4e4848f0b7de92b0f2a422ec9d998b71f65065ce818c6c0eb10fb20707c40a9ded1197f59eae4690404e1f706e523bd22546f8d827fa89654486e9540ff227aff8142857930d6fe5b5746bffb82eb889a47c48f4a3e8baa529d96982cf86ed02ebd3ebb731060fd8983a992c1263f4b560a301ccf65c3a717c2482ee0b6645f8a0f144f7781bc4fababb64a6ae2be691a92106ec521120d0de6f05bd354125a018db515ab27e88a315fc1d2601587d2071e948b39e1cb02ba125d6a306ed8c779b265d2e13f7a09a4eda4018b003b730f32d7605c29e25368165874158ceeabf41a428ba8aa9e15995317462dafeeb12327d162c14b8e83525a5648c5e6c1c45ff433ddfcd3575aeb00b9cb0bca76f9dad93b6f39ec81c889beaed84dc36d4fc92673166fcc9318408c1d8dae7cc1a49fc179d66bd2c2b04575793a5b7157142b8fceef359aadcb3d2abe31dc3bf541dfa4cdfc0af581d059595eb9fbba6685fab8b597fe5da0f4d9cb61d46b779832eca06f85fe0e44dc688ae7bd8323d0abb32027a08b749548c3ba52be5d481c7ca7a47f92eda95d9b75969d6e35e0e66a9fe73667a00477d163006102d0caf251b9fae37e504f61a8198d3fbede10e2fcf96777d4163d2c421f52b0d118d9180661960cfce0146491645a061fe6a8f82d163c772786a849131d13ddf8d14199c7c7994d1dd8f8a6d38f2fde2efa10a2ccf803c76cb134f9cfbf7f74b9d6c68b48553c1c8ebc22782935621d6e420765e0935e4e96828886c3806aaf487657e0a03f6aa6cd3c2d826575c1c0d5d2d3abdfe446de4c64f16104a3c16c9c19412e03c570a5885d410362e2a4d1a5fdb604af5457b0a0f5dea44a18c8fe84e26fa06e4264fe3d0c365572aa0a7f7239cf72d13476cb493d1a1bcb1590d9ad2b0729bef7f3e49467ca4eaf2dca4400cd48589da261d588d9c19bb20698f2e5ff389f55f3bb61bc494adfe8b0d25bfac5577a81ca3aa77a9e81f00e6b4f24c80f4c187e4f867faf98b7758a0b558370d8ade84c541cbe9a8d0d24ebcaf08a5a2a83922005d35bf5d1d8941294f33f37fa0d278ae45004ab55c38c9aad531fc38e8096a3b377018ced2834e233da4491f778b7083c27fb9207a0d6b4898628ab854fc4d6d81b52c2b298dbf85229728b0d95d0d3673e9c60aae779c3d8b037d975b2b6ecee664e8efe4a59dc864b63d64a0b793b8c3a235a864ca3b32687fb6c098d804c01d7396f64a4cb1e4f1b0e79bd208203dc21e7ca7488f24a3666f8f0130f6c563b45ca6e17b434b3561631e57c01a0ff71a38dfe1860119841874ed3113a81dd26353c7b32eb05efd563165f5108c82d8e685f0b28e6e2b5131b4c67964e7a3b6b01d6326fc65d2cdd1b31b67e1c6eec9c80ff0ef1cd222e795b5ab0292bafe3e998094ad351f7051dadf4a42cef5ec4778c4fc6208a5a300cec0334be554004c20828b3b12d0811462ff3d612954073d09aed772fd5e92671430047475d4ac23165d07019ce8a7b7d1b32caf93f5f13b80eff3c400754aee480c2db2dea94cf5ce40c9ed38eca5e7bd35f974685512b9306eecdbff4ef1281e1d8f6efe77752230169e22cc4a183c111def4b10f5d1b5e27745418590c98fc10402dd2bf9abe4a7e907c71641879ffa7da61068ff5fc436083e601d4df2111c4404f225d0f7e4b9f7d357944971cdfea81934bdb79bd78d0ac23724e856aa92e3eeca4d10eabc53c58b6fc62eefd8b3002830207d098dd4ab717455e2d0035f10d123d5f66d77e977baf721665eee2f5d989bc227ba60e52bcff3a370d67882287bd5d0325693f9bd78446a21f3162fe6d8469402dcbce6f2fd142dffaa36898d2697e877faee7803676b658e23ce4e08f7e33566bca0745412609295776ab319c63f60f02dc37070933af0e514d9b13726e18c0b9520d29378173dddbeca9cf43d2f8d2c3d5c2293aefea5161597fcd6ef475a54a1c0b1308106b3e55bd4c0073fb12c0e278f9cd10965a981282d33b1c5da955d2e24c82b1a401e2f8d7fe82041fffbfd53c204b4dc13bf807c2d8a5c675256d9715e966588fea8e2632fd48f103da29f032fc5a320013d20073419ecc7137328bcce619169db4ef94f9b04abdb832cf6044bd8ba157298bd575e1423b0c908c47585d47b35c5638028ae3334978fef2edf8adc747ecea6dc0295a7c440cc8234dd879a0127832a0dfa101d0e8e41c378239398e2cda2c7ca0874ede02cef16d61e318c0ad547e37eb8523aec2083e6b7b18d3e3a071e65c48a2045c682598a155724c7975157ec57820a2fc6d028be24eee33565feabf53b7b11f0f8d794fa2e5dbcfa5e8f5bfaa9f09afd611542afb711720a53db80b3855e9319e6167074d01a65810211e03442a5a31a35bca72a6c86f40bf18a2e1312fa5cbe947b4b543d967371d0c3f0c25ab9ce9fa86a92a5ff9d8e0bf75f75b36c81de9c491a628e35d7f92ff745212e3c289cf9b44943f6eefeba91385f3788cfd9c7b287d7f484a661c5461c44f54977d134d347d509cbf7af9a9e0192c5eb23a69928723872f57c6804804b7465e72d538387663cbb166c82549c1ff519aa9b47d188007b81364bc84ab3d37d6bdafdb07a3452846f26ed75a5ed85d2c3c3bf81b50b9d0ef60c189d3ea7afa01abbbe050ce111a447d1f6427cead8b4b1074e1d06fd04c849dc7bd84ca40d90ed2050845dbfb3705a1ce11d760248a25dae65ed33a715e1a08a1cef6bd6e42358ce67fcb4f86cfa4fca9300d210956d8426e6994fbe53ecd8e112173e349beef8fb090276eb7bb722c45b99c225e635cdb45b52ce1dbb25fe7026db20cdbf23265154c2e9cc9996acbbe5f59d3fef959fd39929bfe214b707dee606d49a2b6565f4c4a9851d31f841c33ff1e60c0e8243535c3869c43241bf9e5d3536445670d31b954fff3ac223535736221d3ab31c3057fb7e2cd727b8633bc364a11d7139300b9dc892f28667b35c65b3e6ed6b92c9de24118236a8aef407c86d82ef483a8d9a720e15a16797ca2dae349d69e936fa5c5074728af566124b18eac7a256d5ba868e84a38921e92390d3b17c0ab36dec4457302b3c15722a6711d1426c37a29d9f9a34ed75b895b08444fab224980d3ee6b9b4185611651f7ae0d3175f8096daf367f8a0b9eed9a02a61a52d4c2a7bfb6c85689e1e44817c72159713a2f1cd75888ce61e2f92c98b34bc51cbb2d0a06b23556d3eaf26bf57df2bd85b465b7d89558567d37aef52ba73c939353ccdd7e995a61ead336c755024cfb160f4e70ee7395dd3771278d59a76af81354c134d6d5ac06cf8e1c829a7f7391d8b952097fae92c95a0681f7cd3a5548ec3443175472089db720c3ffed2ffb2b0dfca43eb137508b1cd0f99d0f276ed82da96d25ea01ecce4457e454012042c123464baece544fc183eff9ef65f1c62c78df6ea7ff55aaec826d3fde2e67b32ce3775372e4fd1d175e8a8624ae588a4a7e95db5cbbc9841d8fd0674bbe5fc91e09b3b577b9eb444eca05508aa383840fa6902a25070660de5b357db03503be30daa71b5655b573a77d26e617700827a9adfbbde556f9d631f847c37e0a10f7f456a1590854e51822901beef0336441a0d95f6177b530e1e45498a89dba3a3b1a2dee889eb43cfd4d4328ad1f7ed60627434ba494c98fc23d205c535718f1f002cd266b41b726358c1d5f9fe4f785c488e170c1f982774233884e8e4e092620d2889d17ee46ca9a998f49041a6a2d1d560ea14411978edf9e6265f6107cb23387143c519848f23ec5cc6a68ec0fada97a981ce3e5f0c6521e61f3876b3bdf5bded4b2fce39c29e0281380a54ffd319eaa6672b201351fc3d7cd18b713e9d44cd4081e93b480fcf5d65f9f70b5f16fb6a91b2a701777970ab2daa8182e86c65eb6061f413f36b6734448d1f7ff1b6b7b2d153bf2d60cca32ee517d660abf7a53d9dc34d002806b88f5830a6091bbb110acce45f42762def334be6bee34b8d58a4b2ea3c97e980058deb4c96c555024e172d4b3a02dd0009927947bb7eed627e7daa0607c6f0474af63e72e5579f526f8f339f0716559ffca8bcaefd17d6365026cd00260c19406c856e418b1e7f983bab68e67195982efd6ee7aad434bcdc824692d9682b76d5fdda128b916cf1d5ea1060a8653db76f645dcd65948f3c2d3c66f0ef16402511296a214b6d7ac6b51cd38e5e692dbd64e4744eb8e91edb02f40352d6bb881bfd035c58fae46093b1be8a06abfa550b00fb0c1b6b8775f804b649a77f14532a2277f78e1f0dcd42b82669fec601f587bc669b88f7bf33ec347440d5def9c6ad6a3f63c1cc83deb253a09e077b76829226f01e4743f9980b6993e271f429ad50a46a672196932ec285b6df2a501f54a8cd8768adfe7c31cd52a65b87935dfd4cc7ced12d9915bcd05bcbd9b4c748da21674c2e17615e675f90c3bc7ec03597ceda3f1117198aa8871f377bf808b77b6cd6e71e81e305a28027736f5e9ff3a31c392904f4a1c3edbe43477fe85226aea60f63b08386e86757adc1c49edf49dc0e4753e749e698e9f37d108508cbcad61ff6bbdbac2b195bdedc2de162db213137067fbe3d3c748d1bbcd8121f65f8d51040e9c64c983bf6eaa40ebd629222b1c361eb4885fe38cb7939731a529b554c072bb267a938d6ced0f21e7923ea6194860d1f51f1bde64485925fcdc1938796c1b86ebfe26c900454d72f25d28bbc05480e2b1f0b075a95cef6fad430074bb0fbdf990151a643e571ecf3d49d2f557acdb2f80187439d7e06204e8d18c8b41bffc9ff7e9dde42020c53ddd1d37fa76e5d3fe4515c5106294ed836b6fa4c7a192afa7036ccf3f8f9bc80a77e1ef4b694f91e21dd11dc84bc0e1fdf503ff63a659f83e3f93b39d54533fd51f8e9a92a9ecad7d6be4f8c11ba77301371e016442ccd6cba7f7f2bf5408ebfd5a5cc75c70e21ed217f44e79e71c316e57b03548236b05309318f553fdd7859bc671613fc049720c1b82493ca89c8f03dd2cbdc9a03550e958c97c94a234d7c2d04832abb4a026372687a883832fff11c255b8f3ded95d6a43bed59defca368bdbf1c82b7422f0b2a515c2df201981025796b99528db3c179de41802313e0ff46e79b1771e3957fe5b3e760f32c3d26a294eb6fa7bdbdf3ed01a32114cd6b4e633b79fad0222bbd0191cc2d34c304615d34718bd5816e779d7c57c71fba71ffa14f978122532df90907166a54a47e6ea5231620ca5921ebe822dda60cfae5dab9bf9ec0493c7d5676270f862fa0bcbdc1a2260379937cd3ee2d0bc6e2d77c11b9a21d9da045ef1b9fe0e921a30c8b4f581ef519e2eb8c666e6dda07786f18f142318ae4c6e2becdf3510859c90724b6fa1e308ab453d4fdf815e77708c89c12ddf237493b72f231fe48ddcc1400bc48c51898fffcd21f186d7e416fc05f5c914483a8c64810a20ea1a75d3e03871a3f0d2e12441c815fa4a13fe559c2460884a7b391b896e21956fbb97b812e6e58f4570abd0f935c0b0168ccc5ce8260b9267940e41eb24638b7a2d91962878f5752aa603cad34498606b2404343503e88a33c2d9837172d528c231e1b2ebb00fe68dab090f33e9434d1ede7f492e10cb5494916c4c77fe20ac3a200925ba736136d3b8c193cd3806cfc74ac1362fe433e9060effec18aa04d648d35d89ff976b1a5ce85cb5683c71864e9b0e27af641f89a74f570acb257af857937ff1b57d505214d8a5a504b58aa677631491b698d2c575e6e64ab73ebbb16ee04eef1579c16e64d34d541f9ec0b4ef9517c9189daf5a62afddec409ad9e57ffc8579d643f0717d95806a3d4d69d251d88b4c5b2bd4b44b0d1d824d4d52cb652550cc8eaf47d994a12a83410e08cf3a93f8bfd616304c6fd343fe65985307269f17e45e942ec6f3f22efe5cd56bae136ee46ac6d45223076d962c8a25e54c57afb5ee432a0ba4364ea05885e63ae8c391ab029c90fe3bc1f95731cb7f10845e7321bff6ba9df4329ceaa3351d97ef9053248a7f10229bf656e4636db668aeb7dc5e830e0ba3a1f7f817ef4f4a6ed281fb99036ceabcdf7696326fe55476ba81003bbd09b999f31fb0a988f0fcb376b92a09395c80a250c15e2f7967352bfb0ef6435791cc2b7785629693d2c6ba0e1422a456ef6900f37938dbfc9abef86975fce060423b00ed2b62c30a4f9d6994d5b84b3854564943b8a104eed44578a940cbdcde11cc05099fe298f0f52fd71c7c2c21d34ed1307cd90c191674261b3961e811c13507b12a4ec618a924b30b485c812eade78d2c0c2aacddf284ee053ae8a7778673fdfa241db05864b6db0631cc1506c24390da2a9c3a7145bcb428856398eef4925f07bd5a7c488c3ad7396e4e9abfa8695231a0ada7413aa6f06c1b413e83fd6297e5d47a0128e70d88605a2bdfe4831c83f33459f635c63fd6b0cc49c60c33e6ce93f270840eb9622defe20b485b23f69d18256286a7b71ea4b14849b7c44a1c64a9a68f096b13c4f0a54bd10d5d8cef28b048292925271884af2a5b8729bc01b5fb8eb3e0a83362322c0c962c0d69850749a54effaff470f43dcb72ea42e5ca3cc292b7760cdf9c23d27af33d250996444f09179f053ed3fb93b7d6b41b9e7631f1957906565d7d4049570d3b99b02c5cf1915ade0b78d5dab62c367ae33b4c2f50d2ba70ef623cd0a55cba9c2cb2b0eff6445e364c051e9890a28e496c186e390ac064255cf47f5c1672f53530a8e92da8f9708863721bb7b5740c75605430aca2f285a63dea7338218d59414dbca19fa591ec888a9c3c1ee7223de0f4faf712d06f626cd86b7efa412e0c0d16e0ddfa4571ada0cdbd6e407b994c5c1817ef195b23ca86eda595eced566ebba07c08b855bb8aab8ea319060a1c8a39a67e31863dd12a2ca5282694f43f640b331cb9b5f3775939418df1c801412bdfe9dfb278c85b315ecfc5287e6c746603545fe51a0b0fba4aa2a6ed2039da464e65158bad36b0298b308a370c128a9e4ace35e5a28822133dbe0c4e1782f539c168b3833e1c8e9781803cbb9334c335ba4b200d3d9dd4251a59323b423e45eccbf5eec9aa0d03bde9c56767ac992c5d076adbeba5b0be873707d9b3178f23717e29297a07150e878bbed110254489a191bdbe26298b918cb0ca0872b0f7402b790ac44988f85e08cfb3f2c22dea7c5644c585833a1f2c76c9072236d0de618d6936b4f6f2b58bbe1dcd3afa030cc7e2fbb4e86033e018d0a0105adc00b29c43be50b1c0e114e81f357a534e6aa0c1a4c63db98e0b4403ecfa0764925440bbf82d8087bb6fe4b485f7a36ad95450505f2941cc1ab89d5bdb035c898523028ab9b5ec871bfa21076aa27458612697a00de5ef191c8134562caf4ba733fd8b852653b786d6dd5b0e3334489468dd9f3c79fba12cf3d392189775ea047d5ca2cea5c13754fb20cc281ba2377f75385e74b36ace43210e08b2221ceacaf3fb2ea96f192278035f705ae596ccbbe0c57ae16f0c8ca28eda0e7a3cc48eb7bf1f4d2baddc68022e25ef19d956bc88c3211b58ff24af7266566d93f995ca1f07b527432cfcf00924d332abdfab3cd976fecc0090cd9412db450be322f37f38034ce1723ba569bf292db49b867c08e262461c931a1a6bea126597aeef0d79b5e8d7546921914db19ce00477f077be46a9b1fe15a11598d94d3c96dc0c62dc52fbb4d5ebc8cf02c6cac07c19b5e2d1d185bd2bf5a9b98e27e9b4c39c5e0f452204aa9dea225aa5774cd676e1b96c66858ba0079dac93796d2b04224a9edbf7ac43f1fb801ad95826bb1467f6f0845c07c7c54986b1978e6f3995fe314aadca83a8e3803de31a1a528fdacbcc1b7ea61888ba2f5878c174e2eb6e260b72e84cfc781e8b7753b5ab95340dd150413e16c3c7bc35e788417bbccab5eb9d5bd1ca947181f95850eb08804b24e7798da7fce05b2f72d8dd3ceef2243ab4abd3a0007dc305b2e530f6405ea74455b930112d494d7264cc1905879b78cfd0ff6f109cad2a99e98ec9ad3e808175c262fc33de4d09dee378bac4780614c581a78c32f1db23e193308a4e9eb7b735b423f14a18d89f677b7757b3d9ea0bf4e752a715261708d3d7ca4123a3bed339b1710cdeaff3e6ff22708539ad652020332108120212df5472cfc761147d1772f33c8552368f0a5951e006dc458e0bf0692c93bc192bd52c6205073c9e3738a894a5b60509483f88ac023a3052d9fafa62f42896c89c47c13842db71f355e0045ab002f8954b44661bd2818ab4a4aaa763d8a8f7a642d20f9f08f18e37953e23462d7fce93a89d123075b2de3b734192eb8180d11ec65edb84cdcef640acd19c43c1e675d0ca8908158315fa1459e392f6c59360ebaf62677a34ad29af15174c5e30e40c0b737898cae1913133be8e5b61812cb9230fd3db15c814af466d950fc083863c28e2ee9a72c6d194af1b620ad49752b406b93462ba7ffa59818ac2871fbf4a299aa6fe1005aadc5ad230b091abde8f7080e35f264032648f45bd5b8c5c0e50ccc80b58975d1c34b50bdab5c4cef940f4847928ce2ff1e45dc4dbe3ec63389c9035181f766c00f56a045d114786a68cbc1abf24f0535f1ba7fbbe431e6babd2c9c13bc37d63e22758ada0d81fa4ece36bc9bba0a5571c853aa6b228b60686c543823dcefbca3c63488369ca2d6bfc05aa1596316f401cc12b98bfb1f962f70ad204db4956e919a45f6891e7c5a92ff3cedb07595197f5113cdfc837a62c7c57fdae67e295a2e1e535dbd353bbcae433b9cc5039930346e6e8dfae7ddc012824115a47a3969fb23d5e9924c05a53f00fc4341c856293c922e27c4dc7ec5999804f10df8bd2397083096fae6dfc7aae9d2d51b0e868ca62a4796f24862d43110521a195317cfecf1bcc3a50f80cb255fc72e3e681d24df524355e8d40207c3cda25b9a6c1caf3f1643bf15cb0f1272a98ec8f20ee609bdffd4dd235c68a4dc301bf0db22c6e7298c66145fa7557ca8b1be25a337da62f143fda607152ba51178cfeac870d34cc9364663fa031c5826db7e92c26cb24f11e243b5d16c5df66afa07157d8d10c4b15954e083d9df3c300b7138c64a634a79b1a6381267f09870a3542299e3062225eca2b669df12791175ec78c7e18f42dd1548dab93127dc1171358a5258eb793a75ae42908276a39b14081e6eb35fa7a167ac2595a85a2134dcebc633b2b1bdbd27024f96889e4d4903148b6231f8f7b3bf4adae535f0e6c3531320edf2ceb246e26617b8d0cfe1ab275c21ead03929f1a0332dc435348060aeec78ff48f9a952d7868e743f40bc0f3a1a1f5f57e2a7d1d6f45d2de624bfaab4198872875225e772ab5b75ed70c81b8293f7c5bcb9961106b30d7fe4eeb50da64826663707a0191dca8b7b77dad0752772780becf00c45de876ef8c4d2b145a441935428bddb9df276c28dfaec39aa2569bcf54c2eb0db31f14a1e61238dcad4a6a2358d372fdad69b530b539403d567af5eecc633a6b4635d21c59dd06e72d202c390c178c8b06be1ddaa189dc1b76e46066c403a603c700e6e4a0074732b2908850f03253be2250f50711b106bbead670878786f84765a1848f8ca3b090b8068ac9a66be5dc77df83f8594849c6818b1bfd7d86f13fb3e842ffbd47fc36609ba37b625ed470597d83e7941006c0466d56b4d38ee6ffb28e7e6c2523bab66e2709e5e016ca08e61a326070e981289090ef93113ef29a10a720175be261797ae6d47848804d36287531aaecdba3ad52fdf6a70cfcab85a2d9af762f2de874256d8da677832e28a0c35cebfd0ed59600f3a0c364fda803d5905c06902359563a7ffd4ec5480821e0fa4890a57e9e6716f40b926bd296e10af719a86b697b8315e4c3fd39e1aa84a9ed70cc3dae565cef354b400d2e996788f572a733682038b7570e249076583c8c9a5796b07233662d2c4bd364168309c6c001beafea88b91663d08037f80638c80c947468909b7d00fb7cd4ad37b0fe96373537c4807240ac7122edc30b8eed1e11bbb9cf8c5852d9ba6e8427017d87540459c940886f986e605c55e96400b48c9ac1c92ad55ac67ee4a7dca38d7ff438956ca4cd359c3577366b6952edd9faee67de3f19779710183e207912ba1e48122fb26630b2d0247b0cab6ff6dc214c8aa57ca85e879141c6660cbc0ed3e2a633e407ef75945a66368cc0bce3e804f7f083cd350ca2c34fc90cf3587cf0507636b998fc8a8931481adfe2c0f8a63330d0dcf468882d8b23df4804f1f15a938d2b92903e0f04fd0431b1cafc74c797b2dcdc23220aca4b1f6f5acc59d96d9150436433de23b6f831594f41abb1bc340c82f7835a2ecd995c209fbac0204f602c84c09b94d63d226fee04c139592ad2e4252afbb5ed6d04ee76143d096f400cd75410673a82c2689f5dec8798c510f099cc0878e17b38e685c58be01d778923d6134aef52442052e6f806f90f43f3507594f7c293b1fe1f654eb3ffdbfa496397192a428b5e7cae2038cf3158a4fd004ad9e6e3e2110d29c256f476c99c6ead7610649d08ab7e641fc4c84c79bce94b255b8d444694041c1d153721d2b2ab50959c0ba3ef0096040e848f2883ef5cab14fa32d604eef41585ff49b46718a85aad1f0f4969f9e70614edd9b2b167c91c515314f76615a12a54566690c5f16ef61fb104ed88dfb0a331526e13e076a33a2f9b95d9236b53d7b56254740cab43f6d61918d93556ad48d14cb31db3c9e96119c870673a643c36df3582356b76ef0b324f921675be41eca16c746d9beb6518621e3c26a2a9116676a57c985845db8ff6fa2f0466be8ad90e9a00d3b99b36d97c5a45a41697b713c8f0c1d7a3592f7ec216a74f5da3fbd1a6ab362be3c64a498c71a602e6fe39539c9516324f199765a974ade0436c0e48ba7a54c5dce6fadd6dc3f7b9c88a3e3e48153c39bce50d1c08ff7078a0c380f2b6094cc444783a542b533aeecd86659c34a6ee0d5aeada2bc5c55968b465fb82967b2241bd98ebcf15c0ab9b409fe49349d200691737d1696e3fea6b45e946eb308af8b024b0002da29ce7f525e35d737590b91bc781c992878568bb1af5212105cdc4c7fff818c184615164096bbd3ddf9ae2658d7d62f3b8e9d63f3fe756627c272a28a8cbe16218f2624b9fa4487958212c2b3540c6e0059790374da87dbbeadd8b53257f7b6d21be0339d7bc6c0ef0d9674056b18955b53b84519cb7df3bf89db5c489d9cfb50fe78b922d99be97ffc90a0b4b42a0066dc36292144784b5f278a567b59fd6e8d7a90063ba86cd81dc82afac9b582dd1658ed6bde077081772f014ae9bf06dde81ca8153ce8d1bfb5e1272c8b56b7e66313b8c48f827e62e947e55f6901e9cec04a7fa1520788756b926d95c485e6f60ab6941068234263a264891e09bba61de28397add9f90fe4f507fe80a3dfabadfcf4595c323b55ef6db5688f21b6031fe4d6eb7c0d7dec365b7775807321097f651249e6ba08a671fd7ab5a50598efaf6b30341379d2768743104b28e5d2bd0c72577881e98c8435a00b11e3d0cd524b3b98c9808811ff195d8bd636684787584ff82f57db53dbf5202d99d1f75da478927f21ccf58d1858e6cccf7feeea886facf4866c19cab44a5d732a083daf081fa3c9d6f70928ae40be4013e3d5326d571827112d2eb013c2ceb7428caab36ca64ee5f0c7a8cee911799b09aabab438a1a833f9cdb5bf7b321659e971f235071ced7354713a52cd2a95f742941cd1781ef096eaa989a83e1c96b330be79037d3d3fb6b977e00871b7da884211b273ede1dcc667c6daf2411d7b9b5433fdc7a5f87f28f139fa0f369cbaddf349ad6edb8e9ce35d8b1539c9062db0b0f9b21fa8b502e8dc8142fcc3135f145eb129c436a47d9a6cfdf37829fb034fe36818214b3d032c50d8705230972df27463cc19c665a4f3a096ebb1dbc4e0e1ed30e0764bdf8b33f46bfe78bb02484a737d79bc6e65a24105bc98eafacd68d7c3dd28843fc70564851158201b2d06eb9f62277a466a1c68a32b465036bdc40fc08fdbff07783dca253d1f2a3908de86d5b1fdb3bb142bc1d2d6935954abd3f31951cb2c31fbaa1b3356316b85d2a779c3b32842755248cb687eb46ce70e8c6b909e63cd373847ae6042f7d1a3e1d504224ea624f6776d913c8a27f0887fb76e97c9100a24edada45238ee93656dda00efe43fd40c14f8498510846b2cbec71dd8fcb795e63cb46c3dc3ee89e9590f802bd739a60388f2943c7f6219f9866cc9d18d9457785efa66585718535b16f8cdd4cb31a239b34d388e494fbd14e2d74c561a93176d520c1661eca72fb1b8a2b9d31d7782a9c46a55c1a5ab15e262eb222c826c0c7bb4b9bf7f1d35541a73f4de8ef8e90c9b93e846d763db80b8efd1598727efea7b6bf35a1b366a13b897228ff3b93360d80483e27e996273860c8f1aef89fcf1b9069dde556e3decd0f7cf682cabf7511e9d7a5a94617c2e4cec89473fba2e59c60346270bcc5ce961e7232c69a71762b04e9c1b0170cc83686db743c13bb588f1523e162705099e60883183fc03effa94068bd46ae5cdb9fc4561a37bfc7860c9485328472cc92714513b0df405e2db09fa50b7838f5fea0035642159fcf3c7f1fe18e11d946ef23374435f0ef313a53954afc7ae58c9f559145b75448fdb078bdf0ecf84c6b40c49888cc0ff985f1d504fe69e0c093bbfa6d087f600ff0064cfe022137d5c7aaddeb6611cbb71a17a257e4f4defc2cf19d23a56f0a2dc214a3f9c3b61b5ac93c92bd068ad196ddcff02dd044dfc4e8f1cc8317a61c72931ee555bba036bcb8bd024c69a38df01c5d2da5bc66dbedbeb2685020a66c48a357f0bc332448f9e43529966bbd4d59ef534914986cffe094a8f21d9e47be7008ae7ea4794d9494a1422ac5de9c95cc6f35ec0d97408c21e1df0a15b8238b836d5f4ceed523d3321ead46718e9ec4359be7a172fab09aa6827b88c95cea7a48e115e518a8c5dc91b5e67e28b96003c5309d4ba26c141b16c241bb20c9668bcc8d4ccc7c6b2f655c5e5ee304d273a9136a0d72c73985db25959b655170fd22cfbf43b1bbaa03a5ec68e1ece1f6fd9c71bab7890eb5eef9a175a46dfaa65ed3a3b3eb03bce0ba0faf478c0a1c828e6d727e3be289c34ee067ef7792e06b49d2734360a3365870f469e277a8ec314c50f685132a15e7879a03353a76bda6c9b3b7a63acb3a8557ababb60651b3905915fa399fba08e96f43f499f67ab796bf85ad54b8fa152ed242af1cbdd5cd1edf6b9b07e8490fe76776f5415ef6d93e178870494e72430a907fa95513d23612e6c8f78ff344b75f7d829c97828601e15e07ed15388a444af2ad97931c83c515b44acd71887e8af8f71c739668929ed1ce03fef95991ce93c41c91b6486ed0adeb3cdb34b9e3a1df61d0aeb2cbfa8960d8f4addd5f459d5ea3048bb5a6c9f0a8750501ab56a026134d121e2d33673e45c5ff2eb22b5ca59a506496216311a38525a38f48ac45739bae4d61f28cbe496a1370db53f59b92e53ac5bb8daa074445d33fe2b4f03b2e72258eee01a0141a32bfdd783ac25e3e180594fa182381d241e475733f85216820f1b9c0930de2d0c4aafad0812d0c3609c431f9093adbd5ae6eb49d13bfd086e07ebcc4d84375549297a13ae84bebb1ffaf5e199780df6189b6d0af18d7458029deab89966a81af3e0a1fb79ec4c9a2c2f9d5dd21a9a27a6b54a6683f55981f7855b8954c5f2de86744f8bfcb034a0e7ee1f2ee4ef1dc9c0ac05793c49ae5bc498d0c7bc0c683fe80485580867fcd626454976d7d179b77bd9692f067958cb2106c65668f8a416745f8d6f4ab48052ca5acc68320d83390510572e30c08acb878212dfb195afbbbe3e8c338a75165547229bed1c8a1460f27d9046248ba4971e81de1951438914448b469bf5d2d1913f27c232493917a104a37003ac0ce175c130136e55e10c2158dc038bbddadbb7468ab51e4bf9723361b08339af57af2a9d81effb32fb78d01877fdd447ff1071aefed54183d67657407a2778d099a8ab066965445c42fd992aa93ac420aaf7d45486b8aaf2026116f30ec09920e16cbd44e004cecff28b1b36b78263a11117eb3a7897148a53a995fe5a576599c15279cfb3dd200039f200414be739269881a0173e5c68f8590ae97bdc4edf9a8133e8cf2646ed983a6f09cf9a1cceec31a3bfdebd84c43f0ed6fe278b20a78402885b1a98b893f39df53ed861f8ece9394b70c5f1403ff7cb1da18f66357e025516ba8f58016c11715dab1dc310124a0ccba447bd9e84d5c39c492c4ebf39cd6df42dc91b635b5858303736146e64321c4ab14487577cbe422e1edc77120f685b3d9000e7155ac64c4bbaca451fb525fdd3d7479aa3eb464ddc56bcfb9c751affa8aa09bd516ac760b0861b91f19009f08f07c1edc3b674f24ab9efe384bd936bea2c36710f60463ff871ae6af0b56546c9417cb8190e85ba7c5fb434863a86b449cbb09a342ccc1c5eafebffd51ddebe0e527536d6e889465ae034cf94d9a951fb57c0163134290a6d365d39821a56b4e41e158260e8629846e693de6e5e9c379903dfde1a80b6a9439d5ffb7f1dbc2c9e1832affa73f56a329d6414eb671ba81ac6ed04901bfba1b74fa0afc2e6ad7416f0ab669eab34b112c7a15536e312102c01e0506720acd08564feeede61bbc3020d164b30ff0c1e7ff5a8b9d9445cd46f1b6873f2ae7c9374c50fa671f377b20292b9642a3558da70aa663954710893262ee25ba94b7ad43f53e2b16345265c9da4487bd520035c357f7f0da3a795b3e06fc98a492c3e7c6c29cb47b2e79d20f46a1b195f79f37d921c7f4fa7888821b4e15c8ebeac7399762494ef65fcad5db3b3c16f300c0b0a555a530b9808b31acc46f43deabc291cc7942763f516e9251bc7dfb80ccddb933e684b3a79115e82feee3100804363bd14a52fbf6ae87d1bcd50f26911d405ea469898707fdfca1c958b13861cbdcf14866eee06a6f89e5bdf71984321d89c5e0ffe5b106f76a8f2611c1b63f64bf4b0edb9022f45bef02367e17f59340d9115e1d95017cfa64f9207881f58dfdd8f7f3a24badb5d2000fbb42d99f1ad189ead4155c2b263e958367d73edb7ca1d9950973d183ca1dfb5e3f0fff2acc99f76bd0c911261d069cf234238e974668fcc0924f08adc5b59ed344ea5416b25101f737ee95c16edd5e63270644b5f06d7d5aee69c543aead44507e57e6e3682a3551caaa29a502725bd72926bcb0fcf8d5e126a1ce94a4bc463c170301cd1cdd7eb018123a0f46c063f203e9da4c49d35d4fb324ecdcaf7756bfed2561c0aee026bef6417afd7044f8f3cabe2e7838bd3406ec8be4378f704269e41291a5b4f2d916599c79deeb02e4b5a1acdc45f26fddefcd02dde5210e2666a8faad08dd8391cca9065d0ebc993d06f1c63a5cd99be282c5dfdb79b6a9f9ce9f9807ed58740a71347659b827385b401cc158d349ab0b4c54187dbfa3b8e8e06ce753bda2aa19756f402dfef3f5ed91959f1d19097e276491b88d5837947d7468f8e16126d454e6e4a206c0bc4e6e53a0f622be4b5cac0a5f28abadf010b74a58b21a9512a14f09294b480b8934c008d8185667961d9bcde13e355a09c7bd864c7e443865f79760b9e90f42de3fdaf0bb6f6646e7c7a167d8797da25ebb6407ab3c3ad87c4b77d80177fdf50fe1299294e9681a909db9230511160326eb1c4fa63ccec100199aef7d943489a57ce98f23df465af5d847efdd2c5facdaf2a9a8bbb821a5e07a972abcf90e97218b90092d6af573aced26e6821c7c25c7f3896aab439ae5406ce6a26ec2496e922da2d84346d632aa77ddf289f7416977a0da61acee905a2539336fa90bdb57a97e91e5830b3e78a6c6e16a5cbb5b199974523d20990dd2e887d4e69474428d969947cba5424cc7377ae7c851f66540103225f9046355d5bcdcd862502ae664ee30db4b7f3c02cfa87bb9b3eaa0caad1a5d7e63b60840352dc9d7c903bae37b873bbf4db451bb7c45a719ec3322e4ce3b015238dedbc9d47d1c584d2bfda9e85798df4b51289e121847c22735dae1ea2550a8dd5b78284fd94b4cdc9662bd05f2ad492e11192d8eda070a178a2da6e25cc72c3ba7540ac421e21ea9aca2f8088918a620f4a161206718bf8662aafc30208980af220948a7a761ca096d921d549d76516e01cdc69b1eae179d2312fd00bf7799a5a883734603c3671d2e62e73472cac97bee52e2421ef98982ddb4b76252997fa567e4dfa18b12230cd5ba3336d9682c60e0ad91c4b95885a1f5c6efdd76f351354013e9c17b2fe9cfc19ec9397b36ab5dc02e65cc2f6d75af2ff0e0d4f6050a1158b4028d27eabbfeed486b41fbc5a908e3b2fe1119b01e1a0402cae313110427068b3ae6d1c577e5ca2858e9376121e12a521d7581431e41924a3f8d4155cd2c7ecdda99d7e398abc7f015cffdd07a195916dc67b2cf570894fae8dba9fe83f94dd27ebaf1fea483da6531b5a8407dec6f13034bc2b6535e5268dbe3fc5cf15e035bc01164ad30febfddcf235b32d070aa3a3e8a63d72ba8b4578e55c220086ffc9b9ca0f3c09920e8485d3637bd445c5230f9d9d9bf65bbe8f5b29782e7b51034c868c8e2bbd5972ad1bde183da489b3dced3c32f60f6e72aaf4423861e3d60c7012f3b8aba38cbc9bc807b6879812d1ecf21900ea7be4a5fb19765db907e877f52c97a812f2b7ddbf684de8eb53f30cef4206e28dbc6ac1dbd5297946c32c8d463ccfd2f5615221b03888b2ad52dfc82907d41f93471cb8686e19ff1e2e78b1283d6bf4bae3d279ed353fc84e71367d4b5881d54fc40460e10e8e01915b8eaf971a6a01ef35d61b48ec9fc6eb0677babe0778c137c1212a3b563744e4a481b68a5c6845d98a6f8a32f62b2aa552fa35df1bec94fb97c411f62a4537e817d0ff977b2c2e0079f5cab858a832b0745d772a16f34aac54271989520d039973905bf97c1ca27b8d7569abb6d0af5b3d7225a7335069a529da65ebe561ac8d82bb635dc418d306ed07a5aff9eb8a289cd50806c5f8f778e02a474dfca860c380854c37d5f7a6fadfdb99614715a5c80babb08b10d07d93bdc1e7fe0c04141bede75fa01a103956f488fb8000158655f4ea4cd469b3908807c4295b323a0270b9384bde593a953b840619c691f2fadc7c0cf967c176519c47686312b284aab58fbf2f935388f349a2aa3debfdf87fa67add95fd781f99724b9768f67f9c7aba1928e4433472869597feded0953c03fdb11d2d0a8e034f7697f746d6291ef214e54219b2fcd2420c6ead4d7df6ab97767031403dc5fa222df5f834c78266e165b0179f50f0e92b81df232d751a69fbf6aa5a9fd18f22a286f32782522ee2a5a2c32e1ef03a1fd678e39792346c8e9ef967e1c2c9c23269822d0267680839543bba5ed7f513261b7f63014cab3889c0d8896207da48c89e8f8664a9c935308d846ab65643bd1562dd678f5f6d2378d3931c8c17c7c5809fe81c2a9b8f86a56a7596ffe67c6a5450b98cadc372ff18b54402e3d785639ea49c0b78d829ba5e1f97ffc3c3dfb24420c77dfb8a28acdc0b19543cff30c94b0dbabfca93355711a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
