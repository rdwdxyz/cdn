<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bacb053dffa81414be0a8096ff27d1ef8b4b04847574471ddda53ca6beed370c491efaab4f7914de93b7bd1dd63ac4056743618fe1c8b930f969a9d9f25c1dec9c1d91ec05b5d56c60462ecc4dbed6557a6f1f2cf5ef312da04a9f6d309edb70961ce2021739b3745f5debd44702cc3ed2c276ae1103939a845e7ea8d437ab21687b5a0bf1a2f01de365e4515a69b6b4efadeb1873ba53ddad8f2776cf4ce041896093927d1117b6a1abc9921014756920336a60a70eb5e10ecc102fc5b9f2b95fb61dd6cc5ea0fcf44d0d24aac1b8abbd2aee7abf6cf267f3ca18d2337971c612507af19779e919bd898240b146620e1094e98bdbc13c090dc413c2126e022534517d069ba1030285abddbcff02c75e0f202f1a089e8bee3f7c70dd1a27bda34d41a0dfa8ead63643ec5cc4760d8b001ba4394f263033eb0f5a877e30c9754a213699fd51b981407f3a89ec87a69feb6d5966781c0abeea1c15f79c6a0f956fec7072c1709863f0eb23c8eb438790f01ffedacc527b6347ca0a83cae90ef745de49a1767786a529d88c11633836152172edaaacfcf552f21883bd0860ef514f732acc60b545c6b4f3dc3c8bf8181798fe78070ae524ec8cac9f2551b150cdbbda4d83a4faf3894d7a42513fb797d027e441174bb8633628fee4ca91a787c355467a4a3b74d766581929eac6ebec77080f086e468bc16e06015931ed9ccf9184189509ed987764f5f20ad849ddfd46e59a92a6e4b5695818c73767de959febfc11d94a344b883fa687852b064641080e9b7ba1d4b4ca5373a00008192ca65066fc5a534158c0d848c8dda2f5ee3dc68e463f3af4ee887e7f661102253d9fb0ac5f1a1913183b760c772d94d6ec47eebcf9dd31c94fd9e9f961b621d7b376c20364b539c6cdba550dc38f693a16819459732ae33ac409f7b7a53194fe6540f31a8c8566baec8f710eac1409a3521c75bb0674e20becfbadba79b756d817e0aac4246fb42858a3333a54d414034d6af4b45c7e84f07d0906e4be39960f7efb39069c70a54f74928bc441aecd66ce8292a059d3ce0268a7a5852b438ab773e2c4cc6449cc4a79e162402931ae0da055cdc2cee501bd6ad68b0308fdc644455fa19a12454da4973cd61c4a1a2123a8fe66e3167be01471f3a9a7c48b138976318649f71afc31acdca4e98ba8b8a2037283174f93f2affeb816daf4c0d798ca9710d2867ec20fa819c1c8b7b3ad3f6488f5b049ea10b280d96b2acbe7ab0fd9c71fbc512bac185845dd0923fb6adb5afe8bbcf43f26c1c5a552c49c944730f9e576a74f0a454e7c37436fca1e9a58a344b8434fd286df0f20b623a3202d6343ac84fcb34e6a05637abc609c39685dc4bb9ec9e64e040d2c233a335a1d475b25c4510eac3700bea8ed176f17f2df783e0d4ccb034f774195665d57a9e3861fbc97b2849a3b81f82fcfbb923a1b2eb117e6b21bd30bc326d293d6e529cb1aa5edd34a913b5f3215fc2d628c98344b39e26fdfc2f6b30b7388da79589742c2298fc6082e7e773ef756ae84ec2d25997c7ceddf62407449f20f25b9fb5e9d73ea306f665da955db3483e0cd85bac0bf347cadcefe9fbb2c634dfb27b4e8a8a9fdc0820484f98f40afebc0fdeb0529c4b373fbe16897768745347bc50eb1cd343d0c76ed637b51accc519b11f688f6fb04679dcf4a575273fa1fee0c08ae35217c5466a66bfdfe501bd45a3974b89a25791068742ed82603a1f4d0c1a800692e61d489c6d08fff8c71a6d52fd2f1c4c2d609f5fc6a61ee3c528bdf62f3c6a445f600e52ad45d01bf86f6ca9c4fe60a4dd964acadc0594dfd93a452a8f042b4dfa086a1c6b2dce027b11664080b94d276e037151ef571e4e70fd6eaabe20bd07758b3ebfd30f8abe3ede36a0c354b0681e12e8f3fc01cd41b75e7aa0b1f437e013213c53bfad56612c8a63b3d291d33492f9f45da06a9842e4a33b09e9c101e2991feac4cfbbf42ac7b3cf3385177399327fe5926e8585865b128df334b6aae6fe2620e370dfe17d22e1f2ddac057daf3c11c24d7bcaa588669532523555a155b302c54df2eb33aea80de2d08ed553517af307660848c98b5190a55421fd8a716c7825304c16d668c60a2d6b575a2bf987354c743f066f51f4ff70724bd4ab5cc74fee446427e34bfbcba7476b3510d384a9e94509dc4370485f0b695b48318c245561202d2a5bf189534c74fa4e591012dcbe5ff3a82d450e623696b31420ff256e9d9529b38d03cfc124287907f012e325e2021f2951c502a87f2efffdfc0e3e7321a81b53fd5fdede0c554e489b00618fda930ec19fc4c65ba53912868aeff1524071c9c2726ae9975d06e0f09e21c67e32df873ec2685e3824ef968f7ae3d0748226ddcf7ee4f8fd124264f8a754920d8bef8a55ddc5dcffe55df1cfca50c6b08201d1b9250e19f50a4ee3f0da1e30fcd7f8b9e1133c1ca81e1a76c5e08ac0321e01941f7d8b90e3e4aa86c1bd0279f2f456b214a512da80fd0f14a293c68e1b1fdd95ad6cea8c63c8ddf9c3bbe6964951182cfd0fbc4a4a233c87b3288b92a494e1bf1ab53496c34935d966b9adbc1fbe1da3e3909b311bc8c9530e8eb109b4815e015481e0b86ca7b3850791ae5065965c5317be9d41867cce4697bdb820b8b6a7c563aa793ca072de49fca36673c710e98fd06c6635725e5fb94c9795b79d69b66ad4dacf0138c8cb53200d18a7a99826a6d4a8eb236230cba7aa2836e99af68f05e58360b3cd0374b32fb32cf9a7b3881986b325052db55635e4bf026f012bd2f5017999a708d76e04c573ad836238225481ec2b1f5b8301b35f219a3d8a61aefadf8a5434e7cd30ef6dfd3c7842e5c0079495b5a4f135f7a567ba629b027713bbaf6f6e4d1455f8380ca309b133c8a8f14834b88d071688c546ac86789f818f89d1261fcd0b35adf1b759f0bffea90cf04ceaaa77153b1bc7020470cb31054aec480ce09fe54f4a4881be78c7e1a9faf2a73d7e2c23cc3b4ee58b02257b642825d3dc4f77f7d020dbdb6bbdc877dccb3642c32cbba80e0a7d1866f31024f2ba11f2d57eeed169bbe213467cd07562c3e882dc4aa1dd98789bcf21e4001fdd949a590ecbb992c20034e91ed806488e8311cea52d7140f28ede440f860d99d8f4807aa6b40a20cf49aec2b3dfe9ab4f9dbbeaceaba2771368bd9f5d171ebbba06f43da04dd259c616bc83094ddfb1474737bca4fde298800d9e0be81a4d8bb769df1737f4db898446ee85614aa15598dd3d20b22e49a7da380208343b7c4f0a64599611f5917baf8567b6e9b5ec375669c0e3761866b1886483122a96e5ef4965639ac4ce25be867421474db65cc4efb51d7d03902fea2c805df563f1b3decd4abed5e24f6ff83be1aeea1b4ed4352c3a7302d8a330343428e58186c128cccd5958ff85abcce6f71e6943a6197faf899f2f001bf3638828199f284b9c34c3e09ad60598e23304b26b13c9f224ee68d4edaf29e8f552424fcd4ea2dce8c3ad64e46ac7cb383bfc2d4ba772da91e769694f57e3fbbf1f6a26a495ed5f9c9d44f13d95f2b84d14ed860f17d0601644d348a442d158aae0cc32f68e625fc21b535dad948c0bd713f7692a4701d02ea5d55f8abd2d5126b5ed65027c0b7c67cd20177745b0d7af7f62e09fd9e41ffacd7434ca1067af81be6ef1eff47775a49291ec6c7847e4523e8cd83e19c5fa4ad91e4c4026c9f95acc086e0640f1bcfd4a46a3c2fe29c9448f4f4484f816cfe831c98fd7264be770ed350769bf69fecae14ad636124499a2cf4ef1584c0e172a732141c71449de625a44ff5945fc477dbee7009d18054ddd1c5807a27800b01ffd3e794492e0a22bda4d235a48fabc21a3d0f80a9c02a0afa9e675ef288d3e7385bcba2f99ff05a706d30a82aee6ae1bf58b605b50fd92693ecee1b68b46d97ca013e25fae5da59d5f2dfdf916b693b31562587f38587eef0def9701dfdd8e470ce74c31786f40def6deec3ac7e51c5e3bd429b0991b35dee4f9673fcc5cf53f41e65066d46994b977e1cafb33d247eaf562fcc8c9a65d43bb4cc5d9b1f8527baa960abaa4dd86879aa42e775af103d437fe08dfe403a7e73e337ad7223d029338c2903faad10d5b40a4569e07c0951455f1080af6adea9ed996845f255f2fa454cab7b0df8f37ebd5f0aaf5d63e39bde8a5cd1d507a8488057eaba02a12665367b9d3817d9d2e9e3cbd8523a0c41b705151d6ddd22b3b1fb58020b5fc3a12fd73c1383d4d2046bf89e8086a78330ad93bddaea21fd3b5dec87f2003092818d877607adb0d86aca5e2828dc0d2e7c8fb3a12dc4410a987c7849d5bd00df336fa7391cb175406ca6eb0a5240d1f795cbe596d15b88353816e7f3d728e7c1c3e3c08fd5bf75fe8fe7f78e07fb70c9a60f5dcd4bf3587c06bf118cb35c1ce5e8d8d0840ffb7388be086cdadb0f4a36d8ec8bdd5beb9d60cb139f7bca8bc4605e944975347b187fe0c780d65e0bb5ab8b05a1873dcfede8cf00739f515d35093e46f415b377c8b81d9289c0b2b98563e65b261b026332b543456e3192322bc18b4cdf54bfaca4693accc8e290a231d63fff445e59d1a34e820568f7a40614a7931597ab55308dab441bd721b4b0fce289373126aa45084e8c84abbca8fb0eab7e521868979c3d76f102637f6083a5a2d5f352e738d08c267979f5b59a9f049317ac81e16a790c8fc8c4ff561497df0b451ddc4d8a595f4bc1910ab93b7283cb66b2b2c5bc869bf32085ed404cf4890d4e424299edb3fee23a13cb9e33709c5c9ffb63d6d5d73a474bad2266b9f6148dd7a858f9ff38a2237d3a058396cc2187b5f452db302c44df60ff3ed0c1c6b7a73712a53dd71f71607a1802c6b4df29e6b149a05deafa3cd4446ca8d6c2652b90950e4d7efb35a564f6e636f0c5b62aa63858158418641cf1eb3578bc6c90818f8265e13d98e8c38dc7d78340edff3d37d7c0d99dde299c515de828c6bf9cb0d5a618b749986c1c7f95d40c9f3006cd6698b9af72fc56bfc18f079f4a71aa91bac32d216d4e213ffe35472eb53e43a6d18edbe92ca3055417e747f312b13d7b3016f8f09121a2715bcfccd69ac2cbf5873aa0a1c6cd4204ef83b3bdb5223c7faa449ee70805a78ade0ab2ba731f349b94022394bd5b4286ae6adda81c798944593413024f3ea3205578e272611dc4368eae659e2ded4a522f021a74b1ef3baa19414055230f55318dcd4091101c5a456e7e9835b80773c3a2769d19add817bde9e5c0fcab9cd638ef0e00daaabe968da6dd9f0a4fbc92b04bcc47890e0fc01c44b78d362019310562fcdd2699b8a10a5037513fe776adad34605e8574ee7e760f25766ef9a106fa8ba83f13046a9dc9bf01deefa54be51487e99a8a77e1791efa3dbcc134099a6452563495a9af00b20955acc42703a16333236d8e525435afa8578e93d8292dd1ec67e4596eb21e07d7cf05e25625207a303f05300e0306e9ba7275577a0ae2ef3cb5bf221e32987a4e935ebcb5da7da8e02324f2ef19c7a6c6ed9ed9a58d21f6b5f565a1b44f42cff37a8df622da51f6e7f48efd5eac499b19360848f2c75460598d543f47de51a979425c93987eef2c8241bf573522348058505deb19c6bb006b11a9cbf2676fb0a95e13b65e31311f86a9765096d4815b3f95772e7792deae6fe1a0dbfaf31a06935d67227e5a446307f4deb483624a0fdd3be66775c2b092afeebc793de61ff2a763aa9aad45a789cb4a328e2ee4fba1fda90db4c69c45c59cbf918963bf6369c6ac698ac064158bc4e300899973cd3d7fb4584aff3407858f84faa17893e0d6d63b9768411d4184ce2301b19ac0e84239aa52301d8ecc9be0a51bacf7a881b782a37edc810fb563fe347564baa5bbdd66cc012e6966c056998152854a391e008bb777abdfab4657756f7bb52e0dd7ca8525fb6b663f7ba9e417970607dce991544e63f3ffb787d6a45345e05830dfb0174091cb6b20797119f0f962192a036b0db979642038a4307f681d243d7539b1df545d98f76c9a9b3acc91376a3b285d71b904594be2b86097ba4c14f79286eee746f62012af5261da4c2d7f5329a5b5f5cdae307ed010247087589f5ad930a2c00f9e61f0fbdde3688dcf5312369f683cff7252da42c0577c365fb853e92a4f30e636266efb6a50ba51fe3ef476c558a44c32680357c887da64f6782e83c21b2e33f6ef17e0e842c96611821f721c645ef3bbe444ea05ff6dfd4d5a44c8d9004799fd2b982c6ff24bd932d1ed8465884c7cd1b0a2189ef48e118713823abc783e565c9e0ccf6e8f787f5c36c0e9c45baf67f0fc12d8f4152b8147376b7fd38fa0428ec3f5a3fa784222ee30e5063e07c1f69672ffe9e3a57d9face79ffd0f084f7009cdb1f6252059591bb18b0e5b8c56028aa3c97fc39badbc76b448bb07ed28ad66e8d7aa856cafd4e687e2b6e48da13a4bcd2e8b096247251c5063f20259a1ba909a4bcaae814c1a934b5d2fa83f2c02554cb3ebf703672a178e788d7f448a99b2cb04e473bb2511eb567ece638182e0f49645da332992601f2cd53c3b95485d50a754f5bca7e17202ea8307a3e935c047c7011c0599881f34342178cf725693b4981b22d2df88106d071f2fee1c488e5288d1391e9758086e75ad2e914d21a9cd3549d1994cb882eeb4e698846d4a64abf33ec699c58bdb64af7e683fd53decba1eb36b20f254789272bbd9f0d7ef257670e8d95939673f1bceeb2657a662043bedf9409f7303c3a0e046e721b3f1e4190d390b6fa6bebad2fcded5de5c1892661a90e33a1a58f9dfa8f1cabf6e9a768ce32e796dba23c67fc61748d48562b6c8d1cc16df7c2080a2646179f19a0917170114de883d3b12bbd03f5087137296386d3a341911cfa22ee184f93c66b9e52c626a47ed8b958d47df5358172ee6ab04ce2e1c85971907e5bafb9473d9e2e3f0bee96f33d65e88904473bc054e222d3ca3d57b9654a2fcbc98f698bd3778198f4624b88786a5b6abd7a5a66858124b050d0ff33f505a937ab786692365fedc8ec525cf8ef1c2d956dde7778b8a2325e64b00a9c2238931ff805ff55219b93475d21988f0382e2866a055b5e80ae54d5977281538d24cc7cd0bda94594821d6c277e56d614665d3f96469f579e68a010b9707eb0b242541470ea9afcf4b873691346e2000d5366f511979823a1fe838fa4b5cd40210284c3b53ebdb21a8791712d8e5af961bb5d3d7f1b18d9c85520e93b53745bd3379d8c8ba9758a00408a235cd1ea231b0b769acda28c2e5b24b869a7a4e0bfb3349e4ce252b9c5755857062cf97217ff79beffbe49f5ec63cdc834334032c69e16bfce7b0b9baa69e964a5f399ddf352e7a14d06e964a2da38739b71ff09da3752487839024fc73764566da3a9ce14a2661da7b488150f642bf5b571ea5c1b7c42fded09c16c0ea994a4a9928ca98b2c290b3fab9dfc6c6b879b9abc1f4019c36e2c56cce5a127bb08a99b5a527fd6021a3676876b97367b3a6cb6f05f9e9e5b13c3f2f7275fb2b769b0383dbc3519acde694f0bda5c0955e087163f577bf9b83ae735e6652821f5168e3932628013ce974e702cdda5ec231c3d3367ed09d3934c3e74e5eafa76c3fc8246b6e3ee1a78767d4c7a074abbf32b97b649e51c1cf907740288a9a535098827983da402e8d63fc5449b0424232170f858284f03191d627a7b1c5a15f988c83edde7281baffc8035b30e0d615a3acbae9d96569085ca27c3040a4c3107a8a81ec84921543dd9ee33b3a53f407eead4d5518d67648d29648bb224e37925de984344fa26eedae075519028fe3e5b75ce0c82569b97ac948e3b25bb82e30b9e8a68d73b14228487549f9c82851bead31fca7e39e6ffd349984a314da635717726e59cdb377a563e0b6edd1d5d440c18df6e380f6d5d7733150e75a5b3ecdfdb8c230dfb059c04ddc63c3f9c8691fa1490cebc696630a4ce4d7b0999583ad678a0f3a8056d8c9b309a79ee446e16e56bff560cbdaa84270b9c7eba520e800711a0076a53642b0848816397ffa47d6d89bbc5f7ecc3d8ac8da3c5c68fcb9dab1048136d2b749a67712f97530a3d814b9c85438ba591071481c3fa3f558dc1065d42bc0c5a5540f34343321cba36f68874aba8447999d899519292734c2225fc61acd86e65e7d08d16e899e9f1f0218a389aaf8a8d4512ff30822bb26694932919bce9f16d8c4c8e8d3566dec344b6149fdae022d339b9c586abc446cc9fbd87589823a06e66c57a68bdf910373e5959ee24a4b52a423589fe198e5e6d882c1dc86257aab094a87568213837d02676514304698f4d5ca672759da732f5b31c40a1fccbe169ba0a6bffb9aa57a8fa16382e5217781409fb4057de21826f0d817c480d55c7eabb200d699be031562062cd54ed6e293eabaf651c99d25dcc4a27fec6fd2130caf1832bfe6a65652fe3b151b19ebab4949daf4bee4171347dea29e9c02c84c76cbebb2c414c9895ceda06e8536848cfff0131332eb12cf1e375375de44f8a2a1bbc309dbd0cd943e61064e1c0b6b030a23f9bdca9979d13d51769113d754755559f56c30d5e3f63f767204ae91c43b4e872cd083bc7da127d42f087d2bc3bb3c8d82c54504d9c337140cee45a4d4c299991aa0fc585116c14720db9f34bc4f9098b31bf0b6f5fd0c0b8501cc0a1f0545bb80b672e5b0b75c1bc2d339c267383908e2523fe13ea79349b8bf4df3134ce1b53c74d2f3df8e68198178cc005fbb146560685e334305d6d9fa2ee7683d6fa2232cafaf6c47d8da00308a280e243de35485b8c621ff9f0bab08408a29f8dd4f6f5a133bc7b4efc8cd2b2b56bf30351006bc4620b7431bf67322409c0bf6197763ee9cd05f4afb8913b2a194aac5e565f6da1145d915559032beeed6c9646e2b79186d289db5f5d65bb0c2765ea1e25716c3894c21f363113c4f3eae3975b437f7e763ff9135b160c3d3bd358ee7fde995f9dbe57ef6b7afb72b64f99f5c4b5f19a1165f8f7e95601aca462e4e412d7f2603f14a1388b9410a201235044cc852f92a7934d151180d3a86a2e346514c067bda815d6271373447c0d3dcf7b9db158ae15af50c7790a30ed2ad0011f3f5421ddc787a7f15f823f0477d29e919d11f0217a3b18056e836bb413638a345a43722ea1706d5f846b679024bb886dd07e70adf119f669b536cc5cc5feec59f43cbdf36b8b131f7cfa383606d3bf5a1035774eddf58608c678201b59c78bf091065963afcac77567190195a464a89ddf2675fb7a98a815443021278f64265567b02602c1806e4de5f901383179deddcec1a16b4d0714f3423ae34d05186042cec5521515460b8a71164c4025f0a2e6895e0bdf838bb2c3aa2400465de8403fadbde02c10b7ac2d36193d4e05e497019701b4366662185aad7cfdaa14b16687f2f3806e80875e62d9a93fafbc899bb0623ec68d506ec24fc42f7c586810195d2c12ee09cc5cecad290ad5ccd91f02d2ee37cdd1ce18cd486f8f0bbaac39bf4346324656ebaa44b846a29da1ce789ce0accfa17cf29dfa8c2a0978d6df11d66c52d6f2f418796129d6e7ad2629e856c9670dc5005a1d444182e11c420efea79375a63f9c654802677987e05cc220dfb932f4ddecf4b82ef89d7c4db5f9d1b2aa5dc337991c6213b71b4960c62d1f7385c7782399bf4c6d33f518b97ac00a24c3f242934efa648a460f97cc2a90410217d5eccc1db69d5738353279b3a1797ab9efb5f5a2395383cd6c8d68227acd722f7f783e698c20117a3ad57deea913abc7683d791010ad9cbe749caec704e54a606648aa39860f3ce72b2e8c6da6508ef5d0b314157786f355f2424a124f1cf763aac1891a372e6072b293677ef8264fa771056925aae4424c09717c207c3b14baaa2c58b5bb609c7f4762ca20e34b81a5b4d91686ef1d100b6c2ba7314a530ff5a3a83bfb7bd35f9de728998e089cfca498f156560fe70bd3116f14bcf0333c83c0fdf2e51508cb81ab1946e35467c02294945012eaa4de7ad04042e217eb16c3bfdae994349a13879fe5248e8ef88b06d35ac0c671173415adeb7734aeed16df645c881900c5a80e061b2246003f8f895c2de7aeb3eeae3627d9c747eab10bb05b7b2acf0b2691a91fc33aa6151ab7f7a418a7d847b367979c500a984d973402f276f40cf1fbd5760889e8679432cc0fcd6eb07bd817e4f50fda2e0d3d1151be440b4e7c5aa70dc4ef59dc5190b4f020d6248a4462f21f6a72b8d1d2c2332ba3250c783fd3f42a0f154650ab41f1bebe6203561d0299691cd5a74e3ee5c1706d0c6d64c805daba1bfd3823ee276f44fcb1eaa17d46ca0402251cc23432ea49ffcc4f74be0299eb175ea25bfcd47ccbaeee6fdd0969d60153de9af324cf8d71b5cde5056c5993de1525c3496ae2f83c5c9d863b0c81fd4915ea92b3c1de90a5923cc0b2bdf64792c3099ca5d58fe4279cf0b92bc6ebfa68aad1a03231b0d04057a9d054de3df2d204f569436933502436cd87c7260b9bb323aa537c64b63c38bc9fe20156298ad66eb1819b833c0b4cc62baefaec91120f663596682da4a9c43515677d9b45cdec6158686442d7455e9d3eab7655af8597513bd94424f3f01aaf5400b6d3d52e9c8689f64ac2146505c524925e2e9649b791b98ea89d3cbea9e84579e072681ec32e5d3941f8d15ce771714b5ca4a1506ed8d183ebe3d3959f4c0e2c7d98b3cf044996b22d26bbbc7d87b2ab8283d894b53f4847c53c87a89ac4d4452babe36adde450aa40f9a979a3870812be9c411343766ad1abaf3bca4026b324eff9d58d0acb954e0194af2a8296a24b04abd9692c70da47e8117dc8d5450ef02d1da20c480993e3052dd244ef9c0acba25dae412de22ccd5b455eaf536eae1acbf110498a8ea6b178ea9e6c4932de825200f07b81e4203eedd3e28c2f537a07a54b645cc16fcad90e551a5ffba9359ab3c2c13cce201216e218bd7759813643b1012144cd11e882d83b51246b2dd5effb9e07aa9874995a1745961de7c7c6312a2d18a843d389ff3e1af965e87b1d67766b16a8dd4390724184e6450ead35d830a3c052686757a7571dfa8f4102bde2b0d8248f9abef87c81e184c295ba479b23d1e7e5968fe223ab5af376500ff6bde4f383c5c0b77300e97c118223e2cff436555cbc7f01ac6d9a6a573c838a697d04be5b6476e91a6abb5defe20c1f85361d79f239db5ed17ef4bcd9352c32affe160dc2c838d3f173ced167b5a6da60f20ad8ef2497533d17be2c2b7a7524e46910826a448e5a04a2c8c17920ca9513dcf7a2a3c6c871c78644ef5767be071d1079703bb18969203839377bc184d20fbb2eb77ec5fe44f66e9d6f1c41811146b018d616e2b6277d01ddd8200156d002b0235a19da7377b799a257ff01a8b11df61981bdc06f18c96065ccd5ad6bb66640b6806748ad386df44dfda776a9aa1f9bad110ca77cbdb7c0457f92dee8b389f550901a9117ff5a25e71dfdf6a572d89526f3313d3bffa29b6d92c3f4c4d14ef4deab8cfb7a36cd6a2b7782e3154bb2eb85329ca70900044602831d0ec6e4923b4027a0eb756518d0a2eb8922bb8610c1ba383a6ed4bb08c6f6cda04cda96263bc1a7beead4042f7673c2c8840ccdaf947cd8a9153558ba750c3850c7f6cf4fce42e698b3127d47478ba755b495652f9d6d639ad9da890a1e029178e8691844efa95fd78bff697282a100ada978b976bbda9b739316f11b0ba988f529bcd204676ad362199297afa6382e4ff751498d33886fca7c1dbf7d6773e6bfc964cf48f6cfda3a2de7d9535e11350393fabb0204ac5350e90e7eeaf2d1174e1e2c4a043c861ece75c073624b3f07d5b9df9e549f943b8da9e87673e767c251cb1ca612350cf734804a097c2d10e4a44228d13111acc1d5a8b085ad29413605caaa18a8bcab7761f1f4b654a88517c35804bf2db095bd7b84719a475e56aa5d1254b076b9d3e29929e4f6c75609406bd9772ffd346ac040c5b4e98dc5e21d60a25be1b009e54948a783e155b5c2ce73df7aaae21f8e013aad97e989344eea3af869cec5189a39e26c1f7a4783b9969e4fbbb9a093d9109300db50255e0455bc5c8e4f0b2f688ed879fb34d9222da3b0f88bb33f6d3df281caeb766dffd09fd0430e6bebd1f637a2a2f22ccc641b76454304b9bdefb372b71e944e027e493ad86576154d22055d3bd57bd7c78321003de6cbc84cb6df7bd47d5e2a115142e48eeb8d9745fbee70274921b9202619b2bfed9c185c856978e376f78a9c1ecc38ceb587dc1ddb191bb7c0642ecd3ec3f458472aa7a7053ae46d0615ad9ebaf693342b6091545dc1ef46109ac6cb6d8f670e24e7ee4e3821bf30ff2c2ed68e142445628a43d2792268499995672b983ae7dd7e68c36161ebc03d2362b0c479f2b1107ace1aa2f7015d34733f987e0fbac82622d0353c7ab1431634eda4e62a7b3cad8468ae6a415d63f5283548f4c73d279d1a5649d2d94d2d31cb73192293d5389a9539b717f6db272e1004c88b3e6837a3707c08e74a3a6fe6ae997a5ba2bbccb885d1db2ad47e9af201ae962a9c5ea7cd553206084f890ae72ee995b822c8350c15f934dcc2e7f7b0fe2b243720cefc622c9a62d310a77aca865f7fabc1ce57595d725144ab50df829b711cdeb98d7bd8ee77042fc137859c02469deebbd5b6d5c53e4b65b8d54eed9371c1a357506e9fa18a7b897a913db7703792cda0e4dbd40c16604fe3a8debbfe50ab40185c1929a96a38fc6306219eae90cb3de70098da78c7c8302db1d8e1c5ed9ff9bd9182e1ae82c6ebd04d488b69625ffb075ed9a136d86175cd593ef40417bb32c2b929eafee7dda0baf134cb0d0dff80dbbcf828f16daf4298b907dfc1319c4beccb4d7f1a6ff8ec002c29eb5d3d5bb5532b4c946b9a609458eda4ae278ab1a8b25d5c8d12bc82b01597010f3c88854967aaf8718c72a88cc84853e8cb7b2972d748ba6642616a1b108c710208a54a5b5545988c48189ebc9188f29bbbbb55af4e9126607e8cdbfdc36220d4debff4939b1c8e24d873dcfa5914f86990ca6fb4f5a99f2dc15195f3a8885a4c642697f403b6a9aa0d009c24f5f03a65b8c328ba7e28d7001ba0f57dea25593647325b149d75cbe23fbcbb7e14dca6f4e105b7fb28732baf85166474fcadabae177b517a7501cf28f70910b18ab4f51fb74680d60242f2fadc3fb0e94739b4070ed141455a2b763877da2a0dc2817c6556697fe440478fa975e375e9f9914f5aee6f366fda2934f96eb45dc1c81af89722b4665a353f0a6435c26f7a29bff99a8681df48edd4dbd224c0cb4b064e4517d12febec99a80c87defe1c0bb4e3871b31fa682e31b628f709504853de1940bd5fba03d645439e8b082b6a7ef754755000e7a818ef3163a12345222c00d0c9418b73d9de3984306c3e581b5a81e88474d04ecd6982f841169b9f4197080583fa89500aeccbe98075eb9609e180bf7b49b80e94584ae9923b69c49648e83a391c151e57d0a3e527e1e9ad299eee15f375cc790ab7bbedf304155fe44e41047261ceefbaa413ca3a431673bfee55bf949691e9571632988aae9fb2dc4c29b27b1ca7c0555f9631efecd729c69034cb3517d739242ab7d1a2586409f3c93a7c294cac94e943bc358d5ba59002f7eb802535f266915e0ae301b905c52e130a404221aad10c82a748064094e046386071016eb6413fdf6b612f5aba6285afb39aad83a6366ae707578b733105dcc2f1570923b9d8cb69227b89aa2cb5068b7b5fe7f8d39968f236c1c2e3d15ada41f8f2507339913bdab4be8d986e39519dd4afac2a78f01c27ea01f033017ffa75f38e51bee5ea576b674b82d31216aaa2415073145466b89cb31454c750dc21afbaf97300f93ce171ba413aa2ae28315a6be7b06f06662aba66d5ca6487450a6080758a4c33588c928ac8fd977e16fa1193054f8c3138788f0b12a3c9c3e2148928b3a47557f36f5c2564f1a93d3bff03aedabe382a0f9232849f7060eca2bb671f65dcf597ae79e0c20e7a6bdd8eb2b27c3421fbd0d46edddcd4d034ced8b92b726a410bf47a00ea3ed49eb0a480fe187b7e58c41ffb21f2a6643dfc9b76cf0dcb5db062e61535b10269f5be5da285b6f287b1a9865264539d945976e61f9c1a0f560a16368191df0e185b93475e9b419bb4983ab71ad04764ea426d5189de105f2eba8b4000ba2797bff95e1cc5fec260c828fa7e775dc4133d0df95ec4826f86c4ef4c3b3ad88d1cc5364c9fc5b6101f5f97f8e7ca8651b10ccebdbdc1482720254728c2a82d81c19e06184488a00b407729634db6e98a72a3beb129315f94cb288238de243098806327461a7802cb3b5ad5631b7b6aad111812964eae4eed6251515d0bdeaeaeca665b8ef04d70c726de5780d20013e14db21bf70ab72434bb3d935dcaf9f2a31917d868955bd26e8d7d1c301eb41b8f990ca7e350b320a5a462db3b803b23ce0f4b3de4965d93e9f1a3d9f449d725b7f5e7256beff8f10e567a094f21039e51759ad6b82888afafb99cefc25849feec6e4516a7f160ca728bb5f785410dcdc6b32f2840420b3bf7bc3553c269e74cb31b29832da9e3cc3968971b699df80590c6de8e823cf9def2c02eecf11675797428bdf2b1f0947898f8ad6bc1cf7ba63812a50455f847feb0e980b97a349daf3b636b4c807a007e242189b2d6d73324c17e287e8f80cca5f44791d74d3b7a8ee8d03dcbc5e4fe2366447d975713b8cf88e7b78d13735496d7443e0e21e810c3e22b20eb0013537e338a251c57d1094ae019298428675e6370d4c5c2d323508e1c6a9cff6617ac95f2e29ca0c2c7283ba040c7c66a7634c99859a1f00ebb557ef3617401be3c8bc96815b4a5cee12affaef985d04dd3fcf5e1ef1f2b8d5b8d85f0ee932f4b6f65a6bc989062755476f7c856fb8160e3ad1e48a9a0cc56e5b4e23c34226f32239e39a4f58600038387125895d80eb16c5fbabcae0468d32d3d8900a55f7737049e70291f25244072464e7e75c622f218c57d060e004d560a7f6f135e88d018fe21a657cce7f85c854c61a64c601187536f959d38bb247347410c6a2c70894c68aff6d2b27308aca3ac788550b401b6231a08d090bb4bd232c739f6e943427d2488a3de3fd2087b0e6326930e2a087c7f47a7b69d72ee5981f14cd4d9d789acb72a27a47900066005e4e7f7b801d4804049e9f06f48d86738e652bc339a344ef8e71063e34971778d6fbde2c52c75d0e4b1157b89e882887959afb01d70014624003457f134411a04f0dbbfabe89ebc18bea8ad14cb36c51707abbd80c2cc78cfa8ee99bfa3fb9733d859ce6f74725d33ee61d2b46ec9dde27c0f3502633d7116d8e61a70aa8e8eb5d52904ae7660c290fc6fd31c35f9196238955111f99fff06bf4092c46944346d5506bfe7694a5cf6d13fe1332a703525349ea2304163e10538fcb42167049d8d1f479de37135642ac050091ade3891a3629937432698bf689791575dc2ea189022834374b0dcf3271183c5c7d44b311ac82ba14d9d845632775085faed8f4f6ebb71e3995d11dbe2913bd711fea44a53f80a78eba580029f0d3bf32f50c943940799ad7dce6f475bb57c7d36cc8b932d555762a34a66ba8d51fa4da8a35fcfa508e4c1ef52b6a801c89f23fdd8e676daa077a4b1ed3792d516dc1571bcc72e4d0df591ba36fbda844b07a62ce8dca079e8e2f23a5c12c7002a5171fbd5d735fbee48bb8b71cf43bbfce0027b7b1371dd10d3c62144c81fe1cc01fbfbb27e2e561cdaf810820b0f83733663466f03613c5176d1996d91c06f4a42f1bc161d8df197eee475d6feeacb230bb4b9bd7097f34c164d3a8d681f5bb56103730634ea1e67e576ab27806f4f0b87a8018e26e6f6fbc396ea70fe141e52e96537b266ddfec2ff3b2644562405a40fa1bd63d4b5a3f157596aecd3d776454d21daefdc35990dd504520f3485ccbad1746918a380c12f52254b68624dabd39bbb92cd64a1722e9910bea505ff8a443ad7c2fb13d68918a28f8971675f09726fd554e0c545627d62467bd0b9229978a08071782cd61b5c2252f7c29d193c11622823e24686c0f9375408e7a9b820b5a9a16629c791bd6d046b19cb1b13c1d57327be7874cd5755d7982e4ad5976a533a2378110ee3bfff357c33f08cfe2888e89457306389333ee6923de07a4c93bfa2ba703c31237f1142eac82530f93f65e7f827d8e3a694480b31755cfbd407e3f0186fdf4b7b549b6efe0caa2681193f49eaf16c4c91f5fc07b462d9bb620c79a43869e7bc569c7bbe7b349bf799516d56fbd953e7e2c8c17b7cbe068d114d4fa2536ba89f91234966e24410a26a56bea587205f9370ef26034944c2c69406a35a60237f593788454bf11ae6a16ea1b3918c721b21a40131776c1f81cb71060a81262207c71c6eac69949d24ae59ab48b41f0c1a4b79062eddf1d4bd2e6a2d89f1c6134a8e3027202e216b9c5a2585a99cb868c2ad1c055e19021debd716abb38c8f72547a650a6b7e968242f5f1acc736ec6437dc1fe69f05be5d008ce2f32db4b00fb4cb5b465034a0d431473d0325cff4b3a69189572fdbae72d1a7c7e356118bf24fe81bb361719313f43583cbf65284dad20a196dc73243cf5e2ef4ac1fd29bbfbd9ead92f0ad3e48f71d55a288f4826db25fab6a5ec25b91a5b3c0b41a4debb4a00047905bd498c675f7f18cc576d28ee2db21a78aa4f73f3fc34b3414466f26edc5989b9859489cb69975773b9c28922b6646b5feecc88869ffc0fc238c8452cea60aefad113ebaf1ad91a59d85e9f2affcb6519b2c7100993aea195754aaf41e53b143de901043e8915ddce525a5196979c16ceb56909dfcff51fe5fd7514d647719a5275b783dc7a662d70fc800a9da58207c8c9de5a0ef6510f4be9e887e345b5654079a9d418e475cf28f394d79f12254a696022c44a78398d3907d00a01f4df67136b3d96d755624901a90135187e29578439ba1d81411756045edf6befb1fc76c0eaeb95b9d25df8e5f5c770fe892fb3d39fa5cd3d39325ca456fa37287ef0c1923ee2b25fc41e2b1bfee492f8385583b9667bc3260d3a5deb75eed7f098529ea7535bbdb1490157288b44c208076c58f3222772847e7436a260c83eab445cfa8ca5373e742d05835290a85c3c8f62be47523dc072dad5464d65ad39ebb379d8ddddef499883a706b2650ea0db682d24d42b33c05326224aa4781b7a7d281d80898da52ff834c9cbf3306362100775b6a3c88c1c69d5e2fbc727f1c726e9fb5cab80dabe84a52c955fcf58363d1a745ec732c973da1ba1388a2a5230c2e2c5402f8664bff848be544ae545d62e62a3b977cfd223111a28f8f99a41db0db6b51442953fcbcd8292f32e339b94966fbe7e9beb463a98b5e27bf214b15b41bd1244fa628fefa46c244dad038baa0326942a727e1ea11ca75529f177587f64f049e28e4863abc07d451c6e976c7176c23e0e1509e532f0a1f82174c8bb675dc7ea5c52d704df0eb8333768445937de2b5055363dc90bf261127744f3edf56a5683fa49c06a13ab6d3c8f75ec3ad206b119fa828291591fe197b69df5031eb8b9240acdfe851ccead883331fa67b4de2c9cf1ce9959fe7ab092ec2a20aa761c91bb6fe7cfdd43a101bebbb77b7b19dd1839d3c7b5db46f9a18d85908ff1ac41f3d28de5c20af47d6b13537f7a2ed407ff5679af53910ea94944216c1c0293269fcf3d140e334c821b51d8195594783dcc8f4b7de933c2af69a4429ddcc55f96399c22f0cb4bd000b5a74614d2dbcb77dfb9c318e91c8f6bcd7dea3dbe15875bebbbe3ed5c3411a15bfe3195d164c1cc3e4a8d5dabff162a152d3959f65208dc9da52213d65f62dd97264f849f47bf1c42bb22300f34494f65f189aeec3aeb1699e99690068b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
