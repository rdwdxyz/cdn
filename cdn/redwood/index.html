<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe6c0d98e17a968c98a567c147a252a5df150d3a698106a1d2e955715ac18674de8f72d64772517b845b6e749d2c2c6418058ddf52dd07656682adbd2a5dce746ccc048ea2efa9c4e4970e13281a6a41f5975461d2cfc1923f2c3e11d6888e06f787d6dc2edd95eb81b12009755ce8b614c5da43256868bd6fbc7326a89cc9ddd4c2d4adbfd6d4e360ea07dd8fb942a7a4181d545dce496b2b04dd52b060b5caa035b31b5d7943c80af4d56184ad99f639cd9c9ae2a1cde9d8f90e3aa73ef22c3ec0e3b958d36f26763ca2ff7061942402474c11e1b07c86805215b572ce598d479f245093e10fc881d61b632e050ef477af8db290ce02ceb356ff5d6c691dea7b56006dffb4d189f6991cee7061d2b244e62e40eb6381773b1fc41716112d787aee692e2f28abc45e2a8f1c0cdf6a6426c3507e7b2c72f20d26a8c684625243da4e194d256d1801b9c0ee40b5efd742765095ff5c83c08ea633f2c5c7fd59dc8d7e0ffc111e8a842ab51bcc33496be2b0301c9fca59946f1880c76d799f1384836337b5f45b5da8e3b0bf0411ec81aeb4c84d45a6b5b713c6a8e5cd4de49cf8a6ca11a51b5f986a8fb4738dbbc670fc7c628d1af74e3f18d3c3dfb200daeaca8b773aab83b7f139ec65303752608da3eea0f43ddb5d1c004581a6b7572ace777f4d6b80cbdb810b7c0e267cff43080b07c9ae6ff73d5b6f1ce207af103ce3a33a1c9ba7a16be849dac905add16937057d674f9221ddf4edfb78ee02cbe74bef6f5c7dc531eb0cb2652ed56a149635d8b337cd085e7edb755f4cdb2e364fb67b8b6b90a3134417770debcae15c055da5304d0a28d7285093655fa4ff9587345d0760d4498d6ee423d4be9f1e5e96a061c324e2ddc821f7d61e9493c3335e1df95899b602a16d969300834d3be6413c8c50bfab66b162aadd0d47bd077a9f58bd7a80ca1aed190c9231b79e2fdf4056606ffcd4f65d7ee9300282c48c22187bb1926aca27455b83d99db3a5bf31f89e2c88e1cbf77d52dab90c59704a77a7aa0ef8d5cc4ba31aa36905e8536b84ea9e1ae75625c9c5f9324198ed5b25b0ce6c81fac567db91b681a6e92587f61b7f4cc8d315c312d4ab2e0e1e5e0f86e8d7a57e9d2f35bf1318539d0cb2b5907e8d5ca2e231413db53619761f9a771017dbc5ecb0dfb2ee3fcb55cf5fdf56dec39f4ce0b05276b7dfa2623ba8755c8ccdad0bfa9e8c0d3a811a3ea35edabe3c0f2298979d702fa4adfabc0814c76c5039db3c1a44aad258325b20f0bd58c6ae76c1eeeed3c6b89e05db9ab309388844fe735a715e70534c9a50ccf350487e295183761eb908d8e5dec0b6d86914121aed86ebc40a3689e82f1a8f83bdd683028e1ed1029d58dfe3183ce3ad2ccfcca9b8bfab091c0459f9e894a7e4616646cf39f7b09949cc04ba0df3045fd58919bdad53ad5c80f794fa830af2c21b2ae140788d3df3057eb5cb853b399a68f984be2aee57e425e5cad0604ed91ed0406bc324ed61916259f5f1506d8a7ee560604e0797478b71e67936a3aaca1570ca05cb15772e880767405fe371fd60410301ebf14eacf5753657158c48c14f4cf48860984a2f0a3ef8c12eaa7949506201930351c634746937d013e5c377840f19bcb96016197cd1cce0b96dee7005c716d818c2184ab8b6040352b509220b61aac8a23fc9f45506bf8ddcb7d221bc44ab79d3dd11530354f6c09107d85d7a2b09470ca2003212678cb3c6bb355d7de01722cac84a3880150a1dfed25678f5618be0714368fa86ff264f87f3c14af1ebbb91966079825a4324acaa3a4f4a245edfff14285ccea8d289ed4fc3cfd58cf5185358254ee7fab6f3a247439da9c5d6defe05566fc9a3917dacc2c6b4451745ba2b9c6d1882cfb702020ff0b3f7b67bdb13a99288600fff4142faef7ae5b53dcaa78118f94b8d348a246294fbe0b3f6530e421b6980262b788fd41db4181421c1fc6e2ad1895eaeaeedf4b38ea743001c54e2cc6b916566b9995f2275424ea073f5068f6e4cded76df55884d8fcedafe53b81fbe5a7d397cab2a64168b8436622838325b1e38b4ae4433012712c5302b479df8a36267368182c194abb2932a1b35f5b991711e78773c3755924ec96c76b95080911dadfd25c21c7145e0317b93be99d7dd129af0e4db82aa7a1fdc8a951c90393dc0384864063967dc06e5659b4854885425106b33931ea3c3552481875af37ef585ec2b6239a20649bdb40bb5259e5cd65990905e8b4f16ab507286f12dbf4cd5e6a74834b552003e5cbf7caa3dc8f01ef1dcbd728bed8c1707af4954b7d8756cb0166a25a15b18d41f236ab4861b76cca4e99f9c9af7b76c51277ee853b34bbfdb06703aa9f79e2b82a9ef576325ea08bba17a83df3f20af6bac8123608b0304003e27f510d804ddd87ba83cefcb4d2f85d596d3ce42158e674f045c956eae806ea1f7c246cc502c54e1edfd51b436606b7bd2aadc0ce4e03308e72a4ebdfbd535bc8f5967cf701007ef462a9ae677020c28e10548f829562970415a7432f2846ee314f652d7ac1e13249f4f54bd24503b734975096bb4cc9c569a65e105ac74d136efe7fc08cc021a10b0146065014cabb867929014c5cd51b7a903a9224b28a0fb5bd65d5204f878c80f91656ad8c19c50297619f16028eea6671fe0a617912194a7ed0b7fe19ae8aedd31971a8b01e68da6ae7c80869c96a8b33c8d3cd82161bf7c75174b91c4fd2c6affc564de298ee55172ea06f4417a2698fbf0b196cb3ffca9f0e3916bfe8901e474bf86f43d28bc1e944b64a9b1ffa57254cf9d0f9197a782fd491c57768bd3ff66a322242b78c5a15a68b4be127fbba85ec928b4f5381e6e6e37f39a965229fa89fe6995149da04296a7ddfb050cf7a42ea0f40d0e1969a7cd525cdf56a23b9c0a7ae89dbd3f38599e4a5f23c4d3cbc9b73913b7f960ad452210520772d3c22602a6f8c9b7d9492b276532d3993342efc7f51fa8c7f9f3712ae6f4c31a4beab4ccc8ae9b0ca6fd4bae6c42cb2364622fd29d9cdcb3438401eb446c1b8595c24518646e74f510170e5cb97fffc6cb51faf958997bc4a92d3b0542b3819df2e949652b689f504a40ec44ca20f39f087064591af40fd9dafc60a5a50f1d7bcd7c72eb629ca406618f0a94b1dba946b7da1b432fcf62cab9b8a41c5eb8774a8ca89275bb995a2df6771378696013fe1971bff3b2a4db1e2f8b495b2a4090a83d5291a7b097baa02d58aefc0523e21e259d3329ef07758480770f612bcec6608411bc9ae357168e3386d19f46d3647a9f3d2511f41e6c9692edc7adf8ab9bf6d1373192789be71bb7a8fd89acc5cc88b1cd062972d9c32a42c132ee54910f7a228098e23526981b7fffb5f622b811b2f219040a4c5bea81b13e6b3633de7d65345b286bc2f9bc1e9b7af057ead53e182500fb43d4211f0e18f795a29066e8f250c23560d55f775d4f061df8953de569787ca0038d57949a211b8e8d0a0990b23a7e5100222d67b45c2849ce30bf68c715dfc5a92f4fd6c0a886da836dbbc2f24fb4f37505eb902074f62cb47c974bf03f3219384004cc23c4a6ba7ad9af05d97d78d10deef91cc5e5fb830e4fc0a91106b6a33586da6ca2172bd58cc0229d3149cd8ecaf558922cc772a9f8e557aa8bd6dcc497802f326ea12b7639e4162d1f986b7af643328db6462d8deee262f4c2502417abbad1728dca48c0ba2a82b78c334ce62598dc198152c4a16a5a613550ef21876cf9a28a7e7228e8b5ab5d721bd77f0452c5bd88fe0f7eb2635af3809f338eec1440f39662c8c76a8a848d7fe39993d533a08a5e832439d40de19ddaee60e8d22c528fdfd2c9463918a7d4ed8462e7194a837f151e568e1711a9939d6b1e0a3f4183bacdfa61c52ccbff23937da2cb6b69787aec3b2ebedbd6dbf80164b595ab3c679eb4e51265d1f6feef28f7b8a38cf47324295f73fd3b1a5b53aca464de269d77e1195dd346909a4e944d4048b6c08a13827316cc238dd4780e32893722e859098994b40a521669a7a03885b071359579999ebb807e6fb1a65a980bde30aacebfabb7658e59a5bbb6286915e3d8df98e050d4ed677b30c1bd163b917e9f2ce22559ba6b209cccbbc15db9987c6a7d6ac23e3881b6340c64cdd19932d1f9cc951311fae5ebfd869f13c2ec2c6babaa0c6e60f2f7e14b8e8ebaa335241fdb5fbb03a51ba199fe0b3bcf4ad7449b2ef120d8f2df8290d565dff0ed0a296b01a23aa0d728ad73157b0331af5f42d85115e4cda9ea53d2f553b2c87326a42832e28b68d3e61d5269893978d3f532c3890325294eb3e2e53f2e9b92cb44f2602af0257c760eb9141ee21f873eff30e4ad565ce6e1a1c74f5f2bad701f1511e8b42a4f59676d364f0355fe477afb2ca2e7ee6a526a3a6d93960b2ad13f37425ca977da19f80268e3de8f4e256acb436b73f675a0c9818eaa90fab19977d3d800c24d613c47dd308e1f5339823eaeb77e5eb0b86d482bdf8b3ca3d1713e3ad4c9a923c54dcb89bfee842176c642f80595bebcd2145b3a5ae8d000306bc802e2727dfad166e41b0fc047414529ac6e3db278882fdf720ca74f52041d91f46fb59c2fbfc313f81869b745cecb8bb60399dacd743b17b421f9caadb3d4e310d3c0492efdb9aad7ed068e6801d7251bb5c01f0266dca30dd1614fc698bf662787bd97fecfaaa2ba13cb1d31e099967d74448f076f0dae58f3dc18e2cee27faaf1f7da06aa5ff79c445b65ac5d849e10412a682e06ee423023f822838cbafa7bf51e763352c6e4ffa4996faf0b514e233844f302333045c3c5b2ba4b4883cb12a3e3bead3fa5c1b49669337071752bf9ad1182d532b2307fa2d8a5913d44b6d93856538c595391ddafdc3a1e8608e9228b58036e3d5162b6f022a1810b41ce4115c8d1da53d79a85f4e174ada79ae8c2d6191b3c04297c3e110e5b445683dc60740f72b929d9afcc24d72fc6ad6348bc1fa247e71230f4abbf9e1f4bd9ae96281ccedcc6a09dc4f1ef6a4fc4c464132b528977b581729f2498f6254ceb7b7b784e30803e5b11d6dea1752e155f45abab7042744bcb461884fdac1dc1e1af8ae8bdee43c8c2134b21b6d717c6a72f09ec7c249b0897f2e976521f3fa125b8f63a52b6b5968fe0f6f803d0c899c956e122d2bcde9c38d5a09dacb29defbdf64b071e412d36cc1eb88a5d065e686dcbd8748ba4d8f6df239108aed4b39137ff1569213dd67a17bd30caf6e215c80e69e08fe2fce67d9342e5141fbcf679612b43c25a859d7c39c5937aff697f18b0f0a78bf2e8eac85419bee477c33a4fdcc33a4d6c0e6bd4065ae878423590c316f6b3aee07a62f498871419714523e161bf41d08df341baf7da921402c83e0fc359129d0b7ed3c60f04bda9dee2478a98b39112f06363fb43671a442e3d46fac4f2ca2c2d64aadcd897d51d46571820f004e7540ead5b5bcf82fec99b13d8e6013379544984af6c47ff100a1c2700d8c605e31ae8850d97e756395683ca3cf9b5a2d8d2c8218374cdb7f1f09e934a6b7d2d74eef6e52f98ce25a6bacb3f0d5c6722327453f8a78e1d087e3d3d16cd0d3e0262b7fbc729a2a286fac4b8b366164087be27b221f9410bd9b9d9796fbf83e56abfd2be246c8c995600bd14b224336d0b7d628a8af11cc56bab414082e3d336f03784945e922acedac594f8fa853a4e42615d321b95816c4867fda3750a86b71786cda36b1ac972ad56fdc35b46b0b73eaf00268ad260a868a48757474e76083c3f7aa23ca984db18201c4b2500bcab9295295e719e50a7fe5ebe80c5a1e8643c2761c457116920d82ac86857facf8fc825e2cf3e7d5e70d9a78a4e1c5bdcf5f00e4934c2c599ae2d2e0eb4cf991446b81590be44e17c52c49969535410f8e75e5f5265082f21626babbc32f6752d523192bd0929e681dc6f51470287c5d594fc5bcba2478e133b278b2b3a38ec7249fc9bc698718d47a016f5534e171ade5471e772a892f00bf8d9a5e37c6c537793288d5508a6891eabf1ce722856b62ea37886dbe679dc61bc208325eb9de01173ca570d88670fd6ee19543e9e64fbcb23ba561e5dc83353e1109a703e45980870b14b07d91c0c5788b41dc9381e87d3f8501e5607a51177498cf99d3bc6eb92af2ac8a01aa17a791e03104b99f0cb97a2ead958b58f806753051b083e5c5ad8297da67aa7e97e30506c3ac8ffc3b97e7523aef128d8ed1be4871c021fe0579e56813c38efafdd1a666b2779b0b89e17ce3c9b25f4c2f6ebe883485b669e3a84598f06d058b1b8f9ab04497047b3b359af7170add4095243b544ccd2997c50966541bcbac7e8fdd30ce466bf8a37ec5709e1497ed1a0b77ecdf18af488e26d4656095fcdc52d05c416a63a0dfe8e4347d6d72b9ae7a83052b126d890f85c9e8dc6560d984ded1df833d3282fdbe90d2865fa492b66c0ac30e411c8741018a18e239bdd92fd0a41cc0b5baf7f471aa3356ecd303e67eef702a9dc679cdca02a73960568cf6ba2c765976c90d0757b1cad5ad3900b92aa9eb74065d5fe5910df063ab87b96b8efe525ac4dd60c810f5d14e59397496b437b94bfdbc9330850f10c35d457abf0955f682dda461f6e6410247569f007c874aeecdbf208b82e1a23baf70b2f290cd4cb476b8103b540efcec034d913422957bf0e5826b4d4079594ca602f71b3db10472277323eae6e19296ceaf7650173543faf898394e0257cafb45b2674f4ed773c6d448b81c468271d4e9b00c8211e3a6ae22799b341dae00fd25bbb87fbae82f7105f23fb2625ec19bd25fe82943af327f06b1333e77fa56ad0122b93f3f27db7e629fbd47ece98191fd722462d016bad1630bf112fd5180506b43d5946c3a8fb038d36f5f619e93e9235f2b1e0016cda2f519be8ce652a42a4ed80c0bb7f3ce2f43489ec842876a7d7824d807a27f137704f83ec88e0df38720f11eba91acbc6fb7a8bdfe2c75a3b60f2bb7769403ac7a25dd937f4d38f7d2f44972ae9204fb843faebd6dabc3735ebaa68cc8a8afc7187b43f3949bcc418124f3039a3249228f618cdb2c6ea0f81cb048d708852e4b2d9da3f4a0d5a4b107d28b00177f06ad3d46eedcb1aa38f144771090ba28b86dcf9654090a4f0d7e20e1d40a2c9dd4483d47b676f9174258f54aae0b82257a490b26ef11613bd79189d72a69693dc57e21a3c3466ad361d713f551f512f869af7b1d10f89d0d89bdd21ec6e1ecb318200e6cfca5c1766d2ce25035fac9dbdc82edd22a5338e57e9bbe77e00cafd8534693417f64e8d09d285b3592df4d202e85c9293f3eabd658c9b7484707c51ab84292551474a38e7a7f03e60bba70613454960cea35439cfa98f813941ed6a5a6bf088e9b2cf3b5ec812c6c00224bdc1781984f153a3553a22a3805cc1f97f538b5b4bc6f994441eec604ba67df9987fda15d5630b9b9f0eb1efc70cf9137127c04f796b1e3a07f28adb9dbd60fabdaf9e9f0e2ac1f936adc38d137ded6972c8f6d848d65d297d97369e3505f42ea9013c5cabe401f65494099de17df4af4e17402f163105ee3b3bf0ece0dc2a54e368b7faba1aa31734ebf16721e4bfe55b3bf13885006a54f2bd316b9e717fba7e747e9133fe81da7670ea2c92e8a841b8cb5efe77d61f803fb196be4cbc64ab8e872808b8112b11bb2f34411b84d3590c3ad0ba50d8bf7b909c3198c562d8d04e4c56e913416ade626e99a6de7f720188b6ee391075aa81969caf18e2e38bca6d8cdce21ca87da489cc29a989855d8ee71bdf134056b454d8f263f30acaef571fa54d33422b9b3a582ea160fb36ecb77edc964cea49359d62054e70582e57cee395854bb3dbfe57347ca47db8d84444551a2907239094504100cbe62c364f8434946173701a57134e02ed025a3e714412b4ca3ce9fa68a758ca0aa668f0050ad2cb66a2eeec42ec0b659068ec42dab9e1ead37fb4d7ef281d3000a3ad71bc093414fe11f1bb6a92ff0c064a07cc44cf68eec618d4da8c6137ad948d3bed468e9d9d0dd7747499abeb4b16e34898aed5a40c206900822f8945ddc5007403189b25ac0b00784433a2fac891a1702d5aba657eb67127cd9c93d8fe11068dc1e3fb3bc431087d418e23a819904f59dcb1f3ab1b9781dda03c858232f633f0b6238ed73471ddf3566294db36279f6651a787b4a15b804c132037c20ed790ec9142f82cbeaa88caec548690df34e6e974f19021fae3ca2e23c94e4bb27335f401fce30050bb6a5a10ecdd366564937203b34819d229e92a87e8d08afe7baf214b588dc79f8b311fd137408843c2058b81d868d84100e799766148280efdb6cc6e3fdfa070afc25ff05dcf02f1a7a53eed14bd884744cce4a80232849f373a39ea8e86422ac46942333ff09d3654bcd4287a6a8568227e356cf2f76823f7355322ff238119b16fffa81fd051ed2b2398a217883043ea7df29391e546ccdb632908f6a690b3650ba8064caa0177263448e7810d2c6afbf88425f3e0760d1c2950b7e63da63f2e022ffc2d2d23f89a316dba6b11d75ba0b777de185d4b56c255ebbacc8acefc457433844034de03650b5d33e5f4b5e9f88fc387f39e1bf7e0f55b310fba13a452aa8c4080f3faca34c48e3a614272c255c378c8608058f39f9847ce632c48e286c5fd906121835ba12814c123107b0c898db955a33e4f7bf4d3aa0662b8b030115c15e1b0e36b3e847887910d8e400a08933a5f68ac5627b126db31520b6bc755bcfe929e66c517f539ec9bd049cbb17e444517df8f04090015e4ad77625559824fd59b82032d33d0baf02e078b7e0211937c2720fb13a324b66dc8d7fe4e2db94c2985e3ad320930cf0fbf8e02bcb9d53e72c70637b95935929d0290970218e74ee10181350f159132e5b9897bf3f7faf7a50097d5acbe59c3ba01d00320e20162374e420e8a8d7d477bec747f67284df8c81e33a34bcc04807a1198836406037788c252d6818ca48ba236f413ede002f0ed4dba805c0caaab5bd08f256e14f53e5d80ce0e36aea80f8fb8d7cb96e401546d8847ef39509cb8bbaa4acf416ee842a906a8bf41645efc240b5473bb8542db7e43325ad8861d01b00393b9f35ad4ec7f2ba6b263b4dd285ddfc2dba515247c71e1058d30c781bbda1f1f508106802221ee566eca4b1d95ab6372e300c561fbbfbff9224d9f946866d6bee267c066ea82374ec27a93b172d805737ecc3e66ffbb08b4c66b4e369ce6710bfe475c62762a9ef82d21d42ab09633b8cda1c3f987621fccb66208813a422956b8e882eb0061cee0cd88061fd870c975ba8f99820e72c2586bfc0727ca9f8d828a4d0c5a827b02e0411e7c246b7dbf65d94624480d22eaed8d45b8b33145e5ba00f3f3f7fb8b02797ace37e539a85ba5ce982a5464a92cf9e2b2b8705a7c36bb5c905e0119b356c43f626d373789791ba788265db02bb8747706a24caa0571a984901e6f16f07baec6f3de2edc3573c7ed4730cd0e07e3c26ca493d1947c9364cd9d6a9f84decc684a49e5da5a9349837e7d9e2935ef5ef93b100aa5e603911653f5f265485761e4c2188538907a15428e77f4fe06b05b00552c24fed63616aa70891b9c5fdbf08a663b9004325038567dfa40721a4ce1ba5120ab8213b3c214a305f54a9ed366621bbd84121dd31e7475734be0c249b641ed3452e9b7f923909f3189ee66e3a1d996247be3fe45a62c46a638d7f82792f30fa54d70e7da2a42a0a8847c22b64cfabdb4cea04ec2e0c6f581d9e5ca4f1483a8d2323bcfe9ef05a6df005851f3bfd40b2d36770bf216f965e61344165e34effec1da8a0f920fd438345f029d24a8afe6bbf5637f5be42fed699b58edba023042bc6bd7effe450741ae9b5568233d10aeb9737caf74d379f32b5440a210ab6d1466b8cc374246bdcb7cab91cdce7d626d905b2ad5bfcc805c3eb2eb9ca1bef2e430978aa928f900d11ba0f6f52de85ea027193e9be38b9f03c5eb2cef5cb2e7183b36d4c4107d800ab3e5d8046ce0a8b21d444eb1ed6d28c63d0761dbaeebcdf18c8ec668020ebf739adee425cb5cef915cad756f0e792816921e31cdebfc556b9122254cd4f1c168bebf1c45528887b4384c7623ffc343d7de51cc0ca92996331e6f471b380e662514ea1fe31c2c8696a502efd17c4f13e09390d8efeb64fb318d093c9c4ae303f6686e03a73802778c0750c40f9606bbb88aec494283b2f38e078c870afa5674b9fef6f5c01ea961cfb72f494eae078d77694c50b145573d716b9973a785fbf2e6b3db5d3913971d1c3e6333a50a6d9b803ca684895ca7a2bfca118ed8235ee9ca448528179089f2f76c702041f126daac41f316d90ab497984ba70d89d649017444fa7cfd19cb02ccc782c7da82e4bc988f6b3b6c35995407febdc85b6ed6cc7d0d4d79cbbaaccb98672008599152d6a19e3ba5369e594b9a30c950f49910856a3e7b34989e6c1487328bdedccc400b0def1ab4a2c8838fa77b50603a505d5b495eb66c9623adb5464d8ec90aca58cd02d2b6b3c946e60a755691969ec1a20216520b77fd88086f6bebdf2059c7008b2cbcbf2b2a9092c54f32d4207419b809f9a003bb839dba602ea2279b92bca2082ffa827edd5f4546d76deb821a2870038bf9574a767a1aca9dbf4ef8f3aa4868897ed018a90a50e163589af1ecd9909dd0275aee23f3abe00e9d9ca746e706a5e980eac0617b726d51c380c254a47b7349bf65a2594fdb30ac90b4ce321e8d4416e18fb7da505ce7f1caed0dfda187059ebf32cb612cea09d346c1c4e75b01a14cb824a5d2ec0f7b4bd2962678b29262c162034413641ec27da29376d8ecf54d46c6124ff0451c2fd1d20a4309ec3fa9910ee5bf400ce7ffaa1a8bb5f849f527f9643bb7dfcff1a13e337fa851312530b1128906f207d9d6ae835a495c6940ba083dc7529941b41c7e231731172f838e429d7ec4194ea682c06c1d0329e2131274ebd899079ca6efff989dfb1624e9c7df4deddcb38dbfdd5f8ea5707ac7b8aedb99b6a116ef55de680e7c1bc08757aa9fda3a85f1d33d1f5f626fea6d09da0534788265970dbf709162e68a900823deb1c9093300e6cdb6c056a4e08d02d951aca3c6e19169f22cb703edb3fdcdae8833b1e62783f08712d1ad0601223bc3d0fd9a7ef19d2018d97862a3db7eb00b9ff24ce94a5e528a4cf18c4ac37f959433d36472b6c6166b88a8d339f6049b015e38b51fcef48cf1c557da3d58966d94f704aa4cfa33b24e558fab7e1c1b6f753d898e90331a9d58e32842981335dcdef41b97cd4904d0d58c508a6a53a4a1d780f510096874633e324e3b5e164bc3e38e2861f66ae0d0a6a3727c620f1fc964f8e6efcc15d1e38ef50ef2f4d2e4da4b6fed201e922c23cbf9b0f8c4d6a614f0c110fde02fa46a736e76055a0f2a40ed2cbfe53cc6f7fab1ba24d317e08ce24f0f2bca8c235499d95deec50f9975820bc358774357ba8f6a0cfa862d2c2ded228aec6ace3e3dfce796f6a55304b35a6cdd1ccfd4a82b157d24fb9d7f68509109927fd0dbc8d0bf79870841715459b0a7791e4505781a5e15631ec97e717478d101e116051fd417e29ae795a53043a20fc9b21fb9607551e80a5e39bfe1c344a1f27bd4a8d3abd6d0114c95fa2e6be2012612273a7d7668d6877b871b9eb2f029a6eabb584347dbc52192611ef6a5ab887517c5483aa563ac4319688fd835e9ecbae7f4bff609f620e3845536b0b0b5a88d7b8622a62c8ec7ba03a722f3d0cd0dd4f33d0257c9528e84202b1f67c021c3ecbe00fa73e89d6d0c4d3f8f1a28829ee263136aa0c043a44f7e08b1ef75c3ae1c213671af74ff5d7eadbd31aea7402bbd2d768ecb269ec0b70782ac7798d074b4cd3bf5c67f912d4a9a40e5d4ba36d20484e232d89f4e360546d206fc744114569efeb4003fcdc722d85bef61c00e1dbe632f4e21e2aa8209bbdd7aef88de4ac5b61d7107a17c3bd77f43500f26c68fe9ce2f3cba70106198b1e59705b6400b8f51f5b1c0ec3f9e0498e3f8e882bde85241e34665856097bb60891222a97d25022d21ba58d66b3050a9b5f826271d73d74eac75583948cdc6c503fd45bd14f3a43e52916f26284ddd258f0cddaa1978ba9b36d90eb7ee6bbfeadd49c5796bbf3a271e2965fcade7e3268995829e4550040c2a62fbfc41ab004232f8b299417094884555004726c031c88cf3d864adc9ef3be533077e63d557bf58c9cd0ac8cd1c3e55aee55cc58000d4cb969cb85266e9d55485e22d52020f0bec204ad28b8302d496d2cb36209d6bacfb17e12cdd0b5705a1e72035d15e61035f8f1ed3ca4a4bddc7f9b739f64359322912ff76c2332c54e99d26727f1eb3830c9428d5b64f9e92c41e7deb0487a4d44aaa2a7226a7f892fd2b86c7467d91ea8097c64517fb848a605865c471c4b335994801c6e4c9b9dcefe3f8a7fc32fe1b8794029200da5d6c1f9f470f284a4d42246b445b6472317ed2c04f82b97a705801c2dd9eec6dd34c037c30926d43f86a3d3494e31963110a00528fcef871826085ebc77e4583900728363443a9aec178f599eb0ec300a4fc574a3da4dd52aebf5133f36755dd655b9260443f3d95251984f657e2e6c74c024eeecf58a5ba8aa6abd898f3b8d7f990fdfd7253e08f217f322712f887333f90df2fb11c0c5a2bc6aaf656187e573e8a7e3c07c787407b34daea0048f00e9a9bef64bc643223dad88c2d43f77c451c4a70fe4e940d2363861cdc1e3b921d79f0953a0189ade45c055f0d6aefc3b9273fc2bf365e34ec2b941b45db30a9c276d9b2442db6ba657f299a23eccd22e41466b1f0ca726f2a567b484b147707c7783c2be0caae3d991d404feb55f18b03e05f354a47bbe47cafd192d7937c7519588d79dae721332a440d5c7d262c95ba3b9a221f060f9bd4cf758716e67bbbb1878160d1e1261f12ef8e6f5329e05a0542838cf4f72704a692c32407dfa0b8976cd14236ceece3032e1dda918c8e4a26bec302fdca1c76346bbb6caa356a28dd517abb9285d146dd735552db191d833b994b2af57cdc3c8af59aae17858f9f78b1ab6fff0974055c2d1b89d413458cc24e7d55d6a39a2cfb0effe64bf2fc52bb0ebc20705d68a23fd48eccd56fdca73b6495eacdbc2a47c2888155b1bc905f52ebc5dbf89dcfe846e51c98caa58e0a94fed027ddf9257d850a2663c2cb35d4558b00768d615a50020ead69e15e62a6b4b4570753a8663b422cbdb49d3b14bcc842be19b25612f37ba267292010889e80985aecfa9b18bc6701fba74bd62b8644c976d874a7f9a43c92e2c7411cae5d035c07da3f56311a47009521c5d270c14762d7e35d21804bf06cc819841bd3b5a3b12feaaf3e707917035e319432bc8d675cb88e748f2646ca56255fedeb26b8423dd838273e77b8a23c37200f33c96a999b27f04dd84df2cb4420f40129920a6ac1cba80883232a4c72a8893f8d19bfd8f2fabd10af978ee6b864beddbcdf2b5f2f58ff730992762f4ece9b97b595853b2fe0da845a7da36a7c2e44c652fa5e83640d7c9c629c9b7b8c807b67de6ec83b9b80554688a1e84a6744390f92ed9a6bb471efe240e91e33d3cd5349b8412284926fee0a39a077cfca8ad0c2bfaf2c49d605b5fb9b47508812c8149e60ba0d208d1b5de60512407e9752bf27d8731fc99aaf8c78cd88c659ed858ae8e40df5c07155444be7e331766170996ff54bf5ae99184ed18943dc44459f30f04566dee22f73dc91f158c822f89b0455341d9e64a1a948ed390bff35e548c8110632d75293a8abd5f4326009c3b23e81aadd6a7a7fada8b0f8273dbf21b63ac61336083d0ea0e2749bd0981b34a4d3349533774d47635ef0f7de0d6130663621ddf70c1d7ea6d0333f49f6faf40d14bd194198ec7d6c30e9065292e6d407b466f736e2dc7e3ac5004a957fd69a1c61f52d3065f37747f45b540be0926a7e81295c7ab11f51eecc62fbd919fff95cccb50933d210557ec7e8c2cc7db2ae6f15d82e3d7370f94ba44880bd871a5e3a293810543c3d546116c3e753650c1cd9ecbca5cda9a5c31583aca93d2abd390a165d79895eff3ac4215a8efcfe677f34336c7c47e2f9287ead0bf621726729f0b6015fbf785543950c8147426121a98226a801111fde9057a7fc5034d080e5dcc746353053ad84b8b5b62efb06aff759a5f8980cb08ae160fbb620c5f6e2ec3df27cfed48f9c0f0a421b221af180810543ba7670f94155f55500299c494b2d2e7c211bdb79ec0b7e99b7a40ab88deaa48df977f868b258d34244677730768f74c9dba674bbc2a0bd0ab3c441d029cf208c52ae69dcd3b3525edefdeaeec230a142f87682ad1fc4a742532e450ad106af5d246500fd5ca817b9152e62fd3100c1c28b279ea8c66885406a9203c640972ace516456d782f92807174ca0e0c42efb479f684ca712a5e6cc489d0929aa36233738683a6c4ed9cc6ea9d5d9a0a09d33c5fe1b83eeb4bcb61a7b3dd4bbf4da4832ce7170c8c68ef739414cbda7b4653fc193b30a5f80faf3e5152246efa2ea0487204fd855b1fdd8f448d33bbb90cd53a7743e75303f059ec2ed183eebb8ec7b85c6476a585a6eb699931e5f4cc5b08cb0008bd379a8b246bf2a25c16335e76fcbf2e0a92c23920462505a31afa8637957c299bd1db0d3cc9c8f919d55931b6f5badbc73be8116f109a79038997c04c7591ff736a001a4ac1849806849164afe0a6049a0c553cea1f1216f94a818ae85502a9331f8b1129eef72d8575155731fc4eb2a37c8e25f7b9bb733e4fb6eb8a651fbeaa503ffce3074dda4b487ac408f30d2ef3188cb50a0797c87d8b1d89523835e05173bf264acdb945fcd62656a3a51697ec992da7f271b673441a565401dbaf93bf67cf32bc3a6ae0f08d8cfb4e752ee550cdfb21044db2a16a271c2b09bf814f549423bf700f87553dac1710ea7882e9fdf45f5056973193846dd576e08f8da1293b595ef98e716624fd0583672ac962ac71d7e8d26809262ae03d1ffec0aca7409f3187a6cd666de3e0ca2a0e332871266b0a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
