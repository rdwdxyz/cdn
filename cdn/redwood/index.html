<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a931ecc4da7c2703f0565cecd5cef45e7e2bcbd503c95f533ded2a36efec705369a6f32890d1db3761167faeb6334d756d9d88e425b51f2395e468e1582bc451e7ae6687689189676084c2542a25e9b177d71f30c0751b7babef2b480836c43b9abf473241d8fa78eb80cd208d472938cd5465d12112b4f2584a94361c5c73aa9522e6fe11aa911b29f8bb3fd2a4f4cf0e9f4aae1b7280e44de85ee17b83b6b69870609573c6d26530a99680ad43fd4278bb51dccf06139e286ec52f807de99f69ec8f2acab48dced99d380902f8a6d786bf314e805939de21d7e54baa89495466a4556cd3815cc937fac61e52b4d36a78f6d7c031c10397664d7fdd010518c14340b4ead0bc9a161cd8f76a0b6a29bbca33852ea981df4ebf9e9817864b212cd0ce28d4676407d759009687aefdcc1592f523d9ad8143d2a00a0a6c5a04dd87e2017568c8d60c8e52b785ec0e6982432a974ca97c31775fe8defbdf2a13c9d5a7c49e6956adb9750994d6bba0cb4403799f5c0b47135d6b276cca404d0c61b6aa8ede265d9c9068fba7a706e8d82a5eab64cacda4b5a48dba6d4990217810a077e0c6d980ff2d7d2fedf1010eff346e097c3b88427003aa2b785a567f86f4b1da091b28c40a106b41081d4d515335ec9bf846128f74838795070ee1ed2860d7ce7cc4610b4bf650c11b9baa2e19206606e2d4ebbd2aa909a7eb2d44fdc8cb47a7b5441c273dfc858e9f5966edb22ed5ce6ac99c751c696c62466c5e1b943c00583edbb6b5ae705b5352cc4a5d96adeee20710fea413cb4f076d45298239c36d9055abc4b07573d93d5397c4dc047efb8609c4d6ca7f73defe14e970cc10eb2fb44ee9eaaf71d39632153161f4916dbf16522d94de0f7138a6453027fd411399504aa07210c6d06af4a455041d89cb0fe6bfaeaba4e929238c1ba14cdfcc1426c1d011338e12af06d90bd4d27fc2c16dd294cddc023b43b972759e3d221cd7c93eb2573dd066531907837e5944bfbbe1f345569c8a8816d0eba079609fcdfd4161ea06fe9f0c93828701e158b6f31646d872645bbfe9109ecc7d25be11942d1d1585569c73f1c919d9946e4decabd9b899b812bf4e917baccbef62a5f692ad706be1911c3379a4075503615e388b942600c32da63275c9a5fc000703fda0941b5ca22aa993a6e98732091e56c02064bc1a069801c7523c9d8b28077228beef1cb37a6e4adfe34eb3508eba5b7da4323f3f7a69f95f3f06d8a7e4b98f32d26fc2b6bda5d6d4b15670402836a9ee06bff274d817d8b927cf9f97fc18d0fac3d4926c1753c5f32157142461a8c0639e79399afa63c94163ee7af2265b9fafa73de41e1dda35a03f297c2ec8a7b426ab5a91c896189b26d00448d7ffa21c30011b235274fcfa6e56a1013e0bf71faac4c4003c564514009b84147918924548e532bb84c384b08f25f014d21828698bc1830bf37718a0e852e937d4d0b4ed13181e5b9db429d8b0097b823dbd064362b509c802b3b663689ca90d68956e8350349d4274c23b8fdc42c5d1350c82479c73c008e2ff350205d9f43b3d2dfc42f2ad5a7355f6f8ef89baa66340e7be6491d7a8e7d786bd9bf2f8519d69fd4f1ff1f65a5cabd64a37437ad304ced562c238c46fbdf2f646d00154bfc6f1c42b8b94e6bbc38cdeae5c3fd4de16a7e466de7898bc2fefa1919a3567eb6013c4ec97bf7b505a1ccfb8216ef478da14b6a8995b8fc3bce69df72c3a0199cb68be5d811c5df6599130d111b55983ba9c9706ccf58cbad24a5e886234c1f722ed52dc0c2198d944a596bd4c90d60ce726f57281d841c998bee996d37e14ce747815a0f56d0808b13af7d83d715d0ff31a261c736af64681c7863e4e43c78b3e9c75a722b1a69e59da1e0594ec5c0202a3f419b6d550df3c4d19fc0fad242d02e5b6fa9c20296076a9be0cc96c4951e30dff2d438adbec894f4a362735e01d17ea6f324ea0bef0f1c7d548a0e74ade12a7a72fdd24376b667eeed93e37eccfa28423d39d02b6b2d8b90efc86aa450f92b4b9245cbc9693ecbfc829fb6522d8ce6ddc5fbf213969ca8a5bc212aa433895cd9ddb877a29e7014049effc9b16208dbac683e2aff56282bc1d376ec4db2a83fd6258a55922d4df4e70661c9de658fd3ccdae5f41922f267851a1a48073003ed36f2746d92bf60f6865599e083968d667de5ba4986b7741e103ef78d74b69607b1628a074f8d7cc0843c84f33e40b03762153e2ce1dbf7f2874cd949107db93f3f5074ccfe3211851f21138b5f89c0f4853f17f4cc8f4714308089162fb92aa6e0adde7cab7a4ebf1432db76693f00386eff10ebf9063c019703e7c88c78765cff571f91699ca45ed0d963e1ae14d6f43faeaebd9fae07b6243308f6af32c51db57b679a5b7886f1c3c6c50d7ff31c2ca22453d88b53eef6ecd9987506527bb6e235dda6c5e724d50fd9ac9b43ebffc5d18dad9029965c915c49a2fd32b35d13c3ff4a496dc44edab1a1c20288c1abab3d2ac7877f5a5ba4ae6fa8855bf43562fdb2a7e67c52da41838d3ae607635c695a13533bb56c496f75deed37cf3b237a429ede0137aa6d4381a3f751103f4279abe2b656fd67bccf1f9ab1ae7ee6170bd605a19a6ef7e20b71e2764ab8f3c82cf5d5d10725b8f20eb87d264da9348ec9111baa3d6625f688bf815893534f9d110089d0a53903ea44482774a9c1a34300b94287316877b80911287597b3a6d80ac7a02df28c72a9ea1b3dcaa89c114e0ec928286b8692abf6140e2fb14aea037534e577612d92c39a74f6d1041a498d92a2de9d66063bf3e611a823c6169f2785856ecaeb0f25b2d82415fef43fbe87fd3133ad0d119454fbf3952e79ff3681898e4b2af837c3ce3fdbda6e2193f66622353899780dae60bbe43cfb0fab326d6c2375fdf654c1becf4cce8eb5f5a975bc2562bc2cc9072007782eff1131bebb7b55543f06233dbe6798c95a63412293edd788c8dd56b2d7ada1d1d6de7aa88b49d55d4651147d5fdd46188e11ac16729b973dffb82c610ffcc911e460277c7b6b55ab32da81d93129828381b3fd2dab51bfe346aa6fff89f612e67a0683d2d74ce1a1bd161943b2f52032be09101de997b030728f26f5b3764d03b023520fcda48127e4a2598176afd1954b841f878c74f02f550c027d55992b562b828a8ff220196c399b430fa27cb85b4bb9c2a788913cc0f1b881cc17682c3f71266ca1f098e1032adf12368500019c4dd7764a1d2e018fdd9f8f41091b5b282308ae750285593fb568ff89e9dbe8a2c124ff2102e5fbcdb4b22811cc53ecbc28516303447d10069337ee17bc2d4203e0b24e87d747dc86e3d16dc8bfd2ebd007f092bed8f14c7b4a0c1ed551d991fa9336219c3b1f8a474579e59deb21d0e257080633140233c6464a6b0400835209d71bcad5e840874981f74eaf27e777c89f1f9dd983f8124ac7a636bf866304632fc8db933ec2d9cccfcb184f6302aeb612fe8ba934a817ed41cbcbddb063cfa9f8ca5c6bf42e10a1592fbf48f11ce347e3554d01a5626c51e61801675afc27d61afe008cb40734707c7cfc463c4f3a07b7976cebb097c160499cf29f4a3c91e816637c44732b89edc1528f2d8d197dc9d290c832a1af7aa3d8bceda48284d01798dc6e9f5ae5124e0c14b78c379280b1950ba9b405ff4bd74530e40ee148800409c0e06c80f4f7499401ed9da899ce4070be8b757791e8e575eaacd98811d4c0c4dbb80c7adf2b5ebd9309faff258bef014e4ea4868b91ce36a00b42a5c40a85d91aacf9cc55fab51cf362f1c375fea5145b89f1943dbc0c4591c3f0077898516829c2b89cd5fe9e16ce95395f7905c8f840313543e6219249016199829765c4944e3a70b0fdd409937dae0e6bbcad4caa3d248897ca06beb0f75ca90fa17ffeda3e593c9f22a42af82c898da56cfeb8f21dea6a7017374c8b514bf570b45024334960a99354116162af2b721c75bf2eb16268988ab6ba673cafe956a4e74cc329f3a7aa7ce57d7ba28f2d0384bb38fe03e6bc60a28ad945e3c29180eedf3b48743d579b9ad09e9ddad01954eed805f273c80547c44f7330c25ddba0a08441351d85a40e472a8989a80c66bfca84d889995773a169b9266bd5df3ac154ae374ceee5cd9ab8bbad3b400352aa45999d4f788db57cac4a3582b62f77e7cb4756abdb9e3f921cc3ec457964aeda3c56b34714ed0c4ced8bd0b018c9e9e6edc3174f09e0cd2dc51fbc68136c80fa2a5193d9d3a340196cac72c13b622371ba6b73cebafb0c2651e9ee6dd9715cbb40dc48713ff968694158a281f3c623db6e925b27db49f5a8f01f78d3ab06d8a63be8b74e6bcd692ae3e98daaeb0ece96327e98113ebe529931c29f367a55a55a8bdb76a7b8c38aed6b33dd63a5ef7bac4bf6298da20fdbb1f7e0072ebdda83a35a3b3fbda926658169212d3df567901cd0e4ad848088a9617c1be244fa7ec3afd81d23ef641badb69fe393e23e96dd431e1a3044d56dda0996e9df2b01240926d752eaabc0279b4145fd45cc30365555b0db48467c815268312848b2fef34cc02c0fe3f65482794e4e7bca07e4150a10334221b1fa4ee9c6f03222ef90a3535bdcd7a1a1d45e66747f4c323cd245d6202da939a332e9cd5ce5b5518e4c41694a59290a3505c5f1d0bc77d80b3954637f935e2ff2acfd4e6b21a225b4d900bc6518ef6fcdcd1b8802378103a8d744ee91b1b5926806accdb6ac6c93730d35671ed2bc61e7cf91465a2aeae29bdbf9efc518eea4b3c3d51ec6de6b9e2a343d2487e3169ed73db859adad93e050fc2cc9de4e0dc3366d4842e2130154f9dab0bf4c6cdb083a1d08bd07ec31f36cd86f1f0f102a6af83f1f054c6a77fc17108ca508b1ef940d5b03abe80badd40385b0a109150181718907bf85cdc58af6b7d2ebc08a6de7682dc0d79bb74c66faa69508aaf1aa767dcf1b8430dbd7d2309b153245b9a67bdb0969fb7967a52433042821267817b57ec47d21a9a96a6b07a73a510dba4077d1dfaf5b9dccf84899095682122f1d4d47d55c3fea5b18983a0d252008acfac91ee2a828eb00f5f033b4221bc46b07ef2ae11a83e6ca7eec6846d82fe8f73a4a0167d61b6f2f761964ed5fc6dda4e734b8c17f5ececab3c27af2701c3fd68230736348336f27db862849e615fec5100361fd6203576a673c1e676839b01d4220d40d8d1ea41e4fff203a354c5048f3853e74ab690559d3473f0d5b45ca9c26b598de2bc3485533953d9a01654566659ba6f9afa10c893f86cc5ab3a7e82ecf2d060695d09b5bef73a270c611b1be53fbe4d4789ee04176492cc99cf9aae2d04f9e296d16a165721ff70217842459327e670df32fc0fa1cd9d7728495d44c94b14f003438291e134da3d46f1529e528b9f99c34a66815f64e22593048dcca8471a4effad2b3b79865feead7198bfed89b67b612c19738738cc390beec4bd265f856b22fb26331e89ae72bc271cdba7399ea601701fd1b1d8eb4d7766c3559d820bc1a18009dd4c56160702c70552ee0bb48bc50d77f91dddf639a13ac5ac5f134ff9e822b739db5256ea392e92690b30c4ab6be54f83677f1e408a2b09cfd6157b0089323527b875568bd4dca3688c229644fe3e5e46f6e08324f54565f125a0efdf814f82759e003ac65809c9d99474c211cf9e0ef56db4da79321cfa9c70af0068f3845980cde6b898161768030952e34a8ac0c0238a87e826d3bb4578622aafd59783cafc86b9e18de32a32672bbe513e9a2893cf02d5347d5fa00713c89cdac048b79b2ad2d1bff12c93033e85bbf2e293b758d4029699374477034fa0de90cd6a7571b7868ddd02dfc853dfab69a8f9999475d883e63896491111cc0999c945717cf789ad667344726c417e3f0736d99f44f5ac26c0c3577e011e096d2bd21b8162bdca08a07d1f8dc5ccda14a4a95d616d7c1ce1dbd4cb4c5fa6c92921d80b04cdc62376c1406460964c0433323289225504ad3c00730b2545a7ff96aba405360e5c27132f162fb4b9bb9637592fabb28d1754831a5b4c8d975458260a6c7ebdf80da281aad0366824545f8c5d462cca024f87d6572ed3d98822adc88b9be59106e9bee88dd6cf2cce972c4f030850e901c6650716dfa3de32c0cc93c0868a7fbf9a2f9c0c1829fff87ac223165241f0581acfbd2cec1a47fe2bf798877520568c216bc6c5e13207c8b85535852234b1a499a3b5c9957704c74ba791cc143699f0918eb3abc1247165c77621571127f34cd74f62c99b4027d7b0619d49f27ce54fb4ce7f796b46618dacb94d718f3667873010caa697687cd924529c82a1ad2223a444295aac1766e35e44d74196fe7cd0a4e023797535e1926cd4dcd73924c7488aca995bdb872e91e854944c202038d82f4e99a8558eb23779379e04d166ecdfe080f7e36517ef2c9ce541895b1eaa9b92760af0890a146d333a3dd8840c83849a1e4d29a7ae9c085cc50e5e19da41b52eb91f8267d0094834d2e3461fb9cb4bee28ef2e3ca005c9c37bb8b05ac5b744ee84f323e640d1e781055b291e217da5cc58f072b8b29e4f3bd60c55bd6262f5aa8402397544721ee8465acba9c78cf9b3abe4fa282234de579b03dd2e977eb3bd6045de3bb3f8c5cf5f0ff427cf3205f6e451c9fc1a6597e8de033c6154e02b2b5d18b292708ad1476a5559ba8d235a7abe3d1af523ec95725835b1114da484144d652eb817e71fb88cf753e3b9d7dbd3c1b3fbad7b2d34021e307e9c5426f67c0b3c70e962ed240543989525f165c7c8766a29a57abdfe4a1ee6b844f1f87047f5a260508f2dcb7d5f790eb254f57f5b65ead34096c318d94b28668ef2602851170ed7b848ef061c21ddadd02d210a9dc40ddeb4b51739ffc4db09c782ebec943ee07eb54c710a54f764cf212e2633f4a075fe7fc90ff84be4d5911f64db5bf96de511d7b095cee5c4b364c2286f1796fe86261f1a8390361faef2d21e23c6e1d1a14031ac3652609e61bc2a7929087d922755f5949fffa4641adbd551078206c85a94f1cc112ecbb4c231182f19c066c9737930028e4ebba8f9876162a4466e474427b1c4fd315d078331a796f09647e6e553527e24b2683670ef1bd69120fe07f3ec09d9c452b846c604bd3f4bd30f0b1aebbde1a73e2b32722e4a7da74c41caff918d2b25e92497cf38afb566f7f2499dd14506b9d9409233bfe0b3340d6f5a997223308eb3b4ce71190af0b0921b89208b8df8ce5fc1d301626f742ec38d57124eb9731775c3c2f86eacb1154bbd4a6e35d9cd6b69a55d3d1d47a7172a3776a068e37662ca195418e91737fe13f1a9acd36924991432cab534aaf043ebb3b8bd0fe9115f2448d0305bdec493e8390d6e6b7d53f038a559ea658f055faf852f7fc6c46d158c768e2dde06fed5e3f3a2784ba8be5f75529c1a84631fc909f2313f1f9452ead02ec94dbc8e1986a37750ddac50705df34497e60770eb25b5d12f82e3180f3879e7c25f2692f849a35f4725e400fc3754d370248b61355ff8dff379c6bc41eedefa255b60e6a66863659ab7b934b6e52bab828a185584e8ed502d3d20361c2645cce26abc6fb8913d047fa91734d4eaef944d8114310edce43b1ac16305e49c7daae4332154753385727598101df666ea6deca030e25761ca44b64410d9646975f489c2fa847d5923f3769d520d7e9e77740e8aa7dd1a6af4a34bc94ae1f5d3e289bba688300cf242e5ed78408c2f3da526b5a23de7699f9bd60d22ae6d955d422acde53943bf9a0c92ca05da94f2221bfa0227b8615b2f083bac1b669e07c1a90be8d52a503df96735f6b5e515e52b13ec848b28839149cd8f75bffcf37fc0ad9a4f488595882d671833346ee10ce7545916fe2264bad1c72bf2d4a4232ae13dd8d1e6b1391f7317363698437390146952f67e20b8a922a552c87ea77bde24f00f5dbd2c1744aaafb2f253663e0853fed7942bed2420f2697a01ba97411b1dd9c611f9812aa24444394ee929f7a8d06bc68cf1e53a00906006267fb83e56ed5ea06b15fc60306d292bf4a6782e7d1589d6db06fdf43ca0f811ac3274fd3c5b2c119f95028851fa714447641a7776e2fe0368965ee3f80bc0dba3e2478532fb17ca6154046d9dcd28c5f3cf6d98f72e0ad1fad4f960d7a32f3fda69b969ec6590d71d162260429325deb4252f25eefe5a8ed8c00c1d7f922246cd0d5dcb55b1e8cbef7a73643a902f4cd562acaff0a29c34b6659abd1459228676fa10c38f7a235f6b66cdaf93c99878d77a141cc309cad6c8e1c0bb85f772fc410423f1bfc30496838c4e76b8f9db2d60d5fd42c07d2304af718033821128890eae3a01283d3d62de53862c425d43693cfa6a9b2148d386a7082919553ed49845242e9b570f43db0324ffe345dc024c7caa7696b4abebda7d0fe9067568c7aa9d167d7fdcf4f3fd7c34cfd8b1aebca034572696fbb602de222b44cec636fd02acb5ae6695ebf207f33b17881d886548dc85adade59e825b4a72a8822a1e2d8d6c00789db9672a26c39a39bd430e7cfa178fe9237148072aff3bb5a313515217ad24a54562379b5c07fcd7003a1db6557e08f5fc49d2ac41868ce60e66eca0f326ff3b1d458b67004ca29cff2bd8736ed18321e78ae6309177d86765040b095f9603e42ba67f2b0a38e9dbbea935623c2649740f5e8e6492f8fd632eb9fc844f863819b3d5b94c7d7a463b40d4c0b6f598953ecec316de2e5978acc8e698ddee1cfd8cae2d7094795d34af7e902a0a496da74d249e1ba15ef2259f0309fbd44237d4c4fabc190fd25ac3096bac265a71c8f48511b20ffc88fd219f3d12edd99d2fe4ca798bc0293a6eb82c4c5f192f866c93e78a49d155e8eb6bf8b83aa57c5aa6c1569427bbadf0d8041546130e1ba54e04ecd00081bc93be457c61dd1645f435bd60f45a41196a922b6a0c54fd2ac6eb6011353885f7a1df834e32e3ff1644f347efbd9c0f3611db18888a1395e3207adcb8a44403165a7970842674048ecc22a0a1b479c1505952b04123b60351f070997c99f75e1e9880a3b27d62ed9854e67dc39ae692026956a7ecb6846e5631137cb1f1c1d9bd819134227c7648b6422d567b393ef618e0976302607e5a9f187790680c5bb53e1bc99370b1beeaf9f6caa911496a12ddbc580094dfadd29e08fe6dec3c9d382eea6a186f0ee55a40a8910c08dd84ff7ff165bc53ffdb4d0c6aa6c64f820dfde7695e9c62f5e8291e0f6f50113967f351729c8364e33060957d5419198d50a439cb7905625d01b6cc7922a5b79ceaeace1cf62c96c0e9687b2b9c0bc34f1e4de7e9216a542279663f6145a28134ffb6d93a2c8ddaf087647eaa3fd63795b655b22794dba2578a301e5dd5d69a4bcccf092ad975695fc8a0ccfc6c2a3db0ca5f5269e1f50fb78588d593f3cc2fbe45f263cc72f40511d046087127be06be3aa94c225c6d7cb1d48d6332b99c259ef8c7a1c897d6381856084435801d3522b748a88cad3705fd495e92768619ab2c92f1aed537e29a2c403216818970387e51230219e52648b131f63cd9a26a3d6632218bff43dcf7231493958420eac399ea2ada460ba731adcc7740f0f497be8a8e2fe581445958c5dac63ec5339039646a691b578ba730cc41867957e86414d1e29f8c79e911291329e2c0fde7111cc9d0f83b4f78f582215a009ed5dcd7caa56f43443c40ecc6edcc1d1d415dede9753e5b2b43b058e658941691b2cdf18e259fe758b4b4b71d8f58295a7641f88893d4dd1d5119420dbe85d9d8a21f160facf02716b11cba818cde6ca16611034f58bb4316273be262ad3abba0eb7ac054a8f16ac4ea25fc6f5a7a70821c7ef8cd1b294acc35c2ed0ac46c62b0bf2cc3b147bde48ae9688f288db268da8de76139bec74871e6ae4de89058d4cb8b34ead9d9b82454fdb4fc053cb9c8940b87b64e6b86b69df1c9140dfe697a4319d634f8e750874d37db87d9e00ec45a36d2a97986719b4281fb6a754e3565f16cd5c0703f136c90d602cd98c48b178584f3fc5b742d1ebc0b9e0c64c2f68dfb2561dd9cd61e60bfbb82891fa3795b646163f8cc9951121be4661377648fb65140cba8bed1f73aff86045526d0d79fcf35cc7833d4b2c0f3317d41c767d28fd1643787300e9376bda61daa7b4e00a0c3b0bbe9979ade81049878f6b1db006c491ef84bf3b942869f59059f257c10d437fb8594047a8fae5b96df10b7c9db1cb015316b73559bfa5aa98835209711441ad86caa4c3df9f94ddc07ea34e3df82aceef84f001d285b29d49599982eac2e242cf1e3327856a59d6c7caffcea27b17849265b24528357c7a43a7b39b3b075d733bc332f75c8edbd58e665c2809ea1235d1e6f9c1b96b9aaa5e15f86e9f605f8e4066bedced716f7b555dbd026ed98bbe4a5926edd4fdeaac687d6328807a1d969bca20703eaf2d21f38bd5dcdd77743a480adefdb2708883ddc3b0570c61600b86e804df771cb10be4c212c6a484b8e798d0a739cf0c856d7e24963ad443f33bced714c80653be9b340d13d3490031981d05995c06ae851b6b31871b6e65f233f1a1f6baff03e5be519e552e60329a4ea42963c08933a5fc860d80122f7fe49e02a58e612e25a6dfa5a3ca6286426d8f3bc14ee9395a51183c7efec873d118cb783656318a3feb50040d4867d36284bcc978a1297117119878fc67556dbdf306611e5a39b8bfcd44e200fa681edb93d81a75afb923f7dc5f12335337ebd92b77374bed567bffb13f788b4f9ee1527f953482f95428da6903bcabb19228436af47951ca391b9869e91aa10d3a52a058c40e2cc34bdf2d7dd703d9a943b84801644cb46e7550a2001732bc3dc7617f6cc8e5fd8076cbcc36a4b913a897cbbfb43a71032f4df1af270e8b809db9c197b377f58c7e8e5023b3b51c7a722b96861f053a21b7c9e61c921503ef1eeb2c00bc413523f5b493c38ce98e519ce7287d45991f3b41732b817e24228aabc9e0bcb7534ad0d677f45f4adaeadd7ed64e8d432419addc2059fde4dc9b77b0412a83819d6284454487d8136c3f6146380e41a1d32f2e5a4e95605c7e6844ecddd4948ef55237a23cd5eae4aeaa9ddbe9b944d7262ae80e952f3f318ade407f2dfffc6ff7df7f0ac3d7386a4c9ed60552f021a252a0463742f8a8ab1e5b2109c82ab4016eff2515d8b28ac145de744818ca55200976b2ef436b84a1cb8f48cc269ae7c24576c99d8da1a938a897585f168d3971627139addd84d1a096a9ca7aba7f1763514bbd4d3c1d71980eeca441c15bd781c78a04c591b8a1b7a6a0bd081d91722034f9ec1530afdaf71a96b8f33f7567e2e35d46a2941074f741961de93e6917d5fddd45c8095b7465eade0f209abe40d92719a02efdac2758bbe916e539164875dec384e4cacda12fb52caec2d1f4afc3a3e701c6cbe503c2f22d465b80cb34eb6959793db335999de08102b20b066d69e4e540b7c46e40a0d2efe74712d6c1fd98f298c56ebac1a0f41e8124be09e5b4d6f8de5e05b73ce4bdb3562aeff5364d77f51afce74a772f858ab0caf4bc6930b8445c2f5338692e7a549a4a744a6a35721f7fcd33bc79cfe6e6c25341efc01e8180312352a73bde29b2f430b1f39c596e7e00e433564fdc5d0d540594925a819b4a3a1cf53e7ad1eaff71fc572b36db6a3faa56988e74d7a4716d6acb690d31b35650cae8f03123df519ead4b8be8716f95d94690555c62bbeb962bcc1a25300ade679c757d1f50dcbc9080939ec2bc4d3688c69a54d0b1b71f65cd4af28b319722d89bef2b9cfcebd96eb833208fc83d5f318c31951169924c013d6bb0986adc9e6b083fc1e59c4b6551d12ed10f60fda8c710c10b8d78311952cf75e84dd52160c1d4a0fa6ce268430b7e8d34a49aa0798928d20a98ceecc9f52f6983e06c20f7faf9ed6f4b08789af4d5fdd0ebabe60d3a783e434c156bcc3bb487f850efe682d77f268a42ba4e6ce56b5df71f6658e0b0d88708586a91ccd838e2788665cf7a6ea0745a05f76cffa66edc4f98e2437b8c76bfa7faa275f74e08663ef8fddf98979f8f68fbf307979c880729d26a36895df304430cae46a31afcc1fb5bc403d4456068ce914730e856b7d209ebc9f51bdfd8b66f33be0c87624f0cfe3247fd8fa3810b9af845b4f41af9b3889e8f24aa5774c35455cb46b432b49eced7b58659714df7f2a8d6eb883111a1533eccc1f2644eaba0efcc306e80fb16691ebd5adf549b7114496c58a339e882ab00c07073100c440be56b0f2fc4dc63bb18107eccc0d29d310d7007dfdf7c73d472a0a0df04da32c63e059a499da2f8eefbc6ef47231707f851f28fe5573e0174f8117f2f24e4e9bd378f3d5fe6a248d33f3c5a5a46117be9fb040e262a91c951981b4422922d1c41f838fd0a2e259ae47c561d15a2a5e440ea0c4d32befe5f5506a68141eaa04b6d3db716e09b8e991b4ae9cd15d37387692d2e68d3caf52fd26fefb7d7f5f17a29887392a188fc726ff60aebd3e862240db719e8f9b3da9dacca16a901ac235469527b43b40cd58d9ca619cb3804a5b530448d77595d202443c31b714b8839d959d8076ebd5ff56c3bed52354272d1f2be9c681635edf7cba646a019324d15af8e110d1f365ebebf81247a89c488bfb0e2c1e0f299fe2f9f41dffec602614412fa2eb45a8504e27ba1d27b77acadf548247e361674512bc4ba6dc70dcd234c64a5f283e0cce620d6596f5e9e0d11486ca8b4640f045091072e748fa898840b9471753c8d374ff2b1cf2d24fb7f0ae171dff449f40bdc7d20301f76fff42ca6a364c23b13117cf42a03a45f7b4ff33f274468c2477cf9f58d7770328e52f1e212dfade657f23ba6f1dbee5bb7e43aed97660bd174d4f8eb3eef1ff8dbbf39e54e5edbe4104a42949f7d4eede320cf66550f3f98b0ec796025f0a66b4a446456e6332e35c098bd1b6403f834f355180b4c52a204fc7356f0ad0d8ad7f4b45cdc0fc21fac2d25e5bee3d5daa7ba716c097565a4e977166f8a2092e5365a870c8aabd59db43c19b8b1316f414f6800b4fd4c9b2931124fb084f99b4308b223c9ad4b269acfc7118008e8119bc1eef109aaf9661e729a46e62c32f4e5da74bcbbc58abccfd6e713c3eb39318411a862a3007bd338c08d118aa465d3817aae446c75e84de0ddc663e2ad985bb5c17ff8325f611f340ff77798a376b3d9e5ed058e00c266e7f5f76c2b6c4fcfb2c86038b67170d12416a3deaaa281ac42ec1f533d9e32d3906267b597eaba5e775a63fb7740a4cc86bc20cf3bb2e2a7c3b24beb20d0a941f6f5260c9ce98638044ab45e0bada4369502a1273a7ec63f287cc3f3e14649e93d1c2ccbe4db359d1f4871872789c47aae49a77c3eb4edacaaf05cae38efbc76339760cdfa4b791e7af2e4d73bc810b6266a1848c8be692d57b832e90b76951b6596c3c46bb4ccd5497d485f884eed05fb872b8c44a902634fda0fa82ac77319cd1fb3fba49afa446027b8918fabbe587940e5c0a5288348a1d27686357f60453fd8cd8e63ef2ac5b1f08a3931bd82837e9059f9cf0e1430c8d5f11c281c4aa367883908e1ef55d07dcb00b55a0032f78c6211a525f966f18653852006d0c65072634bd83bc0e2cf4e589d7180108431ddcc3a27fb80c83fd7a412c7b4537201ac5f74ccf7d62ba8bc35c721775ca16f913b9ddc63742bd0a41b2af34e5364b62b92b75e29e9398ac6c295177d5d5d10f8423a158169d60c7ed5b82e8ade4e7839bcbb1ab4736cb88cfef920e293f9ba26cfee9e4b97fd3d1274719db906f2e3657027d5d8d351e4643e9553ddf32aa2e2fa0cca3938a9f452bcb4b03fd645ce13a7e61e2dd97117733a9b6fd3059decb8a24af91c8dd7036d380d92092df2ae3b6999de90a2432dd2db5e85b571939e68175751c13428d5916f86310f7aea58efaef6dc4af313920d967f9fc06436589d45ecd023d7a9d44106a626f13d177b0cad77996b91abf64bf332f0bc5832831c8e1e8d91fcd47597d5acf3de459d66773dee1ed5c5fb2207b1f858d15aab9b6235199bd1ae6b109f70276314814a8569e8fb52a80aa418f3c5757b612ffad6c7164d58be7de8866d6516afc49435faa63e9d48cd45bde83d4cb065429609831ec8ab5943e345f882988018b7ae2ab35bd1a29af51a773bd74d19e6fd096df5f0db3339840527cf793d3c403841bcaff4369b0aeb1e327af89819e02c4849058ae079364a74d6b2f204a56d2d11050061e31f45306096433b774f4cc0ea1fe753b4c51b6a7b790184f7e14e746667fe87a4de385068742149f7ef5fd6a2150dbd4d9ab7049952f682a78c2ba629ac74cc21fff4315c11cddd04bc32bf7ff174f4dd3520d13e12e24ee54a0ebdbf62679d2f689bc07a36faf2718c2fb47d519ed1ed18a9819afac33412616f27b8a5ec5e3d1c8d5a4d6bf43d9de9122f3ba8ec4fc3ff7daeb2b39c15a7ab6de87dbc97313c8118e3a0a8ed4b415a53895e7f41fc5c1ec72fee8cc0f3ff3eb49ccd83f998d541fc6938ff937cfc6c9ffa57a1dc0e8bc280970a512e194a6a5f3fd9c6d376ce538eb6b1495c220ec40058d6657629241fffa8c7f171b4a971e31527c26f9c22a2065b016aa3329e8800569619744d1d85f515ddc7dcdd8b2f562f33361f3a37221adce139ecc7b3ee2e89640f5e4f21837091484d84009e822f3591c81dc456e956d64e0a1ddb3ba05db588fa6923a85877d32281a459737ed6d8c3ed7d21eab1ed1706fa2734366a86c48b170fa48fdf737542eb3d95e251ee65a5483f6080bd44fe781ba9f59314d2c6ceb59f91a23c91a252fc551647f0e3ba6960ceed8a5209f12fd7e62c336fd7d8993f88ec2c2f6e7478be2aec5ee750304362069807fce7e11fff356ef86aa32e41fb08651775c91d6faea639ddabf61b492de8b41d20da695de6bd353db3417dd5bff773648ba30042cce5ba5bc38ba04e762b55afd836329d824c19dc410509d42c444136bab26d7d23d7480728edbcc87cb031ca3685a1cf5929c3c946563b850812989e8540386a4defe5bce69a16439949ab9424d402b381ed60d5032a8434665d78acdf8fe45dfd812844c853f66043016c3b269c970d515187f6e651cdd91d4d24ae021f5bcb185a48221d04421a8a3dd5f43f47c89702bd86480fd47f469ba98ac97aadf86af9dbcbea5512366d2038358053492b33e1e0b56b49fc46ff206d43930623e33e6fea8012d43ae1c57709aed75f1a503842460b923c80fc3e2942fdeebe146885f5666dace42a466cb09e76974ddbd778a97b758dda483ab9dc83b61dbaf03c26abeaf1cf1b518cc42175410cedc204a82eaba611157cea480ce28652c21e245e0f303d29602d7846ba55cef5de093b07486bbadb0ef5749e346cfc345a8b1c8fd5d7b745433ad6da8693bd02e00b2c24a6cf44ff24500ca2b4ee58b7afc0ba4880c4b14f04fe91b0f1c3d57e4410de5272cf5c58f6362476a3e2b389c27c0db9dd0a17821c8be0fc02df892449d87558a9b7ac14a8e96e1660c3157ddf130921a5e4a63681dfaf46329a298e97aa6cb762416e4d97648e2920a281277e654596e87fab0b570183f6dae332ac2fdf9fcbe074902de30d30963f831d60882457925dd9b80bb4ea39cccdf33e7c286a20d17cef86bcb673dd30b49b293c5583a4b18767f1f0338b4dc98d2d4ba1877408270945a8f18c14c9b934d780cd68d9b18d16054ec2b2d3ee30b4db90e2e1cf515d4c20d0434b06879d11ca408cdee8a7e463491d085036867cfe9bd3be96029efb1bc74915f260eb7069582e8f920e38cfc1b718bb2f777ad495133c92fd1e066dc01ace65fb071d5222ad11ca33b987e8941f9217b8e712828f5ed51f612f67343544697ec69ea0cbc292aa4c72b623b07e9f76e9c11464dd1f674cb1aa20982b3e0653f2d1d573254341d23a35ded985702632b6e2b3f989c8279e13c46bd7f437450229161b76a81c14c408e0fd910055ecc16f83eb1cb0e44712f067a0bd34b8afb1237b7da353e5b98067284bbb0f67edc892aacbe7dda79d716c55242e04ec82dceaecc20afc6fc5683b0e9be85fbfa27473fa3b16de64d369693e73ce37700c99943de91f1a02c330a3f0e1d210b6dc1ce0d90f8e2ce623d6a7958e0f271d59f1b622399bc64b932805eb5c56a3e4d822d1b7966d2f51d6986cc3716d1dd129dd1b0a5c97f8d7ec939228cd5aac969a80af11704951c5e4ef661463aaede7606aa8b440994b0ed3930d39fe6b989a14645e8eacb8b313e15939d1605bdeb6f88761db9fc3f3a528e1743544dc81c1b9b3f32804ae243f1be7567d459a4b2cec680da2628e8276178febf609d2f3c9c5a216a5b77a281223c27e5597959c780e151d038170ddc711f031b8f6505d2c79f7b4b79eca02436e702f1591e81dc17ff2b57061727504e340cf72aa71a50a1c4a443b4cd9e1be1fcf46fef45cea7b2c63ff5f2cfe79988bb9cf6375fff4af77da0459a7e01e3b64df130de442b1f0354461905a363d2966f5c7e47044a286d47344e222c1e306a96d82a9fb12f04e9618814f45c99afa2a4a27f3d4544c23312a094dc1833fde781f5fe1626d07ba9bce8cc3992d9266a6037bb4f4c0188370378cbef498a8a8a1fb57228b3259b59d3df78e3255e03792dff0cdb2166e90ba944dba77e1d996499a8b6c1de578a49373da2eba4ac236203dc22b106543c071632987bb0a74f94a2a58b150db98739570541f8b6b76240f02ba244b1846e62801aa62f7de27cbcbc66553efc1aa7fb0e6b3c9c483f92c7bb99deea2a296a7b78b0bb96365fb1b35a47463599a08c0c2555f0a3d368a45ffb512689955cb222d60b1d423b2d4dcd3717e181fb27e96fa9ac12ac45259acaf2470c1cfe68a4d57a8dc585eb0a450148967166dd4daa8508fa2e666e192cd86950044007242003dedda876be868c80a73c8ee8beb8752b1ec67795d0f6e2f337b77c5788012d29e05d916f14d267cae39b987bab694fb802517140ed101dfd764684606f96fe4d3baf44e57a5cf0860eaf095c87e297afff950916378f65ed73011c399d66a8609dff7780121f45eb4b815a045b33be2a99bcbd125382a6cbc34de409dda6d84bb9765f20ae77eff9c273f4fc48f80b15bc3f543e1978d2f8bf8dc6d3e781eb4ea7dd158b48eec2fcd81873210687d7390de84252546ec7a9a628c81a1dbf2e5adf7fdfd294b1a1b664df27681850f968af782c0a16b8770d1f6788fad7b19a1914742acd49a17ba35d1897394fbfd3fb7e62fe6bf26291d0b02afa8a4a185ff88981ff663f35309b049830cbd530e4141f65098aebd5934e5b50273c245d92a2de49af6650607090e5a6264dec57592b57c9b1875019d9680d8b9fc16254763bc600e44a98a993152376c05eb46f3b2cf2374897705278169065e948d5d840ed9d91510ae18c2637b995fd22400c6aa23e3e32432c2f10446f1d92a3f9e289f0011bf406186d1aad8bb9b189b2284e7664c4303f5fc0d4f256a2a8677ce1243ada1d9de3d8a1d694c7478d7ff506dffa6d3a7bf46881777341d8a278a000b5af5b065a10dadae9d31acd436d91fb09a3fdb370355d7ed841c6ca1ceb44682676816c0226bc6dae82bd31098efd53f35e1ebce5bea9b50b2c93874c845030d4fbab5670ace6914a07616bc44f71130795d267d2b03eefcdc703f80080b5d25b70531814963bcd9e681f538737479cfab25b139aa566c5a7db421bc067dae537744459eec6cec056e78c874fdb34e8d7d4acbc428fc07983d33407df647ce30634f2cdfe99227aaecad2df2ad17d765c36510955de3ad63ace5a40b1b94ed68f4cb340b83d90542d607def729cfd4e9a681a0667cc195e68ccfd6950fc4feb56cc0f6690d8dc4557bc958e072cc8b714ec53ab40df4cf66600309903219060","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
