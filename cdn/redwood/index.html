<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7d166270ce507bc1c56a11dcd152f4cb508453a2eba2953ad0c2d4d0a4d686783a3fabd6cbb0ea86af193bda40e802f795f16a6567e3eb73e32659d3986c73b5de936e8a3085527ff99303ddcbc5262b7827ab99babfd7332f7c3cb5ed9184a0899f13ee02eb2f4a3de2c16eb67efa6596dfe8fdcd505358c5c65df58ded69349492c02493b3593b81fa3517a0404bda634fcef9b1f992c9b806d29d55ff74a0d4a505690c26d3b580d825dd9f261fff6def5bfba565366dd652815d359b58c4badab20c796cebd8aebee1699411652086a92e0cac67d19a200b095fea1f078cd6ab4531ba62518fe373a57f4dfdd165c7c99af657d25fd3e222dec4565108f21d7971b7bc22efe3d33349e553f54e78373377998975ef148538788fc65ccb731a3ad8f54dc4ff4d363056eefb64413007e5a8dfaebdc5fb918f26440033d50f024f70207ef437b2cd587c07df2f844a74f6c95ecdd6fe3b9b3aa7aa3757484bfb067d3ff78ed129b309f62560b6ba10a127c2b318ca38c7c561c9942ac873e8eaf64aeb8f5a140d5721db3d6df813c9fe4aceb96ba386d9b22667b9996678ff6354ce781799c045a8759a0a9f7b7bdc6a416044ec8f286cbf108738b8ee4c59816358a463ce991f8b26b388f2120f3c6d1afc580603e92f37a8376c038afa4b17d38e1e967b3d011ed2baf7b06bfdcc5e5661a107da76a8eebf267d7f9ed6085b011c00b6f2e7bc5495ffa6fc45bf6a321866af79fda09babae4decbb367f21abad4caf61ea80d148df614386ac0db173295d6d314a3e8db089209161675a14ffd8ce0fa1df7d6170f998ce2d78b981a7a9dc20b69363b0512a865ce0bcf7c0cf671f79a797c65df99a5667cb95a002c750c63673496dc7de275be862375beafcbb26453270b2edd8dcfcc4d76a0100063221f1a87714f0e078838bf55dc32893cc04310a91ac7ac946055e9eda838dde4d4e3966b0390a20f4fbb4e46f1e1534d764463ab22a91fac0476e316a7f6ad67c734ed8aec9199ca12e388d81a4690404fca777deed622bf750b50e9c21bb67f75696eee7ba4c3818cd9fc6895e57333acf471d4d3054412451400f90eea69fdc45888a99e5825b5ab096686c773b63a88f1c8c0ef3a84966723f3e28bd94f209bf2188317049622d31af45366df6dcefbfeca33b118119697ccf811533f770a93f79db064c531191c0052757049262b4223b287eea405dcc20d19dd750324ec22ae86e474e3fcb8c83b821f28feb578f6511a1c5b078ca12780a8ce7186fe11f206244e10b445b37faacf21773d3cf982b8e7f9c37bfc914d1dc71d00ecb7964fcf61f8021dbf66eac60cb335530619350c74a9b20726e593a29826b01d1ce665e9540170ce03e4a379c7cb7d9ac36d82c9027909ee782399f87d470bb886680c82bc70ec088a206c1e6e164048deb33d04d33e1d2482f2bb118e8222522e6ff657ba7dbe6c737e240d74a2264f0f85f25977fb22a3f87505843ddbc6d993c90d97bab2098ea77722646aac6c5aab30de627f7e9f14bc15ce97a020c46b0f9f73a660612cb2e23c4e3cb216a47279a89f65e2f2047df3707847f68d942e7a51155d99ef863c1950728e3f1a2eb0ddb9a5585079e0bd33613d69b36dbb83ae29ea798dd3a02835c9d4dc27a34c1b94a5ccadd8c64c047925e2c5d897b9ff72ac7da2702c227ff3fe17dbe2e58239e8064d893b75da697ffae5d4b9985866ae2e0abbfc65b5be37fddf65b81229c485a70c56415bf4f427b1ca052ce7144d214ff8d0ece95a2d3af10754e795738258563c7ca00f1b8f2708fde16e76a4cf04924b3285d529e77ea0985f4a01b9b2f1ef65a5bdc17d582c0464d99765694e0006cd9061f8b5f83c74519a79a7ebb5c5343fe81ffebc18d93698736642d2bbcacf3d919fb8e6f570f1c686285d412feae8bc8f18d9feb7ee195b8196981daf9cd5185d6a99ec73b34dc81e212bf688b6f1941df1dd954f0144c894229e9fa473630e97dced16d5d207ad822cbd497ec46159e9cb185c5d2954f62f438c779b072cb819e3029025a1cdd4ea8bdea4767056147d2a2e05b684e4bb7d486e7e510d13de96b7354fb31ac05b1471096f4f8613d6c4c8669013704a21fed3a2a55f27b38d7b8ed627160a35a195d4722cda88ba4cc350900854cc401596c22740449c9692982ac079d40cd7c1ca4eaf8eedc16b917d0482ecdaa39c6ce3ad62cf9e127b5d7b788d49cf6a1e67f6fa98829d7e06439dcc40f4d2c32c1ba99b3f5581057e036f2557aa6f597f54cb17af13583515bc77f814cd120e9f6c8cc50b72050bc9d202f41747a6937b0507e3fe7134a7cbb3192adc84ead0da2d99fd8306ed925c1a5583140ad11180e5b42e99f66a3d94b01e2cecb17e5bfe9cff6531484a805d292af4cd8d0e4e17d5a36764132e688bea1d9204a55d36a43c18bba4d6dd963327502d0c1c845e1bc48a9e8a71f9c987b218147c88418ba3b616f9f552a2c561cd63cc60e3a23e29e3af98409e43d07ac84ebccf2aa94cb0cb2b02ee1f46e6ead579a2dbb9def9cf12a1ed8739e1b947469752bc1287749cbd3ab85d2a1f2d077173fb5bd4a0758c118816ee578a0fd2dc4674cdf14e66a4797cb6493981447b1a832af5c9ef9023c402a9e285a7e406681c5eb1f2646f8ff97076867fcedb9449d1c9f6061e66faebf45ecec6bc29f6a25eb348e0ee79dfae6978582bfeadd76c6b5437654f4b5dbd42d2f338c2785fea72a43b03acf247643760961bc39fdce8cfdb1b07c3bf514be132f81d6312e997487ec2ed5d37e564dc3ff493e6525aaa9437d2931be175a593d4a19aeb6af8f277304da8d801a8f356b10b9397366a959bbed9497a71591a6ae7c4570509ad0798b771158f2a95380b2adb48b6d0c681a7d773438d0799029c7dee7f45415e2c08436c30af319699ab88ddb9221289440aa7f81616adccc0443d3f1f19164fcb14df0455243f56e6fba0a48e02126beace4739b6e589b4240558ac0b4b875e3396fded2815ce6eda1b848453e3b08a8193682a60cc1e8b97eed171e63da9613293f600f7537d925d407c4dc038a8388f1b90d94722732128e299bc2c7f4afa31cf6c45758b4defb11230a659651f4d7ccb825e01669c03991d38c4c438a596a407738c4c5f267b58f4d192252ed08c7570ff67b9ed4cc33ea27d61b3dfdb55c2a1c6216f669243dbf0ba7e912ed54347faf3a1af9876b9b4290ed913ce5e6b7876785a565af11260c4dbc4b81d41de6e907928c8c8aa40b352168f4ddb374372a70af417d1d91f8926379e49df12a31174a6052dace377aaba2e2eff0279bb30dec311cb7c04852165cc17df9ae0cc32285552101b2e670ec74396ea345537bda9c2867137d465d351245d56063c3b18c1c2522b936289c05c00431e436bb5d811de1ccdd37d3d581947a309a2077919d35440fd633bd70d6cf1cf9d7ee1871e3baeac18e70eee9b4e0870ad6c0253c304b6253abf9f814a1d9cfae1e313cfcdbe56fa8d10934098a524eb27b25427b7f5b8a887a93d1e9754400b24f0b32b1ac9b75ccc76bf16ca2e8255f193a6b3e8bebbb468432cb797f0b010335e98d42d19aed04867445e0fce239ce2180b766eb1031c2cb4392e989644d24334ad7c753e8fd95dfb8e94b490ca3444009874d563fc618d6df69ca533b16f3f0cc38b7fb2547db4880067a230286d2ba40632b33ac8f259306c501d966b67213ebb28aa7bb4aa05695358fb727f4cbfae83145459ccce483aa5a669c06700358a7a2ee1146b5a8121f2ea7490cd8d30b6749ea6ecdbe63e078b44d3ad6dfd2380caead002d0f9e2d53bd279ee9d67e8c6e67beaa97917fdf287f571763f5466931a7d903ab5bfe2637643628ae682bb8928a299534663a03c487c3d4f31ba660a3eeb86c007b8750e2e834bec1b8a2c3a370afa675fc11a0aa37c5d27528349c697d737093a49c56f8bea09553b151b869979e6ecac392fe1676da1293a4d7ebf5af7b0d6b8d94c14dd1af81be0b860bd08f95d2b53ba97adac21c08d4f37cd68bf74da7e5ee3e06851a909242e0e99f3a5a219109428cb7effcb2574b4353712fe52d7926000dedffd4f2bf78c47f2e5b0ce5d912e99d60186d54cb615123cd2d9bad47c2d46a9281c4d05fccc49f03f1cd6c16ad8ff8e5841e4332890720bfb2f9e46b9c0ebc8a5f0ab3e12032ffeda2a8320be3f077a2c5fd46705ebc9716fe48496ca4b2a460fea2a556d11afad2368da4b829ecb81ad710f73993c0c8a81f2ae6d810b96ba34c149bfb61bd580ad569b2640b45827053dfcee1711d429074c9a98a46cc9e36bc83836021ad5d5e515c304af9642c304150858c69a65fbd2969a13a4056160484e85fe523c6759b17f2151fa7c91f3f763f4c5b584017fbd0fbb73a48fa728e56e518aa4681bf27ad88b1658036163c520f98a68027365ca21682ceded6ace5a1a57b21668e16ba3d3fba23e3aea89cb55f9d967581d75bdb9a30f1f0b0e03e70b8d86dafd53a03d8d95a4511b46c8e76709dc7b6bff61f7bfebf0190d9ca354620f801838ee43aba478320a8db28df602baa7e47a991d4d5d93f33595e227eabbc66f142c23a85a33c58aced4c42f55c56717b81d7497c15954e3002e9b53e904f01097d3a1907c62b8d6434475dd45fe159cc75462a6dd5c5e3b6a606543432e40167c547808ce935c0d7338202c30bcec1de8fa08ef6c489a1b39403a9f63497490ed7b9fc1b497ce966732c87d7db24279285a7b410ba7ee56ec4b1c1a02ab6829503e3da4a1da6b7a00f94fef07c41e3b09e290269dbb7356b14c7c0793c1126663c8c13cbbb959539a9a94c49d2edf7588ca47aeaddc4d4dcf9d41e83f9eaa6acf6d488763c938b0d5a56391c6922f381cffbc23bae44117874f14e2c1b5340ee049b94f24076539a2f31c1cd052064e2c7d47af6a7fe6c2a64c1ff21188b5f6f168d596788ab0db7ce3b1c219ac16c8528961afe47dbf39e0b151cdb66374b071a835285eb34c6b960af09661ada4730ae00197b9ea7d6678e4542ed50b717325eae6d7fb8a6c2c954f5b2f2603e080e602bc437e1f9a597b72a3f6ad60bd8fa7c42630f018ba7e3ca71a7f4e9c4bf901f422583930e26419eeabb2a9e7929a166a1ec7e6df14b0f5e6ff8001181574997c6cff71e4f8163f7e490a50ec1c4c2358af9107ea324bf4ba6e5427f2854e30de35f0288a9d2811576ddfad123f01474286ef9ec1000aa84a36095b9d8984f0fd8de12c4ab7b5e2f6958aec4ce93f27db2821119bd1bbfd499aef1774b68b6a52e21dd10a2bc3ed8f307b858ef1e0b6b68415a2bd14e839396b956063e21fc7a073947a27758dfee664061df4b7b99d066e5b70ce696c757822773d99446af347cf5e2b6455439713c9f40d40bbd3d1e5a60012752228550ca93636500321deb1a73f815165ac8f28292b911c13f9db370092263fee8020c9a2e205c5a747bd6fa2e324fcfe2765e38510b96c94d04d8402ad172c1f2106e35614defc79f9eb9673de1a3528b6d833de7d5460bac8de2bfda660455e83789ed99c6698449dcb3133a524deab1edafe9c1d3f372859bcfc8c0ccc11b4c454a1160ec99320e1823da351b8b8216119e71a4cc68851076ab87d79b7e18a0bfa0ade80207f01b0767ac41b816ffbe7d3452f9db4f659b13b916306b501e1fe3ab270a51e75d389ac2b886cf958ee11e82cda9b7870f961cdcfe9b2943881294d94b2310d63614f5129ecf216d31a465ebb2b92c21431a75e63c554d294b6d7f0aad0235732ed8b11b4ecc8d65f7c06cb80208e16469adce4d59bbc7d08dbe355c9eec9d8e71ba3e9bdfa4644335ccdb5e6ba16856bb8d1f3ba659221f4e66b4552f356df736da10dd0592b4b776af6957d197540f7a0eb456702b21fb401faa4fa41609dce1c67db600413390b8cd249cba2834718755596c30ce5999b883b359c606eaeef680f754d219fffa2e9f3454f817700eaacb6a1eef141c6389bfd5167d2ae8d230c254e3daed22c9f28d7a55adddc410beab56f475af666dce6b1e899cfc2a532ff3483ca744e9060b8d2e453c591f1074475663855edbaa5e0f706eceb3d357203bfebb944eff971a49f7ead3d565d41528f07263e49362d189a4a6472dd73deecce5cfddc337336b1fc4a7d2970cf3c487531619e2a4b4bd425d115b53ebe5dde69f9ccd8ab3ae2c7a2013c6b56ce4c51e0f55de2ee1dd83f35e8ded387de1b8a9629359daf27a42795b4cb51d70b1ec3056401954659668f5098b26be19fd03ddf98db73e42b69048348c6f8ca239f89693d60b05741db339c6505ce7c8920131920e3202177d3a4b406450d287fc413fa25e55785bfa16a8e3967b72adfb4624b163f50c86e7ab277b61353f0f67ff88f8ac26e73e76ced314b692277c2527e6ca50e91642cc415c591f8a4eebd8187f2f76ad2aad7fc5502ad965d3940db6be7afa4024860f109882d609a60c582872112b1c59ea28d761fe7d31dee1bf12fd9c2a129ea1dcb73b017354cd2ef1aa4c08d8ff2b2e7105605b508f92af77d1c105ad9082dfc671a5bd9895c5240668691ca69e2fe88b5d7c1d85b916edce4c725f530180a86735e1924c50a6baaec05213a99194dc6c5f8088423c591de09a10cb2074979ed95de51a9e1dc785d83ad7821d2a2e3e672983415af4c105cc1c517bc069e716a28ca0d90e239c521b7a1d3c9971781802651c82fc33ace4dd125abecfe5147648bd79d135ae8ab4cb3d7c427d57c973cfc7e82bc7515bf96384027d522cbd4ee4c43e13078c5077eb0e1b3c7506c1afb97667ff73b5a34137c377c6b9cbdf4483b719446e2cebe9c9fc208a59647f80447ea2e14c5310fb60541c05710be256198d522abe17412de116ba398199d8400ef81199ef4d6ddab7ed337de2895e8fab40cd5e4906831296fefde6ae8ab913c84fde022391d58da36d4d39415e6be674784772bdebc981150733bf2f178df7b2e2bd3e85ca9fec8cdf967f1e6d2cb909f82beb827e60527c65eafe8aae09a12ba36b94022653aaead66700f010f4826d8a7a84f33dce2ff6f9043d164778e6aff32c15eeb642c9baf677b3c8aa39f12b703600c1c390682be6350db9779498a23350c731f98517d898cc3dd2ad396993515cdca7a9be10374de4ee820c5fb32c73e1d1e75b728e4033724119b22ef1ae12a129b8f644af1fe01ce5e572912fae978bd4e25d36ead6221d1ac4589a5fc358d95776504ecf32daf871ecfd1a426ac9c2e1e0498a65f785c38fb9c1513976937797924d2bcde35732627ff976bdfb9ac5a63f3a611fb53edce24798cda654d73c8ec57c5ddf7811c7e8204cce94baff30fc88733a42e90fd7202c1bc68f0fb8301e5dadf5db09d2736d0d6828601e9838c46b8b8c487ceae992ccda3a729588a63a2d519de7f2823b533fb30f5e75245adb545fa0537f0c6a9f7a8c7444f5907848cbe5496c366edebb7e17a955786bdb578fff9a7074a156e7680a86c54fe596cc57d95ffc99e821f08790a7136f20f24625fc873670d8177bd600b8079388f1d179123627bd7a71b4e0c8ab2a8a152a7819309a372417dede8c2d964f6da91848b992cbd437d7222327d90861f1bf7f84eb7838f09c4265376bb7ec10680cecdfd74ce39e14a3bee36e14d111d05dd87f404dd1419744ed26ad1b5fed11b8f68212dcc746d2b2dd49144992a6fa3dcaf16812da49f58a7051be5f478d09dfa6d76fb8bd41b6de95667a4fdf3f6011f9383f9b34591c4e6221c542ddff5601491bd6c7080b32abe00d8be1fddbb1e95ecd7706266cc82e7c1ba00d24d5d382b4d194f10a6ba5e625bc01839a4463db6276ea72c99914c2c4aeb5b2edc8a42ce8b14a2e8df9456a69109ed048cd41585717420e1f6cc958bdabefc407f298f32f2d669c59cc247f27196d9bb105d07a963aa91ab10c7c90db4f3e14837fd25165e0b38e6d8e5b886fbcafe8a042f7fa3810af9b94c5ce4dc91685fd12d552fb2e3d7a7b89c71d8e3f6b0413eb4068878d78439e319ad9a67d571055973d9a6b233430fc32a354e311b5f09586485504f778faa9623075b9ab460270d9260d799f1497fa4b1a84f52288e2045719f2664ee793a7d5f2f268821132cfeda4e7ce006b30a6f95a5ffa6fe479dce25ca1ad3983f229993ef7f89ee6f9dbdbd66856ac6d774d186eab2cebec6ed5884ed3fed6df4c22d225f9b7964fafd6a2200fa05118570e7adc84911165ca3511e5064c4a298539427a27589814ca79ac8c8073d980b81cb47be3851740018f7e0e3de573404ff81b13ffd0b703a5ab09e74b637416ad0aca99a1ea304af626a897cb8e9617fed3191440f6c6587b40ed1dfa85437ab3fc3e976ef113ae2a5c18b4d1521162d8be5200f087b921cfbf9c0df3c3f0e11d7ee0ed7a15cfdbafcc9305cf1f48183de714397b7c15e3d5997a7d365cc8807b416a8bb6ccaf1695e8ff84783037be4698287bec611f8fed402067fb9ba03814d368b2cd7b29236a658152a48e174669aecc46df3689b166f93a0dc84f5694af684ca887f7c0c1e061e23984dbe95d7f213348660dad81e59a44b068ff8f02934c5379ae98180c4ae0b4eb6dcd8e9ddeba7479482785d6a2ceeff8e3dd39a9d716b97276842bc06b84c373ba98be81ec5ac596e5851270f4d73e49dfc4565d60146d1ef82254dac0d335c350bb6ddcfbd9f8cc6a623dd705d09e64db4e9a2f1482662b9b7ea35901e305b828e0324c59e1be18b5519fadc97328394d63f9c276e9f0b9306a3e58a0698cbde298fae3be1e7c7e5be720c949344ab471d54ed36c788e5078ac330e2b9f4d195e23752984d376574effb9dfabbafdfe3eafa66342120e8e663883e819a7fe37730f7a685340280ebe9aa89734da4c980ca2b7f4d6251653a766afc6b4cf81c4dcf52747ba1669c9ccfc478f45002f9a6d4280212cf033ec8caab333305fe7def7d0324bacbe6874bb340e4a69c91ea2a5bec7f37738df44d82ae9862b433946f88c78557953fd8db3842d5cebaf311d2c83b8a5d3489e9e64a45c02d0963c7d7d9b40a96710efb537729416f2246a4fd7386cfe19c49b727ec93871f7d40ea6bd8940ecd0b0e8096321854b690a16a8b48cdde7fbbc2df09d4eab0b7bbbd379baf5c8fc809e4be4c5555a813f5f15ad05892c4a0b4654f5d4e28170f6da3ca868d670c10cd24c104f720ea6299dd62dfeadbf0f91f7961a0d5c4a23db1c6f8aa02a12ea22a785b4972c319736c8660d5573951bebc5e5943c196ef362f45475d91e2b554eebdf3a2ae0a79a6ffbf4cec575f31358cd019f998c4a88ac520e188705c4aa2c3e29f5ffd66018ef74eb6774e6898b0abd735377e52783dc20edd9a49970e6c079b1aeff7b2c39ccb759904cabdfdc090a4a9991d0f65c5b42b3c33899abc6308848e82ec1db8fff7e364868d22def0c46f6281f73be6b04a92d5ecad6e7df26160441a77490d75633dcdfc216c649fca016300f985d97941f6cfff096e94a8d4df1d9e1490fcfbd5c6e569e65a99ba4e3b43d4b4fbfc2c6ff609c5bdde4e01c355d5b63d4219b3c109e2f9881a42f31525ec5dcec43696d2839b79d9e6051547ebf68dd2f9c958f2ec07aec2113413c492ee6e39f7832e6bea4f7b2bcf95eef8242efbeb7406c8eb1a2eb1a474aa1291e94169048f4d0de3ecb85fe56de597593a254829b168256f758690b5bb62f4a27c017af4106dde7db91edb7a71749014a045d34b2091517f4c99b5ec891b787cfcd79dbd4d5d6d1f05b8bcae6bc483408ba33a6ecdcbc665a9f15dccedc0c98f3be9f4acc9777bd7eee814c15c5c44dc1f4e61f79282ede73cea2d8f8d5364bc76663791f424f2ecc4dea8b5d386a4c131b6739a936a3b96f70e01523f1193ccdc89f9f31ba27585ea552b4d5d5332c91d1fda5490364f409db3d2011f676ccfdd9a7935746b1c43ea549be4a34367fe9cbe3792dd94717053503db405133254fd4e9cb859f203c98a7128ca015c74833009c978617dfcc4593993dcacf7625e0d626dd9ce17246aa01c8553f57a8f216d4e72f5f96f887a34e036a52882b3d9d384556b0983f021f0a225151bbbd6c3d9eb7d6d4a547d65e4beda7e7aa7319a17b159b51d2a7df3734b8a8e31fd09329b150c27ab7b3ea90b2422542f570e145d34d772c69959e73d3760558f61dc97d851782fa1dc85dd1ac0d1477eb4420a17fbf2476a06aacc508660c8a0333f25e219f8dde49bff32986eaa075b97c72891b7fa0902e5a5b232a4bd3c66f4da4c660bdead73c4c614ab2d224aa379fd13f1ddc4f10a26a41debce79dc15f7485a008a2a1d9a49647dba98c3e6274d292277a801ef8780a988bf84e2e9ab5d7bb6f108c11cc1675046e3b6fd7e46bb2a734a1e559c1e516651d0b3e29e364ed2a06a632f8b5e83eb3e7e7a723fe612d4f717cb30c3c55841205775af92177bf03b6341e6e871f7d4429e71dddf1407215bbfde71ad9655b10c231cd8006d7b39cb43c1b45070316370a251d65ba4482e164a593ed0a28ec2bbf0d49c28bc35911e97d3a27a61c97abb4ecb7743a2a909161c03832b0cfd098dbff0f3c8b9ee15db275defefb110a6ec1f377235867d158a5d9d0562c40f67b00479c4bfd104933fcbbab28893de7b92f79c1522a432d604f9d4cc1da7626e06428d82033b9289922f751430ea96bfda568888eb17e8d331233ea92d9235fc6d5f35d20d2c6ed3f669f43aa680336fb7f0e5c60d39c873d79f2936fef74ad95d87a62632fb654ce3fe65696ea6526e08bd1bd7eba5674ea0d2c401df47d0cead8ab61647af40e90ef7c3c01b7f1288a22c95b5c1c06b6f588b309e84051b7469592d685564fcac3ac494dcd7e01f46be2b93b4eaba6071232fba07b4e60dd75406b60651e6788f428f01612303486ded64e3f428e10663aa8920235d19de42490fd32da05cc4cefd4f33c95a8cd12d9936d1ab708a7228ef58f72a9e27e28f5a0fe9320c936a89d3bdd7fe5e69ff39470a17a33ad0c3340d9585581f5adccd1d65da9bf56ea7f2a18299c682d0a8fe7fafdd7c6d5fbdf37634ffe36cc6c1aeb364036e328fd809cbfecb9fdfd6beb67d81f96eab934c10e6925d517ffbc25d96db26a0e8802b5a81d1eb40be7c42df2e83d1c28d587b190b4d15ddc84fcf0b69c97d09fb4593df3b2110c891aee6a214b28ff43d9d6cce6c2bb078f3fc1e165500f8c4cde61b4f2e32bfe1733b6ab160fb8fd3941451510c63faab7523d50a647e9b37e296ac6247e755b5d6638f2e373fca7f6a589c19210a009d84d2180469d44d7c691c6387df883e37630e955b59aaaf9002ac825dfbba4cf476349d0e4e14f71a5c42c4877ce969d2bf505fc8d44f61a62f4bb730fd27e1789cf61f6f1d8824126137ad08bc45929b04a6b597ec2aeb2fad3459ce5d198f89ac38338a3b047f3e2d359d63658cfa7bc97c7d9ced32667343e83b6a48efeb7186bbe43e8124078ea2ab47de03215923045ea250b0b47cabcf4fdd86a4209c9279d5c9ec9ef020cb7a290ddf3f5ef5bd92f4b25f337edf2ce56942be12450156a022f3e4af462542a9ac7f149b5c5e7297bbed07d5c66c9c100a31bc5b7e1957cebbcb8b6d04ec855cf7b5970fffc6e636d791822621e33ae78486dc09872befed7a795021ad4400493a24dc243340ca6a21774d5c79e38379378b0aee7384a4aad71ad1089fe5284f5afab31564ccf66797e9b94559c924d145e03acaf27b30b747957f90a50643a644c0ac7114662403c7b76e5210d132d8949d83c1ab940305c9a30524ee7207ba238709f5a1d9581cc5d092487b576920cdd83bed116418539b2ced22bfe64368aa9e408b97ac7e916d5e7342e7c9d8d361ccb92c7b29b3215e286eb1a54bc2d286194be67b2e831459c6f3af3dc712301e9bf456aa4b1f7b638bda9bf9549fdf42fdedd19e9732fca2a41ec0f5b370ebe5f403798449c061fa6b2975bf68c49a03c38442f0db1068a95f3174e3a9a261856d2b98ddb671bbe934abc817225642748838c7b443aea89832d7ae065ca0a8ce2f29ea3c4897bfd15afba8e51d2be879e3e7b0f62684b5e49c8aaba20c6a77db63181e25fd54690388abd1da99661f27be6063000b3a5142ea152a1c5d4aa86b6dfa3293024c1266334ce4925f96914af226c8135807ee265534724e44504d27220cc65435c6f4f8dd0f6ad9498a9bef0efc854735aa2f29853eed66c3b28d9ce29ee56d1da3e180ce5cd344062821290b0e265d2df53c12d2ccfe2fbfabfe6854e4594463540560e1450652abe8302dc99c53c4a42ebe8bfdd2a61d9e68d6726a1e2fdfdc07e5b2a87378201333d12daeb349f8d70f96590f28d9b41b6b1abe07212b3c6d0877db0041767e00380d020b9f1243156c34607b0bf963f9d48c85c6084e3755c71600c53c579db8d3738270ad86e2e1eed77dc306c9501bc024040238c6078c91dd7cb8e60a3329fc27dcdfa5e1bb07e0714cb20f4080de7ffedba726c53f92f5ab06690d29e4e112e66ede17ffdc8739f75f73d0b430376e5051da8aa60ba178f00e0e995592acd52edf1ecd8cedd38ebee3299a68f21964cdb5474dc376f2eb59f6281dabf8da57b016a9f07bbfaf753da5bc39cef87facfcac6e787d864c128dd8d92575c46e36c164252fcee8295706b14b348085be7b47667b2fff53e828983ff51c483ba322e77bb6a034afc49a78d371774b596868f3665473fc1087843bbc8dad55de292ef121b9fe84bd0dfc064c110cefa3c222ceba862450302d92e0684c5cfd468a3940ff49a0cffaf535c8fd4541309683356db51d3d80a522435ee732befa30e63ae4ead30a0caae0e491d05e6a61d93d88ce84c6ddcbf5e6a7b42993502e75bb570e401d38c610693c8ff56ac7c4bd80c8aa9d0fcb7a5ed6f9ed12a7ecd071df0c995b234de0f4c6b3d4e4a9e972722dfecda923366ad4c37d77beb0e760db62ab3d2b6d27e24eac481270912960e140640f9eb07f59b00f855a210c821a1f5a4a479bcf894ba79a73a79dd0c0cbd332ed88552e045e4796184fe7811ebb413142a3efda04b5fa4e502438045c46d2924460f96adfb924129d6371888085a1cf57b373683940ac2c3246a050938067cd45ae65f7968664522da156aa12e24de18e81ad12e6f19de3bbef4ebe55b07babfbff79c7856adbaf18c1acfabf742e8fa7387fab6f4804f477281222d25e4cbe77ea79a658963ab67c262555c0806fb7663ee33f3803e42c1f640745ab89796d59f3ff88507f42992227c843078eaaa6a8b1be43d41d33d39505d7796fcce544da560702f658d288328ea0da626e5d2fd57185e697170bb46fe683097b33c5c428a356da6fe3a16b8ba12d0687e8be6430def118cb8d2999b922436c1a4aa1fa7bbf62a985b2bf6920fc0e20efecc25a4083f2b1ed16ed56309678d7d03d3b91b4da5017b9223d6245795c9de48a7b2e51da54146124df0d764f4955f44c918a2ab80629eed6b08da145f0fdcd047fea24d9c9f6f6a088400c48b874e947919c18a16a19111a116fee3fc72abfda43acbaf3bb35d3ecf3140ee770312001105e5e08f4ab7885911d018ae2810ed6c3473a9e991f4ea1221977c4d29b1e0efebff19555337164ec93fd2b132468ef7cc2c688314f7cd4c3d4ba1852b1a06888bfdf558c47886f146f7e2c03239dd66c71023ad6740fd0ddfb84b4c4a2b99e667049d8c186c73daeaf0bb80e3216f5453ff21ced0f9ce0ded74a0f21932cccc145fe4e96d6ce4a77302d910e929071f93f3dc8d782dfb25522c38b0111b1b14c3138c53559819a6ae7bcd8a5ab45edc35028df7910b3ae7d3919bdfa72711dad146485684746132d3d44c63e8f0bc85802b13934ffdf874bec78ae1959f7e0d1f2a9932a6f7a0bded93f36ffef8f7c5efc4bc0bc826c7389298e8f31b8fe80dd05b90683c20df6c085aec0ce3c87638d1c4a6db9166252ea2fea8bf0afa5b162c5cd066562e6d1ac630b33a257d01362b2d9a0cb2b19a560f03186cc6506b502a376bb3026f9609204a36728a01a392e8d1e35c3e06cde628966526553046c482234cd4ea4329f3d10e9cfb58f867ea1f22751e09f56c02921be223decb704bc1ff733d3147016e236b70b241ab94c4142d7ebadf0a357101d0edeba3a18f0de736c4e442e80b1041281518402c8865c9b915909b965ef99c994b86bbd0340451b817054a96e94d5a739833cc5a08850573156678fbe07d960578784d125f2ec91df8bacfb8d2ab101e64ff6d9c63fcd31fa11a61c20bde9b76769a93f01acc812fd528c389caa5b5efdb58bf4ea6ee00f9d4a21de51bfc00505b47535a8a409aa9cda32905748fe9dc10a7f25f3e6423f98c453231c683de9a85ab3f034776d3b4475b2106c768c457e2853a463e442b44e4cb0cff1fc4ae5d2999f85528a15d7bde04b29c1c75716dab184f5a5d78396b1f6591d2a439671fe86d8204c00c4e4023e77b8ba7091c5e6356a061cb46f3d64d3e9bae3c84c2cc19bbab601f1bc4b5e630765155c9d25eb11ffb589c58192d8943954a272dd5fd032c65f8999f970c7168ab46f990db28c48ce4a79c4a9efff9fb1c052acfd0f8412c6ae656bb405ab284bb6386e4fa2ecc884f841112c700f1567bf4fb80c0a663d976c130185d0f8b6f0bbdeda743838349b94a309c19fb1e18bceebe595e778c61d4958ac07c9d9122b70a16a6b254de4f5004be1e5e61164a05521bbc9ef666513398597ebccd8a89ab69bd0d7a4632e1bcb43f725f0405cd8079b319701deb60e3f3b8b856ce06cfb3a35415c8a5e17ba07b7af36812ab7673fa0f6ea796e02c1cb5aa7b9ce24191cfe0fcf161fecb8e9e45b0e7b2e51f6bbd6d6b9cb659bfa70b54b682e04dd62eb12b994b64a319eb9efe93f2ae8e2e24c0fb43111388a04836d1e47f13cd7a4dfa8973e34ee5ebec09c64ac0c58114544974ba90e726b969e3de256fab66d544cac8adc775e1cba96d31f30ad7483bb3fa112de8bf97a5aa4d810394a48b3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
