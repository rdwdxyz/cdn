<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e4416f79091e849e50a6e3f66c36e054304a132a80dfca82b5a620e08bfa9dbe4bd4a3eb333a32cbd579ba2c25342b8f16e50efdfb539827237c25de5f794ac441e79a15e5b04230af11bf7831ba340a04e7ec26d798f75e4d8bacf25232e3e40daff8259214209d2fcfd63b2e424194aa07e4f0953eba31cc17d760ae7e5ccae90ca5b6af5bcac06cdc18bcd34f1f3b928659f8c8d40fcc0b5673207c7b7d4bca57fc79b838b44e7abc219affaea415047e3b666381aeb125e7a4b4120d4055b5a94afbcf5fef32365ca4abb6fdc10122b4229d66f53b48f9e8790f879456110c38880835cfabdeecd8faba8bb5dd297b9789f0195c11967a3b56dd6022f6a3731ab792c42b16d157af647723d04e2ba0393f8f94acada4581f3b017431585aba659d134642fac00a184cf4a02424d273f6fb74c6f19a16617979ae4db4b3c95148502f01d2e3e9f2d097b4ff5e3c8e68c5144bc43760df6d3b13017d64e7b553be3475a4b843e3047925c12124a40391027f8edd7b7017a87d5d452c9edb0f5996fabef233bd7fed611a6643fef8b1a42fbcbc5e255446cf75b1299609c8e8a4d5c2e6f24fa751c051739c195fce62683a43cbaea4849c4c6c3a3cabb7960a3a93a0d7f3dedd9b27fdac9ed0c19fbdafa80d800a31046be3f4f5c35f525be9ed318c9a312e26e9089ab67dac71b3961b9321a1b7bf1d91c2a54fdbe41813afcaf743ccc5b0e8554fa1e140316e321a5365c0294685cf39f82e555102e7008f121901d4d708e1b1ddce60263dcf7d6c04dcd5881e278af3e08695e0003464cb526125c464a6ecba49624b5504759da863d18188c0418c60e3f0a69c6948aed0feeb3672504672b648f50dc25720424db255f64e35ca8c10b3a07f431704bd107336e78c8897d65d0c656681979044a541288e4c57a9f910bf43aae6d4820083825765dc9e332693455ab3d2ca3ba8d1d87984fe84f71d5f485b4a8c061aa73e9a18e0cfa1817ff0d7e5fa7dd1e9150d0f5487b6850a26450b9e0f903d69a5ac7c53da828962791ca1f38c69ebd356d417908dd4f7fb73fcdcb07e3335093ecdd1a253fb44c545947ddb73c63260d41aa12f77fdbf871a05767d194232cdc62c2ea45dcb47b316b10ca922b3fa380305ae5047783e09954264fa7ae9ec3b9d608012aa43ec6a4c9773c44055708461e1ebcc739809c2a20ac264b02df35f648d95e2c5637661d087db90f85d0dc8d222bb417cb746bc80d1b7f104ab041ae521812bcc5c77fb920ba6027527f6a5d63ccf99f5cd5b9200864e437c2acef133f304c8dd3d87a5d63214c4d93eb14a7047c076fba4b43d2a4e093a2f15cfe56ef55fa0175796a7f14027cf14ea659993a875eb02b4dd7c380d065c081998289945ce1e96b1a71e6accb9dbc19ec343d03abbeea9c52784ca62d94ea570f796d56ac7af937533767f4cc2cf658b95866d6fca501770bbecd406408477374fa8c8350399d454cbc9ba1870e91c3bf19e75c1bab39dc197f18f9c1752ffde06872a44371806ad7cc373078b7c7f24f4e1c6ae7971ff1550d7254f83a5aa093e3cea261717980e1f18449291ea267e1e0f5a05f87a55c6067aeb8a8300de8a9a9920a6aa586f1dd14af537b172354d869fa186951dd64af506f7ca4a9252987ea8ba168dda1e2e318451ada63250ea5a8050c362edb454ab79437dcf91904124a21c329956c6d3111c0c907599753537765732e794f8f311e452e00a9e058434b59b7ca40c19b0f1af4df09dd146ee8a7a4eb6440f191ee1586e429606c40fa4dbc1b56e6f2ca216f6c697f3bdd3dd3bbb27a05d4adbf47dda2e5a913469192d9ca05cde988b11cc5618cc6ccf09efe960eb9971f5c4bc0d1e90930e8f99f492c2dad238e437cab2c3c07d59ad14b875e33d1e0babfda365faf572a633e1ec0d1ed53fe2d7023f4671aad9ec3abc0de42ca232dc78c7ced72505d53cb943933b3067b2a18e3d1c88c0b923b3f7c7535bff42bd21506d41b87c6c66ff287473c4342b56fe76c983742b0b9c36241816151f4ae12bf31a0dec0bfad1c4bf986c11d2d97e14762adc46fbd4c1ed77efe65766b3a0ea943b8f778babea8241ec89185ed433e4c35a0b9acfab050fc263929b1f35b7afd61c37c4b2f5f2d8f788ee514217eb8a1f7790020f28adc62b586eda71494c86324713a00b1e9aa461dd4cb96cdd8a03ae466c2e0d5049574a39e921155bbca983c262bb13e24a008c61066b93b4d92589cc2ac01c08e9a531b32f054c2fa20d6c13e0d73f449fdc3b056ad5ff2e2eb38f7690deb2b71df53450874b0ded914492b5b96571fafc9ac5961dfad34a92aee9a82d4f7c51a85517248ca5516e31f8570104787ca6d56acc332edcab5b390c7e9546c5fee7231dd80a81aedab356752068cfb07132c909eb50bc3dd9b4d88ff393fbf2b1477e5fed4f38dc4bf3151ac0db2e295874f72c6f83d82272725149306ad09907352350ec13162dbbf5b48e1d32a68fb04614ab7773111bff7b3c33ea2fe63d99776c1500831104b64e339f31fc02cb491b43186d8ed3d6d1694e8e6630321c0a3b44fbdd8ba383c14cceafce149c97fcdd6acc83a4535513318dde71921a2d8e75c862ac3ca674c10e9f32a4a973cc357e1849b9e4974959adc9b2ef75ebc632b24e3b6872bcf853f9bdd7d9b3c748515f8c9affc29ea01bb1239b99317e19db57fb8e7a5f9eeb111a50f4be7fd410dfe551e0e93f08cdb0c7488fa34f8d0562c9755da7a4b3361f76c1ffb9877a6a1c7c95d83c19421c4d135aba66cd737d0d3b4b38f4cbf2c7ed320f28d352542927b8037caced93dd135727d555dbba3f2643bb041f8000543e4bbb81c3cae6967d30aea0b22e5fb45ccf9476c6fa40339fb28cce9425071ea1d3c4099bf1f6bcba3b9b2db4349a4cf225370cf3256febe9eefdc3eaa65ab878e250202ce5e26a07234e0e3bee5aea8ec7bbff934aebc8d8dff2aec44be6f96e8fec014be92ca52eb082e3c9bf8a9a8c930b82fb9b847e18551f9c63cd5e9437e5b3f6e195d97d21ef86915613570f7657d68d8d72a5943a1b253faf1e105adccf016f6370192edd533a9e6e104058dac59be2b4dcf304ab92f8e0425ea3e90db81d03ab1d98150be1098c74a7b44fabd8b4de6cfee094a2e725828f4047a50b854761dba22a904bd338ce52a7b92a8edc37a3e30d4f2a1cff44c036f8d4ab9b5627828055ee9a404bfe044473f40722ce14b4bff3e8940ae8ed13b16fc8928dbe64dc34c9972bf844b4f08bc213d42e14dde0d03276f50270da104a4b1a91be0c52b62a1a19bf1c3a6e52d8c16ae3e837af1b49e5460cf7a82eb6149812fab4679952673c18dd96fec9125057b5bcb200add310da2f27cc0b3f31e064fb14458498aba84ee207821843fe720ef364520dbe5830ae4edf19e27a112aeebc970fd0dacf6004bb2c3a16da6a3bb63f812785abb112a48529c49e465494db8051666ebfb1f0e22d65e4d269339fbcd0a557b3918e8d7b40c1c6406ad8602b2b545f3f2609e479f2ab6a80ed1b49f06328916eb10434b1e1cc16f9d78a23ee4e099f0f586b653844d5a8cc1a9bdbc3045e716e4b6e242cac51df4462aa67f11578536d0e6ec2ef6f5fc0a8ad78f2a63a2a84470be26105f0ef8948f09bd56cda9825904485270e7c43fe29539a6ca2036524cb1a68b71681cdadd8155562ae23bf30a37205f94d42e0a3069bc36f52c2b8488ae38725c847f06f666005219070e1ce7ccc88f60a67fa28766aa3a057f5876ba2c852b3b872431da23e6c0e26cc06a13570f2f063eee5b526bf45323a2b9a23b22227a8b13de5d5bed1be5bac457cb953784a330215a6ce0ddef9c725da16fcbd768955f5cebdb31d09a0d8f16905c7d03555cff9a75c258da8fc5e35bafd7ed9c32d0ddfc68ff6c617457422b2028b33c24a1338221f5831f40d27e2d80efb691865c851a1d7635c2846ad3cc26c8adfab115988104384c54c818a82e1612628d24506118dc5f12459a907fdc106c211e605da823aca48481ce14cb66ccc3f0ac7285c56e34d975d2a9d960c47a3f1a7e92c6d9034dd76b28d44a442f7449fbe4d12c0a43d252d76c1acf988173d339c2a6730f5f83678bfeb62f9522742bf8337fcf4e640cb4f620cf1c637bd08b4d02236b1c7c86aabd44b5b4db32915b27a428cdba8ff9bf1917f5242ee8e8ffefad638d879a52cee117ccae2f1d7c2e7a64fc673cc36411b05095bd915c2b7ed505fce964bc791ebdd2bf98fdc3a6b5b2b29c5ae969962c3ea30b13acf96c025994dc225054a9128c982e17568277bb24fd4b8c05f2fabdb47b938053dada07a9a47ceada32857fccb1a26edb87e46476176af8fc67ee050cfcb4a50e6ac25ba4fbb9d61bcfcb492a55f6858f7e7f719914d09ce3a484ec663d9fef6a4f80687e1df1b3e21f880956b3e2e1df50400f239c0d6093b64fd6aef35ffe3fe4a525b8e6eb3fdacb5371d9d2de5fedf969639868eba6c2fdf40d5cc64be8932337f524ae967ac4d8da04f5fcffa220f4928af274730799d32de0aebf5a8eaf8e6c01fcf93a9cac34f7a4458812371c340e525602b80fe458e950d9ed4c46fc5bd90b142007e83fb7681972cbca46778460980dd408089a4c76e9c8671dd39c22b069465edcfa7a4b8739a2d49dcc6f3e00bd72fc1d2cce4907fdeed9849a96b74c37e1eab9dd406f09bf71fa09719df28d18a5109785f273cae0e48ca773c472d036dd5b75fb098755aa8d5704d3e6d1dbe80eca247fd3ac487e83c94f57717c5c226d7099d2228bff194e638627d629df856d74bc239db69ffc56a7327e9a1a0bcf2eef2e2516028c0b06afe408632795c981bbbfa9e3900f21923813cfd16eed856d32f06ce2bf9938dba25fa81d5497ffdbd92777155a0fb4e73bf2db135d3b91ab9d0e4ef5c7b0bdf9991f62da1f9cc4b7a46e6b9a2e5b9ae3f7c10be727aabe0d6cb6699bba2ff16e18dfa910d2d7d99ec4cb4f0db837dad11084314860ee3faa9369a5c202cb19ade23e5274eb565f0a4499dd4bf37a873cf50bd961d2d247a28690e78dda9a387fa6a075d939135dde49a6d5ef195391ba8477ac3dcbb4c778d0e837a6b32013318754d832ac04d95ac21315cbd98c8702278d79b11850d71779fea64c7e1afd9e5d991368312b78ba114f077332703a0124e92e3ef09c5e32bf7e67804649f4ec935313bed1d83e54e5ff87d878459d4dbd56c23f86b0d49780604135673ab725a84244f29134e62fa9ec658a09abf9b26932b3155c41b97d5e75249b736154d204081f7cffa41dcfe85591813c693573d12b460ac47b95b0b131afdf56f8927c62fb05d67ebd563708c99635c60f01c0e836fca0b532955acb7168875914715756a42032cad53132861abe15860c9abf09f561fc6b4a306239d368c94cfd68e53d737130d2a355faf7a464d122d416eafad319153dc64a84748f6bd79229e8edece5c866d0d1f1628682d7136f30fe918ffae4f802c94b68268dec41d6f77e9e569987f8d0578862dc36654122077b30918debc82cec80162dfe959eaf2e4f55ec1c78b198192b6a81dfb1c1d5f5fa2567c9df76bcc3ac061f83254caa0cf38824d63d423be549d7bf53f679180c1d58681ea66eecb6f37659f31fe59ccdbc76800af1fe0894ebec12cd4ab9d532a4a502e6ee2efbcc7cf1dfad465a6445cf8d5f3283faf52f23e7b24d2e119c342698b5e62bee49b15de4f003b85c159ab5af7f369a5948fc614284a78260f83d8af34c93f0a520c35ab71176929cefc59f774531b95392311d142f0b9f48acf0d409dcde71431986d998375595b9400ddc4aa0260bd2183443688f53963f27b8702d70eec4bb32e189bdb8fb194d4e6c3281f91057e692a702041db6b5656ae8226de6341109e503f184f5380dbf412cbd6cb1dd6e9eb8e11d85e52ff597c1b0941ee7f9e501e503b762520501c689e5a5dcac4c25c8073e697a30cc22f6e8b53d1f8e4ee2c79ebed337d2c16a7f2305d436f1dd0c7b23d01bc22cab6630afa7875eca9cdc4ca23fdcc8fc6f2262f901804d2de5e32f372a4132ef8977c6946ffc5d06d5f5885de6ecae966b6370fbe30c013ccc7418a9d3e531194cc039e838408d36683c6223fa32f7509a302bb3b240492217cdab9d0cf548476c1c80a33fd7b3a94a3b950944c190b97af94a7df7a7ed78caaae3133ede9e0eb677dd25b4e0e39b8651ce2fbfc445b3fcd58531530a9bceaf8d27cde30e3f0cf8ed68012534bec4468d2a4e6ffb727578f3b34bbe00a96c8abcd4a9a37cc4f94965d9a3765924c764b80c45c54dda3e7e6ecff936f172e8cebf0a4502dc1d1a4138f4a9465ebe92737961a937b70b9f83b7349a6430015fef0be74bed44ede87f9e3eca711289b5d2c25e845b94c7d68f816d62c825902ec4d7d70b26744912e9b7dec79c4b0ccc10e97ad45d44bf8a91afa65b7f81db5af5b54e72d41c65f42337a6d3cf5b7ec1f57121d382ee2e5a701c6289c61df2062f4e758ed18d502de48734743c69a6845b1df973c1085100aa00ecc6a5b55b0b2383e4b4a41d8557ea54e882d2ab6bc8f7fc4cf1cc8a0e390b1432a493c97b813f61f4d8bd874cdcf56cb548830ce9fa67ec12be8f67396d4371028630677e62468b76085fbdbf31260f6c530ded90bee92837b37146ec3ee06e3657a267238e180c67060545f49cc2481ab2fbdf3e09a74174e2969e5beb6382c12be37881ac3eee79dabf1199adba1a154a561d65d7a832ebcaf14fd75aa1e09cde78bf9fe9c0a0cef47e818e29bfb150f3309029ffcdf50b5d89ed77fd523eb7075f2e7d6d534f274a3fe957e939e01acf8dc70c6dedd776d8ee47a147439dca7a9c8b17d312b37d1f4a30cbb5392921558c93cd535ddd73bd823cd11bff6f8ef9c9a02b453d2c7ec336b76267422b23feba5d41fedca7fc8f25d4cf71e3f73a491f770ebd6775701ca313600681eaf51021685e4b5e50500be6fb17c6051f728ba24f7b7b67ff4146f2a9060c2dc03acaca14d9a076292970285a99690c7f4df33cd3b007fc9adb9cb0000e09c2dd7263c211a4695ae65358c8d759409efaa88443a173f087f06cc6d22f68f89b8990b0eadff7f20931feb6708356cac4dea381ce2a401240dda9479656645db246a2e37f0680eb8a926a828acf66025874b2835401c0b5218be601122e1be690416089e6252dc441e77d55ddda0309e6c750851d40e9e7fd529858530b482cf2628b0ae0fa2e72c424b8c577afa9fe9ee3422ba2b944ca1ea265608e1e7f3c915bf76ce4d1944e272afdcab948e5084b6b35d3b7659c92ce7971336ed34048b2d4b49aba6129c0936b74b8f804601f9d673f1014e6bfce630736f032a8fe0c8150aa0f8d40b528615ed73639a1ec724c0db47f4698a183faf1f655cbefdfb7ab8eb56ed03d645b9cd619abbc3a31e0c5c4dcb48fb3b5cbbae7521439bb49229a5c8579d75e1536a5aca18a0adad243d7b4f49c345967d864da455a8bd85aca77da36e772abaea8d950cc32ba40416de1003b0ffedf6b4d8ddcaf251c9929f5b1507c3ebe44b9f327be795e27c6dadb3355f0a7d0b24c19662c875b8ba4e4995ec50657700c248564e15b0056cc6342180b67f2fb4dde40581d285f054911567b15423c4c79d3a97df9d6d48b903938918730c411c30db3df3264a14177ecca1f7641f7229a873bd4e518b16a0815c71f4bf57ae07f03579f54d556d4715802d67b71cbf8e0a267e9056666423a9e78ad981ff3028eb68e22eaa0fefaef907e3de4009f1dd8eaf89ad2aba01efdd97257f524419edd897948cb9f7e35b049001481a8dd5933fbabd835c1cf5d94ab40101f9ac672eedf423bff3eb058323c39ca403ce2540a03ec43186d781697c283075d3ad202cc3bcf1db949eab06172564ab4ef02eba8179fed650c51c988fc14968089369420e7094fbf981c4b8552b4a72550f2c6aa8330cf7ef2d92ae964cc913d28fc3340d436d8a33788e0ad19a549fcaf0cc80dba34ba13c6a97a6b327478f980b3613d6676348556ae6f7d11e6d5097283db70207f743379beee0c905f4003589e8c1c39ea3607256c19dd0c23f270591524d6b682e849cafb365c6f7c1ccab91bbc1728811055d3691f5691cf7f40127cbd0d43f27078f3abc274f68965a350d5c4f793ed8f25426640ddae7cfcac8d25d2cfb3ee3962e87af237b072fc30ef1c3af57fe438968fb3c7179034aebdda688a2e5cbb07b890b39fd5b42d733bc4472096cd70da4b5c6cfba4e6337afdaf283d1aa14d98ef4302a197b32c1577cd77f3712c3f8c6a16c773ec8d8ace4dd5f8de17fbe40f7e82cbb2413e865b4c17a1b0adeaf7786af77f1c259a97cb8f4607ae013ec7cc0156b0801be7711b44f4b167d8ea98436e359bea3a666b730ebf33b039f2e4f179c15112717a570c0f8e7c21e4b5ec18518139df176aa9ecb6b1a39d48ae22716ce1ad0aa67005c46b778433ae2d8dc8694552f9ffbc5d0d089da2647f7451b1d80d988ba0143912769ca4832cc3518789861aaaa5a451e8cddbb47b37eb0d0bdd1fe99e292f4b33cfb971fbff5f5b460120f02b90491dd2ed116bfba79d92725a9eb6a7aa9a1382b08c105823ed261090c812477bad516dcb1a501dff50a8d1f0435a3a4c52b29a34d01d2e875691e6759433b96c13004e484784192eb44df4e9311b214ca977079410d26ba35b56d2f786bcc3396e6a3b02538553d5eed9fb95ab387d019671a536fad3f3ea34cf7e44bbf0fa2921fc03af9ed5796a64962172bc60c8f48da321ab75aca4d783a570d36b8f28e5f6db73721ec60fbf0f18b710ee9ff263ae80f2b131f280f689aa94c37f73c72cc96712b7995b3d8a7027391743000eb3564180497ad0845518c0acbd29e1fa19ca66a39bff51fe63290075cb887c60ac6c0967f410043d03363f8f1c741a438c3f53c4068b86eb719439ee41b6ee4cbdb3bd3b818fdcbd5fe97d37f2d910d4c390f82d6407c35d086d907c61380e5353b776dd04d6b324e78ee61651fc405c1a444b5f64684def870632a0204b52d334689810ad767ce8d4bbcbf49ec043b744a61b51afb6e609d73c3f94fb0df67ea7cf57f1ddb9c2dd35d07ace654609de546e77a3d6c34ec63b55d83df46c4bc73ce818cadd0d5798fca7541d76323c0e5d945196fdb82444e5dfef1f25d5fc8df1de2397039a19ff16a7531eb3f3ab069bbc1349563f6cc42339973d320444949c77306a17ada1169f4c74062c33811bc4af176a280750753ffef9c99d21575678dcc4677573c8b644399ddda2f87b74eee65de77169bab836c54a9c34873c368087bbbd3eb65f648f9d51f51c0bc10e938ad2a0900270d8a528df1772beeaadcc20e203e9085a1c4a832a9a812fc82868396bd2d0c603549b27690c26c48bf82c31bb3198266b25364da6d792b6db58b8bce17d028bec4dd33041c6af5bd65e94c048f1fe4a83d73f9bbfaf82880068a441c42299bf9974264a23bd441fc907f68fdd6ff3ce579d5eb10f5c02ef5ab9319f5183e187f34205eb0f783725b47f485ccc840d094b1645e43db177e5c2f9fdd28fa4a70a858bc1e87839a3297e972c37cc844069d4b063ae7eadfcaeaf0158dddd82c6477e4638368fe7b7dab4a22e11cbf601d89865d0b9d11ef5d3adea5445471e5f65cfb1ea49d1d659e413dfe5332eecf044e8459003fdaaf2509a46b75382e0fd7d81bb6f9c03e84fd9825ab5b1001e21032a061a4289c2d85bc5203a2bd5cc33b40dd487245c52363f5731807e98dd174a6f28ffd1a0c6bf28e0f5c3568106d1d3c69567d7cfd2387f2f30a2bcde261e0d727354fcd2e63a142ab13c5df1255bd4a902f684986f19064a92b36f6c6ee6e8b415270e353d7ffb45c33a9838cd42d8bc2a950c1ad76ecc512a4f54bd35ee384cdf93143ed2d9d62414aac1da1fdb2ea19041cb847955731f390302bc19803ef7dc6480690dfe66f79a33511ad6662da6244212e19d7164f2b3bffabbc5f278e698286274c8f40a92811f71f8b73a9f00baae5fe292af46641fc7f421990ef8790aad645e9b66fdb29590212eb222855bef0e6a76665ece1a2dc38de96b1b557d9522867f9451f9bd677444808b010f4fe25e5c9a9c665c0aac6751560920c317796fa5ad3b0427ad68c162d261514cbf6bf0658f453fa6cd8ecb9b799d32c2aec150962f6e2e17d938872b41f9136f4b37044a30964d61b2fdea7e921febcaa77d38e85d5dc675ec27a3a65dbfbd75c737ebe38b2ce9b42b89c270cb5c0cc54b2d43dcf396086268abd3ba7bcba87ab7922a520e37c9a830da7bf05e6b58f1a24ef81caa3b791336999b8693de1230edf30f77a7507701f8878edff9b02e38d5c577cbb7c6a28edd079ccfab850523a637bedff0ec94737e74bf89b8ee393bfecdd0ad84bd9b2f18826f6e225f76b1fc5fd36e8816a8d663e4813ff7c594cebde3fcca71bbe9660eaf3920ec487e4e47ebbc865176c3c0a94eb12e1ef7595111b47bd5dbf18551af9cc04d8a1fee214418a62e5536d99785ca0126b5b5c124858bf6c520e79e3a4bb13c813515d1b90d6afa1ad63dca2889a10fe0e7c5d049b8a278ec71e41f5a00d25d8160fa5281e1db5b0f365540e6a00e0272394d9df8f1da8619c33acafdb10cd66bd92d65456e25993bb70bbd22c59db8ccff1877e76011bd35fbddc138bc68d00947d90929088cadeb8d0ac4376371d64258a8332c40c7851c7c09586f47984429c145b0875db8f43d939b1d1fde666b28014060e1f8350cb978f5df385c1a90d4f341913b2f099ccee5593f7e0b4c529eb5ab06a57909929b645418d4827617ff2869ad7e0375cccd2ba9e3b1dcb6bea1a8c9d9228ab77e3f5613fa93122569890b12aecaed157d61d516aa716d09d421ccfd382ee3370c5e7f9a24deac12032fdd19ce63d33667d50c5b5851f25b03b58c71f3433002932d67da1ad5ac4712a626dcb0bc8f20147e66e911b7a752d9ba2f0978990f25042de8b1b54053cb84e98fe1138bc6ec7ca6b42f88b26b26034b2e16185872b1cc327ca55199c63feba583cccc93b26624d7fc7444582e7d6f7362ab0f90e67a1757bbbed2f12faaf1ee78a2d3e2e5d7dc097c0c720f3890d3d16220bdcc7464cdb7977916c009a04191ac5062ac92ccc8a279a081e56c09773c82a722d6f54dc39624a74cdf1b89485402380fc60643fe5ebee24881cc95fc27bd680df0b1478a62ec92ede1de82de9c48fbb6c968191a7fdb4d2771b1ce0e5cd08bad2897d78b501ce585f438e76c2eb1565eff541faf7be77faad559dcb8ad5b24a070a8864aea1cfc4387500a0efc4bb15773720feb4506e4ad60a759a9211e7c70bceed3aa1f2fa74bbe20c0bf34c8d4ab11b53626ed3e623eb44b6e2da726015c41ea3b3b11114baf3d21bf052e12d4aaa65c334000ead2e41edcf15de87d4ab48528ec8de5e518a5c7bc34108a870dc5f0304a517383e05fad3344eb2afc8c664cb2a28d2e0853dc199ae322d0242cdf8b05307446cb3633853fce1fecddaeb31764375cfe27cf4cc9e3b65fd7735aa2d78ddaa59123d39ee6c56627c8fd5d78d437cdc8a4734b4caa91ef835afa66e55ab5d7bcce680cc5a98dce87ea6dab68aa73269b6cd4b8176e6ed13377f3eab00647c49e0ce43100886198c0c24b5fe04a292252ea678a7fb002fe8fc341e5a58acd76c7b79026d315f1c8614423986ab16f57424aa8bf00ce50cde71ec057fe3c63d8d145fee38d70a0a6786c07d96e11a957e57a8fb1951ecb55d126839cdfbbbd38d19ddd5283f2bf2881d88dc59fb8cf820f429b44f9837c7f1c8a12ad874e1db4da79bbb607d9afeabb83155909a73d5c6a196de1b55373fde3bcbcf3894c2bf950695ed0e3e7aa8b741746b4daacac5cf098800b72675189b276d5728afc21b2c47a1c0a3e17b6a27a1c30060183296bc82a6052abf0acc92cdbbbaeb59a3c7938162376fe2a8efeb50cde436cb0ce7a95d3bb598ad21b126e19f5a96dd64a7bd05ccf26e6a8b408b3bef9a107431469d05a23075e0978a209f1fb6c2d0dfd885307207b099e177c8f969b7d51a8f31af8de70a60ab5f5eb10cf16e566384eb9e7d039257c69bc6d1a6ce2485986bac2fa3c42faffb01dc1c0906f71772a0651afceb2ce867d9cc70ede118b058143d2899d5ee7b7624e1f28e71eb2a86a81aaa4c39b83898894f0e578c18af01a4ad5340003ee075ca7e4e30cbc681d225e2b534c638939a5008de27736187bafcacff7daa069809025303b05d083224b85eb9b7677468fb6f7c8b248dfb0382f342dfda0642af2501c8cbfe7d0c8c07915df5061026ea29cef20de0345fe706074c7501c660139b2effe5688c4b6f3f23209b502dc56089a14eaa206786cb0d59a2ac24ad7f252a3a7d6613cdeb719ccaf16f6e69af6846bb18af0a300a173c20d583b8624619a37d47e5848a92b3ed17681d17f4461b9bfffa6eda24622520fa3f8df966d87007f657ff3bac990fedfa9922d2fd52ba04a3e44fbf75a29a2e03acb177b3bc5a6112f21c3789c738193ea016f705064c601da479b38d130281aa92665b3ce83f8437a04f37e1715a1e21b3c63f1c7d5e5eef29e6e9dcce1d39d976764bf1d1df66965ef681c6b6fe5c5573f6d7f19b24e695d3de091b300c0ca4e0796e599b998b0732259935bacf1185449da2777d17efc8868c5f8b3673aa8cfcac8740e4264f00efddac2dea086ab4924a4a75cac050d40a0516c019eb30288764d607938e77c238199bf0da161da8425798568007f29a982c7b94566ebe3a05f1d89e1bea9a421237282f6b5d8f402fcd0da6b747ab66e2d388b7e28b8c75a38a0eb14ef3a6eb7f77dde7d9ccd20f9de0b121a09883c07468885fc33a8b116aaeb81082e81a96da0a370fc636a112f60de08f97c517826fdd9a0034975609804c2bd8c50291dc34b2efa71f2df4a71db28a43ef009fba8cc872616308bb11c8947dd61edfdd1c618315417dd46f7cdc16da8f41e5ae3dd336d99f82b938323f09983def1647b001c939cae7e269ca5018b371bbf1efe7ba458249a7471b4924c874b60adc92178d005c6e0588f8513eae762109052d31c6ccfa25dc3d7499880a7209428e162336a10bdc6f710f40eec42a86cc2dcd297c29c1e0c55cd7e7d1b18dfd85822b64fa5a811856d854bc44e95c24b62ea2e3c5ce09cb6f3ed75c170b0aa5a712bae26aa0fe805be43c9b1a458d77da3fa98bcc8ba3e4358e8c201d0bf816ccf66c6996ba51727f518b7d968e2a873ec806e8889f97f247b4e77778fc9a4e7cbf2ace805d6fbe2b5fd1d220226bdf59778ba72cdf644980abad2c9ac663dff35da6a11a89c713de386574623d03f04963ae37457f34449e807636d65e2cdff8e303ec980027ad62e757b998f8decf108e3db88b7b7afbd8d5b95e726dd1c345ad3bb9c752f5ee350c714ca8bca7ad8a3bc0ee2a13311d59d30c4dc2d37bc5691a3b05def515aad308e84d83dce3c6da8021c0e92da5691dea3ffdfc106526b30a9413fc0cd2291b6ffa4e9c0245876bd685e7a3727d5c7f3819afccefb90b17617ea979e6a8412e0219eed86e3e198378eed880d34b4f289972a486e39f8bd74967350b58a7a13f216139b97977ade3e4ecb7639ca5f8ff47f6495ea8ecb13d77ebae8770b9460aa794319f3311370229d7521ff24a4839afc880debfee6f9e667570fd4de6c9cb0f83018c182d0649aee58f94d9d1bca40baf254588c86e2357b1736042e15bf08ad45601a2c787c4a9ac8e8182888f6f778a1c538e8166169a8d1a4c7bd49a2b414f508defbb7d844e6b03059d6f0adced5dc760a20f22986ef3f0691ca76201dd2f697f5a8169d95bc56088260ae5cb093d26749c93ad7237bee1287272d37fac74e24d98ee7310a63b48afd314bf847172bbc5115275a1e9c291412301214ec4231588754d3ae1d0f444b7afeca1b7480e9102278a09375ef94278f10a8690460725000fdd6e9ede6e5aa0afed6ca1eb983eb3bd0e925928454aab8d6cb1f775489bbecaa4a2988ecee1901661dd121ed8bed9d7a30b500f77e179b440373b6ae1fabe79912d7bc3f30198f34458890b5f1fc2cd0e1490a3f0d8496a956e055a7f91d890d5afc816e7366bef1bb7fbe830de430698e644d63a4d018477a192d3f72867069e0f83244781e666265aa5e552b9ceb5af6d35e623fd1d06b969f77150f115c309975107a7ad61b264a6082472cd9677f88baabcfd8f3580f1735e78f87c5271085d5d74239e3b211f2165d070c86e11b5c293937899f79d83f4afffbbcea06f4f28983ac1a432e2dc8d6725f172c5e4533efcb85be1172949c49829f13cef237025c526964c1ea15befb58d76a275d83df43212cdc4b9c0540c1617eb2dc47a62fc8290dd003eb71786a381d890566a772ec3ff91a4a9bb21dedcfc719c424c808cc71fef7bc7f104a66150e256e9fd593cebd257e0772459dd85ab4e648f7dbabaaba0c6d85138a16b705248ef3b22db3547fab8b9b7b7f7919ba73f5da61d83315beaa232590558d5105fe40f3abd42cc5230ef32284a11cc7456772ea16fe65f7df53513b27304d463d798ad901627ecedd78e54f173237528d43c07a51527c2b24b900e5e50d8408c645c8dd6aa8e6dbac2d338ef719eca4d21986158f2ae16ad4061896d771a24210c15a437a5c64bd3a8695e2c4a256cc9fedaa40541f445e4f9075d29a5de13e374c8ad06fd100c0ac2daa12a39dff557807a8c6af3605673d4d90ea547fab37a49338dd9dffff6f275ceb1bdfc489927aa8b77f6e4722bb3b0e3abd2030d2c3dc1af2b8541f5d9d67ad7ca4238057c67a96f57d0ace07115c358179b4e5658cbce38d592b40193d392238f616293605fc9dd20df9e51c5d61f924fce40918234c9904d2e1926e8c9b0ce6cf513213db92fec8806a1f1f3dc0b2b08c894e1cb70c9be082da8f739d5d4ca342c0217a2bd0e841914c13c8c49e8d78ebea275dbe063378cee2d03f16dca31e5c73ec0e28da6916931e16ce5f5e9a0c1f3b53670d1b1cba34db5677714f63df90baecefa13913c25487436766f52b92328c0a048ecf7361860e25b8041a89fc7d085eb9adf5523cea305010ef80b4a54de5110277e8a03b2ea2550010afc644963bee4bd2eeccc840e23ecb8b2856a340611e15150d5670363aac2a253cc05b5f7111b4783a6d2081045c282973797fe8b1dcadc7cee32211fca6941a2d19be2ff797edda467245ee3f7082e112ff704c744c6822b1a5111446b5d08e4ef686efd4e06bf9a32e737de180b28cdede5973565839e814e04511577d1e1f5d6ba16f0518f1e8d3f7e61eaef2ac4e2139ce79341aedc8d00bbc45f106289717229cd38f98af1af9243309ce1b41cbc0ebb515928b55b38c2b6d94676327d5690fb10491c822436036975145b0e7534556daee182da4cab520ba805fb1dd9c25e1e993a0e0c9b6e332467838d96c8c27ad6f216c191388ba04bb5ff45343d1d9d5aef376dbae7ae5bcd27b37b9ec3625b6f8b94ceaf794c0f7826d24181b0e75be81c67c3b86d41b179ee01b6099e80a53bc1dec24582dd9f26820a67e0dbe136f27265e03c3d400377dbe606e5e641ba6caac9868804d0973b3f1ed51e4f4503eb1b989dfa6614f1e21aa2dfea73672fa10a0aeae9053415ac3403daa4c49f774605ae2bdb984f1884db98aaab438a8d25f3f5498fd78c37ad8b1b0b718b585e2f005cd6398c140942bd53464a5be8a2cd28405a3ad44d4e8200e39707bd8976419f22350e7002fbed510c5d9ad3e56b45df3213a0b44da2322a32d78687f2340cc221970ac62ad950e244aa7cedc280a695a1321e3d4f9766de41210f411f4d4b913bfafbaab75690bf5710873fb651f5c62dd4ce3b460c57551e7d5dc52b450151b0eab1d447f299b5b08dbcb856034b80f6a832ee3523f9234afd708585efbea0733bdde0ca6a2477c14785fcf906fc053ede4f6e8440ab00f1fd75ff06cbcaeb7af8049fc33f37f8aafe85615dba20b377ab14c1bc0e84b3b75d67d9ea7b7aa8f272b6ff94fa0c982dcba901eade43b773f706de323b7b9e89cbe99dc01829ec91f9ab8188d7f8a776ebcf895e22f3712b9b93aa15478c9dd2323ad6e19d9e8a21d455c1d3b55670f818e825548b2ff3f090ece07a1950016c06d91db9d720ab3e9004ff1632e977bbee93709203bb87ed600108cff3ea3fe64fa7b369b0aec163d536b3cee29bfd3780003478b46e82ff4f836cbd1360bde3c5d2ccbf830782c19dd2d05975121d0a62a0318b22d1079733d82ca677adb23d47d8287a71b7bbba49763c8fb553847384e255e0dfe360d337388df00a9102d5d75d9cc5d7ab1daa2778c3dd7b3e3431fe1abbe293b263d989678b986877944ce5ca6c2e494077dbb3ba18122067ae25f8ecf41fa68dac7f979e5606f151d6bae031aecfb82ba53ee8de0e81b713d71433282ff3805cc4218b26bd50e614bab3d5ace4c1566959264343da6074b7350333b0e6c334b75f414b84bdf244ed8c00db08a892de766d0cb12e7b59163d7404cf6a3477e40719ece7bc6715eeeb70e5b211062cc9dbd7488e7bd195c3875514a84f21e0add8dd7e1aefa523cb1cf7b0b17e6b407f95507b8ef3a1ba04e1cd6ede185c20c50cad5f953f9dde63952e97efdca183eda5eb5475de790afc7c1043e4b5a6cc0cddd369058bd71f603642f9c8bfc53f26cd3cc2a4a9e281a02b33abc49574d6daa771926deb050279080fe628d364d3a6927f8cf944157086a1a900505a803fe2319d17a308b2cbe0dd764acdffb4359800a67e290d93f2c738d20a82bd35ea128c8f77ec03579edf636ed5f45214e62d5a0bb0e42e3e3b1fba428805e849fb95d2fd4b8f2c3d094db02fcd7695dde33e0545ec43c0d26f2ac1bbfc0c2787aced9e457abfe260331188ee9c907c93ce2af0e1f58f172da36407b7e0c4b595ddfd1a93e7e531454c185c1b87ee3175485dea8194863f11ea88278a01754251e3e86f4ce5b522f347b3dc4d9a2b955437b94a801f29b6de03968c9092a13246458b49684ffb7567fdb7ad4d91fc18886dcbfbd9f6d51a9903f6bbf4fb97a886c6923e78bcdc8fda535b28c5b83ab82018e6db2983c346338e320f080c6281a1cc04ce85f95b45c1e28a05cbbef01e9c6fede692ef865266f7659974bd4a11bdd472ced5c0b02ac95185f002c411173405937f1029cf4d1d1a40581b54b459f7e96d287804986e9732c90bd3395b0146c731755ca6420b0d72bf26fc7b12b6f5a31742b6937bbbb5eadd9c08562cac94555621ae2d5cfd55e1c76ac2ede08f1a6386705dfd7b3865e574027828075e53dde4f3f98656acdee70168de193402567c2fdc747e602e418f91d0e9883006cc94d7ab2396ac72da5ea34c14eb416067f7955a561b92b87691db9e0fa8aff1f3bd986bde56f55672a927d77eefe868138ca0b91211644f1b7fb78c423eb60ce4a9e3d1e4731c5ebe75b7082c1e477c295faaaec4a92571b1789bf8a5f0139437e05018f08f275f9f5c289bb2bf6248ce9ff2e1d6fbc6358fe13a087b6ada27d374d0b11339bfbf4ddc6dc9c604fb94920367fd819c005e581b73908c9b0e93f1bc520373fc2b17662cb21e1d94934466194ebd5a32238ea6cfb9ac5fb310890a32d887df4948d262bd5576dc891a18f7d4d3305139a7b3909bad6d2385c323086f4626ddd947231e4fad39321b40a1be63286a2d84fc3d2f10c9950d46181c69888dfcd05ab6e8df93da8c710f99336c74830e572595cecb180c0ea7da037005caac96d7cac46e71f616f5d7979117f8e473cd3938407bd8e00ebf3bb2eadc7847a8d0434921821c2afd0839311598522ebf6b9a8dd781162ce3e04d8971b8921c9fbbcf06dfbcbe8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
