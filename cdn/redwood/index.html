<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd2e141ea7ac5e6dffcf40ece1c658c9d16d7892a105cea257d8ced781c3ed31d0df16cacf6b08ebeb0323372d4acd2fba592d2592bbd906cee480b499aead9f26d17b2d7ffb3edf79c8768d3768d8c46d7e881cee0fe7d88fa429b42914a231f0f7802810cca806b92d7ef2f49a479e24061add2eb828bb92ee346a1355894d5d5526ce39fa7a5955b3f85e87129914c900985dd3e9c225b99c7d3d95293e335c440a1ebfe1d64ab82e9dac16509b3c275deb04a6fabb9b3001c27b478dc02f6e4ccd8fc0bab643f4730d3c9172f6c4bb2262277f15c6b932d753f0dc73f5e64ffe1661fb11ac1a72f218a71959488f564d6192502556e718f980ac7d8b68af1a03c8d272ce166b4066de25e15717d0e78a269269bdf3103feeaa9b19928d2b06646de0140c70a75928bfa876832ffa0fe5c313e78497190af070c1ca7117ae8dc914532e797f8aab840f1bda6f95ee5dede594bcc61bc7154f3d7010e28882cda4ea5399c32cfbda58b5df95bc2849fcb88938510709ad73169d3aebff7c2063049ab49ae1a6992101d02a3a1b9bcdbae9effddb2f1f755e7a5e815eb68bd77a18b14a6f666abb27154fe5017bf4c43d85e05835985b62f167fda6fded8101b5a11a2dc46afcf23ab798e45d2385545c87ffdc7e905f0df9d2d94b39e651fdffb810674ac4b2f7308d4565f72a93f6b59692a04274ec44da8a94a50d42954d7e154d2b4c73514220bc8e9f6d0a6c1fc9d1dca02dc7730d4825321c89b1c5bbbbbbd337ca9dce141db5635dc8ea8efd939c67b15950b6a75d8a9ef5e68b6e5a61e74f74cc2f36e9d89e2ad26f8321533b7975e7fbe4f20b210c70e22ac699edd09cd5a536887aa25ba20e7e21c3e5740216f683eece742ce0c3c8fb4009d7e8991b58be3a7d07b0cbe29eca5c0518d5dea69fd8b6892bf4d436514b777c254820fed4c7ff2a9a8f29019d3dd6e7a6f5325fc34b519f285f3aaf77435c9a12e76702f156e3a0d3233b58e6d1305a2cac99454f61cff333e6bd4b3170f7591b52f9c95d31c979db2c94c6f1b6613b24776c0152f0d07c440cf40f808f1b78672e83dab30b769a73adba24d3fd15930092d263442909fd4147566a44663271150211b866ea840566218fc7332c4c9d1f5e755c658b2d0312c77d1fd1fc957d9f535c0f4bc2c3a40931a7cf77999540b07420b40bcd91d2bfd7f6dda4ad419958489d4462b0699dc7f9a324c7b5193560da8ca8851fd36d5a70e6017e48e87b476ff1aac7b7c720259f71f03aaf703aee9edcd665ff7a79ee311bd049fe6c8b26e730838355a9b62f6ec20496a029e1c690186e0309d7a853218ce6dde06c89d49e75f0a3e8ea93b93efccadb355b45a9788651e3747bddb6c8b6c29719e98a35fda566002ab83fb6521db59512c612f95d5be12947c3d329d5891752c3b31c3beb151ad35ac985065b70f77752e5026dd14f866315cbf7c7bd08b3f60e20c6506ffbf5e70a85492ba05784994a4f7ce3bd7739ee2ea9006bb405a34ea48ddc1bbaf8ce1a45f16f8678d1b2f6d4e8775f00a93bd91bb8e0ceb558e16647775226494f5092dc7c68aecc7c24eab57a319120e1f94b432adae21acefc574ed8918aeb0b9d63b51fe2da181500e2e175775a1e82f4bb0fc1582836423d3f1f99658df50da83e30858935484c293537187bbe22708b8758769e7f1b7f49fd801124327871a7ffafe9ab80279c44c16d4d35545c8e5b96273bb312d5a335bbcd8102f08be648fb477e379b44ec0909915b49e24b91a30cd64dba65157dad3cacca479df644e2a6f62d38b7af7d1eba967cc2fe42e2aa9f2f8fc8e73594a205f87e22b38e87f9036868d8124c0ef7613a7e8f1c9ad37aafac07327efa38d13a83cbed2e5bb9198f32b870c2bbc80400b1dc8248f0295fc960aa9f9266939e771cf3b7e8df3eeafa722ebe56635603f8b4098b29fcabd75b309af0708b53cc79472dc69cd00ed97a93a5e9ecc476cf3efa64fd599073350a5945019e39c10ccc5067f6b8873eb504ab9ed0bde0ae5e2fb8a39a31cdf346c6cf65d814928e054b0e53e9c1fd9835b143a8905c2ab78aa9ff13ec9755fb9c8aebc310143d27f61591fe3fd64be7e29bb7c1005d07c83d006bfa60efb3db43d0e0c31f76d91f25594d5b27d85621460e5e977cd6f5b5044df987fa6003c51096bd77e3b8eab81844a451ff9bac6ae093234ec071b5836bfe826ca2c9be16e2be11b066e1b8eb7bf7e675f4a8e8780d40ced7d3b03d16e9c012cf71749b4621d6c8110a1462130211ff2c2278261a7ec182fdb281fc7d82b5160f3b17bf9bf26d399bfb79589089346300b86f5f9dd6a01ba586f45597e76977e1eb64c3c22856215062e3dc7120ff053e3bfd587cef9aea3225e46c5be77f554a76dffab3b2e4725fd4cc8ed39a326220629aa503917f62f089e710591ff8fb9850ef9169264003b7eaa8856d456ffedcd8a385f538a088c47a6864926084c972591a123e95442a6821d968e586b8cb2cbfbb64f5a3b1f830c82e5197ca5d219701e82e27c4685bc97eeeaf5765eb722c273b7716dbc212c89fd82c328090778a70b81a132002df2c90e845f8ac322349c3006ceef35ee91f2797d5cc1f26927278b746aa0f640a85b5f42158678e09fad390e1c13069a44ef5d59c7169cb286ce6a388d5d87ee61b40c43a8b01ab23cafe53621cfdf208309b2b5dd7afbedebc5a7316de15674bc56ac8d31d70214c0676a2b7e906064e1831c095879ad74298047b9a56fe04cbff5d24d3db15c84fab1c56f0955688c9d91c8ca49ef415e0d5a796d04bba19d06a47e97bce6c9310df46d4587632324ecd2ad8fdac63342c08aa4460982955e5b1cfd15cd94eeee99a95ff0ca45d12c2f976d4ca8e80e76c653f2ddc8fc9ba8db12bebc6a2ddd3126a7ede8365d9dee0a7716043a5506dffab8a3111d5001a571c94271573de00c7846720c4abff77188f4b372d8e5aa7ac5b2a872d64f7ad48bea748e1641d3fd8ce700bf515ab76a717e50812a836b0b2bfd09ca24636a8c991681c09cd1b49fe4cbc9fbacd734f5391460bfe41182fa0706552987c61505122a345715aa57c1f34aa4b36e9b3e4d915cad5b1dba629f21b72a266f13e8901267e58938e25e4d181adb3327134f1679bf33a50f145b94c96efb07efcd6eb36aff2ff7d98ca6459431ed74c8703f62e7c1ddf3e9e86543816144c0d74d1c25de81ce33a49cd2033fe08c7381a41708bb5b5f75e6c23523cbd14db9baa10b7ae0cd436224a0b8e6ee1bc907be17ae96bdcdab913cb08033e8a8f09e95ea9370d5661ef4f0501535b94217cba6564447f0318160862ff93a1c270acfe1dc9d38e725e71517788e04f706229875554273f22755824a2cecb7500f9ba162d6fff7dc41eccf1e6627d7159f1405e12dfd7bd5e985d57c2c8375e76271f8ec4e573cfb3a73f015aaf556b764f5e7cc45a41eba5046f2087668d96a54ac758d23e8bf0dc188261b181308d3ec4d46a3eeaf2100d9556ce36457331a69478d3d2cfd5c8186a5594ef36193d479d7e990b48813022297be5c5fbdae6f7f6df5b30475b3154ddff19300beb1ec1ec6098478cd957585d5187f135649d1e22827c16a56cc715af00d18bfcc42708e87b94094e51e5a1c5dc26b1863fabedfb39c0f7c27433978cc486c1ec51ed9529186b7648537f137a28598458d35b75cb2931c2906751fcda0ff1869db6986be7073bb324da73a507b1156dd7285636c3580c9c9991036e8229f9baf5da299a2bd2d1ccbcd4c43bc237d3bb655281f4e73561bdef1715afe9ba63f402f1792e7db2fd2d7dc91a4c7d7644ea11e77a52aeeda8a801a403c54ae0a46a2257acaf27b7fe48f14f85279c60d809e9b478b82df295484d339cb4f3b221a070fca3ca94ac2185d59e9021d53e8fe0a9e19941c990a60b46ac579f12f058e1a7d735c530d29857df9320c75b209c349686611db5268db1dff05e81f7b69e59039f41f264d20f8b8fba5bcbda5ef1248ff6f02e427afd6585f8bc5e081614452860473b0694f05175f168a0c40d9c74b912729ef7ebd1d51409b7d09cf297ea9c59ac1ffb6d2c24d11a2a1d7bd05035d833b47666169f747b3581bb2273af09ff2f9fe1ec634b0e5aa867a52811150ba095b5bf902710092182f915a575c1fad15841afe480bc82cfc1b5397174e54c8dfb42fc5decf1719868a3787e17d738ee8daa3a64ebeda1d2cf1deac8ad9f24e0f863761cc1292535bcc2c5c2cb82019be4e3d5c09944286f091a5bff219386781fcc1c227201c461de26875cf414746b8eb4ae061c44e0ed692886d2c36fd1f04507ba87efbfa39037bd7567a17d78ef7a4df8ed6a2297e9fede2cacb7888a860ec59f1dccf34aefaf79c4e50e9d6d0d750dd27bb505dae1dac81676264c6905da42f7ca7b55037fa8051bf8f16fd78fa7b0db20a31629cffe55eac2021e587c20253b5664ad14caf08a9071f1744ed1fa0b69647617f71bb0ea0e704493b04b6e4808cbc2aaec44b0711c8db91562f0f9d9d3aabfa6eee9711f85d5c61499d705d6e2cb3e6e692ec42c2cce945d67abeb1620d4a74aef9a7048961ab0010e1a056a3a0a35bd6105faee823ca76926d48b56fe5ef8c378d4ed8ad7873faa7af489b55dce71ba41e159d4788f5d29dc1c9f0b30de12893280a1714c973f9f2764bb4c7e0b18836eb9ffac218166bc9a08a3821bb3a3deddc2e2bee1ab3dd8bfd3112d3881c028743387c9ae4ef850bfd741c4fde846ee5534049bc253bc7d85c654388be887d8072973a45bdb1aebdb56863fa7a6e1221553ecddde26b6b3096138f924050c4adff8196fbe87ec0a89107882c76af16ed7973f17361530039be29361603b055d9c6272946f846f52f38f42a5f14b287c93513ba4cb3a31371dd3cc25e6c44d95bab5548c6fe9cb95f2dd3fa0fe230a45d87b8773fa1a6b1b328de1f7812bbd0f23103c1f7fb0dcc893e9041b8d3b5b2c8bab699fa21be6138b71d99e38948f9628cb10f552d4c2232fe464c5f6161e876747c439c0f2c04029aca319c83bcd10c62f99cf6e37f8c6b65e2d604b964c4d2c5e682777ee2dfd0c58147c1fc9e9dff2ae32d8ac7f391bbb471fa429e48f3730ef896b7285d0dbdcb8b70d223565a26d9257277a3e94f390f3b16ad419c8f674c579c9e865b412d4cdabb315da3e512fd69c0c34494c1d78c5459463d69a6b3470a75c20191d0173f1f70054be217afd95c1523c7e348d837044f1fdd7db5f3f4aa72f721f60339a0bcf0b9affc5ba9e4da524ce4c8d0146981fe11f11db13170129818d42e49cb0264dae5b0410104a874fd2b3864bad183a77688c581af3128cf19b68c24560f9d23d179d0746fc680eacddffeb9dc6fe59a22daa110ad212157d82c7e3b588345560a6e20d4fbdd714e4bed3dd3cfc18e437c1fa1741b1d089cf56bef36ec51fcda021274f6611a81c012b866bd09f510d70594fb95c16a1eed0e16eedadaa71325ce1345f75d432c4cfe5ed975c6b81c1fccb63e1ead7091693f763b8512809064d48b06db15052b4eb50ea2556c8731a77423327ee66ccdee5edebd7af8c47eca76831bbdba0f6973097d406ad78c03826bb7ba1d9d67b77ffade8ff2cee3fc2e52f38464c4051d0823cb70b7cf9fb21770b8f32135aa8d98da2d42bac8bd1c185b3be3534e238b84fd55d266c9d2f313d83668b3280dd15f9422e1d326089563f196ab4c8d9b86dec19a300f75f3ee5c19791684b595342fd59114b11536352df6cc789c493c85b3c036ed08961bab2efccf56533a25d5f3c34825797ff43ff508ed39fec794a814b504f2458e75baa5a815b939795c3411e4eac67c5f159742111baf92a957c9c9676455097ad7500e0f4087b44f23b9fd0d876a39d4ad13d2294cfff78aa80a01f8dc610b2e0a8104180b4b6dca36d77efb4e4302799b26eedd31073b331ae98a2bcd650fb650833960856345186642295e65ad890148940583df9c5184d7ec6f31dafd62593f110c620a052c322177a0faff9690b31235ea2173dac84a46d0a00b48bbe58a2ca79d2b47912af33a40bf98a970e6deaf9f149ca894df849c9e47214a5739bf3591978d0476c57942c640c147568d5a32a7a9762d80811619dd69414c3e691818050522b69c386a438b1d583df16fa88d7172529e60edb02eb59b4f6d222bddc5fa5f262f3d9e831ab8cc680330d15c3664fd930db20fa7779fd801826501bda806bad103495bd8e4823b75d2b593ddf11765d416a1efa82b5f9bdefabbad62e2495f483eda623358075dafbd39272707e7cd9a7115e398fbe64925ba720090f50511ba759dbc2fa5ecc7eccad0e135c6c44b1a565cf4cec7749fd32fb9e8edbfdc6c92eafdbf1589b163430a441692f5abc451653eb0ec9472b35c4cf3bc4311ac9de732b82835f91305cc7e073bb3986a3195873a5050e7baad0c70df065b26507755d7a85a885f0ee07909176665bf3655639160a28720d95b329688fb80927c7a25bf7ab18773fb71a9af353e165e9a3bcc7e8136c9a056f02420f8015f1d85b590dd2612f479649f1ba91834978c1ccad40abea6e8c2e50450f854bbb6c1ab81aa612490d3bee912c561ee6bafe343fdacf20a734104aa7c9af77d95682119e220b7d69f32d8aeb6564439c158a941f6032a91a5cff554910eb8a5282abf60731177ecf6867f8272fec427b9debbb2fdb8d9e4ed6d17aec49867b4b1386e4951b3893f378d5aa3028f94c6cc10685a18b816b3038a593202c9100971d03211abd46f7347a68d27ea90704fdf1bc626d817f26efa572d40bbb42b6f2a3d90017db6836799bf3fce9119f10c010efa3f788fb36ddd5403dc7b20c5de6a30bcb2b3ac8e976ea8569ec10fd5def51f9fdeb7dc282962c0d7376e11c878ac3c1838d9403550dc16232e16bebb973fb21567016b6d27f395e8fffbbc0cd5ba6b2cef3dab0f03eed0afc177babf046d51498432d1c2fa243eee1759c1027bfefc8aa7176d897cf47ed88c95954f267eb5b3ff935e653c61ff432d4032540d0557614c75a556b0a971d2b08ff581eb8905c9cb34bc3463fe75596bd69b967352d1a2fe33b2060bf43877bd024acb5f2761b3797eb2fb6a91b22f5e9f62d9ce5d166ea78d6abea7212cff85021ba886e87d8538d3054481372ab673e67a185733ff8fa9298e621a8b34cde4e2f637edb273c3688cfc7476b771a9f1c89fd51c7eed4ca9cae59abf2fe2ffc9e6502bbb72d4125d69a5849f9cf306e83c5e0a2f3afd348ac828e651028658f634b4fe3765acce57a50e11c54097a352a5c4508da6b5ef55213dcc3993525298eb092e11a3ae62ba4b193ac4536c20e461cf40c55224f02d7370c8c585eb607971e53db9c38fda1bcad595cd48801a2605157c4fd63b2f35cad5988ec75bd22b5e5fa02dafa58733fc02731c2d2f42b9b1d75b3e3cdcb89d5cfb04175f8bbcbdd96bffb6b0f61ea3c74c2dd7635036dfa01ca289adca48a2cbaf7a76ab60aedc59f72ae09ecacb0492a95392d6baa510f13ea95d2afe556095937dccc563aa9372751e44b5581b27649db09ebbf8edb5c198d1c9e7bda1a2b3cf9254f51700f38303de4c6642b6074a5d1a22af16b3065a5575d7efef11fc88f50b0f00db148c9f95a6de9b71ddc59fb2e6efef93219e858f87300af50de6dbb15549f678a097910cc4a289d2554fdb1775051e3bb86bd485038da64dec0fdf83844349079989af0e9ae6cc8dc5eefa4644a48a24e9adfab357d6226661e75047156e2b611b6ea2dc5b2f3de09ef5545a02780c2bb01610f3997b5417388ce4a3985b1c02de41d49ca8bf46cb80b3d32fb587a203148b5cf50bb2e1513010d941144c0d1e0627be2ff06cf40e5fa6cfbfb7553ead4e923934c367a14dbfb07fb31c9350fffbfca2ece0517373364d19941ef67c44b8c89c0f555ac4823a98388e5418381872930981e0102a0a61ca5b61d7b4548c076a5ea0fee090cca5c7a707c1cf082fb2f64a2df51645a06099444c2f67289cc503f11f56071c95ccd782e2e8bde8dc402fe3a77327a7e1b0d2a87db491d02ac5d58122b0ab307057f08c3f648a6e5d7aaf98634d129301252c8c27da6d8c09791c8bbcbd16aec73218b974aebd55642f7869df0d135c38b6ea0fda80b07f075b8f665e96f969490e272950a192be38bd2be16788f7d8b73b8509d49bff8e0984714a2fb4bfdab028d3950a9b3bbdc1a485d5fda49b4e8f475b490f36e2d10a5723ba0e2656ee341e63b13eb4c062303cb75525c57fb8d7b434f32416d64b92dcaf64671d0a96324e479c352a6b0b219e66efc0d3713ca6c33bd3ec1cadfdd8ffe94dd598a142306b631a2cacb81c35143e5ba390fb3c5ec1d2607cf3d8cc4f2502ea2997bbec8c1b79be5aa9b3c1e8f270b5f9c71c753f7626ba57f71eedf5cfd808326ffd6ed6aa4dcc50f798b18b2d5e76a08a9e945ba4568e764639f891f227f88bbcdd24f13d025fad8d6cfda4dee4c131b632e1c94a138f4b93b21a08325013f5e2cc460f961cc39ccd111a5564bfbedd481e18a831565f6b799eb89846e411baeb5661b2223cb6ad5f64ca89401320972cf2be485f4c05c24c1055654764aa0a2bf66ff481d865580d83b038293478fc611b40eb412427ea3f6b694bed17e8dc0b5323df63aec1cd5184726117b27eddc8f647a7aec17bea618c49af6ee7ce68a7bfcf3b5061ec2a878ba5c80b425144aa8be61d03a025b7f99c24ee68799a18efbe66146bdf6685e35b2fd04d7c27dc8cf36afa22390febf6489a6d931f994c45ddfe768370bc3bcc886565eb49473f5bcc9b822477beb987e37eba928e4d5798966d3facaa2f8bba546852c3db865ce82e6eda1c98acbea61678e6c052f46fbacf33dda56bfc7bd3095d7524d5485d88b5e2801f7e9478219777ec91891785613031eb22cff7c8b7f8a9cb31584b6de2bf3840b55a398505a66d22e53e21934aaa7aaaf7759101e8ba3ae6d4868fa8eb05cf0351a158992e6cd8cede0f65460bf3a16d98a4baeb4314d7d36dbfee0375b6f002367e46a968ea0a7bc60eef17af9f58d9dcaf80586aee22e2ee8d9e3b7eed5d91f92fa6b8bc469460ee4b8e8bbdd2be2a942ff1768e3329d7728a340210a4443383161ccf463694a1c114f8f194760d4df20ddce1c566c66b05fa960a7b5e3e2f367582be257aabfecc7adbd66b5fdcb5f4d54eb71cc15ab085e026c21c35111aeb1aeb92396f76a8eee108249e69d2db3b6bc621dffd017ac9cea703884135f21181657e248287e71d6a4639f8732888f28cbd2a1b479765d138240aea213ce7219d78f49d7899919d39356433d5206830685f59724a7f8454b08d5ba1907a298fde59d677928818776633a690cad12db4c0cd00b0ce6761250090091c67470083f5edbfad1a113cbc710acbcb0ae97e7fef0ede0af59924e579129e4b55929daf3e031e9fe855f64826784fbed3a89c78110765ce86fdac5efbffbf67d2e66b898d4ce216020a7834e9d4bb86407820ffcf841a2010ec891e71a25f00dd9d50bb40169b1eb74fe3fa0a47cdae25df916050787e61b12d22330bad194ad0c170bedf19c666232b4ef4cc916703e68d8f85306c90f908ef03d5d4c086af08bb651e27f3dd4b040e1b206e0c52146e4a21ff2c3bc5bd7fdb6b3b542006d39fc7fc7055a922db9618b0209cf78fd2069de5bf6296192150207fdfa329093d73f93f17fe26b168b3a5df5854a7b05cfe87f3fb72b5a2043022933170ecf36ee88c7396c51c793241dfbec8e00288df151e001e1108e46fbd3092d971414bf06429567df9233fe46362578750b847d8164316ada1cadb6135693ebc8292fc3d774af43a3ed70095fb0831ed31d79e2346b9ee2d2c483f83ad69b75e502434c7ddb3c4904288b456ea14192decdb98d67d89b3203c4e8274a7c5b4ec424b5130281a6fd1d07981cf7d9605919208120dd68b78b51fa6099367c1d1f5370847eb477d5b2ec233a55ce9e044dcc28afe8439768ef987cd4769b48b8ac662355922caadb831762338c54c5699d8cc4ee498927eb125007e673aa761bccfb3643fd0bcc6c72242b541a61a7b47b010c23fd5558e23e1e695adf8feaff7fe9129857bc8a7cd238cce906127832f330a04b917825bdb2b4524c7c5f18576961b4a41c2d8abbd0b0902cf113c3960225c9459a85dac72b0bb80dc3b64a9ac819f0f67b58d7e0e56ad1c405b6255f1f1795e3e3563a81bccd03f68304270f0c9501c2f1563fa5c18e4ba0abcd324f6b41c04cc2c8220c60de3debcf87617d43b7708d2916822e5d74a9c5d23ba63741e8a214abb8a31ca91a1537d955442fa85406b7b7302452fb0315413029f625078fc73e92164e5566f17caceb2f358b8d949b5bf995c2e8ea68f0155d073c58efccc7803a49936bf595f28e3bc59a1e02ae6c77d97acc800b4e4206d4baa7276ed071083e1286acdcfee3a4e384cd515f16a77677b6a846b7f4f427b807878195d929e6691bc0da8683a158d56f1a4f797f36381fef2da269008d8adeede0cbf0e2e8fa7407c53244f667c19c63cbbd290cd8a33cd852e4045db283e6ba5928c7219ff39a28cd85fe50e246108a2ab04938e1cac144b590b3e6904c5f19e27b99219f911cbe2458f236a90b9d293cc348d61119109a654df5d6ff2c55c3015fa0e9e2a2295f7f24eb76179bef0d765de2f520e1098150a2dd9a5bb442990ca648abafc05173e65855a92aaa584c1ea55d927e78929fb72026816d53a1a18faec6979edab66a6d71ce9341598d43741d4f32adab3b92db7f19693b7c53c543ca452bb90a582e02362bca5fddef336e440ab42e503eca00c793d05d8bf033f9354138148fb613ebae9ee16fbfdc8d90ddc35cf853a882fdc19a0a43e0f9fbc1348acc13c55607954eacb8f16fd399ad2e412a49b1bf71ed3749fd2ae7283fe27fead1c3835661201fd39614829fb5469e3cbad0afdb3b27b2bbd9e56e42fbf1b316d35babaaae0abeec4a4e1040ca338d99dc366379b08489393d80e260471b1b5a2a6d5f8ec39759ff84928217d9ea42b79e78425e7b2b9187bde3718d7d3f9175b53031407e6f1b7c912a9e12a5ebcb725559feffa7ae87b8c943fb6d701f95798a16de1d70c11c91735d6b662c2f4cb7a0bd7ceacbda78ce0e737491e6dd9f231701aaaceb62bbc5a9244abc605428758857efe0f9005e1b30fe956094dc0369e6b37d6f0e528571fa5d11752657255e3ea86cbeb50bc7d7adb4448cadb8d89d3d47914231313b950ca7a10f64803afc887ecb534dc9433c2418fb79f3f1f395c2c24e7f3254fcf44e75ed1c7a3120be5051435f542968952c72bc4de7a7b7fb63b0ed7f858e69e11e4ea0e4a582fa3764aeb491f724da94e483e0efdc746de358640c303d12e5a84fbf643e046a14ef03dd17dda9aec3fab46d1034f3574497136bb14169ea17cf387e784bced954c2e4e3ee152ed7146898c4572bb0b123a1f52e493fada4fbf5bc68055fc0e442b3e6524b8684b8ab7e667d17d5edc15f9a09e35c323b65cb21b244cb31c0ce6d433a668f3bf98978b57d332ad150820014ff5c5641dd5b3ac07550c44952949bd9683d7302dbbe660f2ffcb59cc2598a0852e7b67c2041f49653dfa10836611246f0a7acfc7916ef5103feced3f7d68daf9a9a3cb89217a89c07f431575b8b0c98c555b5343e0a875a539d0acdbbe5d21cfa264230ccc6bcecbec0dcf9efb3a2a8cec3c6c1b13e10511246c22369f3b4abcb01c8c80d2f59b11c04c1153c8c1535f7fec3ae3f195355048995e287a8f12dd34a921058b98c1cdf617dd0ce56e9903011dcfab76d194257553ed65beb00546700027ad8032e5f2ae5ec76375d6ca4f5496e992a6df46f44759baa7c78d474815f6a517238e34be57fe154fb6aacb38d883641fc14bd19f8b09906489009c96dbf35d40aac1a8e2ea9b7732468a3fa45aeb35220e0229f0fec78020aa2311e186706ca35015768ff246ff128a57a19410caedecd9a22fefa1f5b469a0d64fd370e3ecd7d44b8ba2883365b6b56b0e14f966f78a366121384c431aba402144cfaac58924f0b3fe9c066e0e2e4e953ffbfa957097550fd0dd8b1aa4d97ea624bc93b31b48a8ea00a7308c78acda71989ed89225371fd62a99c4b5bd37d49b158111bfa995d4c54269fa68120f59e7a651e0a185ae1baf1a49de2acca6daa947377c8e87eab2122ec211eb2c9927dd58bf99dff6ac895faf721a6a877daf758d37ec50f649c7dd9c22e93cb0f885baf8452907caa3192a8dc1aa64ff907d8e9eda1f9c032c08aba7e25eced7bc8dc6a49ebd913ba8bba7caa2231cdeddf63790b5b70d095b928802d687b64f324c7b616652a2b73cc05b59a93dfd7bbf4fa9bf5c929be7850d6134c4b7de22f8cf1054e8eaee5482a209d027fca0179eb217e2f37dd4d6ba15c456eed0ac569efbacb13d560ef01c2993344d5cc81131832ce58504c202181f1329f7c459ef31b6e9c4c45daa5aa157903d3d592f61cafb2d3c2fb83af0c7ae44e234615136315b8e181d562fa99f726ae20144ee3ef5b7f1c5d8d350b71086eea3423275ee01b12bc0728b62076355a74a04573e300085e390674b7add356bd59769734d996a5b6ef98ace2aa69f44cf8c1991fa4a11731332e28f86773ea6b6886c7d8e3c8d1e70dbc12b1b4baadc6f3e1ad5eeb3b72050c66149639ec1547b32195c1f68d2464810a01f65bf58fa690ddb9ab88d23f7fcc14df18fb19e1261ea4ce4fccbfd14b6642c3f04e4fa48af67cf03a74d275573a2554b908d53f0918b9535f2bb59fcc790e7f423dfd0b5f99bafbc55583ee569042b49cae71982ec53ba2e229e0081abff8e177af3ac42aef14e983d88252e0ae30ecd1f96970cb99d9843be5001564e32afa797b9881a0fbf53b4cc434310568054e3decb1c8f7f6e062e4453267e6e9aaa1a6fba4038e67fc5b544a84757a9f480dc8156646751ba7c9fef153d8549d78a745f2c205bb2d8b8e8055ff0c2e9fccb1dc7640f22d4e5ee696c8d0bdc0350633a9725c2b09111c33d82591f8a216772f3fddcc2497cfa7c7a9137090f0fea03a67e19fe5d53319013ddc47894b3e1ca6876c2e69ef68347fe67d9565cad00c6d0001b61c6da0522c584543af460c06f5a37523deb1d04baf18d649c6df2c2c2a582f64800b61fe8f607bbba2f035f39a4e3873b3cf8c2b743b1687e11350f3737d4eba1f34b287dcb34d3396645d550542df31c67bbc7ff5757bfa868fdc31a4d5a716977cc70004407a2ba015817bce3077a735fa92fb6c9738c8f7b32b510c9e5339777ba11cf078cf4ed5a1d558b5d7c3396be21ce74495ba2a4dc2949300dc550486595d0b6d347af96c6d0a17189ea300cc6843b47d150c4e118a092f83951398cd3c03ace96713ce8f3588774633d82925a4576286cf060c1234d4df44bd769567930203558996ee36d5637acdb7eb91ac1e71de4a28d0316f816a775c605800cc94bf178bd797d336f9d01627d7d92584bdfc35f43bf2d10187f62b2c2ca7b63fd8f9135c561e4e3e86c8ef08eb338a41f4ecd82a1f1a4a53b161b97a90a3e8fb8475c3846728608aa44f7f35ff3b2b7af00a53ab30ba3980513f5495c9dd6e72f22329e4be67abbc003349ba1c9cbe86a5bf4e4a410eeb91996a18dec769f96e5380f0bbebc2b2d9a5edd4e2d96a1e407103460993f1aa4fd843a0a8cffc41f6f2586732b83fe7e2d2e25a255f75d6e06bf947d27bd2260fe4c23bda8fd977c985025bd5fc743393bb87cbb86efca683481a69ff44fc66f0b469eabdd53b3bccc90a29d8ce4a501f0419d6ed9015548f8d450d4e31a3810ee9a500e4c177e2d19f5b44af31b1e78e481cffbd4c4c3c5af2631731049aa80bad404e56c33328ae1b7bfc9749cec5b0a601ef95278745f84a4ceda451b4e8d7cf1183ae010a454be902ef530d15a392f3b90ff9e6737f19a00355e13ff2f20c85b502e5ab46f4ef93b0f32189f9accde83a8880b3c243aeb4bbffe6c1eea89c8da59be1bb426936c967117d0e1a443821900158908d7b6ad706ce89371ee16f1ec599f7c6d244a44c609de05db25822ce13370accefeccfb8d6242926f06cb97dfb2edb370172b363cd42570c74e85625eafa29804fe7b0d48eec47d636d3711d3c89bf11da65662d9908f39cdbf3f9bd49b926a459220fddb1a2742e648dda23306a46f1bfc587cb708451f9ec87e3ddee853065af13150afdc4ca7f8e545f3a9fa140d327f4091db4d3417e2b943fe867da717a3ce95f1ae9280aa05a4bb7346e9f8517c4aeb94d9f69e85ed03b2c9f7eeda8065403eb49e0a9136b3c9af2fc9353a8cacd41ec1c8c6c24bdba39b5c2848128dbbfc0e0a83f50982b3beea7f67e34c8984c429239ebe7a9cbe488cee703d21a607be445100508c7ae8043c7a108f57efe6bc990a4da2b918f9a255a8b68766a51ccf83fd17c9108790574b9117cb1c99789ec6c97b3dbe37d940e7abb0db31a07aea4cecd64803d920906b69870c819e610e09b36f8c705d7e9075aca4373a270c4cbacc652c9f3f6d0ff06e893ceff90817b64ca99d9263e4e516265d232d1e9a930d1602d7aedca4312e0eb203802d9bfffd075cd6cc549e2efb70d96ca81570274a7ec1583088678112ca604ff19e9e63886e2c9edfd823da9aa8ccbedc0384db63a368f8708795322d63f11802b76f64666899ede78bfacec016b058d2ef7fba3c73965402b3ecc4cb478e18825f1c05a54c1f0b128d334cfe81a0aed80854a65d40d300c82f6ca29dcee6144dd21925e21341d1145a5162887bea8d7ab6da8013235da5262e40f66bc2fd56aca946b095887a776fbfe165afe7defd72204f164c02b78b887d35e815d703ef807fb9df27039a8fd2799fcac8f55c67c377be9d4070021a0f0912f676ef769153941de08a7bbb94239ff98754f0a370502b0fda1648ef71cada88d5eb41b8eb69f962e791bcd5edf232853bd531e1207","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
