<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6fc833b127e79bbd0d129c5411671512611fc107a66da8c43a22f92e789c4800b99375062ad4e3b6610f86d79a48a3971484be8d04fcb2f905fccfd404a9fa0a98bd6e3ab3f48eb935a11166d5b686648b14130f96d3e3098e62902582c630d7e9a7d7228221d0dba620c6eb93804bd650bd9eecc72f2f4acc7c8ad2f3d51301eb8331d4bf553989cda7af4c2be9aa08e0142a1fa2452a3b3621164a9892048df15ae4b17b07b81a9916363946ab9840f8df452c701cd10dadccd7057ae0b75c5f3e19c77643e435ac13d4b0d90bd37eaf7717474cbffe6445750f564a86794c36a8a5497d51233a63b266ac2305dad12e5453671c766947c163f73e1b7d40a78ee4151484f99f3150a0ea9a5b1b0e14a085c7620519d2558fe999d33159161e066d22839bb42e8ff227ffa21789d8a47de5d3c8bcda82d849c7a36e0b4e01b7fbc44a187cdf2185790317fcb736bee677fc25fc1f7d7b94285342890d48e0160e5ea399bb57883269e0162ecb75f9226501cde196894b79ca4459567c5df79a840d20a8a80b12cb03de4c4ce98dbce5fd2c59a9487b7747128dd53a77746b229489b31cadc10ce98e7eb2e52542a891c51efedb1903043c19049c5a076143383078479556a639248e333503251c4545fbb7ac6442ddc9979c0760acec7200e56d4711eab31cba5dd5b228c13a7891df0fc14ef51a4213be9a9208e86726e3fb3a8eafd1a99e8e32dc17d4b569c310dc5a2a3065d7bd5b1ef85db9976dc05833dab55dfe0c01a23831bc1baebce5b023b7960b12bbef187df9bb4bae157950ea5c6d2dfa6f99524ee8291e1030757d5dad8a5e7035972dda2a8ef22efcadb733ad45d1a654eab549bda93e9515550163d75b6e018493079e86d66112d6dcb6eb741e69d52943e49b4f0ca709e827bbc1db81e490ff1183f758216d87eb0d0d5290cd0f59f5b22227ed6b67cdcddb6f4b0bf2b81d8e224e397e949a5c88ad8fbbc1fb0b8f466de21e9fa2fd31ea74edfda0370c2467dddcf2e69aa4efc2e831de41b79e7438eb1740775d8b559924775268bb557b34344dd3ababa6759919aa4c9ec42a634da6292f3463571fc7f5b8f30efe24d307a18223e949eb092a739cf3526adb0fe524092c7c9430c8d7064d5956440583b4f75d5167b136b3be3925f4f1348e39eabf74bdf8a6c1d0b0cbaed1e73a8e7b3c17f901317fbc782e6b3a673272fe0c50d66a4623c25b3f47c9ef2f3843001650f4e5812cab35ea0aa30c5a7c7686ebc936d883833007ea064b0d0f43e802c689b15a8d5cb5d0d61723847ede0f8d1540c3e9397a812417a4998ea4aba3dd1cfdd330c3d6cbdc3f0964258d917730011cce47afd831855444431edf093314060c51323c83646595aae50bf58ef1e047ccd37a27237335d92cfee184d34a19ef953e6a6ddc6eff2964c08bb30976a5d1c18c28ed99dcc8dba175fc2d2cb4f3fe647b7bcd6f833bf3092c86db55539a21d067657e80d8cc457a7d88ac1fc04c33b6477a005567d25c76d73a9e43574d76c06331a396fe0d31398e24dad9d690d45370cdcf76f96afca86338fb9d69354109095599e5ad090c824291f71e85bcd55509e05be25e7b78c0a1a5fa13905a9af9c8aea654e341592e127feeaea54f537fa7e535678b1897fc7f5b86f37beeeaa47097b5aad7066b2302d4dcd575457887943a208e2f178dd6d01ef2647f2c7ddeb9ae69ef3369da968ceed7f5b8f2dc643c3c2a78e35491243d3f5d11bfd9ef50eb513533a0a31ca339f122f5302f0b5163273d114480975505c58e240ca7974207bef2e497ed5419fd6c2b3938d3afdb0fdd44caa3003c4517ebbea55d40b11c5621a8730095ab4894abd1a5aaf0803af279498ccb75e2fba07e4b33fece7553aac6a20bc36672aca3c8a32ef567d8e98779082bfb0ff981b5d0f40977825d4e3921df62afe9fee03a7e5c6f715991e6d06d24f620cb5beda650806d586e756fc04217d18eb4c1363a40389c48bc6620ec279f6ce44ef05cd66a534489ea7a9dc842389f9184a6e0fbe2add616961874fa5deebdcbedf70acdd3e92fc693d83d69bc46d0ecb33ca2d1c07628af3bae99662179754e5848f8cca4bc89d179063d5b205bf0a48a60527cf893e796cc5312042334f292f746fe8b105d1eddd6877997e8451556ab79f0f41e766b08cdc0a2d605a6265aa3f5629efd1f331ab33c5e7b99feaf26a519f057eb48a71aaa1af8000896e68ca2ba22b2108c39fb5ee30783cdc88c8e09a8658644642b362e70aca11a1903ca7a9ed2f1ef028e8781d7cda36c00a623fc0c4776a5308256bed19b8f87a0d2cf5d39acc89fa50549d3b1e93607c527b41a1cf6998bee31709a500a034b06a3151154e63af618c4939ae9aeb6b43839341fbff32441ce2399ef4bec6905416c5399aec30727722bb1805684aaed8e13c1b491b87abdf2b65e6a751860a85a53947f562960415f08dd443739ef6d8ac3fd91439c759fd6c3b25c9ea6f71eeb0d8a38263d451cc25187c5f9d48dbc37e5905a1959a08e7c09d2e402a6bd13e5a483f2c1fe4a1750ecf4aec3e43fb862e21c4f7a2eae69ecdd774da80ff3eabfc8bb69124f1b04827982afdfeae830f7eb573a1be9136d2c2191ddbb8db7770f6714f0292e880aa83c82d05d7cd957ecba14674bafad61a9021fe7563cd670399af0d36b674e166819a9ac6a3973bc95de5e17967cd514770dc2229b7c60878e617a6abded93fd9231b64bf6ea55300b1c53063e93159424685a9edcbf2eda0aee7e2ae42920bf49e996f2e60e809b40bff7dd9998f97db0d39a7b1a78beef0701524a2936133cb9bb06023c980f57a4853377f9835a3f926c1b643dd7a29ee5507cb54e659035f86616387069b37b982b77a89bcfeeee3a86fe52a3c160b8bfde5d8fedf57210d55b32d243a5a7e08a54d7c31f70c8a322d5835f81d2830ee0715d6c051d128d2fd66b9c508af7f23888884c0b8e8d0b989285b04fddaf2f545835f9fd2c10b97b6cb0b888f856bc736bad7669e8dc47cc22edd9259c67928a605eff3c2ed576edf00cea021f9ba78878038948c553215bfc979647565af59869af8e47fba91ed6b6a2cbeec925bba3319e251d14717c608d207541550291e8ddaecf4b66804ba908b19a2e6a819df34426859751214142f399b9c170cf1ec063eadc8441adba957a9cc1ba2716c385a4738d236d2994d8653e0037b384f36bf8b1a0d2969235d49ef28ed10393852d05cbeb4b236f787c83ea1d17f500c1575150eca1eb30fe285200ed820c7f78d53a39a3a7f5cd8c0e431faeb2cc801795721908a7969b18552db8c767d01362bbdf0fe06603f6e86c7ebb554825539a47b464f40f53d1c3f8f4cf90298f13d8e28d4664c85b679507d6a54e9ab9f414d4ac120b3881d824c69382d6abd491ad7cb6a9ff87997fd817dfe6d61002d20e875758c914cdb9801c4d2be8df13a152d4ab1b2e05733ef7cd72a49f476a3d0952f4d21a87d507c6090bf2670ddc0bab862e6b9b22a8848e452f72475ceb8a2ab9e26243dba211385fef51e44f5a8eb999f02c2050aad654e1883b7a862d846093e6766dce759a5def5986c331872cc7c2432d4c618a4dcbc3b61e687c148fe29be6820fefe040de26bdbfb7015b230844e5cc97197c67fe8fa32f40021d7acca1e8b12ef69823165e7c530fada717005c1e3fb4489ac1db11f401f861ec5ede3d8286ed591094d19af2e0b3601853a2b473e490f2cd1f9d9f8c975bb48499906795c2290cd0e670bada437a6c257b503ca734f4de372eda91b2c8ccef466589bc97ea5ec9fa7d4373262e53a5d6017d0da2514b56c34ca976b5767ebd8dc7840197ceba1e6b0a0b06f2bd98c3f654d7ea62170d22749f24e865a7bed4bb60b54e28dafc646e97e5773147be154406bcd73c355ff0e39a5613ce6ffa287d6f5542199ad5346ef22ab68554a9c3ccc9a6f0bea8e1a4b189197ad55b2fa1e51603cdc70ef79ba4de020845091fa95b3c641e7f690849f5462e8a790f2f3623ac11cb36f6cc67d25ae39ba9fec36ad260684cabfef65682f7b8d424737f53ad821fc3ac7374e9552305b57c4483eed7501312a4ebbb6920afffda020773bfddee33b5cf5792d82c15a0951a34bb1bcb2cd2bfefb7852d6d4d2be1b8575d71fa96a9a0f651b3ccde6ae6a7990ce361c8fe7d9487622fe0ec38cbe65ee44d13be37d79ce6d35a934f8cabacdee9b4e063e5afe94963628231dbf583a88d25479c173a9f0f818ba8cab77b82a26239bee54e2d03ae655aa644b747e91dc3c47f1c06746baf08b6ffc5f912f290bfa2ecfdb340e0c9d7974e01887486fa758b7499444c016a8bacb7a883bb09b35d56ad4cc4df821034302125686cd7ea62559185c9e446a85687d6e9c667ab857e657e6b9c916f14980e7af21c6652eab5cbe92dfd8a1da92fad75a3ab732487a652a46820a8e4be1e359e94d0e08561027805872b627fd28fd6f8783fa87a7366686dfaea0195dfe14887059d9aa879156ba9235ca81ee8a1ca14a656e5b330a29265acb9ded534b3f3e61f59850007cfa37286f051e0a24a8a20cba54980b86127008761b6f556fac6be35888bf0200350a5d10a08187e76307b808d37708e59a94d4dace9d96023ce37d01905d28503591eb9f45a109377176832dc05fa0b3d99f64f902ea6f6c2b59d7b961cca41e66587ebb8a28828cb796b2d28e8df7a51fff2bd8236237da262ad38a93ba7cebe692ff132aa6250dfef5dfdd40473d5aa15bf087991f37e4c4771c76fbe245574615828f50df7a3bebd2bd3c852948259237b9a144c05974fa9269f0cf894a7345181216467bda51deecfbedce6e06c107a742ed58a0ba01e11d86d9c8ad14e7cf2352454b32a7ea59290d54aaf0420c904b0d8f82643567183a22f5882b0c5a265b1819c989f83b86d45c94c1788e04f79ee4a3bd9fe782d04c07378ec69ad6237d1f8da5528d8857a3cac60ff9417c03ea9a35f6ce2806768d4c63a97a410ef0650333dfedde7a2200986ed0b41716389a72cbadb37c91fc8182069f6cf4e891cf1f9f9a62136a84fdb7c0ac1c3da72848b9cf486e101fe2371d2d2223aa20ca84e9e35e56daca39002b079d2faad17d895a3d785a46894068fc67b5d23c51216955581090fc0c52f65fc207bb0140bec0278ff6fa01013cbb00937c23c283858421bd960d8bd2e0730e112fdc08f960f8b9ab89900f955a40d4a9eb292ee05083a78d921df11d8ecd5a30c45dbb478f4e75023570d0635111b6fa54684501959dcaa680311c545e5dec93c4f7338011eac3000e951238049651b93e1161df9af13916b351741fbe0ecd0a524ef6ab265613dfa94d3ce6790bce9608674e956c25ed4751d148a09f52456d4bd38367cd21275111dc06c85914028a69e86a7496bae942df4038c11d6996a83e59279cedcce04a332622ac5fab440d8ff3bde90d4da406595fc5a8fd0fbf1f111eafef1843821ea550db310857a83ccf0ceaf78216e0b73541a6482ce0478d69a8ad216dab0ab55bd08c4d9d47bce3e544414d5cbab01c5423d0d056518221cb7bc0309513454883c2f28bd9eefb08a9be22e3648838d6b047d822a6357ee99eeedb269d396cc51e1abc666378cd06e65d17cde5d58697099c33892f0e1c17e11fe220ed3d2912932dc578cb48880ecf6d143dc82dc890843c6d1262457a3b4d982ad853fcdcfaafd8f421045aeb28849a4236edcac9e11e892367ffee8b3bb4693f0415e39bd13d0d465b1c5f742de513e27115aade9aa27f75a9cca766c04ee5fa684ec15fb8bb24a32827dc9f6c4ec6f74ed40a8e8a52f1d44ba0b40d3644ec5eb48ea6e5d1aca6d5e1433b6c14675f250a7e754c1e17c476c0e0126f9fee0abc1ed0e637954857fc6159a68014dc6273391f4222e92fc20721104d3ae31d0ac9c4c97674df548bace077601eaae967bb850bd17ce574218d1ac5921f0975de45c026b3c4aded703b6a5084c70defa0de2fbd560d938e646ac5a4758a5b8f2f6d72ea08a466fbfdc99fe7443c23772ef9d2c693ad9614e337b5e62fbf3c6b851567ffd48045e93fa4b69bf9f2f50ef569374ad5fd2e5862034d9d630c864d07dd103a74dfc68257fcf475d251ba49d0d6e16b29ecc9d6a7234486c4337cd7a7203fd54fec5fd45cf91ff2834c3c87dac5e0afe079d9e6828b998d56b42509eca428907e95b63e6798e7b8677a2e7b4d9323c2334fb4441da5321b001b6f6447f985b17a5339bca5e3ed38a10a876a1d4d85670cd7d45a65d9f5c472e5fe2cb31fc22b8feedf5218903802b23d2d7ca7ddce5112886e8fbcf12d93e6206ed66c70e45459730cd34faf975b3ff293217f6050c4ffb73c7a5338a9f6f4c8397952ccf181fbdbac3eff133369308bf259ed1c23fa0b192fc0fad73901197724f2d7f91284e1dd3ee8998d2a1acd5c99f8ffa9694e0e98f33cc27d40441661b61eff69d021ef3970a43322b32a6439ab0287f145f804a8581a88194bcee92f46b652c34ef3215a782de81ab8c53a58bb0c356a58cecdcfaa9536b6d396940898c32ef88f8eafc6e8a0fe6b0a374cbb55e4b69061bac392bcf1139a4c6d3add7409de710f2a1b8bd0b5c608bcbca6fa6537487435cdca8e15039e1064403f136872854e0aa8db75f9799140ae5c1f006c961a9d1f8fcc30c285e7bc6065977f403e6b9e9163c6638dde05714b7973dcc5d59773acf99c48185399856fdb1ec8706e4d8b1a4750cea72905826e93dbd7b7e4de8e12906006a1e4bd7fa3135559b2695b5c6dda89ac4ab21bddda9d5915c0d4fad915f773517f23785bf2e06bc97a31493d2723eacf00634759150234e06922da5247f212f98763b58a4f33773484365f18cc8349da8e19005d96d21dc4817763a309c76c9eb25e4d801c60072e0e43171fde3ffd4eb86360a9cd883effe549fd8ddb9af4a52b51a58f85c3f130386580933bbf20c86208969331541c116b6557d9d7d5d1ecd2de8740b614e89002eadcb61b4aeb40da0666e1492b23dbade163ef1055558764474b9fb8c6b30eab235db430bd1101d6e47d3fa4ab9b73b00035640841154655a049222819b28b5582771228560be2d8bbf3aac3876bd94fd0fea1f5c3ad26be69fef847b85907dac8ec8132e3513ecae73fb3d3603ee17b0d5e5e616ac3068f44b08d0ac997735db5cc7d549c76ba604e1784e3117c214f9fb95860e4135a918244ce78b6c9cd365d397de36c9f542323671828e00f8f33e6fcc61693248d275785143ba9b517ea2d8a8e48a8330854610f3b9970d2b255be1024c10ea851fd1540e592575b7d877702eee9db8e3fdd706b774e2fb58cbfab8f0496caed3ed9bca1840a3a557a8e88f8166b2e1d281cd21a049071d3ef888ddbbf7598121cb84d6854641e359b4b65387bf12393fbf4d810534af094148264a0ad92048ed3b7996cb70d7404bb416559572a98428df4da1b2febcc7b03ecf2b4da3e179aaef20496465eee32f5133f703aeff07efa8ed074af56b1091f800a2f68f9d511dda85cd6f68e47877bf45eebc9edd2fbf34fbf43ac35cfc6eb5e9f8ed3f664c3d29ea2517869f2527d4454ff40cad861e3e7b9c1f263a940e39c60c08b5387fca8719772f824ef005caceda70a2372b0357387599016f42e093175fd4aca557b5d230468b552314db7df9498668a2a111e0e9b6b756297ea1b3a29acff8eb8e13a2db3705d8eab1350936aba8d3b8295cf8ec4ef85329627f386e70efda7b0853103f08ae94d87a5586ced8747cf5fb9f1ca8c512ecc3df0a29d5380067168c1d5e429d6db2fe29bd41430d795451c78906a69132dc03159d4220fdba8f52dcf3fa724f206cacd29f8f2a9393f3ed96ea97485abb7fa4721a93da801fba89dad31e137b35e4ede5690f3e3c012edd7c2532d5924b55b760a6a9e1ad0bfd751db4d338166f64fc311bdee473098798990f8aa5749cedb3d8e02956ef9a46be1c5534c6799927a38eb056ac0018a44545d7b765145cba641ead07dc10d9c427ab16213be74f3f05c89f3f4c16ab16c7aac71995674a2e602c298a656045e2f34af128f73bde98f4c6d442af215f322fd38bcd546666ae1a1011061ae37881cc3666c31b269c9a4cba458de390f360eca6214bceaf57dd0f2ba9a09116c2fab447b38879b304a372cc7d3b57c481c321e738623b73417f229de46084877759dff2fda0b175126ee852b1ba297b43edbe0f7f63c984aa275772a6c02daf98d1dcddeaf1278cdc6f26d525e4812cd3d2b385f79be9f3b213250f7577bc921acf3cf5a3776b008d09b668a925df43774bd0252235e4d67b3e36fa93b1c09e33a35349e97ba4d63347b2f1207c0ae74cd5b296c1ccc6a0929e082d4a2c2a2b4865001da5d09fdf908db9a1f1dceb9ce981a439c32e7c5cbdf4eac494e20a1ac242500dd6baaa6063143a45afccda69f535f6cff0ef116283ada2f852cd5e326d2d2a15783a331575dc101196eea1cd090ad0bd302537ec7f7954db8cbbb9082be544dc297d3acb5116778c27b7363f210e83490938c189866aa78a8434829ebb2e0e9ee7cbfd30be3db2c1bf0af7c3a2893a73af744e1e9fbd0e72f4b3946203adadae9a601965bd0c22638a3308aebf882240fd772ade30de67b742ffdd8b6dec72d0e6f81875f25a80ecae236b82823bfb85b390ef27c2954c1673081d7bae2decc49e21302630103efc1680a360937207cedde67b60aacc4a20edc96b5b84633f323e9d56c96537d989a0ddae5e3cb20202acc4b0aa5ed85c52c145be30d46026f25e14f23e4b3f4ff6ebf0c54aa233674459bdf3e2ae1bec850f4125b946e3f1d7441bf8a2cf5aedecebc3d314890264794cc9d35c72d0fa1443fbf8cb7230b7c5575dca76ad30d6c4d1e48ac42d41c10035fa18238b35a9df15876b8c13b996107832cdbf1c9c838428228965c42bd621c911a0d07c003ca020096a16df4ab5dc669857e1b9486a647023531ffe458f0d763113682b9a28db7b6f672c9ed477ca0f7d9caeb03308119ff7bb6c54d4f1ddbe2ac4c5cc87416efcbc8eb2c3351f4d66b18b07da9f8694c4441771fff54ef22f6f45a95ff12e9fbf64844e33f0edcc00f57d9338c1d6c51bcb79f282916f5f7ac2325693aca80f61e93fa3dd3e5fde30ba3756781f4a98ee46acfa49405623f68874fc81b7ba68accc24b2d6c2687dd274d7b75d29162e7d94d473f3271294e3a9ee2adf962555a17d8829cd01f0dff92e22ef5997300dbea0970aa1a471d58f178254a159c8415fb3b80fcdbe3cc9b62353cf855ccd033a14ab289241e502b1eb83e1925b8bf596c5a49d3458adb35c18118e0afa74a92f9479a5a3fab113fb23bce6a9eb6a6f61ae14ee5447ef5a76cbc2cc5db1ad143a8d0bcf8a677d088f311f10fc67f4e80a024354dafbcf0510612611eb7326e069700814d7e2713acbdf14b53df7fc0ae4c4cd7dac11653598e3c147cf376653d2dabeae26368de7ffb38230d62f8aded77e18e07072265f30780e12629a5d52ce5cfaf13dc713fd1d2d44e34e555d9889a90e16abcfc5006b458a9eddeaf0ab5b90863fa5b40d32347b684c1e4712d078011df00ecd67c5b28393c57c4775f721630aad5670318530d7bdfa707b5af32f6ac497ff8965aa15ad367f071af33e15446474b882c00c10529d72f80640d391b761c13ba3fb3c9f3abe87746c3bfb4c4d89298c6ccaff5468e4747c9e0928034080e673ff9a8a530909fbf75915c5d3fb55bfa012fc1f84f5edd9c6bef32566e45b4d236bee43c5444082c9f614b2e10dcc766d73fdce7e08cea51d134eba5748ca50a98268241da1aa94ca4efdb14b55c6768e124f5251fc1218ba4de4000a8e4fb8b146324ee019ae9f4324590eddc88042a5ec4ee411b9e2601d740af9c5ee6012c89558135c8315891d70c4af5323e2f6b277f20f83f3b0b43e8895f921bfc5cf3e7589a91c7865426ed9f9a1dd5a6395d8c67d63aa2eb19b3aafc556eb38f4f0c2157f8dbf30bf1ddb9d182ab1bf9c26e4f8712d719b3288ddc489609f1d17197c4a3d5a20da4ec7cb1045fe8e0a7b528246a30d3458029fc8e4a55e981c8bf4586a1fe5dbb47330b85fe6c8375cf0ab48d22ad97e9a63ffbdd6daa6d6a982ba58cc0b497694c0d04794bd50102166a761594cf655a11dfb3223cb57221fb25349f0048f61b1a109c9614d5b7164eb2416769aed2f002d696ab73242542f85f058c3462964709a305de7d89678a675f28fd047963b59bffdcfbb7023378cf7a95ca99d9d49ba8d0700fff0f20b3db0afff4ab5bbc442833e818159433b6bdfdd3f8eb5c1da496a3d50fa53d71187091d87e2ffa72e4adf9f6610de7379e251de11b9be7706385e4bbd03eb1a495f593512e83ec32410576b44f654994266c7e795f86ef4c88bf41ca06c74a2adfd1aeafda0d150558435c196400ddb4bb5dc93d797da5b2104829378ad0acc0483cfe6fe7e253594d988418605c9eb56a0e9abb828c51423cad3327b2a9867b5d67e25d90c1fff6c94afa6afe62222e2adefcd29b5c38764865140f7b745b4d4dcfaaa7613c6d4760dbec15e2f323d11dc153550a296f42b5f4e296db598c86fb1c734d7c055e85cb80cb149aaddcf451110a9855b7ec9e3901de99fe4c0f2495a954f89a18b89d7327375c66675fe8167cb3c98fa6c9a655a2c73a7e6a319cc9fdae8ba6b9be502ed0b37fadcfbae74f513509ea436e21107ed6a7b2e53869e5dd49b4b2de3a878f4ea0d80816ae306dd239946aaf5b5d18725711188a8cc441bef024cd04cd60b3d5416358057da660cf1ac032e5a98772e99af4775800a15f5c0e1ee2922084a2192e247d00bca67d594a05d1a264719ded87202a4f01615aa1359532cd4087a86b1b730902552cf058f4e05cbf9c4a50329b14b1d65115955ac0728eb22ffd6accef9cd9aff6857d12e40dd855c1ae1b5442cdfd87c58f6d695524f0ff81a4a7747ac0e0d34bfe4b80db1f2ba38daa47b80853a53beeb26a83fc9bc8ebf0432e91214949fb6ca3bf713f3d4b4ccf270c9bc0ea64558ac6f91d524ce9b6a7dbfdcfb344e176ae7afd2bf8369ccff238d5b944ec9ad314160295410747e0d924b19cf767836760ff03d81de7f1078bc90617429600c731b2c9025b2ee99d1351939d8711a83676a6e210eb130e764cddc69b63e684c2f5029ec701a4d025588a6703ee8e2f2ae898ee97bac3353b9f1df99155536fed67ee8689982ebd42e5a081a68e671c9254ace16cf8f417e59436443840a3fc18a61cc8e6e546d0c131889425006e80b010dd01714637af87a218999851f5fbf4cfaecaa751506c01bd5b64d52772452b824182a9660a0abb6aebac32f59027c25e6a9b435b673d2e7040d9c0a2200c0fb62e82964c1e971186fc9fc5c8ff49f72cbaf202ca6540073cdb83d5bbcc360b3e55b8069e798ccbfb12112fb9f13011b85c44e701bc1f715b7f3f2fa002c4524b6fd14ced724715c67b60e29b2c709f79ad588d3916c51592a4a718fdeb9735013191294b1dc231574691ee34bc72730dac55434e7fd166e0fcf9d059f9fe1aebb83e571f0ea6a0d0fe1453b122d2b945f1881928ea2779493bc8e0e029dec44301513f04c452603757bb8b9b91ff4c8de5bf0eee6f5cef428d7e1de60e8c49140a5280fb3df604615edaef1790f0069286794193bb7e90fb75390135705ffdf69de101c4069bb3d45c036c5796b2e11e3fbe1532e7e0643a2f8a1829a17e6505417cbd41dc972068f8cd63d56bc2d6d89a176d0cf2e92ef2ba9d455d65fe801fb1b55ae3bd73f759cd6f4201b1a0505332840db072cc85e09ccf739ac3b6467758462c858ef85ddd4d28df77d6b010b0357239237d36b3f95cead2e09c9c5c9e84d366e6c4bd7d0d4c8ad7df88f1c21694df63a4e3a141a202f8fc1d1e0db5c6fa490534f9a0f74b17bfb5eae0a2f8569ff5490c433c5a32066236a207f1d56020d77e877642563b6e9f73263ebf9ed9944394e56c7032f14db322290377e436fa9fa248c33ac0bdd40b25223e16b5a39b6a7e3ef0d47e6e98779198e893128a7089a9a6b2e3952d0a4e13780332a57a9cc2a0132c483f25e2838f197946926d12f5c8a0435db3ab474ca53e01d5629b2e9b2a56616471d018d521d81d4e0180b2e92fe2e52d555a3486c881f0c2607751da79e569ade188be48e46aa4e3ea39fafd564f5957bccde99bc93c5e28e7eb8c91888068199dad5fd7fcc5df9d2135d6c9825a68b1b927d4aa58647c5eb8f856228cb0c3d37705e44955eef21b756eb97ed8cb9980f325184527590daea7c8c81f1f90f6f2e2660acc34fc98a963b90c178a39f311dfbb94dcc247300b2bf90f1b1f719756e431bcf0422cbe22b67bffafc03a3e4cf99ad99a7fd6e2822cc51c34b99c492347aa42ace024876301cb17bdb699c4a49df25f019980f46fd3a921bcb9c2743a79b5ba73f471821ed74593262e1dc50d5f5527e49d23d16d15f916592ce3b08a1979bccaa7a1090294ef905bde0ca5eb562294c49c854f797fb31c005767d3e9bbc06dda34a64d3e593dbb224b8e1871f2e59c84be25f75770fd76316414eb0eb8b0fbbd24fda24007c32219bdab9dded353dad4d9560dff597a7cd93a7de36c4b41668e3a8cc763ab1e10181dac05f60bd01a79eee766f7d1a1ee745cb437a32239ff0b6a6754dc988bf1103855be257e918cdf6e5eb605560a911f861473ba4a1cd48b80053a7b3a1c45f22a3efb088301b366136a00b1b279ee95b29c1ca9e26946498d4b2834e2529335f3a2927b6929f8af7ebabadd2927964b0184cbc92c4282313834bbd047ce26399d5d22d0e4955a4f608587673e3ccb1dd8b92849002bd79ed6b676b41411ec789f9c1418f7819c7908b39c31ecc847e3a13385f71981cc27f64f2bc470d238b86342d059f8bedad8af3936407197e7c336b19fd628104fd050870e19fb7df84b27f028766cb5a4e7b4170ea1fbb7f855952ea7f8b3c6a1bb1a913e2d0a944052ef22d56b3046894810f646480e93f8d6fd3fddcce046174c6cb580e276239cacdd819dec561e04c1a60f6a797486043512644f195464381a3cadafd6bf441e6357076a9dc89e5a96569114fc62db4b390425e89d9a39a6fce82a7edacbc3b7cc8d456419ee5993ed584b278dd236af2d2774303b4f093ed7ce78ac15fd2f305c84c1bc187464ee6dc2b11e8755a3308a0726cb65c9ddaeaab61a84cd903551c7add4280dcdc2b9644e3f676d2c7ec91f2d3afc9c575ef4036ff42682138e98223cd7563d0a725eeaca28bab482ea10f8d0cef8817b81e107b54deb0124f3a25161de53321e8b4c89cfdc182c4b0e7591d0902378b3c9f1d96e790c0270dc4c45deb2b9f475785d43d8176f1f45118bb6d1730c132321f52631249ae294eb109ba277c64730a90909057addc897b0b48001b52a584e4dc433305a03481408bd4c8fa8783bea64e129d1a0fc8f6581608156848ac15c1a235850a50423d8bf9401172de3450c7049b3ef7ecaa138ffa1d559405dfea1427a4ae65eb43acf45d09969f8eb5c6e52eb71b55792373353d1e2e4e8c903c32d730379ac40610b1a222a994242479abc9e60f51efd09c122e022d50506d88d2bcd7a8c341d31c1591ae1ecea489f7d7a9522494c7c9de672a81a4a627123677a3d5207e23a6488df54e5c5a27c58167fb1bd10edda96e1feedbc4208dd99e306c6e7f8d521cc0d2bbdba7662fe02c83cc8afeed4d20a4ca0fc9f5d1aa5cf9da1965f37ded8628298b3b0f2ce825952eca3551bb855f1fe9ffea4d0b0e6cb9d6a3bb58fd8e51f2bc2df94bf339f2b1234f196eb61cae72a2fcd64600e0f2d92ffdc643147ecc1088afe27ea472527f3377ffbe7c1ab58c8a3055990a99cc27be858f6223d9d13d581aef41a433de0488a1001d6c28f651f57ed9ab8068c7dabd04b39e76599ae9c171fb85c71fac666d61306d4d4e19c2e58cbf53cd02ba904e22b6a55a07a997daf90d022a11102e309da4b0f5d985c813764ca7cab132dc0ec325966a6bbc063c9200310a861249ebb664e9831b4d960c4d99ca861d20377817610244bdd812a3226edd1271ac77dee3e8dad92c484371e1eb810be9248b99e5f5fb067a61d9de5b493713f503dede9c7f4064c80f99d4696346d8e694fb27f01560bacf4be9a4fbd47b2a6ef936c08546bfcf86bc0fbae64785f8cdf4cb05cb441b8df64d90de1d1037003c8ec7605c4d64e3ee26aa9074e7afe1b9815d5db23670c41d06736e2cfc120ce0c2445751215a39d040daf24362e18d9c017ce29e3be7bd0658edbf8f0981314996970904bcee5f421e5df19ae406e4359bb379bf89db838dfc623e48aa19bd3434c42fd9950a8aed81ff1abc2b48e4606e54f44a41f516812aafaff7099a1228678125566dd92c767932e309aa631dddec8bfd1e0b3bc8a5b11b79cce5374edc422920cb9361b63c10513be68073b570385643449289a4f17617ac550c99498d2b32a673a743db6b480c2b144cfce052a6f2c8a2f916ea2c88c7dbc05faba4630812659e85d92396e66d9569311ed7d2a13caa2f626f926334fabd1287674c9df06500e8b36318f26e0911191c0eadb6a75bfde99017f4668eee83b7de823bb7bb8ded1481387b0c65019f7e1148c52cdd6d42d8e2f8a5a1ec26287d52ba81607c8ec8844006c878754139751d1ba57ffe4b63ee94793153d6e632d34a57ee6e4d28dea868fd17ad960638bc44c0f6d6263172bdde30aeffdec0b13294c08a71281823502c3cbaed07535eaa79daccc756503be3c667dc0c5c46507b3b0736862ac658dd9aa65d31e3d3678a3dbb46071548bbbe6e4c521aa439af7bcc590f723b52a10facaa838043a119cdbf453300977ed91679b230a951b840fe6c6a1a0130e924c5720584a6ec1eee8eb538414ce777f637016572704c3e897def0c26c08a360ce4beb4332974d50cf631f68b173bffc3bb4fb0d799d2dcdc76fa926ca207d9ef103d1bcb0a21054c5a46a07824f757fba06f3fe3b0d8ec920e9576d4077a309ac942fe295c1fca0a4bee842a4f4ccd986225f9db827b2ff86ea3539aed8694e36f42a4c809ff51c883c15fa35d1c76c075f690eb4c2ec4e3997bd6e12abb298538b90373cfce93ab4884664cc7992b5c9954eeab06977e6ed2ea731f6979d74d03506d555646047f793b1473ed7f5250dcef0f909eabb8909c79900a864eceb870a065c1b25fc1cfa00ee45c6a2744dd4df4475614ce0a305d14c8382ef3a0a050f8f2c8f9e1b1a7b4f486eac26f9f06941d5c6c2b821c0b22ab73c5ad5ef31856487814442f454c15fe7df2a7d21ced647f8eebc5289e50f1a8ca68deb81c1dd0473339e5ad50bee5c7e7c9b963bd71283e80c8e73564ebdcca665209839fb4e021a7835e00ed38a570a1fc044841cef8517e871247c9e04000772eaf89cec098bc4cfa02b314432538cb61d7350cbca93ae47c52af8649105381e09d58c8a2eda87ff65ee7a2c665c03b191610fb4ee0e894e7b8f7d447eba189e08cf72b2533c3ec805cdc5c7473fe76a0d0cb17e4eae5231be6a1bd4917ecb638059be418b8b81916d4bfa19697d8029869f3fb420875314e23468f7d94e9773a3a40ae1b0141c04664203bb638fa0d942d80a154fb6d1b6d4703396b860c325e4d059a466c091e2987494524655474e495d0614e93b7f7f73dd894031be8d45dbcc2951f0d136fdabebc7f97d118167cb19aa70920ec9994d6c51034d9bd73b6f80058aa0e3f2671dd80f073b0754a14d335860447060a3140feda5541af77afe12abcc284c735fa456f20a275f54fd0a50e542efba51e8d0ce2b7c60a3cef929c57d91fdfb9a499ec0119ec28d5604ceeaf85c7b797a73ac770beaf3f1c4155bfac27fa91f56640eaeb6b9845c90a98c688f7ab02d44e5b2df111d11eb6427f807cde5ff2d80e26cac9155de13a8e7f10627056c9e6a44e036be71712c5e98a6a1f98a51189224193a5a58a090fd32aa0a95563a87074e4fb139986b74e932161b6494f836fd8d0ec570c62de072e73347a243fe261bb6896e487af1142274b952e87b977617179af18a42ec3efd8f812b27a00b217947f8b7bf0e0c29f979885b333cc6a2fb91c9740d6183d0d0b17926d5a090f700c4b026246346611d20154c474aa3e39e430a258e08617d055c2af61a3f098c9fe6e1e9e399d38d74ba283c46230b009754d04aaf27d5b3a75b501b7c66c0b779f88225217aa419f70356f546b27c531c3ae6c649046021f16712cc25df58677368edbe8f9efaba7cdbe7ea734b0ee0b4bb7278c9ce67c4fdbae393325e0c404ef89a60f522795bfe98875eedcf1308ea1edcf92347d87ba4786ef471fb056ca92135f7a74abb99f0f87867ce82bb13db567d214c3f1e8dc805f31f766ed781616296a825697ba79cbc984374c3d2d0c753c52dff18cbf41f4add1b4028bc781b5a84204853c23d15fa9e931dab1c1748974d36048b5855a9533e63db0e0415debc1eb151e59abdffb30db4af8b5f748c844431c7aab866145b5dc3808eb0646d4bd2426c67dddef882a6ff5b4d68886499c5c6470ae8da942900e5c79ed905a0f3dbcf89353fdbfe218f4606d7bd82405be381456d3e3db6cd08458b5c83cbd4cda2005e602d107e13cb3a7e4cbfc4105eb31274f4d4c63f9afcf5feacf8e0fe68da199d9b3da809813dafc042ae72158d74289d210bbd2b001004fb62e23a9fb8472ef558ec76039cd2ca877dd439b45d8a9b2b7ac70473000308243ff60d49e6eea7418e47f36699dca4edc4e64733aedf096b8534373aab1d49697207628134dfaac4d631deffadc5aab6eabd3d0dbafbbf90fa19e13f69a080622837257884e193f0fa6b313948693d1fc2cfa23d178d23316dd6d3d89a0a031d19dbdfc7624d221e5964ed5698150bbbcb22b54777e5f9499b1f01f5a2ec87f666652b8e0c52d4da57dbd5709d12551c2fd58e8be8e4256376397348f85e5b60364b0f10216836c006b2c14f1d8c7ad11cbed85c2c5df9b5893fb5a852206f21c5fd48efb15414c2f44749d681a3901243fd87171dc415111d9d6f663d94fef4b4d1b60c722ecd6704e889ae2e18cfcf785db4fae6449357859d6838954ca4ef769331ddddf59b9881f3fc33263f6b3c6d39242ac71745aa0b1c1de68731f577e272a859e240dad8e97b714cfcfa35f0b98413e8c1ec9a08733c0ec31c15ef706e88f98ffe7c985a664c1c32bdfe551e73b9b1d65e51f29c7c7b63f115eefa357e3bd2109748287c4dc0ae7fc733e828829add79351afa74baec002c280b41db471b7836387f866dd8861c70950a327658b25fd208d63520d9fc8faf6e9f3684f523641cde37d7e7ce717f7512a9b687021d21e45d1014aaff0a89ee51d7d1c37792ea3049ef6a0201e0f4891537111881f8b839ebd078560e2111ef12396f702688ea56af7b3e51d20320779a242b3c2a6291b7193bb688732d512bae021d4a6f9b3f5793d74dc43aa4313dd065f7e473161cb4c0bb88e6b8fa98709eecd720dc12a283999666a17cfdf54a7741b0b8deb2b7b504be04af951b2fc2025dc4dbceb0e04db4b52fa6cebd4d414ad965c04f6d9431aa07a0ddfbbdab768c4f3b50e74979cc0241297268a2f3c291838caedc00b1603c6bcec1a0b91b58eb67ad651e2bbe9a5073b23dd737271d31a96362731de3229a338b653d570853fc054cd082fc3de26726065ba91d31103f31e4bacfd3d090ff1c34ba963c4f2c5bfea8c60e90f285dafcd37d11ca89c7448895e5709e036513e587e5dde6f5766d9a49efbdcdc2c8c4c5e7e6c9e5531e68285e78147f83b0334727c9f23d87038a60cd86827b7b351e92e92fea3aeff09f23ac328bcdf6463a4c32bfbcf39ed2eb93a06","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
