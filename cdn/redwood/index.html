<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"deea082b6c6474a52569e7e771a4e41fc228a066a0eb038fd8002c697ab9aa1063ec50e6bb2d145466fdf707bad8925b8273d82e5f35f35bf00dcb36c08c3816a7f2c685bf51c6405e7faedb5b5d36d25f31633883032a1ba8d6f4030b25a219473403cf59fbeb4cfafc478a5b71f43c659d592fe476cb5ef3d0cad426c6433c7c14c2165fc58ad5d303968d90cf504ed7d4b9051a19fab3d0a00b6f3cb28c755f12e205c66c86083b7adc5e0b497d14ed67042ad2582fbaed1669f22e4b714b70cec21a9618f5379929cc5ec35588aa1f182c31de27b9ed66e0103e573169a88b2af8839c8c06a27705d5036c02479f65bbb54c7c1594a34f26a9d5bb210c642c08e9e67f01f4e968b87ce95f5918f15e1b60bda1c27cd9e6b57d00bc4acced7e839c7865bf26b5961f57db0a5dd400dc988435d887803e19289e8d1ac9f1b4b62251c3ae55850b421bded889d3b4590167132aaab6f36f607c093aed464f50617688790a72151708b59d17c5b4644fb70bad63ab4c563c90cc8ce67567229f11f3f7d3c00b68ee32eb236e9eeff53c4bb2035ab7799c9ad809378f9f9b23d58aee40165a358626bca98f728d9a0abbc119503eab48105e9dca41b4bc531a52ef90300eec9008fe733ad5b99ac8bcfe258e93d8f7091e2695731dd42a2f08c80a57f52390c30f31309806275b267abff40d1247ad9e5827748e98235ecfd82804e929fd004a8aad821ee5c887d8da96cda0c00473ee8eb4f03faa410ed95780128ef7bde247085c1caabb72af6e3179a49114cd0921c89ef5631e98a60fa39b14c5dc86e1017440f215d12da1b9d8377095c141c381c0c1e54c67e7f4fa7b53f0f920e1a88e4fbc01e766bd4dfeaf6aa16a0b97e438a654d4825deb136cc6e6ecb82349cb21ae221a87ea650c7e7f98d05d09664606756351077727d90ed85a19845a59c7c3767bb080be45e863ee865e8a79866392024e924031fa051fd31dc6caac24a21cbe63414abc4f382e31822a4ba790d11937ecc7f8bd99f3ed4606fb86d8e97b3a3096919e9bdee73e158e7e3ab994963ddd223b1435711f42a36ef79237523a262ef1f07a4b91f991d3b1e093b81273b22c2c3cd8b481ce6929eb32581e3528e309a1a52f62db236595db2735a321abc6983942ad4e3bd9fb868ba3302c8762897cf98273a3feb83d69daabd1bfe9754f9e0ee2c9d94ebe9efcdca95e464c2a7e0dd9576a2fd80932b13be3c1698c0d1274007c10656207cee6381846ac9bac8e6381b1ab8b5bbdc0fcf8c8ec2acf7e9e76de0b5776ec17c2d51d3c567ff1a1ec1d0971136808f143836e336cbeae51ebed9105fe1f48606c9cd6c4abdd97eaae0e1b604875d0400e6644d095aeab8fa4804df8e6a69dca9e39c4daf7b30ac15c94cd3cf088eb0bc9dc2a05cfe14c94d3625400d962f5dd3c8ca6b2cb8c6d96eaefde1be88b1e9639f901af0c86edb0f035f2aeb702860c5a856d533bd127d05b1b354bd6fc7aefcb097306179213faf19686af32463b123058965b8c74cf2b9fe2097c968a5e825f3845664dea124529d71a1c43450601f4acffe901e87554370b7ea64aaf982c0146ad9bf379f5f49b92eb31e8bdb859e331fb23ead2022a3bd2f1c2e976271b57959dfc0e815372d56f8078ea1a2a434fde7ee0d00e2a46dfebdf01859867fe26de9821f8613866e6e557785277f25aef1723fe70c0ef9a13cd863525ca48f98a1af3da165bc05f1f5af4e8d2b1bed3318d27f845b81891d868dbdd28bdf5cfe421b3f633edb298a3c0f1bc801cda29c0d3ee9c0434fee52531ed402a5ab80d41bf949484253922240c834209fa12d67976de9d91045a304732ac162df53344ebb69faee3c004a531c046e292089de095fe2db5325e0b2ff0ecf9c3b6ba0932dbdde67d581de6ce834f5a09a41fa407d59ca215cae682eccd1b93ffd1499426430a6f3baeda38163f67c8970822607e99949f562d704d1d127fe864615eab5086bc15b704e9aedec6b93349c34dc3b7aa0888ae5f8db5298968a206bbc52230e735b9b581ebb57d9ffabcf8d0adc057aadfb4f39014e63f32820e123220a384d963cb0e60ea741922a0eae6147bbbe6511b7411a45b743cad8822c07dfc0ad88e30860d1152a2a2b2bf753fbb6c7b6c26e7c5ccc65e2534f5478e7d6cf733917d69f30136a0e20318d6c74267c743b130390b7ef6729ec2d381d901b76294c152814d3829542ff6b3ab6cd95c1e8a4485d052ebbb1e894cd18840696327f2b2d43bf0af135dae01e209d97dbfce4ad1d31cad74e57f8f873e27b3a7a0ca78f710f917bec15db562ab6b3f5127ce305da713fb1e36df243e1540817d653e2982c3f6db1c2e6c10702b42e117637c0f528050171e11fa01dc41d4feb6c04fcfc5689992bf93c9ae989f56df45541ed4c02f9a474f146c3c509149098f0ee4903b95951ee654acc2dfc4fa222aba62b4101ee96f02b7fcd83889e2e6e554ff94b07e1b3f5f306ae67cf18a72dd93dc3576435e0c786ca54c468f1437d8e578425af1424d64208117f838aa7f7ae72fe2e1249f72d06ecdba5d4ac589ec860f3ca4d9fb3ed068edd75b9a5d4a0ada87ab8c7e6afc29c6fb8ec4e6fbe461f3ea1a8babdecfa8e53ea1082619117607707c03317795d9b12a559e7615f901cfaf694b78dac594f949e3f1989ff8b89c997238a0a2f233be63e25fbb3fb7bbae6db6001cc02dcb3b25317690661ee283a88a28effd3949d05a71440a601b8533b511b9b56b51c1ab2d42ef2dbd945887790d882e3b84c68be7b7e6b3f9c72c41dc051ef0378fb891037a3fdd437b755ed11350b382c2dac83afebaa279c7a9449fa1a7000684f85b668eaed053162d3b3dff650438132bdc77f1cd2904fbbc80ef8261a55962893ae2afa4ba50205e11025b022d69b97eeed5b33c6f8d56f028a58fc1831765c12799f091f17c8fca1bd5791077f7999a40fef135cfce669d8b44ba352f3999f6a74736cd5d2f15436b3235f7c4befb81feadeaab990b5379ee1dcf2f257a30e7cc01b981b43d771f46975b0c08b7bdb5a10f5f2925b2d1dbce447c92579b8c9ad562b49c74b79696fcde0d961818a27c604106f66576d9b3ffc946a91da28495bf20af345c58597ad5de4ce3496986fa2f6beb868e205c79f94e559b47bd8320e423dd5628fc2fe5400e1e9b18fc822a8141e5ccc64908422e0f345def13af49eb58e9736e7133cb62dc44fcca3b18972407f028ddbea7dec081302f73c19edadea014ca567a3954fd3d137c1fe907aca89bba235bc46f4ec1f566075cb4a35d9290fa06a9bc56b8e941b68deb21cd43d48eadeb4ad825b06139f2b92ba328fca3ed8dfd38ee80c5086b88c4ed72e1b3c2af7615ed402dbebc6a2cc2ff4ea4787605a079f6704412cc1cfe9c75c50e595d7b65143fc4a66b900863202a2801248d90705f647afa01626f170e9b2cc479c1d9b8ec0790a9c7ae7eebf54bf181d2bd5f42a471fb118ee2a5331c6d6a3a63e0afac99abef51c7605f1e9c03314bfcfc73cb71eddf5d410e25daaa3238c07941a4f29d0b1385a360b224335111bb98a2c8d3d70c995ac14b613862013933ff3d4e935cbcb472c7013051c07c703bc52557bcf660cfb8c62cd134e0a1163ca876086729baa82b0ed4041e988499af3bbf0818f32933bfd9f328911de77dc3364799de053e34d660de50ec1716b3e5cf0778a91545e91c6e04543bbce8581be5273261335cce2ef1c47f9abf1a05267542f44cb1ae80a4f71026d5106b46faf144b3d55fd16e73486b6a69c8104828b632d955592e62eca9f199a313a4a1ef2491b80f25365729ee4fbca9d11542d6af5c33c6bbb01f06f7dfb272dfafc12f49eecd64abae38370be10c0ef162bc2f0f0848308b2aa8ff082c5a6de25fb2b41b10bd67d6adc9eb2ba4bade0c4c084f94c8dccbdfa00b3788865580c0ec53988acda3fa6111efd843795bfa63b41909ffadd48af3116caa42dd9d4412cae1b06120aa09808db3d778b3c3653740c53dcde0afbc1e7408e426ea54363722fa1122c970dc2b570fa523247bc2605d7ea7e0347a0ea3f0cdbba4bc1200549e2b4637451656e1d9cd97d3e14d1d4eb38c1c77f3b9e2282b6fb8796b921e49f75ed7f2d657e80914d87402a99c138bea238cd065ddcd5acccf43536b112863e39b3313d27193115ed62f7aabaa0bfc7456cdec3ea51e917cb8d184e7b4239871a01deaddd00fcfa393f844ef291c361fc063bcc9ae08d6d1630efbeabab43ad056c3a871180a931c1eee5e674ec496962afdf237227f96bf324784cff3d79bc6829775b5bbee9ff5a3899769ac7e8f04e38002d58bb3fdc2f228f5592cc411e2366464090a5e135eccf47bf32721777b36a7068f2bcfbf6ac3b7dc96f866cc887820a555fd674d75fbacee908031faf62089ab3792f15c92d427cbce018aa45444a28034ed3848966f2bc063419bc5fcec4833ccd4d95f8a02dccf7375a46fe100907bced2d70157f5751bb819d4658de6cd66dc688412f74200d79680650fb40ac45c7a53777ca35a1301b2fa1cc430fd0afeffa1e8bf56d68c66dd09f35b7578ae46aa411fa583af5ea3aeb70855ef670fb0dcf9096f32af21eb9001e9bd2c43932826fffff860a59c474417cf100e7630f6fab3e13eb3583ba891c819c0709a1637b295ce741450fcc90b3213f4e3886b152feb89b9482f5ccaabb0d4f3cb0337a3c1a8a33d63458a8ef5cb916abb8ae8bcd104a5be522a753744f71e2387fa44e53d7267cdbd6e8d50f507f3647945d2c5f93bc65bbcd88a86f422f0b31c0db42adabebcf66d9b0c94d4448b94689d4e691c0948d163c1187333236798a84795a75b85c73eb5ab6d543bd518f0cd126d4e35487a6b4d10e78f493ae35ff263c5055511fa7e3ca0951e12a5b00b27ff00b409cb7b0a4336c3c82385f0313225f3f3ec8e185017a49fb62b6222913b7e4efab7d1522cdf97a2c7c54c8242b8be0631c4e12452de758c67e51bea76e3b7e0d1ffdb56bdd7af4c88b82f67c11687fa60f09701cd73efcfe95137b702e481dd2fb693419751d935ceabaa9ef8c2c35dcd11d3d95dc43746d76685d7b9976d9b8991c3e3280e7550d1d9ed68ee88d5837d29bf951e2bf362383b85893197aa31e7928d2ec6fd2c61448732c0f3f37a7d25bfde86f4c80b77a2d8aa080fb1b857399d317bd2a04311cbf9aaefe71a4c7c822737c90a8d3e1b313598681d2c3989073681167b071aba76f1f6f5007b66e335d588bd2cddd8cc22f04c675e0acc74983698d3489e63eb75edf0cf0396914803061d2ddd76f341889770ec1a438c0d9734489b8159944b688e4e6e9ba16ecbd82006ac74e4fc0469d5e9559e1b4a20260b812d9ad92490ff0bab6545e4cdaf9465f56a620494f07c3a8f3cb4aadb0c0165903b6981a082c661e92258e229fc175c3a3da4a21e1ab56cc95a8ae2a3718ef172a11868595bb1992b92704f1a518a78312b1bef291f24c3d63d00f658937e5ac61b555e82e7f06df4382fff131303a3721fbd679fbf84e08f3fae98e00ce8c1f0b99547623516a2ff598064532a2300ed2b712aa9378c65786aaf64aee2e4ec42977c8ea17a5e125993ab27786056f70adfd13d2800cf39c9c149774d466dbb17762a39385c2362ec8a05e50da77ba9c501ac74b5acce0e7eb9a426cfb8a7e30c2f3335c27b7f7dcf3329cfdb4bcce21ac4d66325e65acb917ef1b05e881614c4c9617cbb837839fd27e66b3733e46c066e04c170045b4f1252a5fb4dbe0d78e7c0b91dada45ac6d9c5a0a8fa337e60cc09c8f4c62a6319c0e8adaea2505458a8ef6be84ddf796c1dbf1d2602651c27f303606c55b013ef9cf32db18e16609aec308ce9f0235c3b2636c385213ea67f36d2c5d8debb1e416d66b43f9d12a784180e1d58e128ceac89ba887614c102fd41dd2a7b30ed5bd1ab8adde2ceea3ec9b5262d242237ec7b50cab5b5310d9823a1900757de6fee061ccdb0abf27d97c74f7a7d9afcf1964ae3ac250b9ee5472c49a4a55c892beab058a9c7c7ca0def56cc8596633cfe99d8f243d56c7020c3850af0bdb6bccef6c1f55e72517b4e1a326f082e14bf86a1b3751db0df825998b1854c640b0d5b3cdaf4939f1272c592dbbd39774569f64c25c8543353977def1e8535dd43093ae7834b0b60a3f12a37d4503c81a5eeb88c2d5c20cd5b869683ae2f66afaa2aa0e7bc9fedb48388ab0c9c28654eebc90824db6847ce4365a15046b63146102727b07eda777f611cabbc162a11ab8105c1adb5fe6918721419b18d61979a2e25a56d89b44a9cabc3aa5e471fb8c45731e8bc8b3dd397a5710745589a6c674e3355f9e41b4ad4f41224c77e69c454cb517decd2aa9c459ccc3d0b7b51faf81a66f09efd7ee8d4d1af769cd5b47ad73d14f851a37859735b21c4a7b128f62a6fc1eb96056f9aaafed8179242cfdf911c0f918892e0706a1eec3d985d2ac3513fd80a45d2330b676a2533ba992e1c98f3445245f400739109c2a31327b872d1aa1ad924491140dca02068285b61364d6d0abe5a5f1c8c072c46fd141c80465f2cb1fcfbb3cf9f0a39a9c8b04adfbb3995b9fbea91aae798b78f0fb1b3b13c3f4bfb26f3d2ce059e17ed4612fdf3a2fd5a6ada5f117c92f4a18eeabf46b7cc731f4a0c8fdc5086f6c0195728f604e9b798df165172f9e25a2b6145bdf8ea821d2a2e05af8b5ebbdc36fcac98553275ac7951e8b391ab3a8ff365e2ca66ac96032b2825a434cebd9ef3798320cf8e28d8f152a0bdcb4028f2936fdd5002c6442240a476e8676a10436f240747e012b7dfea796485d39674cdda9851f865e0c82d42d999de2cac09e40a09ef6fc4f6559efb1e9579f982a3ad66567b5a123089820dc1509923007165a5ea2435852912a3d1f694d6793bfcdaf372dfaa6ba203abb78a4811bc1a6eeae6aa954aaff8c6d4aed4e18f90bb6657628c63d9888c169c46e0c256dd768f0388eeb5f9a5e4eed1451ed30b5c9bbf190b587c4e62c611b6c32d60700d73c73c3d5579234794c51d395419b1cfccc56ece66b442ed952c88876649f44f612541101cfcb2fe7f5203d74b68bf20f8e5a01b2ecb65431f7549561849dc2d78eb0997ae9788ecdc14d582881e597019d2217b18ad693caeb15ddbd8a526abdc3181922b09639f6a2873d4e5a06f23b61f2f35c96b227862f4ad37785c390e41528184a5b85956cde25b0f5757435c3fbc31378345e06cd6dd0b77727b1c70ee86d4f757dcd3ad2aef1e53e7850a48526618677b298596ec80f413be7eb5ee8d9549aebc82f40a9a172e6016866e067f582fd18de90428512d6f1dd261ae2a5337b00490f9c11d7a84476b66fa8d1ca06f3bdf69bfa86699f243cbf6ba9b9070d40798009c5fc212505dbcaa27fa734d3b93bc76743fac5b7cd4747661b2df61676419813c3a7bce9c0c6d692e4e3caa07914fa32e7cf70f461693f9607c677dbb7ee6bd903ff3707598de11fa880436946672ebdbdf72f9d09cba968c6cfab601cd806abc9fa7ba20d4fbb654d317b3f25f4ddd6238712d19fc594a221abb2c61de822dc34fbabfb8e838d7fb054188dd43a8bae4771e4c4d6f80c466232e3435adbdb40d2181fa8221d481ece48945f13f011b4a2de972b5964fe352ae7626282bde60ba4101056ebc8c6fe3c3da3ca62de0b8e488f870ddfa2fad03b1f5da9dbd5b51d2b7109a34c626c303d0345f03f9deaeb3433cadd3834a7b0fb99ed40b3696150762bf2e83b1983e785a182c1f8867c91b9c3e4966546aaa05d081f9a32788666e68536b0a4d78893832adfcbfa9bd92a70fa60cb4e0bd556e028e5e4f08f259db47d27a143806b2d4e9194eaefa7829cdbd98bda52e1331b5ce622df99195c114e15fd102158541002518d34d10853395582ba014b2c06ec886d676a46cec45f9deac0f5561872d813e6bac3845cac4123fb0ea72040695700a3bd29f3ea173d51b56aa6e489efeb15f2d34df53b3c4062c47f997708a50780bad654bb6dfb9fc31bfb441bf5c7a67381008435bf88190717c85aed43c1ce3cf6957f493cd8d34422c9fbf328c7a336a6873d1573ee3e75d1ab199e086137774c8e64fe5f14dfa3655ff23c98bea9ba09fab6aad885ecb0853a3b6b0b151d6d4b2f2492bd12c6f3f71bee03579ee2d47f50436b6001af656318f4f562896200525c89cd13591ea7d48236a6d8ca9a9d53a5db8f64ac0b58fae339189638f4584bf4fc4e0c2faa49ba647c5c40d057912feb6669a454b2da4671862a4bcfbbc86e1999bd0548396ff771f3719339ab9d6f81e5e55b25596fd48424de884f88d63241fed724565a31af40ac8b0c73691b67890adb4a600176d7f2a964b54d073f5f416742ef117d0bad6a3513b1888352d5213c6673c9a69f00b8df84a16963492bc2625df8176e1941a9f394d963118d50e18bc364abd15cb73dafaab71db8f831405331c9886b8221656373da4a96c80ba3a93e3f29e3578b3cea7c76af4dfd80533298b310dfacc8c910e0e8ee17f909f7d999c0a448d7e1300f1571c87671db2ad9e6e64546d798a500404d58ba57ad0014213eb2fd22c6bb668629de9c425c2d2c3ae707909bafec2ef85b1235b1316164cf57ec60a943a73e8be34f243f99ef0fead799951bb00081f6f4f7d8fd8baab549a7192a1a18576c892e9137f40eae105cc73ad7cfaadc7a29c216da10606277378d1e9a40a23ecedebe0d609b6ff5342e6c84fd19db022278d13a4557a7f99143f3d8262503a13b72dd76d7dd5ea37616e9429512822713e1ef6eacad8d9191dd8ba16908dd5638bd2bc561c6fc5c36451acbc4539628a88fdc9201d27da82e251e26fbcd76c56d753e7c590fa782ac12c098e224df2c63661d0cf625a181a6145853793706f0eadbfee5cd3864acf0388674e3591c43887c9eb4d5209b37d54492663ce88f04642f0bb021b6bd80139cf5140d7b0552353867be9da56b4ab435d86e6e1f7a4a42bcf808d994ed342305197a4a9e8d4c32f4bf5e8234a8535f6b73163c1e6f38dd1adbd9b9bb6fd49c09881399a232677e94b8a947aec29d526f87f1031561d81defd6850e30ebb55fc477d0def9e3809df8881a4ce8667e28455c1e5752a874633665fc0fb82b21e61d92f426fe6db99f8ac9744ab33a63cc372b5e869b59ad5b79af07ed17ee4143461e4177e7986a04d441f915dbf51febf73d9776536f804d37f90d6c7a724f756ca86b8ac32a6244604ede7d339f0b8b7c4ae07a3a61ea3cf7f33426d4c19aebf33c509e7740254af0de2cbfdf7d7ca18f98b14cc722e267568e8a2a965178cced06b19de5fdd2a17de51b3c56bd000c6720bfeb8c9fd463081c35c63f9dfbe7d77369c8d198b0aaf3205fe76d760ce7df9e94e1f111b677c2780512af1653ef29f88035fd95a01f5785231df53e6f088923a8eeb5e6d553cef2d7a0e855625710db34f635743d0bee36c02681f02f55ddc60d8e588c2ad47cd386f58159663bf7025fef9ba9441203f9d7ec870fb2b1fac066fbd75b775ddb8174a0fb5c7f2db82da03bba9a6bd8e5b7028ce3b1664c8aab79e8292683bdcbbc61db751ef70893a728573ae92e1eaf8ffe4c195ef73083ecae87187f0410bf28f71235be4ef75c2a3f536656b7e9574e35d7855fd807f1fb91f3f472c23e15c3e8b24dc02c17c71fc3c706b6a5d447ea2ad98ba84407963d87266f78f454a5051b801cc8482a1398f1233febaa4d4f2ae1afb935dfeec8e9a49b6b32a91100da3a9f57afb0edbfddbc695a2b96dba78a4579e1e1895e0201d29a7bbc78ddbc0e9b37de3a186ead51b88e96a1ff3e79b39ed589d78b1d08d6d52eef14a8f365dee691fbb2e7f4a695eb93a515b420afe247254c6dfdf5f5f15b7791d0c5e9d7e7c24e563db5f7fcbc3c2e5c3633684d862b906b081dd623abfe6e9b61ff5f2b40eab81bc2d1de457e7ed2e5e715e6cbbefe9dea0893cf799fda9d3374469cfb74ab798aa2260df4e61c15b163f808389278c8cd746b18dc027f417798529bfe4d7b1a6d93bf960ed12afc0e26c51d70962e9a3e25c5737c42de2a45caf9682c17a09654e4c68ef107fbb1a7d71d8b56c22bcfad162a9bd7bfee7fd107f3edc7085863fe823aa9d0cbbd2d433d9003232a33e9c4f649c2ca42780715279d93631d16338d118aa8741fd7d17c87a33609ff5be779adbaa2528176a692293fcd55dbc7dbd0d287990b4470a9d42c507c64ee03fe4933baa8d20fb9a8311e62a185c98096922143563a5e5b646afada0d45c249ab77c78c830aa657bc5dbd10f3f2646e2941231d4e675604882c020e14bd2840b3e0a936d029f3eff3a276a6c2d62b75cc7ba13b4ce764757c05bc830388a417d622f434b3bc36306a4bd528ecb1989adc8d33aaaefe44f2a93673ad5bd4871ba1be4aefedbb5349982da2ce3c5f128ef0dfdb6b82e7bcb80b2a24caf69f61413eb689dd045e946df9c0a0a4554ac4dac7606ebe6f85a527f4a4d092263b0c634908a8eeadcac492c9d30d688aaeec92e813a64f1b79fd6fc628130ac2f251f256c8660b58007077c2f022beface53039f9dfcddc3addbd7121535b5e94b778733bf5797aebe2b2b4622dcf9d8e23132cafb0a338035db6efb9afeac2ef59819895c2d7e12de039f5157cb77cb878f4eeb581a79fce61e4572e06e21d0375bedd46ac65aefc84ac5dad408f72d1a1364812f636ed8079185740872c79d7c910f64f19e9a21e3a702f207c1b685497976f50382ea3154a1b853ed1e087f7da2b5ffb00e611737d4d646f40c1a34ffb033c8dc8e941bbbbe9f150b3ea3b3aa8fadb480caad42e936cdfb26acedfdd7da9c740ccb27291358ba683c32085ace21121d3cafddf88ba5420f01ed8de1c90c888fd218e2b5d7299e7b2216a2ca0b83491a99119c9e24132298304b4d523fd28f5f050e63baf9109bd4f9eafa86a716921846c47a4568b78fbd653e72e51e39f48c081f260453455a21beb8832357c8fe6d9f59385f83c1134f1d6f3225e8583717a341ec53864cf8ade391451c3c5d7f8351102c9b2878aaa30e9be66020c5a0b23ea3cff2dca07603e6f2f00382b948b3ec4978937e942a94b900b4aba9516ec7a80f82e92efaedda76b57f9e1c00e70235eb46c90bc87710fba152e513c4df5cae1f3f31b60febe4d249ac3544fff0e171ec194a6182b1b51922c495f607be2173ec57e45a78656049a03549d1ce8974a02eb96e0d0f31ffe8d216d6c331460e20811ff7112dba21f499744bbfcc92d80244461d80a7098554b12a7b4b04871b5811cb93669907b02193780339d2b5f5e3c17a3b04eda00f7d99337d6d870ee40d1fcc0b5a154a0234eaa9abc7769e1b838114ae93e2666b7120d24ebf1b41ad45f03e664680ad3e7295b742f9ce99c5a2856a7c598fe9caaab3e9471eb3432030aeb4e6dcbe116883ee42688144323e641ea792b25aa77578b97e0dffccbea6dda4ca92c72477c108c5463ff762c7e723a5a295ebb0aec18336ac82dff6200b342f3a7e0b73b38da4f9b92f4ee3977400a811622c43499a9fed7399767d7c7f4e13200e16da171bae5e4a37113a40efe68c4100bd18a64acdaaa96bb4085dd9bdb01aafa939ee56e4a804a071cf79fb3f48a8d42039bff187b852ed5f951cc0d9546ce10b8900e624aea1f1f72b935ae6f2b788ade0347fe349ee7f235243b0cfe98bb080b2e9156f44bae0fae42ec98f74ae366edf96ebf6ec2822fdb181a0857ee9a8fa9182ae65ac82619ea613cbf5f58c276077a1516fcf5a61f9689efe7950a2ed6b62b409a84fbfda82f80e55d75d17b478fca38eb17effc795c64cb3d579b26531e26b58129b0f765ab37c47a24773c1942ff83de7a8dfb37c34bcaf46beeff4b9a44cb2d1b05e2e8d54b651eda29a71d8b2dcd18cd60838fb1df464226404a24335a03123a0f9a8719677e8a9435d5838fb3e2f1ec83087c1a436e177a911e0860badb8485eb5832c27293526ccb7cf4fef441f2bb970701f41413fbabf911d5d996c55a1f67d9df222bb78c91e40f65b7ba4c45dee237aae9821c79dea63b9a78c8feaf500aeb18f3857de06a5545b6a4158d979cb8c4acc93fd72338e0a452494dd803d49281cbea2cd4043b55780ebb170f53bc8f265ae9f2421ddc5344c929c5363e2766c71b0221df4a4552ef477828e846ac7866f2db192b0a972d94cfcec9d7549328669ff5d8b492f8b38f62aa43bbe5a85a0325ee40ab2e3f0363c475fa188f18fc65f0aa08e28b6b5128ce64ba8ef21baa1aca5b1bfbc2d8dffb03f3f2dc27779475d08746537ff514e30705baa998473a9ec2dbbdac7c3436cefa90435a26c17e6182dada39f82b766a64fdaa6b82130e550b557402fa830851b1a0164348c6601969a65b8ca2b015cf203ace9b716dc5e35f1b611d4cc8f87da1113347df271aca48866ffa21607a1e4718212e986d997ee0f823a8f698e7b2a018333d3801d20501dbbd556fb2eb25b2794bd82ff13c4b92fa5973fa30ba65e94becb6774eef5ad72a163137afc1944bb60ee39f5c879edcb1f099bba8ffe95a71706c01b9e78f3832ff1240dbb7944bd072fa4f6094bdd2225672a116f41762ea5801ba63159111a0201e9c516a0bea49f308740fc7fe30c16ff5f7c721149f385d7bdcd342fdffa12c3deafdffb7b17f7d38999f13d7997743b4927f8d2cc106bdc5fd1e0a0af9f24378c05444ac0861218a2228218cefea7cdbb0bf9dc0a61e4ffcafc5d51e6ca305bf1ccac8651ed1aa0037270741863e1ab363bf24431ed4bec4a95cfdf5cf4df6a12ccceac9d50fc71924e9a4a96c0e2fa2d060ae779361b652b0e64174f93815d1828ec3061fd54be508fe8c342cbde8945602eb05ef7080c341ac5ce5c5f57408a65aecbaff5f56f4433cbfb90341f6c2433375eb7b48bdbb4c64fc41701d6d6ab3f7361be1b063b01c9a3467e3699802c5b3cf2b71eda862943ea502493e1db19760d2ddab800aedc1bb230b9804489fd1316d226015a7d968a972e00b74bc3c4426a6fe531a364f0f430680e89d68e8079f06b9b95f1180b3574d1b4ef551a5b50bdf100e3bf20b3a25d2b9acc0f0cb72f80fca84c54b21ff5961ae6d61247f2720161eb4e9356844bff789126c73500d6b5ecab8bdcb610d59ab3b07cde418992fc7c826cd3dda20ff26f59d08b85d0524be7f73317b9c6fe4b3ce1f3af91ee9c38e4661e01704287c71b72aa7083f954e7fc92dae2fbffd313b6e6900cbb3e9f42c8985fafae7f300abedc7e28daa3e1c5756559d98a4b5a95bc2d9dc8c6d47d6b78c61b5ca003999ad67b9138199777ef92b243ddf6230095133fa9966ebfc91f4140736c52ec4e76be56bb1b8fdd4a44177e81398f8af55a4463b6e0d7ac2ee5a496fd436d1e731f666405217edc770de87f06954a94fcea3d9a011767152dd5d166dbd3c694fbcf3ee58515c0a2cd7f495b67293566729e550138860c243c0e26688c016e55505782332e57f6241068fdbfea31f176e71cdb9540e1941dfea072a4501e7987ccb886c3bd4b02320551d85dc172005bd91e65ffffe6aea9b6f7e4e357b365bf3256f4630797b49becb2b274545202bc2fa0bfb6c0c334895e255fe62613956aeb08e1ca9e2a6b131fbd46246d5b37350ff9066843d80e462569c691ddd28d1b5a6c532da9b57e116ceb11a315495f23756d5adab4d4c1523e77438479baab441118258b4c582a4035440e3fec6016a0b29aeb8f4c14cd5e08f4fb2c63614546d6143926d37ff933b45c8c95ba94b3493ddf638e9f11e043548c180d8ffa0eaa254cd7cd4d830b6023303c11eba72b124051df98cd10e581c40c821945765220f2e3d18199292442695c134f846dabcad8dcadf8ab0c853afbe1794bce13f74098399cca1f2a8d9e52c24aa30255418e718fb2b6543d7c27435046baae938a877b9019c2eba14e191a1504090b5475e6514e9a34b396845069d5608320b210bdd7f62f07c0fb51e8f4e5220cae686261c6ff8ae97ddb5a2c189b466dd3433ce56a7e52c7fb12a299181bd69e5765a66e66a30b0d6f1d66fc418cd48880e279ce09c6b1a8b921119cfb93da936c1cba96ed8aece5689a36c666ea670a989d5777207a4ff601ec92b486fe2913cca20beb9c4ae98b7d230493cb479ab6bb6ae253a7da38927f961c14163ae1c7ff9ff4527e014552103a402fd7d9e5aff6d6a56429a247c05f5665556ac1c1a54cad9c622ed632a76f34b2f4d1a99b426a271283c68121adbd0f60e97beb006c0a03d39a95a730a6800c9ddfda0f9e84002acfc102ad43cbcb6147ef2c4d9d4c339eb2c57e4fe7f2a99c86920c797c9a2f9c46ceec2a812d30478b4f7716f9f892be0254ae5480eab768d5fc01ceaed7dfe54d703f55e629ed1cf0f3a822033805d2d7c23fce0da74f5e304cb4e9a126d4d73e1d57d0fc099c139560423c1ae129ae67997936f36dea13673d8ef29613440f5f07e9326aa5193a88d4320c72bd3b0ba2ca77b028b3e7db9e44a2f81e04cf626d502eaa1fd59b58224eb72f41bdb521d99aafea102b08d5b0e0c414d3e04c87c88fd96854e2f001119e59e8b9dde3e48924a8b6f39252360f6a77a401374e5e3f8a06c986fd35df368bd943663cf45ce741e9ec47416a66725bea1b6454f54bf55a25c0bef13f78e12e80f7f0e3a1d39bc671d46be2e34f9208d218c23a108233104aac96cff550225e1aa281621819c842a1aa342ffa7842ed7cb030b6f689332377923290ff83e4b96e0e7dc98ffb3e52d5bfbd9a93688f60982d5ac9c56525c6c23f195727244df4e1d6e786039f159b4bcafea392362069ebde8cb0770767fac7c6481f8d019cb1373e4e39c119adbf2aaf7d4a82da2cbd126c88a81e0e8bc48aa97b360264fadc04b1b75034534387a0c5fe898545ba0bc1d78a92676e3db9d37e28adcf34a724c319fe5471e9512a4b2443cfe3b9b5f6b7b8b57e3ed700184abbd1461febef9a16ed40388fe993f3a07576f3c46608a751f5abb6140f6405c9de0a5b7662b7a4d6d23c83056d97ea6d505dcc8dc3193dae9c26fc0ad54d2a0f8a4c4066ee922eee0b96af8f4c1dec2db554eab67d0e58c7d9935db8ec4374b2b06ef5f6f6d9c75ed558ff795c25728bef7fd75314b023419a01dc0d0a3d466473fa311fb3aa1a923dd7d6c683a1a372e081005e367489d586219ff3d2ba2a39a3be05edb7b547a153838ad37faaf63ac2ab2de8c6427e6d5543e07dc1958810a2df13ef20b150b929846a661728f94029c3c6f89b020189100e233330a9bbdab99315b4803b10a8f11a8bbab07ffdb4f754b482783395dba1065e996eb1f97705a1a2369bb254854b84f28d7216771916c361987846be632940746e1eb677ce5d0be84237603279a41ffba1e7d21911b5bdfe14f6d691dc55e1f8d2b3729ebedfcd6b65eb98ea3d205092d4034e47ce72086bbd9c8f051c3d3d68005c3a2e4dee3574e07632d1055aaaf0df0d37736770075b618d37716181c5dad2cd4df2600aa9ea4150f778ee54174513362ba40370cad6c24c075cac7a8ac31c7fc1cc24788814e14752b0bb585f9aa82f6894ec709b8e2abba1d89ba54c0c335c9c60053631faa0557b5e1d563168421a53886bfc1670e6107cfad3b0b0ec842942209ce80fe6227dfac818da07f5e4079581760e431ef4f3e328f5da668d119f5a7c36bc6a16a4e6be28cbe0af5280b239a758ad60498674433c883f7b0c0a3c26b1eadab9451d188a0451a2622e36f9a4dd25d299ae5737a120f9bd749102fd1b4e0bd4b1e89a2ffb157be04ad8da0198a4dafb091987650d00b73c45fb1c68f84fdc293e826bc49d355cf633a4d901086529695c2686ddbd0ed9de304955c71bd61b42117a922c1adf010714b57d045ecca993d93112133ad2a8e8c2d706a1ee7a5f69b200ce5261a23e5cceee627dcc2d0a8c81fe04c84f79372bdfc3ab48f8a6a25eec434a0375ecdf78c813263ca625f0ba2f04d76667d87b4e984de2e3ce952402abc24a539c7ff40b6b64b4f1ef05104e1cfeae5a7da94435330ca882600ae6af715961acee66bdea16033633f8e8bd5842ddd0521def026c6962de6372c0d30f6978c044d33714e45463c59d932fb7130fa2031c71294169ad46bb18f6d49f806a6ea6f19299e6d5ee35ba28030da1a438ab2a0b3d6fc9f11de525f6bd22e749a497b82329114cc3a6db2208e022db636ed6480590cc98ccf5a28672f91b833c2c0004a9573a205f438b9424e4dda31d4a0866deaf7af21d21e0c6ba26563de47be32618ce03eee730c26fe87af7c8fc90888a455954eb55305296abdc50c00900a2c959cb9b5c3f0207e7949ff41d15d573fca90c877096d3228ebef210e092712bb06cd90de9c05dc094174b921ad34ca693a31ebe3860b5ffaed722e2b7ddadc01c78c9eb667edb9795786864f4632c398071d72338f95c243aec66dad62d92c6d5a5778e96e37e3b2fb7ad330213c57e9659d80979465c0bd356965a13c4cb0af3893bc8476b750a861cbb498401b30aaa62d7ba69e51d7f6006825489c6e605e51e3f4cefa15fc5836bf2095839bd920dc5902e122692b79181e3d28838d108552b9fe7e11cef271659caea42ff66cab1c65ac65c1cb27d542d0870ff2cd66b182ec9d85fd2d2fe161f7c50580b0dc8b1af079952c7449b105295b42eff3a8fd7258f496a867ffa9c5b8071186fd939d3a2efc550d6cb8f4ba96f1bb9da07cb64a697f74d1a3295aabf8bec9329c4be247ea11de9dabb48b57c95100ed03f72c232ccd34092908e5d2ae318fd284a348b6b5d0862b5476109fffe1b84dcce62acf815513a2ffa97e853f40e7776c79da38810ce41cdf61654282259834d337bda3ace269e8cdf84d29a8a8e552b25414a798233dc77a46c3ebc0662222d773319ec49b10fda87464d5d9f43c3139432a0d829ba094844c25717761e87b2a601b87716c954d332f87457d6c1d59db06c75a8eb3a5c63318d4fc3160f368c527961135944f12ed4c079e856406b50ed0b51ace2cf9f5f141c124a5202201dad19a834cd83dce0c6ac07eedb01c53200f0d979060b654e557297543bc98321297ec112cea1c62f25b856882856daa6444969b5c41fe797781f7fd14687ecb652bb19d55c6024264d54335c82e7a61413989a104ea4337aaadb1ab0cd41dda5156a2c3d397f9a1a70ae893f55067c208feef1aec730d610eac440ddc30dfcdcc9a58c2b7c55b6096f951d9a2cca32cacb93be688e02662e16b47c6478c5d84df93923c92479082fc3c0726abc1a66c8319c31b389f9eeda6f842890c2512c584f84adba66aba9021503280e199e51955f23d85120c5ecbf9b2f8418f86384af4aad88049877f0c8268054357b8b2f7da9eedd1c72dca1a7670c46deaf83df35368da8b8edfd0056db3aa839b1a5814a2a2f29d00bf60d6db59cf3140424c9782b7d09e68b9cb6e2b875c8228df1a3d957369573571fcc2ff0766bc21c280f12788963eaade83142905e072e66c132a34ed33d42f1287b636a3df5e069835addf17acd31331f3aaa9351f7f045c42df04f3707d4b514d41dd96a0638b743abc869f6957b70c12bf9619e67fe2917f37740ea79da102040043fd7b19d5268326897d37bdde6aea830c6622330ef0630caab8dbc945061e0dae2a8e6d22f6fbb2b664c4102c953c09ca9a6ef3cebdd52fba2844cd1e04f516dcec5de46031da8cf212ff8e33925bc4d3911bed7303600e0e0411d26a0c480adb1038dfe938cea8cd4078fe6b1f33b96912782658f98d253d1301a0072e912eaae79447170c6dd2904806d3d24b31cf6a76219fae13ad913a937315f78fc1e6ac5b2d053142396e58c1e782f3841ab51f3f7cf56152308e8d15a209531f59e97d2364d5b2062e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
