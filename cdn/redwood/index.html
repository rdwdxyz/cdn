<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"10b398b04e0731152e96317e69972ae14fc005e4d332465947fdc874ff10493d4d43e3d1dded3757002f3486729ddf2b6b6845fbe75ba03928ae4386e9792e443131286c873c26862f732bee1837095c0138d6a1daf60346a421417a0a3e798565b3e8553800febbf5adda550eb2252b86e66119ad407dea43702d00e5885a2399e46bdfe9bb0a49961e4ea892d104278a46fad2df8af0e7ca24bf9755a03ba01b1069a2723961120889e4a8e58f9bc309c0e510e6dc266d1a1d8cbdf82e1e189913e6c387d7d13077695e92f3fb4d530f7dc165cfd1f5b274a8c7a48b11dc74393f496bb60b47320d4a73a5abeca57b73b80dc98cdac020a1ea2aa64e6c01d5b371a81d92e68879f2ca427b0f4d360421ba11839f694c94dace4b38f0e2dcddf9c542229804b9d4c74e1ad92facca956133e226ab1738d4ab6e57b7c3e291db4ea6f5c251ad25fc4c10ceb0f403417ac26699f5fb31c40c656d66dbe8a01c66362736069f516e21d421ddc8540be7129be7eb573f5246c687594e5396bc90c6a4eca89c443d552b60fd91a49992378e7f77ae4a43c53eb8213ca1bce1adb197d48f95c2f7541cbe5cc8d79164c0c7b14a6e12f35f02f90d76c6e3fbee730ca7824d57e603fe26a1ed899e9ab4d183e2e193ae83d52ad3deff1f2d200d7be7b1cf1950e8001b27788b9485f7ffeb8cfc1fea05d2246840b1153aeee88611cb71f6c651e7e61a2c0414ee2fed3618170e985f47b5e59e264be257c0d267a57e48b8b3c0f03924115ce064b481e51a6ea0bf1436d669941f89303476ff61cb06f59570dbd4160b5feaaa606c704f3bad79d697a64666141c882f627ccc3753147e742e7c0c270e1263d0ee2fc93afa1be07683f128e458c75daa5ef7b861432848858d0f6cab9d04f93bb57de1e2ea967587bb2ab1aa38aae20f8815099e51a8a8c324b58c3fe8d42e3fc4ce34cf79244c9ad959ee212c7ec292bb8ea161ac1794c83d06218a8543bd469c35de9067027cbc1336a33d24317c678769277d08dabe6b1b6769d04502450cdecabbda23780f38351d9df5bffa9c900f58120e73ad2c1d0b08fb59c3c909a0b36e324f58449630cc75ce1825511fbe6f69b8715d02593f6b77071e34c9d32b3c2557d20f9aae63b2f607210cf0c8b646496a506b82cc54a68ef5c40e3d3c0d81587aebffedcb8b66e78c4d89a4956c27512f75411e3766ac291d3c04a18cf38766a8b19f74341fb258bceaf51d8830e07cf922100ed34e7c01b54b7bc740d7fad92cd9f8129dce201b4e75dd7453ec9fc360a7b0f576d9d6b19c931536e4a30df20fdadeccdb2d3fcd1dde83c510208b59d98e551992fbe44959baba008091f154bac35a07940754c8643013b408faa61aa7fc396505642d4beb60e91ecce82189676fcff663f38e97dd073f89fa7488932bd2aa22b349982bfa653369e8f8a25b629580c56b9fa375fcba56ff38015942329cdfc0e5d0fc95736f05c80aa2b3b4736d1f86ab1de19c1c384e68e1afa78f6944790b4e39b713877add05a5291412e8e590f7a737cd653df72d93a2e079a8470e5d26653362e18b2cb1a26fa841cd440f48eb1df3357e31caf9b9b96f77bc21ac70804aa01b32dd03b0398f7e3e50ef989514c77c6ef14d8eeb60409ea0cdacdea9fcf8d9d9abefd4e26abc4cfb4a5cc0a22ccf4b550e7ee3680d216ea906016674752f7ef4f5b813856dcdcc6291a51403add9853ae366ee354053be733add27da891fb061614d4b03819f29c0a6fe347af97aaa3c8a6af4db65a149ca5b58ad81b65b2647c7dcb8e85f5f6dfd637d66cbfc8bbf9c42659889f8667cd4277406011dff492ccb341240b81cb7c785f79eb67611ecb2703a2994d2a70a722779e4afdc5d8ceeb57ef8bff052aa0c26a9475ace1a9c1fe8e9fff61e88bb0b7ff5447aa4a6150e2ef8d71af060adf3e186acccca83422a9d8436b2ffc4bb07576844e3d965164f53fb292b697215376a27e6c8228d3793bb50bfee843676fa4cea08c4baaca491f27bbf687d063b2206de056e7b6f715039a03b45b33ea10c46a18be07a0c4bae2042c72e18259b37e5b640b0458b113c9e2865bea16fe933e7875a69752836a83454477c6f3c92f01cba0a089538e1477ffe027b0b50c59b43e1e8ce4a613f54b3933f7d913ed5b47bdc81eec0c06fdc03acd236d18b50ca8da5e45d488e6bc902e250731d50e715569f53984ecee3df46638891258c0be36e2d3fbcc89616e853ba288555d0b4dc27a7374ea07e9425b44826118ef0f5ab232aa7dcdcb361fa2dbba5a540ff6d3d2937e3e7874654eba13cd2b01f32ef35f48b85fbf4d5e259c31b810f1d6c8b526433d45eaa5d6d4ea8b10c5d544c924b187fe590d7d7763c673eec700a3ad23d9bcfae22435fe7556e84fa59070eb288a39a6b93324f8735b42428873f33a4188568b7e9bd8491910e51a3a54a1c48d5c54267d9e36d723aadfe22c4de00f3fe78a41ee6eed567427d3be70c474308c744feb92d4e458a60ecf58f280f510de4a661aeccfc2242e8e07d73fe81434aa47ff6c165114bc6a08332e03109b5e98ba7d44c737b3167f8d7b7a6aa3b9817a545e59b605e0898fad2a133ac7698eb5bc156d289be1387c6fc5ed44ba6010afb3965a834a6a0a753c6408b255a8dd6b294f3cb89ed9119a5f867f50ca7a16e34fa5a7e975afd36beff39fc65acf7bf0723526994e9e66ee9c102ba3fde52679164dbb0e335060c89974632de8952c43e5236c245364cb2910fce7015a6be920b6a62f610709aabcc5d428fc5562f2d9867ade3ca2ff267e7623e9f23035924a4e09e3e64a6fe89c883704e2c3d6dee526c6d4cfc576d4e91a64e2e62cb3935df861c22ce2924f0e48a4479c1ee4a0c124e494d48ad1488997dfb5e0aed114f537635687a268a0045832819039142799aca9c84f10991879c54dcaca2e9ac7b0ffa6ad547e26ffde20599f4d33874c285436f2608c95adf59942c4a98dc33b9ce42a6cf1369467265f044071567fb37d025a263a2bd2abe3538765c585e62b50591dc4c61c19e2d604f2aecb9ce5f3bfe07d58b196c41fac94dd56402b3f654b6aeae23ab62b8f516eaa61a9105a5ac938e37f2c88d23f904339d16150ef2e6e518017fea386cbd2e0c5611e557bfa08db4ee11b85d1cb748e2f2034d7ba97298818264567e983dc8a37c93301a20bad9bfa5a3b7cc8314c1caf01433449a04cf4fb73b4fc5dd722b1b6afee0516e2fc4c5d816e4b17234ce4f74c76ea8ba77a04fba44f879b846ae048f0f6d2f95f78c89f460b62657d56e257575ba8366af32b4f5bcfc920abf27456590b1c2963b03d61cc98cff5b2ebaf8f20f8c7131400d07a89fc89130ecbae5b4fcca1c14e44d883b09135bd5f26c783e9d929904b8ce40f421f89a8b0a1a7ee47a22a32d1a40bb749b55584fbd32318ca6cdbabf0c767b90f15d3566d428bad4de07e9a3587bbc734323feb8ed9660628244906d29615dbd636d9537377780a8081785f697c6bfcd72227df4ba1638757c0b39a8643782234967c40fcb07adcc28160ad6620be3972df8d221f8edd9bb59225b353b619d5a008a380d0743ddfbb5546d06b4167e9fe12d47cb9d96c5fc3287a5b2157aae10e97af09d1522f733b6f3fddde30403b3a68dd39106dba710964995efc114715ca7409c07fbeff98431aff9354d3b32a0c752a075d2d5ebc5fd6e25da7de68314e8554a4b68ad9bdf660c8561b798e382fdd26e36c288c8292c0c27da767baa2371757b46c9affc818d7071b1376af16ff855b7b6b20da257046c0b78127875421fe76bc0854f9c72b46164edb6a1d6f5be67da63b486ace111b35ff64a7165572d7c76154af8c24d58c6e431c4c91367579ca683ecdcff121f839af0995a20e9b0eee928d03771ccc35eeceedd67608b0c5ff66e67c14036a6bad6bcbd6f03be6ff223d00ca6438ab2ae08a4b2294e2be64ccc8d70754a2297082e48adaf91071c53d78bf338cefa659f3219de6031a0cfe7ba6e04fa0b46d5d069557f78f673eee28a1354dd7c873c0d55b160c54b62a12b327d2bf8f44ad9fd4198593ff10eeb10303fd6af251826cdbc7c5f5c11cec494421646de5b539e0cb930dc6be6e98d8848475ef9860386e1e391b7a7f43d2bb69d3163379c2bc04b6759e51641bfd39a5e0606ce99cf992d78d9c420617ff2f2a04a81174824c1f8a8679ddfaad1c6fff5865d819b898f30546099e20aea9456aa4bef2bfbc5645ee62afbcbbef44fd91ce5abdad9cbbe6b37aba2ce709d230d80a793fda48dbc28b5b9e7afd0afd15ef1793a4210fea0f857f0ec370b0a80ae15f7b79e392a0dab7fbfe82fb8ea5f13d40ab70f4b2747ffeb753fef769118f7dee33815c08cf87b881622f38bc4b2b92044215a5f9558bbad797a82a444d3c506e2fd4b835beb894fd0c5ebeee41731f96b3ff5d6e866f7b4c752c49e346cedd2fac7bb1a0108c83357d9e76ca06ef60aabd283817f00d1817315142c84019b11a729fc395a9ddb8d46545ce46a327020fbed5dc3c71f2ba398de3409df56b476e4195a7d5e271e96a1f178748fd9cfb696dd24afad6caaad336b537ae5f9c9dc4585634dc9461cec62abdcf89f724e1bba1953e5e56758e5193827fe156fb3734da5db9df17f529259e9827479053659787e33dfec3a4c7c6f3c16daf2e16831cdf0d6f1b2c7f1062f9d1f3e489df1ddcd69585622bc83ea938ed478b0b2712bafca3501c2d6c42010d08328826dc0129d78047b428770572ab3c0240de41611dee029f891792a618c120517dfe236975a8e4108ca2ce3ec20b3796ccc2e1533d019df0f31588f71ce9e930e045acbd180f127f52299886049f59f3cf1b1e459823f51bb1501ced53d3eb018d27c3dba0a82cf5ae1f01299938b348bb71f35966f98c00c91f6da54ffd9af868a3eedc2c8f4181221c77ea763186ddebfe80b06b2dda810b06a7a2425f8144825981dff012d087d64812c37a97b4b5124c22bb3e7853b5b036c0157189536b434c5b69dc2e23ce1197cc4b5306fec86d88426391e3327a6402c69343809bb2f529e0113a016e3806813aeaccee9a533112068c9da84a255b2467760d05f13ba34efd0197b095af07f2e7c136936e9d385aa7877e5a5ee7034ce89998a846d88731baeba071cd45f5da793881ac1005fae31b7ca060e50ca3372ad523a74fd645a6ab65f2999d02302f4aad32ca55eb849876f0206710a5be176b27c78bd6a377256951f986b7c32f9c27544c4227d2709d61cebc7b80c2cd0690f97be54e9cebd8e062ce1d84ccfe05c4a118ffc2579c175e9748186a34d169a1931f82e9b9aa679038b33666e4e44a33b5ed37bee1b249449626b74b4ff59b57189e17c9d5c2aa798a3f0ab3e3cc252d97024d87f70894e09a4ef9b74a85557fee35861fcb601e30b794227a5241e869aaa9ad851cf18ffa24605f7846e3a200a0cb8c4d19c9bd32d5269eba5cb870e40f5b45b027499c8b59c6b22ceb366d0fbc163f975c2492a2646c6d49f97567dd86ea2d1b014c581fc97a433534aa3ced4cbf50e6d8c5c73cc70f0909bbefcbb9f4a34629ee72a0535d060a600c4496bfbb76fe1d4a3491dcae653aefbc4e5c6bfa5161d569081ddd0a0ac2c10c67a58cc1bd6bf79d61511702872a845661c7aebbc702d37d4ee521087c761ad88ce3b9f54347a6502c689bb92be33792e1f283b1278d5d2be04713f90f54da6d9233d82ee4b7b85eaad90ed61c867c7eaca2e2a111155bb25662c9f520645cd8bb79318399d9fda44ab2155816a80f9d2846ae12ea6d8f4fc0c11da65aab7183f7a67ac6b167432492e27e0a15a61edfd89686c99b014583d9ad0418279abd291ee637ccac110d9e599a41ed24cdd5de177afb6533aa66d4e11e0bc6f6096e376caf552490cd52403e0889f800cf1235ff97b11f86427f8551feb080b9bd4bf694cdea802234840abbe556e2043ca1e9d3d06fa412bc799b8713b0528e420796187165a33be813c0bebd1085a04c7b7b58a7c141b503eae87d7f7e21038e8356c75fd2b5dcff5ca4cb00ecc225b91ddcea0f03f2a1ce34ae0d324d0609d7f5583b751643c79220b0163ed8e7e1c105c25ca2af505c6bf245fa91db4d50792225d4d85336c6edfd46340739d834c0e32a6af418f25207aba7be14200c2aa25cf457e72133485c172669c12b5c63efe6670ff31df2cf62e71a2432fed1c287c1c7cd9f15a0232a086e8c6a151874316c2161a2a907f4b1f55170d563a0504fe1c8fdf7e244f98443b287dab57bb4493470ddea6183e242334855c80929f252fc61df64c212c054adfc8a01bc60bd20a9a5d1ec9b8c9f829dbb7d46cbb7702213282f14079d7571ae28cf143fd6fb435b5080f7e325eda5328ca982cecf5f364669fcb6085973401765cd82b3d2bc404d5e9a7ce95f4b069d2ec4f2e6545b26cbce159b6d84dcf332067236ad600c73f75d4d7dbdb399050a3b4a7a94f9795a08471683afba12478ac4f6d58dd9c7e180cb1e3529c99a980ee54a6477c5b2574d1d213d773b0ca6a4fd0393ba49dee79a9bf7bd3a4f4ae128eee159690c510d400a956d60c16f7131d5d23d0e05d3a5c9b2a947757f08797bd30e1352e5a48b39e7ec85f8a669016ce6a8d1c7c0138aea090a650a1a4c2b2b8ecbfbf60317696cbd4505b45375b97ef72af1768021778e7c175a7d990453d3476858db990092e2ede6784fdccc982ada1f9489557ae0608f09ece416791978b0de29e92519214086c128f449211002519dec2890a21322f2e81b27fa7237668ea4daeb4adc684f465bdec52aecf06607293e2082e4d483cb022da1df20aa84d9734d3a1fe5fe891ae4807754ec1c1026e0760f7895602dbfa4517285a845eaf1528550986b25d456b5615fc8803f963bb252b33054ad2c1791b95206583d1a023852624d87f4f91ef832b86320e83adf5eb428637ce96d7e8135c076c30add05c8c866bcd89a4508d792594a45acdcce8be1fc1c525b1ba4e6d8eadcbf828ef4108315c6cea10ac40f1bb5854b7d9f649e9dc516c2bce4e10d9577f261b65a4ab6d1b73dfbc2c2f7e3a27e20681b1c5f2c89b6720e806b424668adf7402a96bff87df491487bc480b8f8c18c81df56077e6f71587ab38ac6c02e8546e93787d778fae53a0028c46b700f59b51c4be9d3c9a06f5faedaad28a5a7c038e03990ac1e62beea8b597ef7f6baefe98945cc706eba1042cce0bc6c7c53b6950d082513fc1f01a0ff6747572e96a34e11945e57a350d1186cf55571d1f4b83822d53484112c211125b01ad87b86ee202e5d83d35e490bf5159f36aa649121c724d5e9257c7c3c16b5a4fa2204299582a33a56fb50a555f1593eb6fa02b571161c6117f78a5a862f9fa8e6df0432e8a8bd2902bf11db4b14957148f75dcd23576f96f73110f95f4d07a26e55d1d4b7c0b3929ac031ba898845c705fab6727258c170a016bf3bc810820df9df0580db68a5276b8d60d494b193e5fc900fd7457899b151633f2b1d7efadce6ea4ac0c87a4cdd8455a6e30dfe83cc4b70c913f8d301209bc6ae1080032167edf885e0b30dcfbf0969bc0e415efd7711528d83a485bb39899daafc8e323496564ffc19de0df861d0fe6c65e27ebc6a23cdcb4e39f496b4f10a36af0265d9d3092afa988ef966716aa5b13eb007fb5a2cac316364504716ac737f545362addede616ea4d28b656ae811772e1322d7887157facda1711e4cb858068de85a23f2db1a258658743d7a90f618da0ed55ad7f26d6106229eab906940079893b291bf06be0ebff879df0d782d7678f6a1994aa5b1782a89d760a5748bfc9d55993c7f5d1a6d72e327b3d6bff1804ebaf52956a013f075a085ce0b2f9a29fbe8e535c35303280cae4a1ae56bac40777d9d41ced9fd1dce005fb2d359a53503213158ff20616ad4d193a039575df5c3d53cef01baf113a5650cc4fc487f6095df5909c405ef394ff8dd28739b06fedc02b1bc5103534028279bcaa388e8ba174e929107cdd408e71cd5b165007c965093bc7ccec7ddc85f03433e9f1ce40e5fa9000871cd4529a96399fbf57c0c02ad99c54dd597ea309546192df4b000085a21416fbb273ef80e3a79a1b44b41eff720f7d13c44e43b16d3d30bf29cc36fba943a0f7fbf56122ba38e87886e7ac5fc572d1ed7d1e3ae956beec254c4c310550f79a087f7a88f2a91b2d71e786a547b883dfb8ed37e0cfec27282018d2f167d0a95567df812d42d73eacf90da8859b4d7f09a651ca01d53f012dd85c39a405c9b5a3ab2cc8bea0d65794536dc8c0573486cc878ad895cecd6b30354eeaa3cdcfc19aa588509f4185a61a5c4d8050d2a0dd8ae04a6a37d877577ab90f13da69bf70da08cc9df03a78dc422c499bb3dc9a34f7666f3edb195b13ff042d6063ff65e9141d3607ef21194446a27e7e7b069b93decdc45102ea2754dd6e2d25795e681f1f1b9bea00e9ae52024decc1aca866d1f73c2549722fd0a896b8e5100c2df453fc8205cf1026de3ae38fcdd93354a12a44a236ebcc9515a40bc2ecc019a01f57fb45e50118d9d01c65c25feba46b93b7e4c034ea8845d4e480dc691e313115735247c825f22afd53fcbd017119557b21ed1fe73a4f28d23759df635863a732fc05a07db0d6522df5e5aed58eec44993970d95f6b0c79b55c642f441448c8893520210fb0eb07e8c0a5e23b1a47491b22d244a893c8f763d48ce65d69495cc9959f23f97e7d14b770063abcd6afbe943f541818dfc74a497768dfc0863ed63594c6f8461aea3c4ac9a1bcac5054f2ef23e916343383f3a8489f849fcc3dc0a1fc051fc783f03ab856eb9a03718cddb571696cbe83f8bfe796b283d489b8e56301f82fdedcfd666f20aa9d7a25184106abdf14f0269a09692d95e714d8c814f5017adafa1616ecad750b785697223cd6c146e1f25e1a0567306d81e7d6c54948dec2808f7c9facda1b6be596c4af74d84029bb29459b48849319625422ca034dc66d278cfb8f39d951ef5cdb57ad86fa2f88c5fa71f48438315f473532cc220fc38e6cdf7a387b154859090be3587d0bfe7fe7be8cdeb42af5c9d74b71191550d38fe4e084aae71fe9fd04b65de6758ce5eb3b498c98baff1596c0eba3265fd65ca158da44f8b3910e3cbf567ee0f725e6450aeed57a7be7a83eebe73a99723930ae2b1f6745399e7a049e44114fc08bf00802ba18c0437e30859e19c2b242f12383916af159b8fb61b26e45dea9deae4284cd8e81ad889237fd7dab35b3e53b81ff8a35a48298d4727eee2471dd25ddcc638d1dcc98d6cc31428a31dfcb016ffc002b57d3adbcb44135983b10db26504e8d7fc2f9766b788324e2a53b009229cdd0771d10d1e7ecba3f34b75139f0b966950d8a43383a8493aa5383d3950ab0d2c520f09e4892c53caf0b03f8d6eaf3d6fc884e4937d96e5289a94b0b715fbb60e636aa3039fe15c5c67c6a19aa10e933c9e1fea5507e0e563057564cea0f6555ef700239248a5eea0317f0bf4e8f001e35d2ab26884c20ea7946564ec2e67b7c51b27d1720bfc2f1655328f7c0a6bdcf7cb48292d9aeab95e9b845b3aef0cee02eb88d85f255ce238abd7e6c680ae3f63e3cdb9cd3719db0f8e54379238e885b03d6617df67aa7763ff1694441d4945485e676d48ad1204aaa57bf9f773c1c596d8e0aa2126fc1a03ddb6d6dc664a3a5fd6067ba22fb1b910087172761a91042616c3af86cbe9a456fa176e7463f7ddc2e4c5cdced8a40139336fd375fe26c0dc8521989591c9d22f3ec319b1cc8f88d2e951a6e5ff08a68c84a3df7517b66836c28fadc953c3b8c8b07255bba1e137125915f8472be1d23f663f96a52b4d4b4d077678a6e3dbe05305e06f6e8888fb1689ed9b1705d17bb08d0fe99e6f7bdc4a3cd15f71ea3b43a6b79c53be0b52ab8e73d8e5b6be79a78f54476736b57900fc848df18ab4d0d2c6f48b5172cd1d775a1538bb26e6ef370b332b43fad9c45eb6f88760c3c427d3806b9302176cc80f0613726cb3132e40b6efed6eae4d2120189bf74c8e8e4b27cc2d75ba5ac41de3c70fd3ae158dc9609e456971a4e4ffbc7a037144dc322bc66b7ef41b81d5335127b5d916e954164f29ce36f2715a9a199ee990cd9b7db97889b1a04e325cf7b4b3f26b223dd6946ec45e98912bdb69e12c741c0ad5980b53033f825dfe6774ee1dac758626d03f2c041dcb6a35771aafb833ce140963f51ea5ccd9e8b054c28eb95a13abf9c0bdc9d9388b17012b4f10bd9d20cff76ca5fa7de3a6d16c8358f795a9b45b03ba48b044bed15187ac5f3100adaae3247294eb6f759dba2825637098736ef7ae1942419600403d7b5a28f6000fb60899cc27f9eb857ae75e865e6db9092a2aa6e53578284ddd99076fc4690ca276a2b55d08345ccc63734aebd7bb437e661b93d30938ecf522d0874844e740a16bbfaaac8b0492111d2ceb5182ea387b6ccee5aad59cd31774f19ca3013786a4de559212e2546b6009c4178718e8c9d8c0361cd5ca1703ba2806c59613a986dd9f53e263cbf3d384229a21f71d0afde98202625e680c59d4e051ee1cc4ced107ce17c1a1a977c7e38ceb8da658ea8be60e693620fb1708c7a25dd0c1f88b87114c9f89a92926b37faf45a658ff1bb36bce43140c9274639ef63f2c1c89fe0d8f6dad9a8e255b4ea7afc7859680e7c5aafdd0a671c101c9bce49610b5c1ad27a28ac164e7ff02ca653483a365e1294dc3c9d66806ffcb91965c53217b54ab155179d45a3b5f53e3a1429f4f397fb0a0f538689e652b93045ac2a060979be8c685de901273f9952324ea94d121afb9c440a5f65602602f829654cbc6ced50846ce60e0e12a24eadf60e0a49cc67861713466ee6a15294db17e2f6b018d1cc417801abe0b4a041dead0083a9d8fd393743c63bbf4a34a94a9850c32620a599b16077b28a33b4dc0e76c80d7ff8f838cdb2653847c30ee4a7fd68977330ccdc49064b81edd38923bcb69ac4521120da2091ab29906c46f6ec23988973abd9c09de1a9f12f4cf105380b7aac40926fb2e58ea2942775079c4ceef06386b64d35d36bd074244b9637c856ac5f3008cfb5fa42caf2548dc1cfdd2b79519b9a90767fb91dcc2e1dadeb23e2ab4eae1c0ccd1b9165a44e82d786f8732924138caae722853ec895eee659a7a5c93aef67a40fa725c6886c9de3a457d8f11728c1891ee211f0f104f319ec8aec4acf1f73aa9d137ffacfc5e87a9a25dc0117ef10bf44e9aa1909b78d3bdd4a276378ad811c43015a7fb2ece55317f3b9cb73b9c71188c5ed8d0f34c44bf98e8cc9294c731b7f3bdff9b0cc313fdf791f763fbb34c011075df03eb9f81362fc795d1bc181e897e247dc2eed363dc5c9a161f24f68b2cbb4d3028accdaf3c7f1dec0138d20bdd4ae87f297505e784c318db7b205ccc87680854222c535cd4b207b6baee9459a2d54e37fe07bd08123cda6742e85a40cbed26a875feb65ff17ad8ed160722abacad8e276c96ff4398be0ad30082bd483bcd0c864b20cbf8ff97e34185200421e2c481c1f7068b354ba3b37db81533a36603bead4d5a76570ce833415a915d9a3398ed2e23b0bc253f25a4b8567d817534a8fcef8ebf31c97931a2da4115882a70388fd2bea883d0ca6fea048b3aa33535e95a0e8995991a70138c370b18cfdbe70602a4dd044d94d8bb79d9436381647eab2c642c8d0c3126e9f14ce7e8af76ae3b13457f272f11e12468f666fc2d6ed0ea918f2d585a0911684170354396ad6f5603e57bcb10096ff43f502e98328ad612f9eeb9de050ffd685d9cbf734f0938e7b5f12438ffdc83891d84cef5132c10fb3713d87fa80455c7f96696ff6222aed7ad112fb0b14415db8da43a728f351c75098ab3d793d418bef4eb34199e86b17d9bff53add48278fdbd4a38b3bdc5d68180701424c19646902cd287f427f7f1eff8396bf9a9b9ea873719dce0202be015f5f988541255bf9aa47ac88faba62057a5e95f7ab8eba307d4624d1bb734b50f29fb177f201e0abc343f9b4ab35b385f78dd2169e0596103ae6bd86ef3243f2f095110680960778ebc5a543729f42a333743e5a8e9a5f72711a9d1d1a99164d6d861f7b1b648dab846b6d348788d087f70fed15400185e3b77260e6a706b83c7ba035e369da38fc18909aec7f232731e474918540e0c5fe008630551db06140176a1072191dc73e4fb0ad095bcd6b1b5a943c59370f62e9a36ed6919855a9d1f7bce1799ca8f2ddf7174dfab87ae00435545278aa8aa47c648429df5dab6dcad4a91368382075c300390691e07672f7c61501e7f612cb1380881b73c37ecdccb8fa30ae2a193b6c67360e5db3668f0850566ecc21ee62b8fe88562faedc31931acb7cf1829ffe79909fb8eff724b5afb53227f360c87a2b3a76587a76742dd64d072f0853e3a39a07762eda09c199a02ab5edc7409370fdf9f39c25ae57b84e47abd5b92a37fc19c5fbf44c6f8756bde664c6cfc85d4cbc31af71c62cc3d8be93cb9efe963e0b3c47e36c81376c06af5afb1c1982ea93b9672be1059e573ef467cbb03b614ec7a140020902c37f5a7806174d2bf41fa5ad06c2c54cedba901f2fef001e55ce99c1d9f37c8e6d2a868833283a61916b1171b5f700dfce22c7398afe411ae00c7092231653cc5491f7fcabfd657800638e22d31e18fd4209ae9e0fa3c4cc54cbf0e93d36c8692aaf02e88784213abbabe5abd6147708526605e1bc1618e63c754750bbae71938fab5cf10227a8b96c01a490eb1c8a641f410f028e81ff965e57dafbd840240825dd30be3909e1601bbe06004b75b1ec10b89b9e044cb09ab79b65d83253a9e3767cfc1d157c9a015300da49b8ed6c9211003344d1acb11669d9b5802870a580c63498033a9a8bf17bbf436d16fcbe47af4ba0c5cf759cf0a2a70e94fd79cf78e10f36a86d4b08a167695303c3c3b7aead0333fa307bba50012964b72b8ee63a06374d3acef19a30a600fda151a99f5c321037dee1d17587184c2f6a11e7aa85b769cae5efa5d4d03c4020c952a863827815bd959a40861019eeea966aadb2e6d4b1bb32462fadd54be16fbb72232c95c128daedd3a726e27396a8c5c34c72580618ead02b144c4d592caa06358510ccaa88b82cbcaec883639fb73eefe20567b49b1b88237ad9d8459a8aefa6e8ca8514bb76d2e9540f1896e9156152273c8338b98a33c69500f1ce081f817cbae545cfbf2624a67f66bd68d9da9cef3426b194fc9e56797ed0d47ce042851f820be89efc0a3ac4450b50201ef5579092def14d195f561783bb03bfccb85dcf0d40885453f1fc0ea42c22f5fbea0827db894bad32cce4e977c034b2f69948e895be1a46fcfcf06e4fac03fad086676446ee7c0143decb69ee44dd13f381d27c8345dc7d4a5ec54059bec37b4956c666c095c7552d36e4b83e186ebd11e716919bf02f394206e3fe0f49e741142c7f3f68fb975b7069d8d847cf231deec68a228971ec7ab55eb57176c0e0c60e5e3dcece6113eed7c08f59988febc5bd1f25ce9e6d74feff729f718671bd0a360ef09fdf3eb07f8934f59b18093855c11cc6bccfc7fbe5538f97ca21c64e5f0af77e579d497a270663f6f4a06032ec55550944d7192dc64699df676ca4b3b706eaf05bdc7644b3c313ffb244660e7e71099487b30887e1d5583437a552fd2f5f0c74a2d78555ed9db338704335886d74e891b1593de4bd46106ef7a99524bc607be93f5bf0cae61e81258452c4d4cc387fdc1bb98bbd709efe8b95bd044e118dff064bc0279d9579a41c43849b182dc089694eb7054a9350468faf7454e9610da26b112f8557203dfd6cbf81643a3d55fe78dadde5984d54f60d15f676e796aed2cc1106ba861924ec7f54f9a21806b5a79ffe4f917a22b52bd44d21e9f41d0e606e1321a0632a58827bbced5ef37c96706b899f2384f93b70ff0a394030cf5a40cdde0bb6d3960e3a9fb4725a521d70dcc6929393b29097294b0370d25c2652ce2f419313eae701cd018c0d1d32372aed552139bdc238adcd0414fde4715d7b182b0b1bb225ee3f269ea8e04210344598caa0f72bd2e6aa645989ca26b2f952bd831037c6e06430baab1ba87d54a85e0ddb84ef4d2b58505abb90d82995af7193256eae85499a4e5fd3952b9ac0b85668f3c07a7d7c3364ab912aa83c89f8fbaaab13055d73d3d36289d9274d7996a9c607cbd60d5578b4c1001bc3188e579aed910f6c74f7579ecef808694f371f04fa64ef8c729071fe41a6ee74541d710b52d646d7258b4c8937357210cc57ba9894a1bb60035f828f96055b53c30c4e4c42091e6c66f93baa118cf3b602d1c12e8e82588870199a312f99a8d4cd4e0d62833780d9be0a3a76480c057d1f3d8099854d233c3cded1f408c2c238ba59ebb58cb905d1ba52f6323429a4603c1ca3963adef9aa7c653614179f5fecdbaf57f40d36a2f65e10a6fff303ca35f6182d33f8643abe4c2bf70510567773246f632eb5644850b603128c9bcc865371088bcf718c54c43f5aebe303b3b04f899e820f1120ebf05fc4c57b71baa389e9acfa9e0f564e6276f1673925335c7abe6c3feb0b932fff2a47ed7285b5b087ca748656da5efb35607614e603cce82e81d6addae7c3b663c7843f62b28fdacfe7716a68cfc6dfccc9ee9cc7083d3d4ca8ff44665a2c391a43507b729ad41370a912b194191d1f2ab2922ea08bfbbb86373c819be604d2f2a0df26f96ff4981c07547e06b66cba7ec967b5ba17183cbdc28b579e0bd864192505234fe52044ab09eaa79431faffd4c15b92e245fdc42f9bb3750823c293a8174ce51cbfcaf41f39b907d3eb23ed2b28f038f8c1754aa32204680f02d02e7e5ce2f136b776a4d806c35782a2863639e7453f3148c3534399a2529fdd671b37090f11cdef080e27b7add2d13bae920a6eadb2c5a6728fa70b94439ad5d9842465d6583f250cec0345a663dbf0df325e33255839095e5194ea9cc4492905a452014a2516fe598c61caf6ab2cae0eb4d7ddf0391d21cb8ab9b45f8ef95b4e60836d92c4683be97879fb1723bd28723a9e5456f6173e244e13fa1da6d9b8b990fab11ba5c945bb92d58426ed077c56a331c2eb0da2a9829de83ae900aca33f1295f8173004251ea4722d0cc8abf10e3318537658c03564798d244e66c00f8ab951ebdaba531b3f81d9e068639eb07e6b5979116aaf5683816cfba1f9cef2b97cac0d25e775f38103286fe42d7788cd4d04ca75c787cdb14eec5be029a9be4b5e34fedda36f0a19bdf75a8593c41ad2210c455efda90a58fde6174a165d596e7e367cffb2dbb89cdd972cba2ab1ebba2b62c2b9854c04c35f7933ce32aad9f621fbeb2e551e83a439d10b7beb916e0c2b365bae791ae62d0d1f1099a5ff5e6f17a0a3aa02f43c1b463808ac1fd6de4fe529f9875e9c9b95ae6726000de34ecb63c265c8738dc8eb37edb622786178493bfbb687b50936c2ebd06edd04e3c30bbf03dda007a4d7b61eeef7a47171c48aaa46e680d31d98541540ecb971fada07443582374ae441ccff7d50a58972beb95d7d8cbc5c286cac552f88c8408d0524995185a6cc37a27f90f2cb8ac026db384df3a95152fe7ff3eefa77c4ec44ce390faf8fc8c650c2b97d33e1316c46095c7a12eac5e0017a56dcae88eaa338a529fa9163814ac6884658ff9a91dde814fc2cffaee4926af11419e5281acc3d258070a5ec11a95d1fca20aa61393c53d0ca6df6738e689c918cb5fedc56286276bc9d551776a31f78e29913863479731eb5638a5c6b8310a4fbb4fa4bd01bbef6d4f4fb30fb2c4ffde675c48926997da3e35228a3311c68a9c53a4861eb4dbeca5ab6247e0f2e7b3bd1b8f8d1f68ea60aeaa68abce312801334ac354dd853847ff173e02d8373e92e4fa27f2a084a1d1a269fb899201757a60a9ac2fba721e6163991a34fc8d067b9ccd57b63e334bf675e80849e0e2ba553ba35ea453b66ff7e67e5f5e12bcd39a2d72c20f955d04ef066e4b664eff77a1437a847d4498f1bc11cd226e47b484a417674308c4c08ddeb0128d94dbef7ae02115fef9c1bc0d79ece521d78cbdcbdb6ebf333fca3630074cd50da83b38fb7e50199aa7d3fe597c0a5344284a5d11165f8ee8e5928b3684a820874319f3c458287d2f088967244a6666c2aec3333fdbad167108778ed512bc56ee07a37a6d17cd3163ede6846e253ecc8095c725625bab58c915e1fe418df4fde06efd7b4b7b7f68e06e207032a5430d0f70741c9a676fc414ca4780021740d9864475c7c0a00dd7a42857201601319abde470679c9cdf319698fd16f855b69d3ff00cee52b30acb147fa77bb5039b1b7efd49824d863c4ecf1aaec7d38b25f38576abe88f4f975a5696bc00de6877e1eeece581c07a861b8b0e3417e2a8db6178259c0536f19fab5057a6ed7ca27cab07872cc772cea8cfcefcbf11aad77d42be4b9e18cbe2f28e0da29fdca19e819244482dc4dd226f9a169153ff66731ffb8f157a9a57510b967ad065ca8a69bb29062cbfd953b34a440769d40d945e533325ce6d51e4bcbb248ee0db39df4b3637b02757f33b1741e52e1cf1be852b1f69520b0119e1a03702b228f12fc2cd3ea07343a65f0ad217ba3a675f713327c1b2ef29fda300cf6354a5f4803c42214301553251116bc078feee678c96f5927eb9ffff0947bb4b3601ed30933ead33d9dca0f05306eeec597c51d5ca7d63d07d90fdc282a6f9ed898f5571fe9dae6b822bb714feb004c75d32bb53bfe9ab33380dbb8e554495177e472615a5e34a7568b078f300bddd7956611e4de6418ea317454663cff58111c76ec58832162e0f013e689ebfb6a6054a1b2807b3979bb267065e96fc3d4f64632f2dfeaccccd3cd1042f95a408e102a4c7997bde1caeaa82c7c74b24e771eac606819bf09c079581403b8c4f689bf76f077fcccd25e2c7dc990f6f9a06eb406bd33dd9a69cd590a22eb7ffadd4e7d8742708caa675998d0fc09b9298d3795c2af73fce94d2f5e57ef5ac0ea49c3298ed46d13c0f875aa80c007c001384716b8a437ced7abd13854e7967920dd35d4a17a63a4b94e0e4c0d6ae1b5d33c566989377570340050ed47bfe328b26965fc2c4e895a0f60a78798668d863e7715f08ee3d7dd318152cc5c5bb4e2f45039cb54bed515458e9092ac04c60179927c9b8aed1c9d1e2fe9bd60ed1c397d0d3de3adff0ab7c5920e9df098610a14c467ffdda671ba7d25c7790b39dbdae7413b87caafa44a0913f7f1b14304519c491172c62585487e05a51456249e04f2fbbddc0d6580897fb5ef779adb2de75d411c5d023a4037b831f56150072b8da54c7ec9f3c63a105da6d34cfb4e177b9dc5e359c75f38f4243643c7a5491af4b71d0aced645275e99bb3844c1efd3312ea647b3912cd1aafeda4600eb141addcfd66448b8a5859054a547734cd116cfa358777df384e754f0861a42203e43f52f7e7f0eeda47378c903adc256b2991c6144b70d1ce42b324fa1e824b4a402daad6a911b0979474a1246d3bcb64f5a1c1bc192f92cdb484ca4411777451714983c4ec7028f95c7946cf9b200baa0729f971a273c564a9a64a6c67c72a963f28807be58368e23b0202e15a03a0acca75d36571f75775b5272e81c3f7d81945ab0dd6373636ccd19c3d944502415f9685744a53a9424c6fb0adf7bfe55ba6b76b240296afff33586551e1c44f6fb52f4686d8b94aabeb6e9ce0dc999d3f7843c6d35a90fe5e0b75baf4ee53f6206b6cee500ec1fe8d8724c2aa9be641520deb27ba09e8039d8648ffd873f01c36985cee2b9bdac6922ffb4a3cb306dbba0775a9d5ef7ec866ddfb9864fb087830ee54f89b696a3ebeaf8db13bed00fd417e1a9bae08266833e2f539a13","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
