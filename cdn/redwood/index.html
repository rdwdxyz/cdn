<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4e2c9ee7f118cd9f774cda1e6e0319621c227c42529fd240198f497f38bc55154cc10b13ade733129c05513828dcf433118297e7442ad265d7099d6e1f235fc570c01bb76bffb09e5e3190982f5a37935bcccb735c24dc2fdad29c2c419d73cc77f5e799e33b06a1a49dfd73f50ec8f25d9f61b822f6251e073945146388640513a30933b7157fb2d5cd8687d754088483520d4ef9aa0e8843127b4d2464bdec1577a50b08f71434b44bb3f10cd92fe9e369164a795c3851fa38b63dd822bb9aa20c6213179d3e63b20519c94b64f216bd373211ef2db47ef1f5fa7d2160f943885974cf71d7e61dcddcbfae15534d44340448c223de06d719aea457e217c50bccc92fa1cda41eef780c17aa8b96e023836885e172dfeb27c49fcb6ae75ac119b0b7e76491214a3e9460dda42fde569f066ff708c38996f2a07616de5bb5f78f3bea6c48a66d1af4ace80e6331710dab409941f3b7edaee3c9a54133aa43ff6fdada30331f6e299fde7f43e94ae67090400f947299cccb7493f70a771be294067737ca51cebd0a0cc6a7e35e8e7a77281b84de568eb30213fff99610fd26883de8f2e64f6fa2ce14be4cafa99e3cfda0822da9c609b23948636dd35a0ab3f148da0189f17685f9428a5b94aa0a34e78fbffc0dce075181630d3c453cc4fe0273a793d68d0f8e4704234c1ddac780b2ac59a801c6ad66774d64534dc092a61dbdb0ffc8c4e73fc8bab173be168420601a1a2a8e429fd2fed5ec54d3bb12e1a8433b5533d87681b12aa778cbb3ef65f82a3ef21196708fb93dce711fc6286e0f30d3c457c1a8e43982610cb6ca26934f28f986a49e1e23fe1f5ff2d5613045c5a8c3b96a21dd4c55b5920033350951d251fc5bb767c7b627baf0521d006e644ed91a5b81c9d85b2478ebad142f1455e02e224214696383b8520fdbf46097df92eab2d4a0da2d1b4fad748dec0d75c3b139062f10466420833d10ebdf2e147e493c79a3cf6dbe6146eda8636e650a870bdd36742f2932660b703c870ac9df1f09e961212dff74cf7879f3e99f9b4e8b26e590aa3c7927f88d9385f8a46719ebb5530e96b8d1f9d5d69782dba01b24a2947bb74c5da9c25efba869a6bd62dcb646d263fb783ee4c2ce286d016a6a5b48a2017a5e74dc8d50afa7041030fbaafa5c0cdc68980dfabfd87deb7754e96a261d5fbcb9d183d447f9f8b800209c4a3cc3bb7bb0b7d8c0bacbdc8668724ada19e275ff66e8b53ba1f07cfd0cf322806c2180e905dbd5ee91664fb792cd4c03301358b52c12de0857c128baa0deb045ebba0455dd370a78288defadc947992c8e02510fc984790f4193f3bbff27339b546a42d7b30b97e2627b919ef1d79b97484162ae3f60a6b297f6518dcfbeb0e848c0389525c29a37792ec80aa2d10d0293acba2dc41dfc24e023eeb82ebaa39ce3a3270011e10456080a6af641e744d0d33d1217ada11f7a2169e08cd0f56be5550b3f9534e031d16923b2fcf1d77407cd4cc35fa7281460549f8c3878cd595910ba3153def08b9f66ff8779d1e6c5f56dfc6f3abcb9c1de3e0f80afb8ce2c2cb07e829b761a61aafe09610c394c65790d9d96a6bb926a7ef70255a49dcfe6d5c7dcfabd8944c3f99c2ce646a473aa1a8a60506655e6c29ce7e3a4f5231ae0eeca5657fb3e6793c0144a1ddf7d85cc30944ff440308bd149b2b0d23124b1c9398da1d4a841267fbf2ba4abaa762d2f9188b6096dde7f407e9b2ac9cecc88a395e1fa769e26ae4d102e84f3c644c6f517baa67209927dc21a7e2d614808c3e6a672d73f8b354d94acd72bf4ee74aab33b883266b06b3e57615d533964a23a74ceb8f07a91ff981f4be8affd11a3462f4aa9938f58cf40911b122b56a0e3a106756c17b40f9f05092c17537ad493a15ad0f44d6e168fb1f778dab0668d66efe48b39f310dab30ea68b271d93a0e78840608c011bf3c16c9e5cad43b482740c08084b00f17a486ee916d95646c93067c0241a32dd4f5d1e72d87072796e744bfe30598fc951af93cd0d7d7e9b03f2c0def586c22b979fa994df8869e74799878ac282a6d60bf0a3b32e675b1a4ac1254e716bc0c07a4031ecd5ad26dafc10b6c3fcafc17b1effc3b373f992cbc1d52e60ef6504d250f2d8cab4d0c50febb2d9962072fb827ad61dfc4ee289069ed46453eaf9d7540697cbc550de25caf30152261502e08705d496049719a6323824ff941f29afe0377f692076e2c189f211cd7a97b2343f5d21f51d0e937806d687f820fdfa54cec322cda3a059307d123044c147c17b7360399980f04e504b02c2ff72b3b6008c098f437ffc5c9a2bee3d412a0c937cb64d8935f2b07278759663f5c8ce63361577c242c3b607f3508ffbc0fe6d14f9171178b050b8d695401128020a55cd6bb9e2f3f8e85ffc649943fbc35498239e10079a03df7198b895a52cc3595cdbd07fe4a52da94b28694be994bc89a61ba8d17a93f3b17467d68480c3ef5dcf903b8fe1d5d783a9b45036338ac74c0e09132ce2dbe6b2d7b3f57d015eafcf3f0a3d5d2c90769907827a33cac9d006b400c013a71c2b63cf1a360b0872db2488fce4c680861012e05126fcd454ee35b7cdd71c221ea5b697fc5d6996f3f633c5de7c69816ab935f072d54990f130ae5a74c98005c4f348ca555ba004b47f0354d18c5700f0979514563191a48cccd037434321d43ecb02e498fc08ee467bf7f1005e404a238857f0912879c0653152b4de573b233bbe94b2c00d11c9a7b5b52cf905be2ed75960fb3b4126a3e23ab0609c171e3ba90965cf202078e94590e036f265a3ddc69a80579f3226fd6272223d0c8247dfec97ee830376e12fe3c61600e20e428f14ffe33a8ce55e8e74cb9bbcc87dd79add4ced9b16af9620f15fbb6f2946dc821e420667300900d697da0f91bbf8a882fc6d2fc20ace61124760c35b7d6556d9900759d293ea1d86e9698fab5b588e1c38673f95a798a747ad8d34a2fed912d2bbbd2b85971a4506e21c41873bac9a2d1a9e33d647e161a925da5abb11f94f28d033939864c3e5b3c1ea3aad20b0e30f5c0ff721b6484563fbb7d6d7a2a5569dfbe49f90a095627e5ff3c6c733dbdcef999c4a6903a05756c390f7992b1b8945dc4f84b275a438a8e142a7446ee6a3d74c776525d202e903958e7ca0b831cb18fc77b36ac981c48c2e4d88cbf34cb85920ed1437dc2e4ea09f91b9bc8972da5afedc7f71ec5cc71fdbb02645e3ac14fc36bbe2de77a4e51b0fc033edf0c70b57c4077b7be7245c2a32534d5c21284a7fb7fcdbcd6801c28e059b47fbb5ca5ad2f9ae359201af1e225bba4e945665181bb165c68e20977c5698af044336f9931b64a32cc4b4175b50374e8669ab96c144cf9d67a82464eb322d75734d313d974c37de714eeee912d50a83b8e34afcc9b8fe6d1dcf0662ab5d2a3247a4c3cdc34bda86486a1aa75c75cbb2441b5ef6cf59311fb46651421e7c4eb9692ad345aa8e73832d533efece7b2fa6f175d2d8f27176a464e951184c42d45392bb56f0515e6372ea480066b9487b2fd31b3902bf655b2573669d1e6bbe587ff918687b7c7a421961323552dcdb1835c62ea728e053f7ef0924ef1d58b2447d9d1cbf5f85f35bf43fc4e01a06bbd5987e4c920f9c9996029832f1eb2fff5cd442f6c2d8612ac611c37adde5b2b9dd7634c39b5d88a95aa562475401248333e3ced4de92e28eef00c5a903cce7e1836b5e57c5be38a29d6602f3b339318f5f15c41300ca87535e5726bdf283f7654d660ecfabaf6d454b633a044f6adfbe0878f95087daa08517346f12c8c2e4977b2010ca4a66c0508221b0080bc788767efdf06210064c1436704f76ef24126e0ae86277abca13b974ece9ca9340cab80af9ca24babf5e344955a8e8e548f6559ec9964f2aaa30b3b8aac1f8f299a2d9e46c5815ff6837a7ef2d1870c8e6fe28855100a81cfa02384404a0c9f4b07c926886527b4f79b87cb7c62d7d38fbf9e085b540c46fc6c81ea9357f520d7aaf1f330f53d066c6ed829ca6d4c0222e19671c1f1899f12e1499ebd37db13026f0fea52376e282975fa48eef24c5a370dfc42bdc4d9a2e11b4ce4ae23e1d943f668a2b06e3c338a4374467a9993bc9cba97512e65dda9f305c4e00c631da727142a2fb5e9a7e218043ca74b04bb17d96135fd6ffcc2038a07879523acd609c235d5858bfef6a8b204678f8ec79d5b2caedcfdf2559630c8d8cabdcdeaa08de82dc03e2969fbeb2fc19d3db5b80b68e4c56cf3bfda7ddb72892e6850772bc524f0042383a28e866d776d9bb1a353e38b7b2c63b101e489dfb6f645edc14c7c2b444375319912652313d91b978869391897d58b7c5b8b24f9bb7146b6b282ef1a91548290e78c02f55e5fbdfec26f8c55574433d01f9a712e4350cb93885f6c0e8b75e49ff59d105aa01024e8aefda0ec260e952b65cbc2f58e7c2746cf625010e894e7e8b371d25b793935cdb66464372c842bc19ba4239c5e1c0670b38fe73de9e8d98aec4971582c20dc27906cbc7c55253c0acb53753a4fa5960bcf802bedb1d8e27a33a30ad6adeb17bee00acaa4017d178866f98d4c6987e19be09c05d43d59b7e96d4bd8616d05a6870e71520549df4b112d8bc61b477651ed3f0f9932f71a5af4a3cc22b370fdc47f27d7fc13b35c9ea27d74c9e35293617396915a88f56b70409b4192fe8475093e515c264745109c8558e817275a841616b11b2cb3e8479cac00c504c458d21be57a72b468ea19756e733c08a0f1cb0ecc068d8af884854d13cb50f5cde9b0e71679df1b6846542dfb2108ceb3cba8be70f533c11cbc3d340a9f73749fac5300e09eed887b98169c786851319191aff8eef8f6a1089fe1b41ac96867c3432b022ea52724751b0a41a3e95e36bb44a07b4840115dce54cc1f8058df8af9053b9090acf5841296e8028bfac347a5b93371ad4619d082fb0e853d936a4c52301e1b100e6063b0edb8ead2de3d9b9c0d9f6d1ced2a4799f4264ffe529dc4d96b31a567efd5724448d82100007fca5724edea05f5bdbb025bf3404e96eabc69f75602af62d0c89df4f13bd2ab646f2aea609372875f9eb6f8237386e8268366037c47e90eca9a175a8b16a1a14e1cd9d2b71ec1117b230e0edd19b4918c67fd5d912e124494872743f4c5f5819eacd7af1d74b41a1da0bb833b2e60af6a6d0e5983f20fe120d32221339c9729480303cb14984b84764b588457d910c0c3aaf27f0c04349b01edc4713c02832a75bc9b6e180d01e99056e34b3418f699396693416ea9bd071479ac6db8f33fdaee081d911f28dcf23414c18dced213cc42930825222a98f2e97835cf7c746d8e5f63018038f72cdd8b131774507ea321d467dc974d4b73a4ef6f84a68d7265bdb8a667732e0caa1e15581d93d8653810b401b9914419e3cc6b774234bac523c8e4bd06227f3cf1eb343148b78471196b652da732eb5664e2d95c981f7874252700d656b3590492be3bf76c26ce3a5dcf276f171917a55b51355889a5c22072bac8e095aa17f8db34ce8964a9b4ec5d90a5946e90f7914fc24e7fa8165a10d52fc856796d4c5ad4bfccd2b405312a22cdeae4637a566d2434a19064faed1d52cc2313930262b94263817c96f1e0d59704c152f6568044e3ea7dca0fd73990eb4ffc0200181f0dbb62d3c5ddcda70be12dd8e5cb0e5b34a594876d231d2a275202580f47e4f907697a5a6215a07716440b6245c06ae7f4cb91ad539f52d0c66f0ce81e4a21a478fbf6a3b07ab6f992948d95740238b258a2f18c0d416b98bd4c40be45fd353c726962f34026168011b90a2fa279abdb0543cd1f675a80b1494463a25e00cec7006247b723d0c397712684fa207afdedc2cccb5d82f671754e390d0ea9396bec047acdc3f95dc4cebe86963c088bf71e284705b8cf6f550fe4966da8ea5a0576510d8488839a65b45a90d83d6a30b199820620f2f38be992b863e70356835ccb9c83f6682ddc0ddcb388cf2668da93fe9e8edb63030e257422219a0aa186b919c43b41f58ef76f701bd6dcc0c196b1fa6349f6d9e780e6519ee0ee20fd3731b97b5fdb35635168218cebd4b12ea10cc43f3246d8c89c1fa34c886d24316cca5550e2c937e58655fb41da49ea8687ed10008cade115e1631156a12da7edcece568505f5427b03fb93469c2509b8546d421ecae056b8fc5e532b6452c40fc0abfbcd30305d277a9f91015497721964afd052128ce38cf980977a44463c9b5cf9412de4716a2cd28b8564095f3e599dffc2a183cf445a97d973448622436922722610d346d71482bd7edf8ca6da7491226f08fab9c39d8b5520e8fd1680cb775aae7ad6f192d8035684427ee5be14e70217151b54b47debb00b7141bc7b4e5ca009d130aa60f9df2d5d06159c5fbcef956605576102177a82dd1a4593980479020e83dbf275079a06fa8d0c24cd13c09892ef2edd0afb59c3f8aefcc9cf34afc4d77323a679aa96138fcdd3d07a007291d6a204ab56179d41c87674bb7f080c5cc5fe3ee540b716704b547fa11578bd85acde7bb4029c14d5f06c033135711e90fe1b891d09002e8fff5cea9ad39b5c6bdffee8ab69d2db4e85415b12649391cf709c7cf625ae701d7992c066b26e2de14fb268d61d88fd60d4a0f964b11c580855e0eb30da9c5a33a59603227827be35bc85bf22ecfb347c09e97a0d6aef162379743539ed7425834957fca8ff2ff0a48f19d94eefba8c4f677070b5188754d09ac390705eb0cef1c62b3f6169bc4d423d379e9cef84b18483e72ad8bfb7be912b892db13a9a08e1f143468ec2d1e5ad44a06553797483b9f11d97324a5242e4b27a16562104ecbd5872b89ac64a1861b07a42ecfa0f7026e7b2adcf80417b9ee8405ba3995dec7ea9e19705e1527e7fff1d40999f0d16accf0dc40db5f29af9747d4f7590f84cf21bd06c92e4f29cbb58f8f7dd9c2e561b16fc73380229d9f0456bce2afe19f296c4c51e4e649dcf06498f2a9591909b7161f4ff3891242ef60383840c38e957b5af57b4a51bdffef56765fd4455f6521f84d92b5cb172b30e0550312809dbbe8540efae52693e10471a9674c712421716f452f6aceb699736e0c76c243bc7e2d8e75765905b2d5b5b64b2ce10ffbbd27ac6b6aeef968be6e9651d964aaf5ba902e6cb9dfd1b9fe37b12cda20ab1d4d85bd300127a98aae09549526ea87cfc8aab89ae62fa9921e51ee5cc1774a691e50338f70c555fec8ee182ccd539a37e2b6d0586dc8d6073a9741b01ecf4cf8846642ad4bdcf9af8e0673addb3c1e655c1c7ea4978f0a54388510e8e13d7f66e8b1209e538ae5907fa002990497a76d781989d8450087c77667f7a68eb44acc79b3beade6391feb0ec5b32e0bffee14288d0a11eab3ba6d711be0f5ee289fa526556950d41691d8600963f84ab47e601eec67ce9e6e2854b59db472f9332d74970a6b5eb441499c307d5ede4d3577196640dbd926d9428c0afcbf6064d3681d38a3ca98d9ae7fac00041c9fdbe6a7b90b301231f61e8431a3f977df395a60ca30dea08559145dd7c5cad708ca1a4983156139b8526866457b7fb4ff0830c6a9c36ea2f2df41d4a0139bd4eed1df3f83b153208642167d2c51ddcf0dc3670df1b5265eb197a5f24a509b388337e87215245a8dbeefd544dd927fee7c2d92c1eab3c1268bd9808c826557ddf7848a66ab1df553447a7a0ae9f9b1bd8fbbbd832192b1a48c02c86a639c7e1f84140b23b43ef92ae263de24c3ae18d8fd4315e78c56aa36d024ff4484ce35659da80e067f065643ab3667dcc7b96e161812c1d0512aa28c3999e55d2400b3154efe47753b80cad3bfe9332908b081f3e1b77018964464d3539f0c3c5aea826e89b9f667a075b98d6f7fb7450217a45761c899c5dfc633323d991e618212603ab42b70db30157a721d49e9a69d4cde51c2bb0208ea855d6aa7fe6146e6f7079bc233ecf2a245755c4e5673c93578862e8b0f20f3eb3fe1e2003bc81f408821cebac8d330c1b4f28b8c09bbc983b237d5cb292e2e3116df110e9bf1402d7653dfd3d70a6f4746b8ec5850d889bb7f1c73a3975e3251f602249e487c7ea79ed85da4cbb0d2270bde5cdcd29b7cb4cf23807f0e623a1d0c8917bb2c25bc72802f7ff38d7ef908c4d26223c48b5d340ef8a3795b4b9bb62849001fbe9d9278806a3264bba461d1d6b9117fd82d9a8f264f7d730eb559be840bcd1399fd437a676a8728224406283a8bcb3aca15b80427019a734f1f2c21d293dd2a838d167c79aef05ad18cdb788b29a4d12f49b81ee403cef796d83704c7423087a8f64b6c0be7a2a977180ff293dea7954b925bc5ee3456e36c010ba6a8f14a8280275af10ec4920345d903c7b7cfcf63a023cb5c64037f344de8c0be9f121037fd5f4fa4f05ec24e4db5ca6b8e370a23bd43298f1f1e76ffe83e72c712e4965c0a6b32a45e79c8d7d7262ae299545a40418a7ea58954238fc5eaf696cb4474cd9cedfa175babd35960c889b5fef4aa590024381c262b736156bcfc7d7ed4103b7f14b89f76e9ef618590355b0de8bd46ed21ab6e486636ff7cf0d219aff79bb11e9ef85cd047fb3cf48fc153727f6f9bbe292a280c7c1c643500b32db336029a96c987a0fbe205a2658acbcebed768a6b708f3126f428fc93a0586ccaa9b428f60f51d4c65cca91dc023774f40cc9d90e0526c196b68de97aaac4bf9db33b0079ce0df0b1d09eadf18db6931e445966e2bb8e7e96af4989828830f9ed7ed92d4a382194c48d6bd4662bf8ab74ea68b5eec744d69a332e3eff2f73f4e7a597753256ab83c664e96bf1063c508a387571c07a83f4d67b8a5fb0b7bef4dbf30a0c301462ea344cac0f097063378a3529aca34103cc2b944972db91a3951d41357d384b0a002c56c4a10fc54dfacd645eb6251b30b2ae213fb39b3d2bc3a3df0149b33a20e5defa25482fff67a497221e68a1e17e3da2e77694b32a2a170d782dfe0942a374f2e87cb8173a76142be9747d0833aff1bdd29852d6f743a4a242439d4a791b11f6cf885e261d4b385496282ad63d445655175726002fe420278e987537e79d801355c9c7f069b2d72b9fa8f6f87048ade5ec5bd4ced2bdecdc15fe79dac7ed90d8e2baa048ba5bf87697691735d7ad7389268b124c0e20a56f0746275a9af05f6b826a5094b061e8708aed8cba64f0f8e9e71c3d8db40a0787b1ba39ad78a91a51bd3df5ebaa2bf155955778067ad9046e7c594223d529b775d5162b96113c2ced29219d1d0bbce11a2af7937ec2f303baaff44c4992c20ecba85c1622db52083240b15f9ce9aa42799024b24d95f07ae49186cac73dd8297d13c8e605db77f781e6cc6543401380b60164f4236e1eb480cb6037560ab5855c4d5814e11978d87d150ebdeb90ea30e57e2ce3b6d6281480238a70902fd6f8bf200de693c175619fc665ff8466a7cb1a5953ad543d202ff56efb4e9ae25612e40cdb0a7384bed6d7caff4d19472a316c59f70071cfdee19536e091d85d531cd778c9848c0a5ac0fc3d849a210727cc25d90f7a76525ff03c68d20c122e0f58400fecd2d3235e54f5f3d106594998da2fbe28bcb0fefdab974a6f5fada5bd594ff72543378f7f4ec53a9104db443c50a87e17dd133040eca6e416e2492e3e8ff8e7a6853aa3ed9658b126cbf229b897f8711a119cf35a430938633e81f00fe2ed1d22bd52e715796299c7ccab53e7f98e40697835f72758d4daa1229a2b9e6958967253f488517a1ea3a31c734259019017d0a85eaebb088afbb5ba8e43feaf5f8468627dc89f953da0319b4f7bc0899897c5b70bb47801913e4e10e3a4f3df7b36a79698dac0ac01494c0aa4c66d8ce89133cf62cbd908c6dce38028f09951db1d0e04dfaec9cfd7d0f80411ab997424ce002ff5804f54390b1f626c0ac20d28eb50b909840a6b0d222db2643081637670e0ae5c1fb7c3c7415e5dd784376bb332a05cd3a7c49eb06085d0cb15b676a325cbbd4903a14e5ca09acf2553c6fd1c6c0b11c2fa0dc57a4ab5ed9178d03d8439740747ba129133ea221f5a9c8f98a8aef3f726dfba48cbf5640b232748d3a8ecfa2b7a34a92bc6c77ea421dc78f713c64038661eff2814de8f7582428efe027b09469cc58e4c1bd1ccd93bdb8dc5db7b9f85f4ff1ec1fd6d35cc826bc46b421168c3ace8cf20682afcd5739c54f49b8ee3edaa1332954757dd1e4dd274330aad31632e146f81b31b4be95deeb1dd10822a09b05e04a5029b73fa9c5ec564c56a067bb32d68e96418c35673604568b69a4409367452d220419056ad011cccab5f1e89c7fae8795443a3df3a78bdd5c379e0891cfbecdf61b44f041e216e55241911cee27f0cce2c08037c36a637334fbffc25a9b762ada98dcfca06d3e3cd0f9e44ede5f4ed858ab12c8fc43d0f147128eb2ab102458a0a373cb62f39873af5c811e7386fdc485e07783e936372a60e061da5ebeedf55f26d8b1045a84463e30e7d281e310d91920b9a2dc3c3b4f1ed7c5d98cd52e1b630b7189f859b8bf7662a73af743cd99a9a5ceb0cecb4c7ef312b5d71f6872f0753b1836b929dc51aad78088211be59db25a4c9c455746af3052779c4233af1fe99016183d3e405810eafb3b04966595b91fa5f94da8f4456c6d5379c244b80c1ecd250e3686fa4ce26d9bda5350282e8b8db67b575330881a60c074178bdfc59582f9d50c8df3ebc7c993b563403564d396d2100b3006e4d156952d49ad436557d9b16dc6086b5b4f04b90853744aa1e21a3b02456318dbe6453421b566c451ef04b34ad3b12d7adc05ffb6f098e121aca35d3c02b68e3b26aafc532ddb913c151c333605d7a56a107791f5e0969f5d081f4c6a457c369ebd1246d86359abcd143af96d540249dd935a685ced175f6c7a6c4dcbd3b144d79b9ab00d028061ca40724009f5fd774234f8c358bde6fb6fb60027b263fe0abdfc0ecdfa7606c2e803a2ec762dd6b44b9ec89ee9cb37cc4be1189d8affd6dcf5c58490d0a477f1f7041c6c89349dd26753ad1c0ec25b1ca88adf470bed797b28c0f3a93486da468a906550e770f1c1ac44997c4d4f7e8e3be39ad26ffa83213e8f787025d1e687318ad42c0addf2022c23e894a1dc62e6bd1bcdf731b27ee9569fd198c6f40e02b30309cdde05fb310c4800ef4a3b2584e8d122e3239c2eacf9ccc42eb8786669294c71f2ed566ee078ce20fd6aa6fd81bca3214d568336cbac9475ff80b244dcf735a7df51ed0ad145695b52ae38ca10052d17e737d6528f2a4d2946f93f670d87eb60b1ce1b095ee07bebd23f926df32c9c42cd373600005707d618c3d3e9be6896177d2270983f34c2a65fd3c5c6f931cb87891ff332591ed7d6e1656fe8e05c77552c811367391f0f58918d8266882e2710ab469a961f1c2ff6505b972f4fcd08d9985b0e222aca7e2f41318b245b7e638c53577beda9279b32e565631aa7af6e0fd604962345d257f5f7062c5d748db3f4a6b3696c436c4135020fef5683d5a91e60a3db3488cf2230faac042e2f9cfca56088e56771f949c9cba3870cfe7dc10a3954e5552893be60d86f35bcb4b63fe3df7a71bc25e4ce27ebebb762b16cd375d25e7f7a430353abf03a152330ebffa2534c83be3ec1f85c880503abf0576a2384902c30aff30c9daf5edda246fc8cbc79f5fc2f7a53ecbf45c443415add5f6c0a92b73d5cfa43af9659e135ff16e5356c5336eebae5287f7df770d1f241ebc21aca0c4f90dc1a0d48c4c4c25f7b94a5c7378c2106892b763eaff07620a1860ddd4f3bdd3866f04db1e422b5aa8972f9a6e45306ac9e1d3ec06fbdc70ef1d9b4e983f648baa3078dbbca4d6d07630c686ae7c6a7021f65e2a1481b814f3a7018ff80bd562435ad1fd2c3a9b40fa58491de13586096f6f63961b251ed492bb5ede740b60147184c5bafdf7a116244a907e6bcefcddc8a4fd7efbb5e05ac0100bef23ccaa45ed41bd56a2221dbcf4706680950e469e002965e7c2920dc9d05c317467165d170794ff274fb7c3ddf0efd003d9e3108a4171787ab12530d0fbbc8b878ad79fdafcd82ed31ee88ee6bcd797e2c922f86aa68ac0d89dc9d58bc4801c5d931662dedf9eb2af013d374ef6d04eac582158b1d401302d584adf96d7640b1b552f84a562ad2decfd2c05f14af30ca3e8634105c8a414acfadc24d502a1e4c4fb247d4b06d27aec1a73d780a466b8bc169ddc8bcf230757a56fed6c49b9775a8d4dde8ae4d674840be3ff16773d300c17abd7bf84826dd96dfe77f9a79018b4243668dcb1a0a300c4b4015240eb20ec9a7b92a8078cb9fb95fb71e4c0218ac59d7b25481db00a62a66d9293594c4153e4e5f9664276a97c0d08a8c93ab6401411d7be27b25076869470ca258b687e38aaa13f14caf4137588dea2f1219cc8d0fbb452af7c02185b8dfece01ec9ec1cb1a66b843caa962dc6b3199c9c766a2c9796774685926839b124d1c4b1b3c17516d7c5e17e3d06cbffdf465813af7410193b73ea6655741e161e52ca3861ba8342601f6baaf1b19148b5eb01402871de934335cd1cfbe9f52a2c38236d49745a8352d24aed08db45de489a3a2582bbf12c71c29b03dd8f80561128798bd9523d7024f435e4c7f599abbae23a32a078bbec35b390b8c6fb890dca59556fa20505e1b57e9cf8f35e6538960bebe6dc86aaaa3d80c2e2ef59bc2d2f4ad80d76b440778d251da2c1c0f0aa61f4e0bb193ea4820ae445c186c796c7a8f62bcb31810b209cc200522358aec62654863d596794f7bb3f82a2ca2c7aaa4b2de88e197374402c19cc04d4bc59a33ee6528f6e67eff8ad4f467194f0371c711e5fc44df56028c06f7e07f2541fd9b3c050acc101293e7d5bce91d53be54f1e1e0a9698c576fae262f2704d68574459904c68e1d5dbd8591fa34372822a21fbb2e37970ab8171b8ab7156f0a6c656f974806adb34e32b1c28e8b0970ab2927c30c44fff44eedcf9f36ae21d351069603a4bf6a0b830b084bcd2b1daf9706e8cf08911923c30b5b2a28e7eb3f2a7db618fd2dca06f6a76609616cc5bff769d8269ce1abeab25dfe49d9721cd05e714cd3d736bad4bcb518724480cf3bf0cb347236d3b8f1e9c21f5d112c29273072dbea3cf7627ec7662ffb20e67c64a637eda56361f3ed3aa0c2a670f5a19c780c8ce86b9d61c8ff7fa78479d0e4f2ba9ff2e1a6dc6e23939f429caa30485c723a91a804bbf99d2503b826aaf7632b354addd61789041e83d224151c253e5dced79a78dd68b13c8ae5dda7c4d2fd0c531016a204e5f695a2965db2a8898b780327404c49154abd69660fdadcaa004852cc9554967757bfb6ab2999cc9f157652256bfe8f2568effd25759c332a97cba0b9b3aed6145ab53d75df96c0e82c34cea51c333c7261df8c7020cd7bf91775e5fd35d1cd48347e593260a995889637d4eb418fd7e4e19f682d94f247c8f1c818264d8f9e62ded5ae29f0dbe12297e80b4e5290917e587af30d9d6384ad7aba736a29b967e128dfe1574f5758f7bdd7049399535e31cf0ab7647eb27c13d2bb8236344db3c934f26c8f67f46e751b64c3c46aff51554bd54dbee1b3a555d68c4e7942d93b454d9cf0881ad516e661b0f65444064f7f16c55c136fc7f94a335c0667f09a2228ae3ca36c30a4b99e91bd46d66d36bee38e58be044f6b170896bb83d20c06942f5f8d2d35dff1db6d4aeda35cba92ef1b07530bea5794d932557faf2dc8228fe7dff731edc3cdc01f38190241d2a1be0e068ac2460c967e4b132defc7963825e08fa6d514cf34b65d3c106b3846341e81db37780eb48a17b83e785bba29f150d30680efea2d5944f35aaa98760fcb7c2532f38776efd9362e154908d370395e6f224dfc278b2a0a913021a8b1e9ffc6b240b3f55a081d028d685ad8a726a309db0a0f1bc69293a9f1663636fec9f74540b638599b54a5c2f1d594e35cf1deb705796aa0d4ddda8532940a4b7e767429821d9efc70bb857ca662184742a276409597fbdfa15ad1c4ec06c7eec9cb68d5366e2119c6c3d31fc24accdc7e7fac57d0737ba158b0d80ca95035ae05ef965a5e70316df1be69cc7ff4b2e8f1e06cb518ff5145df7f3c2ee1f8d3e90ad00c62c393f7270bacad9de65ca0c997570fdbc3c1150e5ffe00bf4578149810e58ba37d30b5b78e115ab5bf2cb0b47be7c0483aa61770f9ecfc87a533a79c099fdc25da91e83af305d407577402a70e2209710e228a7677e55e18972769dc254feb7df28ae8532fea9be7697045ddd2273910cc925f656db86ff1294fe1eb8ca3ef79b85ae5499cf5677fdbec4c45a41765913fb405e839ebbe4198a39437e007706bc6f95e0124619dceaefe1c385c254edad3e56b44114eb181d4dac2bffe8629167a27d7d5a6447a075f1e81ff9a202b1bc4271b2e50a5e72a2ebcd1fa7f2e423e0ca5e29c5efac69cdcc9c7550efde335187caf9734727e18adf69bb4c26a009135283db05d1ae9adb1bc7dae8a4234f288cbac6c8fb32d675e3605d919074277981c2611fb9700bdfef2fd3e822a7916016b5190efd2d51f7974823bab05ff4c3b4fd8ab3dff3cffe84f9d2a98643bbb7cd1f7b909881256e90d30e34869b5f54dc50dd5ac5964a568701ccf428d5c2ab39bc0f6ad6c8a50d1b96385a10941dbb823333de4d4397a57ccceeb5482ce9ba10a020e0c28c24946efa893ad399b6f862dd9f70f2db646c64f4cccc7739ac9a982587ff693bff5345632c6260529fae47c19bdb90f0e06fd152539c04c70f06e5be78598a53c91cb74a911dfa8d40428ea166d1a5130bc0ee18a40de4c2da9f923393b680608ba9f7866c496a4d40cc6fe134e5ead4c7fbc375c24b6976240e63143997df418bce53b7f0bb1ddc4fce599c4b209e80a5b2e6014f1bd495bbf32b518130aa68f1a4ed9054125272dd7b7441c8b3c9239c8a0dbe08dea17bc9d1dfd152a66cb03b0e189308ab8da4cc12a1028c0c3be0930ea9fe210464f05e224b315caf049f786392448b874859a8322cf30fbfcdf8961e764ff242249d6bb1da896205a119305161a0dbccbba0231ca989bcf55201a7413dc96504a381cb2be3106d4bb352c870a4a64dbb71be335b3cd719d6420f3c049c7e1ce1075e6ed347207601424af6b4d10804d559396b162d76cc4d9f23cb1a27d60bf2a375c36456192cf2c42b0966884228d890d0541723147d6276ec119fdc9e5726dab41ded54c82dc027db15e2ba4246d85c2639464e560f160bd06d575d651175f24a92f4ddc522b339a197ac908c2c4b4d04ffd9381f359459064a8bf3deff2d9be825c3d5604bc5f7b978a288e2d51ad1de4a9889628cc1786057a566dadcbe93ddb26d43fbd69fc9bbfde508feecc407481c00bfbbd908efda9a5124f42a1865cc9d890729d0ca5f53ff22c04b4ea40eead421b7fd76e3640acc169c2a2d2fdb980c9c8d48c642a702b465f0d6442c5829463a58719052d8df94bb6681101e3ab7b6860164805d5cc94dd3c6c0ae90592b72f04c55622624ba2d2d085f21e58d5f7c63c50199648b19d07fd9485ae15dd9f9c858b5cb7cc1e40864e11d2a924f6707fbcdc69399555fb538cee5a6943e414c52d7c9cb96fbf7c3c50f5aa8e0a64f530609dcacdcfba643f780866541bb77071e43016b7a066d459aa905fed531683b1c4ef1d01714235d1a8b2965f7ac6c2faecceea1ac4233e64cee556a5802c8585b02a3149e056aee2c456aececed2a0a2e4d13392f487a58668dca9f1284e16d88a3dabafc16538bbf82c1e0394a065bf62587d3051eef7317f5fe073c3e6b6a9408138e5395d61472966ab7c7ac8349db1126ed77ec2aa4c4334b5e6435fc186628a891d899cff9b2e46a4984b4ea578614217ba329fcd41641c77da38720f93008f25694deb029b9b38064956a851e2860b3b3045b4cad50dcfd76922bbde8078156045d79c36804bcffa2d429074683d99d15a2398cd54b3efbf3a85c7f5af5c387e39bc89f07689fb0e2095f7f26bd3f67bc73ea4546bf8aa6d94b498e0698f418eba2f14b3c15efafe45fad1455e75c63d44ec3c3c03a373e8ac1227149228464236666745471d1f1ba733c608588e8262db6a0ca7594d28e2eb880a627a1e14ddf4f9cc2962927ed95e2f61845ca883507d4128e971f03bbd60bedc9920031fe8edc125146f167c03a089de0170bc567cd4fc69063ff578c02d9d11c95898c12a9333e3f4af1e54e08f76a3f0e8fbc31dc62a77f96ec487214191cd814f92d88e34f0dc900f8658b5a1ed830f7bcd9ad1f7337814b6221bddeba5e64d40c742478cb517b1d4a753a540a6ddbf09af2073574b5c8ed78cbec0e144f9c0b7463d7e581a7cc8a958eb979f72a18c7ce56ec760e6f0a13b59cdcb8500a16c1fbb866abbb1680214d9f0bfc34e8261ec2bb93efb603fc1aec9176f90dffbf168221ea21c5986cfec6b75302a6aa1621e37f4334ad542e7ce47ecbcba75d3eb4b17238280cbc230b7a9e3928c84624161ce918bb171acbfc959a458ae37746063816b0d3c0be1446e994efab125c630ca2966d7f31696b568f9691600bba65e5392f747df3586efacbbe00d338c9786e8a44ab46148b04303a8f6dfc6b1b2eff410721a1fda82426661de28e5592a4ed008b73bded0329a6ff9262774c1b33c77bb39f62be99568b4ebb1495c9b8e67ed6bf19f9d9829d23cc21ec214ba2c75a8c48bbb594e4ec89e17b83019d70cbdb99a96cad7e7994d7cbc496ac5c25502b212ae94085b2d60f5589fa518103593fc0ac1cb316bbfae39ec86803569d0c6ff4e6c87bb30a4c44824090f149bc9186c0d2f20da3728664b6acf1e0c46a59a79334da8419c2a523965b9c77152d0f42ddb7c28d5a61409b10b7bdac59403802debd3cc34099c2e97e9d81b1f6d6b9a07b25845008f3946e48c915c480ac155c7c5b176325a359d868479fb3b7ee9937a7817f2e7b8e3b9a56c566580628bbe6ee11fc5e0cf0485fbe3225d65a129e654ed15929c408f37fab08765f24b73de9e25d51a3e89e6b0168f2827488a2be9f75d8b5f12cf57366450a490953f9b84dae79901dcb4b42fc0895c3f8205611a41fe9cbc1aeb188b986bef7b7981eebab1be29be6bf226ef107eb77e30540df80b9c318c068d1fe06b983f7617d9cf768f8785d581d9a3c6c06d69cc8a335e3094c271af2f71c3dfe705d0ce3f33a94fc22fc45358bcb3d4c0cd9cfefd9e38b5ae4b918e2c46d29a50dfcc3de240e35f3deb52ee02d20520f28671375ecb98956b0f1758740ca90a945403e6b6c859a33f5b1ea00ca6d10691b3b59b299349096f85ea35dc591a700f8d0006dffb12245cf451841f24c46e7afd60e0fea13048bf9734954240456c37d2d69d4420808df4f2190d6c6a9f3ba5db477d3a641ba8e68b0305e94bb5540dfa3d4e0b89e0288b954f0e8c84e7119f4749697d10f5358d730e126dfe8b778ee5beed885981054373abc57fad48b029d5e0faa535d47c3803a94630d92c567d6b458ad788c3f505f1340cd7491aed69c56faf5c27a79edfec889db0a0f36ef11fb53dbf5ce2630f40da1768870f3ae76ba0317fe2e38b52d115de5a2a7001d99d60c38279d81fa11ac17f65a22b2f4ac79eb8fa188a34b683d84254c8437396ee09f5364f0886626db3134e141db6cf996aa5b6ce64d59cafbcc624b9a0cf31e122a54863f12f7595da11f5db839d9efc27247c894f9d89e67554c0df8e339a16c61a2ddc6222f3f002a74880ecb1afd533c2c90e0f2f834305db2bf89eacfa68ed4ccef25dfcefc332d03db64abb77b0cc9108dfeb05b009c90424235c6436bf18a9da71f0998d26e96616029c331c778d4d3f82a9b354db63b28c4435cd6e2e5d3ff145cc5ecfd06d5dc0cb0174a4bb670b1f4b7f558665d4e5dd1a3bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
