<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01e35866615fbb9240bcdff3fc917851fa8c7f11bd57f3ddc33f40b100f1b22f34242ce305752690887e70387f788a2ddaf8a2316ed27e6a3b399890967a474d528ae7a9a6c1aa81cab5a9aa26604651daea2ba00ae3b68eb6842f966ef5f45f52ff366a7d48982f8c030ddb0e08339a71b7451aa8d8008b9ebf2cf8f41857eb146f913db8363646411ee516c7397104909ef51375d41bfcaae79889befbf52e23f3957f2111dd42f09a5bf8bdb5f5751ac1d6e0904462738a56dd5269af2b96f5de4ea98dea1c551616d2a3f81b1766a489a107c98ef567563709f44d87985132103c23010c7dd8a5007ffb7dd01ea00379f3844ec1708c65cff5614e3e933fb9f4339a8b75d2ad459091b5606c2a019ba662844e41da5e0c5857c89355e2e179bf61d317c68427fa057857c386c90aae89bcae6e09b156027d8c47ecd7f576b106f5d55cfedc93d3e9c9111bb72966667e1bda9b9dcb6541de5becba1e4c2c50b9ad7a08dd8cc5170b71f50f495d670bdff4232bbdf96216ac3e330363e95f0d7816152ff5bb789c10ba68046b7fcafe320179a30101144c441955f1ff5c68031647e34af473ee653693afafad10182ba91987455573750fdbe6be35e4d2f60b2c9de809d81a9c511930348414d34b28b9c7917ff7543e998e0db75987c72218ff2efa85a47e699495176e26f96e0a796eba6e517ebe93bb775025c2c1d702f3a6af67fb6a6aa8e9ccede30f845763be780cc4905d5949d97352e11cc588dbc51fce8f21d90f397197578f7395973286acf9533e0be1f0b67202e7fe497b0e473ee41e95b87e5f49d3c9e8a007efe9aaa61f858f3a850ef203c867203349810555b1a9fdca8d02ee4f819a9ef1991237ecf54be2710c982d71e414a5c6c710987162f640a3d1149643aec79a2135f5ba458d28b2d5c721c664aaa4a6d594180ce8cd52e24e7ddb69b627ac59978dbf4ef1ac7cd718b995ef80a0c51e5ab53a3f97d630c89faeea75c4105294c063d884e54b5e1850073e5804dccde5cd0363ce71cbe18a1994241e651aaebfdf6b2b335bc33ac4a65b69725ae2c943918d4ad4c91980aa68ae475fb3f89e454005f93b325c8076fab423357a049a67c62cd7ca01520194e7eb10148ab76457010566c68cbfb2cfb12eeaf6ab9417381b438880bac3759d1811119769687380d031543d38151985ae1ebb823e9688466d94ce68c30dbc8c3d0d941487ca149e6218d82112ffef26472a975c8eee799b3d8698a7df63b6aad4778eee615ea47542583cdcad8e1391da5e39976e7cfd49cd65589a493bdb0cb9c6c5c0932380c0f33aed9ff4701dab2de1a6d0b405c70166dcc66d42f85a6cc73aa864a326e960604ce1287571e21c16a400610537ae1c3eb9a0278b941b06d20412a2aed5d86f6e3f5e61d607b8785140767fb5d024e5344ebabe0e39453f5d543a6bd887b4ebd4cbe4f89130b805ee6983c7763214bdbfa2d218b321e046a704a59220727a5e4cdb945307865949b40e2a08ada56fd15561785852c8fdfdc61dc40bd069a5a9a3aa70316d1455bd5081dd120fe2a8a253fa71cb9f6b2c01bf11ca88ea01b2d59c657b67738fe62f957376e2bb3acf8b7cd4879f09c1ea9d8cbeda5c2f4b6c03c92a6272c77d24c82c7371c9bd299e29b6ae067796bb0fd03e9dbd5ead7f079a3228ea30bc4053ae20d657cae2d3a8b8beefa14910fb287dc84eb0bbd63644dd3e52b467fbd545c782d745349b76e80ff7c778c155d73077117e84cdb66e9dd264800dcc330a01afb41fced916cd883bc631a78cbb498cfdc573d6637892b0f8806eb473245aace3af33e9f905cab2649477c2999ea6fb75c2b4a709d99c691a652103737d6b9b771da529e0ff6c46bbabc65d71e72785b20a59679b347a5a9180499361a351aa97c1e822b370b18681f99b85720c27b1b9d955b62e090d416c558231ee9def455559cd9edecce7c9be69b857cd78f26ae7ff6e507a863f1c9360aee8c56c361909272df1fbb4bc09f63bb1c524433b678bca5371660fe41df54d08ec7d6a7bd0c583cc306283e127b81e19beb01ba12ab5effcffc8516a696fbeb88272fd2d6ca935fc141e4564e582183fb822a9cc6480e4a984ce54b902a5a54afb68c1a73b1c2950c3c70b16d0495b37da4430d20ba809a6849b87f4590c81d9ac9ff331174b7b99829d51fcc41c7ea2c59c3aeb26be169fe9f281c1d7a3e21b0e859a767fae4c39b6fd2ef3f6dc61e65c0463d7f76838ebbd49f080e74bbbb6a225b94e8c954ef8a06822135b8be596a7eb7762db1bc7e6a06aeacb5a7512f66e37f0db4dd21aa787fcbf35de121b9eea7234876d19a5ba627212b9d3b5bf13c31ae2207dd0f841ec2196588962aba2cf5ff25d6ef95d93c39c9350d09306d878df69e84b0b580373244a05173b2e700b4781c7bc8c337b69534ea3497e5d6f36f3dbb463d21a075ce81299560c193bf8f3e8c62222e0ef059c1e667ee6b1451e04bf31f25ca95b6ae86fdf8340d487c8a98b3e12e4abb44183a4ba56ee36dd48af754e798c4a41a2b53f5d64c4c101f38989eb56d492bcfe3414a349b36bbafc77e13f79bb94781e3c480dee9e012b3513991e1ab2f5c081862a0fe83c9f069029d5ce13cf087c7634fa7ccea759714aa6ffce11acad1a29f1a7435289444b4fa49383d4f81242a60a5ffba617f0eba9ba834eae9836c7b3d7dbeceaab8969f77d6667a5b061cb19b41aeb46109d59bf1c065fb394fb6008071477cbcc0e9ac30c373580a2bcf3aa4b5ffd266d346e1271a09e85abde2a8868923fd9f3a4fcabacc3dba5a86da98a094b2f6ad4233b7f09ed2b9a68c434fc8acabccf2c9d8505712a6322461ee7a6cde4ba5fe4845f904ea3a86416a7d155eef91d87acd68f4df990ea3fa70618b691cc285ec5304104158d5404e6889f4b16a546418a38828744cf36b19841617e91b4a181d1212ddf24f8be69f742bdc128660e81f3b290e1ebf5d792e8dc211723a76eeb6dad4e90cc691393e31ea12af03ece8d0dec36e82d8527b5b9e2b5796e8dc7b4f2ae2785f2de139bf752cc1d8f8768bd50dd29528a2c0320288106c1f36ff38711f4090962658e7da994fd6926ed8d7671c2bebfd923dd3d8f9fea0ace17570ed1e5793655ffabe16fee104333870d0af0b1390d87e9d0748d984703c457de973f27e3fa7fa4a8cd8b5cbcb424e845a84a299a4f5b8746df648ae0fcc565dbe11770e3dadd55df38911749d471e9a392c0bfabaa5085c66f0a329311deb48a0efa3ff518a0e57ac33b9c71cddd48e7a36ec9037e2827ee3f6663ed6e9e17ddb0d31ca2db751911a1affc9ec8e3b1a2bd69287682ceb5fefd7be5d4d12e35fdde36f44c1b238f70bfb6747408b4795f9209f32015cb6cd662230be4174b032811d9f230471eec0c38ac23d91bd249afb221f70f1ca98279b23892b024b645dd697d12e2323246109272355b504288425d94e30c9d95410f028730b8b222fb9a92bb467571c25f1fd168b4ac3e8c57b91e155f1f58d00cef30f3a3cacd0b789bfedd4d3d4f6629e829f50a408d5fed8ca02cdc3824794f4319ea3343b8a9728fbca5ed97bdaeed0fe71b2514352bb42fc004e3cecc1103f9192055dc2dbe2f68370a6c5aaff053f2c8e30bbdda098582efc828de76576d6bb86b2f21af2d6f4b977dba97177741b64866c96a231a9e4b110f038f00ed612be237780bf4b8005400f1534a12de0b94c5b2f5a41440daebaab877a54047a66f4f60356b87d28c551db34f9993cc0ee5df3e79d6be6faf33664d5997d1c8661d19e1f54e211da0bc9620721e17846209e85de8f213c404c36fcdcae696ae4ed1f9cd39b4de3a795b62af3d9f6eeab609ad70ae9c9fc69c2beac1d4c94a74ade46027a2f9f1d71e48bc80d97e67af16ecf79c60a38078c79380ae53f8fda7adf116c01bc437cc2041b6584e36fce6a28d73d091ac2653016472f87d45f6500bda98be1bcadf8feb766c0d3725de27f8db69afbb2ab91bfb74810878c1441c7a5dc752d54d3e84e02201134f98b3ba0446fdf451e7ea586d23b748f7bd8a73f37b8e925523c4a48cc0098614b550ffc56c3c8048c06eccbbca00d7eedce2da9a1a23798ad1dbdc13c6b0c7978766978062ed4b3399e60e509d3e0004bfb913d0f21cd352295aaa8dd0d7d691c9c95c24fe55013dbb4f6821be49b3b1ed5a2a708776ed9dbc512ed6a747ea8728e7f84f71021fe89b0d2b5a3cf2c8466d99fabe69277c27bd7cfa808401ad7eee841d3049f71f0676540d3158ec5fc3c0467333a935a74b41ecad22d1b6027f1195fced85b6bf32fe988b5db159690c29a27c098a1bfd51c57fce7949425b28312e579bde9cf2bcab2d668d260a2f2ddf7a4c53b87430b2feaafa4d734d53bd2ebc4ab032c58903b4f2066df88c0c4bbc6aacd6fd218d6f951955036116572cb1e8923a55a528bff366c8d8932bcdcd73482809e12dcb8adbda9ab0a2d5404e2a15dfd8eb48db841fac2ad189aa5553db7a2cebcc65e5d88ea0122278169f7334f3c6df150b0126f6c2d7488ffad43fd5c284b313145c36e4929b14885acd823432ac73b7879c728219364be62d8af730800411eb5c2f20a60ee1e68b6ac58d0b6bd58b9520a8082f427c4074f71c70897166161056ef8c8d698f318ed993c1732849125037f25663e0bdda23c7f23da50a21f4565b3bdbd3dd02a30767f8e58f6af561d270e92c2a89586edfc459a61bc4ea025a1e1ea3560572a88cb5e798fa6a9740848579e28f605b7a86fdc67b91d7732675159a939adb4cb7ffc9c9bc8fdb88c5e8f28dd5ebbc0663612d3d37295c71d18cd1ae83ee441c45283dd9e1d4886eea42442cadb2ae83c3c62ff012fb28833c272c633c7470ee6f19d42e260920e665054700f9f03f8b1a0b37b85ca1ceea3c90650a8e0d4bbd7a98247715bf99b5b4de911679705601c1bbc543fa8f81774b7f6031aae12ca2777c0a3f80264e7beb8672b4c3870fca22104d099530fcecfe52b7ed34fa0dd412c06ab24cbcf9f08a849ff5b6546accb12a3d8d9be9210abcd5654954aad02355b4d1995e0fa369d07ee5a59bb317fd03a6a15817aac0d4345f69a82c04a267f872890dd9283790155469d92c1c06b5eb84fea5eeb2c2a1a7b92a263127af1c571bcbd549ff607ad85f225d75b5188284dcab6e33d1865dbd19fc390e1f802cefd8b0fc56e3f21f2968dac81becb1cfb7805229fb7ca0e82f4865db755092bddf816e34d3fb325cb8c2dfc22a609ca6fe4fb22fbd726ac25be501627ea5a664b9e81e4d26f8ccd8081ab2f8098847f621eb34a9e69c95b0d032eecefd769d6b39faba468becf638437a3fc4e407ae99418c58f63d6c3050bd4cfcfc93184ab724ccb5c894ad250068be1b83dcda07c1809b8f7dae2a04b1eba01c1e36a4958544ac39e750bcfa5aa7ea838607747bf175942dcf10ae630dcbadaeef41b167d2b0c6958713fe681d3e2d20be00bc8f44f517c206e5e5e2520f85823a5f58c1dfdd0760aa30e9e8ed852d5ace3599bcc7356f2ba3ecc4b58de23d8b70776d9aba9ab475acfd6b06272d2b480a8ff43c8f14331f040c19f251e1a7f854b714ef0c581d2fe8593f4eb42a9ddb1e2f72329d0451e25859a52bda83e410d1f3a80e0483a2f8de1de1f4a51d0097ee1ec6ce7ab6574abd564372ec452d2ca18c03d48fcc436f8bf44d9116a7953e8c0a86a20b6e9ef09eb89cb9708114a40b3a265c765441d9ee0102c83062a5ff17c8eda47d519a896f358f03b2928b47b0e65d34220b8f5bc0b1a288221612df0cd11afeff3098ef8bea88998ae22e423cfe7a73249d33b40ee204126e6cdaab15e5b0e9c07fac8e2970c1a25c4b085eeffb370a3d59fd0388e81a3dd84b64e75286907d9ea97fb3dd335ca1c1aec7544bb01c1457f519aa4e8ccc6e2bda664f5448125b39449b9bacbd0f4b79e0bfeb94f0efce392d52bcecd0fde91fad6082940222ef9a0bd30bf796ad9d88d959a0a65f799c91e0a7f963ba6e91d001fc995458c0186c23c37d0163bb9ba8255a75e12cd7288885fbca66d62542d49cc2d7983e8b74940c9f3c730251464389cdb3578b02bb007a28c88bfa6089131ac809dc5340b23b9f613177c3089f8719d18f94d42a1c14974024250eab4e9dcbc6d79ee9eefe3b6d04af5188046d7eeecca200c2e0a5cd74386f83ac1f74eebed2c5de298a86d0ab33c9bd3b7c656f577ddd7e7f10524a289491d8758c9e5405788ad32199de7cf77bafa5bfc09ab856ebff34b4bc7f4cf2668d158a347767291ee4449b43c7641a7767f6ab26ace45b2808eb0d962d8fe6af247b94b2df16704bd1dd0f89492bc4f4d788f74c4e81648a74a3ab34bd083ebcfae4434dae3aaa6f4d606d42cb5d84aa3dc7bdb0499522aab939b7ad5e932d5fe0e6fa8ef716aba9ec2a2de5e4313e6e6839001e231b4fa974111d851f3b1d8fd8dcc347180cd5aa96a477c7784460136e20066ed897aa5f534d2e2396ea4937f90fb671526049a6f32835c9e0c61051b6825c85bf3c687ccbff25a6a79372f401bec4aa8e0ea54dd4d6a58652fde5ea192481c078275be9a2b64d1b38460c61e1d04a95197ce7ed56af2ba55d067116d4d1e238bc5076a26f4817b43a4e47c485c8fb14a9fcb55166e52b17339eaddbb11a555a068e4b204960fe9d9d22cbd6983855f98cc8d5ab65c2117c37505e2222693c5f140f6a6d7531e16f82bc8b7fffc80c4a114dfe8ff35b932481b8637d3b3a0771dee1b12639d3046ac17c71eea85528a2fcf9559b573cf297263b1b4908f3b6521bd00c77ba43d2b8c650d6cbb81b1b41d16edf8ece1623a198291013dc6c4f8922ad58b222ce968a121cee229235a0ae16d30de1c5a69ca0e313b0dd208fc63a5ddd139eb00a4f55214f114dd19e76a834565dad6cc38d9e260a55c44641f8ce782c2f464a414c13c0b64c2a4c203991ca85dfd7067f9f1fdf89bb78c1b7e25570b9fb2e425aad92c8f2df5988b85ba57582b6a51521fc3f6ed12cf3e88bd6e73a7783449cbfc5ce2f1508a97a84d12c6b6ac7affb41cb2eb2359900cd74b1100813d6f25d88039ebd00ffd1e95a0ac7e1ad11b136cf2e79d2530a49b2a442293706c75497e2f64790d45dcfac135ec93ae74fe92be719a7454548a4a86c7ce29c142aee46db8b19038c3dd82efd724b801df16ef738fa43012b2b429fc0775ed5dfdccaf1d2bd118899bf51bef9ddf0045d3ea4b1111c007405ad7fc8cebfc76dfb2c754ab5fdbc060e9a6bf9be934ea7443b536efafad759eff33c9bf142273dc026e4a91ae951902a2575f15f0f330ece233b1ecb33735b19eacf2d96b63f5a37e91fed9b230f5f530935d85d6b2a706517fa3bc5b88fb9444495bb3f3a7a5ee91893da8c997f3cc84499518ddfc385c53eed746866eb509fe632c61ce978afd277891445098ebb48d56985e96bebde2434d0ac17913baf483bf5e59c4ea955c3a32609afedbdd185481a1cf46f3dc624dffa412e153b59cc80fcfa8c44ab4bbce819ea073703a184ab4457cab80bf42fd93895522035af177bd70c7f09e564e9583e8bb09174ab82af6814417ed6597e9c325b1df6b467a8b708ee26eb2a4d7118ccc99caf93d575658053514646ca2eb8c833768e9420b11b96e4a70208cb999e76cc9532eb7037db52aee93c18b4e8f2d3fd547dd82e4a1ac36d8dfe567bbe947923db22a27c39b4498a486db5bdbb9996a108e5c0e39bbbf55b4124e15709c85de8982661d24d9a33346211451391565b4edac0fafe9687ef7667d540373d6f6bfb694c9b634c06fb245ad338c59fa485589406fffa92784f7554960722235b5493a75a22608580fe8c408a1eadc27dc8a6d7d44741568d8d1e24e1e22107d4d6b812ca3d829aefbc23f1a52c1986705386e81217cce13648be678e761da71a71fbd7e64c682c0d23c42571b49ca9639b1390d60d510635aaeddcc669f498970033c5113a26b0258df7c22ee9adf06235ed207b13f0f1f9ad39bc51772a940178dc34445ab10d046b888de1e5d328827a11488ad39673171e5d59f6f88cf81a5308ee7d8c321e8ca953f02dd2d45f51688defd430bb5b3817c617cfc78cd62805479b093ec625f2e61bb7fef68b351a5c378e8b0efab87a46e812f50a82e6c629ec2c9716e02a915d51ab4b99229696cc8acf911e9c480a98581b6e7cb3c7ca69a768f8c03a9ddaab39eb848fc98c91f4b2f661383b1da0c6e4119b305e9e02e0e5587873d82f367b490f4a76ccb47d525b7e8dfbe2c4317470c5f2f330b88d80dfa6e2d3ca198aa60d5c356e64b10c7723a70ac59ee0f3521703720a67d23cd18a1470de84a13a708fcc8a3f9e0cd547ce8f8687df2a85e8612d77e73ca2563d28c45ba738182455e369960b9bbd4bf96ffc2581927df579f6bf9cc1dfd82e6b67ea45b905714c4519430fb8db7e64ab238a3052532b5184922ef32434a1507795c4cbca9da67d794ff64f4d3ca48beeca16e76d615e38415aa9ead89ae15f8fbb3b9ca265617f91ce03cb773aef3ea14deb09586fbc3ad2a21c41add7669441f0e42d1d1e953f5450decff46b8d70b9766a4567d836adfce60fac0361b61d6dbdc2db2018c9dba5b44888d9144395f4aa9a6791ffee7ebc90ca6d87e19b120ff40f8197dea6543a62664775e8381362737c235545abbbd9fa977bab6edf3acdea7f3ae526cd0b60d319e418536e392a41c4a2d89e82c8a2da39e0eded1f824eefb6be0f47308fb5a628429b5d9ec5e6085b7722648ffa9cd05df933a799b45807057bfda535d7d8a3ce8439846435a65a3fb7328988d7bb2dbe7b5c8a2c271c7cc2d440c85719635f64f0d1688fd3f5eba52f523d4e49d740da7f40baa6e6fda2830fe08d22592c6156b2170031f2ef8db030be42b6ccab8b68f5c97d327a16757d0ed0f9576040ffa586470d81fd780ef4d6dde3592792e354847b1c6625f0ff930c27e269158c0281599dee2419e812949f82621ff3b24444f88377943918663e52c0adfd6ead5d1ec16ab455131d65da01aed55408950670a7f6e99b96a638f4f640ce7545a4e2bfd1d0bac710007424b2c6a7a013feaa68f93cf24c9b1c236531852545dd30dda831648d31db4f6998ce26346b68ae32715533c5d5beb4549a47245b295b2f7b2755ddd4d050b82394102dd175defa73b6573e66504faf546fb8cd21f1167b604ea5dcac5cd10b7cb70997330d8c440543c59f6c27640e992f4507e4ed15ea878788888c325f4986590937bf5f43b05e7ea3705552801b85fc95138e2f796e639486230cde366f592f7bf7090f97e431b10af702bbb79586626b2e73e18b2bf4ae9a5c5df47c69c00cc80ba5361ec52ebefeede11640f5ca2ce0c85e30d16b6be1fd1f4468430ee51f404770a916926649e9dfe98854dc67eb7ba3fdbdc0c7631f9b949704ac4aaf4ad4c4f49ce8ed1d2bae12ca2f5bbb37b5c31969dcbcd92ab9da581e6b5984f8fe8f37f5fbfabda7e2e3ffe441f80a74d18a2e5cadd87255656a24ecc526b9e9ce7a7d85e41b01b663a1483f0f66ec9d738df59d116290e9440f14f67eaf4d5d045c339ec9c89d3b522e010768788f61a93485259570e6f38ce1a3e885229d26813489830e2284a86d80188c20d01940709f58918806ab5d38e90e810289daa90e4fe52b3d6bd89da79d33c3c5c532d7eed0796dbd958a75d8828e3edab2a5ed2b647822323eb34a2d3ebb17ecfa7477b07ac75885a06dc1687978a28a7ab294723c12bcaece00711e0d6e70288d8b4603d98b4912c8c04ccded6bd4a7abe6d9b4350bbb9a9c9e0b18d7c35a382a68e63aa75d9223c0d14c6f5bded0372262d7361dacf7be4df616deede773a3ca70488cf90ed7ba53e7b1675193af97f9007ee1278bf7c794c69a28c69c14835ef885c643948defbf094e0016c706901086116289f7dd8194e9dd145a50f46ba0fab6f5660e3203274a6ee3216f472f7f6021e5301345e620224dc7c58eb4ac22c21bd1d7ea880827ad8a9abe5aa0f00dba628634402896f85d205d15651a01bed25ddd4b316ca96ae87e9d0f986c95a568975807c98e657091bd2be11a990612907a03e81915f79eeb62bb6393151f2a30f5be1fc0ee5dfa738640593d3a51dd74413099b6d68c1f5a2608e128dd82a718b51c879a43999e4dbebfa5dc5571389a50f40cf98fc973d08acd5796e6b63023b4c4ab0c7d343befea0400b992a843c9b5ef6f75394a6ad2249ca933e2b309a940846875e65edffa3c8159930934fedc443bca0dfa740db563f7518e0b71d5aed6772abed0775373ae65eea3958bf6f6cfd99e7b79f0402a457c8090f0f64ee98639f909dacad7d696990ba2868a4b028062f1c0de96c72cc048dc194494247e7f263aeb32aaf3274b96922ca9bcf3bc430c82f71cc1665820942614d64715c3b216d25cd8503971edaa7a57d04192796b99fb4efe5d2a0a93e35ed11616547e9aa5c89c1c5502c28a4b838c5c9f0c9ab23790a88e014947504a2774d0e22b7ff292da2cb60c7d1c4a06cac08fb741303e6cb3687c7104c710d4ac3f218da4b564ec8b9998c23b27f2c761106c547708d1459143686f7d312d6762ab094c718a0e1d11af9e30289bb305728948016713d06bf5d65358fcc6ea5e35eff40c3b8fc572bdcf85e5270758e1fa619c6ac3c56966e3bd377f9b79d660bd4ffc9886bb016903e9bb593b6e6200ac089731b379e6c05cdd591c4bb73e3a038c5f7fef3bba58b404da128c2e8e01b27c8790545b573bb1d4c0cda5ab09ca8cc938492a391a162d7255a4c5ceaa04f85e1a5fb17ba02838ef2a9fcdba6124bc98a878dd7e69d155b773950037a280b6000e97e5e7e69a9f6f6cd2986b5174fb6736b0fccd42afa2306f06f4d933f781187fe68c5cd604d49d7e95d93ac1212df68b2dce46b1573fafbe664f0f29a4ce297ec5fd73116a0c23887d580492ea31107305edd2a0e7d577cbecca7f4acff1f42358f0fa051fe1528c2a9ad3ccca94f1f0f073fb710e014edd772f650998573601d43f0310c7e86e2b4782eeea80d50fe06d7b11663132175403dd1973fb3e472878559d9d27a763c093ffd32a6390e1668bbc8f7f877e39dd69e58ba6a56a36d5797fe83c31c98a77b3c65e40c584181dd149f19e1254fe664eef605690836d1e18daac1a21a04e14d1be6fa7479c244a1bceac1c0067c0aa7a16a10834d8033508ba3618b75ad13d7169bba1ad93a81a7ff068571ebb77ccbcc071a0af0c1583e2433dc2f53c52eed9149d36563db2af80d8dea7fec4b62ec492f84b3d8b408dc37fd534301e21cc86c58c94a2fd783bd4218378e8e5684926f9efe88ea4e6f3496bc9f84f0402925d7338ebb02d64ca1d2ef4b0f9fcb0d929f8d73f2ea0a0798d96807f42747c71c57c4ceb045064e2fe09051d439da3dad83c818e7aa42b5bd29f27b24cba500912d28dbe628b2cadc3039b67ee10cc114d3f0cd329f3fc82c06f42aec76e6b390efd2c80e10bd68eca72c77bb74d431f228f8c107c39d80c5e17f11ebc2ec8cc9d330923e24d1558f795573475fab2b91429cc0e630aad03f6d7b71cc42ed2fa860b144b973be6ff055a87e60886b1e8f1e7ece923c8d22004e94a50aa4cf6d93691a32fa9fd1c0af16134c44a35c55bc9beb2e01a7cffa363c0705ac5b46f0fab3c75fc94b1d919afc328e4f78af96a23a22cf7eeebdc7c6a8fa1285ec237c92fc6e230762ffe811369e557e226b991fa6a40f6b20f925bfd2bc46042d234f4d43ceffd63916d784d38d0dc4abf31e060457dcfd47b3dc446bb97fbb746d41f501c19f89da419fe73e47807e3de713b55b43859c44c76afabbbf3e6e75ddcabfbc5b4a920a5fb094a24fb4142be23d44bf570a01e742a6a360b401316f1be070f2bd0699ec7f15305a9eb9b0692641119fda721a1732c307d09f1551e55e22a5f526bed811c7d1998c038c76074525a5ba763bf2fbadcb5fa89757f9c1e257b51250e773c2fe465f7ea5a31ce823f6a03cea069e35934f2965b9b2a53a3e79f7a47fc4f55f8db626677ea463123113082652994e3e16693397d0b8c674bdeca71c419c2c6014c7cd7b0d6466aaad772ede42f60fd3c2ece0affc71a1f2c6807c9ef6f4cdf973ec02cec31196c6a56483b55e47a27e6f31f9b576fdf26776ad1bb9c9ca9b14df8d38ce6de9a12caa897dbce5968ddb9de7a78d585c1bcbc4418bdea5cd9b3c2092b75faa355535e40678093fc2a1dc44068cc7ccd6bf65d70c7aec792aeb2db36bd7f3c2f92d59ee7664e182fe9efb9221330a916321224087ccc1ecae449784582edd73f8b88c529313516acae48c62552c417d461f65a99b65d9f34c4be1b45e7ed4ffbeaf64eeb3facde80ef8234a77d3fc400e97840e40a0a6e35e9a827c3e2d735d6c5d4e208e813925dc117d91ee0d785359bbd5a2d6f1f945f14ad2c3d2b506087a7f6843c92126b682d95e27b0fc31aebb23054d99feab38388b2a9ca0917712476e47f9aa94b2964bb1e0143aafc7a5d69cf9c78f84dd7235cd354ab1374112ee03cfa7f8850d4566d474c8992a399abcf602a1428a4cd9fcd94bd904eecf951e76f1d1f14fe4a2d4906053fd7406b2551d33dbb39eaeb95bfcad940f444470f3c2c5da6f5743382776822436d643eb1f7b7e0dd539a7757e876e2711c0369a65174c9a98306a4083c296b6989f6c7cdf249ae70599f4ac4cf7a83fbbd731206f88981e96ab9704973c509681bd575a11270416de8ce30a16cb28a9118945e7bacaafe738177c7283bc59877c402270ec7485bdad449a32c84603e9101ef656e290934c9fba5dcfee3631e058b50512275bd1a28540cf1d6dcb1a4fd46b341f027d4f74ac011bf1e2348339305286af2b1d70c7b64d33b231cf7aa89a457f31a7b2befed9a42bc5ea88511af17a36520c6c87c66c88ec315256fffdcd46538e52e78f20642ea265bc243720523db0f4ef16d40010b00f17d18a8326e4ef6a2e2f23ea923b3ac0232c221861440343017ef1aae25acea4ec3e30e2e657f95c97b5f8e86e249eba37fa2a2effcf061f5c19d7b3311482e176151a93f694aff6d45a2fc8a837cb7e4a00e5f1a949cb186a5188178df5359bacb8a46c41f479faf90512c051c409e01a64d89f21f23413caacf9c5f1195535eb7c47127ae369bcd21ef2ca71491557a5caef9d2bb2dd546e73cb0f5656de17957f5e487617f7da4cd6df246754d1654c5c9a23f1459c9d465f209e97a33c7d3a6499e3e845306733cb3c588e393ec63f054e63972d552e23e41fc59e41df44100d49799d94e6355e285a5befe3b7963f5f411bd83c39651847b240e9dd707715a03593133ecf072dce00e579e0a7d8175076887f619a3cd9f2e01668e654df7da3af15b438fa33a87871ee0d508018f6f67a5ebbb254ce2daca9946c295cdea7723fbaa4f44505f4147a211a3d653025f3ee6b6d780b7020c0bd5e7cd4fab983f069872b9afde65f856b558910a7e5f9a9751c147b28e191ba140d98f628fc6f494308a540cbe4bf37c24d07aa18bbdb2ca3098dd6b3cc696f8fd209476635f70bfca64ec8e13f9f9493ceb1e782cd4d0f6441ea2a8bddb95ea0e46726fc377f9e4f1bd8a0ad5f8ee6db171c1fa13ca2fd0171fe0d56ee47f64af9e31a85ab9cb27ce440f7ee7c513fc50864102527a2dfb06c7ff5d36e9f2c701745785d36df3e328443f78e410624a8fdee871444393f7f233a2d88f2aacbaad76cc27603f5fe088a1dca36ce6faacde0bfbddfd2e087ecf72efaa0dfb9b372d5fb2b0db314c6faeeaaf3da72eab4fa0ec46949d3ca41e5791d518d7797578f8e6137f0f2361c376a35c54ee3c8b4a284f432469b52f22217e064714a1dcdec568887611744e5935e15e945a56d5d78ce094d7b0ee9dfc6e823f7b63461b388c61759d94d36e5131c445ea083ad5c1c3b43ace2e459c511cb5b26598b74e30804afb9f81b8d69b2b0b73d6f7b5155098cb01338bca0e3ede0deb69c6acad4969733c66b30e47e9bb5740d9240620940ac01b71c5e1699d51f1e29503faaf45dedd47a258a16c1f09e74b34adc7ad011584b8cdec4a9c6b176d33fb6513020062f16a3e0a1de22be640ac30fb96741a1d58ac2f6d4e52786102f48eaf42699778636ed10694742022702c5c2c2c1e2ed24144b16f06669670d5c5d50a057b0a1e1808ae108d8fea2baa2b61d07dd185de4ba4846e91a71b2865dd5d16d2b4ccdc4b9f01059a83d684bfc68195c312169e995499443c6b19b3a1cd7a19e4f66f6b14425583d07deb247f3b9681bd6e8930e8d19c849f97c3e49bf67b05cdb4250a0b0fd1fd80964a9b9198a2944d608d46c11b8c5f71a664a12b968e68f866489a436deae12c2c5ec7ce7a5f96d0bacf0339a8edefbdb766dbd4c59b26a4ea33adefd2832691a3c8acdb8a6041f88d6b219a1473e1e0f684b4be8d61abfa02c5f1ac6ef1a805397d11dc329e0c21cd4effe02a090a11e1b355888b1e16af8cc88f95f64b1dc92031df5468dacfcdea162318907247a0932fdaa8a03e7ce5db695bea2c4c3060c7a7396fc1c06d193c7e01048a0f0f82a49799fadec2524a0397e4b7d0acac6939c50eb040ca70ea6f8ad0543cd7189d03ca8ae25892602386e3e6c251ff98c4347261ed81be4998db1320b7982ca1b0076cccb86603997f8d9cd02c07d14bf681e5f7f486b33a72a200052c4faccd7718e8fae59726afb42116b775d58ae5b09743641deed8b2689b2facd41c8b5ad9a651282f3d89129d05ba7caebb28b4fc0c03261ed7ac3dca214658e67ab190ec843b88fe1b37dd74cd1e70fe34d3d40c074c48f909fb7feaef667d79f4a63032652d9a2bb47dcded53120c03f58d12ed141b619815a27945cecc7ed03842ae1e21cac17d580a0b39f9bfe6064d30e1dc5a2dea8116cce551b71d74dd4424962882b0305b385ecb8918ab51323bd014b7c7b279228e2f944638f0bfa14a18117d1654b15e9c74031ad1699b2a6f2085627f805eb0d8b31ec372ab69639e2791b2d93394b6540d2ea1ed3ad20cc1d42b0f54bc488487753b5c6fdfcb812c796291a7144b628d0a4ca1376afa4e5a2a29bee00f49ef99e48aa26888fe8326d596d99f330b5d72da36c26b8c038e629f42ff29f92631229f98b6d7ebc8e74b45e087d9ccfc138aba4482a58f175044d3078503a08df56c2c40d09386c8b61f5749d1cd823ad1f83553b0672e8acebc9736921a824b12a2f6eb37a885a517c139f9264abdc653253a4f6f252d7f0b18931dc5dab2a769e98af617ef446ffe566bc3252fa42917a75ba66608d43bc2015c93aa159cdecc15b85f5fff9127be0352a72c77f2e94b68b56b63afe5551a8979f7c22977a462e53508bd7d274af551be1dc418db21fc9c71bf0bff2d73d5eaf852823174d9d6b6436f55650337a1bfd6e30247dc81039959c83e521469df28e8a064f92b249424edbe21eb4c90415def11fb22db810439ae23165be914da358972717df1f7d36d4fd5598411e360f9be3b6f4c620967d5ffa5fc160fbf7cc45b9362c44d0f481fc7f186b4308d9a6121a3b6efc2a9bc8216feb616cc13bad372e4f41b42638806ebee9c2c1f64e2c2373d3ca0dc4c74d8cb6803678969670da14b63e60a6113cb6f18490714ab93c76e9e340505f6b83947ccc409e4949cf9c518db778006769b4f05a4ee3923edc16744b0e40ae488b27d8826d533092bf668b87bd3171229223c2924f2afc7b3e676050deaa42c6d5be148fd9cf608c1e5db4a69e4e841589b725b8840fc2af0a1496067bf9483e3c3117fbfcf502215f648b4202763f573aee21f776f13b72f175bc1bcd2a41fc7c10022681e03e87b654281e25e1bec57dbf2f5c6d0e002c7cbb535a458bf55e1ecd9135a8f9393f1cbd2e450299bee946843a94edb0e1f83ff5a620172c110c4098e95ee0502592615f21c3295f552182aefd04d78f531adfe3b11a8ae97cce445fb82d39bf3b3a66d3118f55aa846aea94f8473493b54622bf7cc315306b0d2145265303c4227e90d5af6f4fd8e8a143743f6156c82e9b6b7781f165a68820114b58be5b875d30e3de176436ca12b234d0dae72c29bf940a62033c50e1e89c5c9cfacb0e72fbc0e07b7bac7c6f9e177eca34d6608d8739f597bfb101ba9c0fd61e9d6f59ebab025d751af47bd2397145435f040aac07c5e8028ca92c101f146b47f91a0d1c1c1bd6a7ac954afcd8ba6ab9dbc966c81e0c7954734ea80f49b5263d97ca6395b382bf30a2d0ef2102fcd956933258ee5ab642ba121954650c008353528a8477ff7846d8d2f766776d7a9a76b0534c5e0371d26f00e24236a8aff08c8d32dccef1005466a516c23c80e12dd226d6f5deec6d6d8ffc3eb6640dc3d997d62a9c6e09c916473c64015406a44b7285268dbf75b85e47d302063fb652b3676ae04d006974bf8c89a47f4a22690916e9fce8dc61bd6600f792261e3ff623e2d6805874266a536cdbe2ba47496fbf73dbfac5da2cc1e00c2b4820489975536ecf386b7ab37ff1cabab9e1ff647e4ac850c7e4fa8333162c2e7e6ba5952b80762259cbbaa7f896cb207384c1d3b71ae17a126b3796f46be6e184deba13e0061ea7b0105c67361d1ba883d4ca2ae02def7a3d45ea5ac668d1182eac60ae91d77ad5bdceea3a7f4ac3bb128683653fa4e05417bf5f88889de91baeed127fb435f7c599a337df86a8e3b02cc4d761fbf9a06fb1fde17b51d3d26904bc72c90809cb34d4cb2fe2e99865310525558f1ed18ec3f9835e0d7748ce22a9d9fe12b43ae70d26d764bcb3f6e8c339a52e9303c1c893b8e604bbbd3b497240c4d77a81ed1bc1979501f968cafb6b2fba165675da1f8354fd15150c57aec2227cca2a9904f330910bf98f46303c971220f242b576926875c63662a2168e4c82b3df2880ed335f87cbbcb90882dd178ad8ebccfb7eb681ea7cfdd2a6661768c8ed3f88bb309eb985bec439c1a3c4a5c9cdc23b60cc3af1f3fdcfb319498f2587835941a901f8b7ff28f17dea787e2d94c199c81c59a0a045b4efc2ec0396ed2720270f99a4a15f91dd194da6bcf99fdbb5026bb65a1ac5cf3b42ce0398c15d8056eabe548326ccc856a76d292b8e6662ef27645540fa33af4a7e516927765bf9b4afea65ba7a0cb1b28a08ab161206b26ed532c78e0252407ffdc3c4d9a6b4ac46c9cb2a7a8208acc7cfcd56432db69aeb9905be981feac59ee4c2f0c7e72be09ecb76d7c1edeeb3a2867e2c98c74547a8403bcec457de99176ae6a55e7aa4de01c3b9435417dff618749bac7e0cc511914909ca109e5617da80eb7c29824221b416694f6c163c35972a575c381ecfcfbbe8c871fb49e2bf967d5afbf1f49e01feaaa8634158deba0cc559a236f474f13692945c023cdf6d288dfdcda5495a9ea7267c77878b89dac6331af62ea05f1d61e9be6f14f81087e5c3842d1e02ece3e53f17b0c415c542900d42b73903fb3262d5a14b8762eea39d370389d18633368445aa1975dfcc8d48423cc5bfd55cbc881e7392208b48020ff1a4336598f7f46b112335bbdc8f6bf6dbfd6df10ffa29f956f3d18946e34a51df31ece67c5dbb2731204a3bd9bfb00bf367b5e55848b5dff5e7868cc1c240d2b8d32b0268829ce649003cd56a4646f6f89badbef41b438a34d909b8e40de07df2149401767fe6d7b9225486f77a6b1a7f5b5c66b052a75f84b6f14f6488bc3f43dfabd4ba1fac988dfac9a6ad66cbd1719531be9b4b2d3f8061ad3b5baea32dc9fa6d0a82f41f30eb6e3d491b2f8dadb1033aa515f7940b444afe3d93a331eefa75859ca2280fc21cca0d1cce9ca6d2103aea2fc7296dfaf88de706ad44220257be65bd62039c475197f1901be8a06c2691484699fc11627bc880920ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
