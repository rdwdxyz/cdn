<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d1c68d4fd0ddb76f38c11e20a391a3855e9eeab16dbba2d98754421f83b1d9bdee391c31b9213233b145397d55ae9e0667597b5bb16f5c5438ef3da2e40fa24bf2ad5958f5e5b6de1a18cea9ce39804ec3642bc5adda00a3971f582c2e428e69e56cf18722a4fd8496853be0410ba7c6e9e556db3d51948011252832cee7e076e3e45125c40585ce2e7b4ef74abeca62834ae225d44e2ef1339ae88b8113a1fc463f3cfb8e009b354a0cdddfba3f1ac32c13f94969e38f4bc32016b92a56c566430875aacad5fbe1ee535f4527d216703677ed0ad24712d869a74a54971810b55cfed03e54ef7fba41cd88a1678783775aa1d81b89129e35bb78e56e271a231b77be2b7af16fc2da05a770abdf22a8bacf007d49521476f5bf1a65a7f0751973fd8a2bed6eb85c2716da88c5bce812396ff8890762944298fbb72bb019ceda452078742fddf3fcf266d11f46d918758ed90e226a6b3b50158dacd7041b93be1ce69632831f3676cb3ea5688be9fd693d073badb2dc98aba95f3185a0cc95bb619777294a4da0e439ab0392b3fb90bd770cff3eca2f26e4e52d2154bc320665d1000cb9ba18ade76dddb4f8cb80f43b6841b4afd42332d1f51f928c982430826a34fa0839e6a3997d0920a154cd9306e5718083715fc1b52514fcc0609b575045bb9c5025276fe2b2fe15ff9c920372bb5ad53dd116ee7df5523babcd1c99db140fe5fe9b683b2f6993cce1f69ac4723745a0e9ebee06d1695c89f5a8697ec3a5c96b15ed8d4388fcf2494e9ee3185fa467da4117cbb54b8a0f55a18df8757aa94bea0fa62a38837696bb91b5fcdb55d3b9c4bf6a1fc9c28999d5c7a71762994cb6338b688322fbe8afa662f0e01f9d958feac8e8b1d50ea8eff5f21c6acd257d318ca78e51f0694cfd4cc583577a0d4c4b3ee669a37517c31ef1e44195c0053b0f7c38f4289683b1f2445a3a44225372354cc9aeb54e609d994805b7f5986ea9cd904deafff65bb56a7e87527fc3424f3b494192cb51f109372faf0e2f6c48f0193e851e630732cc16191e11e1fb52daa588dcb2338e6b93d278385963c2ca5e0f8408790c311952bcc8bddae804e0220f7e619c0bbd2c49099d9e140c7b66d589eb74dda83999bba84cc9d1ecc16b55867e0a2be45fa6053e27e495aa485d61f92a18421e2099ad8ca80d363d35256175fb65f048d16a591832a70dac19c8aeedd2ea58f165a833c284ac8aa5500d6a3e66b0fc2d92cb769a94db6ac9f7ad23dcb0f38e3d3f24eeb812c4dd9f0b61820b9374a8c10dc6b22d8a9a7f3b36ba2ece6861c5e98a57a28fb61527cb03fbe8cf55d4fabf76f1ba9d78523a8026240b841433c34923a111949c65baf65e5609647053b7090ec193949221d46dc53a5b70f32de9d5424529b925f1ffd79f582257a6eaf5860b3374ac24f705e23964a5140e739d416913c8da4e0dc30c2cbe1262b0b8ef6e61f7eba21f039fecf00cc03b095061e8855573f2c2a7c299eb5f0140b0d0b6572dfd0e7a6858047abcede7b7d65cf20b66ab23eb46ac828554a9121228369ed3994f7cf7c32d0c4e71f340277d377fb19a64924b8d1414866da0645b13b86824d6c336452ec3299ae6823f044e7d56760d626427a6a966857d610f173e63b36f043c3e4a4e9f69494b9f580be0d2d15660f9ac10033aecaf137e1464efcbcc89560139f86ceaf4742fac42d373016cd49ea362c49a53880f79b36bd5035e6d31fe342db4320a63f68ba0c2e47dec39cde3336614b507db66f5771c0a04ac3f7c0baff6fe4b46f2f592b3a195a3dca2a636fbb9558dd1202fea963316a67a7d0c2721e22eb7f5e1eb3b07d7338ab2a553a213368d9d7a994353f07b3c41c8aa0399779295cb552aa00ad49151aca7aedf19d43e71d846cc772d08c0a3e759e038cbdf7e5c7614590b43bc76e4180aefd6cd0e6e813875305c2867987632870221595f464b44e9ab2e45beaa504b43beb08e067eb4d718403d88fb2c291bde8e5d0921c43b0a974dde29dbb3a7ba176423bbb732dda32aba71fe7a0daf8f6f348ed8bed03ab72871aea0d2a63114b6d286c3a49ce36112172edd68b3447a93d6d4f9ff5ef2864612709a999957c0c54e1232742b10f789a58ad9e87895fb020a5a61f520b6aa2c412cf5296500cbe8615b84a85ca9406ceda482bc6a6da2e40e29d8b4f1a2b3dc9e5fb551f5060462a89d5f4141edaa199e68822fd2a9e2ed0ef5520206fcc85649af948dcd26c732259db5bbc17c9df22f15aa2345354798e558dfe4285af399869880dac28a8c10f06e24560aaaeb85ebe535e3ebea0a82c475cc4acbe8b866b2753b2d099190239c55916557ae5ec45e344239548508c4095e77be0583c60d47f6cf8f6da7b4406df96090d902c240017cb5ebbe67614279277872e2e6c01143f8835b9e53993682e33fe47779669598ee70a0d8a24064cfcc3430ae32f9dfc4677b58de1d85c4d228463f9c9cbdf6dbef088d2d4d635c9bf89e34e059522269478a7781c93a202b8580e8778a54192a8b6a8691ae72be448161b6b11bac9d333251539a39a82933df2ec2274dfe62bf6121576f143cc91d775ee5ba522f6feab0bf15a9aa7bd23f78b36bad69e91bed3ede8b394199be983484653617a598f7875efa2ca2838b6b5aadeb1336c3ed43a9a1e42bf8aa7f9453baf852c8dea5facb41d93d333f289cc42f7fc70590a3e290beb34a1ff73d4e3683ab8a85fad75e5d770e33332a2b0082e115730af23b3b19d6b134d4d362b1a59419085ac39d3fd5cc62e98db1b15f9232717a35a8cee99c2dcfe983b74d249a1ea83d6710ecaa9932d2940bba75bda2b97577ccd352c11eef9a97535154348824d564c20bcd214ed76106e626c1214065e406a0e6c929016d85e418f12f667dbb78802557ff8177a02bf865e9f9440373797f657a018875a0147f907c9f64f4aac419f2ae4b49f1c255ea17f834c858d3854b14be5b10f65d1d892f488a1a3a0ef6fd5420ba798ff709fb7b34c51b9219bfbef9065d94fbd9495dad54872c0fe1827fc9de7f96e1faff6852e1b5b7a06b1d79ad468abf672060ec36a85637324612d9a252d500db282e14373f17f5eb705fd882e611cc4522d5f37c0309dbf97b0153be916050aa3be1f16507c6617105b34c569d41224a1e80a93e790ba185afe88124e48ca43c562356d8e9731c3e068261a610e4c8c2bfa6ae7a37b8750ee8625eeea9adb6713474aff3a12a1e2368f925bdd70bf8b507eb153fc7d6b24450a9a6dde2f339a3898bacf0caeee4c9051916e13a930033a4133f8869349793f8efb5a1bff6461057ab7f8458aa2073d8a7f8695c3ba9e00e24eb21327c565d5c9c2b2e223a818abf2599b7c6c1cb77506353706cc8f74b9c54df54763279cc94c3289e8e7ab14089ef2bc30b2a292410abea092b0ab47fd883e2649aa767e901dc221063e3dfc4149b7cf11a34794645bed7245a3299216592fae24abf2e82163b1fa9a2344e569bd152ed86ff4bf3dbe873f18d2b75616e37c200bae470527ff7a13a9d0102023604fb71a2429e7e90a108e12508963086fdd6310d47283281d4ff1c12ac9115fad14030abb4b38dbe8b319cd2fee1482ea8fc65495a82f28faa7be27eff55ebf0302c425f7ba9fb538de00737dfcc62f500254205a01d7c6dd06fdc23b94319907fb466bd6667481c43928ec039e4e6003b508963af50dc317405d4bba9719eb4cdb216edad9598bf2c5abac07f615597268894e098b1714e5774248e5c9614db44ca85e24318d6608f1876bda4e709671f08f3e683b44d96d105809de2661fd69bdd328de67078c3aa714b3e013538e9bd7350330e8f6cacd5ac5c97af640ace0956c77e77dcea1cc16d195a164eed8c69e8ea302557fa080c48b65ad532d23d780d5ba200e0efb72e37178b77f2bace7356fbd33e8f7942568bd283e8f9670ffdd885c0f37d7e9ef8b999b4f717039f46a4ce736e782727f13b78329ea7e4f00408d74e0dcb26a36bcaf1bf4e954f65da2d2654947e828fc483e29f1e02156cf3bac2c4438cc707412319fc5aaee2282606ce6111043a40a0951bea6f9cd1366b5b6051528f846089035f254aaf90a8ad9003fc2bb9ce2f5560a82cde6652ee4062bf4126c78209137636163aa65ec80363633ea0c50605553cbdbbf9e74555544bc09c4ac3634e53ac2c088a830c0234ff47ba9f15faf7730bb95077c1a98f666f55587b4bd291ebda3d29c37f45b517be5ea586daf502e696fe35213eebae1adb38fab49618753abd01878510b9db604ca2aeb3dd29ddbc682d1fd113e301750d79d239bf6357fa7ed4c7e3103b27740f696a51565dc742c9a619c6f8d59c2948939e179689412cd1cee4710aacc73c6ca360aa5d815fb40ee87c4c5c39ecb9be252c79d54893d22194d9afdc573459ef95332cccd860db56dfb54f78135c6e1003c94a487bb2ff42f5c31d82a3df1218ce8ff59e0cdebdd1a013342b6d184c9856fb7b7a15c729d1d01ebe722fd7ee0b37350bd8d3feb8ead1c2546650452c61a2c5963feaa0338cfdd77bd8458b839b5a354b82687d88d86bb1fcfa1ab4ce12450a42aa1b0aa1ceaf5bd71316ec23f2d65c78d4aefb0f57c3c651144fa4bda6e9e89028fc829128512105ee70a8e1316d2e33c88dd355f57cc170f33b4cc6010fe3570ef711bb446116b5e90e6857dd8d3d6f1e1ecf7b9d2cafaf410a9dba071adb74316555b3e8c2bf9eb00ae7626535370f9f4b9860e44487390a5e934ce8eceb05cb7e80bff4bf7013825e98da1fe2546a6085db103563761fe79d66bc74a6384c191293b6d98e16f8b074caf052e0960cb1e08d87d1a562fd95641eff0a73b9d00f52ae2aeb7a4498567896646c50bcf057e0f2303132b00a4df405a3ddde495965548b9455f41a525856dafe79ef6d1d72d6e3c291c39c34adfc2124503a44b07cd8f39ed27c66eed627d172f3557feff7be15d4af2a5e277217ba30d9c9496df56ecf2e0b4a77ae1aea5e77345a6a97a3b63d993cf81790dd1135cc1c0ba0a47b608b69e485686687203c2f4915d9c9e549d675b73e2b5bfc169932ee8051f803c560ac1fa1ec76e90542131043813134d1cc3389238f40942d55b1e97022e3b2402ca263e08c55a9e2bc05012893385cf162bee715574f8a74d8ff0e8951c38795220aa9f25a071aef212bef9ee3b824024d5b54997428742ded4c9be6f7b2e2695d8d2a5ebbdbcb8d460ef1d2b34bb0402891fc36e3d08f52d3f1e49fadf7af46eeed9ef243b3cf684a53a045377a9ca809ca84fbe3cce6e520a158a7e620e8ad93e63ebcb9e7cafbc401108cfe0abd890e30bece0dc4b476f7dccbddafdf6670a434d7443ebf59f9a166e4c9bca45142c9a74b3c59e58928e4ddb6e5d151f80ff2ddff1e3c15fd0699ee9a45b2170f6f481c191def1e443b46fd7075ae22831a7a5810ae0a45e3e3127da69192fc90c5ecda39b71bf2f3910a1397ebcb9eed0be440a48876c8f379e6f23863d9d335f5c540c2eb9afbd515cb49854d9d591fc234afc202d5c4f75153dc98bfdf7473bec2443ce043cd746b7f8e3a51872f6858d5facbbb4b401e9509d2a1bd3a2f137e0718cbdb735700f69204f63912faec130d69f3f1488f59f4837f2407cb8153f09215e81a5ecef6da36243eaea5bfdbdfcab4a05bbd800914ca3840e2a63317103de81630bee00a5c16fd6a724a610dba6a9b1870d6e39fc31fdc358448b02f49cc62d81ac4167c88ecd57f72f26a4155eb5d9f093669eba06e29878a96dc21363a6363bf81b9624949269d19deb0456cff15ef61c133ecee1936bf2f1c2535703fe821f7aa8f104e1281027ae5e27b4df1d6294a39e0c4a11a2fa3bf544fec7e5f91361021086dfe96bbc47622a34db8699608a113d1e048e21a09d5c6e331de1cd237e5af48757d3b16e49843d0432ced0d4e9b8e0c3b1df8d4288ee69e6ef595751c6d4e479cc76ad9c10ba028c77df999388af261adcbe5e9966fc51fe1f7d0d35c40d5b4e33e3c2dfad761a5e0e4bf099fb57fa02b0d72a04338f6e8dff5345c866e6e2fffb1ebe0d462dd3ad8acbc770445e56565b594feea66c82e25fb9d5d271f40ada10178959fb97d06021d2414f0dcf0d80a7c5cf964fa67717fc73f6630b8fff359bc67c77df37549b872b9ee61f921c2cc58afecd25fd9c6bebc6a8c9ad7674d1e83e1651f487977e0d06c4e6ca557715ad80dc6781679d91023847fbf597719ad05bb12b109a95d0642b0124bb6276621deac059ed2815ae5c8870a6d6ba5259db95a1d1481d41f86f13ca5123ed410c9ad88c2e61869282b5e1b6f0272ed5928b6dcdeeeb474a7a756b8ef132e3a2ce63ccd79b7290d894a7a6d87738adc8d130b18bff60a83d506ed8f34cf42d1efaab97c9d217d1ce9545643be994b1a6a68ddc84dcd16be73fc69e99a83ee72047eecfc088968e50d4b182dc84e002beb268f7fac0f1bc80ffb6daf1b3c21070c302f5a7a203c5f61a28947719a032c78bc633d14b9038bd6d43262f90e9e574ec49c0936ea83f67de4081de302d8e872c45552a86425a5db3459d9b2d95b0fb02362b108a6fca5350db65a5fa70a35f7e28524e32a7efa369652f9ed3a66af69d9096cff3d3ada0bea400152d3e1592c2b02c35690264d6d91cddf3c2f6686e6e569591aeeaa924e0617b6a72fc814c408936a21356b85cf6a922b505af47bd413fe34260df6310062e142c2c26597fff96bac23ba7a9d83e92273ccab306f80cd22657589b99386e7a18c5ae0d808d11589385c3034e64ca8e4a1d1664be261972231688beee1aee5c195e25b73a8279381b1afafa1b54f5b743438abfd03990affc15ddf9c6f8aaf4cbeabc21843d1f47b812d1c68dc317080c4af288edf6e31b0f83a8e083eacee413dd12be527abe24c590a2308ac71e7b3f23f2550935f533d18df19058f1691cb0e8f244b7a7fd4dbbf28f6d931f0da766ba0858e10c70e649bca7bce0f4bf61a6fe09a0f383f8391f93a92443dd9aaedf5c2d209b355d93002e93ffe020efb0e03dcf2c621e8b1c8e2904eb3d185149cf7b157b00a9a278f9f235293188909667a980619e05d657fa968dcf8cf27b075e6084e38f74f86726e8365affd0bc3c27aa6e033f57cac0ae5f751e9a3dfeec1082804883a82d29f1ad7a12cd06b5d4c4da88f525f5204673a9681c35acfa2065e281a7b809a24adfa7b3210aff21d0d8182e03f38e1d515af17eeb4fcf34be37ebef1e310b0532f758a35608be527700e12b2fe5ed76512599925a1081de39f3a87308b3b4f09ef5dc338262db93ae2c77d0dd31074a3198176b20017b7be8e0cccfabfd6a0fed58ab94f04e473d1dd7ddc09d022b04a5d5f2111626508392239e4d6c919429e955bdbec118720948bfcd53f32fbd0bb14ed6c14e5794ff06961db47da9efd8e74ee23b4c8ef5b9b818aff6bcd92ebe07b759f5386ff8f01f94f6fb3feb5860619c805366112c6ecfb659c3e25805ee9f026bacf0028470e9007e25f22cac1f958d992a88c1b468de0d95a246a6698fbf0b0f6938543befe4184cbfa94639c0982701bfb38bc346bd95a6f8f81944d692e4550c59b095f4baf7eb6b2246fd75d904e76cb37d5b007dfba76aad6a6cd3ac31b8cff37934c9ee21b97d79672cb70766aa3d1d25d0d2f81e6508b1d52babdf5db31ded35d26f33714341f68e0e4bd4d34fce171df4f1ee261c1b7349b3d80963fdfc500ce810a37a74dd3456cab5be37322ab427ce00e921470902965f1346c5edd21db54f4c0bf5d446269f08057151147220b47808d526a7b444bcfd73cae544061d20ccb801491c61fb534976cb7bdb4300098cb579bc40238377285afd45223060f606481fa8fb382795b16b285aad9060371d5c2c14256eafcd0aef8d09ea55447e67e5c76f765a983fb4b710d45ea87b8b560db1e4132d7aee4f14a728888766ccf2cadcad4e0a24b6a8e1332706f3380221ed1f692b6fcd6e76315f2328baa21ffb2c5dead7ea9a31fddb95c7c87276179ff044674e200f0d2cfbca2e848f5983ce8e7a4891c86d3357bf46045861a26ae92185deec597cbefe504d6391dd1d086eba1e1b9825e700671bad983e481220e5731ea0ddc79ec1b6e6e03d64dd699c0005da1de3bc8dde8242c91d91d58d4aa13ffab9f73760e899ee0018b94deb6abce007217a8a12a0a70ceb002a860efad132caec0dbfb5bcabbeea2b330b96e24f583f39b75f30f7941870dfb1a9bf3e0d9448636ad8434a22a250c1b40ae7ce4c413d8d8618a00948eec79a37a6e77e4b7a863b35a493a98d75f48e191c15434299d605bb0c1d43f54cffc193dc756cde3ad8c1b27bb42f4bcff1a13aae2058ae307c1be7883f798a382c216a3f4a63fe970a29e3c812cc7b9b0b4980bb2424b501275f2834dff0e608e83dceceeb357484e298b56a3c54017f03307ecec8f727cb560a8b84744ae5eaad329f8ed5b2ff12d2c4753040284253d8fc218f6340e20cb13339d1ec4ddab1dc6cf7999712209b608f6d376c0bb8a3ffab4e1cd264016eb4af4af52e9d8215e0683a02557b90a0ef249a84c45376d4751e38c7d38cfe630f19d106291380cb1329fa850e1363657522170468cb5e9e66a305283bac6cba5482c7b87100966371b8bbb9059bde1dd00c58f5c6779f16271953501a6ab2e42f9f482d200e7e7748c2787184275b89acb3c6567e69a37a6b95b899f2c76c12fdd7ae1993a258dff8d72e42e6e474596a4f9f2ada43e9228762d00426d8bdf12151232462621c6e55c344b04fc931d334ace353dee67b62bc72b43fa04857a364aa1af6b6c24e05083459e74379a5d9ec5301856e9ab76e9b9ed279ee7ee50a0e8a60d09c672a5c729ce8a51f4833654df000d2c1ea1557a02a2c7a799bad06bb30d6b9fcee2f3f86896fa59813913d6e867f19e67f9fdf1232a2f95f6aa3a4715250734957edf3d6088ee9fab8fc8cb561c8c63b989071d0ec2991c7f17a3d4801cd8f30f7a61bcf5b3e17f671ef0e457b54b264bb5857cd5d862dafdf3a4b63af1f83b3f190fbdd6a39a3fd866e2550a86ccc0dc40135bf683d3e99fb75bf22693d03cac145c9f42fffe85b7bb589e57713edb3e92eb26f76100d3c2c6e455320649752d3ae5cf2b7566e33492551601f13b21c151d8590d0ee4d9892cce1154f264c6d8fc567332774e9a956c31bb7ba27d78776071e5c0111643cd4a5918e7a38f8d5b6b8f5db37b4550ed780975f3a9c7bdf0a2b42a51160ad25a32b91acece4aaccd184f294ce9c04c40338656b57a12dec4916f8a1c0532c8ebe150c96feb59ea2a290292313c4a2a6792a6295eaee412c385e877121bbd52d5efe3b78c2b14507e7df2f264cd6b8b1bfe9a5bb298bd11c798c78a6a3a9ee3ace61099187dd79a20093fa0c3c37809a186098f416ef64c54b1a6e61819b91bcf07b2e6bb5fc1e3eb7a080ff688ff4b660952d40f13a01335e4d71b911f93e76d7f712521a44863447cf77e1a0ec3bfa4dd75a428fdf360e1666d7e89787ad6a999d22c051f181431c338424a4f25c6035308c9cb664137ee9642c2f8fccbf6491a3cd65708d1b3eb0f416bbc810d7a899989f72981ba706cdeb719cfb4ccbf4a483440a42dd458761dd75083d97df0307426d5d466c9f37ff5246507552ff94b2c32d21697521b87c91ec40c01e9b33968bf9aec6add2d4413f4382e0bf48c005bb9fbc2d2b26e2fb0c6aeb725b5f00eed75a8e062a15398d32268395a40f9a5aa42ed339b906e628acd49d89103fc5f3d8eb7ef49e8e9c2c9f06a1ad435952542dfa766caf3fabdfbb9e30432fc0365bdfa8c72de927b4cde5d341f13478a1c48fc284fe50d15785769250fc294d763bf257fe74731a40b7e7e9e79c6e53f305fb2bd4b9a65a61aded640c271097d39825178269af2ea7d6b73fa5d23343bbdd47cbbb1504e85ba7d814c415d5f9543fa91cf6e2f54f3e63112b2e6e891c3cabba46e3b2d4507f18d88540e935cbfb1b9898c3c166f0068254432af9544ad98faddb1fa80e7fafb914bee8ecc117a9239898dd33710f0cacf4ef0606808867c1f928f5c4a0c8834e9c25298d58e89bf67cfc113c63a14720b626a8fb72bed002e51887333f187f4f4c6084358654eb6444820c223439adaa7fbc169d05872ae52b87c11219ffc24049b3dbe9be086f577487ff2d90baa31ce5295bb4d250b256692175c9bddef6be7ce55154b3fab52805a55ba3091305a16b7618064881ed7149c77c158df692d3970c36f61243f179000c3b62a044379cf2600d3f1b055aad9a0f61ce8b0e74f7d4f70eb2c0db69c76094a578fb15cd97cefd397fcaf5a78846f9145ce2d5ff36da964679ab26854c814e58bae12da3eb481a71f24c84f071d65d6bf08d8c051b0a28f475db9553810d132d33b869489edcce5ced0d0a4ebc14f826f1c0a5b15385b5944d3ad6ede530f0ba2aac190f76887ea50604b081dae7db09cda723050629543e4480cb9836cba822b9ef157d2cab4f4b6b4337f561fa47c7b2cca3f05356a05b660daa49ccd57a5f396c937f495735c9e22c67e25a570121ba8dc36af7ff095aa5f89a09bfab0356eb8e836036b6e7a5e141c9a7d216eed0f2d22e48f1ae031d5ae3525f295b139b8e57028db8f007e8063a14bbebfd2ba3b78eb4034760f401b36cd0a56dcda938c71a966ccdd8be4bc9022a003615fec943c096edd56de00e9dd7ef08da677deeef48220660d465438085dd9c704c283fd95f520ba098f391c62e7cd9983dedaa63cc94db3ac617bca84810170ef3133e1b8245b71d6b5e51136192c20110f7b2782efbb45879ec0b2b4da4703d6325d3442d7759af76dec0dc01227d2792309f0089a40dcaf93a90453d0abaa28a81b352092723a20484cf6e67e335fed1f0392770eb1e63acf30f1c90a56d723bcb9f8eb841162126b3fd7ebf6ff1221d6ac3acc457653267a635663a7477682be2fbbd0b1257748bc43ff586b83b741cc48123954b83140bc24208f29e4415aa38e961580feb20f5cc074fc6ba2b2b7ce61aca1e51fe05dfef35cb7053ea43b608433a7c7a313a465b396c6d33b9008266db0a9b09bd3db8e0f9ad09564b5a1782a9be8c0513a9fa099b164dd0b1398a8659ec9a7b626f86c8eeebffe35af6966d65ffb0cdc1dd790e40de721ceff76728b1d2887e89cbfad3552e0115b838871133ba5a0a9dd3cfcd4c687646dcd9fc71140442127a5f59c39facf6c6179ded8adbfc206c8687b20ae768b8485a2e08eeb5c8b13c30d8450f14e4858c3505eb28c06a78c36f33ecac1e2f44d0811404d31eb0017766a908bddf389f1a2eeba48057b35c0d3b0ea5007c79a1242ad1cab5841652e74e2d5ac58f29306a2b90829c0f984e6e5d95c9e05e439a126d20eb0e0c44cdb26ddb02e2034441d9cea6981d25c4e7308ccdf652c1d03909fd7b7f4df415355aadcf3d42aeaf2a9b0e7ed22a7e14b054fe9c14a5167142e82155ccd9a2d543c92f39d1b8c39c9d7d4a9915bb63965cd73962a05385d95342e9f1ec61873352ce06f4ff75a47d236a23a83b40e2467c0654e64cefb8d8c1705184ef3de2f039d74ca01931a8e72dc177e40a7c7fc957f6f4cd0b23727c258870f0dd41014a1299d18b25c44b2e3ba86a00bf0a134edfbdcf23b86e653c68594e2a9cd71f47ddca3d8e203c774a1cc668d537b7a6463645a29230706a487b5ff1fb77e10c347a1c2b98f78dbc4c0744fdb555787a28b8cc522591b51c7f8525fa7ac1c81ab53a647c0a874e98c280988eee8a0097686dc2f08ad7448d7df47b0e797da7e29d95d4c23bb5ba06bf5e8b722af31fa925c98045f94d0cdcc6d92950c0912cc614e2bfef8fc7d80afa0065d0017372ff2dd10dc04a6a4e805bdd8ec25469a2635fdd4d191562d9b52fb72af98cbfd94e863083513859ecd114fe5e8ed433e1f3c18a9ee9b6cb93cd1d6ac14f20430e995c34df091318aa049e751ab5cf37690f437125ba8ff795f34968d3a62ad8874eef090b368764de6b9233feb7f5777e739114489092dc43dc1ff5fea7d23dc2e9c5fe166a496aff3a4923ba60891a916676426498cbb03704e1f70c9565bbfc3df5782d5b3b2748291b0f806c70f9742dd49d8b93791adede93dbcae16c9e47ebcc4565bb43b09103f73005d18e92ec6dfa582f6b252099636937b92de10a1c24d4702dc0b7cf96d74952483a2160382956d3c861e2c06979fba91bf0a361a00edf34a8b157dce9ee1717111bd9541c3ebfd4f48cc20e4867c03f76ca8922a4fa6f1fea50162177b96cbcbce3a2eb3ebab760810a5b06dae68e85668f77b85c3dc1eb475ec000c9beba48ab3b278b7249c129f3ea778c3567ad8a99d65aedc12951b83f81f2c0b1311f8edc663560cf69d17078d58c33fda6114a450d8aa4ff0d02d705cac174e3c08a025ee8d2fe9b29750f7a725fba2a6d62caadab4e839ee37a230188df93af77117d610d6180eec4b88dae8cb278a2bb85e3cab03af578d2819453d737ca57e47fd37dc46238852d6b2c795da40c7d85de70e057668c4ce2f5be98adb53b9db9b17beaa05887057dd1fab4e2e92b6545e8c0b73353a94f0badf6fc3ee0a3d46283191a2e0cc6cb7b5328fe9b2885901404c142a99ee1ea6deaaaf80a4083a9c2c7138af162b85ee703c7d3043c501c6d9e7dc14293c0bd15c08c255b50848dc5eb4b1b4ad8bb6c7c1e7b5ad2730e7fed4a65f3c5f67e7abf40ac6fa0ec5aba63fb2edf00c5feff5c0c3f6862e917d18579fcae9b4558d301465cfe22f1e4d96992502c906c581e0dd381724ab27cc52e48215fcfe332bf88f8daf89356b4e4bc302d856ee4ff6a5f3cbaa6cefbc20737790e226aa8ced034238e58bc538d3b056ebd62fedc455885e7321074330927929c168ece8068597f176b11e46de48d2bb072342fa94d485dc20978c9bf73bd3578abc66e9cb80716f54743dd12019cb81152711174362385abb53b2111e76f561e5074aeebd83b6e4e075d510f0548658a02fb736f21ced80d902dd104cc9ac87d74e2ef77844158f50affa047f6d31e5c429609df7f8b20435b0e4c0558437e1a35dce26bc364d2345ba8c47c7a48c5502d07c90c28b72adb54d83f3b5385308193afc1b830f6e9189aa65b1b2ed994cb43e1d2ae1e783a2d5a2ee4f6a04286e2015301e29d1843456297b982f6fb81006e5a39804d2843cd8c05a6af24b6e1b22f8c2e3d4fa9cc538153cdf5df928ace216d4475a84eeaf9a2eded255bfac4cae8530dda1d3b3f5f8b322b8f1708c632e0df51019d06b061d7bdad9db03c6bd7b8f361f47c39b3038bb93a4cd731169a30325a23d421e21e2dcf6af0d2755d24fad71df208913c58ff26f5c954369b845ca8a1b60fecee16a8a48c006aa30b7402798af24c2c83f8f1eb373effea29f787569c16c75dfb470cb1c9ad00985361beb56433a5d99781b7261458e58a653d4ea55964b6abd3e1d35909ade32ee6420a2a68dbec2ec817891238089bdfdc244dc68afb7b90f4491064a8956068cabbc238daed9924ca87d2e30bd57570ca9b41a54d39a6f44ac7ab3f53fc4bbacfebd4affb4623579750d3c29eac885dcce702617b6b3d09ee8cd68c0b7c5c5864684b4fad2753bd955d24a1f6a1167433e31fbb882fb40812e1e4e40e19599ab1d2c69a0abd8a1485c327e6722f730a6dcb58934ac5ff5e82251b699f6b0b92d81783c389e48f9423ee4285bc290c1b0ae97b6fb69fc6f6499980370ad616821abdf7731359cb9f586e97435833f402f5d2727d081b839183b008dd41e5a57f5997b1cdd7b2b22c5c7b4821c710161deb05b8c25194c3b502b04083400115f538f733ec4ef223be084146a6666bf344abf4b7b2ec0c87c278f43af530128d00e4b598a37464e3c0866c800ad1bdbd6bf17b2c33377b978f3b9974336cecc4ff8604bad0df379cc5861c015dc1573981bb3c07ef1fe0c156b981ad0d1468bc6d29c071e06686df2e9b1f22e8e8a2b3020dfa51edc959610067c4ef1a40cdf7cf32cf75080398b85d86d5716bf984c9990ef0598cd1b1e6f41f54b8deec94fe60e487ba9b89954d5e9481170852f40a24e0dc50da4bd2398aea2dd5eeabd8bf3106d6f957b11babe4b0d48376b5bd32e8a44d00bc87c451fdb672275713ae0cb60418b603304b1553cc982c3dbd679c334744506616703f1a53522761709a277225144a30f63227a8cc9ffed97d5d5f1057f4b79e8cf42a4b4dc57ffd0a10e61609eb0df004fad8d4eef1748d63e73647bf8ee3ccb7a31824b7d5bb0ff9e311127d385720b2b4628e7776fe2233f65ff7e88f0feedb101d695de6f93f04832244bf91a64a04682df18f007546f596ebe99bc747eaa344c3a5e4a736ff233d0c1a3bbf5dc788d46c56b82711d74a5d86118d3fe2e71490a5d2f9bd4c06ac29edc90bf233f073548281ea682b5d63de183b7e3234fe2f361dfbe99e17409cf761859a06b09914104b731fa183ce2aa59cbae2b5b290f12149cc3a597c0001f47958d5f5c17f07d726578ae78e292cd1b50f1023fc248007974a9941513b268a645bf8e6e1292e8b99450237d7d4d6e6f19479cebe416404a7d54186fb7e4fee31e7f88b3f4c3a77fc7cfbbc0b6edeea9bddabd9adfa50c6bdb77256ed07400e109bba0b59bad432f41162d96ceaf88b9306a5db885515b0835899dc92a44a6010428af1b82b8400cea8ba7be687a67505914ea3d38cbea8e159ef683dd7801cdf2320c1f2bf27904d908d995d119c40242c4e5e77a5fcfe3156d6e459f556d2f282b2426950ba14786b5609d209372b0dd36114103b5b64bd6807faf6811264226daa6a622e088b40e8e2f9be2f1811780b5f11c02938e0858995a2ee1f1404ab2e4515bd5b04fa72d2fcc35df4eb15e6056e4929144ad149d6ad2bc0850cc15ff6c144493f11d7bbad742e537f4e2da41214c5f004e9689cd7648c7d7ee44dbbfb22bc7ea832360feeabe9d9ce05faa85d305b10058f6967320d45a759f69f67857005a762c247a0dd54e281bc1f68299844d5f39825f8aa5d9ef3e98a8e005a5bc309073d66509a90b1fcf33e11cbeec5dab775cea1206d3b3572b8f47076f31c4001d2595f9b373fed28c3bfa9ee54817cd358ce9f930e177b6082951dfae786698bd25197d479b66af6fa994a9218c0d0b990233f4325177df933c746984bcfa5ac2c6a733c8d76db7abbd7ed656b01e78e6d0d083fc71973a78c621da61c68d1674c1e79a82e3b0f04134838922c6441ce0d4700651120f67933f7f61681cf5e093f4056dcedd5b7a9cbf923c41924237a9b631219477191552e49abc0fff7996436426072b1b1a618ccb2aa6404b494ae388c8f9d5c6325bcf2ddba641f54f78ff2e45fcdd2cae380505c4261891de16bb5bafdd6e8776f47c9fc45ad51136574f6858160a074651de1a939c84f1629d77b60d760782158a66fd466fc59fc1fdf70a074ab8da00bbbc69f9c962f7642d099ac89c919183c498b4628422027ff329b5cfb304be6db2801f8278a5133268f9bfed0fd881981b5b6280704852ad1c9dee0503fe7bc8528284dca17c44ef1ff9cf989db080fac0d2551f68007e2b1aa798701e04e6aee213e1cd136cb06aa041e5127fe21f673af2d7d4f5351a107706b304d89b88c5e5a5dc00691daf8167887a5a026c995e0d2d3807fc4f359c1fd07861107dee71ba9131de4f61810d5fc37ff3664f1d7ce180de803c266f169f5cce408137b6713a03350e4244fa1242e42302ac7039f958f1b253a35c1afa45d1a3cb4541519b548892d6e2d9616bbca724c29a731b3a2fec7a0e782d276f7998e8aa0183f75a8bf5c31094e35ca1b89e7ce55c852bcb17f54345b001fa59bd231895dff571ba32a74e17dfef4ed2252999600613615108d7b3a59ed650fa41b979deeda24aa8e12d73fc505584e88622ac35a7de9de134390adaa6fa2fbcf476b3ed3d9b50e01feeedb2103799884e1343786cadfcd9c38947ce6d8186cb35d7eacaaddd05a15d92f14153387f51e84adc56d00dc3ed98b2d1e3c474f8a416b2d4b3a493bd5a206b0e05c88a537283ab6db89c7eb4ae1bae6ef4577198f725e229e4afa8451538483aa7eaa8cd02f710b1205efe03f0229327c1ef8773f3d40905a28affbf525776c05826f5cd3bd8ccd42e9de430b813a5902fb8d2e1029da604ddfb6229e725655b6feb3b4f9b414f9189eef058e8842e2bcc4bc5b5b80ae943a5742b3059e735607cb253cdd3da0f5d6b64e0bc2cd768d7404479c8909829f930a302920ac4ec7ffdf340192fc6dda6de665fc3937f62e7a52e6acfecf2f184339e6a1390dc69bd187aa109578c6362e0127de2c709a35b04074a9f589bfcfdcfc07a63bab2c0545a3bfb760302bf5e89978cc81611aa070f94358afee05fbe3e2e8f773ce1e2ffe6467298e2f6813350311892c053939e8a335f73859c13ea62e09cf60d5aa4e58c1e9ce2ef10dc8fbc4120e312caafa8f82fe7092f6ed77251e344abc41580e9213d56d777818873bc50d0bf21382c5aa7fffe14626a8acf280270493cb13b16cc1688166426baa7ef941d49df7567cab893cc5f5192e8283c7d007006b9a6240cd2f86b9056b6df91e9adaa810c23576b44080ed27f9b537944342a0a91858cbb3e32b390d2365f576fcfefa547347bdb1609c4025834198eb1b313087b29eeaa37b4c38de7d09ad5a0525dcf6c6824a29b9b0a7f80e5a51d7c2d4595a696bb910de38a3fe8976c2e16fd75407e834b1c2ed1f03e4af1e50dcc4695d2d26b971af29fa4a9ca5bc56e72552ee391a401f689db56e7e332167a9e0f24b1aa19a1c5bebaf66d1927598245f41f2967567043262a832e544101420c22ae12547fb29c763328901588c62164b7d2b053766d9d9d5586c0bd19e20b8639d8df53d0dd94253212cafd5ebeb243924b71ad6d243493441637f1b3360f9e071be4f9bec2df4822858f3063d60509e971f86799eb78683cce66612eab3fb6d577c836b00e06520bf75effc851f29216025613c6bd9dae2653c059a3133881f8b6484a0e6dc0b455be20abcc48c8b9883d4e3716614db15c042e58181c841111ab3564ceceb2fb3751ba27e6693d898ef3e4c21fcacf48e98f014bab58d9d5587f0c161204479d176a94a2723888d4a9fe8c4ceaffe60bc87189e9a329705181eb6e0ccd3f7227fe9b6092d929dfe98ccf27c5ad0d90896d4bba7cfb6cec5414f7d92b7d7ff33790e082622e71270041a0429a890b9ee3a3b9b4e7a171b8ad5d948caaa740f7850e57bdd1c29691efb8f651a3f5c4255f3e0c1d4d5ad2e487bce387edfa752fe445c0903e41adfe241bc0aba1dcc0ebe040cf6d0fa00a83c5805f3daa6d880d7d4ae998828babac6c9d5561c44c8cd9d0b2f98dff95a688db476b7d84e313283ad4ca62f3062efbe521d101ffb88335fc11f9e9701d2ce96b533fdadeaadd7aa489ec7616b6f51fb94267ad3e2e03737e1f760ebf8a2503dfa325538dee9f9dc827da05a612bb8ac830097795162753cf671782a8bf609ffe63be47466991755c960a917cefec93645faf29303bca8106b046f17d55d540247581684e772d09abc014db2fa65eb6b10a046ce0e645ac7a1b82a09b8b7727e54bfcd9282e11728d03eea6d0d558997fe5a21ec94ef165db9e56570ccf10690d19b37b12775a9182a4f4b8e5ae47c444ace4f26711a16aa6b34d7ee0a687293b73ece00e63bb4344d49218ac1084b70de5e9adfd3163c53d961ea6859837df9c0338852a00c85844c952916e1908c93523c18c60d8e43b2b1e2dd385ffb87fc25476ad451e9b08e1bf2cf244ff7fff2ab15f35d5677a9b6082201332bc061d0ba7046116f722b7d261f4b8fabdca74c036fe451a87486ee8703d9e6f853cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
