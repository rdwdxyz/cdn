<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8938316584e4b46ba86b1b4a82215f6d6a36b352b1f0e110edac1249a4ab2eaf5074d6cd44c77356fabba3e66ff9a72d18687ffad93d23b79ec8c415a808e8a92f50a0d49e679d17bfc9c0c428c2ad354f0595faccf5af79a659b9be0176e88c331630b16c18b461a85a94525955f091dd6f27fe30a4906f6310aae54f636681c0aad70a3b5315d6100b4e488f815b881de5a8dd32bfb02269798b2d7e847c8b0e8cd9b8b71014a1b087930ee9be5128440f36959b3839f7ce640c04cd423b72b36899aab2c38cfb972045a5bb43769df85d05dc1fd83cf44db8abd5a69a0fe02c18e6d4bfaf44efadd3ef6fb400c53192e99fe45476638a0effbf6d1b6b6f838d3dff695f601888f39ca3d84c8c0cfa0af0fdfb5b789b9f506e30cb86bca91b8a3d303c2607641cbdb5c2e84219c236912771e4807671d71bec78a3157d5d7aea9861c3511eca184fc46a6efb0bcfc25102b036390e776dde2cdf6e84ab958226da2dd11806653d1a3e0d7ee8fc37a3894ec78f7cc3394ffcb82e96d6b068d9284daba10dc0f5187efc5158e719a79b6d92d492f8e89bb74b43498fb6646eb7dce5cee16d69c69a78d57a349c521e4807bbe6c3112f58eebbc6a1bfe8e08db4dbd11acdfb5484153c0c2c35d65f27fbc3241c99c5afb1ed9a27f8d87d25599be8f06905a70e54004ef01b4599fb8afeff8f111a334f75b601b91aac80fea4f9421dcc613d9a57f92221b16da8b44cf2b4e477c454a23c11983acc7362d55b45db37d5685b9c6664cffe9098c8f11a82200c56a4a7c44742114e3c7ebd8544d634dd42e10fb604e1139c8abbbf3dfd6f46f7805dd115cd4d18a38f9c2204d7cf43ca83e3f13ac7a36bb962cc05ec59d210580bff309a240acb33495a56c948e30de38e36d108ca0127315a125953ccc51310e697187b23977a887005f067642afd6bf3ce2017da4e8a298a80056f62d8bcdbc51898a376d1a298010018993cf70e1b7bc9b3a6c189a91ff7fe5c56b7687cdca111fe26359bd4108314a3c77e01b5955691ac61aedd6ac9a72f34c3fb4e1d4bb8348b01e88ec682e3905ce1562b1cf371bebb1347be60a68c93cae5ef083dc6ccf394f2d2df84febc4d2aae0a8d614a6c8695da80cd8c55ae7952c022a34d42a76e980e0feb063c50068ebff528a50464c0dff5c1d9169485031f55fe336702a72fa480a01adc7a17f0dd3ee4c895b863bc5096b1fdf1e889922b675fa4a04c35552b587e2a3b4d5b59c17e9a0a020e4da1f88e1be85e095157f4701665414e67f52901d881a6464459cf30067ef8783ac8e5486b59c721c94c35192467e3819e8167178c5737a92aba835fdd18b742de6fc95fe98080fa780b7759a71dedac17a86bd052e5fd9bb76d39e6872a6b9e9afa58775945d7e8adcea4dc07454ed7afe67210a016588174076a460a32274ddbff1ebbc8e39c98fbdd03fcdd361a6c314f2a48b7e798bb09fc7b3d8de8acb98e3cde0af0f45b937eefe5bbd1e64281df6b2e761476d8fbe702a7c3e6d5dafdc16348575c04c77f1a44d86e20c992ba189f3bbc62581094cbec642804d15656ddcceeb6226d49ac0360c86856bac32ca74b72d63be50dc117886a388d17edae9ae844eff0732ceb73851265e78cff850df4310a731748bdcc54bd5711fea5087c9bd84de4a1d41eada1cddf2a34336fe7b5a497d81504d3958f784750fefbeed3094600877a7bcc9409a72c9bbee461c6dc8b869f8dfabd375787b4c44f4fe8ed0f3b80e73ea7bdcd14a13dcf17bd6fcddc25b79627d5a2c88e4081521f427d9e4c7c7b91e5151cd39bd2109904787b0f65e73b689095ad2966813fcc8c6b7cde7869a7bdb4a3a57f7a6cc0bcbb26546b13b0a92e5c89bcbb07ec46b8873cfe915be4568f7c106da63e7679a59b8f9fbb7caeec6b094ec4d0a3f2ec6c916cdb95a17ef0f8e78f04e35c66bf86003e0fbcb82f04f4f5b3448c2782b4b8ef7057f8a4767de551923c10145384d349e6b209ec7564f11860f9359bd863c89fe9bd6376c2195a9760eb5c31ee4dc9e8c512674d68deb2fa99b57941578400540e10dfa7b2fb51fcc44c935e28bc70feb03d5912da3e395a0f9064be1305fdf3fa5107aff1f6fd8adad09bf08b58dc3183201230c37db5b9ed92dc9a4a5ac47b1ee451e486de258b48575bacf8909fe44ff4d862f9854dd2ad17ccfe908ae5216f9f5052a8c9f6cacd84628c4421eb8125f8b9a984b762109cb706f22814c657dac3ad4f9e799ee4c13768ab62aca91d76b19a5ac963c5c86b49317f9a59518bdda511341ad2f72af4cc4cf323df686e2ca2488b586aaffb37d9ce0d50520c5e5639c0dacedf4043fd87572cfce7129a354796ebb1dc66eaa4282fab1398c61f73b846f776453a0b38f025657a85116af7d0f0f6adf37bb6305e4328aca661a034dc43b3187c1622f5abc9eae63f44e327ec1138bc461bfc5370ef09f7fb3ef08a35782a2045348798470f4d5c03e977836cfe8f3ed8e9f196c6d3f57612f04e33c71abf441cf8b5c0e8454fa439d75d6455fb6b713ba2e14fb738d5325f5063d4996f0ebaf5d91b70b015b841c7a815e755531b1467fcf2cc23ca068d9fc4d6e9f837c7aa08eb821f9f972730e6ca73de9cda1b640f46682686004b49aa742aa21d448dc9f24a3baa41a6ea16c3e401f69675e7a7ba4b9126d01199bad28f8c6cf4edfbaf2dab62b5e8372baaf87da9f2782e9fefb6fb5e3781ef690d317992ee60d983e7f84e68e3d2a0276b1cdad52cf725eeeb5aba3995fb438bb6dff1dc1a13aac905323f785a858a884ce6f243444488ee8c1a77bf2f3a77de4abe5fe047f02d2c7bfcd0f41da910bab1591aaa8ec8d107fb25d693968d6f19b37f09f9a0dfa58446efab89765b0b5e884ee4283c7b5984626ef92803b8e99077100763a0765f3ba7110de6845d0c30a625d91135b32cfcd33b3b18740829950edc86f52bd21774e7f0bfc694e9613e82fd4a947842d8d0c7c5e8d478a3552f93704ddba12e62ed567175c63f1f39d5789e696728242f23aa1ac6f9d495c257e64c1e87d3b179a797a3c88a9a9a7cd9d629d3771a27fb5ed5f6f32f14f90e61d118054845c57a537cb48efb8162a0b2b8ec7a4b994c9da2ab55a2370d7ab8be2866b3af315220f601a9ab71f76ee2b9a4d8ceab0016b78356af32f2ec9642b6f6d7280e8282b86e38db70705e7043b3eb2d28ebb128aa3dae9eb6d11e782b68f677e9b6a64ef99de2e9d5f73eae07ed753711dbbee89de86014ac7f92be3cd1425f781966a47bc62476778b0e8e3c58187be387ea70038392318dc4cc6ee3bb6c69f597d6a927f2a957e83d63a406596a534b29265b5208f342de91aab0b4cf2917eea8bdf22d91d1910c5e5d00b2a5c66fdfc27df89d1be3c6158ae5d5ebae1e35be682bd4d0e050ba66254bc30483e008c8838dfdf34ddcee2e5022920776f8ee83af88ee104e7da3022c41bc72b19bffc99cba0b075415c94390a8b6e097a34018d45508f963a367a74a4d96a9d7171f98f14afccfd741a93ee3027944c4db8c165cd292ded67203f8c26fb71b46296ae4da2724e62b5e69b88db2f8bde4ac9703dd567dd77cf24af2b02f70f8c10669a567bec4794725cdccb1b29078da8adea5df109bfd544cf6d9a3271c59972f7fa60f593eee9dfe7ee2a0d51756ea293425ca17b87583ccdfa6fc9c1433f45b802752293b8db6a1efe4a949f01d77e6adfe164e9a0206963e9adcd349710630503e56cdf78db9db97d1286af442e559acb2519fb0884b40b01a35c534345ddf69b0648942660e396026a3d752aa2441be6e40a47dfa108c2b37af4581cf8278a7171e683c9c1616f31761f8c596805f1fa1790dac03c2c7635ac2b9a0f83e6ed034c3993a0886bf50bdafbbd683e3edb32912a4734f965c9b22275e8557e13bba483150c7a6ac6dca2994d4d5246e5bc5ae996afdd33020363b7c80491faa05f37d622be374a4a2f80b633cef7e8f664548a45f44f7cbc9f575849c599b63a77c255b67aa1bf557949a4cb16f85ee998635c92ae89fea170590bfcb83659b4c91a10ef411f794f1f58e23770525e635b8f5e6a355477c3e088d6bb92325609098a66bda510c5c80d416241c68995d455c4a84a44d2322245ea5019ce7bb091f3895383919b0e0b269546b44ea2ac1a49b29e030595bdd6d594aedf45a81c1c5a45ac4fcd3b2cb766a011b8796d61d65f75f2ed058be1ab57921f78c90245052aafe671550ad3c4f61d62cf1c11c1fae1d444e08e6aba84650dadf9748cd5d41614db01e48a8d60ee615eeb830ce2f7a440c345bbb8b785a943b7b00a0670e9448b083323fa33f1509351b6a1ba1e14681193adbba425efcb97699a7929dd4d486a392906c3ca759ff61b1f0cc74816c76d2a094d6f4b52c3fab1ca1e7a03cc7b66a2b387fbffc40656e17e44d5c7fa8e522dc596a84cbd15c47d52bbc11f56022919cf008ec39357f4f045b1ef1e461bc7ad40ae9eb4796e37b2f8dfeb5538e8e4e3a9dd9e6aea39604ca0e434e918819f2d1b56b4284d0c7271e429ce80ce3b5500df4b5e4b6aeb0565566897551ad81fda9853a7a14922ec803bbb260f92428003e4d2ca6526e6f9842d5c4c84b8d3bc38b7f0e4afa9dcd10e811a9d78481f2beb495dcd0b36d12e9ba6661643873d07c406be763e5012454e1477093ddfca9c0048f84507b5856b9182adcbe72f87185ee74fc4ebda96c053d10f5ebc41144a9c1a35f4e906d79e35a6f538b36fcdbeee8d3ca9561f69769479d86e718f69159f69311d4be11d5c3e4e6bb8fa80f09763742de67fca30c2a41b98e6ad9b0ad7271e1afd8dd0e52563d3fc33a9e5e039787140201fc93b3f2f990242c6443a24d41218b525336fcd6e64271edf8038d093f1bec64bf759c85aca113668b490a0ac4b9b0f64e138e4c7b8d21f46932bcfef937cdc932060f29643d66affa58024c203f55ede520612e55a0010f9fdca18b3db187146fbcc0433e3d6d46100652fd08faac6834b836591e8284c56b8cca6bd106819ded96a1035644555a67d2d4163d35f337790045b72d06164e5b4d17d99e795e45a1d4f709250a722420dca30c01517b534c33bd8a7eeac17d078391832cf6eccc5c04f499624f2cfdfa29f11245aeb62962203575f44e06abe56351782e4d864099404060790a961fee7045a4222301db629447642e389b09712cef04076924a57f1359b322483b3ca58f9ba0fd8086447bf635fed7c9ced0575deef0a9b93391ab9dca046bde1542295891d830612161bce2ec37fc6ca1c190f586277793a4255f649e4034b14dafdafbaf8c69cbdcd391177e8ab617fd21f3901ec388c63f8c473fe28914ff690ee4fcca6ff1b93976666c44a812bac5e71e017a86e7ee9fa1c0349754b3b443e68b927290938a563690b70ad9fd3b5e262b8d21d5a7763e5f68846697732aae6274c8359660862d0b79d9c23084352c764afdf08af66b93969ea8fc7bb01978526efc58431b6f770ec9ae662d3048aa5774c801f7fefed56447be9f226df4b5d106ea7ced8d4fb990062e695850d2d6df17a2106a2ca5dc713df38c03d262889dda7d7b204b70ffd44404e86d7bf50378667cd9ff74c1ae759a7395f7dc2dfbcfd75f0a5a7212f20c73ca2d3be7a75168cda1f814b303431b5f85623585b7f97eb93fff987804ade32bb0aabec72641364a584f7f0a016aead19d9d598014b171295012ea89d59670348970798b22cc4c63576b04bba8b7303d2336aa9fd7fa91057e12452ba4c262d3e290f0d977b888e3ff577d83906014921128c387f16ac788c09afe18b6ee3e3719107e9701d7b45faf8fe34e5bb5743d3488a98ad12fcc22c133fa7658930e6196a6c9b73fe94a9c55b8923f0a20e76643bb369b93583eb9e77a8beabf6fdbfb3b98e744bb3ec3e89449a0fd288be8df68703e803f09932a41d8533bb94f4910c2caf03573f33aadace1ee2a1bff797f63f45f798a22c67d86332d0b42bac1f2fadad517ae9b0423dda391052a7e7b9b9cb3d842661510c19cf5719746e1fa0f925b6e7079e56b66f9115fbda7897b47fde4bd7dc2ba9371e8114d51d99e16afaa2dcdc3860eafcca2e0e8c8b55e10da6ded2785d4363b88fe96a4b8e2b5e382ad0716705eda6d9c4b6c27f464cd0c4d9111cebe49aee6680e47914970af3964c735dbe520bcf1a4e06003bf88830f9f344fdd35483296d94066d36e7a8df3fe61be4582f077c6630529edd47d8b7b62256e606d6d1dd8578968bc42e638a2350929e950d119ad71e88ca7495aaf1e76969d9a51061075663e3ca793d20c237b3341734385097e7c755dd00f7f5a8b52d2df007b2b7c138c80aa6be69e253b5e9e9b45d6ce5b1b8b7e4e6f670ad14809a0d2f969f7dc9e6d71daf90d4922292a1c69f6de11c60b227e260b7e8ae58c7b78f1c857a2736cf03055a58d92bcdf1091614bef8d3786d32d604af0da8efc522731551f80f0ee7a857dc16b832793d65d5b7620ed07e0a079c4a25eee440b88f27773fe58d6339753085668f04eaec7488e9084f9964021b458d47e2b52b15422551ca9134b49de650d9018fe9d1b1962a6a1c9d44be6f22f60a2fe3b65d1d1ee5869848ab3717b4e1f3252e3c865122dc8d12ad42ad6d7a952c9c7ca91b226f27b42cd9725f5c34b0662f130c0f5dff2db2696fadaab273bb0a3f3e3409d9693dc0bb5b0261f2e6d04877ff7d0eea254ed937040620debdf7b2c72d4632d945247238b3cf6f6cecd924da4993eecafd295bcc9131f54b9ad8b7d7e02204a097deff60bca847172a513ee4805fd0b5ac5136985db8e1c3c1d084f25c6378162c86fcdc4ab5fb29cb3404b03d6d856b2f1abef149c2289015ee4ab98db3f78baaaed9e945308bee4d1c16c98659f76528a7a94041221e06dbf70f52b99ec8f25a70a465d37d2c0a20b20e05272429abc4f17aee1e6ca07c94d4d8d642fccb32fddad8e3c7e198bf886a92be1257a1a0a5c26e4ebef49a952f7dd572c467e7e5b00fb12fec5c023d76f5119cb59b9e879de2bc2b0c283d23967c2fa74dd7da4434e7b5edf3cd813505b8021cc59547d27e807275e6dfe49ec260c5a3f6b9440c60ed11e678cd30ec7ee48f89b9594770cbe9d80a67eccf899db9db4f2e056c05a4ad584b560d0fd276fde6f748daf85dd67045df37460a202db34066d8bc4a948222128250749f2fd2abd0d695e40fc508e19ddbe3ee6294e77c371f60f9919dadc86ec2d0d354cf5d0694defd921ea91a5e5e813fba57bd3f2201bea714c727131387761ff984197dc33dbf235b3c7c90eae2e980f1c35f8a1b3efb2e4e57f50a3d78f4aa79303d4bad78b2ac383d06860e7f30f1e419a2c7b86721cc55afcc6d5f5f2a1bacfa988e9637ce0363e1c66dd5dd104e3b5c94f6a53f8f9b56652f7cbfba9023c60fd1b459856c743f4f1caf94f0f448275f7e4438709f6dd295f45a0cdc41137f57dc730aafd9788dd51ee30268e90b3a377ed4d3fb1d48c2f3cf50aa90803f6ae293386c08b35b87ee98de7906894b1b205374485984549c69cb7c0a680f582fbcd0f4ec5ffe70fa28523dfdd2ecdc74fa910e4041c8830808aaccd094d2cf467ffad46af464b6c596cea987652f9381a89c8ed30e71598125c10fe9c412b215c95ebfa88fd85c4c29df7141f6db10a3bb6bcfc8e18d668e8b55a469f479a3b4010e94b000f871715d08d86278339a830ad09c601ed105175f021f9175d0a15a68c2b9a4651aca7c9eca1bf06eb178df2708a9ea671bffd5f948cef56d08427858bdd3e8abcf4bfa78ed5bca486df819863c7e1ed5236c7bfb68f77a2210aaad9fdd13fbc2ecd7ec8cf28c7735f5c28751a933d42daf704c391ae8190ad017e5420b419f8f67075c4937a1ecbc3a480f01ed7655effb02924f1f85ea941c232ddb2040b0da953305cb2cadc857441d121ca1b5965a130f0362243de43303d3cf8360eb0644c16a36a1ba4553e9d8bdbe933591d59d7e2a685cafd742bd8da14f14d9d426c25e4c9be46881256ac5a8c099f95ab5c9e23a0a8e99948bd887414ac878cec6c61bb2abd11bff92005603f6133ebd54f9a86230474035d6ac99d538ed8a1ef2e134e6e77ffcb70e93def224bbec36059f0bff5cbf41fe683c450c695e8546bac5037f74cdda04da38cc585520a676c4ddcad817603ddde3a5b6a0bf11b12648bb2c9dc0f8656fd50f57546526e7d213d994224933cfa68e8438221b46e0d22c9ea1bf04949f5a889bc7e35fdedea27767a9f915b1f1b274a73f1c23f0e2dbcf0268fa9bdd04480b5614add19840e5a41391644ae92d11265a613c8a3b887a0cd16cbf95e8fc07bff7ce3e9d70af6e152e67b8d02c69c0063524dfee2d305c1a1f3d1b2cad279cf4bb89b8ad622e51aa18f422a6c4169ed7b1dbf2dc94e5dfa02b40806eced41948a0fea1c9f4367119bd11852bb31db6fe0324e20ea475a05957035b41870f79d683e18cda0b955af46b2d3dca72e61d1de20db2117ae0ba949d30c3e75b18671354f51b085a12041c810ff6e7d6dc4e883380165d02eb03ca0e790fc22ef4fd10f3ae6386206f0e906c0bc5e588fafac967388ec74e39f874ffe32f65fab93ebb70da1bfb8befad83424ed5e04c6e0216f556689ad9188bb59a8252ae83b32117816007c6a3422295cd51ed95456d7f9ed73589b010afc7fc173f55607152bb927351c583fadfdc58b46e9c3a3b56316917aaad6707f3b62698117df3f39b2b9db9f119b36703315620907752b00d339ff52e9a324ac30f5362389016b2cb35e1922947f51fe090fa784310c07a56944d976a8f06277f65687e04694e7bead53c458f6d463fd44b79292340cf7af2a55231418dedaa0529792df7608d2444f434f3c3ddcad3ef6b58cb63e535fec106809026928b3a1b73a8968374ee3c9cd9360152044cf03c1e2e603b32bd02bb2632c35cbf2742c4c6c434e53ac0de7238aafa7b842afabb307fad1ed241309cfb8d71cc0552ba7674a2b25d2e190ea5a54979bc67ed205d1b406ae37343f240da19982593617c2125180dcde41a00af044a6d706b1ee515c3db50d3ed6f86d9620eb769bbf6b1fa37cb1d2fb6740a05c540345d70acc7737b8d252c10363794cf7326f5a85fbbd4431629fed3f096184a9da5e02658d842ab3165a5ce8ed4750cac28fd1eda261c552b9c4ae8239a0b1e98a598b9d4096c7f6b87688c06e0f570bfaa0d2d5d0a88f38ddbbcdf646749541f19219fe9d4444c09121be3dc604c6ef5dc8de7aee36de7ab305a41fbf8dd89f431b4efa183943d528e5b0568dc999bd1546637d79af7dfa48c61e3830cac24a1972e1ed4fc56571f72343a59aeaefba39de31701d5bb837ffb8139920fefc6d9b80394d6707adeb814510317b99b756ae424e3019a3b6080ec7cce5bb68d516c5edca89c749792afbe1514e30b5d78e421854232452639248e40ae2895109f8bde8caff770e28566fdd20cf3b9d5e82b2aa6dcbf2bde9e28d28e2a7197e905b36ec4658fa97cb2a5e13aed938831b1453658d75612daf96e5e303b922d3fffe9973c636601747355ca7a5d63a420b2e195afc852fbd86dcb3f8da730930f615ca2d25b3907caa74361363a9f04c2594d7068f66346f556cc9ff83f2594fa1472a6986b11ff6ec50d0876e830061b0044b1a420c86076e8adc8e5acba765f946169f3cea224edd40dcd44b3d8cd3fcb96eb05424497cac945c4a8524d56b43952dfb8a0bd7498b98beaa9539f0e07630c93f570e97f4188a3248177696ef86566b818a9cb1f36b19ba4472edc9e0eff2eae92f23eaefba2515c4da6799a753c1ad36a19c169268b6983cc2fb57a5dff3d036243ed79ed740c516d5733c614a61fc719f4e5be51ba26badfc9efdbf4355fa57f6676c619128be6735432fffa0434d6115e8563dce5096a3f0036c9d5f9e7e07f6ef37af62a4052d303eb845b2aaec621737811ab0e92e56c10a0096e34365d405592ceea0a8835e2ab4949aa690614c30478537055481375f27667d3fbeff9ee0c6b67d9ffbae557b318bc2831e202c2c0ee98259c37bb442c2f6ec0e7b5f545f9d4eb8f3b24c8e6d14a01463e091a6466a2667ab9a50477e4774e6a1f76477733a08320493a86c73069aa2f73331a67d63f9fa4b22573bf1ade213154f69df4ab4723833abff34fe2141a56ad42d60341c68d36b8fac3ca6dc0cf0f4d94146e09c0000e08b48a4d0292e5f9eaacc3eea01fcb39c6cd43127d85345c03d0d018a81f2a91a37df1e6beaf0f50cceb8f70016f7e1737f79e8bafe9f4c4f5720a3fef3db43147ad60d390a851befa1604998e1ecaac84af371a85eba186e571cbf232186c597227400a31efa29320154189d361ab1372f29cfec0a95ed4a45ca5b2242576587edac9d01b6c1bf91b935721b52a445d06100f33d83cda1104ab3c32d9b5e36af62ecde29ab6027903aabb8d82e4aec179ace936b730e185d22d68480641f8814e73dcd27aca87bf02b2b73c19b3e0a36749e3429bcd3b42a3a2b1cf19b33ec567a003a78e02f1b6854e9e3f2056bb0263ba76dfc5c8828fb75f6d85448da1ce093f1b6579a04a591af0434cf76225ad34f4f4d69f11afbf0fbcc3b161be45169719a4e7e39ec2e3a18c33cad378310dd8e30b69369099c75b753a62d9fa73140cb31ce4410be31e44ad9088daac7eb01d921d020c660431fcc7ef6788184f48a8ff252909338fddab374ea297933ebdc94c7695c04b0e6a49463e40ddacc8f7095dbec9b1f4660a4b3caa26ca8b849bf5fce0b89320b8ab92ef7849f51e42fdac36c7928e2d5c4011838c50e8daa557ec7efa5f1975cef30290de79e12ad3c4f6e6bf848dc9d66fef44f36411453dbd73769ce6d5863809fbaf2794d1be2127a7ff77681a9f1fb06ea39afd2623598985e0f415a85618df3fea615e71b42915517d003a2b7bb60c4e0b1eb9f2b27086d6d60b6a0bdd87edaf57986d598ab99f2d5fc01ba43184dde2c8c86a4f60420ab540f81ebe3d96e0b82e9f9a205ec3c433670d2082ad641177ebfc8e53b3ffb829cacc7e4ad58f0fe93385c136ddb8257273892fce5f28be67dc84707b2b331240ad238eebce2295b0e38c712b2b9f4117a2d6655c6fdd52bfff97ec4633ef5110d2169e143b8c3f80d74830b29321c95acbc39f9215aaa74f8eec937016ed1284150e00912a2854f1f7b9dc9a3ba979b16542d9dbadc5b8cb15811d8e85ce186eb93a38097ea4574cca1135bf35b6f77b4c9fb016fb239f57e51822cfde740c1a0f49cb4fb4b94a01711325dba7b2bd4c4f198995b85d48eb07beda133172767f654cc239882fa2b9f711829e830527c8b41d92fd10bc30997dd5a68b357417352e341dcea8a829503b0a9fa0ab4731c7e216ad57896704df905bf056cf02f7967545cfbef6c50bf8ebca78da94f2e76944304650424c76a9e517f89059b751df2cf0a2ade57478bae11f64a1fbbb823d5ef2fbfbb80db2e3e1db97ef844e3dbb6d30c4901b522854fd9c0b167aeee55ce6f5d7586a540e7068a7c1282eb276f7ee5dd6db907a79f3a29935dd1f3554c60b6ae6648cd2d59e3fb2360028b2b17db260e00214680c2a5203e30b2aeb3d5d3589743eabac6c296d0be2eaeb51d76435baeaa86d50d9766f5990bf4b7f0b1ce1fc2291d5d05aa914262d4ba5ffaacaabe00a987f6e028c52295d35fb9908328820edb246d241311e52c2f2dfc27cafafbf8d5e9f1cd7d6376d3f9d8479ff452e804d4788ab12964422bcd9a328f0f92dc9af7eaa88b0db407163b0c7595b18e482b2f972381cd74dcf07539a4382571b5d4ba0241b79c6a5df56526e44c274082f0b1ea3a4989c627caf6454be55871bbaa59752fc7798f58d2f224de668ecc8726afd074022ad395570dc968fa56d879744e0ac576219b98967a300e825c0ecff8ffd5935bc05c566a504f1735659aa24b41331e674dc7822e89b75d6782bf7bf8014de8cce9c4a385f401da60eb527658b2e8a9c2673458b9994c56984d0dfd45efb50f985e357829639bcbc45c0551b7d9654a95c99c3baa174dd34eb779786ea17a0d0157850c85dbfe8e64aaa55c7d0d2c590ce4f5bdf43bf08824ef768f231d0c1d75e6f01e1b2544f8ba9f2588bd77858f2b9f1773816ba983f1e9a917385f9f9f3708ee5c01dcec9644f3b8979d9d79efa7202ec1aa01b57644382ee9e40baebff0251353e33da4dd27b15e5d3a5f5e1bcb4561e2f36649d922bba528ae1bf57cbad55fe28dce8aadb945e5dba4925f0df4abc8866d453607d0320a36bdd896175d6604cb7b7e2adeaebe53271c50acc685ada4db006f3e53ab983af7680e45a722ff088afcd762c25107bfc0cd1078cf079cdd44a699991fab009f553d08ddabf2d9b3c8d5d55f240b6e5a5c762537f362e2cc6c7331ebd054c3969c932e910a350b516ed12bc3a102fdf37d573ad976d903a53eff77c607cf526ea375ffc2fec00390a9acda5961aff3ba3fdb422a2cec1eedc43373d1cff9d80f75e8a3b74e045acf867d95609c6068ea4a8a3f4e925e447b5515edb57567e1c47ca3488c9e862f2338c1671e5580c346520b9eab8f1791eb2a10887e21a86bea1407badbeba90f5468f5db817ed6c814abea59977d8d37b86882c71d473ee6cee6e56352dd8a69d1bc48e09097f008b8a78eb308a61d85dde4c684f76645deb934d28333fb65b9346dda57348c21b6eb3b9853bf3b0f35a61026c482b6b9ff781aa7579f7723785bbe4208e156f49fa876dfba909860746d708d1e0eddc540e842b90560c135090c1cbb2c97b7caf7310d87e8588a286b059ed7b19dad42593f03627cdf058de151a245b31c1275ac042d7dd08336870336f8537c53162ca67dcaef36a2bd06adc214d6a1e7dbfe46b18a0618fdbd0ba3a25adde357b0461d5597ecf8e90a0c74e17e6d0b49a495e4b9644733ca3f23144c41e4f7d56502d9291afc3a3ad178645e1c29855ab08abed13a0864698dac41c0faba06c1d560f39a82ed1668a8f9ab5120278347090658911b10f5ee19294db4e47ff5db8a4725c631073d690c05240e1cc7b59355833cf0a4ce4ad8292c0cd1e811d94bceb0e94019776b243df60da763e9ea14cf51e2ac2169b74cf19a590c5d45b0979c7975670cbfa42313d3df214530b82d6aafc6f52f3c65bbfd59e0f424e1a2f05fc3b9462311d0c6cd015762961b97796f06818b08352ece94b9adf2d647e0bc670cb4c837724f25f756bbd4fb42ec418bb6aefe76c68cfd533e74d1eb885fc7bd2bf316642c54d0a430f3452f8bd5e673afd6e1d03e75e7286e9d2c63696b7063082d6274a3f3e206fc12604d631367ed30205a41cb70bb1b1f2ec4d249a63ccb50e80ae4b9731661ff067c0e46c79b7765c68b485c5b53fb627034cade4f46d404a4cf8bb5de26652812370ff37af0a5c6b4bee302979f8da72538c0f2bb7256e869f270dd4f3710284e6160895f11ef71361c789aa26e1275ab63a465057dee0dbde768787ec149e1f545049d8de47f1f3fd4dcd67c51bdd4e26782a3f091343e97d8e845a0200982a2fbc2cbfc0e74c0fbf368a61dc9f17a3f8a3c7e84ea23a581fbf3a221c822c15f1ea21311db959fcd33734e41909ca35b153a29bd84dbd1661b5151e513ed712f6ac117db4a99c2cb8d93a9ffce12d36a34409881a879cabc75a0b81f257158d1fdf02db58afa89c6d7cbf8affc20304743ce14d455f641e639534ce4a288a47c958929d8ab7c34048e6eb22fb4decaad3edb89f17b40ca8a5f1c909cbffe494a648c26c211f1b0ecaff6d6f6aa2efe77809fb71175648c36514ae0cb5709d6a50d7ad6d2b7cb595302863d57bc7bfba91051cb48fd3d45ab56b3b51c759edc57c37e3d3eb6ab931efaa67b9ad4c57354a9e388fd60f03835037bcf68b96ba4d5fd1d06d150b4c359570de1775fd622e6e689358bc3a17b649e516bea250ff795ea76cf210160956a0c43c14a9f05975db95b0f7647118cf7732ab47ffc6c812dd4624eeb3c637455edf8ee0d6c5f27690297c88120f9b6bf0de8a6e849301f8864cc8aabfc8f44c39647a9d938a6aabf8825e7d5875530ea15c089479b13b64568e79e9aed788e87af3cef33290d637216b025809bf93d8ef2d1a2910c045a84e87408b0e3afcc287889261b7d65b4641625fe6c6b82c8859c9ce14839d76f39387834edba461bb59f5dd0bcba320ea1026564ebc134c00f6e4763d8765501c7625d0b2692a825f30a77e3577b199e903bfe9eb7d395539bfcb4a8c843a1c6e967ceb91fc59f657877a91ac1b121df8993282918706c86f1fe4aa2446127bd950e36bc7c4ccc23feeda964bccb0ab3934d59c812df6345a282bcbdd480351fd83530defd160edc2c5a43aacbd49fc0dbfe8455431811008ab4bace5e3d34995ffd9d7fd52a17fe9e6e8182c1b184f4b604fd8a5b0e57191bd7fd32816c3f8ad4794a19879ad3346c9ee819d5d071baae008eb35b212f8c79d9941b1837791c1d2ee7d747cc2c9bca92c62c829790370aa7150b48de77c8c1e3cddc01a09aa2f02f21e22348bd53ec1894e1a903876ae8936b1173dcdff281c293d8a60be3414460ae26d57a5d32e9ed81dfbdbd36565ec2b1aaed4b47025c74a347757ee8d9c4aea8acb36ef3eacdbef864725d831f452436467b9a76bb9b5d4a96494f56675108a7cbe041cc89e29d274c04a1e88d6dbbd731e91fc1f8d38e2b09c93748aa8e02ebb8b0481c8c0c53fc66fa66860d99055a6ddc2772bf39d80e59fd4f92a89973a68779340de958d6a6804d47439166d30a9e77e619721199f7548fd81a35f2ae765bf30fec4e475311c1cb49911e83dd16b1cb2e294ab542a648e7332258407fc185046ead38e07871fc38a18a3745560152e1e6655f979b7e681aa693a0cdc45894c9e14ab56ce4766656e4450eb4f04ccda3c3d705727639017ac58cbfb9099e3c37ea328f9844b82334279c9634fbe1a11d5fa9f35cfce6e58812ffcd67fcaf291218ca44d995c1679934ea3c5bd205702fa58f52dd755c68b24c4a669b72bb221a1090d88fa5448b4172300fd2b433768a92255cdec46a5210f9b618375608f253c336033651077c72fc1ee020ed9870bf9296344a3b1986b5efb06cdc86b6100fc1063f5125925c9abb1a888a0c3f2b6ca2a47220c0aaa8acaf5530d86e1367cc11a7d37bf368c11b2a2a395fc9254ca02c74a7690005028ea731c17babd8ea02cb12db2ba37009709f5b04d07b2505b7280e462d11f8b80ac2f245e22b62215c670e13527e5a4e748094cf6ebd768ae38640b852fa8ac97db0e531a2fcf71e74533dd21014bb709ffa389bcb04079605bc886bb14c7446e5af47e75bd17f1c08b1c85edbc7dfb081a1e598f62ad330331cf92b2b7c52bedf6e32e514d863b27a4d4190d2831ec4d6936ea32ea3245711d666e43701d051c8ba990571fc2a4f7920e2f22c7376e92d9c15d4b2600a53e9e17cda7a7b3ea96e0fbdbbf4d234a161e69cd80c974ee703b54dd91eeb3d82a07bcc10152c38e07438ba5d99d83fdad40fcb75a8d5cde1af2eaee0aa4d4aff82c53a7a8ebe94b8928acd363244f3721b5f4e5a13c554032b07bd2c408d2289898dd4208f261fc3add309f01d0d8e2b6d3ad0a36f01c7b8ec29dbe6d69d17c0dea6ccd53bbfa9f82fa74cd1babd52c22c47b606b92f286f40b9ee34cfe5e8a7fb6a1ad212df20514c5569e2e94d739c6e01658ed94acebef847de355c6edbf85f205612c2f5078867f73d87a81450452e54e8a60d80f1de222f5dfa9827cdfcab2495fcd8e816da138659c412b7132858fbe88025ab4b391628e3871e559e72507b803d0fb5bf407f6ac2c1519e84d86f094b8d70794039c79a6b8935a9cef1cfeb4b2baa93eede224096259e03c22befee539f11f577e9328137ad043828e02d77ca314320253b5ffd36cc16c0b4ba7808219c0b8b642acbdfb69cf7efdda11fcb1301f1d556aedae11e015e5a701aad427160b410474ff2758421870b0f77d084dd8be4f5712078e20dd7266fee33ab8af20eccc31291586d1bef0176a1ad3bb7a32a9bba0224799e598dab98e45d960931c25e3f84a3f65e150b1d966152011d0e57baaa8c23071333bea97ab5c30db5969466f30fd60956b2d31354f1f54e0e1bb94a9869617eaf7783f2b386c5d4c62eacf02604d07672408a9f782c327996d8ca0247a6dd30aabdf4df565eacfd4a5ce56163b9f102b2ccee14209212b315a46d21166bbe2b6bfc094cd91e4581824fc0c9412678fe737f16d05cda8dd94d0be9d4c4b7557f754104a66e44d472a6019c258a9f679428ec93b8856c21bea46c001cf8f3d647b9286e26ceee4eaa75b81b182b1cd55be2d5ac2787969f10f3c00108d71ea6b545d98d2ac5df5f2f8d159a910f541dec847f30c162b9b9da1754f9a79caccd7ab6bbd4b4a0d069d3636a69f979f272d31c832d15dff0b6ad44fc80d881ae14c0fb69c4a77a78eef17b0eb7692b2d4c3e8643a00157db4a86133b6c9b9dc030bdafeeaf567cbdd096a15deef73eac4b9d9196b968295f83a102d83c412eb214d79225104bc2a96a69dd80c68df4a8315e2859bb2d99167779e15d35a6ccc254bbf4e5cb10af09b2a32b74520e203e507d36b5104a02345420d3a8089561920c3039bec81fc3a161241b8e1d2818c44440c8512b4baed68f1153e31a3119ff0ebe52a0767edf8ee5fe489c5ae6bbd40f99b21bf7be62e0b6dcf9c79143eb6aa00eaed83815f45ffe1fbe2b452e09618f7ac9624fa121b46772ffc8f754c05744f34fccd750f066261e3ba2c904762b136637065b5e64db88838a32e0df82a2a431cffde855d92fb2e3489bf09146b291a5e5bfb5615d3574a26021b433d9b51f9b39317eaa8183f78b969f1c92c709d4a681a98fa336515166008fada8055a76b40a6f9b82ab09761bb8106c785720129cc13451559a1d2f0385d9963e6a565ca62b50baf9229426c56d67faf95008ebd0054b4115496297970b6aa55a62a74afa8d131747e8189f87a14de22eec1da9991bfb6eaae4fa107aa0690e76327a877912f80c2e7f3d56862fe28a85811e940736e20a006e0b603f13cd50013078b0f224007da86f5f05cf39a393ac719f229498f8f53772efebc72c3a5780dad3aa2fe030ed0ae852de3f357dcd16e3358f52ce330df59ef3bb9f745584a1ac1d081562419608c84b825f42cf8fcac165a8d0e4cffd1c1a5e7d00e6acfdbd47cac02e74e87bcbf9faa2fc89dbc839416e396b3f1e24a8ee8277e57fc9588e8e75d48c07e9c1d7da1cbe513db2d1a9a7d6535ac651175835c76c4fe5f1c2999512fbe195cd78fe42e52b341f6377e0433238a21f5a5e07809466ef39ad20c6472c3dbedba2dc3a50c0bf91c61029fc2891e85a6760114e702a1009fcc975586c501bc08f579957e9df08f086abcf28a307d82c8de47cc4a6e31a0cf13ab48bd3e534fa742894ca4b9d69c3e09b89beddd9a08a4dd89878edd73cf14ff3a859ffb87e0a1ba72359de120585a243ec20881c9860f2983d68032aa6dfd4c5033a4b8362b48ba13343f7c43dba960f1e999514fe71386db87f94149a541bbac2d5dd6e2830114478e6ac65c62711018596fe79d4aa650ccb4343951a34e3f64e3f317a6653a6d844ae3f193930517662f81325e57eae6c38d675f9ea4d22c50f61278e8435f0b4ab76b841fb012af55e74bea4cd5ece197484051e223b5962efb9dd3c985b9412c88eff8126f9b0e6760e707f9a2b812d412b43863c5ed03eb95068afea29e9fac9fdfb79a75587afe8a07cba1ab3819eadc7b34ed98726448bd73a5538df4595ae2e60eb40a465d0c2a0f54d22910c895dd84f1e91dabd09c28240eb485673621495963c917d522bc4e00262fee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
