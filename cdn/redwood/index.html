<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"196174063ac7ce2a66d1e52d754cc44a188ba1bcd736809b20377b1bc16e660f261931e6043d0be9b4bc3df3530200f49d56a4d74329dcef4af942305af09b0ea3ce6c17f11fdc7c03274517373483d44da795a069c491aaf1045bc764c563144a1f1ce2164ed904014a1c2a32b4fcd76f00796041938641ca4e590eac8f976e6b99dad3c5be1440c0286cb6fa56013cf719e0fe95eec5b29fce435e7ef5b154a4ed9161654e802940d51f44354ed236a8eab753940600f71283c5220c1ad4125e4824b366e28c9af8f14920c56537e4b54d4c0224ce6a9abcf1e11e699095e66b1df21a51aaa76557bee9ace978fbd87e63d6f508c0f01a4ba6d8b104cae846c27bba96160834841bcfcaa3c102f4d18056bdd9a80258626e0dd5a232c4c277e61e5b47f456128589cf19ba27b5121fe64400d3f9b3373fa2576dafbeec1766f79a3c19163a51d0f6305a2a7e5081a246fa4327d4a82f6a8a5b53abb6ae12187ecc4b97b899acce3bf0c07152970a2fe19ae4561ddee02c44af005b0da40bd7b397f5795d098fb3035bdb81efd125bf126462754a2e05c53643b682b05e537cdc45f95621052f8d1e06fb114ce6adc24eeda32b36392a80d738c8ea4fe100ed0740f1d474a87824aabcefcfe62d46a612d6286fd722322e68cfe48180ef8aa0b0266c62e7ebbf6de6fcc5d10ec40352575bfa2f0ba6459d342922b1b5e53ff54fe999b1a2b6d5e039ac50d4c60580d80f44d74db236c55bda13cb1f43bf116b7e416d8be46e4edc3c6e51f49645041f0e426046be2369f8885d35b694c79601efa93c7a4e5c12b81d1c7939ba95460f995a809c2e93bc5a37a38c7b123163aa168aaa8d09a7adae24f152670fe3b52713390d71e6cf76e58b666651fd8cdc45a7cda7d0b9ccb60189b24161e8d540a4c7a1cafd080a16ce2ce6edb6007f101c4c44cc67b11a0a3eddf187e7738b0a52c3b218bbd25fef77e5dc45c9fb66a178142c412bdf9c79338042f4a35c1174f55f54b08b2552cac34c82e7f80fc545d55ac0433c1cb906e64872e5cf408a2cdb31b5528454be26ab3486195b592302be0b39991e3b309b23cf47f3482459b215246d81b03ae08482d170d51ab7a0f4d3017e12c45020a40147f0e861f2abdc97376003e038ac6128e225cd6a0d066d03c79d69a6aa008880789ad1ab49a023fd4bdc943acc0cf84b1519e257381e7e77117b7e9c1275d5733935fef34f5816044be75aa97c1d4b60fa695c9cb370aa3e0a9d7e892c1ff59ae60d9ac23fac1155c835371f6cf26d843b6a0e62c20ed40ea41daa3d7019d7effe2ab156e3812e0dfa012d88e9bd5601d1caf1e7ddc20ef14b16e1e51087dd890253f6eeb1dcd7d10fca36708c6469d5a3e50aed83e6972ddbd6d28833c3da7c09a852e64d17bd817c83d1a3d719a48940e6b6e02ab1d55f7f649ef5665b5849d3a02c90be0f4057ddd7e2471838d79ca3687d21f337e887b1cfcb5745bb50c3d588b257484b72938d5c7c6f80f2eb9982537a9a4b09da1ac38d4ec3f0a6647dd06c6f169a3ced1f93e372473dd94c6d179bc7794144c5949a56391ef577e108e4191092c144462f96776b7b4ee7b0a4346b05b1b51a168a166b743e823d2c248b3b4ebe1e89676b45def5d5c3490192053a846bd6c5892c59b1b810bbd47767e7dd323960d834c0a7fec4a3d6da82bfe9c65b3be4849c94263351f57c76cf8efe26d4c04950c5bb4e80a073d9656b299e91e30d0db3ba9c168932815d6ebc69b959edb5e77461fc5808d62e9fffff554625dd264a5f101fc6bd4e3b50b431e9ce4d7b82e5ed83af69307f9f9a0705d3527f0b226591d015c630d261f1631733b5541f5367edebe1511e8450799d1e2987a4b1d77cb863011a95eacc7676346631df6b545cb47e681857eea2cea19766089697a3b9101ed0ec7c6b877bc22fab640d7cc4fa99aaf78290c63c67895ffc2931e3ac5f684663dd117b66f20fbb7baf6a1ab3a130d4e19119d4be03f500da75e85fe9bcda3fb3e3135bccf9924fcc815a05abf94f7de210adf48a811166346396e4e2b9e9262bf23db0ed6f04d67436ebadd76a4a8b484e85408e60c5742445871d81b4d11df6ffd29aeb282cae530d4e7b8b1aa840e16894d61389a58c89db91e8f8e09f4fa036fea4d84160709ff85bbb9ab3fb6db5ac1a9d2028627096a3d90b51d53c125ad936a1db008579ac7bce51a4a72a5efdeaf2cc1397121868f19026ba39584d8bbefe484206476b89021529f3fff69d17addcd56646335c16c31205ff7e9cf8bddfe0b7b648645b7e85f7dae74ec2afdfa8738501278200422cba8a57d7cf1109c9b28ae54b380eb07477896b88762fa14a5b940844cf320cce85c66fd3310f1822d72f0c3edb9bcfa6de9846b2f3dfbbd08adaa33c735a9d6ebbbdccab674e4ea37643e44b09cd0b899afdfbcce25255b85622a0109b9ec06a84c79241e6a948a1e317ee68a7ce327408389f70b10398782f3e0360c8f2f549feb1f83956d00c3a90ba89c6345cf33e1e30949e22f98ca78ad0463153744beeded8ca196a624b364af1af358c0a88dbf69230f7e31d4d6451d1c35cc78cf168ec5ebca2abf858ff1488370143ce60076ceb59dc3263ec2de7f3513d7f7bb3d4c8303fe85347ec3ae5f7c9735471faa432e54704dbba8d3fd399ca1e5ba0f5fc6841a87d6eec8de717c0010ccaeaa911ab1746f2f06053a2c6d1e0fd1df756e405a8c0baf6564430a7a9d908b135156b1a46691ca03f3b61c6c7e5c5dee9c921d368a61b2a1577a553ba65ba36405d489b259b4da3f09c1c196411c1ad2a560b291fadff17f749b88404bd49eeed0dd4c0199d2dd28244457d1c0d7a954a6910734b001b97a75e49e91bb27d65614a0249c02a00b6ea107b7bf6af923f2ca70933086a829c70a229ab494218a79d327000f9890546bac51f030148a0ce6b14dddf44ff64e6ccdece1d2487c99fe94f10766af2a46d16e242aa58f0d195cc449e5433c8c7f9837c0ae641b5c87e7c0dd6cb629c9301985db045cff0497152e2e2c7652e7ee0051f75db55e230b51eb77d8b85190a835dabcfd25a6b23bf6b478e65ba167dfca80ebfe9e2343c1ae08da58d8b43bb67cde836a70fc63fe203b8f9fc673370c39a6284b5323774b6210e98e5528857d99a539f694d6860fe6c5014e863ce71292192fb85cb6d0834b1d8165dfc5031ecd763d4cdc0692d0b0cde9b9671253580c831e918db51acc9331a6465d696844b55de61c9b43e4c6ae26b4a3e759d370469fd5830b2beacb7a2b5c6ac46b92cf56e47c3b578cdc8d0afe1f1c5c18031e7ce5164751d19f3ee7013b0a62c381c2e512054904b9484ddc4b460cd6f388e5e999546c55436637c28fb83b216e281b5c5365e22d8dfe279b2398fa86476368c8e618497c81b8b1cff7b757573f9153e75a3d326efe69760047542488fd92eebb59c04e03dcb3f42aba7aab1d7ff04d83da3fbccecc364726c14efb7c76fc30819720c082cd22c853a62930d59c45d365e7b65bbfd0af8f3c095f6ac4592c1cbe61e87440cd7dcdf5f090dcf3db2dce9448eaca1fe84ebc1a2a13621b8860fb37f7cee4ce1c80ec84cebbf777e1fa12d3651f79d7267c1964fd8308baec94cf9dc045bd0b1285d9a5418b768c984493ffb79ac25febc5e7f2278afbf50e0a80a99f5e4c5665a533b8937d1cb6ca805f0980351e664571fac4c55280d7437a9e91026a015674ad701420399d8e6edaac4134307305890c78d43ac79a5d83b6daadc4a0bc87f379392598d7b19308bf9b32794c3ca1853d3a02af2df75f40d8add71d1bf8a26930266757737a729c559cce69cec8e63db25bd9b81b0878583d9d55f20906d69776feb13491ecd48270f20228549bb01535d25dd997e746d44e595ac88a8292d1865f91a321f59d17a4d351b3f899b8cffdbd4be95d90dc39951f8070f2b1c4a43962f83d43568d9f6ec17906582de1a0c5c68a519bc1bdb2c4328faa491d2f07a5282459d9201e22145bd4050aa6c91c01868913a35f955937ccf73a372131b939c265ceae532992068bbfd26de3abca57d3722a489e1b8a8dec854c481e00756ee4ca207179774003357b9c860e665919e815634f4cabab35067c1c2f8044416eadfe3e17dddc2f9a0f3f87545ab1adb81ed7991f73e908352b69293670de001238a520506086da0ec01219aebcb9ee59a9b1ccdd9dfa94e96d1f361999a149e1de28da8bbe94dd39e0857432828c97b7f747e0d06160d42b76a62b0008fe598e366d9cdeb656f68ad03c29e705a8955ad43f8332795fb2bd6ea9ec89a9248da17dcfe2061ea886f65447cfce2bfedfeec67217accdde8f12c6ec53d42af727aac9265d167a1f97b62774356ac583e10fd9d2c1d3f261b2b7334029a6ce40a52befbe78a132a662b12e78af4302abf8c0c9e1fc7de538dfc4396c78a8226b6d97413bc760ad69a3586bd5e6397e58f9354dc7b69e0d68f00897d36058f2374c776edd5d68141b78e486355bc87d8e337f74f845efb65957f6e8a57c1a4d574d3c0dc7f112869b0bb504304f3b0f2134d0153a41cd2f22e1b5dcec7529fd807b86132669c06490ccef6f07c460fdca0ede26afcad5620ac9fd3eccd30060907b5a10a339f7036f47291b329271fe963db79a7827fc1f44ae9eb89af6c6df7977271ab1bd9f9f5f2cc811f5ccef3a036956f13c527ce5f5959e24826239ea9e30a358ae89759cd76982af89d57083e1ffc7d3439854635f0d7c4d20d25673514552ca7981af074762db8d967ddcefc98172b50bbfcef8f60b7d9d77a7e506c65ad25210fd7071f6e97d41324c2a8b389ab296809daa1f18795cbbc8052d92a5df026acc2daaef5fedd7b8811ecf7d92495457894412460527539fe1e388973074ea1b66e805781d7a1bab4e6b87b7925f06391b640e94070c71607ecc16b29f1b98394e095e8129e55fc48a228a7a50221a93bfd01cad2ba6a05f2d1944298c5a4531a7c1843da1bf41754e5dae42eaf8030f4738211365dde0a77ab9db874642ff057ff446b93959ca117d3a59966beaef5fe11dceeed09b2784956f74a95eeef22fe2fb51c5e090fc55f5bbb2e3399cd2cfa674c295117373a239403352a8be5cfbcc7d559428ebf7ce786ef0f676a26bbedfd03d8fd5aa1d4898a86785cb39c0600d29fd2c6354865e2c35328b78ccc0491eab5f4ffe122ddc82163c8b068c2a278ebeae6e1df13f39b16010eddda2c033966ee406c4377883ce895b0cce055f1eb781df8471e748e889768a5a697999e7f268610505a7fc69e75c4b122dc463162c751682ae78e0bffc8f42bff8b68523706916c6204ddbd2ef97cd961115be9f49e6c7ef49c1275286b6dbb22e785fcb176d43ca8977053c176211665df70bbc28b65a7c64622c69de0c3b240aaa26cd2233e45a34dd9459d018b6eb458a2ee1c1efd4249f0f6075576b82ead0776e1139e117aaba73975bf9b6d102deb655cfbc16f0790000c3d4819406e33f2a98ba7f5dd571569c24ef5c90e579151b8f6d0514ae18a40ec2f1938e8bc6e48d1570f67f7297413ccd96b25001fb23edf982c7c11b930301f443663cef84cf2dbfa760729f4bd8e818b4a04d56fa3a8ff0fe87a7cdf086367db02cf482b9d110bfb717c95c705b0ae7a03fc21811041635c34aa537592f41d13137e535388cfb81cce3a8761da2525524f7f9033c7c5e893ff4cd782dc2db2783e1b3adc69eb53a1bf9f277e5051752d44eaa00f8d6ad18d1fed5cad1652ceb46bbf01415908c16599cb815d9c714cf3e9c0bcef1f5d9c1640c8823de252a2ae8a7123aeb2edb01bbba61ac7c593f607ba0c4b0d04e2a40248da4addfc87dd395ac1fd31da0bbc9805f45ee38e6ece316819dd9e45cb5a2fe4febfc8f790d3613ad2c4c2d0e44d7ae481e71e7dc161c03c339ba7c13a9026a9fd604feb27a90c9bb4fb146d457f77ddecca3eb80578591cccccf41827fea73c0373372204c2708867f095068d95b106aef8fc6cb4a66e33a8b8818e8c45f11ea67e9a829fcbd954208d978d8a2b39d2f9e70bedf5c91d6fbf7c6d43c7283e32e1d4228e17da9127cf40f6c0307450b2827ccf5f6927e78d3d9e0e8f9c1a5e58b8f84fbb40ccb64fd28a400b8b5b2e338ca7052e95669524d4a27b2b983eb62e510ba0aeadffe55bca0bfa29f8cc8534ac5eb03c3ce86ce35f1f2e76e13510fcfb32b1a1682cb834cd29709eee7ed04447306aa5dda485da033b175125463fb928a051611749c74883c1d639e56f44ada180fcd7363de62e1dc0c790db98dc9f49ac419b4ddf33c47f5728122a6ee405954c67d9d3bc37daeb93aeeeb111627a754126523c5f7f93aa3ae54befc13956e1acf05078cc94c47e15fa994ea77371c05e32b90b5a5c32fccac7fb8bfde7509e63cd50f6aef1af52808217f19a84d70a614c479497b61cd958fe6a59b142fc696ff426a00634a091583b6cffcd816c6e8165c07c33c1cd09ff266ab77467fc2058934b661e0f5e5ded9d7d1939ec27908a8e9c69de53b9a8a29ca6d10dec1c1720eeb75751336aee743247fed59ba6a2e68ed078fc6631178894004b711439e301df841229aabb91a5950f8fa3aee7ae6afa4f9a1e8c3781277bac4091e9c623f6a9cdf215ac492b83eb06cf037f21433aa099a678bb0d12c7bdaa87fad9f52e9045cfc73463d3f591a0cada1078d9e4db537fb64186978b6d3f3d4bdc3521354a43a3f27582089a2c543407425f58999cd0824ad03bd8c2752b1623900f9793cbf92ccefe7e679f9b6e93e6be49c9de0812a657fd411c1b8a4b548eb653ce956ee58b6f5a9e4c112613695a03062a9adefb7386b480ae942d62f81411a8ce283b3ffc2296539edd25a4662ada23c5a9ac105f44c36dad46f8c59274481d8b2f71df2cd09d707e02037ff38f488bcfbbf63517c3549e6c66659cb5a15e7aba7473884ec2416f3486ba38b5f51bcc938d27aede037ebec64cafe424807f6064878746aa07abca5e348a04388a86b6f0c35e6f93e81ebb20de6b45b8a0b03a8a6f50d6d7383308bebb845f695172301efa9f4ce59aa6974f1729e1b3ab404e6df829a5603cd117b45fbeeaf9aef07c083a176e3868bcf8a4a99953e5de40d71f94155ec97a78f7876aec0881c34c63a2b5ea7bf59b9aabd864da1c93bd39301ba926077ca12c49613325049dc987f8d13119a7e1a511f99c1ca5365e77514b59f1674c736d1ff97164d230dfb9062c80b0078658bc776528d207e42ac2f86b331fbe07a8b245c979c2535f1faabf5e2a86315a72bfe4e92a446911a4a07e01618341aed70fa4d19ad46ab275b8a34f38f86f5be95de2380548a5006c67293f1d1e7c576a1807dec05861adcda82b0fe6e81af6d012aaf2aa699169441cefd544789266a16906b3b9a0ce69d8131c6922093de42d798d11acda83cdc0ad6b3c91d5ebbd4c02165b418e318d4af2e6245f1354f3edca46f6b891017a3b759d8c9cb904aba06bb6e22aa49d8ba5092f246261b2f0fef6777e425e5f78df3f73d6b12719fd77ded53db42cf5196d66dd932bfb866998ed804754e81fe1e30afa54ec347f383da35747d67592c386cb156e55ded742cb495a73f2ddd404b5c35d267b75b83637b7a7d78561edaee46669a8b6f397ccd3d1d7ee774041ba87f903a186a21c345c9a9ea96e918900a0abeebfc36144d7db8daa57f7a848f7fda7d029610b21e6d6279edbba340c5d91878e426e4acf9343889e99cff5f890fb1e9d13f189c5d838f6905fa1f87593536a8e4b7094daf7516e429834227ea4caebfdad8f10848e7cd80b1b140cd97f4befa75381697b7007b91783c7cbcf96cbd1ffde9d65f8c0f450f03cee21a02c2de53f96485e870b530b17cdf07488dd2e305dda30f76c56dfa26b9e1b2d1ba35d76e58b7e497460bfbc2d314974decdbd7ff50919232569491e956009cc41579cd7a49a3f00758318334c40b2887f2c67b82ff2902749218e26bc50a8b0f6a288db1fb84b56e6d6475b46e1bb7cefee57a1fcd3b884c85163b45a6d3f205a27b9df835856373827c0c815e1da08bd23c5e2acc4c2efdbea4270f9591a5a099266f10737c46f064136434291b2d342e09a24aed71e19d83e565e035a24e308fbf7debd77a1a8173a6594cdb0bde3ea0648bc7bfc9090544e29803c5a2b6c78d69e36719b4d5c6c8d41edba273bb782cc6d31b86e2da02d3d093607f64ef6dae98dcf60487928851e7205b055e4b77f2c51c724c4c27b0df60888e9ca83efebf25363a791b89cb7264b0959455556f4e6ee184bb0847576e08c18a483284393a3bc1e10d6db561459a42d2827af9eb8ffcbdda73e798cd84c5be7aaeff50d19b9b691ccfac7109380c0173beed89b48786ec91fcd4ded4e2faad6d0bd63f3ec8533960a8dcfa4c0a8991742b0959fd56c80919f84369256fc00356a813173c7e01cc17beb5b57e4d7eb74ce991e0b26a2cb790969949af008943b4bec7a34bca578f14aac8df06e9eed34951502c5d410e5a308d1c9dd8acb462c754c697dc6594cab5a486b48ea6d0905dafa92819126025ef164c4297cd80bb1085f24cbbb55ec89e416d5bff65a62c61f5cd61e264d188901eae481bf9826fef26109a54146d8b55ac1c584775894a59d5ee59c278027db99f0680c53fc79d2940f6dab168f667cc775e194b6b2bbec49060863d11371ba3fe67940109d2575d58a31cf4be33d0f41d0df05c9e893ac6387e54dc41d2726173722e9c1908cf23f26ff5a9aeebbf0c58edb0968f01bb7cca0f063d7100ec9525b64e1d944fc60e89c7676d1cf5653e34ffea58e31d91be92b31dba6ad11148b05d4df19eb667b85ff2fc39a8aa87fad12ce9485d6e706998b238b99b4293df43204c98a202ffa0248dc3bf512e5ea1993d9767b379e76ec0d3da95cf96b4aa7dc74e0a9b8f7a0836d5beb98437264c0897bca9ad9f27a7fd8f64df81a7b76048ff213fa7d2272be2dfb6cd7a194c0a0e1e5a16a981232c3238dbc229c8216dc8972967591d7045ef58a5f7fc4994ac63c2f0470e1d65d578c30fb6bd97fc02f263bec0b5a62a20f0a443578db04405c50b1fb99f2aa5f573cda677eea8bb6adacd8b2744889fb40724d8d193c73c95058eb1ba786c467356dcb62221211db849cdc2219b185a82d723e7bf3353deb83a4ef9b636bed2d314fb6eb05c5687cbdb0055123f8eeda36b5ecfc5af43127b8cc009b6a54fa7a4ad0006b7900298842a945dcc3542634a7ca7defa583b6f891cc3d1c7f4f1915bba7b05438182308fe9c56b21084d638a5e2abb80e1812676256e51958579aea8f2d882dc8340520a6f2544ac5bbe79ce7068f280b085a31d1d7afe57ea937f201edd91bc7bfaa859c0bacff4fb48a066d163a1053072e9ab385ca21b8f7a2f041deeaaf90706f4316a04855fbaf201bbf4bc9ff893a21e6146486f29d5b90f12d1be0f289c4039356794d13fc81c6228a434568324add15d8ea8ccd06661d98786ea5dc9460ccb054e030926214d2f63dbb484bf992a01502f1214ece42cdc844738a9ae268b9ce14cd52d50b24e1d08d72d32fb1ab94aa4bc7e159fddf8eb2403fca568d926ac6f215c24636f3ce6f898023ba2a2e81b97a23aee5293a551df8fd396c82a1131ee7f6950772430aa94e9232d32dd6ba1cfd2b126f9d694919389f3168036ab87ab64c287e45cb0353e33937c12c10e2710be9ef601fa209ad070859d5c34a6e4982ec1683539d36e120d4906c609b3e91b90c2c2472e49ab116b92c3505db4dfd95b16ebb828b0e0cedb38ca4c4335a4e8ee60a6fc9e1dc14df1dcb17776ffa0538495c5375ea38d8597790ba40f03e3d77731bacb6a7a8070a17627ad1d4d57c765332eaafb1996c294e10342f1d6aca580a40d4ee23e8660d792f4b49e0cc1bec8c46ecfc1037ab627bf1a45d1404681ebef982352654249114d7f13920dc65b82cb03463abda269a79e3b6c1210abe279d88ba26d0e685d40c7f128808619526db09badcb6d33dc09afa9f13fb2f0c4cabab4f969adcdafc2d062dbb640bc6373f4f93fdd99a8227d337e9c28cf36960152ec42cc38821a8fdf17690f52745b6de6755a5eb21b3d970ddc12b5e8ec155fcf539819605f6fe17727d98d886f633d5c5fd5bb5f4e71df57da10a77a478608d0aea72c6256fc8b964902ecc2cabbd5da11bd73baa19649400da2242cd8ac13d56ea619e75b9c7e75bbaf8adf9d424a8fe9d49d13f252dd2b1ec6aa4c2de462de98acb3a1b7becb87895522c984cf4f0117a11100deae632de028615451bf7c49692ec60595928d36ceb9016daab255d729873cc15404c5a82368bcbc2d6b402f4b7883fb0b7901c1f36ceed149ae361a4d019f3a021da74924c9aed5ffffd4ad42d31b98310f9f17ecfa30ee89bf812cce07d9f388453a139727384930685a5398a02ef8b4931595cb7bd21d019a5737a4736ee997121a6b85e9d40b1c8d714262783ed0f6763c4d32d58364e20b82351a2d33c706cd0c2cb86c1042d2cd8d26fbd5f5b9ca24331ecf35532584d70e90d8de36704961411ae118df04e5caea126e5f34ca1880662d4006dcccaf3a7fe18cf28037ecf7de8c1862ed38722ef4c7b28762d57b3de752185ab0da4dcfb7a6e29f033bf153ec3c102190b8c50bed684151f68314a0e9c3151340f3fcbbed18cb09c8164b039f219faa1a29871e86ef11e027ef04cd5d670b22e5b73f8bdd991d5981748da79e9c80e36896096c4e0e0830b2f2346488acdb83df7d3728372e4805da79ae9079e88cc5f60af1eda898d2501b0c17f8133f1508f3bc5e7613aedd098b0fcd1343deb8a922ffd3012263ef2b2e5ded712a1e1d5bab3d86389ad11124a1d9024d458501b6c462f673db27ad6d703805f2d63c970e8d5a7cc457dc214d716d6bffc9b54edf0bda0edc1cd02503b1c1efb48e86d01d0a6e949a45a3af1c815402b4ec81e0cadeb45cd020a61e54b12814ee525262d2811ee1fbd04c1ca4461cc13473162aa2f4a9c9ced18b2fac3354666f6011d58667b7891baa786121104d3ce10f6f83772f4eb11d266186c2e3f78e01a1fd4c4d3f7a4b9be37baac2903de45117050a83ff5053ac35082fbd271ec99528422269b85c6b3323173a6405d32fe18e99f220e28bebcfa0cc7a221a1207a11162330fad2c4a9bde2ba1bd624f25dc0579deb34c12d551b24501ad0be63962836b4fea8e3752a5b480ea75cc3c67a675aee61707eacf2a4084d430e03156a8bdd4f0a29ded42324a0d569b3c8c0b708625010417e2811bc25ed4d965800b66a8726b027ad66b225be3c0f9d0f930ec4d4ee1b84621a8a8e96431b1a1a15095798fd8d46402aee05bce2ca2e4f56686b975d01731647f423b1693bc13f3b1b137a82b0751d7d261ba1a8979b9874f2d6bd7e99e3c960ed7f4aaaafea07e08e6e5005f5ae9d8d2e0181a423dbb1897b59da78836205c940ec3f1efc62a6f5a6917eb9c7f89f03ef67548ad7317df829219099e466cf7e79d0599f1c50b0da432ff3366ffa7ac9793b8f2a354c1231b1b9cbb930d71cf576a89d88f9deb1161d49f89daa0fb892a17e2c208ec6d7c695244cb1292a42a8bc057523211a20a7e52d5bbdf85c2cadf52d21253aa52f604e1719d6dc518c0de3dac7ab8870bdeab51393af75c6cf1bd2ac4081bafea60293bac03cee241b3dde97014ee82a4223b5aab45435a92e30ae114461d9431893fb4009efbd831ba0e043b2c4f3930ef0bc3127302e722be92f42af9a7f118d142bd93493cf617558fbe0d08619ae6ae16c285f657e7f376d4ec6cbdb8901de9ebd50ea603d4f23c0569465792caea1dce9174a775b40bb0da4029ab7946415cd49c0c630e5a70e7de980021ae550d0db64a60d3b3bdcb3bb6e218eae0cb52722804309f2e41c2d743fee7e63c3efdd92398503bfcbd1350b80078925d07c74063b93bdc2db164807aa61af8869f9ee7f9664dab2ab943e8e6f77cf72780f55640e4493d490ba529d5ac09333ea7f856f2231d3fc08941c2ef9f8c4cea98f47fdcfa521789adcbade053c3d871a76ce1495efcc1117d70522b2638b5521459d2e63d58e803cc22de63b0f4567f92394f3e63600cd6aef5d1ad6ef81a6ad629966f85d9529579c332518621cfcc8bcfbf9bf908c1bb4e3ec4bd21167a251edf3f699387a38f85ff33c162ef624e7b07666a2788a287c4ba39e98aeccdec3fee068a78b911a1cee077b6834771f71ab5ea9fc2a511f8fadd54b2c8455916f46a0055b8ed0757d6c114e9a9ceedd6b13b1984a2897ec40f90df44dfb50bae77c21d67a1e5e669f93fe0ab3120a0ec4904f74ac28d1527f35d28118f2b74dcf486a470a50417754bafa6330b38ba22efc5c13edf7095a71717022f2ab524ca74c259e94b89e9af268da8b68ad2d785876eaeec2617d409ba885d3fe78f5216ae3622c27fd2dac70f6dcce1ae58e83887b39d0885b14cb503fe4aa3189c99046c0d14e066b56dab4d766e2c80cb1b9f76926e67ae864b8767cc97c0a063d7a1e23bdc013adf6282363623175733506d03701405ffd0b2c2ae89562925f305bd262240d06bc69e6ec24ec3a2a0416a403835b5b30905ef4f708a3a06efa1099c0894461ebf0d7212d1467236e916c50585f0a0bdc22916bbe762a208d16a530c4a91691cc6159766a6496894b1e424f73b706fecffa4b1fe52f1a662fdf9cd788766bb369fb764d2822c6c43609314ca34fdad56e0ec40620fd8dda4b159de0a293819e2c5a6e1497fecc9b63a36fcc59f106b3aaae848cdd77afcb23927257c3a45cae5a7019707cf7f9e75b72c205d4824c1974de77b61130f0b0aa20cc5e04874ac5422b3ecf38c4c7fbeb1f51b11d5c4db74829d83a198a8024625912c467fab1f69e72df59be92b9ca043e650510c9104d5a782efcacd926611f14337e9a987b0df22e5115d0c38418187411632f261449f6c6da53ca4ee60c86d87c6a5afb9ccea0450a477da4f5b324ab78b43f405a7d9a1ce56c54768357771dc04ad31ed39d317995f7d18a21f422a077db3a99347add97b68b8691486897912ea5f9c6d80098ddde7b6ec812fd96a28fee1dae0c53dd90ccd720fd45d58398246dfd85697fb4c93319a618800b4d6ac505d89b4762e6eafd475fef1932bd425eeae6ae58d2b5f408f1803d7c29c5e259a493c57c1f366f5faa0df547eb08fd5d2d92287684b48c183ab4b5152309ba63798cd23e159528618e4dac9cfabdac929fc0e82b3b5313e46cd22ad809fc69a40ebb0a2cad91b4dc8cea9bd818891886d73e2dcfb8f1d3a9484c44bd0beeb72b343b65e1cece95128523f08463ca5339ac5d55b0ab0c8dde824b8a946a07c7f73f19783b4a3503c154eca7a47ac6ff1be061cc72e059cebb9092569e98ebd2428f690c213fd4997ddc9281a57e3ac5e18baddb4206384e766b3c255ef51c0b2582e1d147c31a8f01ac8c5541b34b9969847f1e529489acf263e81ed03d46a8946eda315ad5b046b842533c1746349ba968ef6944e64289f728d055ee6b1cbf4034fd033a31e0e7df5a0457170b401043f0c905ea8413cd808c70f55837720b74085be363d3d7cad5d6bdf33ad5b6d0165498a25348b4a8754da6b345b373eb99d98042ffb59ea5c5e4c9490a66e66cf8bb236f574b0f648df352269adbe468b8234f8b900e9a4eb4237e1567291ad10a6f5a3a0cce030ba21db5f3be4a9e23f221e683f2c2bc2ea50416368d625fc7b580ef0a20ac237259a90b8c5ee05a0c7add959e9820d64fa75c79460670b9e8e282a6a022d2b96735d420514407f0063b6551cb479bb909347f24d4327ebb3444354deea51b2aa64818ffb9b865a2a12f38e82b6ec47e71075422dac22a4ac41ff319859f6f6d965614fa5a433af9e201b0a75f6d2889af9a6d3db28635c594b9d39a21c5eec6a6812db6a6a8948c752cdfe77e799b729ab7ef608b148d5bb5533f9adcae322cd80e0137ad736662a7a4b8b11fe8a6c78410651f52d583a556a556841ceba4701482aff760831bed32ee9909da5cef876d6bcfa03c41b4e92a0e12b6254a9aa038907c67f19073eb52992f56d6ce7096a189b3faf941ef745f7aade3538ee65f070f8f61bc885f5d87985a3d7b65d56dfcd84de83f85d61a4850a630c91f01b87eeff6061725404acd2098e3c1e2a7d23edfbf32f35dcb3b73d29419ae0e4db2f1a9536a33db9d6b09dc31de9ac77337f311449c9111290f7e12c11ef1c91af3a3acd1a309cb87f76a453fc69cf2e27cfdda95d6f53a8524ba0378b99eb3bb671a04c76b06e4f00dab879013ca493592fd55435597e1799125008813ad66b419861996137100666e0104a1fcefd2de7b79049a1096285362e91f7a6fa8f740bcececc4b6da68bc6f9226306131244073cb91e77ee6d1ab34d122864bb8c45e465e6cea40e2365915b3fbc5f1351f14ae1cbe0c4c58e86d353b34d81f009fc5f9bbe129bf1e827754bdbdf26014efcb5b3aeeb853833e925f8a9217099f482bd67170d9ce20c47c49ac2d3fc50909c84c1f9342c75a55dcb7beeed1221bc55ee2083c5d8f6994748f0dc7df74d672fed40b8868ff2f10334618f0535cebd5dfd8dfcb34216565fa12ca2aa7f4330f40a75623612f6cc9daf486965f52c39e836c8d44e63e8818ce87adea163f2fd42a43fc79614f761a3816341cf548626af1549a7d2fed01db276d82664f4feb66bd0c959cf42136a2f90b1db04461d327de97f7d2b4951d7fa33f22232f0583debcde9b09be5f5e2636578ddca0722d1312498612e179a80ca3eeb2b5235285731621e600b0498f197d48fac983b5a0fb7670b887125fde65a022471a5d82e400a59608fcda77d34f4cdac51a5e99f2eeb379e4e7ea268897fdd107027c9ba5cb056792c9da6c34e9ff8ad46832494da0ce498ff3c8635e6ae05cdb424edcc743399630642a3663541f9e9f8032a5f9eb395955f6795fd38539b985dba17f2f2956ad480866f0bbc1e83e3d54024c055d727abe979b57874ddca081e4adbadb72fd60a20ef6c25f8b10da07373fdbe8759d294ae89e5835ae3ca4a517db418b9b902acf8af38e2803cc734d4d11a205f614afb02fa342513535567efd70d644c1b8d92068b54cefad7e3efd775a96753bfe86fdb5f1cbe198c055a37b8fccd9f3d42f0ccc4988c3fe3ebe15c4dd084ae31823f330397758f592cdb5a3eb15f35bb97ad963e3eecf071cf0cb81c5f91f4e29751d3f657a092310a2de6d97f19a7cb51879e959fec8da02bab1f34d8abf7f0332f20ca591ebb5dd0e56bb6eb35bb42a03d81d46da33b19381df9cb58fac0c29a6c711fbec7be443486b18cc6a971bc196e9f6243d6d76c76ecd9b69f84120d6c4392c45ff6c281ce9d9034b43316543c80f20c3d2e17d8f4319405cb45e60e1de1d458aa56fe87dbcb47ca0791fde5c4cca41e11e35064dc5fad79cec631cdb1fa07674453cd25074999e861113cf8806b95a2ec43be558af4adfb68543cd9314f2481c9a8f3137534256000c0a92d540b6a7ea522b74760cf5c2b0015b6e5e7072c0bb62d0045bdf332de11773c5b29f8ca83159af3605ae1eec0b638a5455a11ab6e4a88eb7c46f99bee610d64efc66f8f4ad0cc4653d7d20c4ab489f13e8d42bfcd2ce1bc5d17ac2c6afe4ff0f64c799b192c7b147bb3bf4d0f8ce1343e120c62e24de89f58f93bd317013b37ab118c92ad79e790377535e644c75ea438f50ce58a72f66f8a3a171b1d99e1c4f061d5cc28b4bf69ffb18fd5b869d1dcb1bf8fe425e9c27bc7bf9908e985bc04c485ebbbf469af602d5e7b2660d9d942b3c695acdbd196ddb94205fe26dfc93cce8c600e07a71c69294ba3ff51bd4fcd19a0a0f9192d1c87a53bf1293a92841697344454dd456043524e706b660d6af83012e18da6d7c5c11f98336866ecd25710cab6f8a85a3db16e2a0f9c630707fd7f2d16d293681c316d496861d019e38fae772796c59ad2c9e125698bc0244737f36369a7978dd18fd93a3beb877886643d26b8968fe9786df56ee2abb467244e58d0ed6f6476ef777e1cef02b3d00c0776da2c2f944f5d333f15f1b637328e28143e1c567c9f5b83ba2855c261b59a294f40152fa2265104837054b8d481d975a4132acf8145c76c22bcac4efe9a6f9eababe97eefa33d6f459bca0275d2ce4479bba311af5a0c5916bbdc44c8620b1beeeb62b9151b806308617a35d4214335c5a47c684d06dc04b694aab20f482d4d86f58cb7118b83372169b19e17b43828689274eec18e94a2e3df929831debd5dba892c239bf6a8e4bfb267331541c06712e3f76212b420e1d26aa498b5255cdbe4016d43405e7c74505f18167ac09457f56883efc8f2dcf3bacaa102dbbaba7ffd837dfc527b5885ee036cf47bc0c2aa96c6c7f3b3f0d5c6e60339bafa5b85de4f799ad6cfbd4bca44de987a0dee6f7cb1dee381949f05d999308b445f05c96d0d84d905529281ff792be74c0d3005faad1a0f624946c30923040dd52880db02490360011b728a2c7aa495808a8d7a279afb6b93cd5a8720abeeabb21c075078201a6325289cb0c1ce85f6841342498d36b8131bd87999ebcb715070d08e3789a4be2fc5e3a356582fcf489ec789e6fa7940be3ed3be6b7e54503b12f02fd61daa25b0cd3a7b8100c4bd65a529e823b693793459890a73888a9e290ced62248ce8c129f13cc99aeb7994db2ce62e7d4ce821c452ba919689e33568ca24cf35e43067c217762de8c60c67d373f29f826fa6356b7b72220b572e698f3002dc5528cb1a5843757ffe59cf11950139a44406e8d3ff0d6290170c0650862e61c1c655e0d5548748d52de2a9e44e9f72608cfb29e0b6a57c2e3c43dd1f05e2a3f016d3e480bec8465a4739c14d29ebae214ab4cb0c06acb8ffb9faf95cbddd2ad752a9bc8e7fdd75d9161e1b08bf883230efd87a2ccd6ffeaa5f14fea57475bb29b59423d955ea984e45e570817c20702dbb78c1d39e10c46d5944d6c6932eff2bb356cc93e02018badfc2544ea6cd06583fe2cc86868e975c28c1ca7516adbd0f1ba8d4c7cc28dfa75b9f8ed7e24effeb92923a35713e8053840fede35bab89c7b58668317e6bd1a1949ff5a046d12f8bdc881a91514b9da3c27ea86feaa7ed716f66d7676924acd615c851944622cda67cfca4a4e89308e576aa3d3e6638e098a47abce186826f349b705fbd8858a74027250e2f6712814282e4a5e2484ee4237f7d99c1a5609fd1dac9e347ff4778b3c7cab5da8e136f970586fd4602fdd7e79f6b34bc051374279229e6a9e8091d788cd8e87c24417cf3a181513e60130e4403bac35e56478fcd4a657bd6021b507275aaadcde571c1280b4b8ae262dfe7fce164c36a35e49c816bc3a9786423d52091c401d7d8782e9e9fa36c4cee27faf614f5db806ad19f9bb4c669a4328ac27c46fabb1730e10d6b14d9282efda4b602aedbb57d4215ef855c0de5d0f6bbf66a3022689f8e161196d2ac761b00a2ddd6faee0b6e21e89e81fb63379bf9bda1c38ef93a4b1c2a29481b45bbfc0898d60b01b27429cae82ff2a2a8c6dfda15551475d261625c1a285bce53229e3b63229993b0730e7e4d266bf31a52fe962040734cf3279e189269e023d99fd7045c1584bdbfc99490829755e434f3906321e5fcc2c90b7596bfe47e661fef7122b85e0083d7cba1370941a5c1a986db0a1cc597a7b26a1a8a9c16196493cc98fabf5a0362fe64e7893f02e82c9c33cca352f9afbf10ad9c921e3e4d577cfbbe4eb49c2fc9a71ab5e26e5d9218df3c559415a44dba5f65d7c724e9eec0cb2a888ca234754679466fee9c5ea5e15a9e30823b904570faa75865be105d6cdb60dc73c8547f1cdd5028c73b5a662477bbbaac4375dc88072c30198edca3c5e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
