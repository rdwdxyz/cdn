<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75e5ec87c9544911ee450a65282cdefb796f5a4eb6858995047098449074ca756d43c02ef16373db77cb280fc5b6e26cd1f9cb2c064c72911d86393747a3a43de5f42f152b0888eaaa95c7a3938205a27c45af7da090ca7d520286792dc0e0bb65ba246b9cc1b0655f4962aa8db4ab57145463d39a651a27dc1d4c6c20a555525f3b104ebe1b201782cf237799ff1a021ff112c8d641c1d360c11551b42fa4f69a068af10be42b78a296da333e1eccfee43af81c90f69bf307e93fcbc14efbbc1be95d16c75296076b05c5ca85f9ec5992f6b063e6b130bf2764d1a1d7fe1744e74cc9bb1a576aad05b30537dcc999209138808c26b0b7ced5819944fb551b74e6f6bc7156f9061c6de92c1781b0547c9b5ee7a1c1233c6fe0e17b4527f37119d4c41d7468275aef2d6f8a46e3e59e2c20f49ec7a0bf8d360d09cb101508f5d86aac0b02975f54d8832767644849f52c42f4ebe41cd2e944bcf8e51fa2ba2dd03c6a4dfbad18579a572d765445b70e0cb2a8d2bbeeb7899e832d73f2c3ae6edd0b81e5622b1ec92796571c1aa98cf9bc17f182dffa23ac165f37e504abdf7aee39489671ce0df9a3d8fd37dc5ea3efa02e58b681b958fee38da2187a6c36eaa15d1f045c3bb91729d2889fe65e554bdd608808f9f021157bcb20d223376f0a9d5246b6f7868b877c0731bf196b153c2c9888c9bf7231af335f3637c246d91a2f229e66590bd67ce0552ca38e35cfb4595a117ca6353edffe5720350d78e5c570d4a611fee5be2ae40d8a3c168f14f28cbbb83542aaa1ed36cd548369320a3b0dbecf2691e145a6cc3bb82dc0ff5ad938cd0f50af74e941011b02211ddc4300c64f269551a855113fbc448b5f39ac5bdd4c179300e14d44d90ffc6f13b6cff8eb0a5d6776f980b12b61c61c04ae77c9d1531c0db20e481dd005ab3c2d2d8e2f8da68b4e029da4538a0d6ec152e691abf6345e11dc669c2ee7349cf0dea7886bd0c06bf641cdf6efe2fcb49ae14fa8033825fd5ebf0bd3bf831d41cc47ba870f5171b9d8d21ddf6e30745b43cd0723968808def01d67855276e5571887f8fd9725c9aa472dcdd3db4a5131edc5a2792a0db9c74794ba12986b73a782e65675029aece9ea8da1391d9db7ddbe7b2caf7cf4d2517adfc2799931821c0170f901f57e17f9410ae49b143e5a54c0264231e9f0ce49460ca5479ff85e9ce081b213cffbd225d7982ec4613d65216ad7ba5de673cb60c85d8eb4a8ddd250570fbb236f0cbb64fded182ce31c21c8e76cc76a47b86d054ce96d74f16dcf5d4a804f6bedd327b465f7c74eaca2086f4f9ba701a916789eb88097fc1b613c341959109e15b6590d9fe58b54943ecc9fae5e6c7b7f1f4e91fc1b2cab5f6b50a7baf24af870623a5319f76c61ae6bdc0fdf5881d7b145bc43b5509c51c72c62420f6f7b06b50814fbf9232332cb91ea6338d023bffc768af6a62ae26601fe0b178394e11ecb29a226fe1a7420e1db29d372d9e3a558b03bb50cbbc80eb31fc6dcd86e33c1c7ee5be33da8680197a9952eaaa45aa88a3e03a7ad9769aaffa04313f76936e7b84cf73398f6c4f79f9bf3908bcb636542bf8ed45a070a85497a3bbba65704eb6154075b131380899cf93f9bc20c037e29c153dc5d2e1ad2b9fae5baebede979f69f5c904130c61d47a1b2f68c29ff1945efd18d8b404e14c608ca7dbe4833cf7dd94c06a40026f09b4a17fb278f8c76c48197dabcf44cbc47765cc60c62fe8389c0c6bc72beaad69bed39897558db4ae528535f7366ae1d304c270c78f1d952bad9b70bd7a09956e043fe564f264b862260af230193983b84158a764cf8833128bed619bb5b44fba98bdd072a679cb7873949bdf3c409ea37f7f33973f265bad45736e9b5608184dc13c7c7ee6a36e22b8167521f58025042ac7138d50488c3e75822ff77c5d96d6702de78b9ad3bff5f62f11b79f4b471fd21ba39485bffb1d73ca7f405fa9379a4a074d6edf20c3bb716a4bfeb8e3d8bd793f08570bea27b0fdac424250ebb6be8bd02b1bbe93dd4ed34b3138762a44547eed7e090f9ac46b7cd2d25c2b2869196dcc51999ec7afc6244b9704b78254e2e227655d24841b3b06851c1234b05bd198ca0781184305837f1ee182ee145acc21611fc2414a16ab157274fe8c208b6ceb95b712d41619a819eb3f0c9f4562e67b5f7d2dc3857b59737c86c02ec6bd75e77494d99030ed2036837472950e741f0b1374294ab12d0d812245dff04dc28e73b3f712d9100244b28932bce93a2d50ccfeebae6944385347ab947618931f137e33a2506fa879f3a1cc326d7aeaba33499c2148fb2f393838d599356c15b0dd7fa0653ed4321bb86dcf91040429a31df1f1c9f7bdd1487b4ded4c47e3ec066974ed659ffc6819349f2f9b6c9d2bca59c49ebfd5f62376d979e3196e1eeebac56fdf86aea003496ea1c15751211653acc35a3060737da7af2a46397db61502127d53632a151920046585212f4ae1a36546e8197b52553b99814a661b357fad43d929b6bbb6578a03d3d8d33a5bb6a54d2a9d83e17f5ef6e5994caa66abb675aa1c9155e053e0042b4f60cb3e3d7f33fe249c0eb948f43c5b94bf224a09ab751f974bcc8f2fe6a055a34179313c3bf723dead02b76dc9f9f443e73935b2383ac2c1dbc1e4aad6f067dc86b3c4efc94b836632fd2d9f7593cafd2daf96fd2b92f3ed011b69b138e7980f1e52fd21a5ec7892efe1774d85fd836f8295b5495e4ade2b92a61bcc9a33d44099c3a8a355dd6e0bb2fb9e6ba2dcb71ff97835f6a3cb743e564f735612c532f7b4e438393f248b6fb51353658d3c7f5f5262a387e482d27eb14e74de2ddbd67a41bbba45635a6511e7ecc6f26e9efa999fe770eea103f66e9a95568a39c9993e49193e631a55c15bc0c3a348c6ac1d818bcc868967e83f1ce5e1eb455646b14a8487cebcf3e703cbe492b9acfe9cbfa31de42fce2b9fbffa78c0c19f00b737b84a3940337f8305de4eb8826aaa917f3b490f571190ed475836a8bbaeec5b175fd3e01e2ae3812749964203b0f2e0ad084811f0b9ce1132d4f5da8d831613930cda32f652334360c557a8c0a9878fd2751f6e85616624a3845ac507bf7006d6cc3328389333547c6082d16cc3ce0aa97d72439c8670c7d7ae229e409814d3e3b90711acededd0369b1256f6a60c3ee9d9dc4249d3ce798c83b1a1828f07a92f38ca55002cc52c591a8aeebb40a779137cccb9970bb8a2db65f0ee555f556065b806ccb50eae0c814358668a87ca1fe1922045549c5780f96585f779ee5eaee4fcc28bb85853b1bbd470cf8671d6f4a51930e4f797704caeeeb0deecbee94fef933c693d399c95faa2934ed2ad4b532ebfe6875c28b101b234fbdb64f542fb50deb2eea5ddb50f9721613a33b3256487eef5605e7371ae808aee3867d78d598d6061f30bf2d0a65bb0419221dfb8ed97f29732326b7a6eb827d1a9ef3b53dbf7825209a757f4772f7ff32cc7c64fca2e08fe84b42b68d889ff54d4b999dd07ab46aa3cbd08aaf5c459894301153881d556911a8ff2094b7a0b8aee63852edd2cb2f9530f80fc9e5ebdf031385d37c9f3a53f48e8330b4097b854ba0e79aa739f1096280344e7b6611f5562f04a07d2533610e26158a6f1ac59fdbf2778ac1358811745a114fb4a2f2e1321e26f2db2d69b41a3aed6c6b7ec0656dcd7ecde27f32e4acd51dab9935676e7f0849d87f8f17c25e538811e79d6688684d8e28b9383c001cf64274f8ca6ad26272499e04301a772ce70bf376c16dbfa81211459b80221e7509d24e12d6b667f3513088e326d68f4ad5916ad1cdaefe9b82a0dcf3d69d1213d4e58a277f08423503263fdfb4bd818ba874c7ad59fb5aaecd65ed080d40db425dc05472a59e14acb0f7e59ea2b44f38dcc8da3e8b87c1dc1fbf8b7aee638094964b9b5e848d9ab562887f4a610acbdc94a370c2ef5182487625995b7f2bb572a4db25f979f4241f4b903fd5a90fed7ac96a2b6dc18bdc28bd6117c60ff8ba73ae3e0c4d65fc7164f056269e612c4ff639a3490873575be70008d897b69e4257d1303024d41ae8f9fe008b5396ce28aadd450416bd2ad90604e941c1407490f5aa0f5e0099be88c755f5b18a458beca22e571ab22f72149f56fed1a7c8553a7d50dedf2cf9b8277ecfe222cb0aace563f700cbca596d256ec1a0186c6fb9443cb9fc631654c09084e38e670ae1ba979c12fbbad85a03ba95ea0fa05e8b10aa46baa2b9fdc98d014e49a4833ce53b5cc0daf9c0d4f86624d8d8998021f89258210ebdfd468ca55ac8b244f6e5d8795269d279ef5a50bbb65de7a8c6b3c71ad4305261295a6ce7ed86d8b323786e70ab8c653af39eec9d88906015d87e2a9dc4bcc05149099605203b282b771aca577329296382fc84428d5d88c3daaefd0f970873ad3c5c56b9a0d6fac369b6d437f59f0e04a2973cd9f23c2e8465b6ff4e3a385ebd80828acdd846d10c3ebb090ab53076c2d98477355dcf394f92e46953df103aefcc3451e940e9e3181cf4a642976ca737e2cbaf9edee8cd80cf835f74800329ffb34a3c2c898b29696b66f7beea0f56fe3d778e421ec4b5a8ce5714e29eeb9678cfaca5c76b3663dc257bfb4b2de36c1fd41ea2fc2f282f703e55f8f1f2a93d2b011a9ad67bfb132c17a377e1f8df1bde4a21929ebb0c7cbc9649d70e8b1922c2162c0aefbb87bb6861e207bdb3f30f0f1f778d37ffd24ed671be74fa80b5ae0b4bdd5085232beb97b539bc314aad49164e25f7d81e4238ffec8603846afebe0b62c28479bf6e36d648402f4bb0e644aa087c65aff5efa1e1c181671a91f34d9860ca72c70b96f01bebf254c5236b2f15d921d5e0cb9f77090f20f271fa7d9cc0e870170298c2cf1349c1393552999376005cac083d1e95057795451bf76a2e2fedd91ae7a4bf298f9b796cf180006c6a0f49ffb4067f1af178cb7be981548d00a6b1095ab3bdc34d069a71be47a61236143cb5e64a8f8c59b085f375e34df1b05e644bf062f28a849eeeaf31af1fd1f42f5904288d119c7a05f165653a90d74d067280a1db85242d28f5e206ecfed8613911bd6dd51c8c599f49fdf7673f9b41096d44e1f7b1ab3b9cfa76502273e8d2f09ee549b82d3b03420adbe3c1a6d53451bcae417fef0f69002bdfdcc8d10575f9f2634590ac2175861e84ba6f2f7000e62153105f82156aa83a87157ff5d288d93646d08faf972c85c856a182d95a6b0707cce592e2a8ccc2a896939094ec316c202fd03ffcf19946248c621ddea38bd64cc697bd391bfd07fa9d9652c503b5d7d9839d74e4a37fb750567579b390eb8860e6647f8d38866f847b2ec43d5d9fd7b416b9f6a7674b496a4b617044ff4c514f74d60bba8e238a7603990490e8466f8fea6f97cd95cc9eeaaaee526a4f191f767a9fa3ea722669a6ee746f9c54dc78f3b3fad5adf105e247ed725303c11a0ade1d7272fcd2813e5822b29db0ba29b8a86ada5d6098e07062788792299460cf32e856e7f3f45dbd61ad82769335f6eee8ee137794461d91c511b365c3762e20147682c5312ec466a85189252193f523a88217a6be22c53f02f8960190e798d86c7d60310aa08a5001c8657ee623586de6f3bee30eec06f2cedeb95f702a0eb188f239579e6b0c1a27dee7a9678f662a9e242c3179225037cefe6bb31853991b8590603e539b010f7222e83f7a072a61e056d2811ad47ffb5f7673173e510201e20ad1f86ed21e335b6a4c7e355251380e4d702bed34bd0783257a5191af99b8f54eecf7a9eb566599b76a9e7b84e9f75a91917f82eda08a122f8c3fad8b3a2acbfd1bd7a61dfc35ca9384171355f2d71fd0174ee04f9451b053fff0bb10c14854e5216d9ece8255ddfd17cc05514e75f15fc90a56010f8d7db9471ccd31501cc3e3a1a59561b3fdb6ec6a69a1dc5cba34554afcc820b8340bb5e3c074c6681a8a8d86c450713980319acbdd32c17f071bcbc92e2e8ed447f198520b201b1900887dc56a65e856a6197f8c8c597236efddee4f941714bd8083b7dddefeeb3184c3c42b3dd84d75d13dccee704a9e49470112392fc471fe36a3ae4a12c1ed4cee1bbac11ae5014bb34d17e956043a3f35328f73169c392e2cc5be8cce6042c50fefae7ed4da6eae5a160d8d63857b06100af32b64e0a0cd4a1f1c41875fea1bc08e1479d13c44cda3571a1ceace9e02f002acd79953a2a90d7dc81448c51f8ba68bd1f7f7297c5e8024520c7a815d0f5bf77faf6e22cb75eb4af475cb191975da85e1872b356f354fa5f5954d77aa78738fa6fa82fff01248fedb6b7b507f3a6b657d53347ee7bd02fdc6a3bac170f3ea4f20417c07d9505bf9eceef406c5e7d19fd7380510ef4092cf94b66b9804ec32ad180845af889c75424838a343ffee7c3f1be61a664d5fdaef6cf8a07fcc328d6d8056069c6fc3c132c8289ceb70da3e25108f78fca05bb81a22159eff0eb5a6f3aa4ef1ebdec6b030308dba055232eb3c764a4b204876036d1e20dd85b5da237dca0ee38c0853d460d4140bdf5d4a36bb29abd7878088ffab297c65e4edc3c508d7f083e96c53395afb3fdc6083484a63901012a6c143f441925708bc565f65339f0221083d32d265333343d908d8f79ec4b065df3ed877bf19da4c7edf68bacbc9e2a7c6d7e00b12cd61d66cf4d469e77960aa3cd4648e95f86bedeab3a12e6e4b6d60813ea847af6d45d2f725e977c53714c559f3d483c9375e46261b631b1c7b7442ae2dedd933eebe49e83c06fe280b56cc5ea60479b3b44bdd65cc242567157325749719689e08cadf1de2e0f7e6cc8925358e66d00b4473d10e2b2a648961eb8d91dc3e55583a44b4b029c68aa46776d7ad9d92cbfc0aeb30707d77fd4ba07440cc1fec62b0fa9b19d355f84d4d11d4760dc0270289af0fcaca5b074f49991724f424b4f8c44cecd0d19a80b3a0cc6e654c6a6e552d9e74438c85e7967d4c5fe696a43e5cffe05ccc16f0cecab911d458139e80167c98e5116844561d1a45f672fd925bda9ee00c89ab1fb25e3603e1c3e36444bc619c7443cfc5071f14a7f11eb6a00abc50e34f1ad0b0ef122a7f606e34b3fa992c9220f96bf65509db4c693c2068ed884f196cf65c21a65b48eb9e98e18a8f3febe0b0b08a1241131729e850b7bdb1cda83e788638af338e8248747eef5b1e4dd331550c0619a074de885d2feb85dab70175e0ad16bbdd1d30366760e6f5a6e3ac2a348f2980836da02124ad8f0618c0d265b30921535632d53cff468cd427aa884a458f12ea81ea7a5a246e316f6d6f164385bee82971f7675a6a63d651befa9586e234420197742112ba6524294509c3380a2c18138a45f06b7d544cea6a2b81a8631d4f206350cb5cbc13d21251f9264856b701601fd2f4212d6b711f1dcf774cdbae07062b50528241883047fdcd03f5334cbd47c365a285affa308d9f29de1d08a23ffc449e926e0fc7c0fb49eed7f7299dd9e659583882b027a0c5b5565d9f58d2b7f36a14455e2ae6f0755d873cc895576b1e85d50b6a4d64fba4283e7e477d49138e062090898839a61cde802fc181ec55ecec987fdb6e60e82b462fdee31abcfbc9ec0754a396835eb67c4f4fc005fd89f309dfe65ed4b3dd506b9fc9978d4a01d582ba45ea790e9b4da80e94bbdb88f58d4984c031fe6354576f03dbba2a8a435121ad9de5a1d02eca5ec48c62be1e8f005bad37e122f96a1e6dafe2ac5ce9b91bafb54dd4af918b39806cc256e971bd741e1841cd177bb3ed673cd3e5622fd12306861bead09bf227ab7ad92744a89a50cff63c3f70a9b36158c1bab2fbdd614c221825d2fb09f9769a92183754e82be3ac1d8d4db4601e984a72dda7f1bb3cba5497c2b72b6e0e04896fb305bf093ce11ae6b79fca726f8892453c4a2869147a46f948ce145f3b7229555f105fb0d0f9ec73be8259d818611ce3de3f6b68b98a35618a29507e411c304590bc06e191ae6e6e3df1e93967be87db8f503bb505bd42007ecce1e1da42619bb00254deeb1ab3b8e1a40f593aac6b0a695d40b83b2da784f5f65c566059a43feda2ad5b4a7ed94ae635bdf00be236d35309c480f78d9096701414f62add1e82f0455375829b51592ad1e5ab52ed376410ee54a87b4cb4b21dcfb967fab2b86203bc4bf47c0887a835013a6564239f210bf5c396503b1b91c1bc7108313c0c672c12d2382426b47b5f9864605939c5a9c86f5a5977886b39c1789ad7dc9ada882583245d4e9c2645a765278b195c58851f2375cab77d1b577b23155c45ef7af427cbd6f2a79d481c30d64bda99a5862437bca039fa60818853982fbc0905702e7eb413661ddd70d5c3fb3d405274ed6cd0dbb612256825d5719df5d51b0758e078aba8cfbc63b499a0af320c5cfca36a6a997f2e4ad25e4608a11c663a28665def01587df49a4fadca60455ac2500dd55699aeba5b2eaf0d3cf07984e2edc9a724855c663ca1881ba5fd96a778628ff63e620e844caef2bb3c843cd2ad6ce7a715dcd281c8c8ceb647d4ab99629c4574bec2920166501daf177533a4b5628d2fd01b478209d445c24c728f5383433e76605b1eef0027cc1cc15ea213e029b62b76607c3579e4c54322626357186e8228c4434027084b7edfc595d8b17542676db83e9b3c79dc8ad110d648244c30123b599b5fa9a2bb577ed02031e55d2a6141b325cf3c9d2ad1187ec6cdbaed3e38906ec8993c0cd71f37147a9d550d51e8d6b35b8c8efbb1fd4b6b8412b853a7824cc8ce8fe3d685a4cbf3de88b08e2674b7f7e16e3eacb3d9f3869c051bc4c4ce333483b79086cd15808552467b7e8b6f8fff36bb780ce2e3959f3ba70474a459732662c05d71fa746f4afe415a0d8471589d6e82fb64d93a58eaa22bbded4e28e1f1640d61487055df7a5f62e1c6710cb2fea415262f067003b341af97b407890fdf4398ddf3a8e17d433b032b4ce3c918d20372b156e53328c51b2db621ca3ee056084980ddded53934b46f246a33b190a25c06fd070365c879dc13576dae91e79d13af5c3b94430c4df487bbc51df7274998a1c5dfb0df34eada53506d2a4d0f3658342a35867a83464a0648b73a7e95d058be4ef96e66889eb23d4c3f1b1f59852f2b476d73593daab94b85287ccaad7c89cd82f7f24ac65f1a4ddb595339767c46088cc7b8c24705cb8e633665f183479766fea17834d9b24c0cb74f6649f1bb0a8785d96e0a75b1e84a5c10bb69a4fc9c663a74d832dc7643a13b479199ec8d2e69ee3d3edd5d39d10c73aa359d925bcb7a968b7bdc8df9416cf88421791897cff2b2330afeeadde7200a093ec30d3093488bcb078b6d7d816be8a2268ec46c05ef562bfae9d8e77789ab47e155df2f132cd472b5525a74b1d5aca18045b5c8dac5e01058b2ebcf738e1ae35baeaa5cec25527e1a7c881dd1a678260181dc09ebc7b96c4e9bba6a69090e92b4c6a35c0ca4987c84d0feebf9d345cca736884473a4458843d7b7f0d74f25618b0032e059c915f86d9947c068a333aff5cdabaa6ccf9f91684a52f7dadcb3273c8eaef5fc490a7b30192649cf96a2d6d29c983b43bf03dc6e9e82fba21f8d90b86d27f5bfe03464afd3cac31f6a0f5320aa19ca18040c33b470a25150ccf66e587cc613ea4de7a50d69903db5298751fae27b1f2076e5aeb478e67b210b606fe60f890212d6ae0e7ec635a6569f88631e57d53901c1c95be4407a018e3aefb1a4a13c9ef655bd267e2a4dd166d172a10bc5dd4a93dc496f520786f56d93ac76b226c2abe8ac4d1567983d38d611d5a776c5280b03ec43fe6e40696d577ffc4e84fae49c751912cd27f89a792f1e49b6a9c6f7e12c149fd152bc929c7f01fe98123aa1e952582836b23361cbfbb6db901e9886a938add847ceb2b0a9570072462804670a348a2ac1ffe39587aa90b0a5bac8c611cda7f9cdbcac8b4789dd8e7837f1f64918898d83b08c7949f24adb8b133a7cb826c3eeffcd41e15abd056e6c65437e950bf33a8e2d7cf7e40a0f9451d15d117923603cebf7043542b3ebde284f4f72404214bc2758b036419d08b0983a9add87e5b696ca02cc99bdea47d6b016c0bdcd284a886eec68e144cb5c2fbd7a5a875897953220625138d3bd08671f3266aa3d85526d21f546cd23111a9eecc2b27d2b35c537ce22b7143557ac6dd2bb6f5440da05237af7699074d0724f0ee1dc8002262f544a2f89cc93e289b713bdc75395d59a8ec7b20f441507b829c7183a57fb032646290315ce93503376235eedf9015b03d09b26e5015ac960f80ec2581b822935371b7e953faf1ddb4becc588cd1d5a58459c382e9f38a3dc6562b1063e635c86dc297744e3ab22797580e330e2bff27fc362bd5dd48edd5700dde9069c70f11fb6f889fea4c1b2d290792a439e37599c14efbb3ff2fa2902a2078a27df8eab4c4572e51719a9042782c61cd1420a17f40e5fff117e6bfaaa246aadd1168f2f55a1d1d294f678177644689ac4bb090528032c077e58a196d8821c96a332ec05ba116d12ff748b889b06868fafc08a653f00584f3ff7b963ea6b2dcd128ae5842aec06be58455e098f316f76715cc20a2a380f10ca475c2ab0dd0a3898803241f54d410e0189b505b402b88892dee3a29f27982cbd870538982726b852665977256d62be2fd2a002bf99dddf709efedf590f517abd9d7c808d682f40d14c365218054a13450ebc3b08ea43bb0268e310fc4cd1ac2985e7c791d85a8a221e489852ae8fd2285af25aa006aa5ebf8faeb7e14a3dc0e5be8dc3641082f486b6c48649d2282c639b49e7cb033297549947c0ad509d55ae95a24de865f3c34ce20c17db3331b214a192581db76e762c5b9dbc184d13a7a2838b53f4099cd0fc9c55496e71bae0d14376e0219df5dac14bb73c08195a06da1939e964c9b6b7aed3afcafba3b87429ae944329c8fa0bbbd33da4b826fc753bec7d282a4c9753cccc9e5bb4df48db87a1182765cc726de5175b8448c7327bec2ed865a3b6695d90927e541a5e2ac3ae8f35fe7cd7fc80773b13ddfe9e7287149a6987fc0481ab8e78d4e533a5cff5627a067c17f6145926ded95423309c3dde01728408513b2bb6eda37d444778f8335ed90f9409bdb6eb565a81509fbf6922ce4cf6a050d5a2a92499778f9704900e1c098d7f2a27ef8d3811e13aebaf7ee3e4de0207eddefa6a533b23b4da29b324c725f3bb30063cf849e67b923ffd67de995c95554d326277ff2d9f96c0b87874673f09dee2092576252ceaaeb194a96328e856ccd57927887f068a3550006d9d901ed9129fe7f9e14b964cdc128df96cede737c9fddf27a1c78438231abf4fe4919fdf0d52759449fe7f2337218bde062392ce20b40403f63c499d628ab3b53e6407b7bed04219b342570e05856eebb282c088ad298c433b35d56c17693218aa12f167ef328b245e78e71afd4bb5a2f20474e5d5d44d0029da42eecd7207a19274230be89f1895f203dc00cb8b066a9d479d36a6f83cca30ed17202cc2060a891616da9f2ceac6ea8cef910e70c874819e4579626893d831a3460044df5b264ccde8cd3105c8d068a142b62a6c99088d3ffcdbef495a1efdcbd3b99637a8b6ecfe39123341527bcd09daaf6bd495ea7d832db2735a4c4dc78511edaf5149704113368e1e1d0d5fb21cceaa289e7dcf867321d7ebc986336dff0d7ff9a570f0f08a9bff8bc644b5cec69c62416f9988487c85af78197c5f4f7be172af1edc300db4fefd8662a9d1f34e4cc7a450829ed006466734f629ace2a40a26462c1d9be0d11399f885f954032f1dc1dcc9d4e9f9301e8fe4ae123f5e3b3006bf757e51970bab4f80e079fff7c4e5d13f61752cc9cfaff033e8e9ef9575baf4c39bc05076908f3482e8b0ffc82d06818d3472f97e34659de55691003314132fcce3f0aac9c3b0f2abdb2bc8e9db9eddd9c3f09f44e7f0232b02d239d5d06120e7216071e8c341f3004a061c9c2b717052aeec9384ba707ca156dbd77ccf69055f0bada4c3331b0ff0b6a33c06fcac217b06a2bba7ff60994c683e6409b33b01cea60a4adbe94d6d11193e8e22d55008da4b7d8a863dab5f81284b04b325af4365f2cbb99b86ea228edc31f3da7ea2a78b59be86391b3036f4c055325e40f1c1416c3ed8811b71962631c3c7d91fe79289999f88fc820f0afba91e3195609fcf9ec58d663d47a27e5da5b021a84c3aa350cff7b0b1f01cc31b51cd246fb895572ee5b87079dedb474da7f163ebbdf2c246f0b4277525643a72b198ec75ecb3bc39e90a871cc0b8857d501e16fdef55e8cc5683e6451961bd962b733a4ea80532bf0b634398e5e5fd9260d3b4bdbbf5d9e2f0bdbbf05bc025a6397d145d3fca4ce2ee88c60a11ce80a1454eca960b85e165f6c5f4a9f8fc185b8495d58c7e7ed429de6f4d72aa8b92b7f8840e4f1157d1f7d6cdf97d0f091ac7084bb4566fdf624df0fba19172c8f53433211e90d756d5d332741fee21a44ead869dd51767180a344ebe41676523d154f4c7e893ef78a172351b35c7151a1f9e31199c23d915ccbefd751c246385fa49d797da82ccae9b9a4fbf4d29846869d129a8f69c512c126b9019497b964fbe8747baabd3c3b7a6544ad242f41e9cde7519aff81ba0108c340a277add2cfc2366f43896b66352ed8380d7d8500729b91e8dfb760238d973ff45f7fe013e3ec5ec7695c584e56f52f8a1906b6e21ad67a51ea6b4f6edea42251e414eb008ad8c1210b5d630f7da4e9d0b74c41c61acc612a14979c6b0ca4adfb59da2211ef7952096e29c3c468f68f6b01668558b97685315dc80b163069355edd0a13c084ee6b879f8be892e15e9f15b1abc8ae92d067458ce3e68422743971bb5213932ad2040bb249a6ec87978c9e08a744f50200e2814b76e938a3cf1d079de725988dcc356aac86b4f47816b48070fe7aac5be86d5d29571b2d392ac859f21765ad48ca3055eac72a47fc743605bcfd213731e44c1c8bae5fac8deb971ec215552cd8068b4aea25ae5eec4a3c6dc5e5e2e3a997ce0cde83bb298f1085d40d5a8ea9a206f0944de75fa9a73d677e2a9700ff864f3b1df49e0acf8aeafe236c15bd39c1c1466f688ff1a2f6133a00cc7433184c82e7d1c202828282c68eedd96da1dc4678744f31aaedc642c87275b33f620ba29c8fecb65657ec24b754d556b517ecd93b4d4a30a5e955ac7d88a7b4b2070aaf20719023dc78a897c8c82de3267de08f0ec674c13f690c1f3ae6c8d03caa2b3c4634f6647f3f98194426b8939a9c34a3d249b5558f52df34fb4c37b60c682d2a5d6e9f54d75b319f00c2fbe21d82630cb916fe3911a6def285300baa1eb62223545f1492dea0aaa8149544b9c9ade882595d83d0faa77682f164b350890430b0654feea206d1561f407603ca794f9ffbe9a9c978a46f5e73fc62de71ea17426296e1901af5725713c49ec14578b6b4408359c2bb340e075478bee9c51544ec9e0b091be4cb804b3f8920a06cbf6b432d43e7b3b371450262ad22f04daf645983e2f95c48365edb5395a63557426e6740d8c86c88889c56553bd35b30a2043280a483cd293ec6814593d2b6b476aaed24862c6c1523b50e31f8d9c01b3e332c71b8c7b683c11ee17f247eb4f7c5d7c50d456c1eb91be9b1c94a50f6d44f7aecf0133ce3259f0a92ba26f342b6b3f7e2fbe602a47d59096f2bff4964f392bdbf9518bf43833425a09f08b30072013e57fe0c651893aa6391758e1f091216c2b0ed464966fe29a76b08df23046fda29be2f163d696d8f8a0b495911dc4c0dd9aabee61deb7434b568f4d10633faf21ee07023874cbcacc3c2d2877737dc9289023864e61233f735f16c90ae527b7d0ab7dbe79c049ad4acccbd22b0c5b7418b255932e928883d3fe1dcf25852c83aa1d831c1f10073d4c2dec41c9ca4d84dbb52564c42795578d19133c10fa79e70e595d628a16a999b30ca7a02b16f8ef2377b459196e419f0f6e4349f3c95473e4da9da3cc5993566ed811b60a8a3fa09d351ea8f8139fa77549f16c94eed5ec7a456047ecc2bc4128419ab4cdc9371cfcedc59c7d482b383bac2f4dbdf1c888ab1cf844a74de55f70c6202ae0dad1bcd130f2c7c0e233afc052d41be4fe453e944a23dc57d34ad8561068ce00999e4cc3a39586847d355120dc8bf74284d6a71004917f14c503662af055f52abf174f6bbe702d273303582b1eec726a2014b3c8ff12feab2276bb996b69e56be146d6fda9c5aac15244f2e292e90091b18712433ba9edaac4449717a4246b2fcfe671d78b6cafdf5ea450f73fcc1e1efcdc5d8542fa3a0d0905c11b31fc6842b83fd13fac658cf2ede3ec59444ef66680eff7a7a4c52982d296812a8ba994f0c76073f269206107e7b2625d605b9252ad9d22693f250360e4036aa67f3b9203d2d430f17b2d37c06d9e9d27fd74e2a4561918d8d94b09515616216a7593fd831c456f7cb74d293805338b744ad97d8e3ca2c864aba468832f3f3514026e438539e89c12178f45fd7427b6ae114b3d3bae1f99193c4948ef46a0f0911a4b53a29daf3e890feb82330bf9a1f6ec68403acac9142030fa3bcbba03da9a7a9c3ac40128db7a543d57e75fa7894fa4339404d375062385b13a5d3b248fa13fd7067e9582b59f0537157645867d1db1ca09f6da3cb4996174736bfa79d79f3814d584c398ed842e5cbeef89c306537bfdfc77e1599137705d1f79f6310a2f66efc60c840e3ccae1fe5bb9d93b2b7f9b60bd83efef9bffda94be3bd1cb14f9b8a2c95732c6adc62acf4d3fe0ac5745e57376628b729d7ddce2117da5f7a9552ae0b9cce4020183cf07413ca50bf0e559e75745b587ba1fb7100dbc7669a151c8a8f3343138f20080a0cecb716338f5af0344badbd6d5db2b833054fc0dea8f696598a5092b0eca74b20f4d60970c3ca3a3cf076b18c9c48fb952a82a4d07fe74cb55a02a3e4dd63fd6019e72960779600ecd5081e6e5fa729650ebe4f8f557c1bacb959596","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
