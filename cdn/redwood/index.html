<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87876d78f5acf2ab98dcc0ed3e0fec46a8d06d2bd8a621c28f64e91c18100407424db24d6f7fecbeaa2b7049b5bed336c234831f76c192714afc61f1bd6f6c13a70f6f7e0557228f46aa7ea430d8b276dc6addd2c112ad6d20fe1b491b04af6c50c87bf874b7de1326aeffe76543ac3561a43848c5c69aedc0df04edb926e26fe3de91bd5824347372078c47830bdd12c9c4ec6c972172adfcf62fc2cfd762deefbda0189fb72a5ffdeeff3f6233386c4181b8ed2b548ecd43eada36e2511a5833d25edd3f2ebbf95fbd7f63b19065c0d345f6388426c1964276d0f5ef51b6d45b45d018397db0b3281b2b8b8ba41c34f0bb1be089e8bfe9fbc98483d47dee707eb1d345d5e7fdfd6d605dd8cfec467c6798c6576e91fc3d88d5b6b0b6175f42364278c647ef98409997d9d673cedb74130103ca97b3973470043e69a586cde7e959319ab3d7bf9e70a7ee94687bb496ebccc2351946eddddbc62832b865f3aded0077964f52c60445db416b72db3566a3a245c7606e82e1bf9ba9dc9bfd4ab2e242b18061254442a387dfda596a581387751f58a3be2a7746306418ebf8f0c0f93666856bf1a6fe945468cccba6858f29eff60830e132ded90102aba745586d640c78bdc3fd0d5fe3f4a5c7e4d106ae325348e6b83f4f018bfc4b21a9871bc647420c265c60b8578d1b3766b86113dda364040faffded825467fdb16414d69ceaad2f025178478eefacf962ca4f7c4802d639dae09e1a9e97d33eabea427d3739e33d805e724ceb39f943907e55a808bf7e00858aff5ad262ae41253bf373120bb9be6e989ee0af4d315894a55e41932c7ada8d17066fd741e35944f3e3c21af1ceff658f03fd6589b0e802a5808126051a4e62bbcce96cc8283bc0706c9c9b27105049272479cd5a38c8db7b55e95df8dbbd5c943f8738f3fca11516700d8d4a4a259c7c27a797e3763f7dbeec4c795b8c573e27882fca531d80af6798d8e2cad4c86820d20e4a9548e84455400a46abb8a8a7246f351fde5732a9711083b534f1e3c1dd1050825bff7069e40b2f02b809377fc8751908e8129e5bcdaa7b04e9cbe242db26cf2f24f10220f90f8ca2730309fcfe3a524465107759c7d79c0d5ee4fa144d9df7ecc2e65fd8e27d82f69c2bc5c1543b4e1285ccf550d30da6fd41055173fc02620348756e8cdf9d371927d0f2e6362b53fd28b9cf850c2173f5e9c6874be3fb38ec30d538619e19117dd2c7d0a47983611017aa47318c965889dc211385d7fae5d0e6e038e6e6d87d9fd734cb1a58276c9eff1e52cf90d76630d381ebbde9f74868bc80a8422f0faf1f2d52c844092cd64261540c28d8f489e814f95d5ece3e6b556c84307b850d5d16a0da3735264abb65faf5ac1dc2ec766af5c265e79e19fd8693ce10c7423d60fac30c355ef28176ea84ed68e5c3f11b1b82d5dc08cc3d81618e8e6cfc8e5bba5da7e18214403b8b76d1045b0ccbe4e8539fb4ff5327eb13280dde6018f0cf7a7fa68335537874584dbd2d14631551b738ba0eda2f9f1841ff322a92565cc1cc375c630b9dacf2855aa1268d945e6634f626aba05137392fade6919c4338708642d208ae5f323088a5b918bdfa6fc309585adbd404c2a023787cc9f93776c665744c3d1bf6a0c381011d0c808f02a0dbc93fff028e1e51135a934b5b72d634c74bb31731e6869233412c09c751b1cba952c49fbce422e609d204fa1fa1bf881aba154491217bf383746d0e0f9f54bf1b4bee75518a032289179027dd9959698d1b70f6bd1592ec84fbc67df8f1001ea1c525bc88bfe39cc0f6b1daf836b840db6589143938d0a3bc74888e156446ee7c975df85cd9df28caa83fb18533cb8d809d68f23a52f5fa5939ab165f66aa009ace7db679d17a657c872a468a63b45b0c5c80d9136df6370db16c96d15c6fa91a148e0fbb81ef582cd470c134f1e75d56eba06f6ef8d3ae7565444d1b4d719d0b6a028fd404636482a92cfdd197a01bc8c9c9e3098ebd61b815362f03d6f819d19ac49bf55b44cea8a2e4416a1611067efcd1864d7bbf78bd2b4273111123714b5fe6548a9ba55a209262009e36c469372567032fe7dc766a2e2a710d2a044fa1517967b8dcc249901e6c8730b376301d823657e330043ea2bd243596df7f0502edc93c6de2e928a9bf3fa27e5f6d56ba0f5cbda795e9f46746d60e5a257ed1cd5007838d9cbca52cd83b910f092d29fd6a829e5c4f32848a8523b4a9384c75eacf0562ca0fc0822854c50097a8392bbf44bc230946ee301dfb0f183029e5802d2b9170f22b93b68182c50ced93b8fe73d78ed7ad86c7f2d379a7b00efc0ea55f69f3f1216c1b5bd639e122e9f1a0f3e6abe35fd6a90bd4714147d3001547b580460c068503fb0bd44cc576870bee125cf551591e8865af9000628e2c02edcdbd61e653978b09a04a55c3086da38b0e3f7747e740d9b142c4bbcaec3078ce5c6f00cd6b71256a47c8fcd7e8ba6b34f6fbe750632815bf4214b8fecec84aba965987a6f60bfbc9043a8fc62b8c882e85ca84136365af018ccd003c0e71d0d46c66ab3243ad921c23ec53824c307bc9d01f197c6fff673afd35ebadf0199ec375f4e986de943ad329be6b4055ff45fd656ec989a6de2413b7dab58254eebe8d292a4c1e8c4c60aaa6b2e662f14f4c9746cdb291488a1b11fe7bca0b5df88aa3fc45fa12071b047716b49573335f82ba4df4e62c416c1db0519add1fd1faaad28c99e58fed0e8f48e47437ccb0a9a457d509ff641cc87d834cdca031ccdf10ea88c594daebff0807596e0265cd9bb47ceac2cf06bcaa38408e8bc95fb2431aef68dae38a3971566f9742a814fb11608c6c521e94d58eb108908f10d2ec103067bf51e69751475a4dbacdae8d7d82ff52b4ac85cddd1ab7919f233569793c9545a9acee3e0567aa66c6c383908b5121d221c8ce6233958afb4643dee314fb50c9a1b7e4c3352a2b155c4eb20fead88fba001012f14db597e2f0d732389b353325e50ef1eb9026f26eea075689beb5c3fc3d53b5606ccf4120a3746bd56f1f613c2cd31457663aed3c4f2a6cd4e6c9c9bb35bd6cce685b1797d0695c37c6c498031cd2c3886f9ad55301bc87747c9841c62adfe0caa9913e9cb8bd65646b4f1d07d508023593ea89f86bbcda71a174c1ccce7fd322fb39d4aca67bbd042acee534b6dd67008d00e71e50a0e4c1d31f79d9008d164cedcab499ddbb6ac31bd80a924fc55b92693a5d599c04ccd828252dce49c58eaf6a1a49eea5fb29fcf8326279c61a1fec347afeed8992730277a4072447611b062b94f607918a7f855461cc569a0ddbb4955ee418af0e933753cd6206a662e2ac4a28798ac3577c198f1ac56395f466de9d9530c8eccf59be6dd1c57b109083e0ec221ae0075d312bf2bdd48ec3e8455dd95070e2d16904a8195d0ee168269fade326f69b1dc9c2805fd1ce4633717fbd2b729d7de1efafebfc94358cc271035c32c9082aa3fe8cf0c1264f2628d54a8d95f72f46fb21b6a6dbbce40033d2d182081513207c5ae4fa660f19b4525bfb220ce48c68c9686de4b0ed574824f113f5419ed9ae46136310a2d992ef5130a3d2cd684938fa07687d8e27e9a434e4c6842e6826d2a2869ddf6a66b7f48f027960a1a0e9b80dc0da6c408cd0746f39143662e0c08e19760fd3de98be6c698cfafc3c1f3a6782bc1e45452ee9ab74458ac90a35190e2cd678ece1088c64ba572b2cd32eb83a2ce870924cb2466ea5c47364c87da689fe2a3e82433b1124995f87381f2b7029d7a5c9834a83c1d80a041619db0612e4cc4cb38ef03da8c734ce90c0a102e074bbe9a939ba267f2e84c28007282ad2b96fd0f207701b5794c119770396fd16bb9962f8c10cb7023f948ce46c740c3cd58e643264dcfa97025be483f1fd1dc01694607cdd2b5ba2afa50a1cf31a23d9f459d99faa209720781638b6ebc11096b30fd35893a7fd9718eb82e96881cd95edcf8a1cd2c6cb63a097e4038c74418e4c0d997732eca7aabd5136b5f4c699318db237f4e3a108bfed51fb4c9d44eff7c4aa4353e66673928cd4dee79944966d8a6e895a8134d506d9b9e04bf7b8bba11fadadfc31e4e30501476b956ec7051de9f9428c0cc3e56474bae8e74829b003c88a0c50869ac65dc24dba9431b7731cbbae453b312ee07fa0874b3981742d062065a485b0c14f9496e565ff46941999978910f875967638e509aaf72ca7631eb73d6b827dccaef1cc600882a412687c6c959fd3bbaf95d72edf53dd6b6b017c3ce13c092c64bf86f371a7a5737221e7cf5bcd6298bc3979a191563c8c336ceb280977434207dff6354e51f2adc2843efa97761e2a566a5706a35421f185f5e4a5f6d578e46f2c01cd3c6ee0af4a402821eb15b1e1fb0e387775686f79fdc8e504b227fb0b783b31c4c0095ddbe7319f8b4433a12d832a572d9a80c70ea053f14330505fa03cb0269bcde938cf97f9ec38e3771f8901b7824a663a593bbd357d2cb893d9a0e7154f8fbf95dd649c697fd32b50e42d88a21154d527eef382e72166e0e380b5ed9b7f1ad4419afa57a915a1c4a2905b41765037752ff46049718369fc6f792d7e4a85f435a0cfbae1d18f834f4e6362df9b45c563ca64ebd3c56bfda6169d8e0ce5e19f748a2a6cb8a1364f85ebf0736a030b786dd67f3342ea93edb867c27672d0b93d19df2c665b3539a9d6fca17a801e00c2ce5085d51c2def26cd98a5604c2e2fe9bfc241396e0888c7bf805d13929574691e88f26939d7d79de01eeff9ae8a218dedaa74e38fcaf1098822ac2f0c9c006c164a262ee6405711ef57acbc98efd3961f0d576a3609a6a6f48ad1de099802d8a9d0e70357be62e781675c95d61510d9e4c192f7e1eebb43c46126be6b6d84a7728b8b27352db4d098a5f1d0df61efba389c757b04f97240543b1c50b42a110e708d24ed74179684ae90065e408ce8b7b5329a5e7e14ed891a0f5c14c461e351e6917b65ba46063e21fb70c04851d060c6f5e0ac0a212dc7081ad11e82482f2d84a09f5d524fcdc96dde255618cb766ba05785c5a4511c0a60c7ed0168a0332b81b60508f3b1d721859462973027ca3ed48a182fda0100b9a35b3314ddbdc9fb67453e3d0e334f2cc4d8b902191c1dd503fb18db0b6f58b5a905c5da5de7819800c5e749724adebd7e9ac94581647db73cd60b96c826577cd05e10d0f17e30b065c4a53bab4429b62cb6d1bf048b8f0ce59f59356da235eb6bf5264bc3e7b48658558429ffd6c9d2d7954b5d083305a27ce9db2b017cc958833ddbbafcc05fab6ba347c49b54e21c4e58cf36e24f0cb78509eb8dbad7f81f45bfaa5d78ab3ed5711c2526aeb5fe792913b33f08c6a2e8d701e23f4b3013572b06c203d759aedee1dba18f736c4c0295aad2b5710eda29e58fc368aad5502ba1147aa10175e9e5312919952d85cfc4c626c1c0ce06be2e4d5727df737ffd39723fe76e26b3078d0906d4db70dc16bc547b073ba1aa4fe6ac3fe5074677464ee591dc22391637d27e670cdb4da3c13c9c71d4ba375b922d8ecbc45de7df3a35fb8e9f7e6abcd85a6d9d425138be504b9787199ba4273fa2589e80874db3454a277db33ecd0adeb8e5151c25e95377aae72e27ff35085168fd9f996b0e60ba4888a1821d1d13489f3453449f1d6b7e09ac05d6685d35024ae862e141285544ac9e10bfff9de5d8870d3968b2cb28d4c0bd85bfd03f9d186408530b2fe24c5273a380f2a58e979f5a7f87d6ee62462353dd2841e58c5c1775d8735f1537b8ad9a7d068091a27afab7425b683731647aeecd66b4bd806d893d64a7137c51bad794aa4bc6913828d6066f2aa2e64d0d7dc8192621c733083d80006e6eb3011da3455b736fb275ca6e41e3a2dd94b744704950a7111cb9363e96b35271fabeffac2f9c458ea36c47450438a7b3ba77f1b240075d5af9fb02a824e6c86ef31caacbb44d32345410d2a640a5802addf9069a8a262cb4e55f7a9ad8928ca71fb1fd18bb2247353e9f1808457dcf1687e331b4dccb980f42bda8a0115e174787356986ad3caa0e8e6f052782a6253236b858f5c80446ba2c2eaf78645b53c7a2c997ec45b27bb97a588d9971a31af6d60096bf1010d1abe2e1d72dc6a1a48380eb7b62d24617db23258bb1dcfd0bca3c575dcfa965675d2fcc02f3083ca1a0c8ec5f06844c98cc05ebd7f42bf30d9d29f504adc2b27eee87bd4dcabce6a780d3e44ec9893c56f4b4418eac0fff04c80bfb6281ca730d82aba5c23fea513e0fd9fccbdeb4b9ec08463a29befe2c00c913ca9e9fa8934a1f1c99d0c8dd96fe6468e90bda93700ba5741b8b5ce7405b48d8201a60dcff811745d08ef1fd224892df42cdebb27d12bce7690fc5756c7c5b637966ebb87ec8cfd7baa9e8b79112cae6052853ae00045a673c73f307afa1f3bdba35c157ea2cd507535ac102d4a46d9e3172ce96922d635c888775949edf41627a2906cd0e6ca47ec75a2c598fa9c66b8b7eeccb73bba0892e5261db0307a83ae41b3687babc0617339f345eebea327a6949f5ac258fb3007f458cba8525c3a7bd553637b9ba7195ffa5b5ca8c7d438a1144438cffdb238f4cd792c8b72c342bc7d85c87e885d0d4b74179eab86d028b067db414cde4f5cb92445bb359253ab61adc425d3e8a339e4e37f09999acbe5ed76a2d038bdb4f78845696a05d9a2b1be7ce9b582524cd984cbd89b086ea01cc37a16b487fd7c42a6aa2d72ec5aac75dd71265093381bbe7265841fef399b4d93ced33209941352479be7fc2a630e882572928c6c77d084c80203e2e7abf2a79c4254546542ffe1220b0a2a7d6f5daa07b7322e866e9d779a46a01393b4bbbe8816b5e27d68e2a4475bd02303f720ab276562cd1ba96503d64e91b23ec67282c2356d16ea63ea5ad3c0e53394bc5812295d3c1cf9533bea51c660d966b1e4b6015ba0b3097d29987072b1992774ccfa59c320bd068f7f82dc73baa1e2fdf265f269b819f43412b32f64425194a67e32a79685b668eeeb8dd29448714e983a833b021d8f89ffc7a63b15fc8b9cbffb3d7b3194b3cd1e9106154d3bf69a5f8b544d110d3f1ebfd37018b27605f53288028e71b95ffd5fba32274a8541cdf9497a5e5a3ce980157dbd75310404cbb7c9596a769f27fbb40c475fa198d2017b6701c1f305328fda8df9578fcad63258cc3f4bf536804f9868b70d6e7d1b9e1d7c92317410582472f93f9133a1956d5d7cc7aaebdbf1d5e9215378da9d43acf280c9102803af6b2b2181166b5048764d75556395b45b4a47df613efec09f9fd185995d537f48df00d3120ccf005751eca38acabf7d0891e52a24ef43d2c245556e0a1dc85721a0e33fd1911136953ec45dc032d44637141ab7137ac2f50dc9da9d56877f3285bebe286b55ee6a6ec130b6696a11901564d6cbc0be15d2a7ee5b7b1311118718b905bed089067ab5a549d4926a833c6921a4f6259c73482186c22832a5dd16c0df0cb52a04d8ce0480f164d11d9e2e44f288cb05f2c3538ce229e2ab238c5965f535a3633002c7fda51af6934a76b76b9a16b1763c01f2f79f8ba9d927c29f8bc3048dfdb9f3130dcb5dce7f4328afdd3dffd9bf3496319a76d4315fe93c1a090707aac858e073d85bdf979e5fe2e2f21e1fdc1bfa53c3e88aec7f48803bb07a8fe663b72c526b1a702a611b103c98df7acb4187f819af9951b1b9b337c34a40289cdd92542bb0af380b8046bda7af9a8145a6f70d7fc74e4b49d67328bd78a2b590aa6f7807cb4ad78d68cab4a15a71da9cc434692eeca65e7d5e9c0263bc7db63061d283f8838bdafee60b2bd3808cf441eb5a20d18d2cc35fb681baa9e1a11ce6b9fbcec5e52551967df8818fcc21c6d47ddba3e70aac66f16fa15c051f3c38b83200dbd35369d6cdfa146e776492e5a6e85db8c27c1280bdcf2dc272cd361d865e21449f5f5bf12cbd7194ea5db2e41ba0e187f16631997eabc612e30e5eeff0595692907d8be897a8cce65740d68f6e5f1b0c828e189f9bbceef43bf294c866ce853ca6703b9432b52b80efa286397530c6ed6ba88b48ee74a054da95b439463c2b947cc486b3344278b679287dd59edc8beee593f568064f52563eef9c854a8ddd10c23762f7dd83f1832e58f2f898f7180f4880b295a21d6ee4549e3b11dc48b7c7c11e31a0d44e8a4410101c776c59691819f32fe04977267d48b43df3d6410ca92c4acecae25821d2aa5f7f46814a14a50e7e21b9776a1e8724227a2459499b427a4e77d30f2ccb8dd369cac0635db7323fa70cb1b7b243d151daf106f6198a6b08885e95d38b42a227e9d1e779f247018737b8509e09280bd554e44b451badc20fe7d59fb44b917a2a4031df51228b572654bb6fe5481d6beddb7c7aedfb7039b2fb1f27b01f9e3653fae25234007a59d97cb476299253067acd8dca98ed148f18a6e3cf028abd52513d4678e3a58e6099dc6db1137eab96123e167328e3c2b6410ec3f07f4e1b107e65ab2cfc914f5fea7869e52a34fb40fbe040d018c88b65b005030b6e70a26dd4c7b159ad3aa6992051d3819f270e80ceafc197d793e63478bf4d50194d1b571ec5335b2a19795ef378ae29e9f35b1a4dd0a71bcc09daf1becfb65ef470a46d4bb2a6ab918680349931ca75defb6f0e795d51e3f6768986f2ea574c83ff7630504f8d190d54784ca18805cb992f775113f450f0c48cff3d126854418eff99731b8152761a7264b94d6aa0528b41e59efdf477a2b102a5dacfddd22474a5454b5ccc0e4489a943b91d7fd280a74dc0287bd82ba5dbe3eb7e5346705ab1fbe768ef3a0ffa54789c749d5cd5a987e3673f422a5d53dacab043b736bf6688186359b56de2173524cc939f803ecbc6a8c604b3a4a5f2978dc9be7709a60799c291e1d6cfd6323928c21a37298798bc03e14ac23f9113baa8623f7266faec7aeeec0cca1d50e4e2c3a2cccaacaafdade0b4c96928504d836070381181896207711802ca6702bc37a1df9585e0819b09afdd5cfe6b6c1c640adc4555e322e6c362e973d7f4ee2966ee3300fc186c26dce1fd683bb713c1e1230ef0fd6db970fd564f04e491e9c9688de3fcf9b655fe301663eec64ed884dbd948450147d7ffe13bfdfe227379fbcbae21e41bf5deabf93f234f1f7dd47538b7d12c6e38ec0239024605743d1b98241351ce0b0053f6c5dfc4c578966bfb42d28298b3a614f457b6fe04f6102b61a88fa8d7d697edb4a003056dc4a4c437357f52ba131b2963c5c35d55ba304293baaa3d97018a76bbdd81463c7b9736362d47ae61a9ddede5663aefa23e0136e9889494c894c89361e6915e8b939c53f43c6629fe4e4965d3e32929c2b715a29814ef7cec575e8d8569480206a488f6a246c75036fae9be631fddcbf201be94a73d7fa7c08337d05fccff12f89048ef37c7cf4d1c4f3227eccdb45c0c3f182d78664130085783b78ff4d9a0ed8579737166bfcbf2d53f4a4de5269025dde9773e0e65f85b6fb2fc5e05c93e2661d57ce9b5db068c5abba367426099dbde7f9bc3e37388b1a896e0f3ae24cd74af9b66228e2d121563f0ef52f5535374ff217a2b4c347b6beaae81ffdb540b1aa7b56d54b3d44a7b27a4236a28e1ef9b3514349d370c49ee356f1c69c1b5db3c078b3f8e9e3ae2c459a851e472ddc80d9a31218bc976faae637312b131a0e92e407baf084f439fa2019addd1676c5720458b0c32786621ba78181ab2708c1d558cae7b5e0ffa3d081db723633cb8332171ef02f13249516d6a06a35e0ceb954ea9f30524adeb7dfbb47d57230b198ce9cc5d63bf6c2ee80b65242df9cb7f53894a8e7d5dd74b01149678c08240f6499bdd11a90ffd4bbbcbeac7d84d03b08eab599e359f5f5a7c489cf9ddd22665a8f4efd5ba7f0ed055d98112a4804fc049350b8be88f3c938216c18f601c2aa996f33ad535d940a10309e432fd5b6b3b0a89662bd39db9248d8a54d1895379b7ef344f2cc1b75296749031b0ba49d2420fa90c72a4448dcaa51e6db2381e62a17eaa6e9d97d2c0593d14a0f4a18b05115f2c2e1f8125520c3c1616d3e7395d3a010b5cc45482cf8c62f8564eabad66cd4a317da6f5e937cf277c82a70e2e165b953fad46efd7caa1c570078ebed437fcc23578fe5a4392219cb3c2f94fd2ce274bf7e2ec8a8d7be940e009d951150ca4d1e33bd57a8fb1642f54c4ed00268596b33e116d93de767e2f364e7f655a5677e1fe19e1b07564787bed27a40dc70f06f6767392e8b73707e87b65648a3f4483826705989cffe42f1c2c88e1f29265824876433544828d010a84a104f5bd526d4a13559020dd844145d0f72796b3ddb9f665393952b98dfa4eddd994945e7b5229ffe2077bcdf86e85fb515c5e21c5d7606e62543a91fff92820dda559f99fb2bf259d527abae22e464d8e1b0e6834690ef93836f91364148580c8fab8ae9454ea7afb53f7d33e1434e83e94b320a2cc851b260bce2ecf903046e65ccfd246cf5ccd3883dca233fe17b405f9b786c7b087e5edaeb267ed583261f67ab8a4c2ddff409185a05f1b08079f69410f3ee069c3b1c64328f61ae30e2697344c12b24eab1950ca43ae30dc1f5329291ade87707bf202ce36ecf3f13a9ecfb70b3c795a6c20431ec86a2a449fe0c6c6da2307be967d742a72067eba63d6fde23026778557c0c6ecd22f890359b769f3d3cc7e2f5f2528e7989cf05d645b5862b429286424ff0b0a5e7cf120e5c7753530a5a8c835151ba1b02678fa093be2f7051c3170b6f4cc06fd1e7fe41bbef19a7e4a6704e2f5566f259254864dbfc5fc2e15f6b7a95acc9a103dcb84313f1b9ac242ae3e56838af3f72fecd78d951c42f9089f641b98b01d3cf9e9155d251469a3a55efcebfdce35be38e4127e28200482bc5b951a58f4263e360bee31165723175b463bcfa6f2e285a1a544d51be243e81c934f466071ac659cc342612b1352c00a2c6320fe5739fe22a2c2e9e69c4c3e115339c146fbd46d7e32d7dbdcfcceb94ee8831bcefde3551f5a8897492746384738c549f3f39838f8e7e0e31d7ef93bf3278a809fee2c81f305c4ce06aa46c0b67692c30d0231bb23113a59efeed7b8ae94d05b9f366bcda2ba44825f96eed6a732c71b039bf452249f2aad1a6b030911300ae36fbb7000ffbb2e0ef26bce1106d57a30b183d9a91e0b5ac0447a71ba53c56b63b8c415059bbc60094ac8590bb8669d2f724b50944dfc34904b47008977d43288acefe2d82ce5e01896455b8cc30a7d240206d7c17b9b6ac4b5d61a86c785a1435b9df03162a408d62b9862401a353e85cbd5463287b16f5038942f84dfe6a7308568b97604821e1faad01e0a754bd471480a5c07df4c9bde40be7bade48fbcbd7ca9b4ee6358b1f55168f45af2c3a701b5bfeadc03fb441921a003b0a3c368b923652a2789c9ba060178f327372d6fd7a57046e9b630e7ef379fca38139bb567b800608874835101a907155fd9541f9a242fc1f319afffb6ba10dbb704aafcc7b149429a3b013a3657d4dda4774e6d5b8bea18f9ab877ce0b40998880b17bf7df496eec209c88129f25c632d9192811ecf8d408d04cf2eb5a281de63efc04d9eb23a851b57adcb72ba78bd24591bca02f2e3a5755212a8c4207c240c428f84df832e4ddf4d47c78ecc72a67103d3df09974e67a056d1fbb96a6cee1f112ab508fb3331f576ef85d01304f362afb1ad3a31e7121daabdfcaf9cebf7bda631e067aa02bb05abbfd60495c0e32482c6f37b867dbe6a929b8965cc2f7a1f4fa81164f36ad370fd935a5bca1cdeb3973befd5128bb46c3674f6849a4f60fea2589428a0635fc1b9ce531b0aba44f1ffd5cb9b3d8b0ccc3f32569d84293560b7e3cf5a858910bb9183bdedf793c36daba244a3bce117320007e3e8335fccbbbd878d8eaf0eb5e0dddfc47f6f66f5cc525cbc1d3af4e08468fb007f3256bc95d1aac8beb85401fc999345c5623007a31d9080c25a324578a9005f51c7f43a822239f90ba9475eed6db3b55e86678ae1a370ef80e7282bb9b41c2fa2c1690e6c2f5022ed4acb16b4c1702e2326a1c564e22aec3f6c9fe8dd9cb4e45379ec94a6789be183d9885ac753a36f267875d4bdf43b88b1a34599e1b55a15c2c65648e008c1ca18293d3f5834f1efe91dc113270b942757c57c8c9ad8c631743b02771018c4d5125d89a971e86a7209a9a88863885d6885101692ce06f3b1143dfddf9f392571da55ffd480fd82f2dddec4de179fa46085886f10dd7b6d09c1b1e7ec3f585954b3cea608a14c9bf04306870a939618c1fcae63640f9bfcebd62be0503706ee88b2eff423ccf7f8fa4d41280208475e1bff538f64c7c8958546e4bf181da81a37e1a1c5b2b35efb810536bd6cdacf7f58fc3ed0dbf856f70b4be148577e0caca17afafde8f085b260951884a3e3ae2c5136caae0ff868751316f4c2589e5db68bb5d7bf136ccf00c5157abd0f55c69a808a6b3e433c5b9dcf514c5365634575d1db81eab45d0ddeaca77a03e86d2fd426db326542976df6e04b32e5e10dabf2d04c4bcaa69958679e8484bc27452f0e2af20ba70b159b57237e67aa3168f2169f4164ce9d20f7b1292429633eab9041150d0ac32a2042b0245d6381d78125e1c5a750403ec1f9c66219f6d9b0cd931421ce405ec8eb276de646253b4f4c00e8bfb74c98dc203352843aedc0b731df10d88ba218fe0b9972c590c5eea0a449b971333465e1f975df91ef0b26055a93bfe05209dc9e9b02d023b1a0c7ded79270b4bab9ec91b0983c2c69d691fb787a2b32278537c51aea6b693e11774f1fc9f7bab22d2d87b83b820ae82bf596645869db0a4066f132c1737b371d47d0b5a3f5aaf8b65fdad85f9431196122cee6b19e4e59a05e0ac616cf80ce00289a5168fb5cc65691da1d36b20f1d5258431037712d591fb23dac2d8def687c0ec2f3332d063a5545fb1eab8c7bf0bf1dc87a1e5874b858833b03b557922e61ff773ec034303096746d45d9c2ee341093cf3c50dce71ecdf53f72d6a4fa97ff4594bd3d2c7d2d2d20eaee4c816412034c57ace169b0b404cbe9de74697c770e779f0f10474b9d36a306c1a88a0d98e35d19936505f4a84993c71922f0eb910539622a26acf2392cde65e1c0712729917028ba42fd471c503e9ed6bb890bcee6fdf9fdddebd6b1a24443b0c1adeb26b32b4a6b81050bf705434984e3c0be35a462208190ff1ee700de8e9b2a2888bf8d20b26a3d09968eff44f8b6de76da93942cd34577c88416eb2cf215cfd6c626f985b345b0181519834fe37f209ba2f133c712d41ab27eea25191ed1660172dd5de99b6a34a52f1ed4e1729dbb616431ca17d2407701ae1d5222241484b24791718101aa1c69938ded67d578f751947a329be53aed586e7294dfef83e4e8c7cf0b3bcf3f33845c212f15cc521ea52bd3c28d4225e1a5a0d3fd4028cfba585fa8ef2f16bf7989f63ed689fc7b403132b6a83e662eb4a13a6bb4d778af558c6719eff9a5357f995415f0aaf9533505814c83860fe117412d6df9cc116c1a8476afb2143d2c0e326e08ba303771411b27ea5080031068278c14a07d80876aa5ecc1b7d65fd4a77216c6374bdfaf4d8be8c97c9b3d88c0c02b74b8feb05d3ab6d52980d89b6d09f2a64946f3960887d43f06f21994a2035febc7b7252fe02edc5a9ca0ed2530244fbae37fae9c73b88ee15c477fda5a79a7b9a81e8fef224ffa65ae3e88764e46fff59fb3a8e51f0ee35cc16eebae0983c93d89fb3bdae388c4675c5006c8509186b83b619f317ce865440bab29011d7cf6aea1ccbe95fe23b86c07cf23bfa95bd67db97e258d22488ceb81d23dc38267eb2508a11c0f7b6c4e0bce50c219b232d4d7c7416e82281b6c9d583c5555b7d5423e7654bb5328032f12b17e685ae98872d998f337f1c3e693f346b87677271af3d7008b9fbeff09454e8da8b5ddcce6d345a5e0126d3f10d1316b84617ec83807da7aab0c0813f67e2561b2e0a8abaa9245663a0929990e1e6239d7b9f907363ea039f48b1f08fbb921f7fccc56f4ad1d671482c361981f213c3aa62dce180be1b7fee6d039d29fbfffc1634ba6e7c49b3b27cfd90ef7ae0888d0cb4ab091e8cab65ba8a47d6ecc80128767e30977efa581077970d16bd2b16b0d6d2b7b004823bc7a65ac826a6cf58e6d594b5ffd9401092a1c2fe4979d61e52c9da7b942c0c91a8501d74f2e84a52214b6a26d4e2275cafd85bb07b3dc1e2bf92807ac13f0eb9856370863b7307800a6c3192ecdd9e09f7f759af75dd240e0e5cef222f20be16e6e734d2504f1022cba20d90c48adeb2b6a8c9bdb365296e6b6c5c9d4b8ffab28f8bbcdd8ff21eac973057786f9a91e83c1fe6bc1b657dcdd4ebcd10339c756a60aa117f5c4ef04da4cc82d46b57a54fe13464e999ad9c6eaa64a03643b4e662edc559025d8da00efb66bbe3e6399e40317fbb367c22b699e251f83b96be97eb92edf11c5ebdc29d97accaed5d900c04076ae57b110612f66978c6530f03a1f85e73bbcc43592fd8e3f10a4b4a28b0faee4b503c71e6e7aeac40d961c5b4d2a5554e7c49997f331e5f84964bcb3e8232372ab742ec2d417c1c149f0f1c9171c3338323f388d2e46de6a46c3e080c371ff362dd40bfff9f6c106dc319f447d720b7535ebca1ec4e5a2f51038e977027bdf7789a89255446da78531438562e3ed476c826442c56d18d15966c781d6fde653eeecad602124f3ff39f54d047ebad9599b1514cf5afdabafda0131384df325a760f653a01a50c571eb2bed78b4a91df2ced77e9057d867eb0a0aafd9f4aaef8287577ad36968054af33dca7912f993f4bef222e987ca56fd3a3e33df8e6872b54fe4bce4492fb8d3f9aaa6846c534aaa7876a7a7151353c87eda394435bb5da1f84ad83dc592bbab1cfd910b3e8a5dc7b4b79bf91cee68c88a30db2b01c01b90f83bf6df7bcc6e89a1ae1dceb363cdb41b393fcbbd7fe1a410d7e42611b4312fa72e1ef5a71a249fab83fd8d1aee74fe70e29a51f2788fc312b6e854f7e27bda5850767a8d977319a9a69bf7793de9ceae641715787251e7ed9b91bd5d0c2d3e4b972aa611d3a3d3dd3d36a616619aea2a98277c12fda20acdb4057d75b8ba557e8a77c4b88ef7ee9739abb06618ecebc6b482582a4b0fb81cb765338d30d09c01785bb2cdb2d9ec8be3b974ba3f11187685ecb0d1f8e6f90a44074a89e2593c1c671e68b785c4ab6fe92304269108dc7a9c2ce043262a4f75c794a3702f36c530e7cc4852630b3f4ee89e3e30918cd2fd26a59689f1d16aaf10aee412fd99ea36fe5232caadaa80ce4339e104b0495dfa89b813e5dfb13ba5b73114b02652e852fe83126f523d9c77514813f641943c5e70f17e6ec359efbfdf36ff7e023650dfd18a0e8f6649e728a3924d24407efe5884cf00fda3600e8015392b3911ff764755ff5d3a3fe96b26c670bca0ce1379691ae1133fd412f7b66e42049ae6bd39fb9b33f1fa2d4f4755c5e901fd5f0ce847beb4297ca09ffa02b637cb480baabb203ca32af4325994b99278a95d6b9b6534ef7c5c18b668e6583b2a6eeb354c8cafedad442876f12e725252b1eafebd5ed67a76a1b460162ea8c5d3271cb2bf369b8691947134eb46ad1ced200c73389ab329661238161b710839c8fff7590a66ed4da37383196e9342eddb3b88262177c69454ece22f182e209712e094b838ffb8050924c7d8550f73396ac5b98befc3fe17a73128a61d19dda2fc5bc5bc28fce322be1b761e65aacb52138e02b0d593524a86cb8d42567711fd1897eb3429b5fd31b3e7e0e40b788b7ce3f93bf24555900250445c4c7f6658aab982198a37980301d10d8d12b8c84a812a7e980928f333400c48fdde101b9ac5172a2e339991bd2067b2513b6e0969dcac25d2d53cb88421ad2da721fa349f695219037250234f252c9aca5d06e151f3a1fc7ccf2d4541a6d0fa792ef24bdb54654beb6e05f6f37d445a269e9fec4a676a924fa187035ac5be78b48b220cb63ca6cba49f19c9a2e9ba6bfb15ed044c6cd2d6e3d58485c07a0ae64236b0fbe64dbe632d5d8b66b078c91047e64af5bdd4ada8c3f4837b28110047f96c6f0bec75601f5c8d3fd616609b08cf7a9e072070cdc091d4acda8bab1c76bf088b011c2edbf6aa40a6f9dd95f8cb5d0b09aaad514ad4856c3788a94b2e5bcfd127ff2b2554455817920e47de82d4a7a1a619a89f1c8d6022d7d2ef5e6490f54f2f102dd0800f00e9ce9254761a865a5604cb30c3cca0de235b6542880d05148ade586a009cc7575e2f173435a9f13f0d8964309ac5b09d1b90c78a77c0d90ac47729533b2a719d440e4d326f34e3a960f3eebc9fc24f166577f7c736df8cbdba2946d6247748b6995cbc8d67a67f8cb02c07011ce63b24a4d1e0b87a07c273523a2945f8a67f7addf31ccd4e5e0650ac04a3017271b89337946189777c28897096b810ee003fa3fca75a1f9f0b004b113bee049cc970821fede605fd0826c136a070d4bd1a1b65ef6a59594332b6ab2963c2c36bd6a89c288c243462a0df58f3c813e075789064f342ff098fb8b428a8190bd369bea93af58bc15e83b202001e854bfddd809fea4d226154fb7be27535a4fb3df8bd01334f40a3473a97fd15afcc82460072bbb4bc5a0617f71b6937845d686d7a70d635c9a50a453b52f3677dbdf53b7768ad0b14e4d472a7f5fef9c75671cc706dd731a92b2a511783864359fb541b5f6dc6582e7a795cd241d1711739f884147ddf1ad8dabdacd6b9f76abdd7f878f19c1c532e5804070c99cfa0ecf64425601944ea75a83b4c5a1c978aa7c57b99b562c6c1f5a3ddaa712302a336e5762db4973a74a9967a51d2778b882ed5a5f000b37cf7b333b092b1e69b3d4908adebdc75aa020559df96a10f03fc0ab19275e2a08fd3bf159587d1184b2f3b96538a6082062144d6e5b63a8e168cf120375c2fcd00db035f94a561a621727623da0c4e50a7dafe9efe5dd0514ca683466597e4c86d441e87e703494063ed41ebc5f48cb5b5e67fa4aaf25fa141368da08662371434e5f86daa0e2bba80610b6d4fabb02f11e7e74fee6455d561b0f939356ef17f1df858865191b56638d4194ee753f914c34f9861272a2e73f2a8e3c6b86626bbd8feecb9e5ac36cc96e579f449db3e7f00ca96641c839902368fdc9eab41bb1e756307abfd64ac3abf492c1d2c254b2574418ef4a8f69fe666664246964f5e431999b0d686e839892bc2abdc88e893aa5559c46377bda30b1f8910208c9ee74f2fb852d58396a7454407248167a37308a7dc81b78c19bd24fd065dcfade2d4dc1dcdfd02026b22151a44c5da8a17271a27240223ba35ba019e1c9dd39eb7d3e18afd52b1d15886f272376028102e5b4815ee9a9151ce8fda91b390176f92d3359aceb01aee19dc412dd3c6ef70ce8ef1e69fd63ce9b24f6079bd1262c86dbd3718519d2f1af9a033f20430a1869a1cbe8aa6251b7399b054dd752591bdb3d61d53791779ddcd6b840d21a882b3864a340b7237f05bcb93c09ace10b4e0aa0141f6dcf7e57ab5cd2b27a05370fadd8a6cf3556441eab9db5cbadc62239c2d3f1ccad5d41eb21b01834a31537922b6c4cf1b9454f424e69a23a3fe480b004e4a9f818a842cd57c251bfefeb911138d6381e2c6efe84d204bd3c695ba3f4d5e3e89f464c3248bab0834f17c98462db58fae5f095470011bf4a9c46f543128defd09ffd61d7d450b30b21d7622a94b21e6a8786df60df5b0d8a22c9911c047494f0aa49f644b4ccc4085ec906a461ce0adc97c875921176144abe048f83fc8bc7745a7adb7ab8f6aa05e3bc356f2eafa14adb92a11f5a5d9690f0ba49f8729ad79d4fb04fcc9754656727c46bd481a67059163ed77dc395","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
