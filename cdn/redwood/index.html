<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16960881b9dd1688013db9d64ed312a651526576125ae9518a749aac6d38354adb8b984845b3c25cc0dd057b205e3864c4093b7e49941c772676c9c85fa4df1551dd58869903093df6a209ee117d4a611caf0e176eb11ff6e528b03caf84f7797dd9033d78fffd77816beda1c7787fede11a48cf3506af28d45693088e2363472abeddd7893890ad0c50fbcdcd8a7a4f3fd61aee3c0fc45901bc429d7b8c072b3cb7d5ed38e0f125f6aca21c1671131534d37f26f63cc9411460cf85f949eaf462bec38a1711a1bee450a4e70e202dd5c83ad230338002392a83358aef58688839857ab2439b658b2562dedbb48fac6cb2477a71bcc2da5e5163b63a7cfd83769bf38274b07449f444083fcf16ecaf55730308258924c008ba208a329cc9c4058c32a20d2f73d7ce1c830207847db5466d1448c7fa7eed8fd8fa5cfde358c8983212326d31283b44b03cfcf1de33df5291dc164650edec64d65f6e89312b60fc00fcec22c63634f3b5b8a59a7e808e4d913b23c5c5f69b9080e8d957242f41007664ded507b0d8add6c07b703cdf4a20f723c8d1f547d6d0b70e4b18725643c12457507b378c9b2c725941d286c984df2b7266b05fd7af4f897ab4509561210532fa3416911a32813de5cb5ca6ca16b5da36c88466ca378023f2159915f2f450f31850e061565aaeee14f850361de6d0b65adb492872e0c97c6d0d58d54f41a6e5663abc20b612058ac6c0c5e5152033f6662f893b6beffc86ae168d7014ea1e2e49a97e49fd9fdb607536094536d9012dcaa32fd24df8f94d48dd1ddf36562ab693ac950039da18ce5fc8a2b0f643daffbfcc2c413ee8230639046e05585700f341016dbbaf0f66782a5c1a91c6e5d6e7fc4fee6b72887dca42dc710e3fb02ce375698df278814579f44f9ca298847912a4bff58dec592c28a3ac2ac81e06175f6056e7634c028c3d3a63783bf8d357563afc053712f28992e7094e2f6c22c9253ba1cb41e6b519476103e2263b832f475dd6945c7ab1f930cff81d3343f2beda74be79ec53efc091e0de0af2c38b3f9a5c1eaec4d141aaa4ca305e474e5a0e8a5a88b63c7bc22db7f65f304c8d0521ff956ab886042ceb733c11398af495ed7e56743cee2fac0d6ebb061dc00e4673b57f18f6e66d52e47df674c53d0c18ccd060111c02311a7f51cff258ca9a40839396ed2402c64110195035efdfba7eca72efea023a0dd08ad521b12e0fabdb416acca6806b2860df9bd6031a72ba2770636d146b8bc6f1ef28cdb50b3cb1307b10569509e5d5d7c2a70f5ebba72e4f8c90460768364e5ba9ca5983dab20dfedb976fa1be48e211050f07987c7a807def1f768b4f234b01157de6988e269bbc972181edb0141770c57ebc2c909189f7a08e6a7d76e28b110998d31bd6a040b9a2bb65f6256251b443e61aa23f09763d25e5d00c11f6b8daeea818c8dd6b91163970e9af0a08edbb728e129c636c129e8a6b4040207d1e9a06ec99984b56794a08db066b2b4f4bc4fd9ee79cc4a861f8a7409eda62c52a6077a933d0d5cb3947277407f031ec8ad856e3c513d546f833ee566d99c825a3303998c7e99e03e7969039bc4db60c649297e0ff9d3b935628e8b8c1f8e30fe3cdab374af7947313c5be153769492f50f74e2ef136e683bc5d7656e93a83b740bf3d36ae2ab3cafb0631b8f8ca6d46316a1bd090b1409765355b7ec18bfa356d56aa4a7cb5aec5c6ff600f87210a787ddf8ee060697339f31222212c07d7d61d248fef6c0af272c331713344bbbeb014905c8fc9bd7a4a79c02796e4c50191d298d1cb3ab6dea89e2e00f71411fdf25f2e5e186bc57f63ee79e4019d19ba829ee480f0d7d51e13b418eeaeb28d2becb1fd18efbdf061024e32f6d2da4c00cbf686096a8e5480b59491e55117e800f169365c24971167ad50c42833cc9e6ee55bdee33b86072ebd8f5c9fbac50aa5310e7f7f887d24a35c9ebcf950802660e11f9500738555aabd7b03d73b8eb2460153dd577546d8ffbf8c120f54f8f3dcf9b821c6a772189a616b8a92f88cc7cb351473b26c046b7094127c22aa53ca67768dce5b5a6aa244349a27590ab45899058a9c00dd1d181d5b05e20cb53a1947db65379639471e713149a926a0479521650ca56a7cb82b2eb52703ef6f051e96f51cfb1005078b674070f49b43a5519b2e41cc2dff40f1e116c9138036c67605c8c0ebbac94bc8d0e6ab9cd1d5cb904d148799b424693a83d654e7874ad1952cf4cd08e13a9468eb54287ce496b17949851b1ccd35d5341042f0e5025b96daa33982dc7251777012f6fbe0abd439a8fcf3fce6bae04fd51400d57bcc528e32cac979886a87a4207b6d5cacb1e9974eacdd85e85809b7c88b658c7b85d709d52c8cd73613826b87f72b28677cdea107b00b134f813b41af1fd859ede3f8adfd4a115c6c0d8de836795e2aeec4bc5a1b0011c74f35d5fb29d602206573bcf7b664a88638b6cec0ae568f5125523904bc3498f11a188d62c40795440064e1b0c23d438512be75e6b50e8204e0143de2521d1931b0dda0a4a48bd1cc368da0b642f400780cc8e025fe0f1b1a479f7404630d50b178f3f60c910a7edf2cdf68b32f796385c9eed71ee1b18eacaf94adfa813e104bcf1e3f9537e5d34af75ac4f747c1dafc023c5dd9dbd7264bd268454cd4ee13f44fa9a701f45064e07290aa1608abfe8f41f4637234ee51c78a20b84ebf5189faad926b11821b2b6b536c5cf75443046593cf346b06df53d31eb43923c81f2fb0c0b92246a882fe6eba95a0a4597905a59948efa0862a67526c194f06be705ca2896b149b766a9c86cbf72268a349aaa10b9252b164cb9bfd7a1b55663036d5977ffafbc4480afba48982ea05dcb4349ec111d6e519e68770cc7a3c17e1cad8f93db12161762daeabea2695dff16af9a6d119dc84371c7f254f5c9c9ac9e0542f856b38b048fd8cbe1144503c1c35498f883666e86ea78dcf7fde75396f7da2e8431f472805b02a1145e1c85dff598f8a3655e88b1381d434673abd5321039d07375a7bbabf5786744f194d4d0c7c78cd5775db7e0cda3dcb18a380c2affd9530b79c51d6e8450977c822e35e5c490dfc55c2a8e4e903b7e0cec30bbc7e0eebd15683238ca7daa2515f92bfd4216cdc1117091b71f8bc9d72e228d4b525c9422affe05b7fa3c00db9ccc50778ef8059518c66ebd8c230fc381d474ce942ddb8530cb0ffdb7dda247ad1ed597b2839124415208dfb58e7eb7a535eb988b239bd22d9f30348a6d6ee0190bd82d191b1a8d1a716fc2f01d32e691a45cbaef4672cfc0534a4fca31dd52e59544cf9b4168939c682491327407e6daf623f7e2237372a95dc6b62bb3e07a26ad0a13e836494d04d171fad48cb57bccf90129699b4b5f4ad5684bcd74a5304ef294a0e00730a9f2e8213a09cc02da67fd27a72dbe12cc974932d448f88e54fa036809aa72e11f85795bc2cd23af043168abae4935dbc3bcef3254975137c6244de067a2c2993d9e446bea51e40d2d2b527d3d8450927f2992fd3d4d7808b36ce013e69b05c6034c23c104a807c62c2da6dc80a2e88e13c9044cff0b79482cf95dfe47eda753d35b0895a50ca6d9b1564a22504a2b2974e601d0839d7bff22f5c727ad381dd57e0703ad892652e0821a348fa4c5f0ff9d015e0590b1bc8be6e5899307e34d96b05a61b26b9109c6854e57ccf9441ca5d48cdcee967db190e8ee1d61c8081ea4eb6c4cf496f25ea757c2fc7dd0b0cdc5749a972f9a7a1ee54823a8f309fd725e9b6ea0eca96fe8b57b83bd1cb50902e9d8e6c80f8d474f6dfd060fd0950b04eac3029f31b7e239cb7536c1f8e6c56e796041b758e9dd39d601c295dc0a9e79da3e4123f2f92e394857128e898a3f2bec5bee01a44d28d3e03832da5112afb26bdd2f3fb50ace9d7fcdce322658cfa128a07a31d4b55fb2bf55bcfac0a929bb36ddfe4afcca5083b6b061bc276cffd1f2206d1a695d5761affca53dfff831ecaff38231a60fffb10924aa5083c35c6f410cef5dc52e96e80c29dda4f746c7f8cc5ef9194e6153e36e87f4e2137fb1deb17968cf8f386468a3dc74b2f846e73134a729f9a615ee811aa40dfc5eaaf17a8e4b89d787e5892103928028374cee7984c61118170c43c90cb46573a002a46f7d5512afd4427c2b459d25da93a332d2aed89b5cf9445501768de0865c49353a120e54ab337a35712378ccf84171339551d1aab6275faea3429af193270b1e5c4561ae0e3e37031e0b781a5840f052503762d783eb3b700cc4f415da936a2de02845934ce37e7eb2b81a6067e48c5fa0f84432eaf59bfd65314f1068803346c62b74274dd18534d48b4e23ba955a151ec8d51fed727c4b4fce5bf4398d404f3f25777abe759c4851469127613c60193791924392c63aed123972029120d13022311574272b7dbe66d4ba904323a74fcfd865f64b11711d25e776218461c5032d348fcb90674738010023df37d84f411866609e2fac9235619bc03b5813c15ae29e09b01574f2465db0d233cd5d59957c3656c26b0a2becdc40bfb983479c2b4ad5306ae773a2822e0ac72088c1c287778a4eaeea82f4828379e15968c28701d954616c275649391e80cbbfaba7309ecbf9078b7e69ebc68ef8b2433573cc43cff5ebf09564f36c240d1ee4d732fb6536c04e7bd2722f3296acd499f5753b439ed3e5a80d9e5e710d08214aa6dee4747b2d36665e061b5357c07b919a69e163472c3c25c7f745ffe4a711a81a81d154ca0d195478b0800dba288815aed92d357eaf84d84891a6b74d1a6b60abdac88616871f4af4bf76093b8d08cc98fabc29dbd3fdb2e26df24d3352ccee6f9410e78dddd74c06ae23232daded84b9ad95561bb0bb1088559b3ef9afaff7e1d3818daab473a02e354d0fd9d08d530a8b098094cfb61305ee265b4f4924ff2e6941b78f38e1125a170d1fac5b98538a708c335251d1a5063a2013ac322cbcbe52c682d1ea85c8749a7cd3b2d090285b6ca1aa1a4a65d133db382475afa3c58e46207cc601b1c94880b9d20c9a31fc5f80aa23e5b61196fe0d330133a3baebcd58934d2368fd5ff4f5cb38d28435df73c25406a1f9fba3d9dda5d7a987096a478d84b7b9d563945519f4ada033aa5aeccc18d0fc9c7424b71be3200f45d1de770f3d6adb086688b50a821c2b29b78cfa8fbfe02b003f62cac8ed613d27199126ce2d6f7daa9d172fd044938f7194499dc85f5c5fcd7e0023b9bc455c15d7c9caad3eb4558c468a6b9edcefe293efc7ca563f9a9da664f4b67042141af79435c82d0585c2139df872468b7f21735dbf72495bac795ed13f554a0d86b8ed9625b1826131f3e09fb4383a0da2ce3bd93773fa63722553a2f723f8634470719e97db04d1f6dfbacb4f4436140c25c1afa73754beac9a900e177a47f1ff7467b4e79b29b2a85906a3c3cb8f7db118a65beeb4c5ca3f343b589b5dfe7c13afe481df7d8afd27218fb5d2b214d50f5ed2191040816e71d480969c3b0fefa576f97b2d69f98f764f4271ec86536a5c40e1b294651ebe8bfcbd2a4c251378f176378eb66f4dd8993c11a3d231741719956af53ea89b04f9bea58dda34abaad7ba8b44f00913687bf0b9eaa769d8d81be4434563caf5d4ebbb2a9d8c97cc10000539e2724984db90793faaaae5bcbfb9f50489c3b0afcefc8636e894599ae8d64e72156fc2ac1bfeb9a0fff81f785acca2efc587a263e360049dfa4ff2af5be02f80e2c33dbf239dfbf764758003487af67d13483f6de7af5f757912815c96173ac384512b43ac49861517878037b793146ddf964220ba24ee4c198f98773eb40111985e7dd70748d8c2bd95fd553c3a3d19af44af8aa26faef7ca4a232137738bd972751a8e7f40f67ed48652abd583e119eb2482ea84b3d537c73355f46cf015e215a666bd74064d770239f3f30bbbd47573f3ee12950ba940ad90b1ffb77032d847488698ce2671ac6ec52b7f612fba7084e283db312ac55bef90a4d30d631a025241e6fd70cda5ea68e871d4a13f65dce74f92a5d9de9057d1443e1495811bb1753c015316ad3bd05735d640ff959591e090710373884ff237719ee2f28a9ccd3a370d89ff621e86d9c732503233e7283de535f27e599f60146767fd396149f11ffdb3e2a252ef35f3ed1b1917532810d285db1515e9083f2f07bedfb1a886d1cff9fa8dccd0f3d2be1950249f110c82f8c225f3518b87dccdc57d5d703ed1f97fa9d89f151f922dbfd37061b09abe3617f5e8a6587fec5becf46d507d809433df8a5b2e2d5b11f10ea2bf30ee51a22fd50ecbd852100ffa2d04bdf01b0c6e4befdd94f6862e808a14d1cfd9e9965eec8f6ce4d10f0303e8682928f378cece913784e388c1d2c0cf6d8fa59839a34531bd828a4b08be6d175ab4fb7e86c12d247af0af12af9f76d03da7033e0c180ee2a184685015cec3b561fb97066f8d5f9f7d9712316c251e57e733ca0aa304da0c47c2cb054d66329f41bf8e4d077bd7070bf774597a32befd93102b43559249e071837cffbc1f2fcc9270074620b2645dcaafb5294cda756fc410c12d0acf70e72591fd6241c0daf0c6aad77f8babe37c4603aa31ab70d9e940baa1df4a68208bc0e7d4cd41ca101e1e6435898b315d4a36d16e97c9d86df7d46b8ea0f168b3f36a5173b5cd605acdee4549c54b89f6f13586d7f56bebdbf1b8dcae02f685bfa521cfbe37a7001189476a8fc46c9191c0a01b72815883c43dda5b3eda8346e04c8c2b334ede30cf20b87479df0775354bfd71d6fb4b49ef603fcaf2d278d05d5f5120e4f1d994edb207313ca908e954b34dc41d8b8a8775df0ea5212add9279e495a2c96a1c799e1ea6fd9ce7364bae240397c883539f4f9fba8b448034ac7af2b4e10aeab1086518a6bce9f9421c6acdbbef7d9e2aeb8117100b37cbfb0c2aa459f55b9ec954f3048e2eeb2dfb1106fe04f5fb87bc8c073513090979500ada7b6c661e8978e25b75ec4f25d905380232fbd13ce36da71d011595f7a6eee228434cbb2dd1539508a31c1ce9cd251aec684f03266c63d43a3d0a67374c7dd667bc06952a1e46c0b399015970b213d5edce61ae09cd7185ef6740296be57974f10cda23c0399c728afea36d20a91d45558a5d6a8ecc01c4fcb652c05c6b602df16c537f4fcf79982786610218393de3317d0676026eea593d7744edf64b0ae9d3d3a47be06cd44ea41705ea41cd043c70186ff5f2ebef4af37ef811e57bb724a13fc862eb9a64506c66ba8aa94fcba2855ae4dd279cc5afbf2eaec3ff8e88243d2bc4bdb54691fd206dd3cee343254d11c647da45f92c90f8434ebdb0561b49732ca2ab7c8e5fa57850fa94ef03b4c11f280ba8b3bda61f47afafff5df1d2f83a17b132301c975f0fe9b72c7dcf29fd6302e5e1865e9527c20ac96c39200cf285759eefdc3dd289e9f5d6273e23ddebfe6233f9a8d784e31730c1180c58ededc12582a6ef8cf09998ed451410ddc87dba8bd2e23f17f1fe84af3ecde46a45f275bcca9a5fd7eead4f9a2926272e5acb5e307d319bdd2e3c7cb9dc5e7ab91585e875f4be3c0da13a6e981081907fdb6c6b9785bad1237422e07874bb1016e090c1d720954c6c4064a320fbc097993a3ee23a83b8d815fb9d107e0adb3342bf3b70b52b2bfac804f4f4e8a2f93a6f697d0740519171640f0c8d1593bad2fc14c944affb6bcb3d0cea11ba5e7168452b8785afbec8cfb4fe32880a741005a0635114bb4d38fcda1c3fb1aeb0088c2cfbbf81c1daec525e0f7da42584c7246cfbd8f8282fdce9b2aa2bacb9d9b071afcaa9584588647a2a03496192e54c5d7ebd05f1fbb9943a20369dd4a366ce41308425aea0f50aa9b22226381730fe6a82680a7bd8d9b345ec933571ef4c6e99750c473167684964b80a8ea61d71c77e5c2c565e19c997dc2aba4869931b880189208fbd452625641c98e21516765cdce2d01d44c2bb86b1a2cdcb889dd76088a8200e062dc87886028cf077ccab12e2ac1626e326bf6565d0b7c861706427af5863737d2067e9266f85b253d4f7330a18d44f38e0c38d5e71426965b1fe7f98fecd9c5a9d8c44214f193064d48921dcb9a5559ef777433082f836e1d19e8ed4ea849b845f65a00e3e0b5d64120de5631a63cccbc46d9446f7c822bf3670b7f0dca3b2669cd20730873901f1f1f2fdb9b2e0bf2922f2305e8ade42aa885c5d4bcbd01746332b2c95f084c7c8c2e18a39aec7c4c31d6524ac6d7ca3ef2fd07195b49aeff6b35394b11bb57ea9a85c48300ff506e72f95aa0257151ff78732512e7edcad440c4316ab5b5d0df02f24f36c61d5c908544f2d264139d619a9f32d58392ba336aa1c0e5f0ab8b86513d850228766029eeb571513ea013fda700f8ec7307e9068fc6302230cc124bb8ed9ed90c12487a1072fe6d4cd982f7ec48d596d5c42d74dd9f011ae3ff9d0abe4996f74112552b262ff4eb25b6a54881aa1e2784269f2493cd8a4d0556521aaa0c566fb065b8a373a9899608726a8c6dffc7166a46ba9c4a431908b605a48938a342c676e5fdbdb527ccf99773065a79dbb141f41aff5b701223938d868b318f9056d32291337231aa1f2d2297af61271c16e07b15ec93a566de575383a54e0a5616c57cb85887f8ff327bbc17a10d9acc06513306be0a25784f747dda2c86eb18f7e4ec2514a194d1f01072875e2af6722527326e743e6a8420b906dc0aeed299e27648e4910c068cafe50a70767990c6aed8ba2ad616cd6d4b9e33c2139bb968307ae4b7b7eaee9ee188b47569237a048c5e839dbeb03c6da6374aae55463a12a97347a27160c4ba80e864f878f4aab1d4d62ca4b8e2845b4cc4ec20bebdb0a8d538dec33cdc41e609014a7bdec42e9c3e85b8f7464e1b5211328cc7d450e32af413a8d465b06f8cb2d16b85d4be13f03a5ec7a27065f802f86813a8dd79396fb1c77ba67a4c6006e2f715515d0bd81c826de66210d2971b92a048044528cd3e942f43948748dd29e676e96f9b4a7f2fd60bd0fcd900ec3dc61f2365f0b6f6d0d626814f6dd95bb7d9f94ed2d22ce6f9fc55e531763d271293fb1a5b670aaa622cbf4fc6b9bac225e04c60ca2453dbbc356f46c05e2fd77ce8c62b991875215765458e49f5ebfc149bdb1e8409182b7110526d899a9d9ca7254cfabb00085f0da48c0f004d241a7188e82b6c95d45a81fae285048badfdeb1fbd12c159adda28d7cee6c0b9cc73e59deb7719bc0619aed7a147bceb5bc3c87e51eff0addcb1519413ea130380fd9cda17e7832d8ca90cb641ed3797906807c4ac0493b75f26e61de5c44d3e499760c9d57b9316400f43846a12d74c00243041099ed232e2b3ef6688ea6bd7a868f956cc29bb244814da8dd909994096c377b2b769b327147b0807989845efa8d32b2e72258a085dc471cf567b07a6722e73843a2f84d03fc826f139f380a95c7e28ba47420f22bdc31739a65519fc09cffd5fc5bdc3d34b7fb57c765474cb8ce8d281576326af7367a026d1214b20e951b370731ca109baf3b63743a8321e17fbc8aed7baf2d5d5e9c430220d6cbcec51355aa68b405ccf3f6d4566ef906d8d2b128c2c5d322e923d5ed740964158819b6981074758dce395443db7052e2297a0cbbdfe8749661be9cb3c1de03b399fabe83187455bf4209bf7467f8e022aefaf2df59d5239ec9694c45403453cca7edc9d83768207934cef4d6095e2697ecac8de186b0abba995ce9475e9c34e123dc8cfa19b2a06cfc8d7dc7d5905469ae26a4276cdeadfb53f979aec370a9f234a1fcc2114bfaa2300e17b4bf3c29bbac79af927b430454802e34eebf3886e03ca0a9650bac2c8911a92205e71bbcafa8dcd26d07e51df9a599d2557cc1eea03d6412adfda6957effb9fdcaab8bee664bd41eef0c6ba938b41db1fcaacd41f8c6763cf98c8c8f57d47c6b41ea567efa55a4d8d35cd2aefbf1c1a23e615ef8d03e7e9ca83313c326c7942e8c174e97eab1218d9d9f5fa654c1c3f442314dfff4efeefb0bc362dd77a9c5b1d1f76bf1acf1e63ccbd386e7f38ac79fccc4df0f2f555cf0c3cab942549ecce190772c60cbda9c333fed7543304e9d03ba17fd5bc6ce5cd656474983f78fbea0c3d33c5de8d68e4c689c0d886ccc596dd46e09894d7ef92d2e949de33f1b5d369be74d0130dcea94d3db826cdc313bbfb966c2bf7a23a02d6888ad1cd6fa2647ecbeb8e5f7c25a34f36761edde92bcf0aa7cb6a300aaad8f2ad2554da2c395a8b62cb1e76b57aaa7770d8403e19189fe70c943c0743b52694ba1f5df23a2759f59fb8a73f3007c7e70210cb17df7b1c596e1f649924d911d04353ef194248bba4b197087de2321b17034f6f797bc840abc110fdbbd9534565b95f73b4801ab882f9e587610701395d2f96e39f7964320a221890b958e280c733ed1db8feb89d56154160770dfccdb55de1c1eab574eae434344127ff429ea1668fbd6b44539259b35ce95515be8f027c2b9794cbd079adb6e4e33a3f7c04961e1101549b4808be7b6e0a913972891fd3db0bd61838461185d6f01e92813b0981415b2128b795935986b6e6013e2ce80367634eb148b17032eca4b407a020d70859a19c0a001495f8bb38052333071c942feb607cf937d0a4d29e8746f731dd7becb23da1376e39075e1beeba9ad97bdd545f3c2ff895964faaf7bc77599509f1e57df137a0b73bc3f3120c93a52c550a101c55e93753877552acbf23ec28a4bf352f692dd3992f8f9c5381ec10a1d2c2255bce31c40327d4b08fd466b9fc2bd54af6c5b619e9c056ec8ad7486c9b848f3661fdbb9fffeb549848fac4b91f0d79d31bbda9d2094c643f031968a4355204b9a0720198e31b66de05c0420883bc5e13e808369eb1bb30060aefe35e3d2caf4cb581cfad4d3357eec472b60c9ba06044913a6efb3f0b11ee5f3b22ca5ec8710ebcc4bde1f9e1648d127b0a743619216557a4f5c28f8c3eedf36774dd9d47e28a493a91be8b3365f10560bded60d308576b344a5115c7b8df8bd69bbfed140f394d5a462f6b30bdadf5a9092e13cb69085d3739645db366722b840eaf55a52bb3f2def16d22984e8e259f2de9d23dabc7d37e22c77218285da838db6d4464159d7a23e8a7cd0a19e25b08a41ea7a8bbcf1154d11155d7d8b8c44d0ae9e6e3c6eb9913c67d0197d828bec0ff535d47c73c8446304ac677feb57b0c6c4d615f3ab26afb6c6358b7a60b58f34cdad4d29eb567adb210c5a929d92637cb4b58b8e8e0a5d37713ee66ae5ca5b85a53d0c5437aac0d9516b0beb31cf00a462237c31eb5ea552abd9c60616fb24f71d8287d81f38f315dfc7926172f0c9354b42406276b399ec5b507abaf76de3f3c31e489ee24aff0156336d42f6991bda58d2dc9592f74692099f9db6b11d5cb5569d2b09e16a2ae99269a7201c7c0b2130e9f48c4916c39a8c9ec97e23efab398f12fbbb151faa07771e1be6f0982321283895307afa29f74908f40cc181ea195dc0300d55e9dd9d6e845f4ae00f10cf83c16f2484b99642d255a25834c280430c082acf4d7c6ff2154270be4553949c85368f3d76a81b26de659ac8ad017f131ed8921ec529ff96d3bff801b2e41ff2b2797365329f7253d5f2b408a034c9ef15694279b1182bd35aa06356066978b857f2f6af19747684edea139658f6968ff0bd73847e2a5b70e3abc3fd80d792ae4f9a750d69dd3e2116756789267418e3ec12729c7df4ec5fa8efc6eeefe03413bc474c6773303f3cb18cb6da2b4b79f035cc06ef37659456a8865969cb614bd09314b9c3451d979ed54d92134111fab7de0a6a1e254abbe795128254811e2df8235c2289ec901202ed2103809365d0cba401697546744189331997e67eb22c7a563e427e2201adfe94521ad024e0e1d0dc1f1290f6cc104a0fd31b6cd1ca386aad4e1e1aa1a9f14125f3eb755459c20cb6dc21c91ccc1b3dd4c3aa0d71e075cc9dcd1aa2db42a09dcbaa37e0ff9e84fdb49530779f5debc35a5131ad485ed8aa1394bf32a33592db975358ef9c069e73ad48aa0106b191c02df8deda9e8c1599589038780b85c04798945f789c0cdb39add46192799563e56e81f892c85548bcc87c98b9373df31f31600828acf3b5d9500f8ed6347f4e3d4f92db18901f3c6f13b10abd4d4302d57cfa93deb77e0d763ba2422b0e6be0b19275c4fd5a5753d908a1f30f87e7d6ba3e3ed2453ecf2cca11472374df97e7debadcde486ecb998a757a50b1b04d6f0fafafc975e4ba31023e8b229ba3f203e270a9a61e4f3f598a8daad48ff114a84babb95ee5be36bff8bd6a51cdd1eebcf3bb542cca8a27b9b85432d6be4a410505f9f2d678d4328a48abc61caf9b33817534a559892210da2e8dd5fb1e8003af302367fcc5670c8c4af0b93dab5322bb05f7d40c0ad1b846c788492fff01c8fcb5957c58c4618e9513c2b5e60d4de5ed7bedfb49e7fe41f3bb4203146999fd9fc1e8d08ce965df1074e980c0c8b99be58f8771145833149b5669782ef36035e8494ebe55311a07544b93c3bbc9183388578e8c02688511a1a72b3f8e050d4e0c9c4fd3eb864fb2a7d8082a5684261a8b9ec4f3ca53e78b83c2705233293051604978cabdc9b739da8ab90a05c07254afbbb267f4929bd5f0250c76d6739a25a17289e9f88c822f0f8a3d4206210e3a00dc980ce6448ff9e424a69f9368f02fbce7e7914a5b6c7aa78c45eca76a8833661a6ee53f2d0e15cd018a6f60f6275f5d63d0599ccec297224a7a5d4205a14ef912258fe8e5046b966a3a12e28d70c33ccbe189ff1b963a794b2a1aa42de0e7e60d2d6ebcec341bf92fe85c319618767fd2191ecfec701833c302c8940d34766b3e32a0a89fa78552c98063ed5bc0cc500a10796e381ad891952b6d1c0e9e73daf51aca7de8953a1462de750832c0939f833bd51391bd611411a1a667bd19096e183f1a59e881a5a8507f26d2e4c7f7dab53ef834b25e951a7420eb50103d8848936ca5c567024b361c6726d291fc49ad0907f464a999cb7317417b8c88c601aa5b5242411fe74d96954f4d9c6fbe676ffc7c1985644cf6ca6101ec57c00f0a204d8f18dd94742860d9505d228e5cb45e16455645e70223911016b002d564b94dd87e1b5197891850715526c500972929549424b525d7ddc62c671dd1cc51153bca9edad93327b372744d2eea2f8b9d946a42bc8091813504bb76f7ccd6b60615a50201b956baa3b2640aa094c623c1b0608af29bd546596630b3cefce8e407ff1289b69b90700add88bad2faa35ebcc560704f2b224898eaf989e93f28cba24611318fe4dee7d513aa28e38bdc1fd372260be4ee42ae7d76ed48493f51f3474827af185b6641ffc76efd2e4dff3259797d20ad273b51592e32761969f98913fad93ff1c4fb051b01d1ee7a8f12f690285edb7c5d24f922223d8ed9c94958b0e2f814d142c2cbbfaf61026783f5e768c94edb36045e48bd67caef12e0ad707feb78463fe1528a5d0491dee94328af479bb15550008c4f6493c144dbf4f6200ea2ade3cdfd31bd9626a43ac48578625e76221647bac72c65f68d7a836bf0b5fc83e29b29d0fb62ea03d70cc5cd0c51560e63bbd281db2ceed39bf16adacc4244be14f6517fb9ed656a8b3f01ba14d9eff27d76697ffa74b1d5c6d5331591b394e95b3504162c165c492f58be8cb3b20018dd1910032d1d41abf7883f33540d75edcc8c75bdd8067e0b378bd2a3aa573306418f034f9f61d2631dd3af20dfed1ed51ae01397eb63726f45d7e9fb206bae1384aa027b547b994dc1d39cdaa54a7312f8a14916ef31cc8f252e77b94693f767ab395af82ec8335c59f65b5a7c1879a254dab9fe250c46addd9ec5ddba89fa0180d953859bd4c0debca5eeee44127a2642e6848c82f4a7152ab347bdc5eeddb24ab24be1c489389d3cb40afbe3a7da3b97f833d925257d1b86f820c7892cca736c923f5d30cce97fdce946b85886816b543806716e63b20bfe931a428a6d7520b9d9786011e7714d5609e392210aeefb8be7f02cb4d3a3f23053dbc0aa605e6a8b1669ee6ec191f61c9b9bc2fc273e4a0380363c11d38124e75cc7f453523beb3bf653b1002ac62c808ea2d7f8613540a7e080f3e158111ccc91c928b94f3ff3acfac35804ff78a09c025c09ddf42fd150ddd5891a7e38a1d3bdefabf36b4a7127488367943c1a0baf30fe01baec43bc6b679a07f18b7cedb90220380213659892e87d26dd7c8bbccc5101d4fac2d117c350fc25f447dfbdd0baefd9c806d0b1bab9438ef8db9040600c177047d79c55916ca698d309674ca4bde177962ef367bfc6a15ed4753bdedbcf74899616960fd5248334edc92982ddaca56e8bed9ced97b21f46b3d19973f869b3eb3d82bdbc686dfb96b78d8326e92c8f587843769b9ef25c8cca180dce231c31865d7919efe377a0e5c95dcc6d4df6da7de1e249c071c8fa458ab74189f014e46f56b0d0f1ca1bbdbf9df36cc4df40afc4d1d91b5a442ed4805b92d0ca7cffafdf6527009609752c10b680660c5246f4c09ea529e883ceac532dd4c6217e0c0c8bba6cdbcacba09ac8d314d94d199d90c87c80d93b545a4918caa22685c0164745d13dd26a769d096ebd55072b36edbdc834dfb48e0d0cfbb1e90908fc44a29c7e36c7a77df51a0dc0c034d52c7e586db48ae1b0f62f57c1639cd5d512a5efe2f2a936b1e29355e4857df9c301d46af6d1b815b1ed66c00b67d98f42b3aae99792a03abd65a65a3dc11aae558db371d4157f8ee43db530b22cf4e2094f31e7a1cd946d30d6a6984036b1ac700a96fd6a10181f5ed27f647df1aa70fba7a68526704bfbefb24a706fe605012594ed77baa091699c92b9773075ffa4883b1204db239f690d5536ae54214a4149d110c07beda1867779534d8a57508560b661d7ccfc12727062ae610d2453f255ef677099b0c2d4901495411a885b071bf6a7e2b7fa5c2b5189d1c3eff331900ae37558b2922fd4cb9132d910d58541c1146a984c0632be9c6a6133cdb7bc2f5c81902899170ad78077645f801270d32fe9582c8ae6707aee5f01298d90123862a11c16fb73a48e9a1cc3b090015e2bd22284d0b3aa9571365bf5f4ff8f93e8300cd843043764effc4bcbeb9f7861d754c231f1c8d9f9a9b9498164693c27cbfe0fac1f3dd13695ae777a75100f28e574434435bbb1f398dc6596677fa6c6c1e8d1667c6c70a9f46f8fd0c0c600d5cdc26af742c55f293e796ed5b0e0c684a3b77a32011c07b188432b62d49c9fde1a9d0efbc2ddadefddeedd44642daa346605e5aeb4027261b7cf02d3db64e43f5389e326021bcfa48335a485ca0adcb36d88b1ef636c658f447cdca319d6a667198d03e4985de79f6c66fb46fa1482f398f6fc1df3178f41bf904d94b094912153185e0378c7973495c7a51bc332e7354cfe12447af8079c493877d35a579092d68f51226a328ca7400b4683b2db66ba69d3c2494e6c04b3677b893da9bc03cf6be91653dd77405e0156701aa3c11f154132e18b36b75fee3871862a6ba50e42b4c1e3cd79e2c0bda5feb04eb3dffc45c0e737e76e769f0fd025aa9417154498c29508bf13ca0e4558cf0928f551806a310680bdc506369b821a11025c88302917350a2bb14a08b43fbab8ab941d9936f6896ffc97c410bc2111143cea06abd66900287aaf8321aaa2e25ee4b7a9c2fe782f9b168678b92b0d8104a1be712f2ebd9fd091638ae87b48b72d7d9d2fa9a0371e85ba9066b3bd31ac822c0438d942d9d42a81db9a13fedd5651c1d58fb0888ba9a2b64a725a12dc4f926f237707652061de45a69b622a1d40b033d46354da73f37d66c67ca93204ac842c6031d97271ca1aad0146d4fb6405b3240d91a2ea0d00d659a0321ae54b9f3e5023f1f1da05ac6e2f4873da13c65638d014b69344d17bb1048a043cff161338d20ca995892a8b569f6ab58dd3b4d8fe720fdfe85eda45fe7abf23b1577c3a55d8838aec548ad56e94747e9c05d7f1d2806a06c423ac61459cda9b16c6aee206c332e180c2a045647e3145bcf3ccd661e5be96a4c958d9d50b46363ee4a666d075d8ac81950cab6502b86858e46c3f10bce4d05b2387f8ce301dffb0556c36eedd55a5a7815f0cea668c73ceb95c4aa7dc684762dcea32907e2700a236c214499f4eb313e7cc3a5ba71d1d783337c0f6d87dd4be1e53c5aa7dd596e8564dc642c6c48f05767c92186e640761ccf83f702db337070624289ae968b5588181a254994b9b29553fdb128e879175a523652727c962ff76e8eac9e988c9c92a2b24704220a6a8bff102d6eb1585cf6c6d7624a19616708d1e95643a3dc194303f248928ee117614d1f370398a4cfd7a5b8e34e60cde907ac947d7025a1b8916e88d43304d144260cf9ef625f9dd0b11a7a492bdd0ace68e1d70cd2437563205c4ef577547b0d80de4649a5af212a1da55d7908c1cdcc0c75837b15595f69276711a9e1373d29c92cd14710c74d8aacba039a202f7f43194e9de8b0fe9270abee1b4f3f18df1c860c81fb17271345406c3866be614db2b9652d5ff2f3fedcd90bb4ce73d7fe31c2de6bece09c22f2a379ae9e8e730f7c722b2e72221e620642c5121fc935acad4a661a7f9f43c9554b02b3a7e842f3668861efd1b3cc778be00b1403eed6ad30c363c6e202617e5aa0a37bc05333cfbc1f344283817a003feb343da63173aa3ea5d2c7b496410685972c440b0df11ed2e929a852f49bef57fb20ad0d2c37ab82b6195855d3747d3b1affd1e6c67b048df6f882e9048cef40b9a39dd7276fa5531842b2fb6ed9f8c7fb1731d35b199e9386501093686524de56afc2f0872b31d146dafdc180ba5357730e97f5c6b49a89fbc5b634d91bc7db0c59c5394097b3d5138f10e0f7221b66376b9af93986b5eddaf7d043fb049a19e7571c6233c48bc81d236e21b96a79b01900ffe264bffdde724a64d22fc62cb024cd8ba6dd60a625cdce4b17ae233803ec6bd132de56a63c5be5fd2e192575381b6e761a53418b84ac2e2951c1d0b0bcef050104756b84c15aef40661e1833d0a384edd9867cfb7cb5f2e3b2b80aaec9eb8a8444ecaba22322d839d8fa46e7b9db1cdf5b9b685771de8d6c7495204b6add453583e3b239c4c5151196a552e5e57dabf474e05eb22c9d436f891aca1dfbd7ceefb99e8c431b1fe8b1c26717dff4eaa22645519d53759c82fc31311e4ff29ad2cdd80c73e3ca7e231b90835cf90fb81165fb60c91a75023f7d852d93d904846f7c9bccbd0f703b7680579f3705d601459f352ea7e54e177bce5ac6675545af9a722777bdabc0c4c8ab8dbcc487b8b4551645177ff945bebcaf07ee294a64dc07270720d63897c612b4129d42e249df22707f00cfb75b0a4227c1721d9a2121d09a3817a48467789d67043c205762108325b752f3d7686b3e93a4a07f673be0945d67f157be6490dcc3d5cc7c97c0d436b0d2f05b523a782959a1e000e3050a5fd0d7c292c17e042c843cf7dd93e357dd8b430ed9c58b551721c4274055c01d48f77d71ed9206a85181200c6e840af0e4dcbe5b2a50b8955f4cb492c54538c9ccf1c11e4a8c39edc72915e38533e056cc0fc64f9fc2bc5ebb949b17d0eb88cf298862b765aed79c26b1771db4ecc2952ecb3a8aa23d051abcab82efb43d8a1bc82dd5e064676caead20817654b992159e0ff302ebfb879f0e6b8f299ae4acc98a139e98601ac59491f1a15d11213e9dc9f890a616da0cee60d7cd2002dd8aeab9e3eda015db67adc63648fed3b5cbcd46c22fdb6ca0a5601bf6372515bde8fea37c80ce5af6ab3ae2b874fd6aa6f86ad9b416302d3778e918a7fcc6b9ebb384616f9d9ac8e8ab3981f131ded0bb4c0e87487d88d8f61664087973b9b0081e13f5dfe1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
