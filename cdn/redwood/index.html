<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6be55a4ba981e85d52603e853c134a092be4fe450813b39b20b84f70812c5ffa540b8aa54481839be03680c3822364102e4cc9028b0d482c3c7d495d2f972b548aa6b0f74b4e80153aca63f79722f6611b727b5a95f17b7078094a373a03fd746ffdd453d062fb8d8e634af81e4d5c86705ecde2f0f70a24fa34bb5280fc42122b489e2aea644ca5e2b2f1c874fbfbd1ea8dccde1371a36e864af6b85cc2850c07cd259eed8e305aefa6c2428c04d2dfe1dd3aebfd64adefab1078e547aab650b449014baffb8ef568582e778f69988a24ce502e549e0cfe21e8cb4d092825a973e063f812b377c9fbace954dae38e6c56d0880285c2a0f4264ceb607ae1ca505d6e2cf5ee1e65be2880120a96c0a15cf0512e25548eca1bfbb98d359ba670649f3d3857b61d5fbcf648d0762f81a9b9e2c2ecaf5ac4ab79af29b483fc557412d26fb7b8a7585c2f3ed17af1e8f32f3978dc63e5fcec90cbe5dd0efe8fd4bb0c32f6a6eb03c46af36bfc44ea3c6761e4edaeccb7e4d63e2e5d4c6b3201db231ba4fb493d5077d23296d99899fb2c64bcab497080bafee8051044d63d5147acaa6362eca1e67ae93a073f8e74d75e8f73eb02dd6c3f3237cbb5bc788e012a61abbce6ca1a9b766c4944c15f8220d3a27a73d79a1ad5bce90999cfa6919f49b5ce76cc72af6a207f367795277f65a744bb12b7ec933f169011c21a02b94fcc31658619aab312a13eae871cf163611b8518e088b6eed18ce30f43c8d488e69075c89d933fcc419981fdb63412f3fa6b66589126994612263c8dd1dba0b8f7b5b942939352814d806bf940de44a37d357970c3290ee14dcab7f14158ef6e24389850fe71de9846bd30659f2f2cc04a204de3462554a64781b25c881e3330d7176404a5ec61a39e778e89fa1cdd4f23513a18e88af6802bc44c06ad01c0ab5faddf24973d8039c560621636ff065233927ff52f532236307da2a552b2f549f3a146ac647f112d76f665c719a4eca432acf871c03a39658ea9d1fcc7f1b963659db5504f23855c9e438f4c5b13189ed8b8fc5c9f1082c67b6939fa7e9b1049ada33d0ee94f3ad357ac50d4538f04aec53f6374be407906da832a4b1e490e6a89d22a4795fce918c475b044c09bf0db12049b4cc856e0712f3dede34c96faeb234fb2a93469f8a3fc260e402e667838b98dedb533581e74f504121fc129e22324e752c71836fbb626e65a3e97dcc511ba2bd95358d4467405ae3ec4075510c0198b96a0e40f44a51a621518a5a8da45bee07eb9907e151ae0df51ba0a14556feb51417e4cccccacbbf1b386c59ad109c2d45f2e5d215e7d465c2aa23a75f5a5ae719c5febb88a4a65d509cfe6a076b7fc8eb5c051e6a203e087c801575ae9a7fdcb269e83d3df51f21a799bc635d67969c3cf6d60471a4e93f13da009c39c121ea9b1089825fe8fe0f163d13c618dee91843317d341a15d7192292cdc853c6d32ef8d608382ddd94f3cf8ba51816b3b31c3716b31719faa1f90fde78c23801e0f3e369bef4b4edab68d5369394ff9364f6ff45200e4d904ffc4923df2ff9498eb97656b1e9fd979bce1e7eba94f9b66f3e303dd4d1c7bb0ff60f73c6d1b6bd9d3b1f83b1d1247c464f1caddfb092ef0ae8f1f8db6eb42c8299853ae5ce37f3177c1dd935b3a08f94ad5d51439200cf31b8dd7e38cdbc9138552a4ce8102ca16be6f304b4c790e140a8e18725da2d9a25c716677b48177fb00975c97baf25fc40442a091913ce6f61d49d18406f683f59f7c9095d93f9313995f3462d884da024df8e8ae609d762efa64cedfc8152ec0378f28747391b950a42c65b7c5889e6ca71a938078fea57d42113f83359bf0172a2632af17ca829577e2784047f8b6c941ad765a5f8e95ad05b69a007bc4955ab2f954b1117647b097d773999fd8c5aa839969e4517360c9e2f96739fb56ca71246e74fed457a1bdfc0f5290627128d734c96a0c0a92ea37b92dc9ca4ecc2fa264c2f318d6687833699c2ea12ed483652ab4aca826929a00846ac203168e3e36ca172622bae120e3a50d74ea688dfec4243ec5a7f407fc8e789b7dae92551a339a6675c83ac8e4848b11e68ad42f641ea069c0973959d1d3b0ff0814f9a3b8de8a13791a792065f2dec932158521c3b7b0d6cf3028e647dcaedeb32d6ef0618ecd987595db9a140e5ab97565584a4374279a24e919807108ce5d91b1b356552a78fdd2bedd8c919ac2e651076691fcb7bcda05e0bb15839dc7addf207c2e3a27d1cd795bbb92c75a9bf7d5abb436437cfd55e8d5b6ba763869b9672d8cded9d3eb4d2942f89a765c05166ec1a6ef43c607a8d630d9464b2f00d40328245d116817454ca979123e711571bc3c19d187cc5275e59682adf75aab886c013e88f20216aa0ba2565efe30079e18bed32e741ffdc05d0095a46282169aced3671466b264fcb464e3dcfd52aa41c7d6c2fdd80f991dfdcd09dc4ef0d8cce8c5896687f9c0b79735c6c34494d1da14d33586dd40f05c50733f461f46b2ea118168cc0473b51d24904f13db3357b1f3cfd11ee02fd3b403f6e42435c5f6d802745e0761b632531340b644df6b12ac30d2360b5aecef5cc901f1a52edf31100ac34820c2da9d24b37e403248acaea0c4919938796ffada4b19500331bb7e323dc1fb398c20246a6912c1423669c0abe79e2e23981d2489f6c01fb036651af5844cc3f57ca96d1f93db2706c18d95aeba891f6ae02e0a7687dfadb1d787823e4ea996657ad49c409bd405a0dbdcc3e9d9fa1532ad366a98c2399bff5a03e23549c34be8e237cf3acbffb2a79b3b7a14571b1cdb7a63014ca51f6f188d93ee4231ead4f81832f7ad05963aab32e189d11f7462ede3bd32af88a879830fe264e11874f7972f0fbf67c2dfda1d21f425f5ddcf3fd9e8a8c5bc5af23e0aed38fd51721d8afe28baee04c470e7901fa84662fe0bc5e392716b11b79a2a2f9c41bbfc51ea69b3499f444197e5a0d9e67a04964953f1776b82621a38774d4c74866a006088a5a5261984f01d443c30ad9dda328a93aa13bf18f41f7dd4bfb01d7c2a05b012b981a8b9064c9862567ff3aa7bded2029002bf4a7b3853bf6bd20102b768a658b284ff63f575c89ea836235d1666a06e19069c5ca182fde6dc93be38a45fd81326ece089d1a6fcc9a0281edde00c043a5f228f5d71cb3fff64b70018320e1cc80b800df0c02be60d1d74670eb9f6f9748d92428e0bfafbf2dbfa04c3e18c3ced7a7cf424376a2dfc7d3cf649facc5a53d0fc30cd6e0290cb18f2c6aaf7224a5d642ad674517438c55e16f7608fc0fdead4568ac036a25a03cb827dd73814893cdb97061ecec1e9d77568abe8ccbb58261984135153d0697c838a10d71bfb4f83a9bf40e50ab94fe1bb45bfb9e8b1129257549d1c44692e1bcc64166f0a21f5debe47772f0974fc94b7145ffc2b695042f9e208ede1f74b5e97e99b8142d615affbc56215455e3c436654f4bc5975a25badea5107b078064f457d87f180f0cbd7f989884cf2c0aa88a68fb2162c2a63e7255381622134572f9c695747aea6eb20a0d980e7727871f5dd39c5b5148db99e0dac218f02fa65b4fab467d63ef1c10be969d7d2eb055e60c878fc79d5c39b62481047850ba90ab32e76c0e858fbecb89cc16f866941ac303b5f458e2e7e46977200960cc17f37709a580ded34fa99c7c0519c2a7e39ddcf2dfb011d32095fecfc906294537c6fbd3c2b83314e50a4016890cf41a91e4673de431954eca4a01953bd9101e154f0cbeb0ad88c98282299eca0ec5cea2136613b7ff674ee969e600bec9fc39e5cb65e1883b3560fad56ac6fe39f73fb077a80b1e296a10338fbdf2e405edbc827a39fbd300d284b7ecf7d9bb418d5f33b2e8812ffd9d1329a156ef65c81544c93dc086d4ddea62d1b2edb9bda0f9958e47106a4f8aefa8cff99918c6f7c82d0a68a56917ac8bfaa4fd809e4667b8c0cdf0fd7b4597367f24a4e1266767711e4ecce2c765e7dd311b8d5f46ed0587e029736e93680e1ade85379de319b15ed5964e10feded1600a975a9c0f385a65072a01f8fabfb3ac983e314091bac046d55d3967754f035b4b374ef7427ec11a5497259dfcb8587f01c3100a3127013472747ba7830db730351057d464e717bdc0624e531c5e469d6eaa3a4cf4132f7ce75ba2e9fc148b56178eb556b64eedbcfa09ef4a830d292e91c8c7ee47d64bc1412c74e98b75cfa3782a272e154be463cc9263d2b8780407b2a9d5b84471bd0678da85acfa4dba75c04b3f15bc131ebb46f7dc650b33dec8d57aa6e85d984bc8a82ebf954f20565e2ff434267c47f3081c32e977cdf6729d4a16b97bd2ebe45f16fab9305538149fe4ae62d5647cdcac0f83cadd25b9a7a2f4c56cb60c00e3ed287fe0271f04aea0e6c819697bff3f25e368c298bfa620ccc58eeb27552d91e7c970b1b0bbcea1501379c558a6ca961df376ac1def9d840ab9ebd4f523184872364eeba9bb76cbdc3885e49e96caf7a3295ea9f5587c6724f65cf4da9ea4bac0a2b7b2e723414de61ea106c1b7f15a4c97f960b74f418eb1ec04c8e0e7a53d651f328fc5cd518353b00d0632d5e50c2246eb3c6559f5e393766ed9e06ada975e070967d391050b7e5f5f43d1f0d8b8df3af926874d2ad8bd3444937364b63c6c802d76dacc97562145bdce40a4e5bace43cae6be332a7a66772b9ef77873988a96fa597c54e7f5686433d4d2903403630b35b2f8e46ed860ce884a96aa602cb57e497fc79e9a66e26e4f87d39b82e496ccde976231953b83631e9a243a9589f37c5d1aefdb11977fdfe710375e0360a863a299465f50f018b7e7b12f4b4e47f9ad98f3f4100c04dde15c8fd3551bc958a7dafd6bcec7b9f5e73a6b6c69ccf130e46660de891258276a0720439b868de62f67f3588357bd4b019d958d4941653817db4827faa9a2661fee6cf45e2af6ecc417be90ce3af938c9bfdd81f9d909b87e2f7f5df7eaa0386c1a5054f0848778a27e4eb86720fda11c6b77f1bdfa642bdf2a37abca97b286a6b0654d6dda955f0b2ba7277a691fc0131853968e85818642d0a671f6c13bc151a443908e1e39de05f6643aab9b67fa337307bb45ec260bba80317081d6ca67278152fb877eef34a1ae0be984afc4b490ea976ef411326b6b1b56e4644b866e11de7a67a08ed5902dc594eb2898e6c208a56d37046e6219c8d5d536205056d5d5a6c7d4f011137c7995005c5ba191c3941e659ff68a364dc6159252f3167bb9aff9e0136b11e6a7d228a6ff9cf2247227237160558ee68d81d5a5b16a9d46bfce69bf587635fa5cd3f987ee675acd0cae8948be62583711efb960cb5f46b99cccad816aeecc7dbbe8e7ce4e9481d480ba26fa30a8183ffa2fa3764cdd9bcd9fe8481c3b7bcca601a3614b847d2eedf40fd06fd1cbfaeb5b1aecaf2370893cbd4358265d1366a60b4e8d5c00956dfb55de838d8b42cfd550cd8af899270ea0552f83458dd65ef934f42e4b0bd30f39294739bf4cbcf3499a1b1447d629f5f221de4f6d89734335906a4b007c72ced4dc18a58ea6f0069d355190bf8fb3f1caeec2fe482eb8c451dfc1df479476c63f68ba009eea0a1c8fba9054f59c4eac346c99884099824b7eceabfa28e6bedc50c8a159e6311f9218d52488e54701e74078c83d374e62ef5e211e65acc579f0f4b09bed8cffc040c2445b89994694b1d257d9fca495ceff5f389935cffac7459456d88badb87a643ca44d3537521f63430c80af9867881ea28cc44d7cb9522066e56056a96b8e64dfe429ff19b93d974f20b32d0db31ee3ecd04fcea3965749f3a7f647ce2d6cc878a32790a0cb9ccfa65fa6b3b23bf15d4ad22be6e10e2523c4c089e814ed71307c6fdbde346c8fe0841104dda5d30222cf6aa588f48582f9bbc63189d446399e573a76c33c332aa5df0dc2d5055912e442d6aa76fa30834129a4540b901623c47ebe4920ada347556b793722c4a074da793b0949b19d9a5cc005f311ca9d6738b1961ea155952a94f8e2727119932a5d93249d8c4a43529f0e9c8233c5145f51fda3bde6886f1c8ed21c9e9ed9126a7533d9a7566d38b3650f70a5c327b624fc428cb83da77f04d9b7b82c8d695681d42ff01cd2255cdcb916c4ad4fe24464959402a3e4c0dc9e265b5f2d056a6573ed57c8c2f951adcde7d648238f81b57001a2ae3bf9fd030353ec18ff7a3da4f980a437e47a8161a0301b9fe94767658c65f80a464df7cc24097ebca19a6d7c98d72c3598bb4f10a3ebb20f900e05593c77cdc8779e01857abe3d53c54bf5b821a80426081dc88dd207eb9859e8d9e89a73139f505439fdedf941caf522508aade810fcfbd60cef21ba382f0b174eef7d9a9e676a31bad42228289d709484692796e142d9138c1dd89506d0584a74f52f0dcf0b77eaf10c8ecd9dd89ad54214749f84a2fe37ff6c559d4deb9e9cfab0ce828afc68043020e060f552af685348850e711ad3cd7307ea69c85521f2570cae6e0fb59c059a26fc9a4a5e2165cb4f37b742ac3555fb97c0422ce2b68ed38a602a6dc822f5af2e0f0d9aee9e4e16270a6be72e1fe003fa93d64941fce9e5db722ae2aa3032aa336dc7017e52eae9428d0b17ccfe9122281f20f9c53f3093c3f53d2eb4c213dda8b640e73f1a5ce2eff8d2c3459823ec388f45a7cd983ee3eabaa51665cfddd587c9b1fe2323cc40a4ec381103a40f9c38d414854dba1a4a590f8769f2a75718456db22e4290ef0c498106f7a112184ad4695bd1b590218548e57217f9275c06c3537dbb2d72d9efbe653af2662a0f421b9f0c28ee150d8003854e0b167bae4b0f80a1de773eb535f23fe16df4133eda933581347cb8538d4f01de4c540e7b7bcbbb2583f4c8e236e5a8f9f4449f96901b635d05a2b35f4214e1e6811f6be92016f649ee69ad96abca40076abef5dcd484a33d46b514808c24df95c729e0f4bb59e1238f6355d12f745a92e353e46216fa57c3d3a8223c4f0e4899cf45ca422da8075afac8e75b9ddc4fd990e8c925ab0c34d6449b6927866a29e819f508a7f2563c4e5e9138503b8910dd643e92923b82c403ebd321788f2663c921d7891788b7d7c4115dfe56d970c416820dff1ccfb94772bb6e1618bf7681265235245cb61bd88c6507c87ed7328c2f0925ee25b69084d98fd156dc19fa7f2e10b9a2532cc143224a92b5219aa7fbf8b185652b7abb7a6aa8fcbb7cb94deb5549366f9b4a37c68a870dc9366450de6d125668a168682c40c8dac4dcdcd3aba8a3afbfd48f6dfd87630b97dd40d792f54356234729f4b296e91353794d019a944d495a9c78c7c49ac9b4307acf0d121a7730450910bbfe9eee016b284e5f76fa9c4b08e0bb7c72f1b90d18f97380e747e72e61e588114601a895f0a7ea95f41174d28fe092f72659d50546289435329d7979e8d3980375a0d914a2e9d2e6a0161dded1b60043ef707adc286ddee6f7f69647bdedd7b774831b32e375f3fb418bd083d7afe8298d5d0f3bde6399938fb680df3de4a942c3e943eaba7cdc4ea9dbfe6add60c3983fddce2ccf0f40d7bc4d16d36e256f6be966521ce45a7a7b0e67632f3db857f96402d18eaefe07939c8a95117b7770423822f1ce734438b9140b7f83dd90e3177ec786a5fea6c913238d0c78834ce75e460ec39ec67a0df6885de799520244667e533c5ec525695a512b793da5de7a5a79f5b5bcfd226af00185f23daee0ad7ea298485eae5dec19462ad6a4de556459917b7a6ee5a65cafce56ee0a6b491dcaf0fbb8da90910f006b677b1cce97cdcd8fb2a347f0f31a29cbf4060c83dbb4db763d6839828ca9c43aaa3ec2d93f6ab94a717cf28f755d60b52c7ab4f25a649d8f587331bcbd59fb614c67ea892a2cc9beda1cc21151c25c339459f296c727c6710906a52ad52153581fadf51115e7f45ad5fa15435c27286e31c03842d922980b500c7a64e6c0b8e4559b3f04815c6f47c892ce7afbc2becf1078701e459e14d5cb78df7b7959904a54344278b8a001f5767545b15be54f95b1ec4f2b7af0dc636c1f55bd24d17db6c0a0765ad07111210da91b33b637ce88ce364026e5c21ec7c94b1ee4bc03f33083e12c47958dacc1e42de9d13238628a1cbf12496f28e49a6e8fcdd842f6a28978b4ba8d76902d6984b8b55aa0c81ab974e7732aa222cb877b4ef6ee95a0c525864d896d29c24a7ab52535a3dd9f58fcb004b7ddf93861a0958f8ce6a77a0f9f60df93e26481be766270926de47054c0bd6af53201c8e26818dde9af4c476a2c42a115c98fd42ea1961fd5e6229db1f31bcee9347fdf5909612861199a196bd05256a323a412dbd90ce93126bba77aaf477afc07a9ecf7a80b4debf3275413f85489e0cc247d31da866edd6da1f1d3efe4990c5f48cf78bcfddcfb4da82fd276ea4f8fd16a02614fc625fad54eb9be976d88e2fd3f7bad1ed7b826eb96584c6a5426de200a15f4fe4630f5e0c75be5d6342f79dc7c59c66dff363af82274cc50e15d2a77834f4be368bfd34870708c76b481253e4303d2c5650310094c81c74bd44da68ad6f8fba88a84f3eb11fa2c434402a0e902e1c475183c73998e5dd2edc6202a29c63488a4b4568437b44609d8acee20c8daa9f13ab1f8078fc0031b6f7d2f475a4b9e4c89e6fa71e23c16bf14a2949ee0dff8efbfee000f656cee73dfd5a5c28fe7afd34336e6221c6a255d431260f9d2057188444d4382ce74979de84fdaf0153a009807b8b4add1d2f7a43bbe718355a1e2938a26575a6ab87331958840100c8a3b3ce11531f782babb0119a1f12a7c5c76e22c9fa7a43a84cf44cfad2898548489f614b482cd347206ce1ae7eeb66fe8cb62efc001b85ed666a22339c3a03b880251959ac5247da6bfb848a6a47b85b75abf3d0cae07474783ad53b9643db401bbbb116d85c28cd48da42f527999b3a74c87f68f9f5e277698893fa2b020cf3a7594fd594e426c04c4492af46e146110f81cc55277fa16e471c7ca098a3c587044e176fd960f548b96058c9c6dde590a2f794427d69178767953d2f219f54950c85565871a79ffa25ae9f3b2a11b4eb61734d455bbf777876b666c240fd3a64f1ccacfd9955338b91b05946659761444af573854ec1b0ffd3539c0327b239a06c43a1c0c71513a298a36992d73aba62d67471cc05301f632f7a4d8a47b4ceba5441b5c5de12945b6bb018fe71a9909e96eadc89ab110e58ee8d8ac96faa9bf8a82e77a4880ffaad1f3121747cc6fef91b201a22dc731d9d6832239a7f128c1132664c242f204984eb9c41526c0361520eae7e9559ce0878ada946dd6d061a2076059500e41245160045ca85ab96c3514e47314d5a505560211ee9be18661396e49191cc3b4057983b0c2040a59a6da2d9e70d9172927288553de58e1ec359b1760ebbaa81b1447b7e6039c2823a5556864bb97b763df91ab4dae7f94923afff5507e0816e33d388abc8073931f7af1dd163d36310a7dbfecefaaddf639447066a8d3af5f2652e6404b6002fa1c62b0886e99727c492d641b28a6ca4b4e3bebbbec2194786af340ddf948143b819a91c4752ecf6718572927fcce4a5a1c652bfcfdfdf64c6291e072695e1434dfce4a05fd4d5e115cf54b1e7effda593352368ced42664691f4eb255b41d4ec0adf85214af1738776a73b1b0c67e63a74de89cb563f2f15c33f7cbf9a4dce3745a6d848e7f61c712480cfe5c3b790e46adcf3df9b07c77f11e848cdb234a6b6144946a1045a3350c3a9dc35db02086a275e52f0eb632d7f4c9fcc9a41f3411d1af9656d8400e8c688b5df964df52bb381614643b7562dd41c00badbdb199e54cbf4065f60404b86f3ad67088372984688a461b1217660732e3d6664a45098b3da5e9236a39d5fc92b3f1fc6ff8d99bd27741142e6d3fc2a3779f45da9eb79fb17adc06943e10082f977d01e9298696956b4937b4f01d92cc08db3326758c9b74764e10f52db05cd440ab12e1e7580ea20cd69e9994e595cd0a363d558493b203a4bcf9d4312041541f933e49b8ace696feb89c4b8acf704f87dd55b7c9b95c6f3de73163e87d234d99291d16cd0429aa10494987e57f1d65bc97a2485b5a8f1b32e7be028c3d2544f491b19ff80fad0156dea5c67a7505a52cbfa51e18e8432b10b1509ca05eac630db227f2b730bf79f70cda2faabdb9253839c76670270608108b38db9d94e045735a9ded1c6f698ec3fdb843431cfe94743162a039e3302a5f2f8fae8400f4412a7a5c41f3da48b85ddd9eb7f84381b00b157839fd8f607eb9feb723483a08623240423300e658bfc295ddc6429f1babfafb87025e5c9ad48b11654032134d615bcaf989f3f717ebc05d9153cec56b89ef78eb3f006b88ed4b85478240a76234c1e04b223f6c71472fc0dea946ce134b3b8b1e1f91a8045e5c38db906b26cf89e44bd3007420fecbdd9983811efd01aa69b66ef5a8bed289860aa0092c8e915c247535202e87fbc84e79951cc29d4666fa101dca605076ef73af0de3615221ecfc538f0e633317ecc5e3835b9df987886fdf6bd6847efd0c749c4f8481d2d6de3cb4dc95744f6fe5cf353958e8ab56f493e11109ed24b70ef9a7fe8a0545e264d7a41f7245fbe2c8a46ec515586e89bbf9a0a697cc97f110aab99f345c379ef1746d8536b299b34a26fb5a7ed49496c47fa83c79270b79b6a6578c6243cc9ff037c2f2ae645d873664ad5b5252f1ea0ec705891679fb3ece81a38ad05f8aa39efe5d0f96917c6431eaae3df1db61aaefde65c8ac51936a055cf91d578aeabdb311b47b05fe34b1f955207806e59234dfd3baf4a8e523e2e47973d55d4740a5ef0385a1f50851ebbdd2183ef8230781d92aee32cfb4c11680b20acc61cda4462ec25a9fc87fd1dbd515d860b8879987d80e1dc909884e581dafcf56585ea05a8044eda7794a0053ad527e23d25710ee6e4d39fc1b3fc133278b8c6110faff9876ccaee9e684449a1e7d5698df909b48681c98a7538b3269e74679f12ff6ac0920d879dd7125952ca4771bb9c9a603f875d91e81544f9b86f9f6d776ffd24b6ffd68fc86841f3c4150062ea9a0b2bbe7b14941db4d22711abc829b00cfaf76fc09a6f4cf096119d64387a7964cb3929bdfe4bb1547ff3c1bcbfb26cc2f1298c00ef1269da51421748e0508bae381c0669bd03c0003e59ac6dac5820c7353483ad371d100078216f8a5af96777aa49c03d4423a35d1a8f33d7098b6a77caf84381765d88e6be8d4c2cc34cbeab0456522cb5d38e1556debe4c7a01720f917ba6a7e52737290ae9dfd8483f5690ead119eb5e6a04ca6d22d59531eefdfcb2bbc13079ec37dfd11d16531d6e9a8a0493f45284b0b9f8269b9ab57aadd02bfae76aa646eba56df2aefee1c5ce5ce99031ba8ff3876b77135d1ce6ec532fd8cfe3913ee828f76890581543817948984b65d1e98420463bfaff424e3dad4a719a7f10c478cdce1a611ddaa26d47ccb7e03d46956fb9111c6ceff76a16ac0161c325fc5b6a696b5ebca12a96376525cd001e922ed46e41b35b3262f57ade5536d29c440909a7ff5876ba6ab1649cd702f6006040990b2cdfd0f57ed00be52d540d008a6a9cec49cea780f5b8191b4a58ff8cc0a4cabbaa9fc94ee692d92223b65337b31d4f1374eb83ed0669a190898e5f0c55d6d7f6ee4ecd8fec9563fb223ee2211aa5ad0dc124903d1da1c86fa05ccf8cfdf45aa50c4e51b198a5ec3bcc6168540bf2bd0a2a329db389972517f6efa97324c39eaba95a5572b86aecab1a2a1cd9a81e6a50847257d3058ae7ff4da49a5caa449206f97c5114d41c354d89c84bc758cb6204b4a78db05cde95951892c1b1b57867bf094cc8fdae09bd83f791f8be3946b8568d4f4239d96863ea2e6e8f170eee8d3e601f1f1417dc8154dc30b0c031cbcc772329d38a4de125df9a88e0f6c6fc32a974c3ce9aea1967b6a40a9fe7f59e5608ea7c30586008f58450da7cdb5c81dd12fda6cdd0193eefca92d31ad2710c1426f4c81501f36eef1826b6b35c0be89fdcdeeb440e245de127e3d4bc72992606254f296fd40ebde7df9b83e713fc24956aa26e56a3c7220f46afc7b8fe88a35d59475c0f48b00c03baab5d2f44053a6aa3ee781341b8b067540cb0e8a5247da4d67037dc2c7e7149cf9f7ec10114c3704cc23493c4452e38aef7507f7831d2a96f93d1072a4902c1fc5a91a96bdef39d4a0d90a82cf45c3fe18d704ab09e93d7082b25ccf58ea38886355bfd0459fc489965bcf4bf887c813f9e7e5d2759c669cd6c8ad15f7c3a84d3f41843cf1a02d8526e6d5cc1d9ed9809cb4b51afa07d898e3eec38186b12ba8294ddc16fc3dce3f1544ec2b3c70d1da973f865665759139970cee9a15b0041ff2fa087807cb44e423252cca472e3f0b1e13680bb65a43509d57b364d5cdefa848e068e0f0d9ec0c668d07d72ec5de235637b158ece47c232dbd7260b29fef09ae8f12d221727bbf80da0b22c04ed0c3a672dc69b4efca95bf50e0b07d256ff99b78f660336754cc3d8fead5eb993453b08bde54dac8ff902a939bcb76d24049b03b466b7f53b465d056631e8922aece1423f0803fa108d7ff48ecb10ec1fe21fb1ebdffb35f12ca099b34410790dafa2726915a8fc78ad7153eb3dc4c5813dafaba105b7f04f3e26bd95d2b4864ff7a00425190b3640071b5b2ab65beb7b9f39f461df4a0336322a7cd1ed6797f7207238a13395b5c75ae20b2ba1a550c65d8dd5e9fb315c302cd9a7ed2e9ace3130d517ba170e8c6bd95d982e6a5f1bf6eef44dd038797d8cd7f1989ae66a36eba22f6badbcd6577400c95211af1fc91bd4bf522bb9ff71236d4e5634171498431a9e90384a3692adc4957d911d8118e78d64cb313e5176a724285d3c83a1f3120b884a1db21612194292fab825848ff97cb06b59b1abc8d045d2b515fa98ef2dc13a8329d43e38251cf07bf4952f7e26113dfaf937f27b120288d265b912021096573aab892593a3d51688491979db7e0fc50a1ef3cc1f4872680403926f921aa48dcff238c9f9f983a4d7ed1ddf30f206417a8defee3ef512477406b900d56717597c858f947afc29edecf5b7aff982524b63e70a21dc25ea67fefd627bfcc6a867e475c6c8c5302064d359bb070296abbb2ad4e5fc42bc74a2517ab4f536c02ff3fd3b6d82781724a3d331645488c05163922cf8f05e1eefbca4ef996b8a3c7b5364580b8eee282607171dc84dc3a75ab547ac64942ea0a40246488179b6ee8cee7f19863d1b2cbe91ea7346244edbf9d5aff60fe441669b983962b63070c3a5ed5c60aa3abc6f7cf49093e56cbe2c4348756c4af86802d32534ac987044be1b3594aa476896c91b829de2df0bf3a7b7d097576e2a7055aa79db82a131424f6a9ea0b7ebb71e477cc4d1c39b4519f6fe8f83951d6a721e7723222a8695243bbefa0cf393a15a77e9d51cd6bc1bb5769d9c0fa2e729428ea0b6fa3f6c5862728859c6c07379bc31a18e416ef357b01310a899a21d9067d4d58b851046ba761eadd776865b28a0d2e74cd817a435efcf118f3f6d13493431cfb18a4dcfd2ab1aeb47f6eff270ed0b12aa58ad40afbb0b441968123b01b33ab3543d58b6cd36d5f3b8aecdb1f908cd7124a777f19c4a03cef7883baab2d2b369f6fa2f20bb718f61063918890e87bafbb0361b4e50b9e4b3943c82c12cbaab14c87770b7505e68c3c0f4775e950db5f1c22516671a4f485044045ea1374e27f4af9dcbc927ec3a1d98b629702d5a7504743b0d6a7fb1a06c83b49261a26f1c7e921057edd2aec9bde3e741c6fe28ea3efc878d44855e0c110cd9eb40e1041e3aa6882fc49c8cada5304fb2f8c194ad2ffb140955974d69cde49a7aba29a9f7757d82d072bc4f8d781938e6beff83754fcb4b767e44da572d43de01bfff38b9d2f82fd612b9488fc6879369337c7f7a9646a9087a92c8a615c3256d36fef4648d759fc8209c91587ce013ce278cdcd7bbf2330d8bafa13d661bf61a8ab1bda5fa4770f32bf69f485bf6411025a1be311f9d253b7d3b26df1991a68fb46a364f996a2608e09c7dd4e5e203cf4d6d5593ecd984466dfcc9c375ec3ac9b6d9eebb54c677648680a8bc0dfdbb6a77329cc05eb61bfb77cfba0df96a61bba30c998782f4c60711ad5288a7c3fe471370e7285727ff7f41235c8fd4e96a46170163ec2638d86e3fe0752cd94cac73a3b24b167925f53092e3ffc28065a7d3176f1722d2aecbfea85a4e4a3528a9d9dc272f771caf76b3ca1b5e3c19b90aa300e19d1a56f61405acd427ca1bd6681939d7a71b0761264ef40761ba888fb6a464e5b0d72f542c11a80763b9dfd0ceba834bb83fb15d9ec1b16a31b4c1cb252bb7dd4089aaa52ecf9bd6ca86f8e3917608be7d1edda4211055fa0f0f10fa4245ee303ac5094e106ca66b18a5b47e7255f083baabd335b1ae77fa661bc5c57a837a944752e4eef2ce5c13390df69a78df04f143a9fcda4baa5b92fb4a186a5617f0cc6b0c75c3baada1ece78435855c34b3cf7386015e9be6b1cab654fe4985937cd6eb2b44b633d56a7e8690c6df0f56afc56cf60de69f8e6a8e17ddb6596783a0a61f6b92af6297cae9d0f3b36297fa88690a6b6ab6af52007df87c71bd29bb9bc939590b214d688f2dcbf4ad4a646dbbae4cbef0b0ab166d4d1eaa372da8985c2d2a0f1117d1baf331c26694b3413d2e46fdc9e676d81c2bb81840f567df6210aae7e87a551aac05b039e9974a71cbaa3540e1d6da689174501dd28710cb279da6b627675866cc382b31e0446117fc3aa4de7618db8671764fad95ba56b353b00ae0f487b63843eb564f876afbfcb9389817461b863c981337c9f29acdc9cc09ea0bb580f01c571f0a4a7629e791b106f5c623577dcbfb5e2f8d2c9f68d1dc54d8c5858715b95045519e0a03170048689801ab5fa47803317443e26473c9976cb18587f303dd4a3c99d2838b7c7d82a172643ca6acaf76c1862590f39924c6b4455b1af4b8d53f383cd611972e893f13df752aceeee14793721723bcd7c3b53be3874a33d2fd99ea5c9f56ed9900dd535f44c20eae272153716258e8d0f7ac0c8509ba10d7bbe9e18293d63c55027c76a2505e55b5bd6d5b414a2d22d7d3ec6653782ca0efe79de4bac30aa8a7af0c64794ce578593f9e5cffe3ff5c10c980e5f53757976842c631c01201c2012c2134f48fe838b377a417272deb133a369c7cecef5124c5c4cfee8251a39788f60be144acbe9dfb979b71d6e3b8d982f8fa9dda437677fa9243e48f013cd62f33ff4477360749cfcf890bc9cf9397fb90dbcc1f45d11e3892d4561776ab4c009b3eb3a65519afc6f1c1ce7e139acbea936f2540831e9df03fb2fbb1ec3cd7dc5b96747678e3e8596b19bfd22abbd17daa42d4cbddb74096b45d4308261e6827bdeb8cb17bfdb0968fde34d4dcb5fa9edb4838938fc0b8bd5123a612dbb71dab1c9fd4e97e287bb64633ce00865d5199245c0d2f831fa44ed2e9198d54ff6a2fe038a1104141d3fee162a429e47526917193a5303c2b9ff01f6cb212a21e29ba0c124ef277404d0e53939d54379263b3646674df0c3e4c6f59bb829dc238443ecf6220d1829156d225fe3547bf859c02345ae241125babc1f68837f05ed13147f8ad602a42d20d8c1a26ada9d6f8289fe10917332430d996065dc3b892183695cf614cf032af7163b29c6e179b524f39c61bd9c1e8ccc7ccd632d4b2176204f16b224a49e47bf3a9982196dd614e7374b921c818ea3d1db00cb6c6a16b7a0763fa2b0cb55662dc3d1bb84277e9045683681860ab6b84b3230c3ee936030bf54543ff26057c09e88d956700bb11930deb52f64f0840682a1a624472a72cc6bf1ac9af607c2ae3e5dfd71726d060fd2d9a796ba469d7ee7bcc6b7baa93d80b83c934f5934a2bee48e73530e40b3f1c3248e0b8d55e608878f31fe6c590d3f0f727a6fcba389e9dc2b579a3444d39532574f9d280e674ac4a64b559d6a7cc7eecec395341bb8f699e7e8b8a9df2cb4c77548085b3b55e2ac9f2be87e2571ff7503cbb834218120f7f1b860919e5ab06c5c824bfaf90a1c7f1b2c967e70bae4377a0eaac2bac168fe8e3d3e9d67a999e52cffdd2038c1538137b44ead635de63fe8c095a2c9a05556f32614818eab2610059a4d6da2ad39431719b33e71a840f606f138398a463c15a74135967e926de6e29de8ed1c25c2be4bb9acd9667c3bc35feff42993a39efc863b5c074d145a24bb1c8aa4241acccc3d9ea567b4a6ac1db287277bc0d310147f2dc72125b581380dbf96e9fe1919059e9391a6158191fb1bfdb38381be8da5b62cc4d2f84b6d6008666b281ae225df2cde944ff4d956a38f72db0656d1ee53fb9d1a2eb73062aebe9f50f976aaa9c063e4c7911139caa631c71ad0f681ca0ec63a2fec984e94d43e0ede2dee3c16244ac0ca8f59fe2c9813de79756250175f1465aaa5b60b9b66edc6582144fb5c2e09245027859fb61a3d6d574ef0dd020a65ae27f1925a32a3afb9109bf6aba50637fb26c4a3fb87288d110310d60322dc1b222fb768566183f1a0b62d3dde440aa47e75b7c8f7ecefc6728d04a13e5d1bf28fb008dece4ca06a8a1fd46d31c0ed15fbe7b90e3c7dc74a37669f5ae5f802f5d5e66e2b9314a432e75c8038af70aebc6feabc314c25b7570afe7094f5c2d78cd26d51465fe4d699788cbbc214c53bc0e84e8c780344ce3f1b4f7f455675a28b11177240b254d7aabe818cc31d4b5be5f786008b0f74a3654a9020dfe1401049069f156962430be4f9b4fbf668a695587e1ea485991a6611cd8153e80f88b280e2f0f9b152510331d1a51242f3fa898036f8d108ac85cb2143bab580ea6215b9d96518fbfbd755238ee8246e2578c92ca2b371a2beb341e0d5cbe1af6e0d292fdc7d865eb03bf3c36bf0e6fab38a30544e139dce0311b61eda3e5374b5c18bc80bc835df5fdda3ea2e658aa2382cfc6e870dcaef836a2941d89c250707e79b3760bc3e8850e46c9211a1f0783c1b5973b332b16e0be72a54818f1a66fe788e73f75d9e5a365deedb3b528985cc2a45e84cd4cdb94247297a1006d088069c841967adf10a19ee7eefaeaf621f2dec15a459422e0d09a7890780af62d526fc32ffdad630b3ce82de068e0ad3746ca03a7fd996b2ec8a077b9b3d7b814cefd325fa2fc872fccb2c42acf3b6fb39967f71727e8bae729d0ab89bb98da5b1936720b874038c478e288f00d12d17e0bd82bbf79b0427ec35f630f62cd5d10e678de771160aa167d63806c885753c093437963501f27387f9f441a3ff78c36358922c46f071f1bd456c415b5d5fe8203d3bbac1256989fcf32e1ec70386e8d7c479748d6fbae1948b9db18e94bd4797a3995962c8fef56f57193fa4624e27e66b8950090dab9af7731b0e01184dee05563db21611ca702ab627ccf78482156036db27c3cb1c0865ea1d544a23e00a49e58806506398f9a4a04f22d7d2c7267d2ebfe3046fe759ef13ea4e84cd648bb83a47c151c9ea13db5aa9a0d8b0d60f3cc6618838642aabd7f1eed0975f184192ab2f94a8be510f85ef0291ae737da5134100c9ea6041541f96230602a001f5081767ef1c9726c77decfc39085ed6b549edfa856b5ec5e23053b4f1e948c90cacf8758fc40e256df697ebb66e23933b274abb733e56928899dcd791ce429823461f3290289bb8738cb71577165c1692796b99d17036e3f8c1ee8c365fefb19c4db991931d350e691abdad4606af61072c757a50dfcec425a493ee4e173bca6fdb300fc218b6f4afeec9766e12bac9b8ed09d97a4282fe3f1db9205f2bc100ca2fce230776d2ecee80e6cf23d44e857230486a02ba99ffecf39022531316c60bb80832e1695d65847c73f45522276b81e72f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
