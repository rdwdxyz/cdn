<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28aefb740ebb103467320f39df3a49918baca94b7596fc755016fcf5681da38084d4c044da3889e56eccefeef3c266e77b4997de26ab1b8d8ac1c47f155e0a2ee06782ce3297be1d1365bb7ff33e6dd2d3e35c4d0c61a701fcad59a42e6d7569910727f7959fe12f767052787f5807e212633c873d6478124d8e90e6e6fe82f81e19c0014957ac017080cb6bd3367b4aa66442a7db56389590741d6d74d098dee4f335390c0189c7326362f4f20f842e2b1a29466e620a5be9225d93abded1774a0d7d9e3a3fdd7deb4b5ca45a9d55629215c83f0f8d2ba4286885ebdcdd492b131d4aee19c51efd22cbfe0bf14d756520bc7421cfc6e14b02ed139cde76dc475cce69d62063104dfb10e6a464fe9c55494c670062df4468c2355355c4d5c7841579dcffd2c3463cc6877047d543076f5a3b67643db5177c7bba6e0914ab2c4b1ff512bfe1e2cdaf9564a4ce7b8f036a497607818d9c667479920c7fb37ca305bd7dd9878ced956d9fcb640eeb0cfda3c6118bd0c6f3091d9edda053b21c5b112b0f055f9f5f06e388e9110fa87d82856bf371594ea8ec17e4dab26be680430827115f3e699180cc26216d06598a18982bc855eb84e16f5c1663a04c91a2840b89bd6fa7cddbc75ba0eb6c2020c156255b18d6fed9a842ff024dc0c4970f2286a8892aff36577b277bf6dd61a8113b21b1ea72473ade441bc6efbe43b1c67acc9f0bd8e85af11681f89968c9cf4aadfd2b2286a384169728e2973b06b3df6d58b0c609a5d5d27f0b6c2344e1c99887c3138f00dac857b0dd1d681b68941a0c01d9908f1c1ebbb2c6b378214fb8a2e71b4f959aafe505b8caae9c25954d9bc476108b85e3f69477fe59d1eb475105ff66e7a65bf1249bd6fb9f0956e600df248c1b6039fbf0467356fa5c6d4a48964e67e8d9b720653c01585a592029005734193cbb4289f0a2c95433952d5c7179850102b7acf4ad85fde942ac0ef0704e2ff479ac8521144bbe87697404561c1ed43234decae6c28abf124f594aa7564a575caf72d8e9f7f6ad7b4d32afce00a6ab0195e15c578a08e50298d40a21de0af7ff56e316469ae398463470e14cfaa260c5909b87c5eb11b44f6ed1242e1a3ca71c6be67912257e4df387453ee0815ad54bc4395727ec658fd262e3be9eca9629bfb85b5f552ff546ec98d3c91d39b3ac3591116c248c441600c746227c4f760ef5c1929a666ff0e6053e7db7c8e03d6d46353f9485c24dd5a90a0e9289d30dce5ac1182b3303c6f6998cf59eb676153e6e982aaffc910b437253b20a360067f373b8a74138baf40be027fc37c7045ebc2fb940955e2b472fca46ac68ce437fa0a30013496727ea6c487a98c175d47e9bfcbca2496bd12cf969a2f73c51a859d1db2397506dd2a032c9d64f37e192a79ee5bfcc8845498ab1cadef02b22d92de9c47d5e9d65990e75f981ec9c8077f8f32c64a91a021fd7f99c70863d7897fd59a657e2e70bec364596395fb8a0b74e4d0be0689a7a62adf89ea0c904c423c73ed4e951a7a6e75da7a56f05baa6e86eea0b25f3db7beba6f4837016a4afc4df4b658afcaee36fc26f5723043d333c5f655474e063141ec1406e0c2de49594735d4eefdd35fc25fc576cd83cacd08eefbc8ca5952af1c91f340c7c7d37165a6cd605abe874c4aac9840a6056516e9c4e4f4e9ae45119f93f387ef6cf0a4bff6cc320745de82f0b740a3826fa21a160f405499736689acdece540d1fef3b4418cbfd6f68b6f70de315a2f58b42f19a7ad7a7b01765224e2a9666006491aa34cfdedbf87b64ef62724507ad0947806acc8bc00a3142beba1aaaa5b1f7b1dc8d5be1a795d4bda0a6c6d1454555e38a51297a55a1cf15a0787fca5e557bfcad4de445bcd60d569b9fec9abdfb42d99d09bd18d71c58e4309e39d0bce29990503b0e2266c1594f441c3cea651f484a27bc8cd0e549b4a6ffc35c190b16583f157d34313291358cf1fa1efcd31405e7c8cbf8bff588048d34a76202e3799b100612a286789a4d988000d1d9543802ee1fc5d03c6c9a47466890bb21e5a7d27b12867117896d8300d810178e3e8259826714a4c9d03030d87d876d003f6311049233068165eddc26ceb4ed8fd1fc8524d6116da76928d21b0d47611c421cb3e743567661647a6cb3540a86980d71e584a217b84b7fc3d2fb28ff22eb9c8e5bb10770006da2bdac3d514f6495806692c6321244f54713176c6cdd4d8b1043bc866156263f8ad51d5295923fbdc66df841a4e38dff3e8e36fdce4e48f3b942f60270deb7be8a0be69b1e1fe1c19160ba58cf96f8d7e1cc3972b32cae7b894472edab7e69b952b467e0cee81be9733927a21c71543a7fd5dc1ff9c6da8ca626b0d2978e3fa43e181dfb27f04f94c7502f4a09117e5f4d1ce5a9051a2568274e7912f92b3cbbd748993e5f1b1e1bb1b096956c56fc0479912d4257285aaece0087a4f63e7ebb4f359509d60d6285f1e94361558eb74fbbad23758020976a1f42a3a40e219c2ccd009c88a84cf5cc1bfa621fed28b7d31bad5f2d03929305b97e4be34a9d2c4f9c4d6bb907f43b786ab41a30dc6bd0706846c087d68c57a3fa4aab89dfd82a11eb742522d7b0628e7694868ad120271c0c4383b4470c1bf789f100e17c612f0b74cef26e3bc9114cb994d72b8278b0024182daf4937094eb86c1edc37c045e40e2862ddaa831e691b094adc7f341576b79c2208c036c31cce07c6d7bb896fd28aca126562b7a5bd4efd3922e69cb74ec5e45798ff3e8a6180191be67b7d91499c562847f4f1b01198914d04e9cfb57be3c73e93f12238e9e8dbee00d5f0331b656da2fcaf0137c046472098f945a81d3e46c65bdb5dee8d90d5d37b7c6b730ae2de516ff3b85b335e23da4113041d28788e7f20bdf7a4ee79e3b7b63ad5a46d544db44cc0c532c04e8d6dc92db84bef81cfa8d5ec827e9ee90799249e2ca93c78a9695da78aaaab3f045af276702c67142bf248f691938a7fc4730179b27dedaa94bff0549503dcba25b8c5c6133ede3299dbe773493c5466c9a863858428b7b881a15c5ac38901863018334f741274feca62d75556ef0cf99f437046f6e4ef57b9654c19c66c30594d1f24acd60940d737d071d3ee87f747d81fc25dec9a2f2752b1d396bfab7a3268b7270e4b803be7af66ef3c78c6ba5e13b07b41b7bb5ad257f44b2fdd95c999bb9daa440f8f96e2acbbea664db7ff08b9969c1e521138482e4f7b80af50be6f0fd61cfd6de6c31aad4c8e621cb149df3cdbda4b6fad5c138c6529f4ba46bed0f8edce5d5cabadd6fe03706caff42a878c23d55386a18279b7719a7215958b69664041965096ac791f8f42ca8e0d86db9c008f748595035f21db1e00ef611e8f31edabc36408f1e2950a5b7096eb84d5a1d9e3ca34d57e8078745feee77d65af743f84dd166c6c3c3c84d4bf6bc5443ba7690c6777c41483d0f75e119bcd2c834e86aaf255026c894c54e213233e515ad5b0e47ccf19730a5a3e217e77044933a99c5f0ee8b5255f5ec6672377410cca577a450bae6ac242e3c5ca7717757cd486402676cde8a4152b3eb37c00ebd80835119b2253da8014b66f7b4f8f9e979b64eef7f62102cb25e46b87da8777de8b0e3a6109c4d6ef905f8552811859137683a200cdf8701316b5e5ffc2dd882aa8651f30c2ad92c5a79780a82a3707310ff254e062b19a179e5d75d37a0244572b3d86893667bd8c044409e12629dabf8e386a48c4dd96f359f01972503b92b24214e096b2d2f2154da44c6e89a5bbac4f7af145d321f46b3219d134a030ab0c11926f18de4285c9d95a6dab694537a4b64904d553b76253e428ab17599befd7487b9de423e1fe668e850f529b5851941a1b9d757f65939d14bbe400d439b132e680d7d55efb97832242cded555736980795d506dc64ea3d4f60a46ca25c4603051c13add2409cabdd6647b4bee24da18a17567ad01ec3436451b72d358501c0109464d815b562e41ecd01e04a8463494bf7d15851dd573b9913c213d1f716678288f90cc1ca5710ee9e9f358d1a0a6071923f39a99ba711fdc37150eecb77e16852b973b3d40aa9c882b1914cc5dbc42a8cf22496f1ee75f3124e6a35fb6c9c749253b50eb43c7a4fd82dd665ab29f96ac2a0c6fd045f2306bdf516f11328ab09c66167963fc8c139d8aa8946b5ef2b1580cb0c1726e8f73304c72dc2e567f332cd7eb321201a610d608ad2f454dce786f2ccc52493150809f5026abc9e1eb2204ebc6136ec8a7ef99a0b5a29e100be2e85c272b773223da3b90cc04b2be5601490d82d9dae2041e12e61d7afb728ac218c44f4cb01c3586b9519bf765a2565d73ee43788a512c60db1510a21fced4c6b04dc04758201b4050e9430bb5c16639a7278b68a4e2619d9d28bab909ebb66fade6a42083a69cda0dd3f26e06f613b5c1504150b1a85098b98d6c7e1bb4b0af01d539730342b6faac0dcde9cb5a409113cca75474a4a59877e81a467d7990ffd23aef205ef5e01e508608efad5dd9466abc485fe4714b1e47297c8fa40286285cf1d400a6654bdf3e1997c9114a6c34c58fa3e1910a952044c68609c069594605a7d7e4a80491ab834e45f8815acd53c4c26e05eb19069191cd16e193e05e8ae93404d8f5799d3107cc8bf634379d1c81364a33d2b65efd1292755f559c446836d47c79b92219b12dff2567ec2f5d1b1e3fa810b2144a1090bb49654f2cd412f495f932745abe53755c8aaa1597ad7cf15eaa1b9e78907fcb13be312c4ef42c25840e99afdd92d0f165d0fc2ea6bcca476df18702161a96d3f3236a73f3752f011720fcf9efbc3690a44d25dc6e2be446e966aa0f79a198c90c344f45be97aa42e8af024527532fd64bb882c12d040468d2865ec12e10c11bb3cf197298087f94b0e670e9fb5f977a22097ac6ec8216b7b08274ef6b13ab298d2641f6241a581b7a324c6b301b493f52565e6e9afc9db33a527dbe8b5053bc93c7ece0fe746659bc02b74ffc253d406d2d8d6ca24ed501b56def3d8844748808ac1c216887efd09d2c5e3780197f1619a865b44e82ee59b6affff07abf7c825b85721e2bc1fa9f991dce23c0cc42fdf2a337ae6f45571295801372f147d9b7c0e9bd30e0d82b2d314e07e58db848c607c4d599b58b06ae5270aa54094cccf5347c0fbd9ab697b436613d778794b5b5e285e5a5ac2b6f8a57ffcfad92bdce09756eb29d158fc2094eabfec413350f0a9325dc0c835dc81c092cba8622da631334b28d8fe97ada441b972eb8705ce8c918cd4b23a82ec0da259aebbe4d7f5258d85b85e20c390ab7456f7a96b9cd08632fe854cfba5edc5785a040a5aae15ee1e656b59fe79c27d875945605f6d18f1ea766e6516bd034ca5d70546a5efd1951951ba99f1c9ad1c997ef6c500778c52c106c272be2aab153cd84a866e6e592e7886e4b671cd2e418126e1047cf436b55049bc172e5087776019b224b1b50159315aadbbb400aea86b66fe03196ecc4e214b5a84c92b77583d512a70690e741cbcd8bd03607b7ea3213931b3db335fb7b82750b8b59d8602ad9f4671937d45a8250be21cd26a3c34e9bc3d007c7334614cd3df93d787b5ff2cd36de1e230f801cda6fc2341010c20a469515a7964184998d12e86ff270c8503f4b1b7f9c56894d098d78ac5c1876b46e2efb852106ba02beb91c305f750f0f23031c99efa47afb6044ebb68ef431bfa360ffc9418bd22a2dea6025a875ab239e499a6f90968e3a61ecbee5f95fd7159de1b49d32f74236c73838fd4afe07ce4c2cefa22e069f5c5dc3594cb5137fc31f34bfaa4c65c31229c78f971b85413dd5486c4ee3cfa2336fd0168b300e10a2567e94d9ca7cbefe6ae0f34dc0d5c3d2c61a3f135884702249d36dbede185fb2b7691f64ed9ddef724fb06dc1810907d1520fa643747af270e3aa1199061d48fe1278e699b774f4320e64c3ed63d3225f58402d080115a2743ba2053e30188ac6c1b11ab90cc55026ce5cef4a09f7bad58effddf240baff8eaecfabd2bd72ccf5f19cd6ddb50b6e9e0939ebee40aba5b87e52e83fa80b7b17e470d1d0a5e2b8cd47013b163aa1f79a6e0d74b3b2cd37a896fb32cfbd855be1c14a3f9fe58b78943b58259841dbf2dbea673d0f1a28e8d9863fc70a6d25cb4a9f40291c17bd0b28f2da448d6f7b0b1f131c53f2d64e9649a074cc9f631ee299b4f8e68ca7d0a8d2d8280dbfc5c4cca7499e491a0757b04c9ca9c649ca2b91226ab58fba6a68dd17205ce2ce789abe88e2f4e21529336e3a643bcbf30e2d6024ed2894746d942fcc650b7a01ae5cc932d358659664ba313b81ebe585599f26fa11c990523861ac01bd685e76dc592b042258c52fa6c6de071f377b31bde601d86c1232ec52123080489214d819c12c03a5b3439acc9a58c5fc57fde5d4c1e261d557d288e8204709a5d2bc395025de771f686c5d36d512abf7f1b161207194a9af23b66598543b7f3965ed315bd44b8eada105bb6ff0124a7072336fd27d8c68377bd6298e00d104160faaa9d9cfb55413adf4436b852f99bab81617de263761697b839c3a4cacc72f065441f34629e04ac821bbc9c2e2a1aefdce966263a9c7f43551cbb3b0232ee8b87d57a23bdce9efd1e27aab8be6a3366134cce3a4eaee1683e6f7f5f9c6e31e36c0f5bd3af0a2e6ac64c595116bcd2637a38cfeae6d301594b1f0a681922ddde0fb258e9d724f6b5f810c74c87c712e0d9f979e31745d5461ce7481744c39bcdb81852f693e3704335ecc6c73acce3aca1d59d8a93e3c8ca09e1691d1e132631c27d7ae1a2a6c470f046878265aec5d464e46029ad6bde65a9a9197c13caee69c02c2882333db29b3b825f3af8f530b2fe62b511aa506389d11763f3778de6b6a6bf0c178464b75222c0a49d406c7fdb9a8ca56fb388092571dc767cdf16fb28db8e8ce6db0b56e9f1624b7cb0f80db8355bd943448a29ac50f0916fdf54f7cfbb5364a8864813ac952504228509f88fd517abecc8255c66b26c1d215e6aa18f0f19d1edffe9a793de8b42e0ee6c9fa010f31adb465bc45f317d716cbb06da03e08f65b34930c96b44214ee782d0bd23351b5c32e813ee30aa0f8e4e034fb18fe7daec8179d5441379fac62e8dab39cd750ba189e202336d51643366f6b595b2217373b407d919735379bfa130bb736d9343f5548d140badabeca145ace5ce4b3c3db4ea39c77e6c6ff23d989e88b3bff012048b2b787f94336200b5079bb3d022c9c96944e4bae34c76e6cb3d9a5ef3bfa5e6b464cac362e6aa469b1e4bd27e77d8647e39ee6d4b18da733919799dfd1482f8c04223ead8f6d3d2f31f94c1b0716de7c72ce11564370648b1ddc9fcf5e323797abc965803276d83ca11564eb69a407a82e5be107571b748df360e31c1b45f23f546c1f5540f700ab8eb2e852372d6aa0ee24cda0e385f4166f220222b6b2a0380a6fc184adcf3bb74016e2e93d98f506328d94e118fb4da3400c2425ef493316535c809dbb869bc39bcc79fe8736a27e64fe6d4889adbdb3258da8ad1cd12cabfbc7a5940e279e83da45b23768d133e59fcebdbc8d548117ab56f38303c63602cd0905fdffdeb4adaf62cae08bc930a29826e52db8608e4c8d29dfc7e6b71586304e51ca68d9eac322eedd51571feec54a994b5e36a4bee60c75110b1c0ffdfe19c31e743847b729a7778e8a2e8ece6fc20a0c7f6076928495d1ce328130cc1ead6a9e46b97be3e4081ad0597b0178a823371660074ea1c29c0e40595f55e96c1d708d4c02abc7ed0c3bbbea29232f08cb4b257c6c621ececf3843f7981868f1ec75a57d4868ac49e4555eaa74dfb0550518e172b340aa3eec1081c24843fd6d5d2e53715d28932ea1ed1febded1b3bb9655efb115ff64768dc94cdcca43f30f2135a692029ba1842b07b6489908f2a37e82a5d7213455f0542a4cd808b1b4d633816c96a3432a2b281746d44f824327997b1a10a5a387d24af36aa7505f588126b7ecce9f38162549572df8cd6b1602cc1906ece2f433d819063bee8a278c402c5dbd528223916db4afb35c26cd1f35e5855a5547daaec909ebbcde42c5b3023c471936663facfb240439d37a726a8d8c9335ed424de2d78f5ed148c083dcf74a29d2dfcd87311e197c03ae93cd062b7dc74cf4fc4fd38354fde6a799fe7949ce31cf37f1e72632d79f716dfcff7571faa03031347a6c0d071b1afbd7c057757b86950dbc21f2d34490facea8beae1fa9a8cee5a71240fdc129acc6681e8b61735b4a6874b2de659531a3f47df17c1ec545c3a92a3f4de4bf05728aa74c379276eb745e3b36b23a23f9ac4a9447d5178be156e022c1750c9c84cb5a2c36e631c1bd42a30d7f8adde0a4590e8c4bd3b35df15d62a854b3e49ddfad634d62e966408e77ac1eb31e62deea338a7fbc3fc6ad9e569ce77fe6634da71e3d89dc75a9352bfa8353861791c234186e8b5f787b5380790aad607cee9d2364d0387edf7067869a43228d505902c512168a8d9f5eb117bc618b653aac95a83e3ca5b4f08149045af8f66429cc3055cb7e9584790b1e5acd4d07d4391600f270a952b9edafaf0a58fb507e86b4cdc291d94d37c6570aaf6bb65fc02b2d288d8a2b621a26339474e5aaed28b01fad2b75adb230a7d83fc1e5ffe1c45254e7cd01f9c5dfe8ee7796dabf9138836e4e42ec2757aeb0703cd9de4195ce67df855d9090a134403f5f70ac7e202cad47b4ced890284f2380b218e2e74ef00c39f48af5a3983e7a4b83055e3ba348cafe4480d1a4d57d2597367995c2f2269188b1716ca7f15f59608ffc96d2b790e44a15b751db7525bef1594a616dd6dda0b8a08bdb8687795c4a3cd9745c2ea08fcc306b17ac4ef1ec96de019969ab82d0fe88dcee8271ccfe4f22c9400437d5b01e7a64627f6ca88676d9ef09b1cad464ccb9a8910e7593aad6d3153826091412e31f0b07582d16fbe9095bfa341d77ca9e1de5a48a7784bbe2727728a5be6d8d8bd7ff8ee2e83a66e493bbabc8b56317d33a430c089cd5fffe3735556772ae10a5185589659f05eea6ef2394a9f22d7e70ff2b5d97e1f67192a8ea79c04775dd8f51641ba913d3803af435dce6f731db86c298d1903955d5fe4650ddd284f6d6d78a39e8553c676023e369be55e9d2ee93e915958b7fd80b6ace8e6b7e2ecb08ceb09beb960f8f32f6f78acd729854a5b9590cc043a058436b4b9239d2feb8235c17b06a20d74f8c28f45da14077a82f6a1034c65045efa54ae84e4758d8185f31c26bf75285e7960652c982a574ce19c8ca007a02a295c22ec46311ba7d094b50b79beb9be99fd6d8e16347da769e737f28c2cf86a9a13a2032118802c5090277eba3ab010be110477f2e72789082075f954051e658bed02bc5d43186fe57bf49f8fa9548ac16b5256f1123dfbba05bda494f1b3cc50f9f1df511c79d8489f4da3d284acf1ced0e111d8100412168c866111cfdeb1dc25554f63ba4b21c768c2e62701a216c7922176a869e09b8de49d35a8281bc947f86023e1deb3d736a76b98a13d8ae999b2496fa244843a520c5c656a0bbc04a7a5c6c85b03799ca717a24da703f0b3333e6bfb89c40a6228cbfaa80a56ebb8d4e8a5746b3bd48b8ff9b56501a280fb56f7e290ee68d7730e0ffd60b712f496f32b3ccea12110ce7142f24a234fb571b8e85c7a85bdeaf492a51f12b6f1e6ef9f022e6619fca011e2557147bf35cff4de04429163c310192801dbc8f2a1bce4229b6ede51b1e4ae15d63a5c8fc0ac75a32b9285013ce32e22040049d8343e505597585828c9aad1f2abf14ac77869e8021de029db27fb85beceb5b85b3cd0510d0cd6d80dfca17bfb8bd8bda437d75104ff89369fd182cae456496e7685585040c4641e8be4e45fb0014ac665cedbd3efd2bf520e8a244b35623922a7f9d0fcc54c33501db3d635f472b666783d8a0132191c2007337d528d155a9ae55cb686df1304d4b2247ee5a7f781ce70e5cd170b1a4eb2c72ae5033af7be687ea56a2b554fbe9bfa6b12bacea24c3138cd5c01c3d5c71f96111a1765aaf66b5a158e7870955a765526d31926680f09f2318bd8ad7a3b42ed72963a4f495d1f2fa112d80af2ff4f999a9eeeb786ed72c35da314e44794f71025de9e4ef03cbf321c227f47bcbbe574d4c00439842d3bff4fc398fe1396ff366e701c296024f8e2ad10595f40bc51be8f9a316b954873111a4f47226881ae0c4e8fc8496841eae24485b99079f7fb92318d8406e46dbb273dc334bfaa3ff63163342be6c8c826d2ee0e0938270d5d6aaa9141ba8f2565a8d66a4085b9c23f171e851ec231c9c427a4bc84a6a7b50b808a679998a57aeeb2c7e09217a98699acba993a920883b05b4853d15d9e4e925141516eca1a4a71f8e84138521357224969d19860bf282b93ffbf25cdef142f73ad91f4a27e5d46f43c189cf8c36e909f5e6f7a4a97ddba2977086b9204b2d46f873935e03c0de37bd011701df25bb273f82f4c0efb4b6ef69f1040beb291a9be00bc4ad85b715b9dabe7536cf085e663a5d50695a1e022a8bf898118007bf8753a89fae4d1fb62698c2af93e8e6113332ac99d14831c42926cfd697cc158ed199a292f84e9296f1f0456b11c6955fc56080627faf663e72d9379941ddd4da06e39889d4f6b1f55aa18f95f31fd80d639b52673671419d46f3c59eefc33290af54fb24f5c9c599674da72fb9cae978159568d1a0826afc5d2955b1247acca9328f78197456dea3ee2a02bbff6b7a796a81ec6bc09d56990d79ea542331040786018779a3eb980e8837add84e020a1a3cf70c35b863f005da75e8628b619636566e35e7925306dfc54af16262b8eb762f40785090cf4aab23ae77504b4682365f8ba209431b4f48ad5d3555e6fb0ac8e41260b52fd5e6317cb5f9940d9453deef88eab5e6fa280b53e9f6b01008602905588e4183d8703311ac8212876f6c5a8f5e0801bc4465fb32b0017b3333e3119cc24421ece67c30f46061064eb92054ad3dc0560e6cadc34bd801c472ffcd386154e354fabfe5b931ae4c636e6f5d0abfaf6ba8856ed199f242a6f45891b8c3d88cfc1b2685bfd84b705e36a1b61dfbf4d8e9cb59b96082bec4752d588599baecbcd97e2e5dd1f2cec16a4b77b4e6ab6e97fc8a78279c80d4a2872041872dd481e08ceeae776099242d28f742999052530a70d1df78a5360c1d4b9e04dc88d2f2d9ea056a4f648ebd593b10b492093b80841fb1b3f3f256883ec75192768276d2a29569c881383ecfd3b710fbdef0c3d2bed29aeda9b895ad8eebfa17ec4598568b0301401c2d656cd2d34c3eebb63b92fb1639114a86048a3e6c81799d95f6210961f739370c815a3000f63505433a1b455fe4b5308aa6189d50776551712e47f49bf31f48a279ddcfaeb9137d094ac6b4f86a2e3be9998849ab324c4eac0ee18dd631ea615700c1af8820d3ef24682b8b404cf107c21736cff09a6b55c31890e27c0b91e9a58ae0ee7eb374a7906fed32ee7754b2b0b6294808bd11a0e04bdbe71f3ac8cf10ed4f7cad374ef8a5bea45a509f2b4629829c7d14a022aadd534e66028186bd633b044b9f807f8496097c3729cc73387410f2967a758f51222d532944367a17ad81a3dffc4551e3c72719643d699d5087fd1cf8781dfb23027479f13751d9d143eb54fb5447155f5e5019b8e6c5372f4a232352fa351340316daa61dee0c28dd2967d4c5f3956be271c99e0874900c2ee6132b5cbcee39efaa4bd3c9ae2b641dddbde9511dda2c569dc25b0dc743da27df572d0899116ade515537134490eac7b727844459ec0c79645f08bc85d3d2d891a52c3614f8d1a4f180c2b97d63877404890460f5dfdf366436cfeb4657af4fcd80feddf015ea8ecad886166d815eae07166588826f2138a5a1b27c1862469129e03319c892c28de1cc92a2ef61ffc8346906c1e6af8c498ab4f0bd234b2587a3ef9e791d7f878dc74470257692a596cbefe9b7f5b89d1d3e6570b29fefdec80bdaeaac7e56d1f021899aaa6537796982c6181a9389f3a75e843f8a12482e9d24704c25fd730243499545ae37fd871213a1af553c940d0423ea74765b6726c10cc7794cd65593e8f63150ba91ab57adca875928dc938921526ff618d8ecc50320501180cff03425e607cb7e2f8aef2292621364265a70ebe83a0a979ba6c63801775a05fcd4cdd7d92b186c1052dc0987da54b4aab79fc0d459f39de20cb98103b9f76acab6d6194b9c2bbc01fc6d3c3afab75ba802cde0b116f7d6fc17ff983447fe8c8e9d6070560685607676f3de39eecefbdfa077b4a74bf94e05805564318821c9f7b59a971f6db7a498a3fb8abe0e3fb3bb51c7f4f78ff25efe4b212ccf9b6cecfd2c6519d7c8b0a94fff83b12cf2dccbfebb69e054fdd7555f24a064797ca2197f66f16ff2f92b76e8a74d3e3aa8f89464684600905568808a60b53fb6e204256bd31e2c47c2ef4319f618ae5a9c8f9c85c365efe19b355bc22dc67fb10cc4fce71f175534112fbb74f282bb26f1df45aaa0cf1e37a1185c15cb02a59f5a665985cc792ba02547af4c9ab3054e1373764de18a7e9398735b2f8cfaf2a7830363671e6e6b18cf4188382c534f2393c6661bf3e6c5a07f0ea0ccb4d0a561ba76ba5093d303ba81b02d87964df995cf7c435ee66d5907aafbd462e916746f1f8adc84736f82c3eef3f1dbeaa7fd3a208cbab455182f079372fd38163d021bbe2bf90f25e5768b39ea33f225f3e90415f392ff907be5376bd91adffe8a8402e2c2faa6365230981a4b86a0e96efcec78ec7bbc4772caed10d916589c40a2d118635136302ec6800d4d7ce8de4ab20df5ded8113aa3172560a95cb1564c7b4ed1a5e22bae96e2e709d236b29f2db5b6b80dd97c6dd29e0630141fd6910aad1c482454a4238ba45dc7f9d3208a10e5e71559458f21c4bfcf7f8cc86c34b7496dc1244e287f04b5035a3e780605e897e83e2c35be634b9b4b1fbf62db2471a919a85f2a0a18835199f489176dd77cc3be50b1e9cd80be3c70b6f198c7d51dd34fcd8f0c2280ff4156799de8a5cb044415c39bf3b1b2ec812748e1dcbb5c1ea12c0d4efe87f68625b128ae7d0c54353ab876311a3f903b51d1c40e32529f1af2e5412e8fb57a72f6de8f27f5874c3150d2986e2984c33c34f8bc6c04ff27dd794d00bb5f0d56e6aa4f796299d6a5c18956570f2b67ef6e0a7f8f86653ec13c82781cab404bcfaad252f468dd3901d0e4df35bc6ef611bb42562de34393eb01c63c70e14fd34240964453c2188ecb47bed3c54a958c2a31256af758cfd10d8c099c99caecd3f0323731a2a163dd95bce59b50261462c339b9ac39a44d54864b1c6b371626293fdec428f38ebb91809ab3b23e9fe8b47cc4ef86029e9f13468e41e84bcc3e2a23571cec835b27d012d4e04dd65b107675a68ae52e0a6cf2d60e2fc9d730b23bac7e7bf43dd95c412dd7c2a45d958ab088a1abf45d6c1ac114100fd43634a5f6a88e961232d1b5ac2a9735f258d10f6c33c68d9d6e8b55a0655e7900329dc1d4307abc37f208d58f33ed807a5c025326e0170bf9528ac978d4648877734f969999215d7a6784d05b283c3382c4253478b189d10484295d4f6d519bf44c08cc7db39f8e1e57f58fec9360f08acd1ed83da3ffbe14d64998242a73d6943d07d7e30877df139666d4c126426e8b5c15cf12a5ed365057f63285de84a6a2b6b73842917c7dea996c9729c1a1c65f736733e5ffb18f503cca1e47ad79ddac58f551b6a8d704cdb006f28de483cd13844241d044d711b39977d586933f52a2ff6d394abc518e25d28cdfda83c1a3497d9d77aee4ad501ff2f054c137e63729e62acf586a74a323cff2855eca9ccd39991d55e4136587c453842be884e309fb4dd0ce5de2a38095a4b09317126d99e230905320efe74bf6e583d376e9d1b6b4a6d5e0d81ba4fd86a061c3d97dd6f977cdb0dd8d2225975ffadc61016658b0cfb084cb2e0e91ba12f056e810239de3921aa2eb8415e15969d109914a29b89e41dfb3caed2b369fb1f4dcb8f41133ce86423fed02092bac22b7b8e6826c14df195fe61a05897279b5422918ae81bdedfcdb5c0d915330eb5f8ca4bfe37ca4b31d0d55bc348ee45f92f6d0b0911786af89ff5d2559eab6de0dfccb0c44158cfaa5d27475c06f98eda577f0ac00de7d957b6c103f0589e3802eed926d9c9d1bf5871d1c932592f11d3df9ec410ffee78652ff747a1d87ca985796bdba8d56a4dc6f04566c139bac9d6d9ce8f5d7fe67e1580512d0c27e45dd143af433d15a4a4a9e4deb4bbd4646c8b6baa8c15b0467899f038cd3bfd2b81cca46a92c9b58b8a2b1d019dbbb369da1d16a550336b71808852da5aba22f5338a12d563ae92f536d5f7064dccbe4e145b6e77ddc02bc64556a4495c563b47f1bb4d7aac374ae6696ab2d98cd596b2f34c00f002001361c7c7afe813d199ec51b58f3274391ee6a4fe3e32466d54488eb444ca79f75032f257ecd37eddd3be689c8c0c472efb50a77a9712cf317270f5030a9ffd5f524017d440c51046d5aa5480998c8bacacfb13aa46f1062e3b4bf6e8cdd4aeb4bcfecb36c32474795b7ce61aa7fd33d354ab08bed77070156b68ca910f3a36b2dd8860cfa712f5ebd841f8daf8a79f92e2ea3e468b67af5b8e00b629d219154e579a6cf12dadd646fa0bfae5c832b6f501343a9eec748c72c5d2eb040fcb7f9966238e08cc88d5f3980167316132625d4400ca189a6da57b39b79d4d418457136e595ca71a81f0c7d9bbc1543ad4e9d3bef1e6baffeab40b55cf0c2b98f1b11a203e166e72c7a912ca3939f1171c62d4abae4c287ef9b941f4ec8bfba8fdd4b1d1a3d8a3a82e323f9bcd9daab1f1169b54b28f75bdefdd8e93e619d38259455f6bbd2e4810c0a8fdfd7a85d4a156ebe2ff4b4d01b32abfde80770c5be2a9d0d398945ccc7c2a19d4886694c50ede492a11d26b11de0233604add3e54a4eefcbf93953ca750ad96290fb7908112ea297b5a6203cf2cf8712911bcba3d3a2415d0908ac690d927dcdd9f8deec9830b321c184810b12d3ebcec453efab12059294c6423f5e7595dac0a81dcdb5374d42fd7763dcdb821f14e585b14d0ac57e213209706e26f48f19bc8b76b635f4b684d74e28eeda35da1d106ed7cfde71648315512cead0e54299ff61a4e855e93c3ef1f53a558f9b65393cc4f65337bb937eebd05a01b1aefceff84f60daa4f613715a9e5b4d5d07253ca9213435c2c63a25e62581edf082d61b8ac374ded3bc3b25af5c75a009432f002171b26136521676ec7a0d73cf261ceca5a407769ac9785bd0540d30c8671454b5afe7d6d990a1dda8406ba3eb377e621046091bc1ea00415cdfcf2fc8e686bf3ce047d117c5b3ef98fd14df5fadd57d3becf7ec5b175b81dd0276c45630c549d7e1acdbafb1c6663d80c3f9c57ba217116325fa3368fbd887e295a726d02ee8c73136062b9fedc6e3849e0087783082f86ed825e938737ec7ab90e0d95d16014f2cf5ae4308ef8f216125ccfbb545eb93d8026f776ae9574c0433cd6e9ece3ca262c30696d8dd3aa669ed72714676a6b8562de0e7c7ef87579c7754c9ed23604393443b71479453200dac09781700881578bda3f8659ab701c14771677a1f0d542331a85bd51884c853eff64cbb4bdbd71a19cd6cb73a429be91684eeb4e9bd16814ed2f1c87feb1c3b57b7aeefa6589a0c9698b6b06704098a705d44e93153009fd8a419cbd1669d0da886ceabae73d8722472bb35e1a6f052507afea348935d864c150ea849d300f9a7deab7db032e1090e9b1bfbe71bdf7ba979fae3b67bcddb10ef15a14213bfcf9817d9675fc328fa09b9ee811585ccdb9d11beb65212db853b60ee0506da793fc3069d296c541621f329586a96bf9ae24a89ed71cdc7320d79c0def0a6c88e870c0480a9019504e53d16f1b5a6549a24dd61a56c81c8fea54cb34f349406e484ff7756a6ae3f2cf98f3d7516681b2435aafd44cffc4355cbea229d1bc1792ef776d5149c099c821233cc789c214af9531b93da78fc88c3a6d61e5c955c96b4963713917a5ad07537915ce3ddef9f44aee6f5b2a0a8b8dff63624032e5b0844ab09d13be258130aaaeabd24e2761f7ae60b0d70c3e3d1ad5737842015529023f0a3b840b19fb7d2452272a7a8a3cfa01257752abe3333c7cf36af38c0d5b3c59b944133d604813f687a8f964f31937cf4ec079ecfe8f3ae3c403a7134766e9cdf9498cc36b043365431ddc85f54555d04795a726bc88804bdfd2eedc2432672dde7211b4f5a3bc11f51d621d7fc86449c79e1c8037af446d22874d95f6184deb0fb7621f4aa15e73b378bd57267d49963580ead7282d2c710983a3f261a7170eaae38774b9fb18700520341e7f09d6ff405bd54300b2f68c56549cce61e88d8963832f52431f43d878762c3232f38bdc886a3ef9b71e42b9aa9a8d9ea5df683f0cf54aa87d6ae119a7b2b9bd4cf114eef4ff7308d59362e63c0749904a3f8a33e1d09cee35a104709a69a758a74df88a218610c3eb84a75985fd3d1fb322c8d307d76b9abbfffbe050143aea8c6e740a11c3b63fc5880eb5d1ab33e347037d7d5c2d47087f011ddbf18a37f2709dbc708b086f244a58216cccc6c655b702e6ceece85b18a9e8f68c18c56ed1a313763937e63a01adc194b72114a8d17dd818768d2c5e14a655ae97710c8c447cedac8167e1f9fed226d3d982a7f6e97b7326738ecf1ea1dd3461a42bde167a7604f403fa527c192309f99a51becd5fc2c104520bdaad48593b9b86c24f8339aed998714df36f87247658f68a29eadb31cd93c7dba25b6023939f141a73bce7fdd2f79e1768df252ed51a74ad0a5ca2af79f7da24c977235320f892d2b4d1da5644aa6c8d79b118990f0e130eda2880392a839340d5d9aa1250f8a1d318e5aff642996bafe376c078e94ea6111c2efcec61b3f336be115154b6181ef7596e76069967eb20c4165f2cac5bcda0c2a95b219ed7ba5f3532f46d4930c2ef31725cf59d76d4deaa6f30cf2529f700f9645091f1f0ae46885c095c2b932af666ba5c15d6639ea08e216b58ba31065945606d912a5f6db4e063e1b28e1f6bc5a239ba0a62904e54583b03fb614f9b5d06a5287e3723bc736182242a1cbe5110fcf112d2a38931685d7978396e8b95414a6424dd5c87b9a97d496945de332a54b95ee62f6348bfb5ed5008c73f1395d1e8062ab68cf4c75b6e03de4cebb1b210e31094ffe36d64db68827322bf96910b82f9535d3c58adccc835e0cf81d77aabc1268fecbb9e76b7b00936dae05eaf37056bcd61a9cb3c473e1f89167216dfddcd925882f7575f03d4e3d9c65d7c87ad5c547a1e07116c6ae12c4b4f53c670fa130f0f4f91f98d2e8792240fde273f5f86e59fa43da6040dd36bee1edb8c42dd1a97ad32a6ce80856fdd6dfba9439e9f080075c6c06927095979af9d8ba5441b9b0c4a4841ef1e4f1cf55627258aa6ceeae7afb9fba961291da5c3ac19cbc8fe7979de7667882c67cb2e039228d0a39b4756ad2b342ad77031d182662dcef8004251abe2b68c5e87b9f0cc7fa0bdecf1e3a8a42b420408a9a62313d43e094882039300ba2375823816b326205111561696795cab3a5a5255452091909a5c0490ea9c033698a5bd4ac671434d3fcbcae3dd350b8e791e40c1b54ab1f95009f376a1497db9fb07422f480fb5643b1d5e63d5c2ab482312448a2bb4149ed4c5fa7395b974414e507836b941385663e06272559e9caf00d8b1651cd783ecbf39ff3a1d891c9b60d242de951127f3a22ac6e28297ba939004d47cd524029fafc52ef2c75263f55ac95a2d2d9a25c6ea8e3018d778433131903a35b0f9a669a7bbcd8552e6c4eb8ff5ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
