<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb398dca00d7297f4dcccca39d4e7c1f7e5e5898b888510d53e1b1519f75214c1fc232db1a8d5dcf5db639b2d115c5c439f1d586c9da2835339a8383b219ddb31a2aec5f0d459c9d5c3f92b37fc32bae27a3f9b54b1fe25db482648e5d74e914f741cc303d557db756d84bb6acfbdf2e5d9f5a1f7cbf80d6c11618f6e24746907ae7c4c8cd16d32a1930ebc2292c6c7ebcd9b539117dcd6afb4a0f59d5ce14caedd8436aa7e22827df16110b225eaeee9660c46fb0e15615185cca9fafbcce437d682a2e8d2b5b9319669d781d10c2e43316a9ca9a21ffc3944a00038d1a9ef3ad0f81901d11b646e762149126c4fb5db868f4c94530d021775a9e8514439f64ea7655750598f87b55452a9359b342ea450fe3519118eceb523747c6596b664fbe923c547b61b214cadc7229771fdf3bdb896957ba435ae01b08870b22df0965241814087612a7452ac63433782c366b9ac9da1bf733596d9a55062c27085801e42ef7191a1cdc5ba0af940791f87c61f22948940c6482d3a9dbd58ebbb920fd6b5b8fcde48ede040cf71d02d395b06146b6a61a73cd8a52146a3ad3361df26a2daf39600a4da2033ec2433f50ab72e23c46099ca16a51ce9e5178bbd21f4df0b050d165a287b0c10a22f9750d24a42ea9f79d46261f48efd347cc68c2f9f520d2c1b3a3d3f78d148ce2becfe71c10b2ba4d5dc5504d77f0254c9e88ccc68bd8a1ea282ed3c1f5be97bb9591216a8d34d01ee53abdefb66d52d46c29e99a219b709b97ca8b22861518deb48ea455adb0e4590adddf684784c847e527b09f8c3db08f98973ab838c33e6eb4afb2beac0fc35d25a052d6d7dc4525d56f1f878b9c9af7b6895c8b9528015ce24b841e6c64643df16b58c588133c2c9d46b236747b87807c2e0449ec2458cbda4daaef4a692b07a5424a23e8b2219e3c1232897dbb569be64cfd94bb7687538fff11e1dd048ab7a311f3a21337ca02b979179cad702fa78c2d4c58d325ecbcfe5d2583408ab0d5e6b8934027e0361ebbbe2d920b7d66c0bd05e6e9c662e34b5554a1a4aef2e00030e20b2b37efb5836da076a4684bff980f6d9c5588f7b09d58e5af2a33ded222ac828ca2147ab0300c224435cd74c9373b59992efbeb4d3a9c8de22369fa0a9404955614f89fcc8b1e8d5b06cdfd4f332c3ced6d5db9635803b3478be94e4cee66ff91e07938b137d2fc7d7bccb960c37321de85fb089bcb5926b0555b61787d1d14f8b1aea1d8a8d741166281f0336552103b04ed427353c19afca07101b3f98d502600e92790ab95e9609f2932f5b96d3acde2f84c63ff42ceb934c892c1ba7fe744571bb546265414fe10625de89c5d4133474614a621d0f00ebace244a6082be0d104270c263b257a8222c82900feeac54534a299713cbba3c10c184a01feed289f1fe859f1ec16e0649468dc795eb5c39ac09536c39a12b1c4dbe2246fb700a20ff5c3df8d6e2053d4ad96c33ff814c8587f5587570aa93446143595bc19b53041ac19d2a8b9d118f9367ceb47c347bcf8071f707a55ec537578d6ab34d19cdd56028a879706a248f778e4746a97bb79a86aac0cc95d72d2a887ebe1f8302cf0cdb939994b70612a6a8c761c1688c7ce5993443536f683f79104f9f469b6f7a6e1cd519f30a790a59f1e4e979818f5ee3c1df50d4f82a9cdbb15945463b0754b25d7741fbd619aa22f0c195eb9288494d636a1e486e640b3f614f244bf4f6ba71e3ee38daabcbd386b4cfbb178b5ecc401cb5a0fed5dc61ad0183cfe58fa8676eb7539c9a75b36b727692eb4ddd668da1ca8c4c301ae9c4b8029143c4cb7b830183290fabc99604480cac41608efec0f575eb148368a8c9d288e58925575d96b3ad606692a88f00cc14d0d38e233e92df3bd74e1bc9c01e328bfabdf1cbaf9885bcee53b750b7366f7f196f3793fa88bda712ff00698cdebc15f941396c510d6494a309660e346d7ce6be4673740419c2b064426e4c201c4131eb35f2b43501dd723cbfab95985c1eb1924961a7162d46b88e0162127763ec7e21a2b7f24bcd7acec3d338dd7f2df83dbfc3021c9e8d2f29bfa2556b18aea88d85af708b526b8699f4819b9d2168ad6421deec72cf3b6f5438330e8666bf1182e543aa43a90e68f6bfdf858f39fe2f609e7788ce64ab0a45bc9726789f852a9c2e08a07ca8f96139cba423a63f6884b6aa67340e354db62c2b24775d725b0312dd7d811b77b582ffc2a8ef88cde1938828661f4406488279ef6d2184b69e46dff5ac55657e9351a6b0ceb04c4dbbe6ef161848f3a448146a599d18e22742f41de5368de1ceb9bb069e289850128e354c4122943cf4902f6554fc28a88866b039b3a2b465bef8fb95a30cf989f1beeb1c529945ceeff830746cb49f7cbaa2b111c7124fd67985fbde20653f1deb7f9b290102017834314a2c87f6f7d34396562a9da8a7edf16e12fdf25568c6c59155f8f032d5e94739677aefdeb2f843e65151474993f2ebd839e8bdc9e97d566163f10eb2864d1861a375c7a927cf9ce3964dd68ace7b874971c3bd7f554cdbbb815bee2ad1450a8b93bae9ecf4184b294b598a0a31c5caa8a7e403835db0f568fd06510875c84e95658698797da3965e8f7285e366292efc408741b0255d534b264eae7939fdee2772e2f43487dd7c487f465d578dc2ad940ab5468e38f49aec03291db1817b2f6804354a52a82041d832167a050a9e4aecdfd86761ef9a6c77607156060c3e107dba42eeba93c68c69138153a66e8ccda4c5481fff2f23cb7251801df753a35d1b34ccfcd5ea8b6c725c7c6c629bf68655c3c20bd44ced4474a1667ce5f7dcd4ade66b3bb61009635d45cb25863a75a483f1cae87a118f16be0fe7d26365f030f11fba36d3b52ea82af988ba6fd4d20a1426bcc24bae748e42681e96d98c97822516fc542c0a3819ab9a503940adf0b5019132c866da9f4fd5104124e72d6a85fd3c23cd90b08c6654070e7aa376a12afcfebf5242c21ef0b92f8af8ec664812e498bfa677e10ed451e0c5771af1c382d43f4d44ebc9a981ca94817891fa6d17ca6854c338c9157c252ee0e3b54bcfc1af8b28a6458bed791379a1ac37cae8e15e2934926611e1a830893f3f704d3ab2bd3c98b8c8153e01e7d3de64e1f00a0b38e31ebc35f5d57e879e8c3ea945a29a7451c695f76a790a0246e0381371f98f043d54ec1907ad38cabfd13d7d02f945d4a86f41d0786447cd0058021f49b4bfd948be1fda0c4aa43e68c6ff124e95d5efa610911588922f7dd3788499ea483c3acf73ebadb9830a20c070d55809fc50192999722de6cf72a08960e7f98185b872d005ba7c1b33a070221f2684fc5c2e555e2e05e97a1d0961632f90b61469511685feb49a8739aef4ea083c8ab7d6b0ce7246f60b9b338875146deb613cc4aae0b45d835b5bb04a2c375984ebb1ca9fe1d954f1ea69692e8791991157c713fc71f8594a75ef7993d346c6be3581c08de877229e02b27490486d281f183389c6471fb2f8b4ea21351ba73be5cf6481b757f825dc5b56167f08d20b9fcd10c0563bc2777a251556ab2c45a035808a4c7101f9224e200d47d7f26431e6104f21304291d78a31155c32bb1bfb45616cc130b850c3d875757d6197a3e564b49643f7eb112ba3b0c07f72bc7e213adb4fa6684edfce8126ec13734df9fb9acd2ae511a7792e889641d705599c85573fd063edc767b9cb145a64e63920072abf6d7edff1fc05a8b22b5cfcd3c0fc6960fd5c4612eb4034e3fd58d8ea7bd03812a3aba7e97c76495d4b568e2ae491f4181e2f20b3793d49bef9ee25f0aae585fdf89cb054c0f6c8ad4fac598a3137c359a987926806ba971067c962f9642fea60867f07731e1fceb7203b4b77ff900dde4b4624d91813b4d64d3e11280173ca7321717706a33572745d89c431a6ea4886b150eeca120e45349d700e4c201b253860ca281a94a1727554ebc27acf8e4ffa13ab2959884b48266f53984ee249a5f83f73f6bb240a41a487126c8ab26f82c6f781bb7ab93d64ad54ee92c721a0bebb6c1f1ec2643d0a7131a2a2943ccbeefe030e2c99a7407318f0d70686415c0b4faf034eaf21d6b81b3d3fc862e51354cc57030fef4a40720c2903a69af5fcc14259c2a63f039797020d73f6e76e2c0742f4b8cbc67c7bb38ffe81b5730b2d4618245b3bc80684150173a3445dfd8b4b6d67fda6a28608e4c07007e36763c09d3ce27ac750f71c9ef0531f34efae74b2de0d6c16ed3ce1417c69c392cfadb50c8983f4bdc7499b22dc42047a89cdabe3c26a162e94e0791a1312fd170c4bc3e2cbf2455a1e0526b110ad0bcdd4a397ee007a5e55b7b77f03792295eb348622bb56e36bad7c4949ff39c0449cfb5b017f202e76e579035b988e1e2b0a321dbb44b0d3c9b6edd772cc4c11200f50b883e689eb9e270fa213a4f1f63a1654943e2c12df29ec43adad0d11e020d5eb0bd041ea6f49dd7a616bcd1fcc2e8c63eb15a8346ca50d2a65d0d05485f5d23416cd4756a161f634743da61afb3b7a3052d75bce9d687db7c2f73ecfc41b9e96487483ac5d52ba35e6a464115f607044db2803981ac38567a5e291703f73aaff79d3b3745c655675d63cd6d871eae174d59c42a97a10425ebd3aaea1d1167b351f8cd7e1495fe142d4c590aae4fd710dc66fc147fdc84f44a22348ac6c347c62e0dfb649ae1d09ccbbd5ef96d8745d20d6afc085e1aca927ea98dcfdcc70c735d76b62ec695295919a4bf74aa990d7f25c16d841d120a03c3fb9c399bd0116a7476db7a8f3bda66327796d63c68bcab13cace06e86fd911a76ec0b8a8ac3479c7e4ece45f760389561464c801d33f9d2888f1c4cd4efcc58d71daeeed92096df55401985180a31367b05104631af46986bb94d52eaee4d357452d49d57ab5e02503eef301339ea643accae491995c594dc7c595016dce2aa6a7131d61915e8e002374e810ba324c17f39b1b97e0bc3d23cee3a66aa473ab3a2eb5d4cfc498563735e9083bff2d0515a93f9d6059bd23fc174ea38c2d6971e4ec55fcae15e6ee9442fbfc24026998f3b8dd5e9b6826512be7606f24a4dab108ad90f7fb8d26e9d921d27c0ee9b5cf19e650e9aaf2ef77a4d28ed71a103736042fe3148599304f7d5d7249970ec17a25e71199c1dc3bfd43045cf5e91b55a8e4d451d307f27f541ae1a195fd9f498cbe292b1ceee0fea5c8062fbe0fa2879fa4e033a96332734d598afb829d66eb8212a9d18c3469084641ee77acfb617111507300a4975dbf9132e63ee108854d8f6b88701ef930ab01662d0ca668336160aaa2cb0d6667bfa6cc03166ecd1f2392ef539069beb1d6661c5d529211dfba60f5330a9a6d751119e5b1b5d004be57d7f2c6806ac9400cda498a573cac4eefaefcc2a7b4bbfc06e07ef8d6b0e10608b403b913832c03c94541da1623d59a98a503a1de81ab5a54da69397b9bdf3f289acc45146e208219d7f2ee87489d987438d3731af90a345283b0b29c682eadfa9bcb568cdd0176828e41ee8d12db019963943544d29f97faef6a89c9178ad794808f8eeebed430aa5c53edd470d39dbfc845598b4d802612ebc407f019561ba7823fc434e4ebfb1b433bcd03e4254a3e74f1ee71e48849feb8641caccc775736e82a61333a8882482acf4635416f9fee4faa43a10c6635873d36d3a19cc9b3da1ee97467911495f37e0ff7a9820aa81507a535f56e5eec8de108684249ffa87463d4c74fb2835396a6ec6abefef9379e82bdb31cf305a65947c118f01f5fb2c7ad4a0e8a77c2119221ffd7df6a5f14130649116f315354268d512bd11ec959afcb80eb6784c82bb16e6c77cf4882db216cbc47db58ce322edb6fbbec2dbaaeea41c9712f2612d70c52454d94b7046609ac0fe1522572ffb9ef3568c23bbc92045c31045abe374754ce4142b83f40486105f715bbf6932acbecaa426d6b2235d5415c5103e8be32d53902b26379b65b974db2b4e0685402203b9c20696ed3da8b48f3dfea63f8d56a449562f4e5487159ceca059136a6abbee3c8c65a64d5d10941f4e1ebc4e2de090d71a43d073a3b067d249930c8752ebaa12dd1729ef86b3da2e24b8d04c41aa9f30b2bace4bd8ad423df840fd2c394f731df5ac3c9007b0111e378730e2d4c0e56becee88f538edeff1b4ac7ab38cc66ebd0523f1589910687deadbe6e54c91adb6804059dfebfaf21a72bc0c80a7fa149576c311ba57deb6bd435421d32a685d3b5a781fe1b0a304841cb27443757e05312f39ce7137e91b655491b243f4b1b55216020648d28f83611035445e14896c674c5c4f52afb068d2ccfbe1eb70dc2b800116f48154c95ed90f8c5a588c826b4efa4c1f5f9be539cadf79e24626a9a0f29893e43e4b075e793694d4df6e9a1d5beb58247f0169bdc48bc4ba5ec5942356c0910f7f8aed3274485f810684ed4eadb5b28c84cd0e1884fba3583a237ab744e0e59a05ea2613e9d1215a240a6273a55636e74cd31639887cdd9a017c3248355de2f46be7a02e1a337dadd682c4e73ea7653c62a03a1aa76124a65690e44a1cf46811eb4fb9cc72b5b8650feee0b7ae7869343e3bfd9bb7c32bd6ff7db4816a3ccfe8a25410d192457d7daa12d1118a2af47901866e0c9e6003cb582624bf2ea392d086b9061651f388acc0d3980caeaed762c3a57a153761cbf64759e4ac25f702177f2ed73f3fa1208f5b7d9fd86f92d76f11ab3364f150dd58b25e74d42150b2e9f26e7c76c5e3c7e72b44b69aa75ac1ec8789c4a8b5a59828f27cf1624d4c361d59963d4866d069f7ea5f288e80ff75f252b345bca85a9f6ce4b9ee3792d0214f4a2542fe11fe6ba6e9e26182e02032bffc71caa9487accf513343c97df80db3e366eb46e85863d2e47e5354350c11f039c411a419d21c696c5ee5afae1a2f489e3f573048a564f9d915009bd3f1dc86bbb129d34b2db0dfe6b7f91e38875dff64ec3d58e6e35ae4556b8ffe151632f5824abf00288608ede480689dfbf912d243bb88dd555952868eca37610fc03752a8c2d4ad7a086856890fc012b12d10cac46526f2eb073d4591b1d2d1f7ddb3d685118cb4c9a6781bc6b26cd8aa5fcf4bf827d57e5cee5c73192c89c235f4372847d19f03895edac0c4fe21e554bd6e90bb195de5105a6f697b591f62ef03289f52f511bffe0d1df12900a40f8200c09e9cd37fdfb3e8aff1d38f04f4a0653368200a376b9da67b3854415d2633173f3c975a4e02ed7d86afcf0028c741aabc35a08f08e304c35e7135b20d8657f8f09ef27aec9391c10a3543c9fa27076f5b9c5428ec30a824fdc757ead7be4ef5acee8c7501dab2a4352e690fc5b3e6ee1f3e869ec2db363669a32da43b6b6d716aa54fd153d6146d773548a11ad6bfda1a8aae51f65fe33c5ba9ef9f34c8343e0b11dbe83162b091cce8ee59bf13718e1be571039ff1dd0fdf84240ed703e117852fae03399db13fd48455a62dae1adc6b001d9e525f5f9c54490a2277ad8286b5b0f17c930d3d6bc6165c5dedc65fdf20492cae3c3ccfd8146c58f92660a260d4676e45f4dab17db7377f5764cf991fbafb55ecf2908cc7c72c8a6689e0ea5a15df817956fe927a1b3ddc15b6afa49bcce1c8c1d9ffc1edcd44c008e79606320830d43be19facc202a5f7f4bff17f03dec8feb8aaacd5596a0ba90a05ac0606d7a1b03522ed586e5218b796b2ecf90842dd2a798e797057efb378134c823679909a517980afe5cc46968cd4a08b66c128d850edc408ab63e874e486a267f2242c866ee181a8d3efe1f7b334402831ee0558a502ab706f18917989518b90dd8089f4ea92cdd4490f57228fcfbd3e4e969476c95e6f796c9d100ee5a083942cd26c08169a864bcb9279e874bc1d938d6d8ce7ac3ca5a660b0de92a687484154b5aaf73962505c2ed28228c1ba864ed63cb19f87020145285820b1d1fdd735dd08af06d015472f883c6968879176c72601505763bbebad02c62021326757ec114d3bb1bc4cc23c5c21dc81ca7490ba5bc166925897ff05da1705c7bacdf5d57641033d7e65ae41145e3d0588407069870109ba33395ade8b4148a6583b16fd7fde295a0f1d502a70827ea91507f8346abd7a1866f53156eec573f8b0274337a1313be5c67493c5a6e92b7acba75769046f71af5b0ba165641a8bb41ed386556cca745f156cfa7e29eb8b27bbf1368befb0f137109f33e0cb9d649a5999dee2afe6fd8137ce80f6e3f9358bb4b11ba1172dcf276a563d571da6c0456b68d6efcc33113452311e67ed3c86255716c116ff29b414dc2a751843d080bc286dcb0772fa1a8ae61eac9ef30ff6d85c57bcc28b3117a8399dafbd431395f60267602687feeda84f8c1b0377bfacee737e2e65ac6834d2cae4b95a9bf253b092dc48643f1f2d8f9a9476cd86b650d2bd602724a332028c7543bd682ff41efd60b6834e7ef2275f81d2de050683fb8864d3cf5df193adb9e0f5f85ed356206662d296d9634dbef3e3f3a01e0208e1b4e346a82ce287f7d34c75cacff9a4c8a7643cdcd49a804bf44876161061f1a53788eab0499a90177dfe7f52f76ecb78d88f75e70fda4638e57fcee4220064099211cb65afcae6fee10a8888bef72f1c7a32929909a8ddc7be42d96cc3d02b7e0f0add417bd2f951bca13d07deb8092ffed1e6422706ffc01553c460b0290b70ceb556864e9134de4a36035775429cc9990a175b1756b4e86e26626cd373da83242e38bda01f0105b3dc88e1ee9a13bd35398db05624b395c2b713dc9384fee51b8035a4b792c09cd56750971750b3dac8fce0b95905435ea4c68daf22f2682e48914f19a3cdb34b4b43e4fa16724e81caee4f9a31c8bb852a16a09c67c61e5de4399982657c2cbf00a6460367b807c4a0c10952e2dc85ff37fa44f1cd8cb65ad41ec54982c51a073a4dccfd3b22826a1b711397b6ece98ce94aaf297e589126c409ef00229a7853d20548cbb5fcb905f17534a027c088a9328bb8ba414d614a6092a1fc8d6c6d5bca096e59793f0a320ecd19e95e15c5ad8b4a5ff8550f2560c3f5507041ea6b0dd437314da72c662db67274d4492421668dee154492a203b494fb31445c4263c5a77a07be6ffd8bf325814c510a5cd398bbf550b9d1153de40003f09e3352b7907410b44f486131cdefc56cb9fabf734ed956f6b3786c7b891ef96c069776bbfaa70b7660f0284dda3659b0d80a240f7199f584291e3462e5f209faa0cce788978ee74ea1fcde15ddf0b81ad0a9d5b973ded994fc01795983f224dee9c9c60dba41d98351e6f3dcb6ca4e17fc167bebaefc0e11c8849d89c68fc8e22a81ad16eb7be359e114cbf1d679098cd0b39673df12d1f0999e814a99094f43c5fb848d0760157e303f1f4a326a0eb4d9f314610da0383ddc8e8fe950ad5e3bd87983b14449f41643c5cc59afd5ad24c8e0cdb029b952a1c73f3aa318295b483f3fd5bac8abbff659db44c43ec95c39a213cadbfb37e23b68f47381774e18566a4becda76358b345d3687e3effb1133ffaaaae79e8ae044ff37084fd4265e4f541217480e7d34300e9b14ebc73587a4252924eb3b0fa34387ed34929ec6c1f8eec5ac672a146b380c64fc7521964ecf60de9f5b0b3b5b042191809c365450f4dee16e2ecaf973f49e12d08f29c09a749124fc33bec2f8c58ba3beeb09b5bf66cbdd7517e36c9cbfba99cca600396a4c289d06dfff57dc8a7510e13d9fd34125d6ae9aa54f5e8d5e844aadc6a9634883e01890ba324223ad2b6bd836b5f67453d25640d379d3a5188725b1d76efbbff40a0834049b21ae178abc03a37953ad22cc3fbcd506388e297677426e8f7f945fd968d2f8959f836093e6984cb75667aa693c259ee6112eaff74eae9e133bfd22dff922c2779c8801dc0f7b303cbbccf8ba24f5abd7129fa25ec01c6d58fbfeb76acbf818f78e4bd7df7f3b01f86adbcc424066a080c3b1fe9d1ff0fbfa8c0ba8ad415090fa9a311723396597d1bb271d8d211397d151c9006be3353c4e7d61aacda9bc0e584cc7e9397472d8e8ad2d73d136fa988d146d974a28f9d6ab510b2592f31653ad86a659f17fe784cb0adeeca6362a952273c3ad741eac865f2d378ad56683fd909adb649f1fd80357cc2d3bb85923a0d981ea15491c4860039fd860fb7fc4b415ae39c5f5fb05d5ae8a45660c1999220d8675ffd601774ebf0942abd6c25be7b40d8fd6d9a62668582ddcb13766f621b7dcecd5c63cccc6c31125f28b69a51dcf2439dfcbdd372bde741be6d34aa623b8a4db53dcfff830572756f7a46a4d4fa7183d579ad1c6b7c2bee96f99b7bc016ceca55eab20231cfa01aca4ecffb2e902bbdbb85c6e842cd7fcf3206a910e08fbc89aafe787a7b6f65826f213cc2effa56f11e3b195d96ccd0c3601d79f875f86ad84dc29a31eb24712aaa3772f883b2954ece8464aa8ae0c877a546addb0c6535976aac60baa685453ecb58601f6fb7e093c9b8a7ba5e12f0a4ac8b0dd22bbe323151b56a102a8a3869e44aec1a611a5b222d3b3e1d3e8dbe34d69e2edfda8a236efab94f64e150d94be17e76df79837fc22ab792762f286659155bfb46761526a058b704f51e021f084a830a222c75bf59a1ff6ac0d84a896a950651c8d1eb164de6927e11b9d71f74c7e9d79f8a1dd1714c6d3d6515779f3d5cfab426942df128b96b44d38d1746783d9133c49b2a60373ba23a726677760e0ed9adf57f2fb8fed03c209a548b7fc684200fff45c886c05f1a7a97acb445667190df894ba41cd949a070a3c85e4a9fcb657bcb54599920820f38a4dcf92261a8ff078ca5ba1a4d1d1fb6373fb5d640c4a2f6b478a7b0904398ae71a0da691988ff7d471322a014a36d2848f0f9cc7ec1adfeb9d1b2c14ca069376838a994182e97a70c05cb0c5ebca0a53a862e2674c4d092c2b3b8b5594956da0daa5affe2f6c8a43fe7693d42a003e75f5efb6cbbd40a090458d15e9bd9c779a6ea39a3efd080a237f2614a501b1f13d90edeff10b531637209b8968bc5d462ee652526a0a3f01e2bf19b776fa0cea979d668c0a344ff2e98faa3f2076f78e8b1c10ba5294d769cf5efcb84a65ca84a136dfe678168907b9711a9c3b0e029454bc8915710b263418132ec006cf02a1e35957c11de4c970fc3e38b95d20047ab334dafb5103472ed17e6d6942d60000d8b6a84e640d7e22aef9040e24e576d8c95902ef6eb4ef2cdb695e0e4912f002258bb583e2587363ddba918dc8f286552b8e9affa918c61b4fffa38f189bbf8c90053862e830250acdecf4cc4a7f81338f184e64adc3cd4fa983a7cc075f9d2b150dbb00438b3f503ef62abeefdcb1abdf2546eba5a6275c15cb5076fa99b0bb0c6c645bda495f91b46097710ce16428c274d7241e128210e2c9f10863c03b1cf0a552fe03b77983b4b03f3d0bd866f4a3118f73217b80b131e6b7abc3b1497b7a5e973099d4ff1457e0f457b58359e2300d306dc41dc82cb9aafcf84a71aa3a9cd9b158ed1adad2178896fcfe541423e2522dae63df73ed84e5d239bc1df89d0f094aa4c0de3de3a6b7de7544e2fea3bd71b4e5f1415803240207b4f307bd17c656b3e985b3b8e1f7d750f691302d1b7e631660b65165d2893dbae90c24aa516e151e6a9f3beb7b01ba60a43dfd3028b5027ca7933f21f9d080c5b1f16d0cfb99576fcb470fa8fba3ab5119b51e29ffd29af390af26132b66208592709a59b1df289103adc79c37752d0ee12a0046ed3b716d6cdd2f537c6af27a23059612f71070768251aed0ac48e263ef1c9f2261151d95606f43e7f3fda2572f48e7629da1b9eeb0d8990ab7b4ab5dcb8b7c229974c776eae54f26229d3daf47eb779a5bc004cb0a0d99eb6044bc66c249f78d7f42fa76e75cf8da4cad3b106a6a9890b7b28154975d54b66f1a27a330731a80a95b7da8df315c510a24670bc5b9afeea9cde413398cb96c11c7f645f1240fa9c57c556a8061bc538f5d1c6655eb25ef9e3c39fbbdf8874eca0a07d1219ac2345cc8755900a61b31e8343e1d8a6d0b2f3695a92bfd5603befb22382de230e0113060d80187d2b03ca6e91a3b84d91119ced8cfa9a2a4710c63152d15fbfce8862cea26329de6c74ba8f56ab5f0c5aec1123dfb7fda8fe3e5ae6dcd86fc96596cf265bca520bd6ec084ae8306904e94b3554f0c474968a8171680e283e75b939a3bf98b80cef4bc31d86b0c966b08250ef1a88ac021acbbb5922f2755af8bddac322093566e370bcc1523019481bdafbcd6610cd3ce75617fbe1be7ffe2dbe37fd0dfdd321bb2c6619d127cd9991b673e4e88489609f184d65fc24b44b65ea7a6dfe53767fff1749338b171dc64f9f6a2bdfd2b8b6880e38edc57bafa1d12ecc0da1b7224f53568dd91aa991c0bd12eec9a3fba44a80e790c94fd99a3afd7b9543e529c161a6537f922276b0a8aed531fa69a8e0f63675d01919e85dc1057fdae7be659f26749710b87f983b8615847df1acf7782becd7fb0a7f0a016ce344805b391ee58442afb80976c1e03e5e9dda072b091d7a7118fd3efad5cd928bf703cc5a72150336ed80fa30132750b01e8e3c84034168290d5a36f4850f550977f587a81327a3524c24cae84ca5543a4e7d591db3b516b506df28c3a15b96f894fb81d33ac48de3e386f91570163194996df643d742c08decaa598edc2507d3a73c08d1d79516def36faabb380d2889c019fde6e8db48e766603db7926c948ca87cdbee6423a33e01818696b91c7e54382217be0abdfc9b59de0b44a2a4f019d058774224d58c36ed09e9789f09e3d50fd2e5212ece0af492b45cc7feef724b68cb42bc8b556faf11bb8424c9ff05127182b382437c6fecc9c297245eb316cd32667e00e545eb6f8c198b4e9f2c1303dfbbf4ccbfe1cffafabf2d8f9dcaba2030fd80887fe3207b9ab0b747834012ce5cfe1c8e5f6cd416ccef9b8ff292b367815cc5e66aec0b128d5c832f2a3d2583a18a3e5a6216b312965de9a5b10ed4775afc5a1ee1ecb22bb053bba95c2893a3bbd8de4521501e7b4d60e0a100ce7020a0f5c419eac723f7c7019e717e9f885f580e670e9b45c38acda1dd913cefeb1c5e2c7b31447aae95778776b8a638d9766ab30e45520fa78acf43bd62a858fa99c621e656fd3327578b4f061e372da2b2051623658ba9b5b99bf8b11d2f3617e6058a46c3ea737e36a31810b29417b3738c62a7f39cae6599672aa4d5a2051f93cbb69dd29457f35dedab691460ec1cdebaf7af3eda4f453890bf79a7993720bf20ec21269b90e99aa714292562f182bb6a2dd4831a35331c804652b607693f4357367715146a014956e41a657e9c983fcdd3b08ba40774496396a50dcf530dcac4563a3b72c7b2809e925778c1ed1a77ba67345dc68bda25e9bd9fc42116c45be059e44e5db24bca33cd52c5e6fcf8a8d95667f09b53c99d7cfce1383c6b89e334bf98f02facca2aed6b6abbb9e3de0eb1ad07cf62bd6db95215d60ebdf598643bb79dc131b141842572a8e23cdd6dff023f638598b30b29f41737c7ff6367b9738a689498c1c7242c18535cc63b4348a9e3c837e0b7e495f7e71299a7be8f47519b999ac82609796f7dddcbff019c60d9e6ad937d80f8472d1ca8205ce9031b79ec5a0880cbce99783b39b772bc9206f35fd8145b9098d895bfe9918e4f1143716d383607fa50f23f08cdb5778d7d9f61472fc0fc26044d278886cd60317285071ce2ca20ea8f265dfbfaa79ba7fb18e917b30fe7a2cc974ff16b8ff09b9492d89ca9b45b40d48da821b26b50ec16e558b2aee41eebf95d45bba8a55f92a4be890e8c9e0c6e26a726d6c4ef699daead887d9ba2d294e2e507092408ac08a50918c9f40feb075279a57958e2fb9c6ba35c1d67dbbdf4da950fcf77feb6b496708d70115da8644ed1cb853bf02a135143e52b44d2e0568382d07af06c8a645ab50deee8e69503e3346f065bd98b4701872bbd89477fa2914305cfcfb87471a2c148b1733d44fde11ce94f862b92427086428d5e1c102243705f6419fdd39a8cc221f9d3c3a699806f4c73f9582f6bbeb139a7231d4f517adb9092b3a3e2a8c2447236b49adff2d49946d1e2e4a59227223bd4014c8caa8045a76c3a16d26bf9ead6549c6738e6b0153fab0448b27c365963024e93ef133460dbb89211ac398baa515069cc89fcb6f38cecebbc3e325414933d204c54ecad5d771587700753fa5f56b32cd2a75753bd443f3269b7a46ef35581e69641dc56c8437a813eeefc4d2e99775d6cacd7ac590e84660b2c7fe5affad31fd721739ce6c7be673ac60925b539e7a1c1fa579d48274136facaf2f678198759ef02f54a00af4fc9ee9d209c81d2f323c63629a8db1ebdde8b04532e212baa35380cdc2206ffa4a72b984710f7548bf0ed79e6ff0e4936f6533f000a7b37b2b86aa20cde5bac5e6138eca4c3f4002d62bcd4b2e50284891ba3365f1dc616616279ee1d61ae583d4aa114d0251c1e7767e4d797e53f4456805bbcd63aa2b1cb8508c348494a1fc828cb4d983daabd5281d363d02621cecbf88c7f3ac923d5e16be335c55cfed2ba293eb96e2c85895f9d239613032cf408e31edc1a87d48d1709453a6a41bfb96d00b7aee347a3437cb0c0a306e848858bfe1f5b51f5a122dc52bd02f479c00421d797e2d1a502962fbd7322e65a326f5bcf3360c0bbbf6593f695f5820bb976457f81314c0e9bc7ddc3a713c92f888cd2770785dec7a7ca63dbf06ebaddc0356a71b53d18c6e3d643e95669fc13883878fc929f7b8b49c3f30e34a10d03204e9cb4b241a5b329beffdffebedc8a8ce75ef727080e8f36e24f822c4de24793a9ac4e444fa83718fb876189d53b386bb0e339cf3cee31e1c80d292897db1343e38bcfe1004a56243bf16069a0e480a69b3ef9f4704849a227d9149e5b518fcf3f756f026d50c573363332ac9e20a2b7f9426ca678fe272bf132d3b795bd8561308126ea1b64eaea755a3587ce856e58aee7c30b9e8f5e40ce87","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
