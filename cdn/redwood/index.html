<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"118bbc6b4dbd94ead07bb38a2580c69929394346d45acd5accf54bb5b6688561a6bc7cf56516d9e2491cba894f51f98378a0e162d7f728e2fe4a8597dc1a9dd09eeab16000f2eeb8955aa656808be9aff5392fa884dd1dbe6be8f7bf6aa5adc381e0ac12e9294f72e6f778cf925df411ab6456dc0fe639412fbcbac5eb76e706636770d030a55b88444bc18ca3f2a7dc93edaebb46eeff3d58520b65e54b6904ba04b36ea46abf54651a5b597714234d6d90d9d428fbc60bda743273505a4ec141fb67800f893223e69c727892b1d14e9c3f98ab627328ae5c61ca2aed55632926d2047780c6cbb27ca9536dc6fefeade6a63bed5cc2aba4ee58b8318c4d3701db035705ca556451db361041ff8a8657d3290154669b3fd1402ff5918226ad1bcf0882150547c0f19881f2507f4aab18cd1aeae0372539d9ddc9135ac18405a75d751b0745a3abe5df57cb63be1ccf7fbf60ff1376fca2d5f23123d54c708665c36c2baebc4a1f4b5b9467d01134bfe5b6f3e59ae00d7398669bc0aecb8d65797521ca4bf4c4608ef8480caef5a184d13cd742087cbc4127eb2e9127a2768316c31463fbb128d0be84b26c69e2ddc2dff4ec798ca364191813a27467602655e4d0da8cf1291a0d67e3f6a6917c16daacd5ee0641ae4c49e42e07f90d1473655a016f58da49840f1c9f0c4878a17ec3f50c4ab5da585c2ac6d944732ac83d9bc251158dfc748ceb2ccf60c6cf05996945a6adbfc9e6b90b2563350a68ed55d80be2b2b5de34124c4dec4e2980e51be55316018831c975348da60c18d48c0cda148a4cc162969ac65f4387b2b39b029f5112b9543c1ead425612485ab895547bd611c04c1a2cffcb26f7a531909f364322d2f4d48a2c3e8a20007640ea8ba76440b3118457dc200d00f67db66178d76ef54f1fb158810f9fda1682b03772a6c4c916c58b9f71293f0cceb41b0c8cade169d4fe30efed42f9d0e8d30368a5c5249f04594bdffbd57cc38dc1e1260e145895bc37faa19bc72ce08d49d90928d35a176f5926ad3efa2fbbbd5c596b70050555bf101be9c691972d7ec774383508160db5b30800c3db76ed8b16444d30a9724fc991eeecc4b4dec3972187b78ff93b1ed53dbd4bc03560da92f03e173a698a4f59f81a2c2ad0d470531fdede0cf58cea133a2b672a28103df6ed878f34b09447429f6430e972597739a6809229f467d646218fd3a02919b32e1cc68b7e2f2e6a0f6a9f36bc71009161701a9106f7babcdb332515b37feda60ab089e2172aa5d234fe27cb120cd98fe7dbf2d306dc498bd19502c4618b083dcf1c70d778eb53259accaa2d937a26baa6128ab2fc62184468404e5f49425f6a5fc9e871a1716e6ae6697faf7fc5f9193b98d227b9b90240b9d0b29db14654e86010f7d9b41bd84a28afd5b96e950fe3560bd84dadd93f8511146695c2f8f09e800932e9be5b55e6c2ff3cc25f45bb41d077f5575d33cdfe3fc9a614ccc1717baecfd503acccd3c2163b8ca18f44435c763177c25521c557347a67736de0f8f96e13fecbe51d1648f396994168b99e70d05c2174a3d5911114a2dd06a70fd5b3e9d2dc0fca0af57e8f90d56881be0c8577ae9b95a666a270010e327c50d43fbbac1d662e02a681eded0dfcff689eba7d7ce4aeb2c46ce7d859154d23ee0b81e8a00670809ffa68690ad579a5aa9348bd9a57ff1c2471cd414f18d0847196edc8754a659ce6ec2db4cbb5c9d9a23dcb06c3f62caa8062baf00dc02d3157f88b0713a259b2b3947935229fbd465a10dcc96e426e9b27995aea2963aeba01c9abcd8ea295fee57f9c4527e64ecd2a3ef88c8bee15b4cdc6480211a31288b51808416278122a8c5c61169c43b84ee4b833945c8598f76bfbb0fc9af7e1a2b8e79c64864ffb3bbda7e04c46e77837850f714b7699f9883bf17c7546c37e37916401c75544080e19758d6b995489a66d3bd3008672aaea619db20f34fe0c7bca6d121d886106896754e662de4def4d1a12b989f6b9b36ee71ef5d3905815c12320c40fb265e7f5cf254fc6e4fbcfe2d5aeed9f5a9039887ce59e84e34ce009aeb9e04cba6e353f3d9155211cfc966b6aa1ef995abbe8f29b04edbb2addd64b3f69ec778557e0f37cb5a3aeb1783f2913bf02c0cdbd78fe46f2243b44dd327a8f5121a76ca1f9f380986850ee14acc4c6656cea3e700efdd22ee067fa2b7203691d024bd591fdd33b1bc9d2dcc5156d920a8fb48f598c67f950b56c5ac1e906fbfc802f6d4661821a4a1d52f21f6d1c1cb3f9311bde3a52b142c30bf6f52a26170985a14908706ea35ccf46571995042646275d0d4cb90cd10130d41fa7f637eaaf96e4c68c432bb798b189c873319bd1d646494fd69b30fdef773cab19c38124c9d383ece2c501d61c4c601e5c1c7b20f92b399a92bb49f765ca34069f388442a0201781b50319150dfe290c3182247ef027ccaec8bacb8b2d5bdef7660f9bfbef6e2b2c23a3c661019f4454ae25b3ac20171875f1499a0c1d74e854d0c494f887e1f60617c6268cb879f7069bb76893a4fc79bd529ab5603f6717dfd2d8be0c600aba6ea8cacf3250ffa3f9d860ab61855d4af8f117c74c528419d3f5efb48092863f56f9f89af11a96bbb2b96f5c3d07029a3fb440d35902fb15b866f4d0e4d22df4f01c4853ead45a89c8915fbd8e738533b8b190b799c326a0b360f8d4cd0be788262f2bfef5b97dd03d86eaccc1503f3ee4417815b281e14e9453b57525d0029bf790bee78df80573313a757ae41f0dab45e50d7d757059e54e7552b43cf8b74fd3d1d638f64e4e0541bb178eecc93981b47992a11d0b8b2284206cde6f7dfd933080faa6aac95acc0b3e04b3758322687096ff9fa6cbe17c8cb514146f2597af3f01db79a5c8fe9211d006e578a5b2ae2cffbc133c37bf655ebd0bfa272f111229d4eef216c3cfbc6484677ab4f1655338782909a1c75517ecd5722ed76b471fd40d533e7234745864062237c89f067cd6d559a37829e4f0ca9529fef986e8b62187506c3e94bd56f5794d5553ff02e75b454035b55c619d5319f00a3f141ea49efba8431896b307a6530ea4ecfeda12894331de7692981b12dd836296878b8c4a2344faf5f04dbe6304bba19b6607d0092fa873dc3956ff0be69d91f38472d462cc749086c3865f19407624573aa85ccafa5b8ee5e97d7623712204b6a355cab84417ec0084d79671e80d469a36a397de5428e36743982b183d7d1a597e67e9ae1447792ef3bf424f7d29c7147c3b5adc9bfc031d3db713c488e883aee8745e092179d53a7a9fdbaef8620df54d1327442698615d0e54280e6436e4e2b06aa65308443c3eb659f8d571c023e408be074965144bea6e355f5dd0699c0137372a6c1361be5891f7f31a371d8f851ec6b6e1b367746dcc51ec3583967db28078736d55cd6d50ac3e066ed103447eabfc57e4c4f87a40655775270de4c87e84364bff9d88bf4cd88b8dbcb92f36f85d084564abe735fede7dd4ae4a7360d5ff6a7a3c4f0178cd76dd450de2dd6a20410c716f69b87e0c24f20819a0a191fab346826ae3dbd9c1adcf614916af6450800f6bf28f3f7e5f77d7366142b89afee499fd84ba04e4aa3c66d36f7074b7a9ebc676f40c12aa125cc5274c39d73842c710cc6f0a67f048e2fca18aeef1c81d86b1716116d2f0cfa5606cfa33b39fd663c0930b095500f279be968bac722483bfc7d31f0f421ccd82fa9df7262249e1ab9f95d122ed152be508fb381e356aa0acaee287425390d2e7a62e641e08bcb0558edd558f3dc6f0fc95d3a38b33107ac1d70164b39297d5d68a532fd1ebc4f02219f6d53380b07715d981901f574852f9e4b103254380fc37934c7392eccba449aaefb58ab3f5fe75005e7787b331f2861cc501f4f938f4c669b53eca7832bea2b30869baaf91fecd22549bff49f71294c0649ff498cec6ee944019f4c8d0974baa46fe50f9f8ab4950fefd0aea775fcdbcbebb1d88aa8b76e8b11af7799ab26982f1d94504b75588ab2b6158707013106ff641f521d16c93bcf99d1c5a601fe5504395430c1d025da6e6e176ba17da1e69caf034ba2e2d4287463ae0bf252f9850b5bd1690f48efa9817cee8bd8dfed770ca4ccf90f1350f55fbabe64540d3bcb028521112695817b314da7b339a0a5695d5875b6e8f338eb36fc9847ee45820964d3348b34a78eede03916d6df7f6f2bc96593bc9274c5153f26470e2f612a3b6d4fecfa2ccaf99def4a8c19bb251e7b8f28a01689f0a6d250e768276814345d07466c96a9e523bed5b0223001aa4c0f6fb6f1b476dcca969388b9a286a2f62a7450560723c991021955cbb9357cf3be1576a1a6fbb8c2f46339088bf0e70cec401d1059015c157546c217464fe217abb7fa36bf77764e106a9c5db4f4408798a895e916788e584375266134385af0d0222e686f59114d2a4a67d23aae4bedcf42a6d4cda09e9f87556ebbf2ad6c382f246188d9c914b103125f2c951657282621b72b7898bb4fb990cc0f2308db647e45d163f4529dbccea7ccc35a11d52750b618f93bd9f0db19ba9dd7f1a7197d3b4c116ccca5ee585c72c6aff596b6f3c4fed0a5dab6261f7826c73e9800fa5d9e1c2cce725a6427bb040f669508319a1a136ef13be4bd75331e0fe8f62a3cc2ee64409dfdb4db9bce9bf38b5b52f73aa3ba45ccc3e32b00de90f16d4db4c9839bc40292d8370c5db4f00e5fceca4f0bb409e45e2682a65802b0a7624ee1e90fd40d94778b954f79e87e0852af4ca6cb1d6c55e84eb77fd883dcc0b4c8e9ff7a39375aa0780902b3c35344e7be615751e405141bd921a91baaa48778d9175c99cbf51559d9fc42381b1b2aa021977bd72683f5cbc5deb30b9b494717d00684254a2e127435e49f8ef0b289060c8f21f7e86773c2dbc9a903c40f5119c2fd274165e93ab393b555bd53bc66871e88db69abd3925c96aa7d6511165b8d995d9049f4b9fec5946c7b2e1bbbf69e8b21ae82e7975fe910465ee0c5226339192508728f8ca05445def44e7fa6ad23b6750dc0ae5ea3a4bbee0df561f83850220f3a6fec1fe26c0467b5d82ce8e89ca7a7e840d1354838778bf6531d38bc67392834a8dd236ed40b3909b5316680b52574918d69669f01eb9a497197f691601eb681df88f1c83d9506753eccca71fd13ed51456cc9091750181b746ebbb17f4a00f4bd46be13404ead71c76cb28e5388ac16898dddf9f25b74097d85263524d742ba718cabb9cf0fbf8f7950086b35251193f5e0c68f40f608cd3d3235dcfa4015faeae3aa81e07292c2cf1f7224dee5c08930878bdb82aef18eb2e01af9419c5565ee5f92a79cc24e0945d84c0af49433a92c5cecc8c8233824b9a49129dd164c4bc621f54c97817e7b233b7c67fb1b555ee030fb84bc8f665ba135bad7ac165b40315c80466f980ced4e995095411aa228f757508de3566666c72119ac0d585e7ffdde2a07b4e8def29f907fe179998d3cd61dc62c4f935746805f7b1da159ec19b39ae7ae3a34d2aace2c16636fd80b578f982fb8d0341a991199aafce75c3620679ebc771fe095e772bf7534d764c7474e139ef2f14f94125e7e500535e34475290dbd30feff203fb9636820da6d0633dc88006c3e8e83ac4a5914bc5b01804c9856234b49190808fd457d10790e451b7144de73af8796d7c7fd26a38a0e9b0220fea8452d50cc62b7c69ccf184130c91baac30798412f8b50c79ee106ba6e57832049db8d42e9498f87adf96baa60e4e11c45eb1abb22024f707880fa557102604a0f87de244b5aae1436436fcf2180e0b0855f2df5caa72b8b1a2c883d273611151ed2c04174020a32c5bfc0004a389f8dbc7ed6f841d9fca1973e052c811b3b04fc369b7db19e9eb0dd0d68bef14335f0938dce6a2064aa71634ec49dad127d2e24b759e51f4a4e693102a7b38dbb3bbe1e62e0c8c290c67072801b9aeb94594eb36a191fbcbc132c516bd50bf0246a46dd068b074bec17e913978815be23ad2d667d7ac8fbd98aa0183ec9f54365c6a69ea57859e2a83d73ce9c96abfad5d18be6640c9fa7252c94621e17c7909599b2d161c9e6508ea457d4151bc72dab9208fb9f12fd2def81afce3dc89842b46dff292a5487aa344cf1577f044ab2a4f5f964d8ad9ad1ac03bd812b81b943ded3189291f44f98d67dbf5b94d70257f571e459df38795a2b9ef81da6646d6cb876c66de6ae07a88797ac6dc65882b2da9e7210edd89aeab99588cc649758f48b0859c65e330440e2ada523e0b708183b812bd77202f13356839bb60f6bfeadbcced8d55b29020c2f977864e079ae5728c856b565c100e423bce38ef08e08114efbdd0548e73d0faf65ab83eb8e320d79f25ba08d37d6401fe76157df8dc1c319048e100922a4aab33035748efde66476630a920db48c14570200637594b91cc5c24d18201614ff929695e4433f91ae36a741491c5080ee76a7ee3954c4af7daf29ce492733a6fb206236e412c4ef95e4b5f8e3d828f68ea923e2ea2322b5b6bb5965509684635d8baecd75bc75936e2b84cdbe64ca4ff51ff8f1c49118cad9f20007c33674fb98029cc9a07b3884e5c41a49bdca6134f4bbd9d693ef4b501d720e27f59bee6c105a44673d148e53640bfbc9e7dc13816e0f92d4ce817cd6818c83c48f0bbd3cc02e1297486e43346dbb8e8e489004686cc7d42b9fa9f500de81605e44bd61f27e931cc6955c1244fdd855c6a2188c4136bc03d39b6378b751e43d1734f39e583df7334d201b7304fe7d1591fcf7d3a6e5f060c3f6c4e616647c99b7f8ab45f677efab90b81c73a07b98d19a4d490572a226693f7ab2aa5305b50c8871588ce2eb60e87f7ce32741515cb15c96424a3ca3327c68f03397cff9539734ce0b20a4642329a9d2785ab28451994b23fd7793e95fe21416a00ac221c2b9ed36e4d55323524df2cd9f1eecfc4ad4ea767d681919f252224a2809692239fb2e4e16703e5107f6d0327d0f4bb5c7bd4e74b154e344903ae3b46ff981a875f4e15ee3a01efad8058750688cb5304504383feb8ced8e9f16c46c960276f9600dae683ce483b20a197452b4873ac570e462aff54c6fd1fe80e80d23c5c3b795848eabef4742db8dba91cb3eaac6c995054b6473f522cbb69b7c5756d45b1de004e49cadff5814fc34788e75fed76d1af70354a133b9cd655f58cd6ecb42b98898e1d3318b4840cd771624ff140e8b4df2b6bf9dd7824baebadadfc0a5f6fce137435752838a3689ef14a2b83afcec1df8f9680ab371a4052178339ae944b78bf39b5c98170ae60a462e085150890992374c337f56e7ea09fbd32c3f20f89a181fb479af11be3279b605c470ea2cf24602d36d3dc2ece0a18222a1488c7ee7e85167979858118ee0c832ec30364a6a3020af7d49be6c84bb1f3973fde0161a4e100105cf4f6def8490839d6d04ac3d488ce57d4c2a6e259b5f0bd7320b84133c115fac674a1a42157d25a4cfa80d6f661c2030a127ff8ec91b44e2434ed7346a1e920558ce2e8f2a9c0c7f4129c6a032994f732022a388298243e709bde0b9319df45908dd288a2154f2d4d11e2f00372f6662390984d7a1be716c32ddf61b2bd28bbabf74d906ce08bea0698d55a4df67891c35d317f44d65d41f318564ad6936e1664d66b966470f1b0f1622a6426d07cf141d977432de46883decf4196bb3638fea8aa422e3b37d1a639b6621891bdc9f10b8b1377f9421277aa36a65c774a36d62e9c684c2ac403fe810feb3b1facc9fa6f8f183f31fecea95f2c4da9bfcaac11fca01093bad35d47402aeb1a24787b7806a70de58c921154470aaed2334a65994f276943571756c2fbc469d1a7586afd6b68dc6b6462a509ba580d6a3d257d0f1747f0d99a6cce85df51aacb296ca700db6c7d0e77f1f3270fb5bba70cf13241c42c6f9de83979fd37c0d1ff394780ccad116afacf103d0fed8d687c874e3aa32f097b8b5ed228376860ec5bfe218907c344b1892b614ffa9a850783046601f2d896c72be025ff4ba3b853172e9e301a03ef06c5d9633681aa5ad7210bedbe2cf99eeffbd14eeb3385e0445230773d2ebdd71990a9bead787ecd28727ba34d71c9b4b74ed1b7cc194a88687e64bc82b173db2b26634948bbc17395f47301647eef762bd85836d84e7b66f422fc78f0b86e7f59992f06f89a24d0ca2c8d0f411c57d0c27556060eb1cc1f73073dde8fffcf31b2c98ea2d36811438ab072fdb4c81a5f670617c602de1b64a00b912608bcd55e38415d66e343257e60f648038bffd610a3ad2365e0a21a9881d2ee86b25dde924a7094ef5325af849d3ed974b737d0e2e77c98b41e3dd1bdb9fa413b41b6e58e02ba511bcb9b7e1cf07d79392e35f040ddcfb779b9ebe4d4afbbf09b6efa6433554164e4180b51ab4c768eb9d1493bc6d8ba3d6fcedb61ad07d49d36cd943ecb27745f28f866870534805b4aa9a3846a8a7278b27e1d7c41560d9bdaf92c8d063f1c62c5124908d9e7b73599ea528b2980980e4066795a1f7c396eeec1a6e7295d40c97e7ff93112ae2f03e52b17a4bfcd4a9f62af700819929f66399a912f4f1d95e93fd59168f8bc796f687a15cf1e4abaf01e079734aa4aa718a67aafbb61b0b061a803b9fbcfd93b1eb1e42e80afb00af765a90cba37a43a10a4fe3d7da70772042de98dd352f4a537e28f3b705c28bed06d7b2954c87470f29ad22f6629aa9abb4396c1619611c9ec5143122bc70d77bdb3a2d4ce5bc022792852727e3454d958ab660f680edbf0351451f717d603274ec39f96a4ed23818659b9e979900bdcd37c2cc3a3b7c9c29f073a8206f63c7728794d096b4351b5c1f775c5aeb7ef32db956422e259ef97d6c6e8110f4b0c51c4af8bcef4e978334b5e1257c58bda2dc88aac1916f4f555835655c3f35c4481ea1dc0c59429445f13bc242c3d64aeb07a6466c616b21136cc68e2e7df4b5cebdc1ae139da3d8ea96b26bc42fe5188788212cbb923336ba509adde6a500c7521822aa2a7e089383b7ace9f094e2c5b41b6d758d7839bff889b2a972bc7d3257b7f4f308dd27e149a0c36c1a974126f8c2e4534b8f5b7e30138c9ad8094c3ecfd30458715aea0b84a814aa5c4f07f536b326b5ed533c1203e04e6711e70b224bd0defa244ed12cf88f50983f09cbc300701f38a6dc8b4d55b111950d7da4d6ab3e9e8e661385e816c7d45b37067588205042b3375120c09985b049efc4f76ead2ac52f7f060857e6417648cca84d20b8c1cfdef1cea66fb18d47d7730a90d3e2a1e185d4e332f29618c93038ad04be9658924206bba0389c07da2d388e06c73bf274533fe0e75068a7d87246a3fbf1157e0335c8d49df13a842dda662e034304b228a03142fe572f308f2144c7c7c8523c7c4d09f9eb3dd0def9273283c0d4bf9404b49846637e9bfb9679533ae7ee421672d7a5d25d8d234cb21075372f4f04f1c248b5471add8db49adf643ff2810bac307b817be1c4e96b19ce13182eef8067da6f510571888ab42381339a80c3306878365a98781894a76554c297ad927ff60d74889141fbb44a3b905fe661cbdf9e571e9ad444909e2f3144069660d484b807b0fbb890e7608575839878f58765f557eee6135580af97b90a9f2cd848c1c70a47c47a98d1faa85f943245cfc2fd819edbd509b60652e354e10dfdea370d504cbf17885ae183ecd673fd3bd3411dfa6a1a470e5478714cb12b3db58140c97025c4b017ff7732589e78e4bc1a83e30ea51ae9d6ec493c889e5dccf1d53842a68dd2b77f18f1a6ac5ce7dd36c8fa3b655555c9abec58f2f94a4fe1faf8b7d982ea07a94ffcd12ef1650624421ea01e49ff71ef1773c1a5cebdfb984061fe0dca44049fbf58b1f740e9812f5544cb389d2201474cd4129c7a363be771bb6462ec66d6c4d8e3ea6d4f33e1b38336802f08d0a0da4424a4284c4fc6d20e9d26e735f9d40ede0a3bb84fb104ba483e3a164d0a21e8fb37fd19214a466de18ebe8ec45d3eee7f500a38585d637ab8da46122c1975cfe31307cfd46196c1e02f1b8d3558940a7403c9e66abc90c494ee0aafdde7fc4cbd69f73e8dfe18429e9b1986f3e9beed12ee3b01e20281e83c6d0cdb28907b9a22ed4552276ca546a380a7c40f7183343e61bfe8a4e3be9ca0fa7d24a63fe9fc411961023fe7c2bbf8784d06fbbc44e327671a1ba1b594cd477b57136f25fa171b7bee7ccac6c918ad18ce13560d63253dc8924aecafffe38d764210a33c1b91bf0d03557d907579093aa2648d148268d15d9bc22f936de2c76c3b287e5518c6c3ccd7b2f59ddc004ff08b823ae9797c83fc4e2af504945eef1beebdd820a5723329214c73289a1b8dd82b1279d10fe64e55ebd0650ca06c201a6a3769df0fccdd94d89be4d4254444a6c9f82d0e56df0a2544f839d5703a38b173cea380d7126a1c483c539fe25c3c04feba8263f2a7e798365db5375f0b74e0c5bd7f55708dfa01882951e5467811d8d25542665cab610b9a3d4fcbda00b60b4199bff226a8d342b130d81495ac0b129fcaa01814d632ff90051f0e0c18d8a505045cd941a4e6d231a0dbf6e2712ff8cdac8d583ec1f1eca563e0fb2052cbe8fbf6b45e503746c2537bde5293098d4dfc78a1f4beebc1dcb709b2f75000e100ee289cc34eca6e0d05b9244dcc85991d2aab98736569f878c1e27dde01a530a7658580010dc58e78185702f21dabb1b7a790fe01ab74ffebb48185eed8179c0d15a64fff13ec79031874bdf7ce2733f3495d0b9a77307738e1c9cf249f228dbcf9fe82ea78beb296d03b049cd8f4590c4703d231b69197a36e35222c2c61c8d55d78bb37a76ecea30b2a4666b48bb6fa66565de7cac2a796177a982b2701072950a333c4c73745ae878910713f8219dd4f3d270c50fe2eededc4e5388284ef3924227c5de35b9cf0bb13a45300a3adfdea26b8ac73fe4bb3ec1f5fb58acd1c298fab2a876974194d4a956327aa73d4505bd1bb78c54e022a4ec6752eb8b100fd5a10687c5013593320f8889432a7e712e61dc17c5e819f13bf330a992f5030bc516decb017dd0efa666c5c96e1cea8d8f46f5fad5f073ba7a564a7cecf8ff96f063f67d9458c2b38ea6fd51381317c7ecc2cd82eddd9ab39e13bf6ba89bd835c60de7384c417a715caa5641f3242f3ce8d1c1051ce0b88affab0fb0fc0e0d417c5f5128a6ce7dffc97e2c917b289dc366fdb9bd1d175f9f933ae935319dab206d3a5dde5c1778e9f2344c9fae2a454a5af250dbe3a9dd09db88b06de9ec3bc3b343f17c91fc047a0998c1519f8d56140ca57db72b9a74a08bae2d3d8d5bcff3a60c2145e87d395d1f08731ee21f6cc653e1b8e2927655466327ec1f9c0b49e7e94b8d9249927adba37765334ed1f235cdda72e16c105409bda0f8ae6107c40e0ffc46e630b26d52da614b364a8c0b9a6b80775b8008bb6506e84b2376b89a70084ab8dcd4d32bc47b6220225deb1fe544055875705ca67720bca020c3f6f5171b5eab9077dcba390ce55c682b87a7c7a219e3ca80f5af9cab5ec9fdcc2e2e88423c3630505263cf61c71096bfd833f2e1f6c03086af49ff1f989ac2a7103fc3bd6bb233f29af7eacef163f894f9c6e9933572b2c93cda560df3d893e5914058c6b637976bcb8620fa9bf28a10eed3c5b1bbb8c8edc993a8195569cec3f83407d4bdb6583f37a9e35e62635bb487891e5658fe815f57571c5ab1e86b984395a2eff012d1d9c06633d8511e07365d357697fd29911aa83e4af51732709b01a9b547661e51772ca83bcb601ba22edbc101603c4808ce2a4a35e0d76d258cec4048112dc118bd447b6f9dc0f658529f53dd302a7df1734491117aacaa57832892c7f6b4d660682a4f6f8ed63be2aa491a18bbf4ae27c2b058f8ef89f43ee086f12ff243f817bc57135afa01b32cede854a3de62e180c754e9e1ff0ad030b1c6fcb91f21b7c5950a03ae14541dd08d4045e5cd11b1da122ef9325446aac3f6a11f6dc50c5c8137e2987b1e8c42996d3de62c9b734bfcab55df7b43f697bf72ebaa28017d84ab2f2b6e9c99110aadfc0b24851d57a0d9130b282817dd58f660f88077c6e3a4b41668649cb8992be2e3f8fbe1affe85c4e6511e5fc58da1226d672279a33061f4d44e8fa0aad263eed6dc9b432cb1d3d9c9c55ad7c9c6fccb72d2df7779118fc704e5765c47a74049a31d139b61d7bf8486ac56216b7018e6d05771aa70a397eacabf8e6b081cb3f07eec064ef1008bde9c2d958b2d0e6b174490268d8800267f818b2e77af9962187eaa5b6ad9b902f0dad3878f0e3d9a16f8190b2dbf2a2fc4141bdf9125b5314a5c5fa72febed76f7686231ac223a1a999e16bf08ed32e3ace786b4d15d70d1367b0a7093f253909e4db93db81d3a3dd32e3c3eb8e66941861f46fe9b68ecd58915732fd64e64d9dffa53da273e7321c030151f777bc55050556e11b16b4073fa3a17e2a16c1189c60ba8c289039625a99f0df6498250fd9b365caa8b401d59518ca513d7b6e23e6429f37b5da397c4d95430b81f9b4f91c16af0e9610a16ab49cd6ee0ee9010ed89aa42345a67d5f3892ed9994920763e96f5993d96c60dc8393694fa0c4f7c262b525a97281738d0eb47babd2eadf5340dd94a40065cf4ac640d4e9eafe51a35d3d25dd04b1f3d43165938fdabfcea22571a92bcfbaa48049629aabe367a92341971efde340460d563fa0bdd3b6c8f373da82252b9df2ba5eb1fe9ce48e5add7e083f8204bfd0ad5ed514a02c015185779d00800882209b9dbf0f487ef1d9e6071af7a8741ba3e04e9dc9967e8f1a45f26e13072e94094c385ea51060506d1fae7257bf71acb9b72fe929bf88d07421a8adb1dd83749a44f4e56bddc205a3522ddc2e8d32fbbcf5e4e472c693e6ee48651bc0220263214522616b766ae3301ccb89a37b664ee093a574351563cd688bed45617043b5a65887d89ff6612ddf6b5842dc99dbf6064eb72ac2c5479a688b557f932f5fdffa37c13f0ab7f0e96d934d8c0e5dbc9d09873f2a5d3449f0ff60f0e36ec5ef21475f5b12015d0717cd4647ab116762513ed0f3cbc5a4527d2ab650a4ff2d101ad3f6f2d7682d522098f8443d775d862de60972aca5e7102ef1ceee7e25171b475220fde3d81ccf149b888d51f26e3c75e335c2bec714a266c029fece409f961fb796920fdcab1373bae945689e7f9843ceaa8cb7e82a9398b1af41f160c2412aa64b2e1b76e60f19c93802cb949013a34dc3c4a281d18a3c60457e93f779afc63e7e5b80d1dbb6b21ec40cb44b08a6bd51761ec4c97c7d3b9ee3a6019ef414908372a0feb3a58cf5b2d0edf146d1f5d8790732eaea94fbab06fc98def750a5315ce9553fe311b87e1cb7b18afb890d405e7b2f371a4f7a21062086d2b03afe58679777de485c687efcefb05f81c4d6510bf22e426d81b27c89a1ea1990c604b9b448a3f23366304b4ab841828d773a10739d001df39f317bcff2acaf8b25e35610a57dcd947fcd9bd82cedea2c19ea4b4f3464af8a069cb84e88d8d561e64282973b4b6eaee2e74780276e41fce13f40f588b38db756cac488c98cdd7e56ac8f0035adb8b30590d02be9436e13a64d5ac9f9eec441369b393d5e4d55179d9b706eb73883f9b3ce8e765ec9286776c4139ed6e017185df49f88b1b5815c383eed055815eccb4786f8d97d1d3222b1e1bc30d19e646df159d93cefb8bbe7df22f4bff98306cc6bb6489ada828aee40c2ca1a750a85bb3ff00e005d754e42457f8a1bd5339891370af444e6d7e9baf79658d636d5181a9dc5d82fc4a7afc82fe64b4f0d7370106433a1d93a77b8f166702489ac698835a802e261f02f55739786563ce321ada29b031660b9a5681a6b779494462bf01c638af8b09b195fc5d0e5dfffb03c5775d23263fcf7a5187500d5e3c421036e055503ed5c45d2b23d4b6903a8bc6ce0020c60b910517134d2e33ac4c529272abf6c8851bfcf996eec384eadb8cb0a11bd5be1551b5bfadd5e63ceaac604971021ca58d934fa15cdec3c0725df6a38844c7ee07c3e11bfbefba913ca87a1052ab49a5a39f2f42b74f64b4ecdd344da6c1e8532eb845628b0db07132f244b4039482e42447e87c7d510df5f75fa62fd4d6748b22fb6a73e2eecfb1dc595331361d7faab6a9dd8530ea026286ac63f7e091643b04e130f2e163533c53813d9f5696b01a23489a7560ccc8ffce7367b8f07d8389bbf7e557d7f4ca2bac358ec7a2b7b8de46ea6591ca02227de358bf6b32a91daa84a321b0876e3d9de6933925a6df331764efd1643888eba5fd43ab1e29e6b72bbc322aaae1e381d4695ad5298080a99590e30a441298c1511a3955864badacdb3239e9445f951a095b3029246b96f91178b56cd11952c844f0000e839f4df47913bb0e9db2f250d1fe48a4cfc17f9642f472d00b2d43b1cda0229f0b1108d19f41040b8225922e91bdbfdaabb6f6f6da87e0af0bc021566181ed3a46fc9f3012123ed7337691417b7ea34762827dc6f76935f94a9f9924a2bfa08d42224c62adca51877ff8ee51c6d6e4ed25ae9809e3116683a7c4c8713a3daeab4e2c85de136db6c858d5bc0d4af55c60976fea584767c56f3fd9d010af4ab5f0bfa18f1346f896d7c1ab47fd70900610362462f2c2e3b200595819a910d88ca9e477366a8d64f56134e308d3303ade287b9903ac8d7657e4e5420f25af2337bedfe18d077371766241e2673aef22b2f2a33802ae6436676bf13f5a56b2c1f9e814349989ff4de293bdec9e3ec6909f8cf9528859aaf832dd3ff4262f976f849a87e95720d4c891aec72aecc144c6c4effd4c61bedd42f4f8441630ab7b4d4379761be7fb5bd4c834c13e62fc63e95cdca7022edf758003949d09ab2b8826e84e210228000af3e6b341f6c66ceba222dacdc9a35c5f021517254cba49376005af13c1dea64c9cc589006307ab260b11be41bc904c16837ae27ca02cd5d550295e1f2fdac738dcc5fc73ea1adc238839c9d5f17da08b1153fae7d7e9acadb901e7947121bb84006e92b61e41a568cf0319920f26557d07be838939f58962e4618752afeff949ded4aee7ca5af3d07806d66f41004f9da7e5a1e25224993e458e8eaf4c839e35ca1d055380f05626726237f7cac67bc6e2b9901411f0a05633635a493635733996a60b6057263c14faf52d9bc79e19be3cd2ad36a5d8c4d4bb69503277c465365dccdc00e4c943d1bcac0b9dc7bb532ccc6930114e86a570e367d0dbbf2a9cadb2b4b712348867e093ef4618b7c135a4585608fbc660cc3a801044d3c778bea291fda73baf635deba96cdc33c3dde76e4cccc404ee9b2355566f09d593b82b4838ef70b357d11133a06e9d367b3b460164b0d9ad6f31d050f6980336a36c0975735374a7d1750dbb558f8758d44419225a3f226a0e9757991f765236201329b80bfc7195021d3d2e6be88ae6e5bb30c6d86b196aa446f1e075c8abe88253f4eb9a7cc2752c27ef3a0e768432c1e66a962d8dcde12dfdead43f2da628d3cbb1a7c817d0c79c5d1fecb9a52445d02333071b0c2d9c4862bb6aa122d0954ce3cb913e423acec9b45d313c1996b3093e87ded35f295f1799e4ff2178d5e9f268ff33eee59724ee436bc1c38673b958690a6474eb5a548ae24f04374ad7df25a776742fa430085131d6fd78227887d01846a1caad148b258aa131dd50051927e7deb043a7aa32f5c0fccdcf886dd09a5a49d3b46b6ce9a3fca69f384d8869ac09d75e793cf9f48fc02655f67e236914ffa523c051a49c2e3a5c9e5111f92ee5ae8fe2fddcc1891826caa40eda56338c5f7fb4faf7678ff8ac1dd05fc7bae5db58354d4ac9ecef2370f11517f0f5646957f63ceb34c6e7a0985e32ac1ce250c4942b74a4f66c46b0b32ffba123e07c0e46ef9698fd17e494ea8efd36317e0e68c100e0aef4753e10abdccfd2d6e6cb90625c8b3121641583959a020b799604fc565a15a4c6f77cd7d4b393b47f17d3d54a128d1e397f2052bf53e1e57c1a7c37f07ceaebf79c4940792c870da9563068e68099478cf326f1a25c6ad7463958628b69c28ac4132420b715555388809626ed6d11b6c52ba66a1fa8175258e2618735ba34fdf213053533c0d702565a49dad85d23aa2cf439d9f626d486efca6bddf9b72482a72feec2358880426936e3b856e69fecd090f205add617cd5b80fd868855250e25b3198d47263e3fd5aac0fadf57338997be6151be065a3907002cb20732aacafc65e1904ebcab504dbc809e43706a5a01038cb71abbc69f48fa15da9059323cba057b730622b25a4f61e8ba5fce677454a46be08d2b2044efdf27a14a21503ce0d26130a03e41e385e374b4da105aaf7c3b1d0c90564ac38f47beffd6170501e9971b0dc43638d14441d16172d40f4ccf24fc0ff07503b1a35fc5cf1f4c7f6fd9784476587f1eb4d2936360cdbd1d8e5979da9fb2f74554a88e8119aaf9baeba584344e959146c16b38c05b782139282b81ecbf30e2f0fdd3853c1681b5d1d93b854e3533b47cbcd50c278a9365851c12d475f6a65da13eea3b28bdfb35730ba9420db3eaa0b43ee7408c97f8c3cbf38c0a9c218dfd0134c8b12473b335864d6772e34de9fd47cea145bdc526dcc84e7d6ff1af9387e359a54895c33006b2231fa9549207b14593f776b4310417db47f1d3dc3b1ac9ed19f53ebb7dd1641bf86adb34dcb9d91deef72b9aab39aea0668b61c5a403f5cd3bf9b631fc39ba8699bebf8675435962e39726944a66fad381621e2bc41ef1f0e793454a66de26d43a9305dfac2fe11f4323516c16177afc271bca26821d9ce981bdccc3746bf2005939ff6824352419e178234ac3abf195262d4ba093f01943f98e576dc6193765655be7d76a207584ce7a24bd8f04b6b1446a637032c5597e01a573f1cda45fb7d28ef687f69151190b43d0a39848288c9f8e738ff3affa8db083e3e0935922ef314c37366d887501578c391e7f8c75f54687d63e311d9770941de56ceabd169d0bb445bb5321bee52b94c3271e076725a72336687208960092e183168b771984c0b983f72a60446888ab37f4a74cb173094608eb9906ae1e05ea000a09ab4c5b23aeaa2775c18adbffc79ff96a16f21a9dcc631dee9fb13fd74d1c606ad44dba0d7c12ae46f24020b7f78b8e1341fe34e5585f859c8a8ccead4f6e24028e0c1d0539838e06772de7f0e1765fd80a7ab796b55bf8a405c12284da880f186fa2931e8116828d66fb630e568b2758576f8191349dba511b955e4856cafd9c24780b4c623d24cf0cea4a6bb224d4212557d613dd62bef4ec4565a89a022af058e02825ec61cfddd193f3de0cb663ab8f35de3ed81a8a0cb406e35cce7334bba3f6267a20b4e2b98a5f7e0847effda67c1807cb92786a852be160ca5d1a1e5420bf4ddbd7f7e9ab93646e1a148789662085368d1214512703df4ca37c350bba3ef64ec5a761ad3511be3a47d0c40a925852c0106ba6fdafbdbf013a0d5f0fcf7ee035d3940ad5940db628c778e458edc0a39afab1cb09a7be68031ed8f08f9a699c4e838fffe112bf102da609228772660d95b72b450757e3064b9f420867997c7e8d90451df2816a55ba1bb034d92476457f258b85a02e8b813011a31a0a146715f553c51c5644f0d2b6ac74bddaea98ccd95e27b41ced374ddeeeb7be1d87caac5dcc10444e45c3c66b94bba714fa0b41f453c7866af2e804c50ebbbb5c0fde0386202dfa46352c4dbce39d47044dd328b8b6eabd22de370314e873ffce33a6c05952c64a8f97e20f62c64f4943964ed20da9722560407e9c74c0376bd2af0d3a383f61a530133592affe879cc36a5a6458faf13595d99dc314eb80a01bd17ae0bb8609aaa196ab0401f03c1086ada2ff2bbf3413696c332e55a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
