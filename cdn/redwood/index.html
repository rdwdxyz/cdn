<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3095947a0067267730ea75258e237554cadbb550c1d2d7004ee7be6801f609dbdce2e2067dc7733c03359d2e9b83a1ed9ede7b7ae863f22ea75667aae91ec509303bce64a96144f237b84d5237a79f60592221ae2b1a3819e086bf2385b9d7cddfeaf21394722c3fb2fe050e11647a4c338aaaef7bced29b85108fcc1a8b9a2879faa259594da19275f1823fa19ba77a28f836691b10c8f6cb3574374d097ec279e24d50fcd5e2cfcbb161b5bc388f80f46098d55ec32eca04dd9517d92b13caa97d208dfa6a4eb9b6cb1dada6d520c02ee789babf562f561133533da5449becd0627135183cc14d1b985caa0f6e93be7887789ce39727148ea01614ceccf17c66df638742b8bf90f1ec9dff9226821408314225a0281f2a8ca3cc243f3c00506ab87d33cc3d1751a212c4a7c4bcf4b5bff9fc31df6cd7256cf94740935e9aee52212835c6a29b28c78c4e43f646475ed40fc592c1045d9692748495c15ed37b3659f724da4aa5c7c88c8cb893185438fcf202a5dd368af8112ff1488c7d0f78c6c0b9658d5fe78ab93997a68bc08734eb971aed421b18774795626b9392d40ce2548e16587eb1906d52afbc0c10dfe0abf7c9c98b2b72fdfced0b3dec855585b9aa681bf44ecdc6842307ee774e3009ac0d12a7d94b23347ff502e9a7c38c31c54365b9a700c89cb2ef0c781cef269c9b95208bde42fb234ab5471d588c9a471600a7c2d6394747ce2d1d1284669516e14c4bf6ada68e31eed5f762d8427b5e6e9c5167d1a53623879fa46fd4d80938d583bf7cf43039cfd6a3f802845da8118e3acdc4cdd5d74072951b7140a4ebcf965a8775ea145ca9e369a22f1d4043b84523eb5e95488f936b61e838434c9037eff62d630457dbe41ad8a8eaf47b409d18f4d8581cb26600fe48eac551f834e4782733ff47b20e59de12877abb3471f03528d8af322de5f227fe1f63e3b5c03c0ac3a96f2b08f8dad2f665a82aaff2a2c5f96a8f1bbbdea9bd9f5d6e4f961a44c9dd63ce49271aa31dcf4e6133735bd12c49f3496bed753639df0aa110f84d99decb0da26f86ef19ea56265f6acf2ed12a3f48a7de51bb75f14efdc8e2e10b2ba5268f5fc06ebd076584b133456edf7c8667c9cc5f631000742aa32257c1d06d1927c96162fc0349cde75be2599d617c28a62fdc8d2ff5ae98879a5c6fbdf3454cb24fb01d9902e6543175dddfe378c4abdd8c7713ebe6ed1f4be9e24e0b634c84a127278d58395ad7f939088faf5581ce6ee400714ad2d4eb4ffed14648c259b1888f7a76e447eeebd2e413397b236cc745f8e8b95ca8738d85461e1c42aed457f023f1e5d9d606099a9b8e2307941fb0f6a9b5329d924b5d454c807f26503902005ae8e8d72fd7be41b418ae8e88c28a0426f9504e04f102e00eed7fce8c8f83c4ec7ad2ca257e1d159b30ac736138c52701c66a0d326673f53f9fad60fd3d5532e2258a1a7312bd4430ff21fd6bfcd99f1514f6f99c4d7fa9943b57b5e5e1c04e390f17079a7d53cfb45387e4476bf7a69528e35ba3e77d0af368621a01744687ad27f86b239788c112a21e28af90cc47398425d66cb0ff91b8679b8aceca6d2128e0243f42b0a231f2f2b19930845a4a81de337d0cd9f18326bffc258dcb4df79afe2fb0bd6befb8d1f9f82c7b5078955cb6f311f62248583bab78019dea13ea7e6b96b6e5205e297fb9bd13d1889272174ee04d615c54dcb0fdd8ab89f235a3c595ba68cea62dc0de0f4657d7a64c038714c35fc33320a34c640c8cd38ae6ed822427f4ee5fc88ee0fe8d8b1c200d6c7c3dd5e9f6d8168f71393e004811d71da84cc0ce3141f675732db8ded99e1f3b7e7fdd1a42f529a90b772b18faa72aab7990b95e164b5980c46d32b4f5640d6073824b0635f381a0f1b76e29473e9d0928e3abb34e7d1771ce724d916e33b2336d6555d350d9de87bdd6423d5b100e7e3b982e9690e83b90735d5024c3be6dde877d190db04d6454c125e281517e545c6577f54a34f3032525bbb38b3a5e9e6f975cd33417ece8ec8fbd177ca52f1f1d2f185b4a39aba20567662da9c75d1c645094387e8af97e2e1ca53938e04bbe8589667f0b2f1292aa42dea2a27cc9b7db802543b546741685c6f2febf666dbfb40cc1b1e8069d3be8449fb79444c4e7826a966db20f11ad5fc117a4eb88322d56dbec9b207b41cde3856d29998efd03142dc9a8dc3cf39ddac63dd2d6e8c39ccc5b8e70a1d77bba45ef27bfb85a9bfcabe00bb76acbd74c2995c36975ea33f234bdfb7e4f86c053a732076b836fc7cf6fa2ec678e0f77d9f7230127f530999f4aea2c0a28a02aca27f965ac80e3d1ae05573267b72e855936c7f5d8ee176251819a13780cda10c8c51c65f68817b08a2e445393bd6e30ee4f0a4a595893092ae450c3204cbe1fa69cd27bd6b7c6ae9a9946ce766c30dfc50a2d1cc1b3253c6fbedd1619f988014f0bef15f72ef737aeb9ca18fdadf9bb95c39ce517baf295ac1d933b4d7d35acb8dd016b58e78c96d839404609500a3e960a0b2ef6be9a86cf34f900dac723d509380d751c53f258e225023263c8c1fc6f263e38a8119a3e1b6216a91199a9a8ccd47a91a1434c94fbc202973e38feec0a841ad6e1213aaadacf4321ce0ba9a35bce8cc274360589e8eae287a61e0be932bf1d502315ea89104ec437e5a1db5bcaf5cb875441aba974b54a195eef876011847a057bdc2f1400cf72da8351d4865f63ecb59e7d299e39b36fae17223a63d72066060d5501ed9eab25ac5574dc6b39b18f1f8788477954ad8c9b72822b79fb5b6d8f5f66a09ee1eb3cd33f782b51df29b974816bd68fde61c389becacd255525ec9ad439a748364e52160823543af9dd1265ef4047c1fd008acb010a4342372b37de0eebfdab57228db43960bfa237d7c6ee93e4e8f773ba16546979c60951083b755a1e996640c1d85f0471b1984d5ab8d329a5375b9e3257c8efe133e7c994daf89a65b89cddbd31a0b733115e419ac1a2ecd487b33476987ffd0a55a938e97441213289e4a1ba24f68a60aec469b455167a9224790b29911d91bfb3fa65a51aa8c99c05731a9250d710843e25c169829f7fe49c56a375842d5d2e1147f6a9baafc41a540d50b2857d8fbb027ba5d0ae972c12cd5a576a8d91ab64a13911ca403fa206a33684396eeacb895e9e47e8c168fa02c1eee6994a90bf80f7bec680ca0efe02cb83c555a991ea93386919187e610279cee9fff40e4214efa83d5683e8177426568cb137c7c6c623d918fb85c4e0209f740e05e8a27d189b4a80f30b71d3b1f39ad49f0bc2e866cdd074f47b7031843abcc333db9fb2939d1fe79ead33732b4e714c9efe504c0e126558485ca9b946396d60ebb94adfc55849d517151861f5410dbf383a93586fb15843bc70a7056cf8a31a5b4cd1c7eac838084ac39cf94ae954cf2274d39348ea3c78fb22830769e5d0e9076b2deff644ad87d63725a6f0731a7a2ce2634bc826ddf9f1544bc5c8a94f977da11b952f51c08d42e422965b366f8899aad8335fa5e7420466f24d786eafa43933c9f624ece0555eb22e4fb4e37835e76843b66c345772b9783494281662347ed883e35a3014463ad9e988bbb93a0a31e1ef2e23d9bcd95c8b3f18723806464ee4df9e9bc42eca1ac2292d72f402df7d8efd35a2a14c57db66731f894fc19ab29efb7d80613ffeee802d5b1a442a72a167c79836fd9c5ac63a8136a2104eef725e7c114e9a40ee485b8359abf61bfb50e31f04108f5752af8e25db2636324bf15a8ff6eabbc48ad8c1a1bb17736aa5432726547dd453377b1234217297d6921ac9eeb9465d3ac4545828f4a573b56f813813e4a7a938ced9f18e00a5b966cb0c1e24c8031e9a9e95192ed9793d2a92f4f0c9e45136157e1ee102cd89b8efbda251a840431cccbfa28499a981ab0f3acf9ace1c492da88db82770dcb658aa4f1b54723bbd28df1fcde0d93d23e05e239baaa1dcef6f9f472458fc289f92ffb9e55d96e8938728ab821777aabe0e50c90ae9c1cda5ff3c40d93813b639219b593be6e54d69204aecdff417ba798392f52f35b765bd17bf0dd671117fbb3f80ce4c112c671fcec69c3d59f0f1deeaa02f36374a038395b0df55559d68f46c4e42263908002aac63cb49792da76b0b51226f91278746c667d1750751df39572a7f87ff20258129305fb23eaa2fc3015a5df61f099a6d948a20311479ac4b3eab4dc4d1e174db0065b0c0c27fddde6365eb8841a51a66f5831c8d07988cf37485112ad5512564b6c8797e16a66777a77e869122dd7670742ddbcea5d8fe9ad8e12ba491e101ec8672d3d27ce056cfd64b72a30782fe04b9cdcfc8e3f11b0ee73bf7e76c5d8620792a2c78fbedbb5e2122bb790551c6756f4a34360a87ef574d387737dfed9c8342720b0d5cc026f338e370ff04f204f90f14814eb932e613b9094fd3fa1190162b2ae3eaa528878a008dcbb437d64a2722b7a3e85950650c87295bbfb4b43eecdf282239a6354cac686d83232ea6fa2e535a87c5288d4c417ba890c428468c044eda63212cd0c69ebd170932d30a7742aae136631a0a94fd7f11f72e92165a03dd84f2e0771671d604fd7f78f3410c0f1366f9c846baad3be27f96535cddc82f80f8fe3501d6d709ef12476cd3870e51909c3d5d04598e720fd24199e48a0b460757e008aaf9e3f4aa7b181b1686ebdff35131c8363f6b44dbc627fc1c59a3da39e39d471125192b04db0d72708d8bc10a1c250955ae352275e1b4d5312ffad468c23fab259364eb9c1a834c7d76b911bf7a5f0e0d289010a5d4af7341cefc6cffdb008744bdffd7cf41b456eadd89d39089b80b010d4e3bb0437707cce1e62b5c92442af87af4307a5eb260d2d1f9e0f714688afc9985582f68557be0d83710fb8eee1dd1ba334bd46d5e45b41e98dd33d76aa9330b93746d50044300859a3635ca34695b30c8265c57b9a2f1f085f25a768bdce29f6b2931f9f97d56dd915d3c4f5e1cb2e1d336f9f08d273ba8d0f7ddc77ca7ff98316400442845f5b33b51f324e1220fc6dc1ec6ac4e14374af584d8a92313916dabb8abe658b1c7b8339c43ca72475b7bf2b074d4a714f74e66ab44ee0f8a5b1636f5a416a578e3b5911fcf0d67f6013e3e9fe9ee6048590f8301a6c8209e77612508260c5737fea1c48891a46f33234a898b4f0243ecc0aa48f034da6a69a55ebb7f4a305af96ee3a4eb4f0c577b373106863be206846f88dc93b69c364031c4d0352cc25cbbf3636e432be71ae697e1d0e5ac8fb1eb6a40b4e614070c1a5b3e7fc4f3c3b91df6fd895c3f703542fbe028a0571355758d3a9fc9d42236204e07c8e64d062d29825bc81de387b3180eb68b3ab6d0b2ccb7bd625797e451635c309c02004a092f1694e9fa456711b06211b6b33b2300488537beaed40dd586e0db76657c3da0a3159405894aa476589e7f8a0cff4fdcd273d6677ef7e84807b8936d8edfd4f60e3a23f137d5be9cc9e81c3514aa71a87f6f4fc7bf58dafa269cf792cce763b0d13ca48aaf86f4f091eae3bfd955aa207b5c1922a8bc33dff2693006ec8ecdc26e9fd2a8079e543b36381cfe1e75de877d7c56ed83208c83d25c8d4a0259fb1cf01aa10023bfad7d00ae15dea2f3219b4e94db3447845328e5f4fe3dcd033fffecd2cc49238ae7b395069e88111453fd4d94412e52684950d7e30790e048410225554c827b5e3016df36fc4a832c0bda98857851838003b7e5995a5972e8be67df606bebaca50499d175cbd718923807911b971a2890b5d4131eda5e09e24606eb5ea925e008d9703be9e813124600ec8d623c67769078c8600c3fb017264e68d0243d19246485ec5bbaf420c58b2fde15f1b342000f15f4fdcf9852565da36178562b70e4acc006129d641a3b593e88c662f7eafe02a2e1266ea8a8cbc5ebe50be485d559102d966ab45993a92a93155408aac82f0306730daf40f944e76402945cc85949f96f378b1a855c4fe63dc35eb0014e5e0e0ed57843df4a2bdf9f56bad83c278b79aaa897ad3dda1710d141a251fb95b08b0df753f700163236d1634125580d4cee93f0eb6e1ff82b36b3a0adff9b7766e24ae5a313419a6216cf9046fb41ad004b0d59c3e65cd7050c7c802e8c9fa51674afe6a2509d69911eaccd858e742f2ded301e0adadd6e2e8b060ec72a5b069d71a629cfe98b0e2f6074d466fb50b581cf5199152c66bf7785ffc30a646dee9f855fa40727a38c77f7371a063250dc271f0588d25476370ca62b497abe46bbe1323b06211854fd86606144c1418e7646678e2923abcad7004bc93e5255586c55bbef0c696f609cc366b812fa83ba3bfb5bbee042cc5759691dee603bbd2f598b8d37ce04e13a198a1f8f6d8b8e857255bcdc279c7afc8bf49293a547c71dbcf229ca1072426ffff7420e0afa7e61c0cc69755e646a80783f8521e73fc1cb56d32e22575b2a2fe1ed2eb1fdbe455627439a76d4e8e3853b1fe1e04a6339742423e65116f486ff117ad5583785b1ea32c45968ef810f9a0b0f93d0d3d4c2633a258bc0c997dc01892af4f621ee483bf7b2607e1b13e17b24fcf9b2ec2806570c14a96b579930b676f956612c9116b2190a2e80434f0bd7fa53d1ce8f882882decd2023f24301a12629bda8fca6b384972487ee54d7d57fd245396a7ecf35f6c2cb92467804fe6d1740c99b69dca0bc851b083129bcd4f4df1dbc84b2229147504c3d369b15b4ef75762462127552a93501aacb5cedf591863a4940f1fdcde036e00efcd0c192c219128a708b6d6b4cb489fa64669bbb8987c74d6819e775baba34261f50448359940a88e92d2cef33a9915f7f54c113a74dd0921b9f2ffa1fc3cbba227d58a1144bb86ecdcd4e5586928f89a0b7f45323eeb09a915b2b76e21a3a24426bee2a1f427a9eea70a986cd0f5fc773bbac469465dfdef50cc58260f7f394176d1e6b758cf294dae3394ad0ed64a52b737a3684094513ec8ad40d57c7399f7297d4a93916b0fffd25457091f43816ae202862e00ab9f6d5c1691e004a97afbb3e086f968c5818fa5e2ff79d9d0ef4f316c1c3b93ca88c34323962c93e2bb090a12ecfe74bbbaf2888ff90cc595d55dcbeb68319f6627e3e8b8c70e2852ed0c132ba91319288426572ab9920024fa0a3e58c42edb936dd06d327d9c7dbde3ce307130a8883a9cab99e5803d5dc503d90316d8d4b04000a63601bc162d8c924c9a7ad9cd601916e511ea57e51924d607c678787711808cbc05bb455f918db64e50f121ff3cb6628991ae32c525b3688bc9fc8df180335f6919fc48268049c69e534444b2432873b2687a3f2c65d74110784ae56990732371051556e92f479bf08fba171f12a733c292af1c1617f0fac0d8fecda672c7b3ef31b0183ca52c5c3df8e249888a38381a4e92584485881ea2cf2021dbdde7e1f4184c47818d481cd8f57821c341d3e270a018f8b72cf8844f0c52805831b100348d680616694b71028cf14eed41ece55b05b4ee6e68423de7938f81dcb0fc28de1c09cfc6ab362c3acf33dff477ffbe9d93f14d991d12ecbc5a799bb3fc5023eb216d6344ec698930d1934838e2a1f4dc4a2518965b6e31b67136f2082b4e37e5ce5b0de344bd0e88c0c1c454e38f7f841822ef52ad21b857cad33f4b30a2d5d994f2e8571dfa08817bda42796bb48afccb30a935f09d2ec2ea96751b9d0a11ed890879f948121e14abd8e8dc8d5539ebe182d0511efae177a761be878455ea20216a304d7c351ce92bc484863b0b01d595c05f6aebcb5f03645b47a4d41270e9ce5b09312069b8aaaf96e00f988c6b79fa38fe3ae2ed61bf807a3168be1254da8e6efc56d3f44060d18c722f580894d67cc60abceef73af373a96fbbbd0d4e1c658a67b2b0eced26298fb542e0363eb43462a21ace45f4dfbb2ddc5fc427b321612cd6844bb0429091376cb3ebcebb379a1d200e702e38e91a6d9974e48b078f690920fc0d32de35bc8cadc273621a58859a18b09e8e752ebd8a058d6692d70fbba4e888107af93f30dbef1fd1d88bd3de0a8e1200f916ab36d3e138c1e2c5dfd0125383dab34223a221399ac78c631ba35a23a499a05caf043bca76665c26e56ad5a8e1b43793eb82e1fa2b0d2fe6ad8474641a370bd9c89360b29ea6904233531a01e1bb8163d1e18af95a9454e8c016b12d0774c7d065fd75649ad17f0a3ac8bdd8c9fda1e65ec4536962d9fd7c2faf927df83249e6bca796baa6c53aecb6de54ad8162b9f484c935a69bce746852c30d94c24753a85eb07111585021f327395fa15e07549e1825f4d2bc21c22a86c096f5c43bfbd6575c751433ae3e185aba176978bfe67db8dfe331b1b2f51ae8c822cc41c7aaf732e26e639bbf8295fa07a897c351c8e4014838e3bcfcbed4d52bb84bda38dcc3e5eb8a4d329e051a6c92062f6c28c95ee18bf4785f16415ab2c90fae2319b357d1c1238a38e87365a57347a93646219334f28e8b453c4a3e994bb655a4200d862eb8bc30f12c17e923ec216b43843b4eaf0689458a88e9dc2adae17d2a38c39f265e8a228c567cc86cb09f7251c0967a09234e5e2b65cb6f59394f5de9ebe317624e83466f61e4bcd1135b034abf1746a7f97e828df980870b1328a216d5134b59e7fc1425fe3237947690950583e421a2c3eedc54ce034a9a2a8ab5f10fccb899aebf37f1c5d1deb6b1d974d4dded5206311775b569bbcb947a222d2d358c6a8284b2c0e957149416bf7c2551f05146565963febdef3f479805cd340d9d7e83a88bc7b102fd6de749f53f93e8b2e81004b8703c58a10557ab63b3394d3b6613c09e131f5e2e6bd29d5610fda2bf84900bfabc2b01814bad7f8eed6dfaafce503be71efcad2ce7fd4b2e58769a569cb84d76c84a1c7fdc58928a740b950cf35a13244b180d42a18d965e1578d6f9b7d8021749b4f7a368cd2b52d2f2a93598c75d8806446a674d6ab239d5dc1925387acaee09ac7a6a000715f258ab4edd662e17887d15c267a959f9626c055cff42a7ce4a950e5e9bf56ec57193f008e534d206f869a02b6695f631aac675280b86eb431b8a6d4dfc04b3baf30d6067f3d9f5f318add4afa96f334c431ff8eaa776c31eb6e24f67478c02ec68849ec9712b62ded24701ffa6ef3386459a5ee26c6a5cef58ea5020fcb4ecda20c1223813b10025d2d5f40343ac7970ffabd9a568ee908a896f0d2a2b2e261ec88b795e59b1db75094ffbe0a28f702b2ab6efcadf9358d9b544e45af2db2d1d6cbaa4835dedeb76d41dd5197eb41a6171ec14c8c8eff2ec8c5e66ee705f7b6cf325947e88768c53a4614b22d0e00046fdec5c0bcce7619bf6231c89bb1a670f1224e961df0638d97b08cd444c4893f128a62c62f448e7cf16587979d2b68f15021c662d7d8dd250156febf6e4b8c0c5d5489554f52981432e2c2843bac6af7999f270d0052ad89fdb80c45105f930aeb619b6d68767ac2be0360c51bb5d4a57ebdc720e52c2d6b72bc02a7c80c6551144c95da7e660eb316b7f8736571c54c474df49e47e539893ba5e31a746b854948d55be30108a5f877ad50b31b47eeef0260ce9675e5d6bfa18de6b85e111eb7c90907565efeec14d7c356ca60e25c78e53bc9a6afe082d8ab174f4a67e3de5f44972c1ead1ea7a45b88b37b7a9b1620520ba8748d7d8a4f6bd459acd2a5b0b9f04bbab6c8532a7416455d6e5d44e104811402eaa3c4eff69cebc9a4823a4ed49d2be5f11f32210aef63b9d4ac2446b8b66e8b2875773ba46a5efe2e247fcaa9fc6a43093a2b8f28615358c470818d0c593e76efe0071813b4a79e070b2337c3d8fa7f9b12d12f68b2ffc941f674d3db461ade3304179b58f9f0f539c8820c41ca45c3d6b385564c307aa72cde81d1357b13758b6a280d463eeeb0403416268b2bd31da6b8f7e5b6436a44dbde35e1b93a9e433ea1d328d8b946c72aec37f6cdab3dee1050f61e924af1f9cc8eb1fd0c1c412b06678d445572fec4725418546a425564c35931154fb3f581a41e5e6b62cdb09fe14f461587cbd544e93976956e7027db0732d9746d244ccacd103ff5ed45d2629be20d50b99a83b95fc9234905af7150d0700a0465c7cf555608d46ccaf18d9f54e26a885317ec75465a094b02f082e0c857562a28c843eff386958bd03cde7bd6d9b37696b1944f93da9999e6db5b8994a63ce08127ed36a4b2e7fac1a67ba52e44620c3b9baba3003e9197bf19a326995e9416407f3ddb9a9b20022638c9d659965237627528bc621d135b28c6b6ede2b859de64ca9519128506492e992166901055268e5b7bead87d4bd27305a9cc474115aa241b8f2a75684afdddc53c6b0cc760a57764ef44b1b7a6bf86cd019b463f3f4b99d06293539b5d68a27a0d683c5d139c648b012cd6c65a4bae6b369f66e3378f749880b046bd8ca32304a4167cb9f711a1f0b9cb42a27b797194dd6aa64f3a44673f16039d68184c373c4155f95b7d0a71bfe66e8a02c04a18522d339a0d6cdd18ec8a548547d483bb2c749b0156be4562ac4f2eb9a777e49036272782f92bf798793a70274d1081e9cace972ec4c9912181fa0194f3fc6349df7ff19f0e01543f277e5d30c4c64049c65212e7194d1c2e8e57823390c6147b3f63b5fa02ea6e0006d109c6abe650bff7a4d5e71e9da7c820c89dff84837cafe93666b91dd03e0d2d1a3b6f1bf34ed68dd0151d0a069013690cf19a09c5b32f61d68566fabac1aa728bb523cba2654159ed21486a32db3bab3d6ed3a3a037e942aa686fbe04ee1cb512267aa5fddca38ed4ed79c3fb6ae4d0ad7e87f5a82287a0201ea4ad377769fb34f23dd0309629b4ac21681bee5b02f29185f614e97e3946dcc576441fd2f63fc4fd3e811db2e47dce74615b8775fa8e3e3372d287547bddd26a732779e71b92e28e243f2f0825581f3c546b976a6d979c1ee93d98a9f84a604d85bcecb50aa079c5d466f113b3e687199e166ed11abd155990d91dcb6532fd07ec2816f510f5dea9b1d5744c2ae348b61e605f77ee66607139a60f821770a9c793e007725c6032f2657717334bd905234861c4e6a2a01921769ed12c5527a0b3eb69ba2724f6e1040a65471d53ac1d59c58f0290425d768718bc7cd665d37d00eb73c533cb292e47832780295b6cc86a416dce1b02151d513d4b2de8dc719d37011d938e57120725dfe4673b2642d599db432581b24db345df25bccca2bcf7fe852576cb950ab4afaaa34655c65c374df7a64745a5889e40fe6238de24169f995d5ba60366084d347976150dfc797396832b64765b8639c897d9f2da3f1f88382ccb9dd3833a2e6ff219314cf60fea2fbc4e88f95a9a509fa093ae558bf076ada75266b0f9a0f46452676cd1d0d24408254eb0044d9c6a36d76f8d11a6fb351edc7223e8b38451bf579a0c78f49bdac8794ff6f4e84a6eea9cfe8775f4a3f643158cb06139c95d0738f2e370dbc6b21e1bc6ef99cd35ff2ca1ff41a1f2f52ec30637d5a2bcc685e58e90bf8be70c41d4fbd6bee60522956f0ec02ba3b313ca9353c435979586d08712a5b8eb2662f626d2c56c3e891c7af6c158e5e48ab10410481314db2daf44bfd9f1ca1f533bd3e6894e1da4a2a7ade52ebd19b562ec8ac0b8215a6822ec01b0a026c73b72512d996d197af0a9eb07722ca4d9080d3aa256f9dd460a52a6d6faf1d4967def00d5c1c2c788a981068602dab65a151eccba93bd1b7c6ab00c3824e317f6b248102719010d18cef27d03ad2142acb41de70d1f22e5608be8d16217b7e3a290586ab2ac002be3e83549baade4484ed7157ac223e11b48c0f11ed6c63aca5d42db56deb72812d88d5beeabac02fb549c80706fc5216c1bc8b594d3f2e7afdb1996d61980840be9fe417966a479e1c1dcfa7e35f137c8b4f13b5b47a4dfcb5a1caea3bf846e65ff11954c8b6db240025350214fd980622fa305a45e14c84e857084fb1e1f7cd0cc15bf34b427fa40e1588a85463869e111e5acbe0bd1a2960168c53edb4c7e351edd46b1648423ca1e091b16e43cdb84c3419a88bdfd3f2cc02bace5807c629db0576c1ccf82f75146b23a731c21157c5fcd5965ef1b8fbd91ed90dbeba3a13a2a58a9a61917a18237f47d7550cc95cde0524cd8996ac77f0c14b075ea7e1e2384cdfbb205e52214a230a65b18e2afbbd7af174124996075ce21638b99da4b90027a3715f722c6d95df1f4ed995dd00532b7096c66297c7fc756a70d13a3b5705e9a6768c59427252d4b8b0134d016718a6213e75cb0db9456aa46d83a64f084730bb61e23d50256b0f675cb6299edd23a70fc2316c111b8da48eae7b77b57a66c16b9160d8234c32b4e3610a741b51f22387456793fe5aed0372ead944d1857e40669ac3bdfb69887eab66a830f34e7b4918310a0868660bf9d252a0c784330b918655604ebe414630cdf6c3a0d2be30684ec6bf029ba640479f168efe5ce5704f6b19ffb24150f80eba3ce5bb7bbf731b34f2299330167495b76f63d869fdd7d98c5b687e22959fd0ad5f9be35610ea396fca21b91342b15f186a8e0a2c87daa96f637a4a1fbe5008511d3d185405785b6054991360fe8873c8c5db38998b36d626986be16778eb568d4012a6568f7b9c3a2311efbd52cfe521a5fabbfb7c9c86f2c2eee498f2467218799862ff9a3412de105db6f7117996e65082b029f8ca81b1a5117fa8c7c0c5f10694790f684cb1aead121b71cbabdee31ae13c9163ae736bb020c9a73fbe8cc9ee9f31a57caea17ac2a82446178bcff6903aef7edab550d590df2a370993e4c48a57ff80dfd21aca8a5cb08f851fcd95f944b945775b9209f989a3825f639d759383fc81d28e3dc88faca8d27a7f9e0849de3bb43f654fdca779998ae9a56dcb7c039fa9026b8fc49d40ce427f4aff525c1d517e8f5210af75f702d77938ffdd764d82b7daff3eed75f5f0eafd8f1e89ce8e44aa76e6f302324d5d267419930d8170692f6c825fa0f173d6a9dd1f5fd3a1cb9498ae775935002771cd6e157f59bff30321f2a3f9c3cdca67e0237549e27d16d31bf86dc947c574697d327ad9d51c54a6725e2e532a50e029c21718f38f2957c9eaaeb04e6598b475e49ebc5d62df0a9e8c67695951fce089c064f5448f4ab6ec8d77423e571bd75e96ebd6312bf594d70c5df39fbf11f3e371733ff0bef0acb4bf67b67dfddc63c04b7b2ac9e137bf0d74f2b8b98499ff0a56cb4b434ac0f4fd16894abd8a67d12f1da717a583f0c0f3c6845ce7fdb9a7754854f0a5dd35b57af6703559c2d30d3154d62c03de8e9ffc4023b88026dca95bcbe9ac0d75c03add313a82302be52d92c543e2587bd4e7d17c8e6393c1996d8c36ad9e42ffaef1ef363d8ec194123432411058d917da97e13456947f2321799429e1e41a2703e18cd36cb1cb0aba9cfce7595c64cd1560b712ab2b8ff539bef23befba3dc3a5de51ad7c00a7e20bfcf0f419408e1bf34899e18858aac16c5ddf8ff9c23dafad16b0579afee7e1ad036062592988f0a3023a40a28113df5358d56a1b317c392d8964bb3ed4b159263a040e25d5d361af7f8bdf0753e966d3adf4f8b1d89cb19d18b9020a340b743a0d90571a1a65f88207044e1c796f00c7301a1ad6092e22860ebad5fa2cdc128882571734e9d86d9fac5c4b4c8e1a0e062043ca062989e3b797123498148424b664eb69eb8c1a0c907ca58bc704ea05db1df99bf590147c0bed97f979ce058d75a14a23889bf7968f2537bdc424a8c76351ae8c8adc0e520ac5c675d1850403d2ac2e6d2df93372523c34151a7092814101d37dd9e55494040ca060e745adc992dbf9e13d0d177521a389dc1a47693cd5f0585758c8336c2daa6f90bd059cd00625497f7a2e5701f03348439437355fd0e4deeb22a04097876913322a06746f33d33e7621811e14cead22e982fac718d15566b9097467a80aeb2002fb00a2e15314e8ab8a8caf50793e0b9291f56cbe05a40695ffcc6ce1a09959b674599fa5799bc6e4d47e53d4342ec02e02df075114045d11bc2cc957714a6695108838f5ed99ff0e54b323388f0af704118693769c6f62a1fae3e3e518fd0d9af4082ac4af192ee2488674b731b270de6af37bd8a42264c336ba37f63fba2bb82d43ed6e97861b71be732fa764cdcdd97d13ec860ecc76d87d113dd76bcc32b8b9f20fa7d57300971cb3e68835623213f7f1b4c0c19c5c78792c5604bdac5136f13958d16dc6b6ba49e539df99a8e425f59f0c5defc9aa023c09ac76335def415d4ac75e6686bf88d0a635348ed3dbb4489369818f3ed97581d92b3b68aeca4c0923bfe1595a494fd27aadaa9ffc3323f6e4d58c838d0b190a94aeb58a025b852c06428020c89a1004639670bfcd9db2e0b7f74f6e6c07a8fc577e7c50ef09580eb5344b122bce6a55498d956f004118ccfda46eabf097bf77fcad29d7779fbb2334a95383a60f4865608c891e4c9af8ed623d168bdae5818a14b8811db7460d731d7df0868124d8ca9aa6a74e515a39ac2f960973b5707b376cdf6d26fdd17479c799a71dd850051b38c9297be6d036ef23367ee0912a0e769b747b43cc3bec0c491b60b3a01e440fc5a3136971555f0d2ecf81189762e5b803e6a31185ce768a9b1d041792bf9f5aef09050936d1907f2710f6bb024adb5d487d29ff7d37fff4e5bccd85654dfe94a4ce2d77941307a13f1c8e804aefa6329bf7ac0cf77aa4a6b4e254297947704b7ab5ea6fd2fb3304b0444e34a077c87decbf829cf9e89896352602ad483fde096eb5eb966df1c3d49539eabb0dedaef047334447644a61abe62b7e2e4e1f8df0bbe341efe28aaac695297b40691c86cbe5305a40a9cee7149f8fffe810f74d2e3616f973397406ccd119106bbf2c43a0275f048c8e915a1609439448c0c4f42bca4a2afbe38c5853161acdea4e3217d88e77207879b971ed5f8088b272d821e0b7877e8ac3e44a3aa1154cf3328f8fb2bd0e683afe94e904377259e4f7e14e6db424e528fe4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
