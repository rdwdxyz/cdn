<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb9dfc5f1186ad5b1ae4cf2df23947a4ca7027067da09a649a13086d97dfbb4d91145dbac91921717e94286125f02443e5e276e0d4b3a3555818090706664094270261775712ac9b966e46102b67729fb3f0b656750a34285cf60b4c6d193616ab9a9af4705e5c6d8a7efd8c909b5280440f6c20c209f4749d76eca535baee9ae4c23f3160acaeb34011c25c639af02ed6d43df36a8be2cfe54b5d27815f347d1c13f620ecb384ae7192d0cd2d8fc8c3bb749f7af5f51ee211ee7dead604f2b36db5bedf5699185e54a454105e5676d134b8ad8aa90c92e4b643aabf218e95582fc660065774bd3a594eed6c6d545c4b6db5933be5d4211d5328ecc244e388c377ca53b93c1f667bc9290af5b316268ca090cc116bbbb87dded93c23e0eba783785f05568f6c0c5f01cc1d07a82bbbf369e8c6b8a38b821faee4b4b1bd2e0b0678f6e3144941bdcc29b1d0c4ae20c5718c1b928ddd1d2cf5a213484528ceed299a4e70eb6b38942343cab6ae49a03bc60516b4c02610d2b04ac1922ac7eb1f9e6e06335494ce393bb7927fa80be9fa96ef2f4fc64c1df395300ddf46584f0de94ed64b9a120f20af888bbd10e3ea633153359a300cd5fb202cc594cdfa8ab2e08f65aff6a2e8e740fffc82347d6f34f9a2ae092b1b312dd18873504ebb107acf6a86e16bd2bafbd617dff0e8ace7627c4c1b3bfd38035a24315f06c1dae80f6b383ee662cb93a3948b5bd77802a14a972ddadc1e46d4bb081b05a870622050db2102e5728c79f0e5b04bd62f3ab0cf65ed2397fea57c772c69a3f7a502f4e966ad5f6221338f7c37674fae12cbd418530fbd3ef1de1030439f7102b4d1012c18298c02cb66452ec677479baec4213fb0e276d0534d692833c7bcff0a148cdd862854f5e7b6a48ee3b764858d028dd6d3f89a364637ff71b39e76253ede21d979445b0f7572ddef8a8c434ebcd8d78d4b7d79bc0b524dd48bcda4d3ff76286387e4f89d07cb5c4a2a60a541f3e28ef7926c7ba1f9ef89653535c46325ca030a9e266f9429b3b543c66f48dea02bb981eee0bf94b95cbb0cde8b7e55f687fb8b1edbd8984733ea1bb5a949908b682d85b8a8f37c5253488bd55993fc6e9b419dd54c92d53792741f344b8ed1b4bb670eac6aa4ee0b7a3d02a83ccfe91693aeb5ffc6dc36f66d56a9d037b65b3b9b92c07e4b638d47ee2b847e4fa5b7500ae4db5ecb5d1c282f956bbe5b1950ef2155119397b91f8a75226cf4ae9c45ed62d9f8f95e1f9ab753b63e3d7aed58b939dd459390a3073bc96840da0998b1ff11b871fa145c056ba9199742352db84871d88a01097571c12a170a01c224c405044aa81c6241a2dfae92181717945c3aba3128d68008792d13a8d32bed85f5b6ea19156c83a0580a5ff4781616edce92fd94a52df82270a87a61065b74f2ad795559e8d375adb66273f3a6b3b856f04296740eca6d10848fe552deccabf3906fbdd9f49d776496d31ac3df33a937ab8efbe66bd13048e46dd1389dd1570718031517bf3dfb69b4b48e8a15838601d6b8d2823daaa0d8192e35c2491096e9985b0c2a701468899c4c45cd35bb08c57109a8a4e59812b1e486d6c98103ba318068386eba1a04341546e67b0b1492874f9f536dabad519a7760d2ac10f137d1e15b44a80d8e06f5a973f3c7b0f847c6415a80bd9e98f39aa2306eb4c2b3573afa01da71307f408661de8cd362935c876bc4798abbb6d3b0e720be488400f8f5486901ba7db1d5af8119d1aa747a33f28bec3a19f0c3bacc21bc5fe6ab03970d4745452c1c5becd84199ba0ca0c3ce4b2c7806835e1bd83bc5c5d704032555fa270d037f2d0367bb7a14c5923074e6f12d041bdc4bc92d51933ad66145f9d33a4683aaa5cc29d4297bcf7c5159a5d4490892edf93469439a263b1280faeb2c37c11d25afad2648faea2d1fb776e6d9182f67a133c3ec5b443a0d52803b3527ebec195cf275e49267bcdf364d8383c64b28fb11959ac9384d884478777f4753ee0e9db6510934341bb1c8d380a255392882560867a86c2f3f987699d3ba4e9314b65fafddaae676ad5c7bd892c6e9bca8ccec734550bca2d1be665f15c36b5f482a0edf356cde77fbc16a369b6773704e8675d01895b590b00877e14613f36f66f43fe64ee23f4183340228230b8577278e399952a97263c6bdde3ba899df7397adb8cabbec0a806db367ff7d9a2d3afbf4a403ed87380c03a6bea020e9adef0ea41c4d056949789f43e4286b21d8232d53b7edff260c2becabd3c1d8ec9d04baefda81de3fa80ec12bd5d703533bf7c89394563cc25a63d00df1313bf5525a4284491ee31439fdac8c9ce5814d3f85996c077d146d797b39711fd47164431949eac22b3d3567031e73115077a4ecd09a7d3e83451d17ca44de19e9e07c843be87948ab110cb1cb7ba9f6de106f938b22f35dd8dc14d2959d3b44e2c566e899135cad18d90341df4fa3c2d9d31aecefdc35cdcf869a22acfe0a07e36aec755cefefb13e94de2a9bb155bbf3c8edc74adc1229b0edbfd072d63d677350251fe967591805cbc6506f496c5053de0bc13ab0bc59f7f597317381d5656dc68213c2f7aabdbfe0f14458ec3d37c56f22b9e3ace98c71361ed372857865496130ac375d48fa3f8dd089edd9d9f4f3c078de4600db4c1143566d6e5742f819f1f7cba67890db0ecfb4f2a0eee624812f2d4a5fdcfad8520779204a1a25b3d7e7a38ae4c1147c9b105a30851bd1e5b7b96982e1b62d7c20436505fed34b50162e9004e54494d229cd2bcf9b582e176893bf033ab529a1e26c89d033895c66de4634dcd82ae1532b0095829456136de061bb25beceb090906b4c17ca81bcbff678e6de6811afa978f0cdd406754fa7acf4b3d87b30eb4449f21313606986dbe4dde75c68723a01f68597364cb051d5ceaab5c44a482776b1fb32441dd72782de0d274d017a42ac13e453a96acb2b5440c00eb07716e6cc4aba8f915ab675ffc25046f415171d6c5099283e92803943d75f0dfc5937b8538c2cfac36a1c0a56f06e15629fafb2a507081ef368d6bfe3cbd69540e062d1998b806fa56ded43efee2e531f03782b82ab57b612498d4d2346ea8fd01445fdff3c668c1ce1e4b40156b11d2095043a2b1ad5675b2f1a327c3aa3ab4b86c958faca4d9a0a8e6ac50ee8bb555cd5d1b6c057e4e74a448d130a41fd49368ad5e15e63cd05ed471c05d15423e88434e86f09d921ed7e937f2297863e15c476400d716c806da3ed0d4bbe7b14bf4d4c5044b293e36af18ffbbdcd555382f047f8993d915eb4302e1407c371aca5e6dcdfb31cacb65bd08f9e4d864e0a20fd82f32c484b75c2f84fae65e13af5485d9976c90dc6426ef4894954dbc4485d23f2f03fea20aae62b296e53775af28cb2dc1466e340d0272420c987c3d423090e8875b167c5db47e1e4802fb869ac5a8ce4f6e13c9e18ee7571130618cae929a965e0bad868b2e5d73b48655203db0ed7a390ab518ba72c9e5d234acfe83047ebb33e75a80c54b079689fd34206bf3fea6bdddc563e4abdd6ff02c0de82da48129d426128ad506e84a3df7581bcaee3a4f64f2987845148f3eab5625221677e365e2cec0e1de1144ee31bbce025cb9c72403df7a2b2e7a1e89b95cdbd05952e22bcb804a0c7fc3520655d4a29dc4ef9cfcbbb8b0f4eedeca2575493fb42e6cece6c1424e5a832bdd8a06b24d385dd44a4abb9bfb88708a30e02d8c5b2211adfd788406b42722202f49c13ccc792ebc6550b305ead695e61ad76e6cc03b944b11a453b8beaf44e5675840abd129d484963b6cc9db15d33f8546995bacd5293ce90fb3a263e0c8b8196c9c5ebaa6b47dddfb9a1e1511eb937c9433f6d22827c1215f271b9b7adc4b47eead8edcb7a2fe2b59174eca9a97a236a5b38768cdef29dd1c763376f2313ac27fd8fcf2692b640d6badb7fc43ea1306f5e5e398240cb48e7c6d33e78e9f197c39e9718822fe048f2cb74b9185ee37343e2783d484d40c373ea31db70a34ed7626c797b0e44dbabb5d0a8b35d751ef90262a4f2aa4240afa24726d48b15ecd2a819e72c6a41ab2d7833db6ec01b2a0c41dd1822254b1efab2b30b38cdc84185e6695302ef76b27db56c8df72b84524b4dae1a44eee998d751db51e8043db11c73ccc1ad80bce382b3604f5e0514f0824d76456927a055dfa52623b5a0ac2af97ec9395b46bb972ddad41f92c6244db52025e512b7defae0bdb2cdf619a070461040ff1c2f562c5e6b5bd926138071258e58c4451bdfcf8ed6442f6b51039a41b973be96908d305ccb8cb1b517eddc9c544699672315f0a9e5e2472ba8207966f2dedd1ecbf8f21c4a2aa416909657bc35310b04e5f655f90e777d30baf0df2de58b547a1134924cb9adb5c65072dfe3790babdddbdf757d0ebde9722ac1b024894527e8397bff3ba38c3dedd29dbfade45b400093d1cf62694790aa6c51602ee3c9de6e0749213762cc3a265ce08693cb7cb26762b650be0d823896c2d0880a20cf0d3d69b80c1bba2323231228c167cd57e5fde19a5e55447489590a8a664b59848619b0744f320c25d830805f5dafd3c8ab709a62993c34ef250002cb24d4799ae3b2c5f453081459b8dd4f658866ba4bb4d354222f550e0b290d5f33d6381bfe36164472a03769b74d6f922ce82527ee41dd76a3cfa7a43294c0b6196546945adda5830600a4d9b5e44003c2b55449642d3fe8b7a3dd07b6c12530551c99557691b1d4092f85bafdb43ad05755c444b1a67bfa3a37a418c09e5737fa4bf4ab3f4bb9ec32d886025ce671d4b061d2961d47ea3efdc043ed2af1749c13e8e741ab86956cea1cd0bb29e810b27b772a7c1f5361c7c78c770b916fbdf04b5dcd454421b7faec1e63231f8bd5cc1282381cd2067163fb141ec63c827e4ba50e12324fa29bfd63f0793f261e91431b248825b7130a84224e58e16c2d744028664abcc108ec595321066c6a8ce1d6608413dcc76644de7ec8ca7629289292b36722713db5fd60a55b67480d8dd35e451ddd0f48daf28399346063e8fed030c68f7fa1a9a71da99e922a7b2bfecedadef5d120e66cf349a4c427ff9b64a6dcfa0da55a26654d460062e77a668c2ca9486425d5a3d7ad2428218d1f2289ff5c99056752eeb24d5c778ffcd15efd02ac0aeeb34a0296857903128acb72cbb612a700b4d0a856d0e563154acbcc9c89c652bbee97c88a1a84efdd646e29b34e01b17d9f4fefe06d489a1e9976fa5ca86fe57ad36a06e0d3574b4f184820cbe8adda22b230e23c1526031554bd7773245b1c9b7ac819f47bd57851d16fe856122bdfd5da9367f3ae2d89def9f452e720cc8b46f276a1a32a1779e95623b68d43ed63c3217bc5c56c998af0b002b85615b41eb28b335f99cd29f7644235c199258f062667c5f65543fc8279d1e5a8d0b2363c8412063c799e3d537b2893e89d4c87cbc68fc31cd742bf7fe25a8248636a829f990feb8469ba169d8e3c7e4f467e678bf8a21ecc666db54723e9531b2febd7e2492679e238e90fca56d825af869716c4532f4a6e8b547d9dddbdea22ca6ae7fd177e553928c4f3c5207d5b829dd461938dec47e3ca4577d99b4b18d8a2db5919394c1243ec408070a80b2cbde0ad01c65438ca34123a1671bd64b6abd5fcb278fce307b77dbdaeded87288c5d2e4fb4f3d1b918e84a95f62bb83a1f1c099c2cbf380a9218b4d1cdfff70e30fbbe3a9eb8b3fce9441e8ce6550968c2ca77c467e87a894a80c10b390517c17f7a53a25788da999c7ef23e7ac9ddccce96b8bfb5aeeaf8090c180186f7ca36d125176a14e6a43dfa85a394e591eb5bb728ff7a017c3e281705a6cc49e7daae4713926a5bfc86e26fb2d3ca233bad310df1a4975237bfd8151dc068d536b36b580ae0db13aa28c271b66e23ac45dedb0bd28c7a2c52fdba27215711acd102cf860a0a08a50455916f02eabb5ea8ec075560e91d5b1370a62a3054f6499aa8b7d34febb3eae0397f6f3b339c8f0c2ec99fc37638a9bc8eb83896101e88e03b8e917308bac2e9968185c023034b85b1032bc4be0c2f7c8f11c1a96cfc24d4fa1adcd1eaf9eaf03e057fd9c3e78458d25f27588d2fecc8b856ee1832bdcaa53c654333649e19090175fa33e47a38e86df6f892bfcedd85bf552fb210c10e99704077741ccb7159840fc2a00273501e137dc41e70647608f6837d61f52dca901c20f3f3137e5702a93a21eefc2676ff778be5c5dc2e5d5448faf6b3aa13809aca67e456027588bdf1d1f907c91ee09b4d1cadc3112591528cb5f916cd95e2ff9165fccf97522dddb257e967b807576101320c34e2839090a3baaa255eb4ebcd3bddc365fa51f816396a772d32113f3c9b5e41df6359c4eef18969555649782bb159c608a035802d6b404349ca46ab58bcbd7cc71438cb847ad734c1cdace6c741cd4419c99ab6a2c6eb2fd79aee90bc9d62c8e34d9896707c64f9a59c0e614f60c223033fa46ef06f53760e60f450aed271bce231a7dd49d9dddd40ffb411bbe12351d41944afde1022f83e185848cfc34b345019f4dae04665a1c795b9b9f09454a9c31cf94ccf95bc08a708343cab6cbd25c147567fded6730388a258048ccf6e83000f82cda836886d508b9306db8155f98765bc2888f5a54b7158e6e7843e49adecef94c58c1c19dfdc4da593fd66832aa6fb2fde3058c201b850807d654997642efcee57300459124e41fb32f822978434ef355263c5b821ecf44ce706e787aab88371d775c8e1dee91bc141df582ddd921269c91376d3a1720f5305c56f5a9f92c717a710bf564558741f7726609f0ff88a099cbc8cdf43e53f13232f01685ae1a1ad8cb0c08b51a32c55afd844df0ac37897994ac861f7c3d03b3857cf7de42ff9365fd7354f01ee3275cccd749fe8ab73b64d379c89fc1a27ec0bf8ac8023b8231404458159df9784a43d896a4bbf7c2ce45e6dee64140a4984c610b5e87683cb9b411e40fee9869cf352f27fafceff8940d57891a0901eb79079f236730d4319a9e1e8ecbab998af388098cd4769335e7d7582143d1c6483dce7caf28e7943e27c65888d9d9d7b606bf2faab4b77f45762fe807afca8d6abafbf32701064275e3a77cb3cdf7acab7969dcf9fd76b5b7bcb83aa48a28351e8b10efaebafa85accb0ab100507824f230ff2ec0231867b4b269413bf6ce19c12885ebb797e4400a0f329edb2a1662c2109212247a623226e427afbd633fee39ac5918f3755d4b29aacf202f3d61167cf943506ac4560c207b16a982229df0f12d4df865fc4c20a4bef303433572be5e69f78aef4af3667e5349c642594fe67a34a47dd76a0be2cb5b8eda82701cbd49382efd41db896ee972388e4cb08e7b10364f139b3d6ea45a5021f542ea2d0f1b03088cbb26d974a28bcf3c2bd5a4ad95d3a74af7c90ba157f3a643d67d573ba69a5d44ecc583147cced93e81c3bc9ffb86cf45f8dce2c7b34602929b6f160ef5406b3aa00b7a106da26621ae2c49b4011f4a0a36ac4f0de595ed05599b3c7d0822f2da68dea8b5d603c4e900a3894fa4b9c5eb3eca917d7f9bb42401093b262926ee2bccf3ae3a3b6702f2f46da2f2e613a286de4cf2eebde65cb08f2cd94083e2300dba521519d9392a3980f94ca2729110a9cc06a08dee3f9107bc5dabebb0e52fc5120f5dc43c18f91ff7b02735f93b06e3164c1ca2605b1be3acf77b992cf5bad83f72a2ffed0ab9a543d0e2962cae9ea0df0280702cfa5a6746b5f022092519aa2c8cc569275a1ae42c282b1ea74f6fc005b48809ef84f3ed6591ab560dd7c4814b477fd59a07ddb7f7a62eb578c4d7f83c65b4a1cbd98fdd23c25b40036840faf2c78b871e054b688baf152a6f9376c68202a1768b0ceca52e587b13543697c6f24f1ec144521910e60991385aa9d1944c70d0c98a457bd93be92a0ec44adcc74ca5689803fd694640b719f1a1ec46918d6b0de6fb4e1b4a75bbce957246dff8918b0acae7a780540159271303bed75d7797a857e5c7fcf35ca88b45c1fa1fac20dca0ad209de45b39d73b2dccd118d002296ade206f4835cc39be39c7a864e1c1eeffb83caa68ee83220a0d86c90ac2a432f592252861e7ca2d0523367ae3c1c76c072eeb533f726d90a36800a57843bb473cd697d9b5c987602d4b36b8d07b83fd269132603f3750b27082866af5557dda5e5585687b0aabfa586988a307340b0c7f6f08371c2b5321720db4b770d0cd34defa54d92f29136f84c52b1fe07c4ca5ac3b0ec41188f3fda6d3b7b7a65206fa0f3dfee0600c2c0e22821b5b3196066313628bea83753b69e3909bf942221d330da17af8fc955ae028685d7f05d4ca515a7270d17d191f995d2144f217a022b74098c99d65ccf6c58af123bbda4384fd5e1cb29a0bb53557bcdffb1e82bf4ebd80a6c462d6ff6f3a61b93a2206017cf5cd8d6ca261d41b56e632dcd9937f2a6f55a3afb99585a7fa0238d62f41906393229fe53d5123a4b586df740699508095fdf303136777c006d97130082eb41724fbfa9b80ef103e0531b158089a5e22ca58b297a7dd9b7a3a0d7e17d3a3b73ce9059798cdc51397cf912398bf55cbc242a2c7436161b6018c6faedc29eec0515f03ab2c8872f987e069e33cb6728cd155f74faee96cf955402f243758b5c1d8591f9895f59693ab638a4ca7708ae348e94d2bfd18520666907535c3814777ce80da8ddf3cd8daa5410d545dcdfcd53d2794fba8683c54476da140c900e3023d3cf4beac8ff6fee4e41c8dcd9ae9cf2fbe44e5bb4732dc0d00af3f72721bf543c9ffa350330ec5a07c073253cab0ff9cfb10dd55bcabd663ecab5a8b8e9a54f44494d0e59e730e3810e05be527587c90f62c2dfe7911169462c0c3cc4c03d6b07e240254fe60f46f979d0711a933e407c63b062f9601cfaad55da85ecfb6c75e91fd7a818707349f0c54639d2e88ece9258a4844bd8d9ed6fcc71b1d8a1ec9df500231d07439f1106d53399eaa4dab5c5145d6ed28596030e61f66e55bba10056003ef813420d88ca27b2d750640899e127c8ac8eacafc19062e8e1808d5f5e8337616b32120e7b393ee1400445f4d501659f52e62e5e0b1da285528b9e7f7fb6f36283dfcfde1b59a1b72f566ff8c799b6f53c4dfbcf718a39e7ff7bb8d76a5b221795f4b290a54aba93de1a78bd922e1228bec61c1bb6b06c5cc65f0f394b7b4aae749db96b5aefcbd03154f88813ec865345ae1b13e3142109ce582f34ffda3d5bcbee68d50634e48303adfa7da1f21142db99c8c4b472c14b4abddae68a0bf1527f5e3bd089003d6581ef030198d9cd368fb5c263cc894bfd1aec5a540a3f85dd2f370cd57c8cc5278e26736f3440f202ccb00e69ec293da8830c211031dff937c94e3d0ca02fc6cacf957e1d86aebe40a77576cbda9577db73f0650411c0e6332e66ec72f13c49bad39627a6739f06827c7465afcfda4832db5a9714c66f1ee0a1596c097d5b723b6565e25b3f608a14c9d48014ffce883df9490ac7bcd9466e88dc2305895a99cd13b6996f3f8de34dea5aab46ab08de18c26c83fe2b80e2d331fc61576b387aabb7b7ef0f5655322575415843e0426c2bc70d34e366fa135d1cd4222ab7fc3c43833160a7ebe61f4ef1fd5a87e61bd20677d988857296b9c48f1e96ecb07084bee9e3e2d701ac4eac74ae27608533dcc2c177e410576330e101af375ee88c07e4f2e3ae921f8809f225e14cd11048257b4ab81970b62de92ccb03e4217461e3e446a72953be7fc8e22bc98737b9715875bafee1b6b1265cfdc02891196af5b87ddfc0220313c07f71bb97ada5e6f4ef10c395e13d29dc624fb99dcf1766d18e559f450bad28c7f6022871f4803d577fe675234184f7729036fde1d360845f5549ed3e43fc114c707bf2534286e6674d6b4b1b37186c35fb73bffc8fdb66a123aede3fbaf439d56dd9cd7688e344e576c267cfe20b1173c6f867ab9c98efccaa07962580745c7a68b1a74c3cd85b841327aacf3ed014fdeff3a04bf6311ccb4550d209e936a1f1bd216178dfdb4e3a18580261986db3410de98258e79b6c00de61ec8cd2f633b9791f231c5e1193458dec4feb9205ed760a34c23ea7c410c6fef6429363ea4416627d0d3dbb095c67e3943413b50ebcc6e5ddd67fff87d5979fec5fc1d74b1bd89d350c5fb6b06013bf8a13fd65f871d9ea44d05e1abcdb9da32d84c2f9d8c9b3c84046d391ff11946d32a637be62ab921f3264afa81bb3b5fbc9acc635e2966a3411d5fa80295809a0e9050559a504001e4a4b32d536c4340063628ebd2063125245c74014164373009cb69a66c432e7e97ddb43b9620eb448da789c53edf92bad28f84920fc569d5484b087b19d9d1340446ceeea7b558830b0b2f1a0b0c904bd9e3f2d06f39da6b99a96c5a5ecc0aeb2d80be1182e3184e900acb8ca9cb2dc8f2f12c6f3e432fd2c112efe6012905f7848b3cafacbacc1bd27bc35c6d692138d03fdcfd0c9a7c1aab11b5d75c321730e53cb883be8d8f8c42be68b7069574cd85a3d4414527f06fa48e9a32bfc1715b337bf5fdafd9a88ab9064dd03430c32d458d8bcac3675a992b9eeafa8e4cf81a51caabbef6bbd699ef5aa0de248fdc050a8bfcfb261922d1de288c4ead994c7411b3263b69fd461c33714edf5c10f3ead045706481b14818241573cb100d7a0ee970e335708b604a63f6e03b7aff7c23e0099859f4c011d95a581a3e2b6892d2233c44805146b4ae04c99e5971d18f386d6542884eaca8007162e9b1b375ce94e9862cc6fca2c19f43c477f0c0e6598d7afa601507e8eb58091a2a12a2302a29728781f9824ca6b6b802ec35cfef54c27f2743c1a60dca981c64e41eb943c83d2e171193e5eb224bacd54ae76766c1c114627f98db7bff72fa0656e6f1dfc0a1333c6d9bb2d20855f7446f400b320e66980d7a86135799b3064215c133095a53cc5db6908afc53a95fee2966715a2a5a1735ac62f991c8cd9fb862693e676e57b806bf76eb504285e256d47f20d5aa28a305c98c45b5cac323428f17e3d18b08dc469cffd2a29841f8edfa630002d019f5b81e3d422e0872238da27867ec308ad097d72f13e3d85cf0d873ef7daf08add276ead6d7f78250f51fee2700edd7a02e3ec28dc14ccbf8e8881040cfc10f663a9b51c28b2460eedd987f16876d252e7a8e170e3ce196e1d3210aa6e9095862d03cf5306714e22e7849cca63046ae4433af441a7a6050e8c8432b94acc74cf6f27867db45d6d160ee4979446c392150a59626eefeffde3a5aad4b02ac49f6cb605fe623bf19824f0bb3469ac25c07a7d4f19c20dd683c7ee1401e4b66804250434ab6681f148dfbeee61f677ec0fd4af63ccbefe0e78733f82bd0c59092032210d7135ddcc7f19acf59211db736600f08319c92456d00275accc0fcc0dd16b2068629cc88aad4231c88f9166acb3e7400bce723bb964769dffc13b94204567c0a4417ce08afb86c0070f9d0f12fbf01c80b21389a872deffdd890b2b7872eb26070e25f9aa5742570fdd29a309a5a76fb712e4b90d5063160f44ed55e16a02b3fd768e3ba3dda6137025777d849f159c70edcb02a0c4dd967d921cbb51c5f9fd8be2d5fde0ae9af8771cb87d2940d064dbc2520e8c3c0c2e1b0eba6982fa9d48638565b4726a9434a87d7b9dbcc877090a9a1363f6b8353c333dae88c7294325b6a58d2ce392f408123084e643b7be1190a5043f509cef127bdf1f248be0ef1ac6da0c272a5040917404be0fe05cf720aea57601fb0e8836cea8abf1bb9b7b56c551746ea8c3fa396e6c5c7be918fde17b6f360eeae492ebcb97a5a4a06bccfef15bc09b20ef5d1e3fa66090c1b240d687150272c29c881f06f907f263c99dadb297e9c88c4558d481bb2195b28be70fac1cc71f3fefabdcd7eb246d9f4d118311b9bfb929923cc5c7237d43ac9458b2678cc17c7b6eefbe013463e445b3bf5b0d4a4fa8f428690eb778bb8d3f65c01166d454964d1c1a38ef50490959eda7c19de474dac7f433f566184b1b8de782c0f5d0dfc835f9596fa9c35167ba532622d6839dcbd1317d4341582449d14261955e35bbcd35accb9a97c003501be02891b3db0d2682bb28d7050212479899b097758850e096a8b7472e5756e62dc8fb1ba1a80cf910e5f8e74aba2286630827a544935cfba8e0c61c38298fbf5c629dbdd9a6e47ee5e9d156c60ba3c86d00748255990c4bd564444ba2d7772e1bc04c019495593d484d555b905f190a4b69c9301a01b8397e7309d8002bba247a175e032bf9d0ff161856c5b133a540bb750db1b3ef8c433a38ba024733dc37c9cc65ebef59ef891ae4eef7a81d0ba824ccfbf9dd844495b419f26b43112e8a4a2ee6366b63ca5da956960c2e6c7ab42ba667f3383723bf3fd4dfc6b7e6a86045f4ab36507fbcc86b691880dfc4527899c5be1bf46cef11745387681a5faccf62aed59955a07d66f256e435873b20e40383e5efcd1a449bc10e1e1b7b1d25b1e4988b60dffc50daf632ee6640cf9a496eee603a8965911047da5fa40c7d105ce86d141abe7a29244ab8b68ce68329309185f89fd2a2068190150e6e375fe2692eb5da7a7d44288feb84c0fdb5118f38101a59c34b72c8a8be35ac598a2b0ea0cdcfdc709cec984b1674db08912163aecc61ca8342bf017e566d7e697b2834be4e47830e7c427e691ceb8b9fc51404dc7e4b4e8591183c654cfb2e72cf6d5ec3b5ef647d50cfacbe82e15013e4266260ba44395edf05b88ae319578688d611f7d69b1602ecc9ef89d7c2a5e421693d2304ad82a2440bc2f19ede9e6ab8b9b35c3824a64246fafdcfc240a59b7e68626f2d9d8ac11ea82f975467c8a34d9839ec6e296fa56beec04b90c69fc743c3861dfc621f607ef6bbfab9296e231b4c1298a4cc37186fe2ead70ea4441cc6892c546f9229cdbaa19a4990ab3facd7ad314a409e0158ccfea608f0f2dc67bdd5f1f5956abf920aae6f6114ec5d3c9d21c16608ed0061e20181dc2b5d076d1a4e72e53ff38b719bba71b3989af93b74fcaac80580d70027f1a754e63826e91eca05793728b9de4e61f8b7a45703ec386383bb9a539782bdfa90abe485c5d4b8cdb7041b867285ddc62ca12ffe9f824cb84c62222364ccf4f22887206d97dd4aad0ce76013293211f2145795e10c90063883b21f5f75a4ad562fe18a4f47638f3c29ea66a85db7230f7479b7cf316103a1c6710d2085c05b7d24e4f5452b9dc9ecb6cf27af99c5b3448544a942afde7853fa495170b5ca2a705f8ce20bd39aba78de01b9b9888274047a23fbf6502bba101cd5df71eadc672cb8fff3670de480bf034cdf0853c27f86485c203cdf0241b094389d993352805c560073c311e67c29269a3716941a9205cd26b9fdd4dca2202a99c54bf1065d9ee37f4d8f65a42dc2fc31ab88cd8094139a323bca101718c8a0e7639dfc2d7d80432b511b73134299f5aefbe87d106661add558018a720f93bd65306b2493ca6f9b697d0ee3fef697e3fcd3296e7daf5d3cceb83606ff53ce7b8209f39e8b96b1eb8b0b46bb5666c6feef1ea2b50bade32a5c77bcc3a460163d342a5855317388109456ed8dc3eb445c5fc8a2169223d3610767c58935f6e1b4601a650a816ce93d8563e5ed7b969d100a84a2f47c4aaead0456b2635ce2464c9cec1ba8aedecfaeb53162173f0023773cbe40a49fccc676a3c6f696b45c435a114da629aac13a18a46dfeccc078d79487f615ced5f39793cc3a5d6b7fbed70f1908baa3733d55d43f1ced5bd0d7af236b551c6b061a3a8e02bd94fee5f0be23a6dc9e3aa7c540527dd59b3d6e5cd4d35a01e610f603e166b867a3951454c3f1ce94bb3fd058b7ac9b3cc19bc4cea20b738af872b91f85ae04039e1710341269831bdee7127d2eed8779722cdf835162b00877f0b3ae4bcba91261af42e64ba02f9d2cd282b4885630f396ef06ad4bbc786c3dbbb83fd89a657c4562b7dcb5577ed680dddba7a84b74a17a5afa9be80402ccbbcce5c9376ee69826cb0cc14794078898fc5b0c269c543c7c11be5a6ddc510e7f1f7780d26854bc805b8184dbd97d62c0bff1e0d8d3f113d5bce9ad4bbbdd091fde66dcf656e0eca54635d37ebac4240d3da512b52afd38569cdb4ca816fc1bca7864d5f3a95fd003d65b8d380fc5cc32943c275f1bb9979b8a3d8e23dc71ead960db8c10052b5a052b882c057eab1d19606ab4849696ac96517bee0fa71c6a8e635d5ffb18bf58e2b68313f038a39f1b9f3eac95f806a3fda02355fdaba95bb8bdb182fb1367ab2a4ad74d0ce4b0db46885015d6be3d4dbf311a17e3d433db34204c14fa95bd2594f56ecec1af86cd79a8057433ea379e84e5e363a522cb9ea12d8547164fbe4b36994877dde513caf1325f58fd82d40b761a27a48a4cc1e846859194f67195f2add432c1cb9f1c760b2770536efbf3d7a9235bc0362e36ebc4337436f78fe206039e9d795b686a5111db1137c2140becd20c9317c248b636e5043718791b201f008008aaf0b4ee523db77cc2154303f07ffc1e73fa81f03cd2ba906a61b2f56d6709f55b4578e91c052edd14bd9cbd4d1ea05daede25627f8763e75e945609973455b16bcc45bbdaef9d1041e27ab77ade2f62239ab4146ba681ba8ccfcee2f9685ba85d2dc1ee5311ceb10a9175209f3a4720c2b3f89a13bc82e5b40a3a096ed4cf2fd51103c955c086b326d408c5999e8eb00a16215859194ae8ec8b4b5acebeea6c2e5d11f0fb411c9b1b38105312d7466e31bcdd0797e370dd9a989ed0a058bbc2d911d926fa542f4f384dfe7b309b8aec6de89c1a4a04d5a4223c12e39c61833c98d8b21120c686e2981671b50feb6a9cc65cd751891c504abe76803c94a392a0c72369dfdfe186d33cb45d80910450f3845441d882275120e24095435837f3b714372757dc59af424bdd9c6164d880547a21cd7886d3ff068a21fb3a25439adb50224539a9bd777d843df13433a7078d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
