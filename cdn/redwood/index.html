<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa3a4129fb2a052accabcc26e3f3391341c75759cc00f1b966580011513f7102572887866375fb6841fd06a5b8377c323388c9b45e8e9eddf7d02704f427eba12b4c5a20de1b6c8030784c77813998e4e75b098be7946825c4171b5ebcf198828fa83a9f167fdebc097a4ef39c1179295ac7e94039f4a0ccf303074cca6a814afaf47350fd9122cc9148d671e182246fb9356d9b9322689e5d8a058b6063e017d4145fdbd3705bf0baedca29e37fc773248e82ed4042300a856ba67658b04747da313fa6741e661d6b816698c8f59cacb80b83a767395a4658f9f4a0b3d589a4070886033a6e816922e6b35786e8b869fe215a0ccf497f58ba34a11da7fc2131253c72a9943fb595fcb74b10af769690c31d4ecf9f5c7fc23a65e2e88fc4da40e642c8c5fcb327ea03eaef5bca650604891ea62b3be5bf1c206a75d906b975906fcaeba47d853461dfa9f7d09c3529ec57da3b5a41acb85b8179c9a0d34084d5f4fa3afe13440e5b470e4cfd4124a49399fa5fb8f837672be439365419f53f5ca5c7dcfdcf2aed562bf13dea37986778977df9a787d58079f5bd2ed0eb39f2fb6906f7b7eb7c255ba545dcd28fb33a6368f3a9dccf970ecbdfb92c5483f9c48c99be440b807d2bf66d7115797393e77fb522d623d0f06e811c945513862e272ffde295ba199bc6cdf7b4256056c9a354870b374d3c0f6015574de927e2afbac50e5bcd0a0afda6f77f9908339c3bc3f6a10d72b3e362e1bfa4cf0c357b177133bbb43392046bb2f9b4832493139c1d9ca6c73a8eb99c2917908e45528687008666a21761f6139600ecf62b89b2d711d1071009f3e10cb16af80e4b44019bc84537db39cd7c022a0cbd1c67f9f1fa286359ca6d042877d75b43e5f78798afc539ff63e1da78f8a88b7b593ad83a6e98148d761bcb3b0d1d8bc0f510ed3e2050e312889d2c00a428dd1c83c6c4b499aeea7a506ee3ab8de7f96b9f1c2c1c98f13b4e9d2e4421163770737113d4cfd87a0f8d10fd17d273ea48674318b6371140758c0a57509fdd1b4c5e1019ce09a3d7c2a9ad9c6a2c20ea137051a9c37b35b5484142a817d1e73808094db52a2de176b4721af5802df53a00ae4d4e737c6dc2b5548763065b0ea0d99ebe0a6fce7a7cbc6f1abe06525274232e265f3801c79d845539dc6eca5f5fd507de3e5d96249b4eeea377a6889085e6f3cd6df0cb04cc2ed7a07d81e2b15eac7432342fb3258fb06f9ce259a1a6f2d4213895cf326af846eea25d633e1f4e61440b99acd8d79d3fa63a8858ee21efd24bafbaffa12ad6c3575d54faa1b9c13d51b3bc724100f0f210e389f9107339661986b76a18ebb730fc108168b6fcf65ae449434136b9b78a62e14c1ec1efc17a299c1637b7f07a05bf91a9297ae297c81709c7cd3ffc7c684e1213b11219261b745b19e39955d5c6bde4e9da3023b65bec10ba68f78472b4424a356d58f380a09049a779092440ec65639406bd2e948f345e8d3eca9e2606336550be2eb9c259379d0eb33f5cf4e4ca9bf5a2a1868339914b1da0289091be734eb221dd4d3879deeaba982d0890b1bdd85c1b96ebcb57c559ff50fab6ace4ae178d1fbb96e311542c14e908f97badba16972bcc35f1ed99b302a42df4823f20c497505fafc89e111aefbebbc06ba58e0231c3fdd95ea53fe699bee770e4f87fd22ca238526548faa99218e28e37b04d8b2244de1b5a556ea876425e8d43dd9164f5857166f48fd907ef983b1c10892d0da7bd28f67fc647d1aa85cd768047cd608357be7f188e3b4015aca3571826b7010963561bbf3b610385791a98a7592d0bde1d1839ed9b44f2bb00af4a8842c5674ca14da46d57fd12f86b9f6309858bd982f31dc8367d60f208001e81e7e3aa39d965d46a1ae681e943802d839f3509378c0447978e333f7c68d873c756f3301abe38038753326bf9c60d72fbe6e133aa5a92475d9db57790973a9657bdb34aa385c5b7c7abfc55fb4b4b6781f590da07023927f50377b014100559cb0c8215fdcf6568d2e8b79de57e96b0de975b5047a6c0b4277b3d0f17d2e58d637d158582b5ebbb6b85ca55bd036ba268b184fb8b45bc2f35cdf4311cb10864e02f9a20c710775fc098625ab15040edecc35e37ecbf6a309b3e3c5bcda9ca4525024bc8491226749f9af784add6e1b06545d84ccba6f4a6d0c1faf74c62a8ac49a201134f94fa70c6913f048ddf288ea71ee261dcbf429877ebbe16df289ee009e752a48372b5a851f9ac4beeddd858d443610f441f7dab9fae1b329ea81ec924e03b879794ae514d98075b7d605472edebb470c6cd1d34b4eecb20e89dd045e977c3996a5ae2be6f5cc0261b4ea82bd3cdb735b2022b8770fb7bb79fceea746d154ad4b7dc0bf638e4907e33fd407a76758a4221912bb38614a95eef00239ebb3c3205b078928eb10ce4efd97200bc9407b3a45202be4bed19dadcee40d689606f384546a6473d0614b496237365be995e6f3190066db8d33b6cfd55efe33cf52e0fd79803eae013acfa8c6bd1a3a591f28d4424ff18dc57aa56e75df6c5af5b2bb693c5096fecf32bea9a700d4bf66e000b3bf7b6986bc80d9718452e125d606c6d45faf9e86e5c32b67c4c422996c28d48829ae2e463fd468dc97ecad14eb9ec0219948ddde6d21f1809a709fd1da267045f2e73d6fee3f74d4564611377207e3579279e9ebb7354b6013b33667b36751f6ddbba24b30005c9ea9c9030a45646a1977d81fea2cd09f53e0da5ee377f1250fa65ad65c68c9372920dfb5813c59c578f39830cb8caabebe3066edd770f84473182c0e3d1f3eedfb195a458638cc4de5d7769563527f80468688d69ac864aca6c1b4e61304f87efb80631ced4a3a89251989dc14493a7f0d7ebf25a7a5507df69123475862859cc25e6edaefc655a692d8282ae0ddb01daaab8b7c726a0dbb6d3b7b6e9b4a18d73023135a6a124bb0d2fe138934984248502570999b0848ca8a4737aca697bbac2e83ac428280c97e1458ea4bb89e1be7c18137a500a46798d6066a138c139468733995f2806fd0004dc254e8b0154e4badc77b8b162ee799077029a1609624968dc2074a74d058597170b24552a718bea0e7b8dbfd9b9ac866b1e85390511dc4edb5a437dea1e87c85e4d7e8c3ca26f09757a4c8fcaf1f15508c6f2447e7a934f6d4140667ba44f6f9e142e1db7058984504a9a7d397f18c8b0f9893add71cf39f8da2da1720120bfaa70544e4624b5d1b7040094e99fa6db214e9785c15298eb9e53176359f4d7ae17cbf3dcd15cc61d8c9f7233262f14d836020d299acbe2d6decbb700657701d694450a24d93214d48d7cbe6eaf76f148f8c599c021f398c3c001e0b9d7f537b1359e22c4452a24d14fc307f4009cedaf1b2f85e3c1d3b8eea603997c6eafadf66a57ce9b1887bcf6307a047a88a6ae22742addde284555328cec7d667ca76973e03e5eb67e27b90a53aab795a2ca8af52c0a7fd37160dee58b78fb79241c2220c3a0604b09f36576a51d2683caab6e306871c137a077737c190b454c2b2582d3e993f162a7b2c79086acf305cff0ce58cdeff6d875885d072ebbad415f09c36c9f6d5d38ff4fb3e19f618c1672334183aedc5de17af4d1c25b5c422eedf1eecf3154db83a4508b639b6dcc815dd460a5d8cb77d91149496296690b244d04e8ccce7ac36c0d94f0d6b0b97c1fd07d7aba04260556ed626664508910d9edadf98513944e35c1e22213c7ce079eeb172adef13d2d66f527acd8f976a2c798edda28b78549822b467d71d1d142d58bd9eda96b40c6cd4b0ad04f8c889d00f31230687d82a71e05a760fc2bdd839dc6e968e8acd5e12ea86030a51387fb2cab0402092110d21294fa0860a2fed7d0a7bda9a4b38df224160a62c6a0a03243579c9955ba946676c306e188bd87bb9a5a97d41d3234389bc5884bb00e712f91dd7fc862a5702d345ad26d037ccddf34b2d94f05344085d9821afb0f7f60038ff41cbd7f6e3c8265afc97cf00d82225f041ff73eb30bb972120b5ea0564f34afb4786d23de8c31f7e8927190c3bd7ee309ea6e99ef939b3a667428c080f48c677af1a5232e07def6da0b8dd7ccc55ddaae62b4d7b48987ad4a9c7354c85cee43c3a0931d3d6b20e84e355752b48408bc8fd45cb2c2a6d4a8c6d27c57787bc731ff33aee3d233327d1661af1f2fb9c667a4aa1e37e4314a58e474202d15adadde220d8c5c78a10b6475fa8a4a6805f8cadb280ce5b7f87491a0c20c79f6e196ccb0c062a72525b1ef405dff0dc7d207562033372d73f06f8becb671ee78cb732160794eb6a70cc1f437248157c0c675a5e99da3427078159885bb9811f0fd8eb2c607f33991aca93ad0181fb3d06fe83761f3e626f2c10690fab4efe8fa9561f47e91b83d5ca701249c2b42e87bb4643ce46636adb74bd11a5276a668ed7c62737dece9aa2be4a371839702f448819c9ad2c5e0a078e925764940b1d0ab65ec8bf94f6a26b6476aeb3dec26af084d7c1a36559bbb00827cddd55cdcb052ef8f50668170657b3950cd9b158018c1641205e010dfec089b4badd0ffc69cb2309cf3482c1ef0ec471e4700a7c3168b464f2e71880a499afdf6ffa742056118b8a78cf654dc21d31b54c78935b43fa0ed879e9d4db81f15309cd3350eccf9dcea74b44880ba771d1368310aa01ceec30c7df1cd4965c27f2ed2320ecd113b46fd1c018625a292b1bdca005a310bd32e595d176f14aef5787135fa4fd0769d3d86ac9e66e9aa88b5a52fd955bcdad1ee7a3308b06baaeee522bb05d8b279248f13711cc99dedfce02cd8ec7f3701b1b57d32aa3251ed8a31483338e1430c5a2d666e32dccc5c15b4861280d35d9948df764168abaa4acfcaa0e969d85b5dafeab0809df81b97bc6422a9fbb4ac9c653d72a5ebdc06d5abb5765b117ddd5dbc3dd903139fcfdd1a9c5e5d79fffb5673c9d228331e35a0eaea567036ada7b18274995dbe0191f15e83f5b20138ac18b96609495be48b00cd6ddb1c2a32c7f258215dcb55df27badc0d2b9000455efdc870cb5288cf846740a26e1330625eae33d1c8db7a82a05d8f3b63f591da898aa34c2905d6212fd564ea68b3e5f451073ad815d2de2110cf153669e63d1c39d7e0c25baac0f2b5772dbdf2b9f092d53e00c212d73f17f1a7c75faa8fdc4fe7647a6c0228dc5e955d8191ca553282f4ddb6136392b5aa8ddcbd8699e6ea84ed84d321957f15f2b8a0ed985992347c3e4c857f277ffde90b0107b1d9310008e1f4d797de8d046aca3a1e316acfbd2dd768d4d4d9539b300a42877c6f18fbdaf8672cf63ae9e9d4e6deb885eb60a5f5c1a332880e055d7b56cc3ef5274c83d7253b54b479c26c22b0b3baf8207ff564e207785568d3b9fb48b25516a2d7179583147f67ecafdcefe9416f64feed04951d51a441331c10db9e42cfc9e65e5fbbf887711f9a900827297acc13b0da36fb58ee03a4543ba7538aee0f65ca542ab7c3d933c549cb5dd165a1d1430b558a4259c7f3dd5008a13430548034e24c8d0fc9e4a7c86ed2042a20fd6e7319702902f9f7cb8410f64151ddd29dfc4e0c28f5032ae3ddecf3f5270bf0bce71d92ddb507617a18bbfe47e1f19eeaf389b3e16d883a48a9da7388e65bedb469151a754663a93ca7912f6e60296642e20d353cf3bddd4341af76877c544bc31aeb00d959ea4c61c48c66d22b629cf6f44ddc4df1b325203e1626c29a985022ac93cd7896f8662a2fc43203af41b756c85a80c93a8ef66a788d35d996725f559c0d6c8a6fbea695851971eb08468a24d06be4a6473e3c182a34e0fb90e631cc3378ed8dee9d70e84315eff9066da8dfaa82ca7415c0f59e8cddefcfd67304c32454ed64ce36a349547b9b0496390e778ea5880374445a350266a8c8e72d35946a6a281f638826925e1870ddef2733891d31ff928a7d7da0085f62ca40006c54c10df73416a6ad893c6e90cb01f6e3019a27f3231f16cc6232a84e9c735aed7b541b6b7222f94931ef60ede611c56e508e6142df191c2725a05f919e3e2f2a9ea4c60798ce0e9b7da2d1cb1e0c3bbf6032eff732d39171cb14cc3c3c8361a5a3ee84df7d71f1fcd4737e0ac7db899fb2b458ebfc4a2fc632462419d387c4ac1ffb97f5776c04db0101d323d52bea00b7dfbd96fddec1a6494677e430b862b2504f8e5be42a682cdb4c48b411cf2901b80003e1977c642be56bd20959afbea07651d9f65730bdac1aeab0f1919d2e6de65781cd8fb000015b0dfaa688542e618a37b9b00f078385b292e96b00c70024f616982435779f635a75f4db8f21ba3ccaff73c5df4a5709cb3236ea978bd312ac2d050edbc3f637946990693dd39c9549a89e6e0e90885892ef84d40bbdabf56cf37cb0621d6e61b207b18d17540abf276a99164d94e7f7c66b7d9e4b0f5f47a390c0b3bd751af9963ccc850a74aceeac166b441cabe6e5247fc20cb2310736706544ed490923ceaf8c6d49e73438cebb65e7b56d13de65b5bd87cdd65b430afa1366ea0f2ab7d9206d14a914bdbd34a0c468c7a1ff051e1fea85a8814df633e1c608175e8111bb377ab716916c5c685078da739534cf2781b2ab8deaa6fb32a45b8f9290c49988d460e1744221c789ba6c541c808b30eb017171224de83de1e2baf73bca697eaeed44a38b0daf4351e1834375ea02ee7fe2749220c75be5a280a9661137a0669659e63df32cc12491a2700afbacc55a1c2bff5c77e2c1667fa2d379336580ba204a119166d775f0f25b45303667f7d7cc3c6c300634cc2b643c4e7076ac3308ab0a0f8291f3e929825f103ae65b599bedf1b5017dd8d7f795151e36c351116c76c9fa435504ffc7b6287c67dba6a86854dc8c0ed449fcd37e62c691d18c324a5adb688d96b36d69bf99a3645d815c5bbe6ece0c4ebd24f7fa449cb1d3ebea2ba718b77c5eb9a17385eda324593f2463d5c90271fa87d81aec7db020956340b4af9f365c2d1098fd3f32db5ae9a64cf2f4882f746d1bf171887c55c6881bb63cf7d52ac393cdf8c85efacde3b8f501549c17daf8cc0cb10758eded3f2adb5ea33094be915dc0cdc4111893b7a27227c00afa0f7bf5debb57238698626f8e6a607d5ef9fd4fab47b80b34ea89d8515edce709c1492bfeecaf66b0b2555c239d55a7cc008de6a7f9b079c6d739ffedf5490bef84e05f383212ffb3ac80c8e33f9fb4dba4377b17b0a081c92e3b97955dffc6c8237a12c9ae5ef84d4f88c410918ee7fffbcb58ade67821f061d0a94775519b8b3f78d847e248a55d6919891e56127b31391b076a7d86d516f764901583f336d8e067bacacf832eed93aa5a760c4dab77a5f05d4d4eec5ab3e71137ec71863a6cf480436aeca2fbcfa62b9196616d56a535c3663e4cad3846052bff7ad02de85ccefea6421ab28e46ea46566fd32f9d73ed61b870a13a853c028b306e9fe973abe97b4991a68f827401b0433aa2a06f6843e19d3e060de254034e42adb9955adaa01c6570d7c8cbb4aec21173585defa0c9d2f6131f2f7b3c1f2b26dcf5d9a37997a637c96d0e49bc23eac79bf4ee108a4dcc9dd69e1a14e36a179ce8e02b4dc1e295fdca5289562081a9fa8caee258f60c4a57f005d84bab9ebd27a0cd6305171ab3ed25f90ce4a24dbce851c86a7cab56f17d2f1c685dd4a0d5f46e6b29edb37ddda8da50d022ffc5e8e464ad625334c0466d1253114549759a0eb4d36a2522b29e8bf7c0b8fae8088a2f98389819f6a0b83e91251270c38ec6d5f09c4d939c026bd847d670d99c0cf1e665dfc86f2e61c728efee03786b69ef4e74f2734ef9f5a21320c2243f5daeb68edc6aa08cb9c21a6c8098bbc0e6e8f254b46723fd08c19aa5a9c048a3256ac210b99205f063dfcb8c508f310a91255391e11d9c122ba8eb26e0d7eae82a71e01d5c331d6606b56e74165f4981345c603444ab876a470aea121630462609c8fdee9b0a63db58d2c421079e26ec33ceafbce28afff9cf0e3c950a824f1fe0fded8ebcc7fd864b8fa91735d500df53af07b67e9cdfb3c3b8928d93d65ef74977a931269d3532a968c87f8a93ff7af6084ca641b8118d89f9ed5b763d7e37b71e6de28c9140a5cccc216d9027b807cb462de74ff2953f46141d2b9d8217a08d477b153e7a416d5088bd3a9cb175730bb5ec09a43e316b4d3a6408b4ce3c3abf4ef4887ae9333ae85be19474bbc594083d79a6ee34c9e0a8a79f9d0eb7be8a3eef6fbb0c498e3c3390bba9868f50ac87405e492e01dda5ceb985a0e552c448bc5b2ddb21614ff6a9d51bda331fc19a858f926193764428c0acae660aa6ab1d267beac1bc686e693c51bef53e12387efdfa0af256e745886677cb61f51775facf142f4d27d4c9f7dc00a732e0ae5ae31993b2d44a9756549f8cc0154bf558c628153c1cb9ceeaba326511607889a6e00d1bc6649e1a6af332365c8e25da131b2d282ed486e4ffa1af2d6fcd1c817ec03ba004430705804b72e3d68433fd7f604e09079df99afb96583446961103c67a35e5f9d0cfeade77ebb5539a2e3526c2317f831470c5eb059605de975cce63a8ff95eaa58900f2f170ec7ef95ee7f6070ef87f8645983759ea24c0491c00224c32b9f7c2a0b640a6a0a87fbe59420a95c40bf882e7ce5d4b0233c0ab5e08c56593646a3b40c5c5f2a44fb5aa448c1e06a50ec2f463dc0c387b693a755ec3511a354ccd3e18213a1b4f31bae4ee7a43fadbd99fa40ec83f18a2ba96f1bf1b2b167c5d872872fc5fb316b901299d2b2d9ed8d8712ab86b6031d8d237d97b6a8ccc292c4d36a52850e6fd9159bdba46366cab4c5d5cb824137e14e4d0c7ffcafcd9ffd6fb2a3960cb446f76f9263f8578cb99db94ff6b6870e0d5b5e1d49d7345b12d240926618716f96a42ed67ad931cdda4e6ad4c7a77680fbbfbb0e8716c265bca74b4c8b14185a32aadb7aae90d4d3df747b7f5719388587e6e94a2c60b2e28c43de71ffb3afb18c8ad9ca08d91f91ba7c52d4fa63bb8957e74d01393e1c54d7bb88702198028e7b8a63fe998e33c3054f05c0cf043ec27d711b49afbbea2d6030b7927637a628d4e513a785361e2ed41caf17001780c67b0bb218d76dc43139868fb38bd25a30cda63734adea6706f0178daf79b95fce925dc0497270d17886fd1ddc2937f61f977d9d2f98b08a9ea1bddf3519fa9599bcb298d2222e8f345981ff7660b4c729b4ee951e883d43113a08199dedaa11cbc16806f1f926443a83880e87d4914ee9c15b5035e0a6826d36e9ba70337147b6d4c18ce4c285799b2d02284f1f2cce24826e15467f66fc4004da4dfcb69276ee9c1b99342965faf30d4e53b6ce58e5ef90f070cb14d2b3544ed912c4042b711debb82b2ff290bfd0628c80b8d82bf3ffc4aefc59e79c16bb7055166f88f454005cc6ab103385ae623221ec8b181924abc280dc715ab762dcd39814fa34d2aa5434bf2fbdad5b4eda339f67a0ee98038019094a19bbced989667b4500d44fa7ff6775192df5a5c07a6aef658c0994f915078bbdbe7fcebf302ac410f79f22e47e88ba57b59011f65e3e32c16164c716182117f4a90732c0f079db280e47c2e37cd27d5d59c2355dc2eae5ecb1b117d49c50b9ef54b90942fb970facad0df4d3a256304e2e3a392a050904682faf57b06f099f1330e13345de9b011be12ec6063ac2502948a1d1b1625de535049f4e3b7c807f7a726048eb0f8a1b06ea6c0efa48ff721ad4b4904827fecd2d543783e3886f95a80d4e1ed21bbee6e7545b09129c4f02fd7883a1c9e5581ae6dbd0061000f165e1b9ab85df9d427d3c84780e941a1a4653e717c42d2ed5d0bdca74cd9c39c76daec43ffee8e2de339004aa6e616005a842aab67b412fbea78451d946b8f760ff9d65dc1393a8ac595237ba003c4463030132bab5bc904853f82846df5cec8895e004c591979985885c21701a5ebe670d766dbbf06548026e40a44f5467d545da0d3b2627a9d7aaee9ed1a0597e9024c51dcd651002c4eb9a08e5e3142a4cdc5911f51046a2a159a51e44d8394dd48d3367d9bca08c7078149be4ea70719d0e384c58fc3b54aacacf3ca0c839880a7e1faf0178fd50edf9961a7b570a4014afbca96f0cd731672fcb333599e41059bf64617d43a4e4a46bd0b38014fe3a672c07f50ee8a22a11c2a44aca793c804f1c6fe1e179ba2c1241dc24015f9b14ddc6573939e9d4c16393c092e6ff65a11e550c31ecfb5f95a3be3358ebe165a136b075dd0e48298f253f677b58ff1a115428c6a6c794e612fbd8379ab80ed69c0997defc967d642236c014ce8f3caa9eb13e378f209d6b413bc81c02b6004afb95fea851e1b9ec2897fa37661e94feb00ce3c55f34bc8d0e2b385944478ea265542dbd5af41c4c6621d727312270d029861323a0c979a74e4b56556f485956b4e856fb7067fe00d80bcd6279c236fe6c9369b22bc176558481fc653950dc7d0beeb72acd1a16618128c55077c260dc21beb1e615caaa3b4ede80145df381386f30d5c11a042f9869dfdc93ea053b65a847fc3d951efe0814939196dc3669286d422955282d03fa564f8f34418ddfc3b365570b68284c0706c37126354baf5996fb99a925d6fa7c36005a4b93fdad91827c1ec607bce6ad22a8bbab5fc98015f9f68953ee64accf2ab058c22b62dec66e722912a4f1350660bdc36a79b8c8db3a87b89b7093ef3aafd2b6a9aada96e048cf684133096a10b62ada5fb69881493b2e181616c8dc8a5a23fc7fe8929f65879c9763d1dea4f37ea03994e6a95b508329706d6f94353878cf824142b9b7341576f5a09d7e87999bfcd0295a19d64a9e5f221e23f81c23d02b6581878846241d238a6dd7477ed1a95f24cffb9b10035c3f8dc6e11add53aa2dd599da22b149be6742e47a49224376d166d0bc4970de1ef9dd03c025f8780d0e5a07d570894265369307c29b8d2f73324cf9cb9ec6bb8a668721837f6f36f4c13eb1e5139f24312e6699ae159866cdb4e03b4b19bcd80a20b2a493d77cfefddb568b0fd7d72628f6a96f64d4bed4de07e8149ed036f81c88f1c725c07734a09af1a98166a5c7598535e31c261e9a2a9435c2feeab20d70fdc0f8a8cd1c8a2dbd5660e2d1067e3a84aae03261a6bf97ee237f80973ebd661a193d3bb1ced201534084bc7cb7a2c1a446492f548f473699dd0fa1b32b4079e35bfeff7b83fc3edb17ee0071313ac3edab5ce24744723f72f5504f675a4f8d49f28bdb8fd0beb7e1b1fd9e9b76d7059a9790968799d9ac3e3154b31939498aefb07e97eab5e7628eebcae67eddddd2fe82eae65f2ad92fb3979659d42e1c213a74f866b6c144a4a3025cc8ad362765ce9919b3f3f5711fb7f6f473afb0747c01c830d338028b873815991f2faab3d18e455201a00daa095c117da473763b6649b5c23c4cf87a28af296aab21b028f26b32fe4abc0479e764f32ac978d14d74f90644029cc152129cb0a026131cdb2ecbccbaa54061bb400ce0bf48a5ada6c01efbe6d7975143e22c31ce3e734813e78202f05db50cd2223f11106897b2472e1766369cc88b9d9c0b3d7cb422702b2da0c89e7f5d5988e989593f741b0713695a38351e80d2ef28f01354450f96c0b9b082130bda9b93911f7afa2b40f26a0b0f63ef5e39a12158998396d49897b53c9cb1d95b234a18690fba4ebcedd0d112b99e24360d11b893c9da711e53ddcc7409d8df9748f8e83c31acfd49c1e3783574edf6c24c5109ad8d14098cb9a0c332a70bb77e52c3d6a1f6517a10455bb4d66164a2171009497fc4209a031cf96d96833709f2585fe06e269b78ad6be503daf7bdb5ad4a03711500a222ed314852197f4f44c856f411d4dbb01ff2da22052f4b2de39660f27f3882db64820f635a118e976e83e3656b0053345303a9392c5e4b1d76c8d2e79bfb97ebab536901ffed800eae95106fbf866fd7de5c44c6522c6a6f52b932d5709fdafa6059c81d2c8e3788020a4f66fc4f14168a5ac622900ce0dd0b37b0e089b8a9da5c22f064f0759ff131b7fd703a09a0f52fa69f6dd7c75fcf68fce35df3f4ec05bc2e652a12da8af4fa5996f31895c0cd55aa4074b40cde74777998435e0cea3cd218b5e9ca34e88f00f7b844d5f8f30d32121e16d5c527b62be1ffc1432a444e4eb3e4e79408c46b7d2daf86dd43a27396a5d7b6ad6d4f0295daac132846b7f078cd34e3ae6fc95bb7be4360407277338cdd5e2be39b613bde29804de23ba7f0b7f709bae198d57b67492df6e4ef2d450327fae5fd152abb3d60bb1696816342bdbc56ebce9581e3c6a3aebaa74431975ad41c58afcd6925d724bd3416c77b28c309f6ec960b49cce977ed5724c6619eaf5093011ed9e3e4eee64b6db7e32207b3a1148d198027803ce1323b43ed01909f519c5770e42b06992dd57e7aeb74e7de2e1a6827c8b9c9d391c30d5ec95dfcaaaa9bbc890f1fc8a3d26fc681f5baa8229b76b3cecae1852cba918066c2e3104aea04e7688c872bd5c57dd580381830ae032132255c39eb428909d150c28a85bd20d098c6ce2a1fa739a6b77c4b42936296ade8af9bd67eb91c20fae5d2b33df9ca2493faa2316f81a2f95542f3b4372ecb1b9e51d56e390d8a682c4bd716aa66125c2f3911e7d305d88396994bf4b16ae6f53c28568e77ef44ff7b15d3b327156917290cc2ff37831f6c0e682f5a6057ba8860c8478809b66817e0a77fd1fecd8bb39346c8f952805a946374c3ed4908feccd0b9cdf6e59138da47c1ff82b4ad48ea69eb47800859e2be352089232ba1d6a0431d52a3c37091204ad66ef98f69361b0df29fd7358917abc27c86a759f737c06f67f8ed0166d24a566242e716d9e83c0d4b36f9b0299a1de2432b4ce160e7f748d4cc6ac963c5b4e0fe91a4214e463f8c249792786da533513a5a4995d22cf1ffbd428c080241c3c8c4c5a0e65b1ea3260609202445558c417c33ad1245e84e90738bef959b3a4f07d62907478543b4330b55c20ab94fac0258d26e38f5237613f4edbeb8f3cdba6fd45efdcdbad984a17fdfe7e121029da61cc9a58e47fbf99254cfe783927bd6768e1af02f2d66a8b17fc4a84f33118c9a75b9d993a4d1fa72b9a5c27a0132efcb59e8adf14f8f25d251cb38b69a38619d0cbe4b23ff059aa0ea11196effdc98ba6bfcd2da79cf9a128757bd5c3f658cc26e397f2602e982e5996ec66af6a982ece6274b8fb0639c593f1b7dd09ac5fa5b2381fefaab8c15e0a0fbd6d59ecc169ab2a5f4143d9d70dcd51ea797e6a435176ba2782bc60c4616f9c888f7070b53a80d0cd1fd3c21538873ef62b27d2efe7fab262d0800b0e0af806592eea8fcc1e3520643057540bf2890542bab7745c18002dffe845768963cefbec02fb085ba479e7991e4cfb2bba4e33ba57844ad73697206d8a1c26d72c37a51e85b0d14bcde2ca49be7e1b8a94922922ce38a83f8b524147a6eadf2e07f1ef4308579a9b5dce1941c24afc21ea1e59ccea5c5613867531ad07fcd995c3ff4fbc8fa219a9ef6696e20c891c9ecfa9b7687a0282def0a1dfa8d494abf3f00cd34446d2c1a3647a239271c751e8cfb5eda168588a9e77b30c24a997f6a53834faf04729919228df109b40533c7e5a34ba64f4e3317378fa6eedc5dc7625abd1698f11bc9fe420173f5379cfdcc79a64008a014e929456ceccacac3cd3514135a451a0cee86f566f0a9f78881da948c0fc6f5a9cc5394ba501fc24fa24e27f331fd23943cd282ef6053fc90da10d8b2081c3452078d0c71c34faab5d57a95374d786bccce7eb03e7bca747db15f1ef9db8eeddaf36aea758f0d0e23f00b40a7a0639575b410e2a6f53c024d8865af2a866bcf10cb50c5a16f6c39e36c9709b15c11262349238402fbc693aa8b64832cd1cc2afa733aa149f282497b23f6cda04a17a33f3e452ac18caded7195ad1ad2a53eb373335350bdfe68bfd0b8439c07ba46a2cbf08418e432af09c3ec016301897d1e4db2a19446afeddf641ee31c70f94d33c1d7daa72142b8e508d125c93e1cc9f9f5f706e61eba7e3fdc6d4e8dfd9dbe6fb3acd2e88da6ff50f396d68cb42f5627acd150daffe4b991b705456c1ccad5ac3d4dff49e8195a70d49c7171a697f399a7558f1738b2b872ae06ff44b070b8d3606cc47b2e44d2cd9023606e18ee931f524d7433a3fdf2bdd21fefa68202467778f6ddff4474ae54734af19817feeb0630e63a7e42aa07b2c35e50910c4b3100bc134011167861669bcd64b28d0a552c90a18037d3478bc1ddd8cbc1cfca8fe7875affe74efe3ff2f857a128ba23dd9ccf75cbdc88592e9ce92e6d25fbfa9897a28fd1d7e57646b0adecd99eb54a9f3a1af4d201914d9c9846a99324f49c1e36da8fdc7b1d00ef64e6a9d32132740b671f88427bc12145b7ba51298e71405b74843e969bd9cf68b79e552584efafb73c4d4e4299b2c536ebb5e8371570d215bda269734abeabc7627221a6dd11db64afa15d8a981a7d530505cf7f2b3dcb69c946a9d71b9959c3d36f5199f066362269158e387826aa0c969c5a70b3eec732b91cc4cacb86a5b84078cd2522aa8f1aa7937f51debe46dc8f67260468b9b02b902a88ec8196d379d4c00dcc312f199987227b834e1a2b510d1150d1c6721ab26779e53ef980f1362e2817cb129cd0ed034100dd8c74944c0cd56c00937105beb4c94f36273156e64c64aa35c558a6305bcc1f075b484d28448d3834e8a4565a15bedc16d99c438aa40f4f1b4fa6998f379575ab67dd05cd53213ec929cd4ddc7220771bdcb8ccd5c9daa53afadf61c101f414912c79895d3d3558f0f239c9d41f6f07426b16e1cf55e910825170d6eaca12c7053e489f281036579535bda94b1afc33e3e1c80c22a684502cfe0397212f192c278116f6a0e5c5d84dfcc84e6e6d6de8b72f03c11030a8ac2ac8d1d0ca56a0b9ab1a48c9d9f00e895a6c61d8d8f40d7c7fdd5866c31fde15f99cb7f33177b4b802e81d7802004314ac98fa5c32533360bf0e12c8b961b27a4bc2e28b80611d76db693f269e6307da81a74135f55c7d581acb14111cbd253820155961fd08a74eedfd62c0ab7d2fbda29de2445862f1fd25685de6c9576b0d99d932b8bbd25f66fc32fbe53271c1c5ab235162188766ace44924cb194452bec201db0b6188b3925e9b8a64d2666d0ea5ec192d5bf78745586889d490caf526634bf16d4ad2bc05468a4bc38a2f087e9e7bf4a8eecdcdae9fdc668ad1e167600115e557d93bf46114d9f635f1b80822dc4b304511038386a3cd19b20596f7e3415d5dfdbc15629d9cd455ca9bf9b5d71d1db56f533ead96550a140746a87511dda320848884addc07334ad6a5a706f443a6c7b7acc73432da61c9839478dcd05ffd79d7edceff2c6dc7366840bd06ee6ec4e4e20f94d8b77616efa3c7d09721bc450d647abafe61b92be905acae7cbf5e6238a1bfdf3e52288fae4b7bd98b5a21b9cf5d5ec43f1c437db0dfb31ae7ccfda956065e8e901287e04766f8c1e6a6b10eefe39857ef2ad91ee337f8c2b0ce356c3623fb4522ab0628a30fdc5ba5fb3b2d4cc6e699bb99bab28e9e72815a356fe5a21ac13061743baa494da4a95ec923aeafce0d5525bd4e5dea5103d28cb7ee03f77b157139ef94c0cb9cc30fee8fb7d20b9771b870b0895da41d0d8f42fe866d609fa90f96aa5de8c80ef722f8c3e2875f4ae95ed4762971ba2579be391f7c97ace9a126650a116221a13e3bd54436cdbb4e46f805f20df31694799060f12f3e1bea4f453683e8b535e0c871c0a278689b29f1027b6703eecb6c26a65dd54e9908d004134abc0fd8865337c47bbd83568ccfa5112260e2c764434b03a3dbae1bcb65d6aff2fc77f7a717454b398851ef77e3e044f9126ea8ee1aa6ebe32efe3476b0dde7b35f57202486ea38a6e0ac7432b9b49ec2e005629d121a3bd50be3eb9a515aa26b1c3182e402cf894c09a3b914b7bed366841ea974a15df080848020d46235b7edaec3a764cad8ef4f581913be92a8c11b372f6c44a54a0eb972e8fb5f8c7126f9ac74043c790986c42cf9cc6bdcf6c360a76f413e4987d29d894188b05d80535b610e3e0a8885de38592700f452364560d063b9fd0d45aa2cad78f43b761fbc5560108aa30598071bd01921449ae0521c199014fd73ce64464788028333ac9c0e11de3f217fb7f02807f3fc2f922b286a80bf9d4b8211f207fb77a5ccf82f87391f4ff7f868ab3650561be1784adb81de04f65c35da0c717bc4296393bcbb708f0ea6a8594ea97c776a2a524b341eff2bec6c9a521e5cf8a6703c4a5e3cec49f853a8d9d607e3bca90f1b36a15f3a577ba2f20f2e0fd15dfd2e61e0051dc0ed8f12e24c004bf197f6aa058eb38618e505f71f2b8e1fea75d809630be66503a21bbfc22d39066221bddfd18dcbd0740fe27df3b2ae7c91f7b29725cb3cf01451f530d07753efe15f7a36da17fe6ffbaf6b8ab4a61fd2d5efada8eab258de179438b7b254aa282a7274dc34b1dfc9e09088299ac9dbb0f91781d079b3897ef2dc208c4e9aeb4e3297580ebe85b6c5b94a88ee096a9dd389edc21dcb9a58a10230147d5a212c54089d8cf1f0b565855c96faf1bfeac995f7cd2af86d401743ecfab5e43ffb9da38fb46b9b13d6dffe871734f8898b39a1408476f79937884a3cb6d564427f1aa285d7247a0f8a0fc72bead5c3a0030d1cf6a3475db61bc0b8a8bd0733bbd4c817dafa0badce4f7e6972cfb5c1f8b54871ee0e1e8bfb85f6edca51bc95373760a52cd1898c49b3f8bab56c2fb3b0872bd18d75f8d7a9d84a4bdac29d0ab0a10df79a1f9d2ac4a02655351f0297abf807812c4a9963ba567cc775c1412cf1245f3600654f1464923dfed80d3eb82734e089aa678022cb65270fedfdb70fb4959a2c3e8798908de5f99cf13047ad56457b714418c5e662ce06e66ce4f63f7e58ed392268b3a9cd28ad2ac255b8a26ffa38e057a6a8d9099ed376709959276b70683bbe85bea8f78185e36a58d6bfd3ea62b71292dac86e1cb410ae2e80addecd9579f29dd2643e1c494e31b0364838e76ca0a45edcbf2b564b9fa3ec5fa473471e12be614ae7ae900c3674c4bf7f45413fc4d2640486ca081d71efa527d9e5955767318d69920802697b9d105d7febeacc2906ff595dc62e025f573bc227b46997b7492a86979ea32b0ddcb22722d0c0b77af474ce0728ee698a9dd6a3a2f920624671ba0c1742dc50c9359c570e91b62c1c87561b232731f0d6b217e11f6651d052993d772a3b7838cdd8d4f2b727e31b7f1ea4ed159af1a8d41977e1bcad0ff9bc74827893ec8c74b09f2402568bd0e4e1028114d6118867a3f3c4ae886d90085f119f041a31ef0cf3680d66b7732f0ad8abfd67ceb0e3112d42ec95c8ef302419ca8235f5d6288b99eb3fb728db8a1e878ef661f9f3ec7f0d77060a228c63ee931597a9fdcd4d1b405386140d9f987e0cd2b4378f3d7ccac532967a2db1c121bc28f8bd40bc79f9699167cb57ace87e44b02bb2e41cc406a04874ce1bd88f1ff3c022e49d8e8a5951b8374a150abe47655fd8a64e2da917b4db5108eb356b2cd94cd99672940cb64243edd04bb6dacaa5bff0b27ce1e04779e18e5ddb08a28964a85f505b79e6030cfd3efa644c782806efa927d8082fe135e8f99f83bd6e4396542f97b03af1c0d51a42b96ac8ee58f258a6476ecb2c09ea46aa61286146348bff7e1648a9e19cd292cc6ff00cfd98cfdeeadfc5e26f71b3e51878f75e6bba66627b4e980a462bc98a996d75b7fc16185c6ab74dcd46814c0d8ce30088fd45c1e92d9efeed376b6ccd6da700f39bacb8d6c359ca4f167207b4f4f753cbf1e1a05d870e1402aa8fe3e1e9bd4bda0730127f75dfa3c71f5268de1baf0f54263f0be1c632bb3894062b7f16daabca3cfcb8b09abeb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
