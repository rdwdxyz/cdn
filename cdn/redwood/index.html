<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d237a025e32b4910a6786a1b768930bb67d058d7c85669aaaaf754eaedbcd72f7b1ecf4a48df9a4e8649a1d20bff3cfaf86839c22c0187f6b6cbbe0f597beae20daef02c074776b3335e32cc19e0439d98d11ca2f054ce844b16cbd87ac001fc9a7d6741499ca079276eb99676bddd17843992d1e3c919786a940873ab054670c0ad72083cbb95b1d2c2f38389ef2f3a6c0e8b752b33afb216a44e14f4a8c46a9192b5fea80bbf59c7213ae35d1d0690fa8004a3ba41850012d6e20b36307b8762524cb0b5ef1391fa7c436f67e4eab28f7a799a5636b83f4c6e16e37b911a78104b765587c6b47f659ac2a48beda565ecabd4fa967cdda1fe8af6c0e26ab39eeaac356ce4e90d7bbac81514a6d477b9c9593dc8b12a63658107d52b544b72cebb72d5857afe7fe449acea3cb35be4372c53e778aea0a552e1a5fd2598ae378190281d1032c35c69b50433e7593bf56634581d7a049d4247cfe2d87cab41779d53295fec490cf64ca4c565262af3078b7e3ce4382a8f6c47a1b62fbff838aa24a7978bc0a869101251364faf17779eb1ed571a1eb582189a46eea355241e6738605e1768553302c25eb59dce32663871aba3e55e52fe2ef5906cc57bcbc4094ce51ce5df119f0c6b202d7f3a48f66893499418fac7d022b23dd2e41734c0ee8ef7e98c4e3f0b191ae4c7c5804c49474f1e62c7627301c0a8841d7ca990d47487ffaed3b9bcc85f472d720bb832ed40b2e208d826905047b1e49e31242e14cd69c4522ec4a552124d636b8206fcca77bbb1753ec8fad09ab2b66a88f4c5e8938c8611149fe3359425edb0f766f44baae4d6e207d35c1cd11bea828ecedcd27e4275054c54720046194f8b0d12a4fa9a6ecfb83ac989e82ce9d5c66bacb3b2e6740fbb6374ecfe660c7e13de43abf9d2a5c498319923fcb4421c1842a2da22027275726f76dd59fd41cb757116b794f78318b5fde7511c2a6447af12854bc2f8a23b5f96c6fff34a044d04ca2c38eea1ea9f7fe349676af40a1149668c03aadf3569dcc19a052b36030ccd98926775d064a017c52412d3c82da4e062d87e9c29ca8d0db89b8588227692643b9080e089aec05db0cf74c9b0d8229787dc4b4d7348e0e126404df389bfd749f5e09dc206b940058c443050987a77150cd6c457c5fecccd3a1104ccd7daa1aa661a828066f449ecc8b673f56a7fa4282cdd7375cfe20d2345257e446f3c6c9831bfc46ac78d7512d53038f54bb7900a618d0c23a3deb30ad57f9b6ac588b26b96fcbeeeab345b75ad977d116e7ea260c8cf7596e7fae7516dd02b2b76a8eed5b01070aac6e519313ba22c7bb0e96ea30cf43fa1a69584016bcae1ed4bedcd8016dcd0f693a0008ea6cfafe5add336512077f5b114e51f6792fadd375ffdad92392c4050a44b517c9d1b03f29a1c5c215c52e70160b186d9970d7106a0ba0a92aa787aedc420782567fcef1fdcbfe0a2bc35ec1731d0ce600edf7ff57471ae198c265a6b1cd354f71b40753ce6688d4a17a28c4620fbb4eb16cd6d5dce8a5f5941cf770f00236cb161b647358ccf37845d5321c687f8f9e2b966e523a815d400d93cd4370d86638e26883aadf266ee49bfb5eb8290c1b401159933c5cda2993e44cc7dde2b55e172ea858e0241d72ea694d30e99ffffdce7fcf38b331acc907e2fb3821cb496a7fbbb8d30e960c4d2c9ad0842d39403f6605044569b6ced8f4f812c8aa0c8c12af59552e1170742efdac4896143755c8acc573204302f114e22109ecd32f8ea61960759f4a6b5809f623e31b3c5bad02c9ee13d1cd439394c34a551bc416f0bfda78c6dde9d60aeb68ee9484909743de2968d1ea3b46a8fb30d14d9a9bf57f1eca2ef684a7508eb66e133090f2f2137ae47679c36ff13832641e546ab608508cc3c744eba432d37ccb2e8a078f740ac92a10ed1a1c7f388558f7bc11bec4cf8c59d9bd9363c84f65cc3127c38141e13f1de79507d8d9251d1c612be42ec09d6f58b50bd4ddf9d5a87c053f7b2bc18d1328ae6bbfc98c18d1897cd28ee40b5b045b71d3185068ce87d6c738608632c62538176dc867c7d1b70e7785557a517e1fdc148cfa769abaf91dffab5b8eef6299a169bf8c1e0d1fe5c08b1f37cf88c9ce4c2bb4c012855bb7d57c3e4f4e79656824c4d717aee7e6b77881b268fb05dc698145d0f73a5c404222c4ac8de1db6d14add24e4b852962eecb4af5bd8ec774a8acf138f45ef83d25257d50b24fb7a528fe0576b189ac5c0ccbf2bc54e6ff9108976fc59ab637710bacffb028f72bc8971a26c20b2cfaec0e9833d97d6c6f2ab276426b783c5b0afa7adb5a47d11fbaa6b1656864e7cda42f52c2d50e0545640a6788cadfbbef4e7ecb0ee0e73a197b72bf25209c899381b855f860d970ac54e00605402ba7134efcaaa018be16031979cc3bbe0e164899c32bf6ba0103407e3cda3d65ec6c491aa8682110e398074aa6d960dbfc6bb791b4ac5bc38f0b407a0dd2a51e7e50a85b79f732add0dbf801df2b474592e59e43ce5154c9f7f0984cecabb0c47c7cb5e40581fc72250ebad67e26d8123fd0bcfa0e5851bd0b9a25e407e6835e432874421a4eec4d6209f76d10dbfeaea6ab9660cc058c8e2cbfaf16a5dc3b1fb90794d7f1b636c8bfba6e45e18208bbc9702e4c4c7b6e3a530045e096c5963885e3618aa71db3a23fbf2dab4b02b9403722166cc065cd34eea6a268deac577c03bf3bd1bc116333c6061830c474fc43ca17de65bd72575998eb5b83d46322ed4c9b0400562dfa0346cb86e92e37403e8b5db044dce79cda0e1d80caf6f219ab6236fd272453d69c84239de8b8039dc9ddf0f2ac6bc43c2d68ce420204acb32a52589aa9d6ef24c85820a157af88279dd4990f389c114576b83783ca2241a005c5ed9275874560dc6416e276610572139a8423e710972b2af8a4b61b739be2caf55de439faec48fed77d86c908b4a419ca2b3e26017f2d20eb984f46a4d6467684420c71907225b002e6605257db7b42777b5815300320947fd4e41c36ee2f157fc08da128def1eef6c59f02e35a7a130e0aababe09b448b94e29119992beff7238583fb26f603b499c30c8b05cea2e7fbeda4d4b78340ed804ebc60427416ed877be5d1248812de9258622617257c770da1556e655dd3a0a73bb42c932fb0edfca5ff0dd08cc3f7a5b301835c0e71649baf6ded3c4b23695d9abb8f3a413702a5691b46d396f7eb9ce7b31366020b5dbd5c7fc36e7013edc01547fd863bc6ce58d5b2d6a3a61627ed6defa5dee0409970147b42996e6c3ddd2897fa89437315ce0254419218bf266b8f5ca77356ec3912a8026ac9a9380c333da6b40c017f2b2864c1b8e96a7a3f60dfed1de2c5343a7f2607810e414b1d069f6d65cd2907ab7a80a7a69b3d1529097a71be56d5bb0d11883eb0fe36b1de484aeb6b3476a626c37662fd2215d69cae8235c6711451eca9358681108eeefeec1e9f8c8340ea01b4ef0cf6088d3d89924d14ae93b788e4d43d846d4f678af49a4c2ffd6680e70eacf6835e8fbd7814797b024dc4fd880dff9c0c83f3a2ba341fe406a975eb762603874fffcd3e770a3520efd331a96551ccf1345f910c1cbe3a35c32f34982030e086ada14885399b7c28ed0bfb60b664d7a721794016cda18b87f6144e5bb18578822b316c687ce2498dad36d56e4e8a95757da2a12b147a87e292b5130a25f91b4ade8b5993422a29cfc5bbee941bb1c21660a215297ce7b2bbe22c0d0fee77d7a4ab5fcecc1ed6188ce31513febb1c3e2ff286ae57c3ccb9b663860ef8d2d83cce689e811f96f4889356cbd313351a962cbc54f585f855f9e9a34ea8e5b180bf67371f1f0ed67861db417479947b7eae6bf4c59e78da82b7075caa4793bed51ac4395bc504626b3e991d860a500d0cf446c65c1c72496325aa56f5fce9a72fe9571e3f6e58f4a9073c7d11d24a1668fd7a92a4cd7f22221184223297b60a74e05acce8e4798e8a6cc86ee9519c984e9daebb83d8f141f5af8035fb9062463576eda329f1c5e1413304eab4a980cb604e410b3ad099faf95d3e3172939f72d114d44cf0e34b64baf41e870918d3bb38e2f0f5d2fa857695e0b17c3b5b494833ed5916450d0837154717569becd568e34ee76be0b8919927e204632976c3c30330bcd5ba07a63a21fb7f9f9f5edbbb632e4aac928bcbb6748597e6f05280fadaa74937f2449c9adc71f366cbb8cce91979b629759c9fbfb2d975f7ebe9cb296d862a0eef688d55bb543d28c209dc7360604357e7a3dfa69e54a6e04dbe7babf165a69c327ca8da343f3ced6c2f44c67522457b981c6c88d387b0385caa0bf2f28d37fdaca9351cd330e54cdb084fa2b67acdccbb798b219b5167e0a1685e05053f179e1b0e4b6531d0d67f8c857e1964948aeeef79125c2853ec74d9f56f4851a739a666f44614bde0fd70355d0c24410c14b7ea59719f1412ef35d6df9f354c85120c0e70e15aee0c8b006a8a0d01193d8a5d17aabfe16daf124596017ab3e0b68c288601b5889bbb84fecb49f7c5fb21e49993a1c83c2d3d934e11d4fd1097adffaa25621f4a225e42b41b1c624f6224c7dd842631a4d3ef3dd60b211f97c96288d929671bec8d09a92595bebf6ced00a3cabb3c7f85d9fa392ae06108eabf30b631b44e8c05d483bb0c6123e14ee0ef1b44f774dce454eb6e022689bcc21cf097791c8ac16ded8466312330f22ead5d2835661f753ddd41e67c6e8b6acba24a83d0f84cfefba244c4a7bbe38e506e1e13e020c0b1ba646989562f18e0f9113cc0f0f538d1c64302efdaeeb6b372f724b6a313e585677e83b1100cba988bbef313de1c93f5054b24f7d2ce05b27a380ebe9b6a2aee1e595136124e775d15e4d7599423cb12b2cd1a1867909ddc760285797f70da04aba91864f788c6d85cb6be3e748834f6ce50584fc760c9877ff822aae06d4e232c8f379b56221c80a6cc1ab254e4963cf3be212d02099bfb334ca43468c2e20b39ec91445afacfa5cbad9d1cbb43fee4f7486fd722d39ea5c4e080128e6c206d35033b852f99b11e3e22156491dc4603c97d7a4a5be7e8c63d05e2f31f77844d9062a7476a48bd45f48b85d0f60bff5c4714133b27e3e18284704bd040a058b5a22ad65d5fba95ba8646171b027e200e9b44c904c1bb9fb6b35e8d748d5c683d0b3c8136452cf1cee5dc2f1ef4b7ee2e904f5300c4f811c0b1c805f06fca6942755c17e0bc2329b96cf57e067482535efc609c00d3e8fdc1139ec831652d6d0b281f31a033dbf69862870272c123b89195c90c3efcc772fdb8346e59fdf577ba2383245608def07b8e35c42d189705196350fa79993409e437e5bbe6724da07f254aa22cc4f37a5749dcc83bdffb4dcaafd0e6a31a2f9e97aebbfae97ad10af4d0335087ec2bd4cc467313189210207d53403a2c794ac8d3c4760db8ce02019d60a78b502a10835fdeffb51fabfc501283e1ee6a61ecf5e7b87c3ebd4310601cf163eac6bdc465362d3e229a075967656cf35c69925d8c39b740866243694a0e08d1488c7cee20d35b71d116ef9a203b97b9f7ef9304a1fcf763cf60c8168bd4c8a4209d2a8ce29ff1870655d19d718691a66f66b95579c39bc6515f27b455a8de7b4e481ba0c5cfbd60ae387c83b24b036e151e685504a73e338c41e5ae520946a0acdd9b1f24654cc5914405567ded85326ccf5e40161c8e6a1e1685658a977c62d76a5f3aeffd037f5371e2d7f89feac91d7dc5c5056a43978e2c5becd08ff683e9fe85d3f6a79bd0ff24b9290e861afa1b2eef3696751ec10f24edd227a42ee950e6271a77fbc95b0ef22cef136f805e21de9d4525bb403f09531d800c3ea7193589ef5944eb7afdab246b60319a9c0543c03029e0d6c781272279c3fbbcb9bf84942c776421e28a2c037b606ca3c0175fdbebd8269413e3edf1ad15a4dce88ec54b45d9d476734f48031a0b313c3256dd1240c5f0d3be017530ad19f859e6638bdecda6cdf1240c44cb0f530df27e3008c9637d41c682407513086d0a85ed7a543c6c23cba1b985202c018406e05943a797c0b55569c4ea68ac546371dfd66711533cc3722a4dce823447edbbe2d8aa34884ed4029c5d8a882b0912f854917c172d1ae639c7d6e6d107f2b17f4abc25db5337bbbda9b668740aa7f3a865205471a6452c70ad9dedeeb1e076c516ec1e02338b357349acbfdcbc83c7990abf7a554de41d3f3e14596dc9037ac7d3d2858b1906b778f77883550d7cdcdce031ffb7ebd2bc44912b2ae626b038198e14570a262ea7606dd0a4ed9fb8b4bff5d01fa093bc6014e92721814bb9c8f68fe006c41642cae8df4ad60f681043152243ef2bf80f532a66e472762082200f3a6c442f96f1561ef78785301d2717f9e33befd17ed643c9a55ab7a18bde75f69af825129acbec9263ef41b7914c418f58394989df18b9dcf12698bd4027d31a301c76edacec741e0139bf458cc31708c41cc3f0dd4f194dcfdf54455b903e21614dd0f3d30431b4a6e45c5ead4468ffd9b39763138582596f385cc9f98abeea472d067d93147ef20500c2c85cf5f12f324d6a1c4a098d80674f159c2c9d1c0dcc50a32d2c93447b0c65cc2e548ad4771f9a0248546409db0fcfaca6e2c3024335bba8905b615760ee0711cae4624ebc3fe101e63c0f2a1910d638f8a852af8d5f9f4ee4db25649c5e2d2f266cffb91e0e8ffd13a95b41eadf3a537ee74f91d0d326b9ce6552c937e28ff174bd8b2b54877516b051042ee396391a0f6bff2c358e1f671f9e1ec0254361e3621925a5bf4e009d8a74a2ebf824038def8dedf42d80d76853ca502d43ea919d2f787f6e68853881effd0e1b378d2ae4f1321b2c69b5734f0a97a2171720a47648e52d920722b2fa4033e49e83d7e4c26bc6f852db0c533085511e7d3ce78b12211fffb7a13349a9531a0cc101bf38388a84d88eb00ce1cc2f53fd0b716b960673e7ae7728083202b2e94484c8b185a53da980824d61cfbca088b5d33747f40f200d52d84c2e73ead74fdcdbac5efd8f0231686c189efedd9ee1df4fe2796bb8e567b6145eac8c264b170eb8394905ca740ecd74ab3ca50180c35c5fa1654ebd131da260d98d412430d3f09afce8dba5e14ab70a503a07dd79c5daffbefabd998efa3f2e29784305260a912fbd50324e1fdd9b9ea13f03f19ea03c7ee0f0ba4fba18873018a63defcc986826cdcd6ac02700fea89d4f3078baa1d61fac59871ef21caf888f3e531851836b2b148f7d90272b22ae83e576ab7b079acb609346d5065992e864ee64b6d24fd5d506293308a95d13bbe0068006cfa5b0ca272befcadb29f84469fc3be942db83c970d7906f384c6cae9413d32917be9599ed18d7d24c64d98c68911e48b97c635f50456c513a241ed30403a341aaf1626f91bf3c577112e262ab244ce984f01035547a8625a37e8ba7b7bf17c98b76893489795cfe2b6d79a2571455ac19bc9b1e3d6251edba52c8180e70cc2a91f3b6ee637e83c7a5edbfa9517da45478cc3e84852d9479d5dcdba1c336003d34de2fad611e76ca25199bc48cb24e11b08016564bf5b75d9056515071a96526ca07e3b9d095febe8a12646d5a2a9a706c06548efdc867b3c335436e7c5c2ac9ff49b1bf1fbb73e1d56c5612da84065604dabb707fd7b205be8fec3c3a19cf6bf71500fb0e33ec507bfef55c84ab18501717f3020e4f81412783606bc0a34816e17ae6956e527e589607a0cc34ddea4b2d0739e6755fa8e85ac5f5f68d310ead20495f617f389893794042f05566ccf142f735d98bb2758c5f6c0b55a317ddb1c6dc6ba466bb516130f2e7ee99f05c04ff2a1d7fd2926b5af1e11f4e84f1acce333cd6a98c8638791028a0abd3c08255f53fff1fbbaccbc1c7d8cbbc1398b8718a7b28674f100c4dfc6859f977313c070c7c60203f00c0f0dd0811a32c79019ec65cbe7df7711af436a9c69ee419fe16e189d040fb320e9c4bc49684bc27cc453c45e62849b6b05050c47f09e643477e424937dc25611f3eadfbd35a77b9f65734639e6544c26761ea28beb404406cd14a7de48aafe6258851cc460c2afe8cc4075a01d38dda2e75e598eb09b66e46891c86339ede1572935569416e60c0947f13f66ee510378acff816955747c8e2e8ee6be3eb13a9a0be8d5548df86ef0856847f71096ddb0d08d02ea8d2eb19825a91a46f9d69ce361eff14e5da9b5144aabbaa8d80785cc6b0887419d358396cb1c1042f022dad369a4fe8d84b3c8a0941f90b92e7d8e360c9e981684f023d1a192b87c985568d101a420d023d3a9a40d9a96df46c85342adf40046ce1fe1012ce76a9ae6e2a337a709dcd032d81076e63892e4d72b84e8e54cf4ef9e1a298e487f80df07af836275d67b235c72f7de60b42284d518abeb9830231ff81ff0f4a27ef0a34088d8627679639f2c2e755128e793174a602bf33e04706c9c4fe3cecf2502bbdf90de00b3197e32d6af6d30aa5b032a1da666350aaf3dfc69893bbabe68646b299ded1af6302b69f7d4c03d84b542d288ce24cb8855000fc3611f9f5abb2bca7dec0fa882a1dc339a1a2eb26f9fa846f6fcaa7950f5c95bb44bef2ce67d3ee7771318c1ef7960849a3341e01700a50218a3593c0107920c79430b83283f40f2baf5de21c3687ff0227df461a937c994fb2511634f712802de890ce114347fd08e48844e63952ba2e4f5e6b5a0915c3da90c425ca7a8a561516a7c402d8931ec7751cf32354cf3549c1b5f3d1e14203081e5e9bad282fc644feb27c12e17b5a038ea0fa97e5bbbdfb780d019771c2261f782f93fc72f6c35bebd952ea7692e87515cb9e07e952ae3efb1025f4a9d8942cb0a7ede34b2c170d6da07a91246f246958a94791394d8fca30fe68f7694d22a44e45ebf34961452e21a05007c7530e5976f8f6c866187b34563b17cf6e463c355c75023b369e0dc83af2c4c59d9cb62f876e93600404c2a06156985d4c10b5ffad407955441e1658829fad51a2d005648c363b76525645c192ad362aa62f4e30034305fc7fbd0b915b297841419996e64eafff7c2a380e7a0c3e5f899a9e4be1f5fbb1fb1228b81f892ba5e6d30b5b8ae5398686bd6566c24f95d0981aff7865de7a54e97966241935e56ccb05d26d523de0c15586097d55ef30d98596d673099ae4ef0d2f02171ac57169e27ae4dc158f30455e89bb4f252c79a1f28ab91ea6d1c7fd21d7000c89f54d2687ecab68674e094aae4172c7e47ee7789b0ac1644dfd4af3a18f03e28b6a28fb95dff44363ecdc2423e8a88b6d516da4a0316e82094f5bcb0a0bc5358f9ef83c323b268d66e0e208d685658ce4c86a4f8e688bb7988f77f1644d1a8c244bfa235bf55bd4427a8424930162daf23944a270400877911af021b468136f55aa1d2bd2efae95c32f196b1bdf4f88264191817fca2106103c816c0259ce547062f8b0582fdaa8ddbe0b4611dc1308932b72edc020e6d7233b5864d8c840ec3889782b982a733a5a9073a94a83ef5cedfca547d2c26315bae083b758b8c3463931af76e4c1c88a9cbe6040aa786fc651d0c3e5eccf96edcacae62005a518b1f0dd655db6c10d91c90c6d458d8346f09b86c9882065495b437918ca96ed683b53a48d5a7435564d090b9ebd84f8aa041410e2b1d4b2d74da78f6d62ad05558ecbe0b27ace2849747fbb33ac770360fdf01dc89a7010ad59055bf7eac9522ce44214b63113ef7f4af63054b524df897d0eb877cee2be5c687ab7ee6ec62c6333b1d0550776287f4cfe61215a78ade10466a09982a78e482a74cb0f133bdf9e0a41b426859fa85b3df3a4a6295359929125d3d96f1a27ab681ce1b4c88d8a1b2edc8cbfd3a3dae31a98c11c8e5c0a4218a489c6273bf965a1860c2825b2e2da082f4a8b913f423b31fd78eb1a3cc21e95afb7fca429b33c16a8bea5dc88c44f377cc0742cbf1839b06ef0cf3ddf5904c2f9f82643d1deee7a4434b3465ad4d260624151725f98f5e20598a94de2978de3f760000edb0aa7b8b75bea090e4ab0e4377422376873fa49b9cbdeb18d38b646c36939a0736fd40049ccad9534eca7b4637813c6869c9fbbb0bcfe34937410589137320a48756490fc0a7eed7dc3203600c49b161b45482036272b336d8ddf661ded0e4680738bc03b4db45315e04c5b3f12252d8ad072b455c2322e52822d428ae77adb6f3e812a4cdad1975f151429cc0e50586cd6b228b4522f7562d743551e6da27497140160a8ff598a367a4657a7ffdf6411e3b12c5c601921950c804f87777744b7b022628d103c9b9fb02c08f046e4f8be636c387a84313ea902a5c4d480f4ef08dd09f46449212c352dadf4c0cd691c5834c8f9de0d452780273ce3428a0e4767c592634ec585c5f32fe65b09ff7b469b09f584b5fab9d8d484f44f3a79c5b1f72ec718ebfab0187d3e646870c4936b4fa7c9503e600a85a522b5894683ef7e93b9eec9b3929c5e8a5152936fe9ffc9532bb13a1faa47adb19b1c02717b494216bdff71f8a4088ab27cb12b0a09a8108c472bec6baaa5f7b48f436de1b3f70f6de87e4441ddb32d3e91d33b5bdf9460c6eb7f2172cc907ba3b5a413388f5b9b5066eff329bda64ec56303c9c8edc9172512b346cc74c4a3b256e825a5c619dd7b26f3012eaae5e293d020c1e5735df144593599b75a13fbfebf8a95f74736dd4e728b116aa381d5ded61832922c6a816b37ffd219314aaffa598b298b85e53aae8f1a3b05d4cc36b3191ccd15bcb48f98a1d8494175db3c79e5cbff1eaeb789ecf2234c8f991f228d0f3e7abbf0cad96d689da25427121cf201bcda6496d64ac2f84139aca618bd231c8735458d9282af984459cb333fbfeae3501597ffab35ac2c45df56920ea0551ef3df7501dfe2168ac60966ac5861c511a3cc8560ac0109830f4d770961c1067f60b6b0c8d1414921f0660629b42c01bbd77cc1cf860a60e043d0f6cfc0aadbb3933db7f414fc18889f41281efd1c76f0693f35fc60e01269e69692c3179d20469f3b93cc7c005f95f81d9cd659c96d6c43df51313ebf733ab1bab488734b5cb410689dfe083d2f3814763005d8fc653b34d1a9a186cf9d81d7cad0d5a4e05ecfaed0a73ee2424705bf8ea50c26bf15a323f8d27723fdafe0683612365eae51ccb4f6ae9509df4bdcf59d8fa213f088a191db45e8c807d6cfe91d68be6447077dde9a4c96f41320db293f1a45996dfebcaba2e4da6671b209ce150223a3706dc2db6ace7f8777a7a4dd55ffa157ac89c828eeb736070792e6d4b9c2521aef6fbb429a04586d74c9814ee9408333abe411f558d6e824c4343d4c7c94d44b1f2ea7b7926b223cd4cd69706f61a4ec8cca0b6f782a405a0add653c0185f32cdec746a211470cd8d93a5e49b3a605c9e0669d9e8b54af3af47fe5dc8dc3ccffb6c0bd89310e7d7dbbe3d41da9879569411b9af839837e9ca67dd169ee18ec8e51865fe658e805bc06385449056faf41ea6768ac1020194c23562551a526c2fd435c2a5cc18c2f111e0ce5599535c3d77b6d5e32a00718641c6fef3aaddabda1feea0c0cb08ae8d79fb1f0cfa9814d4f2f913cc7cfa65d554dfd23708db7a26a8188378d06e5f7b20620068cd588fbfd3643d7454c67e01a8b9e322fd740de2715551b8a819e15554c4dcd606a1290652a1b1c8a18d57d6b17905ad9dcea25296d3146a6cfb07c28a1ee9ed20c9b221fff0ae20c4ff6767226f411e8ed92e5af5a1f7e49a74035a0173605695cc60a87f769b46413679c9cfab0633c3fca1d226c490fe5819e0e1b6451f8d5a066553134b80c3ed18551388d4b591801ea830fd618e74e6b5b560a1fd1668722114bc0fc2c159fc4494bc76f6ab2e1141b79893b46cb1cd4cd5bfd18440da5eb37966c2db1058d79892b03931ca4ff497981cdf26743f27195b0255e9fe0699a9e8ace04018337ac8835ba435e6b34d8088ba5eafd477ade1bc1407aef519cf6fcdd7f081b348ea67f5d78ebb1de3ec177961f840982ce6798cb0a448576daf199042c466674c8d3e6b5858166ab7b83401cf23466f443af806c395e8dca0576bf117b2d24cd62656a297fb11fec4cf9c683b5c5efb2e2e107f044fac853da33feb2fddad13a13ee43b5406310d4074fee1b6c2de1848e13c7e076e0a4ee6f90a1d1712cafbbb3faae14ed78750abe349e08db287bad5b2a07c8b313ca6617272cda922050cbbe9f167f77aa4b5dd00a9ed5acc491562e9d6fb055c4901cee291be7fa9428eabd6519f3c0c4ceac9e082eaa6c4c16d20a023f16d757b05209da26407a4ac5376993730f249b3b03b4dabcf3117f14654067e3ce55d77384d6c2444b7ce1a8732c9f91aff0240f410739ff80e49fc5f2f1c793fc3473d7a004de5c0bccd811fc32d0a95acc9fb08051fdebe9f499493c30aabe7c3d5f5efb7a1bc72d61cfcc5bc49884e99f845014bede7d34a0c18cb86e70333b055121d50ba8d73200928be33cdd4577d8e84d303db86b2dcdd62c5db01a5f174de96db66a37f10ee3344185220cc62a0a696ae4c71a4300195a9d9e2ff04ddca50c34d132ad89e7a58b8f8e4469770b7086132ffcc4cf7e5de163fff40bb52fc2d6f4706d8567c9a811c28e610a81146085c3b02b4a1b42dd4dd5b9a7d40662f754f7da85146009247bf54e33cac1a70615180b5dd80c2c95cfe5bd8d400e41b782c457edd889b37b5326b09f3309baf93c64005b55b5e02af8e436e96fb974847b297a09727cae57e6ad889b7beafd4dbb3de39e34ec9cdf4bbaa1371fa45b1bcb24ef15c71bd7e6db13bfb8400e0d697bc507a95102b97d65d113cf449ee89ff563acde833617d4ff9051f618248b919a6828b83172f24256b604d7962c784acbe2a06e9674dd6b41eef29f921205031999602395fcc0158c0928dd9d0ff3b84937159429d620dc019e24ec79a773656108043b92097d5d20aa5525fba139d3b4a739aeedf524ebd2650718c53fb51e99232d89c817f9a91ecbc8dbccd5dfed1fdbee64bb0abf66c0024c331c537ee84a5cfa196b54e501e23727077df427b538a63944b5552feb9d393c7fd53ca7088c43b9fa8de1228ee512c5a8dafbcc9a8e009a8f7ab51efe4061f8ea7e838bb6593887d1a9f2beca2d9df4fa512b5ab702fa936f57f5ac3ea0c7134db75d80d7e6ea17f0b14183f37437fb2543f32123876414288c6682b9dae6be22381d46ce3f4c7842c8735604d84c8702062c27b15ede79329f54fd8c8a0ca8204be9ba31ff42d3cf4aae744cd3e24ec9c7e0467111cb4d7cd484241fa1b4cb36ed680a3dbd35f956ba2ac388fd4cb6eb4d4a9cc547524d8d9d7a274c0016fa33711a6086327059137fcfb48a84d69b12b18131280dfe6a12cf3a044d5f21aba25fe8fb5bbdf7bdeac69aae1d0ee9318296ec7867c1a74dd41ac8f2e34d4116b74129b034586f74b5bef3213a4c5b1aa39ec3021e2593bd19b0ae12483b081d422a8f4cf63774b12537dd2a29aa72e1075765511e52c98a04595c58f38f3adf085f2aaf3390c0e9d3667c6ab2f26ae67ac3a7f93b54888d559a5333524d9ec5665738bc2bf5101d85ba32a1d3b4066dcaa5604c433364af073e5ff7748004c52d78b38216a926876276318586a3383f42d7d67e84207a1dfc7591ca0a9d3a0be34b4eff3bd9533755a5a5e9c6deedbed7bc59fa76b731fe9e16b7731e885825cb1be25d786b3206130fc2946c1b8135faed30d3ea9032a14acea8d09bc0c5ad6e8f87ff7e7e58458c234473dbff2d9e2b3fef15b129dd6de400a1f23a3860de88a37e2739627fb5324f015d2c71e1874a2e33bfe9dcf04a768cba4132397fb1fe4c3b42990399bf8f35591117a5a192d97e98a4895d3234f2418a71c10f2a082f578f5f31d262dff50e66ca99f1c416436bc5f517e8c700d8a0f876b6c5b051c27b1eae44f8b78c04109990ee7af1d8b562d811e991561b0ed03889d8836010d8098460cd5ec2cb3a0fad1d892934f2f6ba177e8a7d85017be61d9e4ce576b27e2173a06ca66c81eb90b0b1a611bdee5610a26d6ec0830b101dba7ba8790c0a0192ecf8b0440c84e669079d25cd3dac8437ca453965244f7b06c421aad95a20865217c725f119aa044c70b444ada7303e570f1a94572f19a377f502b845920ba78b6a767e02d60be344ac6ffebbf820aa679b45654c7c3a218c1f8c1eb1949a67e64a472d73895de573432135ff2fff6a864f9b641203c7c3358830aa6863b4b7f92a1c19851401b1084cfaee57891390a9e53b2442e5bc0db1ecfbbc5322f753d3b76f8d98cf573e058aff29609c33b8eadcd32bd5e7f31b5380c0dc25d6cf54ee39d5cae319d0ecb67893e8a222452d7a1b62603d2b7e68955f3de746d6f693360b69fef762c8fa380ab66f25c582697f4bd218b69498e5e61f3acb30387cea073b1ef0b59f83feea634141067c5acc31ca477bf201be3d186d7f39e69cb5d635fb2798a52a38768167fa8ef50101911cfafa52cdd3c377250cb9888204734f489f971c04bfc76265fd78f7fea34de9e1ff90c3d51af7b87e4c03f24d950e5e5567264d7ff3747d92a726391ce2a30b330dbe6fe75f8bc01381781a7a886173cc168a272751ca2505df25e256763bd498e0b7df4793324ddad81d491f1570ccff35344b87af4915437cc5f8e5e48cecda87f7d8571c42075bfcc95e9af43ad9a8af3cc1366e2ffe0a41adaea4000bc2f793a956531d7342b22baa054cdd380312508c6a1d71c35060ee9a01a1642cba58412ef622a91336160944a9632bbdb629aef72d34941d64903c27f15eec89f9689f258d6b71408dfc3be0b7bb47037326903a8fecb5e91c7e303818502012c254b9a7c370266f4101b73596db99d80eea71fc46910d824b371025ed340c5f3466c3c7afee320bb875a3828326321dfb24fcb28c25f903ad3b09bcd08743b9c1cd8c1b832a435c46efc547f1c85b57d3ef5577b2069dd427779194e3ce263c34bcc5e01342148f2a275a522abf2a7995ea5fb59addbabaddfcf67c71bb0c61a573e041aaf7e76de64febbf0e3efd69d11fbd45dc9665f3b60220bfc497135c36277165a68ae1557d569e50def114f029e45c209080152d5440b0371e1213609921bf17abe17c47414667a12711c8d792fd4a5686ad1bd18d516e124df1e45d6161a346a914bbc3263c9d96bc6506c98edf73fddbe65524276ed6e840271d4dfe349cc8d9c11c47597ead8afd84bff517312ad38bda63bb6f9a51499c698f01a81678935a684a270ae2a1634d94d2cc5a1c6772aee00055d2f555ae52b623edbfc430f3642cabdf5f7b2e8aaed1ddff0a7a6ccd6dce583410c1760f4f511020534b652e96b42a95154ed9d73b6f4e48e3986fd34ae2dad5a00d2cbf7b23865602c3c1c7fb01167240ecaef073697fcf269ae7e3c6d4d8baad35fa40c6f804643cc4a38337f92f45927b26260c1bb48bd944cc830a69dd00407fcc6b8c34aa43d5d63267ea86c56f0ee74fed6d875b527a711d554a86fd71f860d8b5cabd3134adf82bec9797c1a396c120600e40f9f7a8677d71c44dc651bc2ac784cacbe71460928541ed06b7f4b719f1b98b7142d073efc0df65259d0cef17ebf208f9bc6bba916aa5a1a5dcc2a45e455bff49635cdf1b2eec19698009edf6017ac2c391455a0a112329ba2cc606485b92c4e9139cd151f9aa567b2ade721ecc5b687fe73fd1233a2d5b53c0cb6ea076f4dcd805907060d646397a1af4ab2dd8ccad84e6206fb8830bee92b557df472c8ae5508af42b6caf7993648a186c5637d16fce549be0be941d35168454aae679b2b72e3d5e1963052ba42d9b170647ca35f67c2e85ca724831c058ec4ddff6d62e942a0f1b025abb7685c24f5d092af4187d0f0253fc2fb340534d6c0546d29a78be3e8a34e34db11b987bf3d84b54389c8a1fb09df40b208097508228cea8550e728104601feb5319bb1ec33f2277bb7d0fd093864a47da3923e5a4962d3f5cac880573482a9df8598f66abf62fdae428da432ca1ef4a0d5ba5f1ea8684311b4fb6b2c4ee74f9e1147658776baac12055ebf112ce9accdb13866984b382f5de466ed3b7b50abf44c5dbf8fff0a27a20595a387c39ea2cd8d5d482aa5571b687a4b8e549b46f143e27a7f57b2b17e26d6a57f2613e5c1d97c40fce29e22a29640e80e6343746b2b15580e35b98c7c0a1eb931014d972a2391cc48a65e4da7a31459500435f985f6ab97b17fa87a0f432bb2e585392ba8c283f98d2135e91cd5417199b1436b9672b3752e0fe5679db5b5b97b76f46c94124eabac320fbd90b5d6aad261762522ab63bb125af052f219d90895a75acca0ce2749e14d196cef3fbe01cee51d99263a2063bc2347091d9616dfcc3d95ee76d252a2f39f05812fa78fc2e9480ceaf64ad1c66a52a822634dd9d7d39486456cdbe0109754f298c0d3dd217b9c60f73b7544067149eff5de92bff2efff0a7f6203c4f8a8bd32195fa1660fee62f3ce0257c775e48c8dfa4969282f5a7b55cdcd6a6bf50141d7aba9bc438106ee1221617a043df41cc3a9ed3e16d403bb94b992cd55a67cc5e937fcbb68bb984808346a6b915524532ddd68f22b17794dd8be90f0c424a6fc2fb36667c8807d0e2be5ba6c643ffbb902826e58b4a85a937e8bc93c1f8d28a511c288ef325c34fcebe356ce1eb821d2ab6b96656cf94ef52207502b30768a4cd5f9462233677c89ecfc1d55289f116bdf083b9c184eb78bc5076548867c1124a38d021264bdaa5d1b227f77d236e4cc36258bd9f817200ef9c30b8a83505edfc875e9198428a1abff5cc548f706399bf417092f5417cd1aab7fb994927db4422ee2fd01c1a250450beb27e11737102a410b5c4b8fe3fba48fe9fa0e07480746c02756a0208afa3d6131049cd9b3db05dc8a79ccae3a42986b7912f59a0f94a4c1a7a6da281a38266949fe30e422fd81ec164f66a4e018d796b6811b99f84f1c5b87129fc616edea0a2c86bc837d5ba318ad7c528526c63a52524033a059f49ba77f32f7dbdcdb31f1fa8ba64d24b662ef5fe4174034ab57e341520c122b2a0fa114816bbccde1f3c17050975488cba9ff328678a19f13e9ee44b90ff76a7cc18531d8594ea737017b7f669852ab3beb999f8e944a19c81f18fd389a6fe966cbe6c6bf02f0a514fbb62625bdcf294407c1b4898115c9a9232452f5ab70a038857bd3e2b8f720002f139186729ff3a14f1d2d8cbe1751df841d27c91ebac9ba10dd3dec90056837f6d9d9afcaa3ca11eba875b6c77890fc2a2faf76206b12a4ddbded4b9ce7c613d5b97a68b79f37a0d38e012779a98937e1044fbc3a78a9978f628b48506f7b67368682273a07f2ebe7aa2bfa958e6755b7324f099808092338ec406c03c3745c10d79ad0f00482adefd1be936406a443c47deb8582f5f5f273d57f0137167f0ac6d5ca1ff135dcd4f1462637d3e09668df343b9ab50582e1a4f5d22ba0119987b596ca56579d6c940823f95bc3637dbe9514e83ae590b1984ef40ab84a012b106dedb0f74f8eb4195ebcfd7db5002b60544d38039538682e7e15e9695a6000693dcef5e585fca596578710ef902ad88a9c7dcdf06818b0907fe1f3cc91de5ef88994d6d7515770a52bf4aea889cc7c8484e90cae98983f481fef63ed9f7fc0e24d5cebeaf4a8e9e1166f8b9580d66e2017cf9f68f649dbef01d1357f43c5e554cac92ba7d3047c402434635619faf972deabcd4b6ae0d42202e32bb706ea0a851d309b6b01371717f2e57e37c147df4b08804f16ce1eeae6595a77c768af333b72b698c3a51eeaeef3b36b9c9bef9ee7a2877927d11a5d203e4c3104cc172d082beb37988501ffbc62bc36767afe57bd7407a0e304a4030a4ae910ae89c9f1d6c9e0eb6e03d72df1688038538aa1f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
