<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0266fb64f33e1e40d12f01335934235400343e4d37f863269b916fcdd5f12b1f2ed45ebbe058c7dbce742b338e65011f12702da6a0cb9c31b58e481bb6e817d77261d5524e798b9cb83939113c03f612ec98f92f840a8f21d9edd4f24953856b7a96972fe9c9cc7ab258e1bc6fb70454c76a27e935a8b335a931dc25eb2a354f6c525bb17aec79f81997874152d5938233d8abfc1142ec6e95a4222fc6ad5df84e74682971f401153f84cacb8c1d074a995a9ed619c699af9d93bd02b44e3e7e03c46202198b6f65ce6f0d16a391b192dae4ef0a78bd175223f3c37e03ec945b6d91a3553d82dda0708bb65ed55f4452c54231d5d9544af0fc88cd0f756aff76c0f60f440006b15ccc94738ae4f62598a7feafee652a1dd463047498e10149bd0d9b04c7692da2ce71b964c8b6e62d20b876b12ed51f81304c6c4082ab27e37d1dba737a154f571493420f29442621325f99c41896937a3b3511976fd1d5e14c2f0253588e4957ee577db7961c87e5f1d17c594016e23a575a5b50a1e67a98c238688eb2fe35e693c4f7a422a5494b5b081c5d1ce84ffb067f0ff82fe028f96a963d0fc69417db8b774c5c29382e9f000613a60b93702b8406de94a33e979a0c705d2d5242dc732510b031ea9fd31d982fd240081bfd7755b4ac6c82f6aa8d3f8b6c34c34011e8a8d19494f6fdcfaaa1bd505a598d75d811a6a2311851e001b3bdad58bf4992480382f9238be9b063cc6db74e06e53cb426ea8195d41cab145f39010b735dd1ec0df00deb69eb4256892a2b4df16245415e867860bc962052582eadaa477c15f5cd90d7613b52aaace613acaad479b4da3d45c5e3082d8a55c47b4c50ac3ccabfca2d0069c0a852245826ddb4ce45f35aff6f22630484c7f8a4b5fcc0535dfef098c5593b694e263b80852d2b34cd9264e8b16b91c9e66b75c86bd6773603c0743170cc529451f005a72cb368e83c36848ae695338cd459812019f81565559e1df4d57af4fd198fdb13df43821936f7f6e0a2d281aef296d2155adbbe66e661a46922241cf9083433ec09a7adf3e290bf4a564f25433580027fb20428e2e6fc7001b88b0f1c7205a8e6c3ea3f0188d0b00f7efb3163428dd49ded3bf6c0d03836fa852a8edc710daf203769a032ed70042d16a2591ba37009393ee05815aaadb343ad5a96ea7818e79def34b91c09015a2e6d067b8e38f45be827bb3025859e7004ddacb36fdade8585c10131768290d069cc41611fc99fe33c2ccf81a73f671b31b4f0554c3439088432d091b1eeb8a39ec2662bb80d3fdb41d5b8bd3e576df98e55865c0caa839922cbcd5fb857528d176e13b65d299db1162f5d95341e9245964f958b13b428f17fe6b1e617cc34b2a6b227d548a098314a79b5020d6fc388f760188fbfced12d1c16bdeb2cf12533cc0e0e31591e3f09c2083b5e4c3612d97d16afaf3c40dc91f82a0b0be771b590de5e38596142524b4afe34a47306159ff5d5f755e6546451d3e63d882bb9bd0611d4be4b0d572b6ce3c0a23b16ce1001134c5327cf2cc7cb06d4cd1453771d4b9606617f82ca3b391aae7ba493d435e686f54bf961f4a951e46ae4f5c00b1ae662c8ef82390fad66995c019af2df26aa02a27211cb1bba96305f395a402cf665e05fb6b8cd44486bd7796e66c48eee5086cb8fc3ba5687e1997a02db4cf1db9747ca5834e7951f429c50256b55888645ae0bf2708bb668d3b39a6a6c0e87d6570c7beee7e84eaf5c79f70fadcc7622de03a2d90280e43e466ef0afb6607a0d498ef013f99c2a689203ec35668b06cb1dee9d14ae4c6809202b52b4c022936905f1d4e6a7deee74e3fc9a98d6a89dd7e2b97da0e4806f231de8bf0c9b2f69da7e9bf0321350e752d05618c76f11de8c5ad8b937e14e4cd9f6c1ea149c60e5f0261ae8d1e482792c3a5dc4d387d88ad2ad5dbffc0e9a70d435bf89e64b9ecc16a0cc5ea2c65e3d19000a394dc32685b3ab2a378e5fe860e68089de553aaf83658ba6db93771d4f7d754baf8bbf33efdca774ef703bb359baa89ee189434e947feb29939f22178dd11e0f141419d4500517306de34ac550162a8a029650176233d35304a5bede3bf6e61017c848c7d73e92066a6926704cb1b9fcdda31a20bef0ab71275c28ecb1403e45d3628936d044c18fadf0b117393a1f1a065348d81d864093ccec383e08b7b251acf16187eb687796384f3781e1439d3bb342cffc76601676d1cc2fc09604b44171c03e1939a987392cf6e1c67a3838e16007a6135ac7db41e93a9e613df4cb672336334d1745e17268ff24381ffb343702818cbd93d7c23f4aabb89ff16096b8ad6309ff10994be61d13bdcfeade1ef9661d5d2499631030e8879dde41ffdb5b2b66004b15c52ee1718c379134dc75610c357b60723279a1517371dd9c17c7705ee30a50b88336f3ed5cab73618edd4430ddbf47d342357172a9474df60708d153db5de06053d8b300c02cca4ac988996f2ca25d9aec6ce053833e054f267356aa87f736caa270254779e7c75f100d5fb6225a58e70bd3ef2ee93686afc185d6b65540f584f53c93b0b4417e2c509e154c81bb6d06c1dddbd9ef81cb572871df2c262d5a8b2743946bce3c91a30f4594733e74092f807450171d23ee1d59977b36ffa02ce496ffb130b4aa19c50ae5e699248804a97e0a8607d737a29a0e11384785fa389fa6e4ba229fa60866725dc64c7fa1d45bb64f63df6e3fd2ca03c8cf130c1b5a44dfad0f23436a7efddf76babb269df1fcbf1c36299ec70b1a3abe26d9fbcb5e18f657c271e66559bb926056cb02f9836ce6dbad3fcf9da278288d5c5f541ab6f2951559e3bd224d70dd50b06dc9bc114faa0c85e721f5d8c625248b2c3512001d8374bfc725669e3d6b40a5c11cf9ba035be420a3a01109892599ffc97b41b93ae3a67ec9a5c8cd1ff5674f602a6e66543de3e037fe8b9460dbe3fb9445642d808d02eeba481d9fd080ddd609a7b75697e62da9a7738bde1f839717b2d93dbfaf2582fa06ada3f858544c1b58b24c2c5a9498ff0dc5a4ce7389665a45f22aaee34ce5de84f9fa46493c1483fcc131c0a847eaaa0e7f9db1778f0322c983391988428fd0e457c84995fa97682c400fc431a3856967eb7522aaea10acef5bdcd2c43881e02222622a2d1b9a426f769eaff2963674c072cdcb10725131aa0e0536d569706264e6cb487f8f4863ef3a59c13e5edda6c819023de33e40c48ab46804dff20f9628dd7a926f4b2d63649ba25cf19cd9a51600901d57ecbaf0323a9a5f59418673e55d780d92382b095286d38d5b787edca043570dff0c3c2f862208e167b7fe34fbb18b50abbe8a3e679c882b21b376370144a0c48995a10c9125e0d1d947f19a86c66c17a1d94c6ee6b9f1286fe0c23c8099d863c311914524087959a4c49d403d7f5e143bc5e13850be3ac745fb168fb2c43530b4bde68c75649646f313c2626fb424e4da451b313934945713342b95978734ae410ad1bf1692186bb6b3788600d19b6b36718dd7e242d5f9c8c44d8a5bc01758eb993fc4d2cbf3ca086a4c6ddcab8137323d56b0391b862bd429bb82c6120b89381891116180ae6e6d22b9dfcba896ad53af4e00157f4127a7a08f4be02a28e5635a819f4d7a2e17415bc7ddaf3fb0417567ef97e8d7b77b5b55fe893a9ca466615bdde51e73963ba40a0c676c7645065ce5f8bd848b3adc6aa166c889cb876baedfa9c26031fe7f7168567a997aebf65fcb4fc68aae647d3660848c9944c245eeb5585d247087011196d0bcb69c410906cfbe4fbd3ead0fbdd5d4f7ffb4810ea121f54de8087050a35b068cd6f15f5f096ebca452e245ea1a011fee2223c81658fcc09589b5b47afa5d7ae18df869ead870b379f639be3ef9c849ec857d1320242096ee3f3b9ad08935a1a98ff345c402aaf4af19e08abb4def5c59267781ac822e166af06938c8fdc311e66195b2ddec783a226e34a6e45780767a38bdda5646012cf17107b684fcd76835230a9a7500f4065321a06fa4de3c3d07a1021944b4e5547e62c6c75ace03be30a1b4928850307a83d5859463e30bca49127f9963064e9d14437aecc1ee949370345361924db5bf26d7198e94426ec2b84dce1334d14d7fbf9323f365c7b1c1796af9958089681937a4dd878210527dad0809e9e4c2b63ba9284406db258fa7e62b3b3e42dc098218f2d4af45dd1424fdffca64b5822c0a8959b93affcb4dd1f0182bd782c3b19817e31c61ab71ed1a8e31f84990113e36fb783f7c94359b1b584b4524de2b4ea6a2e0ac2f903e494f302dbb4d51079a8bcded0c3d54ce96a23c4624f665fa57a11d2e425beaccbe06b01784da47b8d10dd81c6dadfa02f854b1ab893c3e1d37b25737d2027c5e4c249db854d0562cc50551a567d7e06c8754d4db190d7270453d3acd0550fbf5aaeb5589a8e28d1e18ade1d10fe3e7f3a58fefa065e112e2b55deb2233dbcd116395ca55aec11165f465ec1f513410a3d262775e0f2c45f718209934b574505b6fd9aceec67815bd6b7c038ae4ed9c2af63cfdc148c8740aef32994f2087dc7630b74607673b3ab49f638b443ec442a4df5362f084bdc74cd6df9c8e5c195a58b228cfaf69498cf012e8143424b9a719a0c8e484c825a2be43c982f39e80cfb7589aba50b178a0caef226d3a451c9824045c8f2c3efa14c28ce35151baf9c2806ccc4e54f829832d160a815bae582a3ccf5cafada16c5836129f2179cda681463c7601cdf41c03c85ff6b9d824d06ba89bc9265518e0ef9afb87ee6fe9a43fb05c54f07f0983d2ff7e2749745e62a39d8db8e4e4b89c8ae7baf82e1841dcec33a9859599fc9c27bae0119f66de1dcad7eae294f22eaa403bd8e117cb8206587221d0901a3a9a5d1681860d051dc2cd0fb59124ccfc334e9fcb69c10612dbe144656dca771558bced687bee4851287807351e031b09c918c89dc9850a7bf89649592a63d63f07541269c756145a58459861f30677853e63cdf96b9d3f5f4631c61be66035d35f3495914ff85869dbde56292d506158de7f637615a3f8c477bb27482d10ad59d8b9e9061f092c3de67379cb013404e2144969fdeeaba24d1218c10a86821f278c9756d22c46e840b99cf5db9c9664078fe1a870d03f56add8ee3f872fb59fdb0b106d0c47b2dc83149c8f39ae0cc24e3c61b207ca7e23ad1fd5a6b21704a99369668d16cfd6db2ad058588cdad67172384de571d5d93b27b7eaf71b8dc959cfa47178b1ad2eceb727ac2f4fe4db117879e90a83bb55042da61a7d055bab7e3b0b642dc62ea072d705d29fd4931cc65270887ab379b5c9ca962110b43f42c00832bac7de73d949bf312dde750e240334609aeb29beeeb222f68cac045396a51fa2afc7b6264fef5fd3af46c376de359e70c419192709034ebc1eee1d2d55720e7ff333efae05cf3bf70e401e18876e5ea38710c1c61eb71bf3a418a8b10381bfa995b404421c02c43be53b43f455ca26598f5f152c599af7fe95ea91a1cdb6f46c31f954cbb46ef894e15f103a88e16fcafadc9b26968419d8b5ff81c94dbbc753f388925747c21d167c3b9d30bdb5dc4f9db17639d4a874f2b356cf672be4cd5500d03291c41bcabda5529373341ddeb13da5e5859ad560dc447bb262b49ee5c90a8ad4cd58802b12109fb630770f61dd8f37da8a52c68ca534bcba6cb0fc7b7fa406cbf6f034469fa0123a9ee3c810128165affb5f45708c8259dd911345355353c17c2e1e6e2423c8bb5a776f625a7ecc0a53fc0477d9bdaf8b27b1c8a4e3de16a243092834f2a1b9be2bde05e7d1ecdec35d7f188d8792ae445203f123e65cf7d92b3f603473bcc081add948f563458e9b188a1b319595430e24d6966a98cf40466abe255d79093c717990c4769fe04d6bb80c9f46db90b3acbb11153ead66dd188af1e0e1467b7bd6220f176bc9e619fe6f59080eb8f9d4d8816e5dc9dbc3b2241b2391446c65a9fd857defe968e5a623ab9095c1e7c131dcb36fa3989df84ec9caef9a46f1cd2d689f1d0bed756f8473a733f741c456b4991967fd08d68942c11dea6ab3dbbd7d30bcad3a1f510e5ea6a29c6d95c4ccb0c4789a21f0d8cedea7cf1e9f9d508936639037ba3bf2ab34f821cee29301e6673e9b721993aed86b0de6096c45c394418189c950aee4e2aeab02eadf6093e77c29e864d80e548405d61bc6e93a5f99bd8c8546114fe369629075dee74a46b2b872e253f5334d6a95397ecd7299add985e15868f3dcb0ccfc853fe583c57f51c05b43628a89730eb7aa5c9f3d347be088dac191669454351eb537834924b24f5b19a8f210409f23d708106db487c6ed5c6485c4b262beef5e45281a9cbeddc872ac5f8517173211f2674839f83fa31d99204b797863726ee9f4294b2fe561db43eb2b4c029ac4b1a2b016933183a4ab93ae216a42d4974d08098501a5fd6edb599c7cd4595dfce4c46824ad09ec99f95bd52a6505da852b4f1e02a67033c2d80b938cfc9306029e2b3c70ce8203a6d5af87ca803ee028627afd3240515995bdfb0cb8b337b67d144bc5511889b371f7d68b4f9c3e2f501ec5f00cc7452aa8cf87a073d68ec4a281a078afb722e89461718fbc3ce26b6af1529b7f12c735b08b1cf1783a2e0bfd30f27b5e66ed8e3e73769e4f45ed6e6aa9b5d120a74dc22507186fb5cc5554ce73bbbdcb4032fb73321458460899c218ade6e8efc0faf3e80e0142f405a7741a98ead71c534f27aa91a64ad23e65b68133f4916b708234fbf3ee991f5b35170ed2265dd08e6c648aa0d6f7e71926a07d8f98950e509ac1620b933526e74a6243181eaba5e0700028f7827d33e33c472443ce498b51449125d2818a8024b0084eec65e62f7e188a1b7f36c863888ba1824c3dd834d80fe173a03e0f13f64956d4c652ce78984eb688cf10333d7c33c6cc598dc6680cdc12f3a308313ae99d58640d7c75ab1d55f3802ea5ca08d4218fc643c00a5666743ba73fab4ebcba1e5ef84f91528efad09a4ef2900a7d7980a954efcc27ae483994c4b10d21cd34b4321fb1f0850599c7038e334b2463b3df117ca006464b88b0094ed7e53a3fc02eb1649966ca2dab29b73e97b3c8cb2769c85fc3b23428df7e597130c8a603229b728faa55daff82d665477bb5dec837b5e268f338b7b133972d41eaa2da588296b08bcaff2352d1eb83adc55eddb5fcf2e0cab483c2867dcbd29df3e53eaf8cdd3987df1d5afc0286322e5b3095b8c42f480fdafd538863870780e8278b73a10b77568ada5a63a7640d6f0aaec1d84eb046cfbc172a1abff5fbd2bb8828801e9fe10181f85a11f57222bd5d7cf85e483aa4d929e964f4ca78da3052277f63d60c0b608a0c55d869e22d5f9480efe8aa59b6c46a8af07bb88a6a3e31000e3779546709616e34971c9db2f6fec04162f2ca489f9502bedbe0a4bb2ae58626b410db2b490be6c736d176afeda7eda7450700cb5ac3de4c70db0495658248f3c30776b5cacc8d9436cd505fca172e40c578f8ea470e3b9f9d9a8eb703dea8ae18276266fda53d7a09eaa130c8fe6da912eb44c2009813f7053d7e3dca0b968d38db3d651e2ce18afa56fa8fe86bfd763cdf9f98c8b7c25b6d60706e8950912fa5c75f79d4881251841d51b9719b12db88fbed2f71cb54063ccedbc5b25424df9c17d7a155de0775cb786d816e475ee25f62932bca84d6c3220df0aba04c8d2983e90bc7b4d1296041dfa03892ec4b70e64bd3ba46aaccd9a9828ba24d6bd603cb1cfbe1fd7ea26834f1a0af8c5633de040beee5d5a8e5af0a7ad3fd877007c78300878c84ccfb244bafd1c07d4f873d8ac3145b1ebba046bbb7d20604314cf100d33b316d13e3ef8c5427aeb2f9b5fc0a51d3676c86501b1493485986e402178d981ec51182584b8372489747d9187b5df341cabad99f5250b8a056536414035f765184e13f3fd89a5a61014d98d95cdb588a9c17ec7256feaf8d6c85debb2c55c22dac87c50e39e4486edaf234f000179f8399f825bd96964700004ef299e88a1a16cc465f0f4cc53827b8361e28382f6d28e3b1f73fc33187a781b08b1d4195100dea30a69cdb34151693ca9a168087f3263d9d5f7c9c35c65aef2549831d515835c8fa364b61e0d290a6a8daba425ae9c9d1c725c54a4b47641781d2009a603bc26731d38b4805561683a9f3cf291ec90a28d5066062e1d7bef0e9b6a537e429e204d9ad1a3663c73a7293964bd6e8ecc5ef617546952bc16324b4f242b8fa1d6c3e8a682bae50fd957d1a03213d238147d5a13deb85dac8b468a45dd53a35987e239550e82916a8c1019497f0e507a32baa4fb02a15d5f008b0f39ca8d3152baa41b4d53371316dee3d6a66ceb7074d87cc4a110e314764584a5529a1745babed0a54717d36829211c1c0b6a93d4cae742d656daa5b338938133b61f2064e017538ccdf6e230842106eafa022ea2e5fcc91003e5cf595dda33d34530ae6fa5c970bddc86f4c94ca72cb791b0c2e411f0a119404cc8c306e2244a0268c23e370d935940a58c170d4d96409dcb5d9b474461cf0c0108b1f65c033c1236bab60781e3aeeaf77c6a5c3d083133d98870d257b54ac4f92feb79e25a5bd54249eb1e72b3946f0224fcf4f46fe737c5e780ef210c7f29b0e10dfca3431ea405e31e481c97c07ec32d580080e70aacfd2ba610dc11dc96ac1fb534d6637c7270ce0eed7e8022937d5b291c902daa92d23bad77f4a4949e28bdf2c7afc1caa653635fc13aa41d4ea5256da0319be925ff97abe2d25a0e43830075c2d6035153016d830c0ca3bd5b5a619587830b2d4b4817d933872ff6caedf28c53c936b70489a6d26b43a45fd079d70d27ccca63f4e123e4089ed2fcfd5b536e4a2c7e51e6c02c25013f3d7fb8780e607b43ff4282ce1b3242f98ef71686734b19e9d8f61d7bc94502ef134bbd997aa2e9c059515b53ef81e73b9ebfdc625fd8e517e1715a1b8bfe1eb696a7605167b16179006a3d1b6ace3e5827755aaae880d62b1c42cf00356883678248e02b084114cc2aa4259c30c429a2536fc811bbb59f26c326cb75bd49209713c4725630e9a155335e833bd14e4017a6ac0aa9eb356fe6c3d525227a3cd7f1003d051258338f01aed88a82d112782c5eb1a0bdf329e3c30540a81877db6abad6c357aec3632c0e00fe0d9eb30ce34ae676108978eb579c1449bd66b56a4a47a6ed9873ea4df2a793e2023e4fbdc9fa4779149178127eeeed735efb96495d26c3bcbc30b8792a41198b1b151b0b088a77b0975628003e7d578073a915da93e38419c2b1a7953ff16903a684af70bd14806cbad851ac316b02f0270a5b2e5d90736bd3413bf1386d8fb153e375c34c2ebc361a5ec42fc2f56d224204f19e1cba7c695cb2d75a5a08782c61487f0257169e41f42f4325b9d453986a6bf6c9ab49983ece36ccf2b6ab50c10d5bdd9e51c57cec05d46893bb7a79eaaea5b8e95c457e5a1ccf7cdf914941beb709e740d6daaf6297e1c5b6ac27101e2219dfc2e066f0dff79d7ba0ef84d07d1c020578055f0d93595a64343c087429bbecb74a4eb6b6f26918fc83c88360ac6b4af178d94a13a8b32d1353cf8176fdbdc948aa4915abf77228d582c821b21f77f0d9c806545ef855d31dd4ae23fc470ae87870032925593839effde03d93cac6a703baed93ac603a1f34d7ff50aa91e2392686200338ff8e8247909cd3338582948769c57ff5fce9ccac5f477c38610439e7772f4ef1b790c85215573e83f704bfd5ee492f3b0d55d48a5656e422d6c46464080b5898006a995caf4cb22fa3e448918b8f7c8fbc1f1fb988ab8c7512c6d1bf46ffcc5a368117a84499eb0a71ff4aac5b2a17edde4e79e1481f82023dafbf8a2b7e670da858b8e42a9c7e1dcd9cd69bb882fe2768a920bda5aa666a4f852f7e594c853443a3ebdae25362e855b4dae61d025002957c94900454e72cb329020e0ff812433adc2140377b9fa9404acb323564a7c82fd14457cb4438c2858a9a60865dead8e39e8cfa6d5c5e0598ee88dd2832238d840c2aa7b516516528372c72ee624ff36dd03d4849d9fcb9267ef14d51d7554f7c00c44c5f017b100a48f33a9305760826bf4fe2ac112061b9cc91cc99992a965dae1f08ca804165fff59ac737821d3334ccbd0d830341a1cf7b4136dada861850c04aff8c076d514a4bfc27d258e214629be387098ae0543c5ecf56303c580dbf6b23139316392265997a35df058081a25954c6f379bff73343e440ab1e42e58ca0920cc2a12badd2aaf2d5fad91061711cc381b87f09ce7377ddf8a3364d4ea09897afcdde82c0ab822367ab26b17c56b6e2c180dd1d119d83b9ddf71380807fbc64f1aadc39a0a406e36e4b985ca12bd1909655540775f0543cf928f1e2701fb0090359b5085bf4e900d065716ed419917d43e82ab5e05ef5680f4a6017f92257f9f769709040616886c6295d64f11116ef658151efef0e4d98d8304a5704dc6065da4377c2504b0adfd772ba1c1a15e764995b04b7da509bbb6abc3183ea12c1fb40337f1cc30666c55b68df1fb0b5b1933ec093da173fa9e9048bc889f88f9dba456081aeb8750830c5575d694a4229046c752eb5f873f5962e14ca7ecbc344f97cf7ded17712c3b361d363f85a84279340c23aef28820c590d7d78dc54dacbd36fa6ec39058837ceac5a6d62b31f7e8a62303356f6d0330233eb4a78d74cd26a61aaeae0047a2e104e683131b8fab2e2f9d3a4589675a422e814728e85b09f8a1108e94bc74e906be5c519fedf1d265b69951f1f9b2e2978c7b88f11ede3a2474ce2f815fce610a57ab6c1bb3a53dd9019c053ae294f985422ac6fa5f5e7d982c52b97f1f2165b9eecb0e9b85ad71f9cb32aed0514f96a9439884e3c8325f985e118ebcdfcea1eaed37c2b10827464009dd80354f889cf4c40dc72b3497dcc48ac0f310b197c8b8373f97d7a1dc2b39685803b898b25a7b27fe5bd8ef1c0765c3b7a275d7a9786d54847b4ddf1e816fe89bf193d7b97d6d98c2c5746760b7778a42652e2e3931708112b88877592cb5f8d98866328e1282ed5699ce1781f0f2fe0e4e0f266bbb72a0e45e1dc60dbef7d37cb0c2017feaf9bab83797f9f49253f1515e67bbf4bab6dd455459a4e9d02d2e52e0d8e9b6c0f6ae014c3ea74423515ea0eed6058439c79db0c7d1664036ceb599c8e06bbbee80898b969a4675e213dea4160cb664acaa692cf0aaf464ea1531790d64525ac470dfdc39597623cc6738661e759b16dceb3a3f645cd4279ea0e61aa2c114a01cf7aaeb2b0e84cc8eb510c81fd7b5bee76550df88508cb8a36215c130eb3dd5c04fdcdb5468a883964d999ae54c26a7060b4fdc367ee89fa3ab42cb1f9c7559297c5c132b72daf9e6d84832c21b2adb24e7bfc6df49bc1d82a5c9610ea13f8ef171563edf6df5783c57cca26263136b9f101fc8d78fbae62f4c7acc39fa091c10b200b432701cbca96bbeff22317bd0c423065fa013a08083aea150759d02ed39d00cdd4fa1190f92167849758488eeabab82e472131cb7b852e4c64c55ad2ece71ab840162d602345bbb3998ca4fae97918fc51c732d57bcd0d71f6a76ce02a4ded495a95059dd375582f71cb692d283b79091f157e30fe0e9ce314024183b1d8bea646c8ec6b1f744e215f8bef8ac51fc658fe0520d4cba51d34d52d18e8ce942590910d9fd57ed3292936208cd269681cc9781598f6e4cec6c87cb0be6bb9ca4aa5e105907856b451965a23e8630a27f7d9f57d364235709c69ffc4b4435fe876883165e6a1f3794c3b9c04f0991a1d64792dd4b0e124ea5791eb756194de46f6fa85a31e9fc6177a1fe405ab90f0c538f1e846adf4108b133c0f57d58004ea891bec5ec90cb76f3f4abd4ebbe94e7083998ad080983f1f8d0447212b089235b704543a4be3bdc26034a31bd0a2a553339b757ff62d5933e794a9a79ee3eeaf475eafe84d164718342e348109073201077b15487079043bd2bbfa1ec567d3ee3512d4b2415a9ccfd97f8e67e9c763c9db2d3a1600ea2fd34920dcfe17f594089365c4fce9fa5d54e3cbb7b6c10aa2aa55a211fc425c7fa9c6500ce534efa1e9b6eea0ec47ab19c08e234d46a5ad2150b597a1e2d37f1931afb67e8224201092ea1d4f28a0988d36835095a749535be02cd6bb4129fe28a184988efe94b6e2134a60cb3c146fcde094589a8e6db6ca17cb5725ca463d526d5dc5bd967ca82b3318e2e8ee9af42f0aface35b29f5bd923642433f955da0725e72dbf884e1c2f548f352cfb266ff442d653fd4f712b9450de27591dd20d2419a1148cc4753092b9df298834320071a06b620b9320781553e852852e80e92ce3bc0e98f9b822f358ecc3fa5e8c5c954192825d9dcc45a7cc75d60f0998fe93c42f1061a69fd5b5a0ab24053cc8eab4efef63b05e76d8e9411b51d6b0f54b77f03601b51797aa86b6b392037342df17f387ca97f5ad021a4c5f095b39e6d6e4b0feab6d24b9e59116e5810bc1d62d80f8a39c791e31238eb91bbd35589ee27061081638a2253ce38c026a6e9f394c224a3e386d27908723b2fa5be8ddd0683e873f30c3242bf2681d7174fb7f793b47b99db45c19b362fd51a435e914f317bff31552cdbb5dcad268e55864a5cb02a1c974a2e6cc122bfb72c6a84e4c746079e350b0aa4a721067f1f0e7fe5d3b0c9daadb1ceb862c56f0baaa79716ff8b14971577291b7455af39d42ecc269a9969b93929b63d21616b281bd8002518e97f22856481cfc295fb5e40728efbcc9511c057f98594cff1705751e303bca269e76c2fca1911563d097e8c1f618ca5a71aa3e0fd4800ce9affdfd8016901f520a88f165bd227118a76084e9169bc0aa7c521cbc28a32bf1c2194e92d74d00e5bb31a78f1058c6242cf40fec078220b3ee4cb83afec343e2449567e24489084d044b83d0149b5addcb06ae4ecf1c4e676a43a417627d132f70f6a4a3ffcc5ff255a83f80bc051d5db8c8db2f1141517699fe9d45080855c56c72e011015285458611ce57c388839993584279228c57bfe65c453ac63c8cc4af3e5a02476b93dce71c9cb1dfa5de4ae33e3235f6014388c59e8b1fa46e02bdea3d5ce4802763f6cb035441629ba9cebe4441f5989b0940e6185fa71703d23f24b185fa49c2f9be7af4cc576ad300258e9eb0a581932310696b8d0114c36d4160b3e676fd74645c6286d5cc4e8fba86ac892b86a15e841bbd5837aa720a2211230d7561a10216c4c65b57c9b46b5e743911072539dd7327f46973305d2c248f0888c08a6253f28eaa69ec5202c3e01816a31ae4ab1b7feabd72ed95fb773dfa81196529fd636ca5deca86af99091ec1463806f6dbe67e282cc5b2beb369c4d9743b5dcd5197225145cdeab2942eeb5a7957d73264263ebe3831295e1f55a3bedabc41d036c59a6b9979d54110cb167e986e8c5330b2ccb9d7af63bc2cda15bcef4cf1012d71c804044e1d4a7a74dc3d41176018d674bee761feb5603c17a7e3e895bd90906f3ac39190dba12153b984c97f446cdd2f5d8809cab3467100bfa01a98d40960b36fa36373621e91ad9c1e851a57df56188040e1706b28f67ed2d35e6a17c4101cd0459dde4a6b265bb03ffe6bae1b30a6e3bda45d7e65ed2f089a19348305fdd6393968ff9429be7c4c79bc42705dc7a93a7decada4b7c5e8aa77043d4232a256e82e28751976fdb8ff0f940a8da88a90b994025064f74b4c84efb139ecc0293d8ca754f25fb0ddbf7c49482df97aa3ecd9e095f9f2b584e2e42e2d649da8085f1fe7eb41ef094ca02d5365ca9c354383aaea07689f79c36a2cba865c5aed72b4299734a7ac5fd8694f822374ef0c50b107c4cf72d038f23e0a2c257b9712a3590cf0ef4e27f870b0bd8b91db4780d2648d6beef9056a994506eb734517413992202f925e29f55822f4df2107fa9fd9193157f305d704181af12fc8f03fb2bde83b63327d30ca0e946078b0e4e69eb32b508aa352a616c63cb72167ddea949c3c1c0f6a3fc5c38e19b87160ab814e5e39e99934b02e8d48061d8b55298166fe7159db76c94432d59167f2ea3dec3d417e8a0078d86f9455bd7fda826ebc5336649b35280930aa03672bff76faac42a176243e54fb6fbbe774a41ae175189d3abb959fb2dde219112f826d289fceb866173305db76999805a3bf476394bc7450bb5b59162d2548b68aaeb8f5f87030f047a2f1fc8a009b134a317c6477d74a88f9cdbca105b4d3dc47ef1ff2ccbf2efadda4e4712b4de6f17c72a2faf78d99475abf54fb14e39da402f55e517da4935bef524f3e037fd449a2966c221b701588a45e76075f52088139d2e4fd26731f563839254b17b201bc5014a12df23a04f1c19e7cb8da4af1d788abb06b2ea49d7142b9eb838c86b33bf83d6ba8671a6191ed594ef809df0e52151d8eb7ab58871346e5883f6b827eac8d968385f4a484ca1b90bc8b84f287aa75c398c296d39d2200650524026f2fb2bd137cb2c16d99eb1af7c9cdf6d4fa94168092b1b010064ab6cdd647a6c85149ec7cd01aed767f83e280d36011aaf2b221c27c26d5a2b7d716195653a25afd469a2aed31e7a95b40e2c87cf6950cadfe173e34e8312f8b742a352fd6129941cb214aec39214d2f82e249593566f0a13711dadfd34d343deac4acc9b8ca7af6b8c49eace3ba16608acd76d3597c422afdc56cdc6a57394ef457e7e66d3e83f718e6c79356e64ff2759b8e405389d4b0057df4296dabcdafe9b3f271460be61a13c47322333f123fdfccbce756b552b9a07650fa1c63b6c62c0de396e9dc79273e0855b7272f8ce3af563abde6e1243cd8b6d7fd595c25cf8bcd199e7bd0a95ced82a428411e1c4260d355873c4a5aaff44f158afb25c8d69d94970c194377b1767ad89690bba9cf7e81403bc01acde1666e2e17642e7eb9bd22e7b8b6a05514d3f36a6003226bfce7d2e1dbd7e2293e4f975dd0ee746c9b501001421ff6620ca9961bf982b950f8c9604c8efd1240bbaff9131e3fc77d61b732c5c1e0edaedc61ca0bcc0ba7c5cc4ecd941c17d9a041fb97402c74691756d542678cb59e6e053ff1fc36f0b03c0178feddb6df43dad741ad87f0b978cf4a98f9f89241383a8994fcba38402b1003bcb262861f35f35b0565f84ef860e32e7d7c7d0a1a5fe5e67b3ca77c83f8e88c88ac6205d5ca6de1c95153444ac0437af283b6870b77b588253af8fffd64bb18fea0e096fbb1c8a357e52c74fc759493b2c2467c83bfd95b604d32b8085f52f58cd4ec2b795406bfff688d7b8fc779f87f9e84399000a4576c866c0d2e1329f418095036601736119476b055c27269d95d134027c9bd9c647034e09a44803a9abaf22f04ef540f85de9fd931f05a9a39cb9789eb1f701e76a6585ccebecdef8e9f7b3c49cd960d6bb266aac62e57a2009290585c2528a3e90c2b54e86d37c6b4889452a9a8bc7f11d329dd2905f53402084e2504d9d471cacb0addd4e472eb9e4137e3c39a993c87d8be33cf057aa9e3641e5715db0f5a1ca27ceed81b1fa449c72fb5e2e204592b6bf21efc2ecf7df44efce9be493c13015efef4930a95e5db5f630a1c76e66bb41c76f5674044266959b5f87c44861af5fef1416d126e33fdf50556d8ab33f3cf7ab6fa2841972079e527616895484bd070203936ac255ba27d0bad41bb4bac420441beef944633d170022e00ac3383451f23e6a082f6ad6dd69b1c529a2db099dff72a387a961ba4be2cc0059ce7743684ae3089cb8c5290816ebb38d280a79ff508a995cdc99cf7b39bda8c8ea826adb6e05b236cc48ec0aaf3c890c400236877d021ff1f76d193efb238a252977d51bd0e21b55f33d19c6b3d471aac5fb04fa6fcd59757827bc25e35e9483fd93901ac3c75216a0a8c6c197e27970cf74ed35972f55c29433c4ef538d4669e1b109f18722a6f87de5420038fadbfb45f141a26c14fa8f3388b4d8c34f13b72111dd2aea7168ae66ef28c0e24a0c79fa2f1a62c49b36652e7a985599770500de644122d28dc60d02e7a1978757fac4aae40d22b3371a91a9cf609c9b7f9459fe83c99a7dec3497abf7103211f2e42d5d9568eb41a25d797038946c07deb9ecce576777ee3b4ce183bb39536bf6be1a35fbdbf5f6e9f6bd9ca9e2904aeafc27fcba865de386941b7052786af3afcf780407162722f7360bd67cdbc81503244e3f64e7b315946951b694573cb09e07019e4c94cce7ecd53a719bb5d569b7a240f92fd0e2f2fe4b765e0b9151360c0519bacd0e2be983747cfa1962d7134a1b515c1c62f4a353eb590be5998d5b530a70d41dc86c50e208105bce884750c41a070455d688b7d7ed6add933c819439397aaf0405644b1fa3244739bde18cbc1dc526b9c2a4731776a375a994a5243665824270a5dcc822a31a9152e81a508b889065b2cfe4ae4d9c5aa4e240ec3e12b2079c417f7f82b57f5df538edbaa8c54660976f44f976566b489991edd64a5b08fcc793b3ede9eb78af24853d7d8b9810e1aa8fb5a57e9667603e21b0c288f6400f1b27c21f53af0daa3deec47603e5fd1fffb55ea6295e4ca02a95926aa89db2c95bcc74e34e513f934f402f7edb8a13fe87d34783fc0227bd088f1c582e4b0296eb8a2b4fc2fe7e72787cdb1e721552b70be99da22082a3c8eae8c86cca4e6bf2a6b35d788c8ea2d0e88307f752e6f1fec6434cf12de614b7ced04558759cb1892013a2b88bd8222daef4811c94304fb2ed7569e54c0b274feaca5aabfa617e5c26d94e28d17d2cfe0d432bc77410b21c5ccbae1a0c33d6b7f7e12937cc5c1492b380dc8303bd15f5ab11d79ed000ab0f94e1503ad737554100e0fd673fd26bd3e2720d5482d1e43cf34dd093157bd86c50ea0da041b96f2a43f4ae13f65d789c762a4a2bd267b742b537264da6752c3d1ba89ba74aa592830cdb02f4f256a523dde746531170eba90128403f0d6f9a62adfc421360ef21e56d648b04b7f905d5a8cc8ab617df5bffed6a9b5d3af8c938fa3f5f9b81bd84c7171c08dba50575dfa4b2903a056260507ec6a01067c7bfc28fc7f11cac6143aed41355a6fd651bfc675dba357a8d02de2b4515c9ab237c1b43fd31017ca1f0eb233dcedb9e6dfd6a283743ef3e5b0ad71f5d06bbbef9564cb3b6ea1653e4de644b26318be673026be6a695e442fe2b57fca545dd2b1378489afdc381656a0350c8f5346571220bdc59150996d3c0fb5c8bd2c62076098adb9328ed75e66d65c53c934081447f391338bdee3860fb39907972317159daeb83584dca53299b2b2652c5e2aeab6d5d19f53aacd06c288da0c02a54e4f74b16248f28ab827b3bdf1aa3512f153f565a963dbf17d6cadea39cf9b5714a2a5c68aa1f395453f9adf1594cbc48cc821fa1a0333a42443dfa88727b2f1f8fc5e80d335b434baad3f5bf0a7f276a1c89a0394c386003b15495f2e05c283f69de2b31a75e4ea9a78b454305954236ad602d5d748d0aa3dd950abafcd380e50223c1a89b80966a110a2eb92b3d6dcb91645cb73245c8b39e8512be6f96ba35dd76a8509a6fd201242c15d27b29213707b67ddb0eda8901213bdfa6f60454c67dac83a2e72b3709456ba4a875d8e3e82762adad5d70f87e9f3b3d181bfb197b8affd5cfd907fe2c8fba0e1f8e77f8af998034af0ed5bdc16a42bda68586c5934a0a4756ed0b39712c9011f9f89e4d6d68f7219bebbeaae2a74bd22caf162986526b93985fa0753df9b06d8d38e62ab5b3c9d223278df3e9cbdc6d2d5c92129f00dd53e184735b1e461a06ba7bdc4a43c3b9b6bd8804c579000e2b39d8eae1c7e1f41281acfe2eafa234495a8413a110ac0c7b8d1fc2ed8a1861a2b12a09b2b4cd1751c7dd37016dedccdb3c5f6b7d57aa72d446cbe0e1d865130f388a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
