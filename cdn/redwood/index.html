<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a367451fea8d42098bf5be687d9011314a1753ddb1754edd35a05e9af42045679bd7cfef7f85c4ff3732404ae41bb14640935be0c237cf787e612ee635e8e9ec52e6560c356e18b532bd1a035151b796a363f8e607c1aedf74561269e61a7b89120ba149d8aded5e1394ec16dce368882c199a6d17f5058f6381fcae6eb6fe03e53f4a8ad0c209a8db3f2c5d887fb3bc4b0947564a91d71460b69896826a5db6e4f37e39f9b68368e9f1fc8a281606157eea0d278bcbb51272e7a0e8ea0cf22746a4ab0cb79cbd7d4120fe8ed2b0923f7408be33abd2d5af97a0b5d8f09b93f74d502f0e9384d181ed7e747363d2387ba91cb941a13fe6caf7cbb7720a2aed15de5da4a1b07ff05cf7e11eb7f2f4ed7d0cde294a597d43111e7ea9ab546e0e9c9f7376bc06a48cbaa618346bfe6bc6615405e237185c226b3fa19163fc26fa65e7c4f4afb9a6695f625fabc10d95df47b0069230877754e1e5a7dd9ca4f5ff9f56d32efd92c80578f86143acc5956808c631853720997e03bcb0509296b24869dd5fb30216271a540f9fb0fee268a15d0a315902dc9514843bce10f44b4d8af9e70c919239a6f7e96189742e738e7a0a86d77b0d99e022910b47e44704b69c5a47b77ebc4296013593b9e852027e5d3f86e733d768a4be1adda082fadd08ab897ec670d1f357f403d678d4616a1c90a58586c151ffea3b00935243169020963b929bee0ec3deff4ddc2f3371030d2ead22870acba7d21608792cb369d9490f8a4f1fc3b1de1918f62f59222848b79051ca92b471cbff3d60f0d6100845695a20b98ad26abfada54eeb496ff1347984b66c35bafce81b979e23729ac3a7aa3bed553ac7054ae4314d22bb0366ab2a149f70ea4230f1b3d8bb51040ad0182b8116a81ea7914d4d0a49983015bbefdd49d906cbc0bb006348dc2b12f4862304bfe930ff5c7158a6a6b1b009b556a9a74566ba63e4ed04401f31b5daab910a17a2540d3549408d8ab94a4c9c088a80a5d4fd4a967f6f73a4059d64583e19ac22a282d3b6fdf3fef71072572eba0952b2b77711520e2785867d5f569802db25b50fa5f82884582332f7f2d2efed1fd53101ff6b1d45169cbbded6d7dfaccf7a5b04efe4e9f5b2b4950fef24d5460f17053af442d1b2a7fdf3190639eda25b0f51efcc7faa240f6305bc1f6aa0eaa7aa8f67a915a93d53cd674e114f92abeab999b6de1275c16c3595c9473ac45cf09dd14d00d0d44a1bb22888bdafba4212fc5bf5a058c58a20f9efb73f937f7d8e29075777a28fd991719cd259b979781c6711e380df2ceca693361618dcc35ba4f8e12aa0d380f0f3249d506ad2576a7917a6224a6ac58e516327945fd53af7e52366c62fd8016ced2bc1a63e4a6115482c1ae6dc02ac66c2e0745a269c38f0208424bf321dff944fddfda38e1ac93e2c4481d1e1e3ec59578698cb1b91f8a7188d8276e920fd105c0c53411a6324c99795d0e73a76ee116d501aa41c09cf96ccdeb5101afb27c07677900f0dffee5aab7d5a9a60dcdd1d026a80327217693a5069adf6a9221659ceebde45e508280ee3b0a8f2e852b8a9f20f5a7452a791d217e0950668e2f0fd617e08433ed96e3d43c65f7ed6637f969b7610f0324e70061fd57d986f5d88f16f35dd633cdb5e5b162115dd0e1ba89c6ba91e511d80503e6715e7f76eae0189481d25f3170dbb94f1e679407dee3afa52277732cae14290beda4e6b12acfd80230943ca50539ffaf4dd0c7395bbb7a42394b8fa442d3d3ed36d7c46fcc5ee9c9fdce23ca72d434440adf285ab2a99ebd0bbc9f0cf4f459b8d90986a38b3e4779d0c8f945b1ed48dbcf56d8294f1244ddb588b5d1e05dc34db4fdd74fbb78b86c6413a4f5b7d1a7fe16318f564f2475cbe6ef9d99a25ccf25cac61a48e4c2c55d62c3971462405b2826587bdb7c660f58db7e7dcc8d228d07d4e0b36be292a65cfccac4273004df442d815bc1fa0499f0e515331338003c4300a3b550a0b36aa40a931e4213cfecd6c32947f5f149716ba78b4672fe74a3dfc4b312a30b07cba2ff33f160337c53702c10e95eb701b159fdc33543176fa04998e8ffd14f9133ad109a33d18660ea0d62029ecfe370a43b711a48a901267ff227b14e42f710a5e9c19d607efaa854d38f3c207c214fd1e4e4a60ede16ff472d061f75bb5d37e8ce4f20b6fc1f16f6a0db27fb4bf5a7b59354dbb6858688cbd7def1807eb1f9ca4c3ec4c7266a504548e4d6d35ab8b45d91c7edc664b18d72355bdfee072f590023b8d3cc9c46939cf15ca93212f2b07a06f4725a479feccd277d880e247a7a1d8517ebdba083c6dce601633526c91198833cff5dd1852e9f570ef630914741591bf466a658cd6d13561e49db462d2400fe661dc2ed02564ff92a3df4e99de470437e7f9fe493fd584a97d90d57a4b4b94750718724fc65119362771c07737f3b36532e8d2324eba5db1a4ec7a781a082ab7c5dad21e78184cdc71d91274e14bee9952e99db5c0cd46c49b6db2d0e465cc0c672e0c1187d3fd2f3d01f9eb4e9aee25bce6de729b7353e12004f3d09e64e0464e9749862becc970088e733379b69a9d23b8c6028f5718fce1610b71ab1b683cf11f555926731517aa13fd3af45157d05efa3e23b551d2907b2292b1c124559566beb743fcdfa091b79b26e156f4c81a2e56ab7e508878450f7de0f2e3a0ca331a72410ac1f4f4df5e20b838f1332e793a1fc61e614c9e191e2281684f18834b546987d3c8a9350b8e8979bf4c1430da83582912aa49b29bd403e70cfd7a9c3c912455e067dc9e82055d42aed4593e5a61dc0036cb4100dbb1639cf429faae4c879b5b45bae581e299d1d392395980cc1a8881c21bcf5861a48aa57a2528ab385ad60288e2afd20c53f7d14e585fd1aab57a5fb4601c63496992a06c7704b2bd434c86c6202370fb6f0b45b0aaed7d0e9526c8ffa92632279ed25aa82ccf9f0e7f531c232ef9ff5cb3e8f4765d9a6652c2a18b661f5c884219e7a13ed362eb20675c03fd506b20b47057d3e0edf2a23a92707423d19e149caf1e96fb0a66cd6d277ac15b3a928eabd91c244bd536a53f28b623f5b24e7214dffb3be8df43ef6579db2b44873f6980b25037a0b0d5fdce6bc2a82bc0877ad81d0a881a16e2328df008a1dbe3604977f253d544cc8622ed6f56c928cd0e912dd8cc1bb9edb437b06e21e7f15ccc8cf72086aa276cd191f8f0b70ff71827ddb9ca68584ff8f5de7a1cd76784f14b834f9cf4de90c6cb1abc937e69f7e72808207ac794f19c172478039799627af3fa3ea8c35d0769dbd0034918b90cc61ce8fdebcb3aaafdfc251798a464977da4a01092d6c1c84618659836ffdee76925ed4e69ce8d5a9de01364ee40f6d33946013a036c6f939698107311c358453bf34037da0f4a651b7901163f0d8caf411186fba3833f9f7533d066bec7ba2dab58483818052816905bd46db595331ecc48b872eba7425e51a50997a6f5644cd9c7fc2d6fc2e40e35b2d90acb38f4756262306c29c1428aab7ddb205ea9346e20c133b98987d596b1ebee1d18311b6ab6533914644fb418448411401c2d1e76be8d9bc9d6a4c6f1c2cc049629437a16f3fdc71109c2498e16bc5536ee48161b64b8dc9e4cbe606ed2b5cdc8589a1e371e60971c07198c5b8a6f35a0a0fd00ae22fa04f92dac11a1ae6d11aaff0797a0ad3484d2b5950ad91e9e6258f7d416f005cd580577ea27e9182ad91f00078a484d2ba6f0bf1fe5e679db4f10a69f5deea0ee715ec2161d634c17476a690275fadc0f8ffdf44aac7e0dbaf13125ad6b0e2e274df0f546fb87606d82b87ccd63e7799163bad7ecb8c3670acc83003f505c185cb195fea5d60cb9e0a30ce93a3e94fde1efe508909b588eca33d50a4e5ae260fcf24db511a252cbd8dbc6451c92a02f0585fb8cc3e93786ba35162221fcd06157a0890bf9a76b873d0ee7fba86cd587dd7a0b97f338fecf1f8f4c4abe4c68cd146ac0c32f508f0d7935e09498dea59af514b7b36a258158cf84bfb1f81e9fb8df394ad6726598996f400e87bb2243c54a9793e8f3fb1ad858353ee71f930793ee1ad9cf7d7e4e6327f176cffa34cc6f50478d72cbc86c985ce60bc4e6b25357e7fc3f275bc8d16c29d7ca1934e466d2d446e4c8f0c6a177f89bd44f939760657fc659159166a4295cfa504dcd757223fbb5a76f4006c4f338b3553dbfca204f1711a1d0d41a149faabe8ff2d9206087c683aa24188d03067deb68b7bf772929e2afa629a8dc4f8ef8412ec8280dc3a9d4d5b7d4cc0b76a5c9df1f2381f31f0a97c614e63707f05f5f285fd82b7c77202537ce6aee7c4aeb81f3585563645ea762b7966d45e1b7d84a5cdcaa4003ed7a86b178b0d1468318760e697867b5760de98888c426d559d59ef76caf492939e8cf9ed9e2a47a2e38b01743d515b06c6fb971395a1de6298611ed29644265ca6e1ca78d7f256c8091365ad07c5ac073b8f7352c95ca50a403b6f25634e36a824af60c6cccd04334e113491fcada3fef56cf319bb434440a897c0166c4323a878fa30b2bce238dfad7591ae41238651a819d86bde08a60c45043e07e55a184490a9e604629f938601bca9eee20c6720f33605faf7ad7c1615b8fa0ee0726f95a55727638a37c637e7e19755b9ddaa2f9ae780e11d834d4186718e8b4ecae42a3eca5ab9ed1b124614ad768f1df663da9834a616198b73ea1ad02b941d7e5c2683c0fa5d7932a20eecec50a7fd5229b4adf502a0972c89449a3cc1dff0e2b9f197bef05c975e81ceba9e13b6f97f2536db3d487a51574391896c6d42b58c55c69832b791bd59d050b9b542118fcaed634ab65edab53ffbdc21d3b071cf111c5ad14fd57eac7d1209282ceb321a53f0a8cd4e88410b91a37cca65f73ae28b23a6f0b041a6ad6b5644e326b5bed9647e0c513892ad4e9a4fa9131757493ace317aca1419f8aed6038af4e6b4947e7a53116f624d24237ae892b6bffd9bbeee64a7da6048c4550317d1ad12439b51c9160834b78ea2b9846a0d7b1cad37f57eb06a61f878614f2ba21f547e8bb4bb266f5eeb3b889e99b446c32f935dbd1738da3da3b9c830ae09cfc5e3be347aa37eae486137d12c03d9888919f16e47990246a2de9a5eb00bf0eaedb9dbb8448995e653e7819fc3936116fe38cb49e4b6dc976c2095a7f5ca9d7ea2556f3cb839b08aa2a3906000ece6111a6c9eb3788421d0ddd6884a8ceef8dbb080640d6951f91eeacf9f5c2923deb8d6aa1890aa0a786516ff84df3c19d7985c674f02fc2e920801b130af2135499eef831658e044091cee1289332deaa889cb44276ff0c7c05fc4afdaf5d134a99e38ae68c2e468b00fecdba5afa33dcee69505b91f5c0abc99a3446d1425bd64b56dab4494815edb90ef401f7426bc866f7baa30ec08c6443583483120aca924ace97451cb6721f1aa954faae56fb43b1b93cd8fe04b92cc18e7a72ad11df528a37cd84a3dc43b36b1147e90ddf3a0df958c97f7986636b96355a8687e172786f0e34c0cc66f65e08c5295e8d2159c9fd36ef3eb499b07c91af58ab8c5051a2160748d0ebef5ccfaf80708f5d1af10be8d8be5f688adc35becff626af95fa8f415c2c63ab31d421d1997095d6c9ef6543eada2f05af990ca8957212031b8ddc22962ac74509fde9fb82fd09508fdffd8cfc3f782f653b1f81e7e44704b10cc4db68947bed78939e401ec2fc4776e6a8166f9387c06744dd4d629d19aa78caa3a0d877e27e981df349643cec797f9cc857b859ae24c682a8994a36e00623e5c71d81dc1633f63eb2849783080f60bdf6dd175e05f6ff1cce8ed057acce4e2278f2c57458dedd1f64300aec98241bbeeadedd4d7e7a27b048dafa4528d0f2188b8e70c8f6b42d518b0363c6d3cdb39fd53b3be61512ba94e73fa3f521231b672dd3c065ce1faa822010d940f69a5b03d16149f880b69427cf5e87a3ded43f0b84353aac60db4c48655ed445bc4ee4c65bfc9a3191a43af4c658872ddaf9a0869ceda3821a5dcb9ffec3263f1ced81015e97df9e501aef21d478f93526918689ac9e9724044331906b7e97173890267c8aa5f6aac947e882263e48d773c0075d189e6863af782d910447dc3d3bda304dddbfe83b33c9126ccb8f5f481939a0d61a0c26f8a949da59993f136e6dbb781695b8bf8dee33dd62e5deec41250a7c8619a67c7d568f70b6fbab588e4011b6399b3a16468dcdbd53720e7a573bd7e1eb22a2377616fde9fd54fd92053d4c119b4e18e610d89d9b0f20d15d2c9bacf43863ab4dd63bdbf1cc72b87941af4c541f368925a15476bb165e1ff016413f6e9da9a56488aa6feefc83cfb1dbe67c87b089d63337f26e3360e36921ea3c77a712379d925d986417920c37f1f89c931f47aea05689a4351b7934f550d3541d5d45d73bbec94b25ecf990da5c0915af93b726bf623b277a0bb7b6c3e610d22c9cbc92fc23e394a88e086a21c92439dc3bc83f508eb7bba9572a00d7393d094575523f83b5b852d52c148e9103e0ddc1bafed10ddf65be92a092d4be1a74a7636d16c7df08e9e2493c7b123de6add1a52c987c64e99743b3f8cdd60850917995793b62e3174c719c751cc771863bd8ae3983db35a25847a707fff77713acf73a77be451d19722043ee2c4e69cfd9ef9c0091c1c9c97d4b06f753c089fe4cfbcb28c3dcbc8409a586a527271e648218d85b3605bd00db557bf53f845c5430021310ca04f1368c1b704e3924edf0ebdce1c77b50fb99d4a3cf99d169b69b7650733077321ce401488c4a071272357975169dbf6b32a1da291ce79edf2e19dc924ba713778478fbe4061863bba0de086166654364bc41e5743a0d71e4d0a9f2b2e5ac2bedb586f474702071609b591a3af32c9bca27fee1147ebeb2d29dec1243b928a6ab01d20ce317697b94e60363b4aa4a543177262cae2d8bfdcc90fcb8d711bd930355ab73f00c9e20c726a74bf184f5d3d8d5090c65c1656987a8245d76536049ff8d0c2e438bde520793f59c94f85891ac488ff2368ffe0dd6db5d9f18be2fa93238f5a9833c76b05ae9d96beb64a783b8122fe3d973b2ea6a87e6f80fdce8952c255caa4893061ece6b4704ef08639c9572078ba7536c9f7dd77504ca5b1bb56593618ab019f170dcbf12265b95f4d6c1db37b65f6672cc569afef33a74a64ee217c726ebdf85556ddf85738ec7853e71ced1da13c3edf748fafc88842ab599bf97d564eb19fc2c3fec0513fef21519e8b559afb2eb97312d926f53d98eeed0e48c12b2313dc7d4cc16d61feacc75acd50b028962176af07e79c585e15257272f9419f392287756f9063c3ebc0990c3b3a55d4788c25f2ba849a104c3ed6d015404cd318bdcdfa737319fd3cf16e586b1eb5653c0f04904e0f12a6204f5ff64ce4bef805775f0d1a1eb578cd5201535768a263cb8c7b0e98a6405f13cdb4e101975bf2c3c4c3f8a4dbbf5c83bab41c7d40c04c70f947cc57e32ba50591cb65a064eeba50d4f520090aff76d4a88bf868d1dc1a22163b9e47546c50512af4a91b8010b74fb6a8e37c3c81d9aa5369f331f0336448d9998a698a552a3300b40b72ce53fc3f6319bebb3df1bcf3009d927919ae961216782f113d626d4d78660726ef3b0268be2a07f0784805075dd96f03d87e498e850552fbf40a65dc008a0098b74568fc90d081c550df2f30f5a824d790b14c80071b1c22573c890359f2a44d21613df3fa615b75327a9c6bb93d7767d4b284f657257dd7a88d414ed62abaed5e051a8685d993b869d484e9a948bdc17dc29b5c270e449fdb10bbebf714ab61624fdd0d4ad72c472c6f176098ccf519cf122186d9ea9d519e64c3388c5589d6cd128818fece763a7096ecf9340e77b58d11495e71aa79ea2245cf335e477e7d2522091eced765ecb959662667626a20170d1d2007b96c12df968377f1fe541d7f841e13ef12fb4d96d3e687bad017f89eb4decb48a5deda323449f415612e53ec7442d9cf3da71cdc705ba6b0bb7c6c34ba551bd0c4fac7d27635cbfe0f8a022be042e291c605c20aacb2de8af7d0a985ab97c3ec0be34293bc36e9529f4113ea44c9e888d71c37ceee53a93e52d0e12ef5c8bcd9b756f8c51d2a65be7ceceb1f488776c2bf9ac8eb127a0ee2b018834390aa9405b795a12e0089a929f6e5433b876d46519ebbac7b4c0db917546070c2153ee4bf3f37645702b98ebeb2df9b658a4c21f7c17f7542bf17e13a0374dd2a63c90e3a271d749b901389db43c0819667dc499e569a281eef6e9a38b955265740f9afad017268941b2b5545864f28564068c4fa66a5d3d8e159c2a11077adb2956ade2f31f79d27914f10680ed0774755e3dd85f783ccae5b87c86deacb5ab8a21e2c817070639fa62e74bf785b1cc3b3c0bdaa676bfc2018bfbc40f5cb96d33e9ecae939da89e3736db1d31959d02014b36c0054f9d7056cb7f54dccb8cde57452da7e81274568f90cff393e3337ef68df958ead7527f01f7009bfb4bd34cf79f48166ca408a4bad5ad92ed5b734b9b46e7745c0468a9aa9332c953ea2a51c2dd766d9e207f302bf9d5f699414f195d51e33486cf86f60ecd40d7aca5c61f93cd4314c5c6097f2dab849e5774d333aac4740b4598fd4cc920dc917ceacbf379c5cb6b7c47efc61bbfa91533e944b532a7ecdef41900a4e658b3390ba68df858006d5b619565078c97b69ad16be93a97f160e7fabbe0a5e307105d46fac372783937c92e5e49df06d4462c6de0131d52948baa3255ac209ae01c28e017dbd261e0497a363e407ecc5d2ca0823cfe1f54d0f10c2ca0293b66582f0f3a005082b7cae238b514ef9b4f633a43b47487f102c88c8d5b42de200f8dad3f1d17c21781ead5cb2a2af8ee5d7dcca8d9c3e01d377550b3e8029198453c72e29a877eb21f10722fbff2444161c1ff99a46879fb51f4340e6f3118756321c2f16dc6168e9eac893fe010693610894d4c7e7e56bf33235f18beded569586270d323d279208048350e12fbd8186b6417fa46f8847de26599e250cb0aba614aee382706bf7360a05cb629bce7281864f6a817741902a0f80af80430ad4b3c01742e1a06fdea8585411243c5e36c85f74f502134da66719f72fc15a152fe3f0f65527019c76dbca8dc0d42dc60cafe52da7353499f5f467e2dac90bb3290b3e1ae966ada948655f407aa514514dfc3212af330e913392a061f61c84f6c949b8905f1ecea39aa76ae6e6379d0db96443e0a65ffc5fc61ea76cee51d49db1d9272e73be554c124f51895f9a83659be295847f27a0eb66c6b76b83c79b2a869fe7b92d9302ce149c525cffac2db66f93394f8acc91fff0c679dde69c8cef840231df15c3ec003b0a312e2c8f4c7b0403188e7790a3dd5644f76e3041c8e3ff100cebc4a07c1392c2c0e0dee1d8501905afd9d3d0402bee6aaa5fd9700f611e81195648dc5e27592977eaa436ee32a00dc8de44d5ccfd4a6af2b81f409c5d5c5e0f65618a724f669ade7c9f5cd6b231a0786765cb40680115ec34fa8186e3a4fd3c502121ee3e1d7e35111e6cf800911d0e0a372230bed8bd3a3855520dd2860b9d2ca4d2f78873146beff2141da32d363b716d892b2e9fbddb033ab028189c31b62ed9240f4b2c7c5b8ec0ccad22e5f001050006a7e6d9d2ce7d184e7e12e3622eaa31ba1064bad5ee04c5d82d4418c662dcab4f89912d116b55e04da8248ccf03139fab87a400b5a3e8324b0e32c917e74f7c3848f069c9aa5b972a49f110edafdf6f5731e3ebec018c10298141be734bad19bfb8885e25860bfefb63523552e51c98db2ba302913a5121ff610d9b859120c2a6db086dec574881b62c1da89268adc2fce8508171f7bf2a5bf7d09b65110142fcb4e95624ebee9a7d6b4e28f5e7a9dc1d0cd2bb0e241a04f137a9f4da191b03453d57b1044afa77f8a42d7624916ec66ded87871ed96c660e43da99130a8c1b2f84f2a6ccf96dbaf520a3e893cccbbb408c3d7ca0369a4a8037388ca5fc2c3a76b311781945113725484481c8aacde7876d837407611a856f7ef6f94bac04c2e086f567914862afe5efbe6dafb5ef814a25ff89b09b4baa8c884a7eb0124b74c9ec67d0117abb48c9805a4684fdf54fc0dae2fe9e1989b8b7cf24570caea927d9d6341be7f6e74104a1c15f692537b16a949378a8767d2a0e9fecbc0caf09da4a92abd881534cb4e2248a77ce4591e87ffc7381d041baffd75f5718d9ba5ce7e2a78868f7ba8512f8bcd154e5b69f6e2db027b10344d1a854f8df3054a1634ac6ea0ee84ae981de02134ea31b3aa78bcd385f7d4e04b0dee1c8ae096cb128f45c3be3025aa5aea2437494f3f36fe68a08186ecc5f96baf2cf13a73bf59e14ddf3e8c28ecda867956cc2ca0dc54ebe3dc982e086285d102067bf436361577139aafafa790c9843323b7602d017dc11ed48e93e85c24505086cddab067bb0659ff941a3d3f16454e06669b3edcf0eaba397a847016dedb10ed64df7f862446ed8b7444e7dfdc2fbe84c36391d13eb15c0c2de849759eb0e59d68b1099b7850a37209d51d9b570dad939f213df5c37cbd5a9b5c66d04696a51fca6174f31c86a24b66ebeef9024b7e3e6ad43f3725964843328cd50d64ebd14ca20bb8201e1ad7ff376d9dca573aaf9e892f6f148566e13065f67a2ae68f2b2df48c355d3181de5f2a2dc735c056d601f825241206c750a27da78ceeee4058393df22cbcb15ecbcf6f81a09664a96e2342a82c19b201bc27be89d32859edac8b1b6959189ffdc2b2d6607db67d1b217b0ae970e377476e02870fb1b8942aa95fa1c1fdff01c013ddbdf2c9cf8f917d87783843e673f92d699189366f5f44ec6adc272c8db729b388d31bb7713adf03bd2e567bbc0fdc579b8ef921c6bb8f013cc92f71693d6ad8ea63de8b2f72ba862775f9d949c061e912e0e028bebc0eb9eb8f4a1962ff10406d569fcab51482f8190a1ff8a05b32e29009e498e699c251ee91c59f78c8f7aee8b86ef216ff2baafc04ecbd216001e9f63d694ee7304f1a1f53540b4700256d38df7fd3f100dc4ae530a5caa1d1212a92c7b12333adabab92e4967df9169601b7054660baee64345473b79054c8ed3fc27f384c54d93153bcba4c4c77b37ff70a17fadc2420a9d9cc084f644524de4fd091feea22c8c2966231085474b8e1aaca7e2790a8d80e4ff0b984e8c6fcbc05caf4fe8fe6b02cd1229b93d611a8ad61ad67b5325fd408a75aa3d88306d119889c8133578be0f2dde35be125d996e219374a4ea47e43fbaa2c0e542cae74b5fc05550ca035d59c07832b6a59b7a861d4a2a5aec75706583ea11f93a33b7a33df9d3a7adb341ae0f25f3d0fe0555a824a1dd7524bb302472243ed40048cb3816eb16df2f3f6e66b69cdd8267293f58c30319307f8e096dfd22c5d7f8b8ae3114bd391a10402a6720c590d7004878e531d0c05c9fc0f691eb6292fab3c3b48772b878adf54eb0baeccb8b388353abb2fe9889d423391d8c4c0ed56b5e201454897f6cb0ca27b4f40a918682295241951e96cebe3734dc6f1c5243aef11f5ce95ec9297fe766444520159dd8f1f2c49d9980f5d36cae8102fc855b436602e672d3a80768a78ac4360713b1b016e3035710af195f1fc472852a2fba0c96f7c920a59c49f011c718982e422fcb72b9f182c4581159b72ff11dbb0030b1c5b44dc9295ea881c46e384424a6cd188c863b3aa2db8c708023b1d13e10e62211208a51035f15cee50dc7e757c6f63e80090ba2746785c71028397ef0ddccdf7375d216e44c440eaf821aeec57057c0ef7a68cd245bdd05b570bf170f82935838694e48bb2d82c0ca8c9ce9e49dea6d308ba2fc04421b8af69b85291380ce75efd62a6b946c6662ea581da223f669ab854b8ac3b80db806a8c1eb4ea3814ac9d25b2bbeac403fcf6c47166e1c9584cff5714dc07591f0aef4cad980dc66ce7212eefe837e7910ce19b9281fe50f4906b2ff5a2c65e2c38b47484364fd82cfe484adfc13c2587f1cc00425ee2f23942437333e3a2b0efd46632b2f5ffcb01862a02b3f3c9af94b7b6bfed88caf1fb4b208eb1be74e9b0adac58a03cb58a6c76585ace27e0c5af97011cf17470db29b463d771929edf8ba68fcaa9fedefcbef8a0ede10590d1b91b1329b162896476094ab9447c478a039b668115a2dd24be8e75eebc201e315cb7d2436bef3c1c67bb5fe1451a78afbd31283ffd23d66215cf840f5ae3dd7af14ff51ac30c7700cbe51ebe339fbf7a9e14942da4b3f8cba46544af4156ba2eeee6766b6eb19d95dc0102ab45f775025a946a0d87300df4516f1c269d9b4f1e32ceb87c31bc58f80aee611dd99e60424ebf1cb9c4d33e586122f8c27364c19f22332238550927b52abfbc024a8c32cf956ae77b6778747b0bc751f06a44e2aea9462fd3952b4e4be5c17e1f2eb49a9157cb052b8f67e1a3a7a7f970accc20a630ccbf4e8397905656f8e9ecaf4b04e718346a342bdbf1b55805cff80a59b1397dbfdcb03b4c8e2a2b2236440f79183f03164c6f9ba3554157391dbe0c93253ef672b23908faa7a15cf61484b96cac4d5f577670d244043c439dd6ea758ad2976b681769900d295274920e28480f77b2258bdd502c022ffcfccecd638b57d0c8a06d22ec17e149cfbb817f61116ebf99ef2a0bfc9473c84ab85ed2d2585ef81699ed213bcaa384372a578f53464264e14983eab80aad3fd73a35ee45a28598df79860bb88deb26b9247f713d02f1f1eee6df5e2409e98e09b4b89bf61ae9ca50b431856031ad8abfdc1bb1f7e29323571d4fa20945bc3aa9ccc0d2cb94c5eaf8eec6293ebdf7bdc065ad6926dbfc48271bffdb4f230ba08c3a9f4d90abe4680c251370e78a0919e88bb64f9a53649dea2f9b0c59c3a5c905304449fc1230897e382868659066bc1cd3ce11bf9a3db59c24020b1f816a5b847c60126702cdf5c1bac1121e8f0936221fa91ff1ed3f5043a82e3d746abb17fecdb922e6270f4fcefd5e874880ce6176e4c52119ccbbfe11f487c85a525eb8bc22cae7190a2533d11fcb038353ec306d0f56a4107476986aaac37ce6cb6ee417f437f2d96e9de3555d40718a061fb850db2ba4ff809ca4018e151ce38c2b3379526ac547e2b25c90ce7ee59ac7d5f1061deff9b6ae336db1842c758a8008790ea6e300bccbd84052dd925236df9e7d817a072a171e211917543aa2220c3ce6e68e4d221c24f30176432f7049beba20fc249a4e9663793198d4f1c8a9c44596f8b46a4cc8a56a13ec391becc7ef9e318aba8624a45b7d0e04bd3df20203f2b5e1281f7aa3b5a6d208818dd0c1b774124ee8aee8df34e9571ff233c3b37aee1800da773c2ab9c500c19eb1fe1ecbd4bbb4dd907b30545b800546fb76f7c425de88dc451394d759909550c40b00995d8a6c02069c6c16f12da896b0b164a86ae66e01d76d6046bdcdf1fcb9cc425044e1c9526cdab6fcea307b5cc0fa2f12ef6e32a2c40a88e221f10692bce81bcc4b32eb141c26636ac5b0c19ca257916e9f820785b3f2f56d70bc87be4159b01ec853bf8be2ef5b7aa4a31b70f98ebe5c838850d4e6efcb93a0d8487dbf0853992589b9aed5095995f079b5e009b3dacd14184060872b24c1b41f21d9bc7a8d494ea33f8c51fdbfbc80b389e5f2da0b5ef09a4f276905bd6742255e8b27b4681432cef89af9773c3c0c5edc8211b8a61c9e4f67370072f34af6c2f521be2de3c55c61179f554aee600cab80129ce1e67d6e60a9eb4e853dc1add0c0c4025100106806a2ff65edd1631487814a3c166702a73f282a271399ff344a9e6b68707d638dc183d31e4f787c80dac4af9d7df293c31f628bdb6e357f425bb6fff905d9fa1cac7fcd6dc9a49e3c67dfda752c66f9552736077971028db65da172f2eb179278c69fe750e6fa06096d6369ccf1036d5064e22e8f490a9f9c4235ab443df75b27c24b24cff480172488bc01a50d43817fc0e505a7ed83959214a72d21aa06b42f69a90427048c83fb77d59d23cad550e8052b26332f026bc8c84415a30eef4ad7f12cd6f1f1b50c7c66d0d4034b4466b6db4e6cab8dac645afa9deefa0802c97d97dfad25d7c3a0d7a553bdb5322bb3802219987c242e211e1b3b2448fc778a01af9824f07925f4e450575e4fd884b803189f001f6365293883d616e12a331a790c0d0bc10a9ad6e6f00eb1920b8d2be41fdb3c1d34dd2397b9f3b6af7e067569389968ecd58f54387ffb317e9fc44fb736a5ec0164352466c5bf0f504271a748ee3751d9a8d6e6134b6eabfea4586a8b390c8e43fe2159be7c1a50cb2f63a0c3ef96634afe432087d70247c19b7de4b57ed78f47d85c051a1398dd4b03e42d8415a1b3e90951817a73503656aa5f9a693cfb9c4dfde7ec39d941532a4d104fca8a3730039a51f11e2a1bc075effebba78f498a9c6f66d0c989487e1455466b380f24366e4f15e99915d9019b603fef9747d674bf73cb9437dc0dba79c08744cd7283495610709a10143c407677d685b1a5ad86636241953ba90b00694444cd2b0f4bc31c0c78a35fb6d08aa04cddefc55c3e9837cca1387f1ab47339515b2601e007e46509dddbb0990b61c060d9d0c3eb6fd6f6823ea7b9a9993ab7adc733724f9334d880d9d95c2d313f8ce79ee1c24d61ac88cb5f2ccbc0eb23fe7ef4facce43b1c16b422f46997c3ed626fea2c66ed8f8d96a64440d486d426db8eb1ea1df2bc0f1ece50c737f17fdaf418582fd5e3eb513f686b8331b5b1fc5b3cae25c0d82b8c953ace9d9cd12b378bb94c8034ed8d53489640a3e85efd438eb5ee389d0755afe6b273444716ea63c7420a9cda0922e4007d96235024edf6f8a690616c23846e6023482251da375d404512f24e441eacc653a0becccced830d76f253ca9a94246a2cdd60e8b00701497e86d0286873d012656aa6dc8f434aada3947fdf240a2e568c39fb14c36553cfeace1dd728ff16b9526dbf8fcdf255b8e71a91ad33bd72823026847c3456a76db4ffaaf8d74bd60d9e8c9f0ab3d7110f75a20ccc9317b89a776c6b06a0ccea5fac8e143f668be500f14fed2037d69f838b71400d857e90f7849fafd2b0cdeb98c8e3ec4838c7fc3343d9356c1fba3f321b462e492d6c17fff6149d94bc9f63a2ed1422c27bc84a14275d05ae8f5527abd91f31eb24dd3dd0a22b968772c0625ac57e494d76bbbcfe8c2b9899ab5705dd8e786ab42bd2d51b6eff100d1688876885ae108c295cae0fcdc2245bd62046f732bae2568584f76434ef22f87b7b32f88951087a3f13176ea0ae4c9b35f152ad3a88b79006faeadcd8959b85428c3e584bec6549f664e53f759eb43cea3e576bcb16386a1167f3bc299cfc14f2a5328473b3a31e46213ddb97b22d0810f750daaec262f1a1caeaac04a3971e023e91486475da9264c568df76f5e8fddcc40c0dd19b0d8ce12b990c4b5bfa288c732a76c79fcd486ddef107b7fb8f912d7011bc193788c9ac87abb787a2feece1bed25477877da1cbb87af8392c7c02f91d8b4313e837b94e101c0272bac189a4abc1f29cafcb4516a32809ab660db8b19b564b9e6c29a6f3838ff6aaaae5955376848d7616c8ed989e6de4017f4bf2716ed3ae853c38bf6d9492c86a1bc77706c037e2a96e62f99f021de33adb3ef3f2223c9c6e9e735d05cd1bfa154435bad107a08d5d8bb9430f84f0426df147684afc7878723d2e9cc56c2e121a566e000dbc56cd12a527110a7ee9f22fac6c9d8769125778ca9dbd09c0c45af923caf159e7ebb7124c42d75132ffec3312e3ac4488d25bd96c565889cb3020e957ce9c9f1ed9776933449200441191a63be7efb5032cb343cb85128d8353aec3a91dfc093a3430f51429d2cf085eccb31d5cab79e5e63dbfffd28a0b778158f92c25801f56e4c4069eac77c33e5e8152c52e0a4dcb4db23e7e7c5fecb5728436f1c1e704dd19bc00dc6e6f4965a6b72e0d84fa70737f36fac41805ae7f7fb257051d9130a8b8bde32e809a1da3059adf240f97ff2a583dc4977eb3dbd8bcd94306708e58a1d830b46255a9a1969a34655b9c57776a9708081abcb5bf0640ae2203d400a7d8114bdab6d432d6492891d138eb541f18cef313325ef59ed0e22e845014c76bb9aa47cbb35438111d0b2c85defebbecde5cb636850cdaae1b670fe3ac7b3e60014cb40c0ec6aa6bdbae423d13a709fa6dbc9c9ed108732d51ac7aa647c17a3890662b99044394f1b453eee2011d17904d24d332c74a6bcd17f80206b243b31b772534c213be3d6b6bbc83ed4700bc8e00abbd9b7c3f9c2528a2bda44bc87829fdb8b3fd743645bddc31cd3ad8bbc4b81763f5bd69a30922cc2cb7b674f2e519157aa91849198a12575b09d2780b4a2ae55244dc213dc5fe949368f051b716792b7243d7e5c5a71dddb5482e2054d55561b14531aff1fce1bcb75b2e642630b870ddfb6e3e5d086a829a360a117864e9cacfbeb1404c6654d1862a30fbdb84517ef4b9bc99b339e3346b92c412953e1718a7bede0dbd16266c65804ffce0d9a4ab7f12925f793e6c34a5ffb9cb7cac79a934e3a8e2b9a55827a0ca00c69000f016c299ecd5fd7d9d5a1778cccd8ae2f077cfd6007a30af6945924942ae44ba48752c29ca13cf8a2692b2ae3f7eccb93981b9063ba8bfe139354f686f3f003f2ee97bd3d35a0fd2506c7d15eb18a6203bb9d3ba049daec0307efd53688c46fcbbefd83bb10194dc9b10375266895bf791e70c9865302dc1e686b22220b956d2067569277dae567d8d39bee8ba175c2d85db095c47269ee13bb84041b3395937c9ec62d9ba86d837323520d4a528b8a6799d8e75ada67d5fc56ae3dfee4b6ac2ff48c477c72f96a057513b0857132f48e48b5d88190d545737258612069ab4dc16011d85770b3b8748371a2eb30523efe92398eaaacaf8a2860236868df7a56f05e04d472ee16d92a8557ff698d8135d0839b0a37f805e7bb7659d9a19dfcb877f3a5db0d206488b6c3a5c4af07ebf7f6f11ef5b178775764949f6f59633fc5448eac1460177486410554868ceb4f6d5255ccf1a72975fcc238980050b14741cfb6fcafcaa320733a5a3d85f5b26be2c31f866ef5b37609e31016af451078ee75e1204ff77e9038d629509e8ca1280e1c265e25364971186445cf5f46565145032ca640f1a6cc08d59fcdaf38284846ee6580804d1b654f92cd7094e705bd9f59a5ab9b886a2896d076fd06b8f6c8d9e0e9ef49b3aade0b06502c67a97412ad71169fb60805e63dcfa24eb6f8c9da12c4738ddaa486746513a90ce2bc53d1f75c3c4c7ca32fbc2c7cd9a3091eb3ff2c91bba5e9390d4ec485c33cfd852f5776da659aa8d124969a543dacad9fed41954cd99742f97a5ef3c8e9f638b883119ddb989689f8ded5b9f30292239433cb345e05ae397d3f28a17a1f74947819d929d0cf22a25988c73c1375421042a67a8840ceadaf61ef47e57d94fe5e29c7b758ba693c432c5a8b5cb42a5bf5ff2bee12b7d1b5942cca0ed2bc2b2b0753b97dc1cd434aa549b35d97b735582daa9e14337bbf37d0ae07041078c416519171dde8dee0f08142a16ae7129a67f88b59cd1afc298df3115b96af06d7918be6acb7586e235c7d537e0763d4da32cbfaf20957069d7de4486ffd2ed01100705e730c5f2c66555508b5937c9ec201cbe52fbf6a8588ed58635b0503dfedb65af5a185c75d6a2d9370cdeb68ac746e28757de27a76325d0232379f0938eb162b625403fd4f83266c1eb0f6edda92f5f0a39f5936f45f39424f289fe304ca137b50fe22bc7617867502daa77d155f4cac1c638f1812802f8133404291da13dc12c1c8d659c0702a6e6775bada1fbcb93c1e61cb4ce393c7c78e74102e9890a2801936ba0958d65ac101105381338b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
