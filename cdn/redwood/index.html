<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13501739f98f28d3e68c9e3beb4713d0659be7dbd91cf905beb626103c851b6ec6b40ab90591f638d351e42c2c5d7e5d30db8ca648bf816a25354e56db99e1bd662cb219261cdfd3fdc6ecb7244740d2e933a984ba805285610e902a50b15d8431c51b9f713bf2c063d8994eb02824d42fcd5eaf7df33553e5fa8e879aaa67754bffde9e323ce27327fce748669950b516af563845720007ef75385ba8a654c8763b980824c3faba23fb5e7cd7835021adc896d0cb8e72a7fd73eaf53eb5c942130493a5431639fc61f58ed250c515e91af49795f44c5904a6b7ea21cdfc8bfccee824c627a73b388ad87f40afbf1823775391d5bb00afd9cf677c6fe7c5dfd1ea68749e3c3064b47486e5a6da40c4cae4d5ab257a337199c44f9714387c454ef11aee40d9cadd553c49970e03663d1a54452c0714eca261ce1a01ea1682f54788148fc1c1c661bce52f31328debdff1cb0c07d40731f76c67eaae42c9017629a1d9ec6f95043579a7466ef56792167d391b6cbae3b22d190e625e05bbc79e7e98aeed6c65d552b5a5d96c9c4b21c119cbe9d128a50011f71ab1e79eb43ec03625f06dc2e5dd8aca6b877b5529c435d348dd3f9a3d3f785c9353833628ad299f9eeb83ac6c9d3ba7131e0e3b42659aa11a06c181412ab5a5a35575e3173075624fe6dde92544b0efdd56415b8d743a5a8ff40f619c007908a84fc03cca70f8870118d416ac54cb78527814ec179e341c150888662fbd0670f712736ff8b1b44f25cbd83a9d7436542b1cc0847b155b07c0050b5ec8a39386c261132a2e08206805a30d8b78979d1c47899585333c74e8c3020742861a08890f9f77581b2b69a85df1544eec266f5c2433fbf237898d9a1fe14c6e2df421ba5633439730488a39e05bcb2a8fca53f4a204b07dc6b453b691ad79cce89b16445ee8943a566ee42763611c886bdfca8a75c16736d76711fc76a1b9fe08910689d9023cc9b74b19e342fc56aefddc7aa65f6c0e8b87bb7758003aa085c88fd53d8475b3a398e43047e5d6e4bb9d16fdf7d00c29db9944b960d56591b84b700efca4a0fb4bf90720c19974e52528eb5f5b04f6de77e1e55c063f31c7d69fdf695d560dafa9912d394367e4fae071cdc010760d2583da39457d6ad453fd05808f7fde52885a4a34bcd677dfa919fb63ed6132413f3c5afbde83d053d8bca7846e6b7d07c656d93055c08783ed9a3a9ff262caad95fd8fb24e5bc33818f3b289fccf6af104cee201bdbe7411faaa6adb058c4074740cc156a79497095ea3a958dd628851a38a09cd315f452adecb7c4a98dc197448f97ea822660bf2c5a55823a985abd35e6893dd2f5e3f9b7a1973e63b44a30194b37177bdcb13b3cfd62e3090fa2c51934956429bd7f25d4846bd96af054ce670a78bbdfedb1e403ab76824668d914a0ce155ed088a76486bb3be3ead3026726beb2493ca5538370aa99caa18b2181c7ba9a4de66989e78dccd05d79779723d9fe5656de3b29c37adcbf0476df2ce6b0cf6da7a1312db481eba2c86d32e129513eafc8ff2f57dfe5acfc7603d6ba9d6c72e4c9ec21d1fd88df9145e9cf336436c5171e60bebf4e0400e4601d4e9f06ea62f1cbcb50bb41c13c70f92bb001edd58910c4168f5ea07a2a1147973b901a41f0ee52c4a72053cc316bb70b635dd2b78ae12be8168e0f31d77e3cfcfd65055049a2af34e41abfca2dd7e792a3b949c561d34b3054be13d808dd6c1a8652fc6421150efe43a1f560e6ee468794adbc9113c3da36e3d14caf90ee65ac66e024f830dcb0a0b205679e7d8b88c04437bb20acab404f1b3f4df6d4e40d198a3e12570adc7d34e28db3fbb3a937e1f36952836849afe1948477187e517d6fbd52003f0dfcfa43c424c98b2d33fddee4865f9df0381c84924677e483406f330a3be91c86168f727be3af968350c80f7fc48b685c2b9e2509132603f459a075adb1eae1eea725ae8bbb2efdffbb0b1efeb422b3463f15e6d33f6dfe16dc722a3688880fe76522d5ac747a10639a111f91d2cce29027853cde551a48b8effe4d2ad65c0eefa6859a5a013d2479cb7aa0483c901d95aae212353619b8a1ce83c9e23fff5f272e238c770c1f7ddb8be0ddbe4d925108e667cc44f6109a4cc9d55b2289e8d7dc3c83316711df947497badbd841a564c3f73f906df4ef749b0b1c237635361cf07b11e7fd6874d4a5785271507cc368aeb6b9fd83c8d75fcec38c1f2254d9d1c1fd38f863fa0d2872bf2f5a08a7a4031113076951c3acd8abb197d43757769b4abfc7d383c3f970f4344bce0e53e3a23c347efc879c680a75457eba2d311a177e84ec824d92da6f950f38eafaef21e320ae79ef913503c9f163921d6bed342ece99a7443367f85ad2365cf2d4bebdfd10b7725612ba97dc17083d65688a5c8b82c75c0857820c1cc3021ef0c3b19bdac68ae6b810b38f6a747fe436b26f9660bc9f17fb98cc903caefb0a0001c31a598fad8b1a2416f9f8ae590858fd7a20e16e9d9dfae16cc5f0807bf8a105a323d0834312b21a3ae89308ae2df16a6615e0fb8623baf30c2ce35147d8c74a548aa263575e88a3d5fca9e05254ac6576fca4c6f6056b1a6f159cf5fba01cf337f8be00c7af6cc8195ce0bb26fe2d0189c7a44aea38fbffd0b41c38531b4cfa7fe3d4655f45fe40483ceba83394a869a509232d15bfc3fbd7de277140b4940d42f9a223829db5b98f1df5b971c549356ddf01771f532a0d0b2897925f37142e7c261e44d8af699ab03afe4631b2ee299f05b0845e4919ffa1c5cbe761082b325c1facf0184bf4a0abbe5af63db9a5e143c675365cae15adb98b38b5819baa557432af684106c63b8f5cc1686ad5f1636293b4e6cc6c2969b456a535efe5471c75816ad6ceebf85abae4776fd264effe9ddf8275aad4a76d9859ff451946539b09476add52ce3612fc0277012243db36fcd80a6541185bcdf24ed6c434da3e293fbdcdd33865a249c9050ded167497d04d5e2bd5d7813c971a551157345608ec08e512257738d5ffe83e497cd114eb627b3b2f280355c9e54e0f3e51a7fa63eef6497e74d30c777ffa3400a3e45cdae31fd54224f8cdc99ae036217ddca075eb09a7ca55916121236529dd9a193c465e9f7e94024bb7e7908617cb8ca4d67571b6eba4592ef1918a42cba3e337340c13ff5633060f66c1fb4827f70739972863dd7088cad93642293f8d80ac42bce284c5b8d9919825eaf8cbb3b91933ff9f1bf8bd6427d7b1eeef2619ef42228553a4ed7db9dcc5746a2adaa0cfbf2a7592723924a79ccec24d4e317f220b7cad8a3e4e9fcba7570f155fee32c0942ff98199fbde713e7daf48a7a3c101114efa043414662d92fabfa2730bf97003a9d62b41b290cba5915536c017503d673f0ede3524e70629a815cb70d6f8c4dc85e6bab762a8dd2b80a82ca2b0c5b371124a26a67acd1afde311bea3c498bbdc431a136da95e51149fed2743d7498235dd8173a3b3a7266999b9df37451a584b977b419679d65f6013187ac0f90be74b3913f95d33a5d6d86b4f77b911b6852d0228db52539a7ad2d31efe90dc01b16a3fc66246f4f8d20758ee6d63c3e73c30e51ad02aff04b77a5cd42a564af0aa68cd75e706f628198542272b4e248542dfe6f49bfc98a35a7a62f7b472e962eb68fcf1d70cb91bdafffe871e78d33b6257e054a7d3766f098a570949971e57698819cb669e24a0e65eb7723ca2b22dad188f0e51e1835d16910222976c1dd6e459d67980df5de03a727b04d7b464551c44cd91111ca1cf6644846380954590af8078c17ab34b7cee7cf4a1ba9048118d0ec1a94bac5f5c46d8f8b77650c8829c17653b28d89b664c3c2043fcff1554ab9eb29fe61de4ce56227b5592a0f79e325d98abfdd6d39f4122be49ac4620bebfedcb35da1c137c8ec684d24178afc3f702b3a4a8b1339b8b6af39de9abd3820d622d803ecdaa7b9556194e8e86725fea492df51b29a2584bdd94f9b187c5f918ec93ffa0ca18da1f2d773b9014ccd8619b56a95e9f1a8af35f14188204f4e87bd30bd73fdeb40c21c1db803420bbe58814addb09230a701285dd59ce9bbb8d65d1eb8649bde8997d45111892a454cbdead0b7fe97b685b36b329fe528c51ccb39b6a27142fcc48954bc70e670126dd541af713fc4265e1c86f87f310cad89a114829cc2263cb74752a429b3b5275f1e44a3a910d89f54ab7f5c676e3efae75fb109e93851e5530e6f2396618527ea66c61ce6962cac3aaa3a25339c9da67549b2df305c74c68060337702b8bff573acf646f096c17d8a04ca167db058ec356182b517af1f3bd992207bd6889ba187932e2cad4a41f00552a2cbc16015008e5fc623e6e0feaae59546a42658ac211b3a90bd5458d2fe75da61a99202bc91302c56f200b81653167dbda76aa9a56332c94f87f722844eac2e13a62f53850f76070d4f3186a95b865cd1b176a0079df663f1173e7f87450e82d5d488d832a76c42180fda357dd0b4c71ddd113ef6584f7d9526d0d5c9852342480072793a7ccab444b9e3881eba8f25f76126d501f7782ffb114669dc8cc958fbc77e94d22ed453e709bf902268c176d3d26c38a5a5e9279440a24ccf8966a9347658a6878ab7f190db9d2ce4987988f4487e3c39c812530da287d952fd4431a013b2c95860e6d1e8fc35806a0f7649f88a406af405caf15df7182496fe7bdca1ad15b8ced80b437f821238af4cddfb31a2d081b9201125789b7fa8d56b967ab62377fcb92e375e87e4de813f5b8dbedff7fe004c159eee517886b259aa208940ffa9e7073ad42977e89ec5b29fdc10679262d8b0b1a9857c767d611fa954b0a220b332acc78af8505d0172c673261c715b54dbff7ff07c4f3fc490b46d123e8701e5426332cda1879305a12910e1b65df91ae96af8e890d918615a55863ed99e7be4f98d0a5f22fefe7b4455158adaeb1bc73310643bbbce01ddeb4a59e91c8c770424991be534ea62a2426373ed05167c989d68c6f630df9d19114452afe0409d817ff2ef2b6fb39e05bf73c8156b97a96c13d2f5b6db86ae6e9c6ec5c791a42fe93e29d8a3906dfe13ca1ec14fdcc7d33484e51c8e71700baff76c5277a4f72fc793bc15c06a3d0678712262e0f10488c2496ea704daf123b7d03fae7eaf5769ef3a66dd17fd481263f29ab67a75fbe971b7f291364f3c9e9e37120f8a1de5cfafd93b41eea4b9d163d597c596d4f8f842742ff7da96516f0889765f2433304d3f9b20f5ce419ba393bf0fd2434a2fa8fcc81fd09617ce7ffb9b49163c02b77a690a74b1aece8e094ad37db7a71c17903b280731c6b42d0b8b1562ebab7ac0cbfb126e90ef39c5282636c0e907f82c24623fec3755bc052c2a8eb07cdc4b7eac92a6fc0da6a4680a999a94bb001c81d192785d81f7b15128a6d26def920f4e36269a12aa55a181a49c9511d821ae67162b0f397ebd2ac1a618c85ba49f245369843dae9860043d1b07df043ae3ce57c35b233e3108e3c915ff2e72d4b4490118df6599b3d6b4d41a214bc71b129c50b6498153040dbd6d4f3219e4674f0ff3e21f9a965a639c2cfd990803c305d98d71f6e20e4e35e47b1ff3f1cce521da9ba7f88e2d2a77b902834376010d97b63611838b7e233981b3f9f8ada01b58db1af6d805eca8141493f5da05f802c85e4fa2e2d731ccf9f17ab6859542552e867e7a45bfe371c77a9209fad1ddac0f36eec8f3a0c83c53c4572d9e27e6f33a06d3ec3ace9c6e31c19c846d193398d495a9036404673fe635e6d519071a204286ad258ffe3994154d2a03bb681ac5c4426e4fef3470c50f3bbf4a68e5d7b3073c64284ee497608670f74bf5b83258803b62c3b1fd69f1894d0d52a3578882954052eba3d28e013a7364f4f55058d32c6b3c09af737f4075367939234cece2e08fcabff9e470cdcd8767cf8d1d1cb028e762d4110865fac2c75bae3e2d485120ce6edeba0600ec6f0694378839c9a763d2a56b84a4891817f58fb767d24a17da28f645c9e7a14f8a569233307fa42b1f9ace0e3e04ffb5718d4694be81082323261e493eec2a4417aef1baa38f4cbe114fec689423cffc86b036db5d432305c4fce64b030184d3879c2605d561e7c4c6748a932b1bb3de559d1e4f36b3d6f26c0cf59d2f55a54bdb52392c5c25970eb63cd395c1e82395c72fb0ab3cea4667dbafaade6d38f04a04b85164f4b961d80ecb4a8ec86a518d40abb7fefd73e386b0c7891897ac4624a470626d19f88700057550e0a73645b623c7e93c12b79d2b9b67a33249a9b7aece37bfa99c6709b130b4ee4368d82382aef609f4a2d1ddd4c6e29eb7c25592e1ec577fce40af93abb8ace75c6f88d1bd313d835645aad06173d90d8aae32aa5ecff2feebaf2de2d75e663b1e97a578ecdb939bd37a70df98aefde6c7d857ceb980319fe0e0221fb57578bbcfedd5510cda9612b4f78164ca8739befdc094365f38ac7be6f7b92540d8d6e94422697d528550fa3bc6246c31788c22ad272192218984a347beb9551e1f441feeddbb4fb22b647ec7a3dd09506f187129071eaad984e4d20097847bd8d904604040b99df2876318e23909f60775289fd5798eaf77cf7bd26083a482f2ba832bc70a957127fa94b7fb865faabb0190c4a7779937280590e6c469063bfce7675ba72c6aa15f0bb8e4f57f821ea6a214638b9a773f15f55d2bcb0992583a25e0613b508cdac65601d8fad62f9c3b2859c244e21dc792f2d06c41ef26346981bfcc47542c738e22e0071f5e41976264b22cebadfb9006e8ed35ca2bdda25d1dfbfb4bb36b53418400d7df3a01ba84c79ec4e2457b6e4d7547356b63808286bb3a5b0f9c75ab9fd178bbcf08ca05e5bfc988d69f41872813b4ed39f06599eb3a803506522bd183889157d96a118f6e3fca0e3e942d4394128e1b0a85d1f2fe19818738b28ed69880c1f6bf25e44034688fb35b34512bda7569bd254be55a10dd61686e48073b2d193e4c91f1b2ce4951903bf25f725fd7c693a47633bfcea7f3358aa4b87f0f0c7777edf02320000126e8b68b97e77b2d14430015d85eae006840742b62d4cb256976d8bf92d3bac69497fe12ec1beb0f44b457f5fa9d68a17db0193dccb09c5293c3629300cab3ea0aa88c7bfe5b4d2261c7931831459620c45bdf98f751c0a6386236d0a80aac616c695e11a0b3d8fab70f9a3521e1b485508e9c530fbe181f8446e083716b288c04de43998303bbb99f521851e7ec9fcbc4af720a70adb046450742f74f6b7fe03887b7a3c708f173cedd14fcdbe266e827d9e1998af90084e47baadbbac908aaefb4cf9709812f4a33402cc7fed4c5f2bb564d81bde234aeceda0f3ac659b57e324b79f3bdbae90fc450506fef70eb1cc12077037c69179741d4cb81ccbae76cc01fa81978f9d3d5ec3f3d573d867eea64aace0ac101eaf2e8b0af8ea83bcca8e25993b110941f0716099f43c05aabe14d0d3023fd3bba90a9a055c27a72144f45ffca9600fc95a75ca69fe74943c9bcf1af275019ead572be13314781301fa6b50ea942cd4a9f62e65dad05578417854a90ac8ae31b3bf8611211428430fd67e1c0427867c0fe4d4a00a7fe4583fc82792f11db1942c02d162f3a4b688041355188e09590fa9f7b6a989816182db2c27bd1f61e065b57ba69cbdcdf808c6871e431624feda633caacfab20708575886a0ebe9be37250cdac792a4630e08212cf1474d18ce6ca67da74ef12e2ae97bcbfc524eac3d9d96a994d51f1e04b7fda69b28ddbd997f5f8d31596748aa715d24f8eb1dbbd03a67a5c86345fb1ca1b73faec958710fc32a4f1e58e4152609be611ff364837f966d3dd2bf6b84c0721468ae26df275aba602042add00fb508e64168ba97239bd5682351af9603ccd73601be5f14820879405fa13b0deea88700558bf3156e3288c1a4f4707804e29f26c6d900e1b9a8a712a23fa1fc11689ad2b9af814770f4279f0cfb3917937c7e7025334c909f706917e7efab1e63185b6ef9678496ad8cc3c2b419742331b718034e1846e3cb625b07b4fc754c8686cfab20e7247508775230e1167418247adb88595ae10c9035a47122c5feb081cb3464da0736c435721a2a91ed8a24e02df32da7fa0a47c7d5f40516e0ee13c85d2aa22290158a733d1df7529d7d2f54e933761675637f586b142c7bd050f5a76a2adadc20932cd824924bb3b4248dfd3ed64d07549db3969a8def52bca7fa2f0a7eb120a35f31b860e386182c1ff577e4ed8f00b2d41c2af031006e4bbefc66ce1af25d3e5f19e452329fff13088cd09c76ec1a5b91ed2489cb70d07c69d9139b3637a8a3894b24b2926918e21a966929518f8280379c611246c40435c7b3f46b52dc28c78418bd32b5ec1ca80de43a74f5cc0bfab067b06e441bc468afef92132a74e0fb498a48e527f80a6482151d1f69161230429c32f920f64320456e6ac90fe884fbad545bbd182a3c6b1dd84c6f92d39bb294ee93cc4375fdf30f309eff911030a4d2e3b45018f09fb9f9b98d781ba37387ae557e32b6839a06dc063e877c3f4b8c273b74aba6969b6549560c7d44556ddc61e6848aa7a37e8ec621fcfbda1d5eb54cd9916e4900dd43203e7460bd3f8b321119618add9b06943545287eccec134bbd1ee597b395737f012bd372fbf7f615f93d840ef291aa4e4245efbf42ff95483c36e94829f7b0bf72aa5c78f83661f884fb721606fd5498f17eb5f2cfcd318f9545ade63fde6ba0aedf4ae7fcd1fee1aefb7de7d931363c04dac704c8a8ca27a94ce672bd68485501bb92e41fe078dd4c9187e515b8dd0dc3b02617199fc84fc61675cbbd66d357f53ac562bcaa4dd49ae584110366dc417ca469c2f0456480c34f7f391a0b81c2aac5ba9a5dc92aa12c7d64d3b5489ad84c9d653c7b058dcf76c40486139023c95f9f82196169408f3ea71b85ec7408c2d4e2b8dd24170bc336da0aa7011554f9c62952d9fbd056bcab706fe04699cb165337418a522b057862d4e576b7c8da336ab9866d92d4f103741f3790a22ab1dcfe84abd39f25f760766470e484375f9c81409f700ca5764f53fee00b4a89a724c76c7bbdff7cdd5c38d7b3c2fcb132ff8096604173bbb59790b922db32ec8d08922e06c19f9ba524016df9d4679a1053b2687ddabb17f625fdc364e5161523945af87d44de8f5f8373b5fbed741969ea1026eb5649bec8fee7b6e15f423314db8d10555ae4470b3165084f1e3f5caf2633670675f2a308dc0e4957e611183b9eaf9c3321faeab550c49a5380bc350902f170e15dc4d452bbd86ed3c15f548a8ea5a419050046a0ce6a5396f2ee1626c3dcbd476d035cbecab45dfa1517c82167ced8a983edbe818b3599e09a42e6be8ac2ec56fd7997628a0fcc44e015a3786824108b4aa4f3ef0d445385a915a8bd1240c6bbe581c7901f727a6c5f44380aae3c52f991261b7b56273f1d763125b098b544e032abfa2c69fbe6d9f8d7dbf9ee0a4c235f19387e98afa137e3cbc0e3e2171507399fbf6a0c751f314f148fca68dbdc0ce9da2b91f961faa28eb43f0312c3165c9ccf2fc52c477e9e9ef69fcb4ad3ac90961412b8992bb904f808925238db717b13c10d7f4351e4623a1d53d468a7d661237f1ed4d3645d932b51edf9390ab5ef339e9b44073f41cb63acc43359f6fd4bed0159c1e09bb8cf4e64b09cd475a73497723025daa588481cc8a7ffc3e4ba81c1509c1f375b6a3bc2707dffe8ac69feab6d3897dd6c52c8cc875f933b0f6d0886c57a8df4ee76fb499cf92a6943455871ceeea169f633e646762d86796755da08897ca93cc19513589de6acf6c3da5fe56cca561c29601095f228aebd4c8721cbd1083c5e12f3bb9c2f0014d4f5ec8918fcaa09c20e944050361cf565cb0dfe98906d3eb83051ac5ea52afea95f2ba58327cc97707e90bf9d3fb64a274c8d6744695feae96594071d4b412bcd68d972e3f0295e9cece00047008eb90ecf0df1d576a69f97ff4e9f1ae98083e11a0678115878dfd8cc9269a9aff53f8e3ec795ab82943b84917283026e52aee7513a9f444d4c9473c54611d09f7c97be09070ab707a1ec8e7ac191645068868aa97225f8c8aba220139184d351d56a2adf08df72a19725705b982c56650947a39691fdaca2d005c82084c35db1812bef0688b3d181e077289c43f796ded3779ff39c9b550dc3edb2cd960cbcddb47944116e405483671a614210053320619f5be18a960fd0833d86d636ceea652dc74b9ea1b8a21bbdcf5260028940d50ec314daae05cab9a229992639157425d268d4def505e95a002b9dbbbdf51ae2871c10e47b1345fb5237330f1f2bc8264945329002d4a8901f74947cbf2e3c2980b7e6362625026b52a8867e53138848669af749e81f7b7cde648c113d4fc4e6c2cc0631865addf0be7b469b5f1297d62d84c80297bbecba89c8ef75eb2f827bfe19d4826ab747f4a0fe70a771d6fa84c13084ff29f6beca13528348e850ab8ae8604af203c9d69cf4b5fe0a4f406e9227520d0f9d799328f017537051ed8af9adf394a7995684da6852269432b447bcfd5723e6dbe12b044e6be2f5c1f883bc1dfeb0ed2162d666d90f64a9e024702abebcee23952c5ac1e7bdff47603951728e4bfcc7e9f8166302f52bae015326af52a4f7db992b56ee194e3d245c4a60a10a3dedccac2044568998d52eac80177f215be959d77c66caffe9fe02db34382169f26d52e0d910705526ab7132a19374ddb131eaa859d2bd16d26b011d1376b3cddacd19bf7b8afd9ca5f397b9c736fe0695de80f30463b60038d828f5aa7641efb37d5784d3ef2ae1112638f92618eb5d653110e4f4f371c59a0f74078b089ee06177deacd7cb14b1ebcccc20b4b953c56ce304b1f43080a18ba3d05ddeab5542802d0035d7e19cfc3ecd0ac1613dc9982809e51209ab27545c2d51779611b8e3909acfd884961fb13de67a8ca0eab55893f95976dfa0efb3ac9e7bc9573100d2d1f602c6a2b12fd331240b6c859653e29023df77e32985072fd5fb824751c762ae78beeacfd8eba0b2067e13d2de1eff3398d56a621c3fef876f12b74b2c946fd8b9352ff4d7c2152738b9e956bdfbbc3830af0d17960f2ea1c71d828ef30309d06764938448708e8f2372f96a0be5d26cdbc99d3b4a112e5be7ee61dffd82180b897fe026a6f64ff03b189dfe30ddddeff3c029e287b1cbb9f50f141337fb5f7ab2027f856f199003fa93fe8a8df8ba13358759a278181834458ea661275c3a2f55f3e1d1c2c015e2edfe800c03754e8e55e1682255a4f4160f07e8674d72627989ea62766793a80a3def75d9aaad6ecf47b82a249315db33344c6b899dbc43cd7d61b6831582d335a6dda0f77d2b596d218c5451cbfa0e117cda706e905dbc41be3ec026487674810231f4bb9830d818b2acd090dc17f7953ecba53890dde43d8c106896bd6ab81f3587a7df111a0b2db1d9d92475421054ad6b6174ba7c5fc72b846992f5ca235790882b7e5c7b175995a0645c7cf9f7f259d84642032eb9742a8cb41e6cfdbb634dd57a33462b6cf0d0838d1cdda65d44dfbcab6818e38805f0ca82e52445e9cac4d7236bf596e84b76c3dd6920d8300e40bf78a9b5a581fa261dffdae622833189767f68cd4cc8f59b3ca863dc254f7f95cdd3433add4759d42705615ca1d286dba5d728c1f161685d922b81ceaf956f65a67bbcecd56cd0c555c5d464765955e5c63694199fb95138cf194aa776341a155144c3463aff1090fbf22213875ebc1cc32eef32dcb788573af80c0a44aa66afaad06df1eb50f5333e76b14d02d8d51b0da96b25aeed759cf4587afa280fa4b56ec50b6c18109eff8b51500ccd6044cc24d86a61ba4bb844fea4d9e69ea5af02779e19faffef58e171deabdd15add65ae74aca2e463bf42c308966c7e25ce23d43aeec757cf3ed374a3ab048f7bac0d4dfaeba398e7b3b3f299aa795b6b51ad33edbd0493cfb0443e29b0dcc95fb6787ebd76c4bf505c30d2e2981a99002e0c241b3955d8e0d23c02a23b358d49acb1bdb7d8b8d6cdf8ff9a7a72f84349394a0fa6385c14f9c8095ff1d83687fa90964793f97657be871fa67a8b0555f20eace835d8e756f4502bd7cff119ef6c2ebb2b1378cb2e6a4a6ec8d0383f434cff2e0ff4ff5f8c3e4bd6f0690828e3c88f1fbcab7e6461cf7443e593442336c0629293671e880bd36337abeebf7547e660d7e745e0070d6a88e9667eb70d28ca34f26949e064b40bd8643abb369bfd6451570d21354b1af2d6a4fb25ea30674cbe8bae8d79fe5b0e55ea1c151ebba363a9a1583543c7df7bdaf1ce90b8571e331915a52aff2dc7d38c864ba59dbe009c49d1351d18d555f88588c99a6e99d5a065793899aac8d8fdee8aba013302a137fb2536f62e76fe81185400f0e62741f3e567bdfceb9591bcce8447e002b0f9c693da9a024157edc7eb52c8e6ac4c83511367f87c4a9d96a923519dc18662e783363a02035a165eb957261dac7a4a2af275a96d12309eed185c4975341855b880b992e2f8efa534c5708a07daa35ea691484c4180edd752a8590bb7efdd759a8c9cf2271932d70cbd9faf970d1f2da400884ffc3501a1c503987dfd4ac46cebfb11a3a4ba048741287e007b25491e37cf2a1fbaf65eb504208e440cd7d483a1a315bdbb9a7fe7d4ba27c64476756c83b77bc2d238bfc26a69495e11f505fbf44abe4f9186463e2d5083f4b58f44e9d297efad2dce7ba2f78e509df339493f2aba67ddf1b24138395a398f8853044c080b64e0204295dc50ca3518fa160ca083c7e0a0559ade3015a87823af2c450c452b54352ecd559c2d255ba8cfec34865efe034d45f40a7764f1d4ec47cdc107f7d38cb45c9daaa894c94980693dce3ab65d835ba36aefe0d82bfeda38620ef6f880d257097e9fd81f701dea22bbbb670a196c7623de79a7494bf16f9da6ed14382f4731b412e5fa43306b9b9621f1960044ded4ebb86f9a5860c3824db6c34fd26ef01714a1b773e64ea2b1c0281172c9ce39214bd76689087e73017822c74ec1186794e621c82f4cced8a286fbd99b2e7b25b5d94c8ebd336cfe751edf698cb1187a79b2b31dbba1454f819f670338f00dab142355dffa3c56ec63b9f33cc44685b6a285257a6935a78b4a53f07b7ed96b7dcd68fb83960bbd16a966ce06e575222e6577241b437c46e0a4324e3cc58ab14c463f476a27b5b039f3fc2fb5dc44d3c305efc60228d637e2c3950d2ec1fe1d2a7d139ebe321882c96f9cd721f4bae63189b5eb44b85fd66b748f487ee41000db8e47e061302b2694c74244233d065d56bc297d16b62b9e8214df75e97329be689eb96b067a406b33e76642c3b7a068c3c688e079d0c5406fff6c756ee94014a3950ecc52b3cd74d6c4e179c6214bcffb24da4d7a2d90e91d9b7a54094a6204bdce4dd09a5817d5e688380cf5ac9fb274014beb96d0159235a2f54e6c601eafb016238096c8facb904f28c4bef4347485edc41a9cda4c362274c17b6e0312c0b0d4a9feeee87f5887d7546626f85761e6890d8db4519097a510534ebb6e602c69861e8a44bb8d61c0673530c9f0ae768d29c7d9526bcd80a83391a33e307b771c9b5e7d7fa667ddc9806a554d4234b2a6c483f6a8570ead582c4dd9b81cf28f3957b34087c689713cd090e3bff8dc38d099398e700d89c60ffccbbc8941742aa58f1d0c26e91fe0da45da0755781ab9512e2778fc73c2d995f23c0bdda40a883bd0b2af10b0d2cc02abcc8edc198e2eb452ccc0443ed869f231df62b57c6e685ee6d265b19955424f459be9bf36b0f56c3fb6282c5c3cc9876b390ff92ac2b6b55679dac839919946571680b00941853f0bae853106a193c676cb284c3d9ed1a52df4b035af1c3927cc02b6b13c7ae6394a651d6a55366f2fa6d59295c01965438703b9b51d892d2dcbd4c2b6883c290c07f4adff83e807601b7d3257687fdf75d46fb75d5e2b04fbcae866db0119c08a1d5e420c95d926067aca63ba676d3537921af4cc229ac5caa7bdd9ae422ee198d6c5183ceb01a2c114e720c05846299c3aab775caa56239e358a682a0c4593f982b760e1c5860fc82d3f00a6287f8a9cfcd36249224742ec080b749d1ee7deb13d8eab9f68a017556348092e2efd876b14dc9b18e39e1a153cd4b9c6e39f02ba26b70277c5c3873bb92c30339b0bddda00477764fc118e49f4e4caccaddd171d43614650afef9c37235ace3818ebd6ec530823b0b222bb952ffc5df98edf9fdcc33d901fec15fedb1adb06926436b7f3bc77ad3c691d41727fa615bf87d600cee2c75d30126a362981e7c9ba4459d20eefbae302a399d6a52bf8f1376a736f5ff4ccad0962ee0dfea58320e3347b754d13672dbb5bb546d91564b758ef5a9af1d9ab0bea64a72d489247d1f2ebe8088e9ccbba0e114cf318cd69d3060f871847d65620d0ad95a06d1b360400a47604a567d79fdc83f1c9d35d48e26b0de64b5b18bf324e93a42cc6366626562ef003f2a80811bf06bd60bcbefd06664ce80063ad689fe487c7317082c43a26383473337e570dbdd9fa69215510492f36d21d13360e898aba6ea6f203423e890dd350ad523904d77e58680a24fd225e55d4ba727a1c2ea0583f6c95615aa5b3f5249bd5e0f5a9864ade4667c6f380fb29a5b4a2769f7babf456cd8188e57c667dc74da272ee658794c6ac45688c482957f1315de830632b9fb2e551db458083c4743a9cec5b61ad2076e67e86157d00fec5b3d1bfe5034ee4eae32d3a6d635dc1e45d634d214c686271b98482c3717d2bbe3fbe9b068b287ad3049afeab6b71f36e7f86235d8918d8533d5b01a645a9c7bb476e82bb4ed66eae3628e916598c941095482b431efe10014c92bcf796b12a1fb54469b268a4619f183cf7c45b237749f9c1f67ed4550fd8ef38bc5483c78f8e308bb410312b3d400aecd94be80d745375604cefa60271e6628ac7f53d49b7ff1086a49c08864821784687a1bfa1b1f17e1db1f6991a9ee8afaf3ee257fb7539c45854a874b98b1d7b8387aea42b300fe92d9e09804e25c9bfee81f017884b3d24d7b72eeb4667d80dbb6fcf61d7bdbf03225aed824ac9290f378f534ac0f7529454c3d9b054934ddcbce3dda0652d1e37b7eea2f2f412ae821ebcad47fdcb72f1be1bfe80b50d7ef077a60adab0f83e3d9e5f8729360bcdff87a139054fdd303911fcd1e7eb874123bf4985bf4b3d39f48bc4ff602a7bef63da98abe21604b767e706d7f9c447bf763704c8b26bc6b6a925f6deaa0e09e4bcab76d5ea3b0184cb6715cf2549f2034ea2f76a69f2c27c23a815703f994faecf12c3779df0a3452968491d43c5119fa8a461ce3412dccb9f7e84eb9ca86ee053c8e4fc0f827df765941eb9e7e8545b54f1a04402842d147bf7752cfcf4eb3d7713ad52d11a043469944c22d7a5ccee049d8bc910e72bd9e0bf0983bebda2319d6985bb12f25d42e21c4d8373a89f1d8a91daf387c5f412948cee182e675a96638dd875142c9f751d8d1c60ef10e41c8f3e9615d47b8d1b295946f334811050ffd81adf2d464a02d8518e2f5a8e69a082c5407c80912f52be5c3e907d590265fbba4ebd9e945fb2470c70bae90e9b506b9be6ce1c6e7437ec83ce5f1808d0c0596493fb5e794fe5ae70f73e290ad8108cc3366850997f895797f694b9309f1e6de9de4abf2882599f65d8d47e5d3affc3b559681125137eff1937857807c2841ea0e78646a4307cc9191a484c598fbb6f88b4040a673c6303746451b005fe505bfddb0e8cef33317516d0caf692058f2724d65b7393d560ba173da67e36da726f77f28aea82159ec31a7819da728bae6d56bf15b11464152a0adb87940abacf90f5603c8059c9e0ba71c17d2323f74f4a26ecff5e95f3c7d445154ab9972b3193510fa9ff49092e48057ebd7d4d8d5aafdc0ad2cc30e09f45733f17769d69990fc21bfd0382432b389315da5876592b513ffea6f4237ef15b254d7187a3e72aab4af8fb93cadd742b1961ae4298b48dbee037a2cf93efd0491b9c815e35296bc1eb44268d878be01755e81bc83ee96d0b725405ed0c46502c707ca47980a7e2a01533988a687ae30d218e9b3b92d338fa22a13973b3a13fd14033216a6f78f14c1906ead14427dbb77dcb0e4d1188f38b99c4f93252d0dfe2c7acfac741115040951cf9c8d0bf678cb2d288129df4a1f0a26c46e6bfd2980e9e4d1b1e4b63a1b1798892f6e5171f60552d1cb1d68177a1d650b2c2a866b06f7477dfc82defbc625a157474a5f678744a0929dc0775005642177c86826dfc33cb1eb6cc772379aeeb7e1712a86b470a7a86a1f37d0cbd67948f55a8aeb182da374b5f62b1bbff34eb3c555ba68edf9d3527e2ae503e81d5d8ecccca0c931e5a387c8c1374cd669085a10d6092e86eefd8df6cccb8010987d2e4694939c31a3ac1bbee721d1de21b64170adc3ed6841ccfb156c962975df06b102dcefe2cfed8e445ba42f5b3170085f3b44b53f2fbb98aedf34bc841f74a9e30ba37a0c6f77cdf8f6fcc12fc58b2aa38c869974ea02a6f1654c258d13f8bb5d0e30bcb30c5f7d055e4996cb726a7e9a08025ffa051d6ab9f7465356e11e941f212b7cec41e136641af334c59e453553ef33d9f7c306b97a412885cf8006893f4586b11d48b2e543516541469bb7e180537b1a796f58cb3a05c1301735e78788f315ca4572b62eb921ab688484c2cfcc6bae9074b87fd0b188781ad394dbe0b49a89b1a00865c830a26a54d88ce0b9832bf06032415c9949de96c31d65e466b72e3b2a90f78abc01e8b8ebbff0efd5941bfa6f8ee9828035f88357204900ffd991f84a80ca26e6605310a2bf609ce4b3b084bff40ee13c1628288a19270f8fb239c191a6949f6e08736e0f9eedbf546e2a3e9441d0e6e6f80fa6dcf9682c77448b5ca66c1428ba07ec93fb125b79d29429bd170cec7e73d9eccbae265122ac141a32934552ffa9c9e7abe8b1fb093865d31c03075f2268836fd1ea276028832043e69efe076955e0a13fb9bbbdb9f25362903925c946a59212e6f573be70f197223eeff82cb6f15ee3a1bb0c9664fe566b648597f6d93bc0166a1bfd607c1ece4c5df8093054ef7bb92755dcfa3e0bdf4c216860d088083856fce264b39f627a80b278aa2480e5bc7ae91961610f34ba7f87a7e62c2a4ccbea6cd787fe1b60e3e65567d9b855cff1102cb4c896adddadbd6b0e781aad8affba2069c1dcb0fe9f9bc2e33b353a7aa4fe99038090ddf2ea432c3941df5fc4b1738995588df9ec374274d63d7db312eca914f3722407917e5352307c1972f0e90196086b1c4e47d4e77d6488ea836265b83b1e22deab720acc9c1e951e18f68809a182ae36fbed5a53ee1376ad58ec43b1e4305745aca31f10b4ac8f1f1ba54ab84913f0899bf617a1abc023f5f5ab127faaec5716ec6983ec2309f436639d5fc6789f1c22bcfce67e208db543d083dd50f86211665b379732cf10b1e254fc8fc64f7039f06968594c63e8dea912d516dbf0ccb6c1beb4386229d34a0ca160a2c52e2c5628c5b7bdb589f4f0c7f8610feb4b5682a096b113a3259669e4194d57d086d6a3e1da741f04727bbd767e008b099b648c28fd11a21ae31cfadf651e805b1d46beae2f4921d50f55730945f013bb719484b41f513063448304480dcd9b03d8253a0ef1fc959974810feae956d2540ccb3327113163c354c113040229a87d93578a3ba264e49a3d3466148a1bc26ae6e387fbce696932acfbd02d9259896f652e3f25e267cd89df3c08c6e79a978772f2a9ca71f1837d3752384f39bfee8e8a1444cc5fc93ee674dd51ebca7a90255b4aae3a975b5efcc5d04d15dc66d51c33936cc9413a1ad6e433ad82954afb0180a6d8cbc6e143","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
