<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84042555621ebd0bd054e3702080ff565a5d172651cc16ebdd029cc72e1d2a6a152b781468b5aab6a7216ac0a338de9ba9cdadd56ceec1b011ce91ee442f9b28c4b58ae3b334ca936fc82ffab2227cf74b6c11a26272c6c3be7eed0f3894d2240a7cec50a632f9164358ed15a5edf21525fbdd21b1f12935f2ef8f83e99089bb16377c6a24f9737b24c9366c581b50930ec8acc326262016e0612b0db61f59167d6b828d63e9feec3c891dff0db2c38800ef2fba1d8f45a7c0969e3bb4896edadad73e627aa6174976f4fa3e4477cf07f6e2acf7807748953962ee3268b6b529567ce17638379e4d6bbc000cafb62b1f7de47b2c7e1534593cc0b48cf8ff93ccef44f0e00a118267fe6495c82dcdc356ff009266bea0841a8151e67f51ab08aab94c470310f24613a62378f4710309360d554f63b566eb1b4db2cd24198a4a2c9ec3f086798368bcd0f893fe74de7704fa9cd8e9fbbcb693634f44acb8c8f8f2ad6dd794319a0bbdb41fcaee70979df4779978ed48c042bbba2497fed4b0a877e7f4c4fe28a28b890d88fdf2e8779c71a128268851ef2dc2afc75914fa260b8532c4f9968597460011078d0ecbcd454c570fdae07615f2d070fa74904ff9c631812b229f7e7406d5a7f3e14e049a96be4986259252a925e558043a0c951919b450f57edf4ea02ce8ea118cb40ea5412a4bd77b8c7945c81c3d3f870a52adf1cbb78a51710dcd108b1fff73c82358cc9b48f109456d1401f783b3585aa7992066cf91ac8e442b20ba95f7ea00846123f5e84ca618b6fd72461111ea91325bc9d5d658b3a84badb7678cde16c4c65bfd187a52a874e074cbbe7b210f0a0b74b78ba7487cfc692505db22ae27ed17be044a9f7a83089a9d5a4f4519c9f19e81e5467dd20682f3fa5f783b611d10681ebc71fb224dce1533beccec37f88b11df1b223108c8cbcf13025b8e480c25de44e5ec8f82b0e4a971fc17089c89f939d03704acac5e94aaedfc072940301033079a431511d854eaaf0ea371560122e6fa459ce618190ab1188edf736e74724e91c25ba17d1be03fd81a5b336adf2a2bcd31f574ea3c3ec2b67e7b191278d448d196db2105f0f728483212b1ac18115e471474f89c36124ebddee5c2d0cc93c0446d599364c7f95c43ec916fd1e3be9ff4a07c05fc0b83cd18b4a7c5b4b3afa105df7d6738baba08f3dcd13aeefa2d02b9ba5844c89af91a4d35d336d5d94385f00407f81605caf375fe72a93109aaeeb87a5f27a5328d064655a912996eb7a60ec27dea7be91aa16cef1dd6c2e4da75badc620f7b0179b47bcb3395f7b9a4cabef4f55185dfe7aa9a6d2a4ef7fe16e01f844b66cc8e97a254536b87d5649bce897246d14281cd19c166abf88928c06b875f78d9a3d738926f2f392b950f519e50902766bc5b11adbabc2342c494e08c54ed1c5b9306d3bd2e0bcbbfe078b8a16ef68ecddcd3d8aa0aedc47b30ed4fd4b83411c797233d688fd68844c5d347a5133266890f9b691643815f9f892031d873e850405bacb0bee8e2a55aab2b85c10eef1bfdfd9fd57f4d26cb3ed2eaa2f2be2aec7b7982d402b31bbf9a5eea86203d1652563e96e6768c47fc3cf420cc0a1354002608a1ef3aba96aca685fc542add1c1cfd9c6aa26bf764407637de3dac524b8d8736334c107fcd29a2315a148bf56797bd3909854cde9a91e57af973efd62f06b22115f0b5c8609fc59d0bd23524503825d48adb2da58ad377a6eabec4a627c3c2ecbe4da2dc462541b8529c9f28fdc4beea093041adeb4424b8319d0a5e9446e5dec059d20d492db080e06807c1a2ba45935c39a600061cd4cb9547dcd79a48d068cb4b156acf91cc6d23bd07d3d71b454278908114109f24bfafdc1f433c5629e108167fcbcd36766e8eeee0456dc1f83a3313cf23b346319b292fcca52f348458d3aa62fe43784b59e654d0d6560a36cf9ce7a2d515750a3f63b7d77805b1d967f1cc80dc1d8ed23376d844e6c652f09633ad736c44f2156f02e20db50ea600d49fc58292edb6c05dfbb4df0c085e7e282884d23b8794ab4dc457ad04d1fd8b19319364466b992b9f82f0d29554b2ec7bf11e211069d45677cfe2f62df3d560755c4da5dca6f10c1bdf13d0bd1b11c71bf9d8b65ae7713556d80da6c0a9fba2062787884ae83a49338759686c7d30ce57f495db288f2e4ced285bfaf9b55158778e070ea3359d1455b09652bea998ff05b97b86e2c28d9b93e186ff4a74729c40c0d6a23f21c64fe0107e0e29cbf70b717d78b9e3e04d6479fece8a6cba23207fdaa9e3a6793b7cde99c78dd7e6d0f8097563cd666878924791613a749e9823a284277a055ff6c110a7d87108d88cc2d27091510d82b7fa379e9f9bb63c3f8783f8e245e543ad0197e4531627f936bcb4ede6fbe36b4d88f912355e256e4d5438c43c28c28d7d47eade2dbf054df74dfa615a59d81cff9daaf68fed55220df2e32e0f0c81be971af9316848eb28e6ffcc3cf9659a0622ae856e1fdc9d602662349563e386dfd9b251e8d1202f97a8269c58a6d1c5f224c097060233e3fe6b3d6716d3d572dd87e6701c06f4227737555987208c90dc5835c613d7723e50d68d4aab6e507fb2ed79668552791ad3297f84de1b8de81854cafbc084d05aacdaeb4bbe2a087d8d630e958db29499c4c002f461fce9a4f52edb0b59aa2ea3882a180c07bd8e841d6a8f939f9a295e7bb167cec58d2fa8906a6b090ea88be8eb1f49c2ddec8f08a4e4d80e1ce2fa4796b29f6460f8af2dea0b6c8c5bdd808822d5e90ca72338361c1905c8fc73cb64159fadba8b98fa9147f173cabd473db73200e12a4737455d596acf6138bcf6a8119e244c2525db3b854c30c67200757ea32ffeae7565054a7924e18b335a126e9f58a8574b8c4c9758c737aaa6c0d6b53c8880f4813ec6190d63c537de6b732d6a8e01861c0deee865214faaf797c63a800c1a79c17b154d09bddf1bde82dbd8e07f981b6a63d824e6d6df5efbac5eb35d46db8b6cbcde6b4959e97acf25bd99c8072449e1d1c922e556cc230105ede3ead6c86ce84bfad40da00a6ab760980010c5fcff5e8bd37c50e7a9f9759fed3caa25f776862dfd80d3ee2673f6013f88a40f57594330df73e9afee6e2328ee13fef50964a5c647ec49b2494380fb89944a8451afa61115dc7bf30c24fb7346cbd06742be55d38a530f9d2990decfd5dd127633ae0b065dd1007b8d3c88362357bb94545f6ff7f37a598b15ada105cc667ba26ec6029fa9144337f4e527fb7b560434b75ea5345f109f79a6315d0959c54905ca6de7e93b76645fcc9649de1759cb2aee891d6eb9ac80c9d9d8054862076fcf71168cd66309b24a345001c2265bd9cc8d1bec20028f6a6819517bc1ef470c670f5c7b5ee1b665d666219804a43aec0eddfd4ef50697cb1d28e4c5d89f7a371bd548f28bb66fa89da89435ebdb400331893dd53c07daa14b314003af6f4bef4432d9f58c694e44a70ec687101168fd0657b7aea52115c688c5283caaac48d0016ebb39bc153ef8adb73fbc40e37ac9b8311408c4f9bfffd47933d46c7fb07b595103394672f570cfe1d412c55b8bdaca19d61aaca10cda61fc185f1694a9c5e3c7fc7c135d15636ced9339d81c3f9159da515e4e3063e16e12eecc733cee3e0e80f6f0cc2e66793bc9e9b021e80f60969c641d1645a9e86133be784d511bdc1021e712627f1239a1feb83c6fa7d46ac5e4cf31ea1696c306d42dc4c23e3b674c737b4a9740648fb0163db74357d69c13da8f7ae9c75c3092ddf8d63fd478aa2437650ad3f97c5d077a26350b57049d1dcfbede72dbbad4bba1d932cb70d4a6b5bd4f6ad2e0eec134d8651ccf7c99051ea1266d5b582b5a3bc3d706a30d475951ff35865e84a2dcd51f55db85613694b83453e70622fa2a5810d099a2385c7f960122a1adc71ed56beb34d21e49e276befe5af3f728ec6329f40d998c3bf0a4370b46c21e27ecd6ab9bc5383ffe5010b9083b0232f5a44752a6e1edaf9d124f5119af57f3e0e88a1ca42b3322c168951b68ec88be1132c9e310f233116cbd5d9b0eb89bfc11fd46221e8c6518dd6c47b8d891038d3ae96deec4fe48d2a5a5fb87a48a9db27987f76680a314c946cb2468fc39aab85a0002e3df40f4aa586f87453ca339576cc2989db664463776e4629a7551e9a19059dd9f4bfe703e6f21b652f6064fe910840891952fbf06dbeefa0de1b44b1ce2f6ec03e2d0e1027c7a8243093ee1d008d624e968ef57de34a474eeb26c664aa52e6837ca56515721ab6ae5faf70447840ebf0657c246e28f8b909ed826a28ed44191e326730c5442ef94ebafd1cd7e88a6bb720c6a35d5647d6e8c135bec33b95cd3a9baa042ed0c4b031754f78ea72ec95fd1624be77e0db514ca9102e42c69b5bb807e788c224bed4c245b4f9c4048d9165f9ad36b4f98ed685f7abd7a94f878d0238598c16e8748ba063dbfbb86f302d002ba003aff0db2e5d6b0550ae6f6a4ba597ca3918aed82e7e6730fac059ac2c5cef3cfe479e106987b433f9717cd43d869055980d4ba040f840e44c7c2c6a151bcc82b3e4f0a2ad46bf0347d582f68a3c2fd2e7895f1b0e613de377207b0152154b8cf016f2e28e1ce0bb7bac6e13e3bde75214e828d644434f3d28b42136d3b203ec398912afe6a29d0db8a7e200d7d24ec5f01e5afeb83419548bae8dbfe4344a5df0b26885fb18366864cd35828069531bdc7620f9a63bc3385baa80477808988a7cc410292fc7a5ace241a0b535805b4ccecab1b8bc11ec20829f4ba1c306aae8b303b809bbe2754b9d98800054b504560802b3fae993123ec3cf1fb0c7f8991d427bef0c8de39bbd3070310f674fe2a1f801e5a7367011f45c43d1cc78f0f9ad280807ff146eccd8a82c93e7bd451e817f03954803a5eeecb7edda9d387858e5214fbb8d2c6d9315bb65073b166508e207727db737ea94fa369baa4c9ecc7bbba07d13b8b3a3b4e68dd6e04ec16444a5aff49788dfd8c2c8163cb2b5d15b2eae4c44f993aff23ccf5e952daccf9d74540428b9863a37aa49a88d56cc3465c21613be8897c6b8c1d47780e8ede542a5b2147b11cb943ee8e8df04b5381db28c3fe7990690ebbb04e4e9055b67c02a68a2af1c152b263dbec089938362d2f0ec273522cdbbc17552817b2163d8407eecdd79ab8d8dd1f519cc01cf697b372d178b947ade0a34126af8d53e40f026908d3dce53d2bc71e8d6911f91489c36093fe151b0c9afcce6cbd70cfd918acf366e4aeda738aa710ac8ec0b0afc1e4053f6d1eb732a78f3baf26ca2331edea8e19fba620c5111b74ff57d6799ab155362c94731435e969bf8a559521927e332a788a5bcbb6f85dc1baa0d2557883e1de212c6f24d538d19c9a03392fa997e4dd4bdc9b12fcdd948a8bd28d6715db40d9a840113ad695e599567e25f85f659922625d19e94821a10319710cdd8f4126224e6a5c52567f71120d011af054f61485c8f54a6e149e935d0e4c79b61cb70686b757cd10c151abe2ac46125cc6efb12f44277b7f357b5d9e6fdb9c559ac61b0afd9c677a2e6a5b47f6672490efa6a86a44711a634cb5647810459bb1e103f272113e9ee9cc380d81a1d00155c987020927e013f87c1ab61a382fb2a8ff17b571c37acfffd0d1c7fabbc5aac055e92477efe43c390370e2e5973b6d1f799709d1f748f30da5c5b4396b76fb5876c5ce6e64a95e01be3bfe891556eb92e6a25e69d5d29fca43ce9020b5bb55c1043ebecb857d7cc2a958767d0fd5c7d5733aa0c692d971b22d67d2dbfedad6da05c657aec04df986cabb0ea4b019b451762d358fc991ce8b15f5dceffa9cd2c9a4d3ed5db4f3477edb1657a716a2a9ada2d595dd4eb1baa9098cd59c228f778d2f3ea04e0e71d57c248a87152d6c46063d26a39970a24469870274980a284feb96aeaeb98ea54f3e9ca60d61a69e5bdf5ac59d2f7d85b3b3685bcf8b467f7520f4438596a48c5e9740baebf1548623ca53f7b1f28e9fae9ffbf4b9724878a1f4317afd25ba67f8e55d434d74892ace758396f994e0db6cb9890732773c6323aa23eb6e223dc37bc41769d3e6e8e7f2fbd3f9c9e2ddd619e33b42fdbd5680a4b726e42a9f0eec1ffaaea8e1e5b003f2e5e0b7111de60020bff17acb7ff1faefbb1ccddb0ef3e208e4fc06831263b6442beaf041f14ac3759783223859e3b6906b12c186600b170ccdd22f4f6060d783ab0817ff497cb4d90be360fc91eb81fe5e0407114dc658bf9026311168eef67ae794925cdd63c6de9e35e400071b0c30e008f684fe9309f3e01444fc4a9de72583a81dbad7263ee3a56bebeb313167add579dab79d3c18b4bbada96ece02ffc6895c78fda8de8b2bea046dc45d2364a781f16db6db87f682294dfe84d773f9f497b2a207bc555672c9c56fbcd4fbfe66a58fbe962ec53ee7d51878f8dcacfcab7b410509116d4790dcdb4b50d48a2adec1e8d24e9a697f3d739c82f1a88f5f8482da7160c58cc4fd85d978edd73971baf8a45b517e8ee3c5bd5514e7d3fa479971c484a53b36cabf0c20313f28b89416d6ad3eabc8ef97b0922f285fd5d7c475c6c012c6d4390bdccc23c05eb00aa13579a9ea208b48d74415032559c834d33fd7a3147a11e4822578983c88de2f5c19e484b8261884d07bde6ff0564a83ffaa0a88ee053690f99bcff99d2bd765ba1637e1285ba18c3ded677da94ee1d27ea26262a464ec3fd34cc3ac03086ce9dd29ae4ad0cf928b243c8eadefa497ebf9d027cb895da17034e16dec23025f6c4c64a21945cbbd57034af9027916c2ecf7c8798cd4f1f58ef00879c03fa9a287082d3122787188190cc59bf01f147fc71d6aca2e5238f4d34eb953aab3c689fac783d54224f0ce2c82108c7e65265e31179719bdcc2a0fd65d1ada76035b79e6607812a32392639017386720f9859d766efa2db1c7703c424390b73b9b38fa68071b5655dd29513b8b0d2a4773f83a6181236f4650a966fd47b4c0ec441a7b0ec61aa5ce8418fb738b86aefb829a51d15ffafd0bb865204d204a5f3467eadfc0744037ed9b8591af8d3bcde35af2a0450947363db25cbfad17aa1547da8e3f31e04f894c0ce032f126969fd616abd7be748b99c56941552538b3626373428f49bca3b4b6f9808da9ecad973322f7b7aa3a74ed314bf303da445de0d7b6723dd39985c79235f0c0f6f57db350c4a86c4213e2497bc537ff3bffa8ca702206bd41fa1545da3a337cfe866a61f9a3f71228a50ed933b8d1879dbae4ad2d4657267c54c8136b85bcf22cd5a1d9a20c459ba8bade3f0021a89e82cf0c36f52b6d883ca3795c2bced802e4ece3adf1f805ef8fba4ca397763151c756c7fed1f8fccd54d6f9cbc4a83c905d98c66ba00dac24437d39c8754303139083f9e74a945ba9fc041fcc882ddb2b7ff9ab34e84c797a1bd586dcd9f7ffc5ce1188c6e115d4ff0c18b669706d3092c7ec3040034bd968b00820712063217d67645ab5eec914c17bad83d117b6d6d371d5181786b0165c1ca045b655b103a8c2c04fd349a6e168b4122178a899210d0f1056e257ed31e451fb3816e96161e1a079ac7ceca3d7c81921cd5ce412f5c3afd18a7f7b9d8a1e1e40f84377f51232986429e7b1d7e26816c00343f9404e8a334e63be269de2623576b80b868633c9db76e83ecca6cb882e7c00bfaf1b5bb1376cf2c6e611acf46bec4b740fd5f31488db8cf400edc08bde77857f7f081d65ab1f4fe0b627fa371d15701ab7a4e90fad11c989b919cba8ee679ef721826a4c88f03f6d739952629054f85f114d86e815f1280abcb1536898432c9102201e1e1a9a093dfd0a56127bfe20b93c14d73767eb4f271d1cbc15be6028e23801e317c13d0eac3ef8019ee29838aa20f5386e377383bc189680305d3f462af5a246c22c7885641886532be1b80be4923823f3403b9b6699ac832c70b1fc938c2abcde565f39d8462e39c7f47a92bb6a3044035a373096c6bc094e20bc48df2380ef5953204be65ced66cc3e69c2eb331849218c1ee9aa4f57140350157e8043d3f37810f4478ae716073b3e61e6aa49dfc4357f54a31c200372398615f6ac1feb8fc93f518270a67a8e8f59ce1262215340ca186ca34dfe3ee2c6d7c8ed996ff2c77990039d7ec96a32f6af38e3ce97338d8028b0453bed3105795866b93ac23f06a6184faca48193ac0189d2a87678c55e5e574381a2f9f06e865dc69a7cd422ed2cc9b3b1d841a23315111b3e78f6ca16cb84da72b94f4395321683f7d56f39f86244a3d2c778322691b14266615d53087bd7c06da5517356c75c2bbc1205da2102bc1be86b02fdeb8c83bdc1578ae856a5735124c2b65fbe07f937f906a9ae1e22281e294c715912f82e7456f634a2c84275823844cba19ff699015a695d2f1f2896fae039f10ad38420eda53d52077c3a2c5a261c9aed8f7f0c82c336633ac5ae36882f92bf61d8962723c4d8ffb02f742a50739881a2025d236051513ca4d58eed09542d559bc5bdf58e7d6912ed6a08442f7e206c62581504e52a5f65e8b580db38500d70a0cfc3aa60bcda791d06ee9a450d11d4154d0a15a6f04e251540b480da93ac6db87486bb06d56653df5d3af0ff130762299c9dc79565e5e36de72aee6d08085c0110ec1e59f280585040c180f8de5a9f15c07e33ea1ed35a7ce1f76651f529c508996d3745ee31fcb0fa3c5f14b25d6952ed3c58bc47b5238ae20afadd9924c91704eb7b5dc15244063e8633fc05febef65df6771d654bf15f4fc0c06fda371a489540185ee9851752ca1a1a487dca516b1dd77d50d1a7b35dda260e7f516d1ea83ff8ac3b18d5ea87b1db57fdd5323167f628d599279ef4b39d041f1a0e33cc7df3d0717a486b22817843d89e59cd4d9ad3555196d2b6e93f6adfaa510a6a85b2c57921b6229b68959a9804fb3d42f97c60d022224f7c33f96aae0d7d93f2b3644944dea7eb4468964956a6fddb38fa636880bff1750c3951811c43d8cdccbdb2d14de316587e8c80d1931865db40e2365d0de1d86965582c0708977412e9ad231ee8d2efead197e7580599b0172c4448465c8d32687865f436485f5ad3ff8899a16a1a19599de6510fd9b145c1986aac94a9365d1acaf4a296908254a1f696b2feee7af5162c7dd5dddd8bb6b1c30a60d0bc9b5df4177200aa16911608d3085a46a1b02ba5bf04234a56899ff11a14364318ef03768387a3dfc2e066a1596cf62fc415c89a14db10b8f23b610d738f7ec1b2cb7cf40c9015cdbe7f5c7b5c94675333bf19e187cec84627f3b637dd2d8e7dd768cc80b4c3ed931f116f8aab8eb25786735a5e301ee04adfed7d5183a6581353503c3ea2c7952db422bfa81327d2684bed4407b80d47b6a3ed56c14f7fc9dcaa449cbc487de03c5c40e4121d94c7a41ef7aa789fdaf748d50a48f0e1eafa9ec9b5c3addb04a5cea553b9e6c80c5bbef0e99ed3354772b6bc7b84d80bee8a40d5158b87224b45ba28860bba2e9dc93c2b0d8a0c2bf2ec7005a9b5b9fc1324774ce75680b3f45dd8b21f37f274ad8574477158501de32b8b6b5e31aec019340127922e61178b6cdc991911ad9fefde95774715722029e3f452dc77112bc3c57a128c0f65799b30bbdcfad82b3bcf4867c4f1efec876ff656878a62c215c4ba0c4c546695e669c60e82bc013225ea14632b7320e4a2b751cbaf53413f54f20c6696ebdb1d1564d92fbd5cfc3166ff8c977f02ccc0085bc2121cf5afb967e975d06bac4077ca0b746284cb5adb69f014247da94fd4c6417735a801ba616076e6ab98aa7c8f9f1a9be40fafff1e94eef56f52ba4a21893b12d888df0e9c39ad65b077a9547ba32399ec1e15e38c1163f4c3f0265da605618ee184f23991bee101626f8cf15a0b4835239d62f6feb7fe1ea8ffe084819adb3c7d92a18f8e542f8e62b9bc14c8223d42e75d0bb400bf15bdbb974a480bb94fa0c7656ea99ddb2182fafffddb4b12334e60e0df261a415aba71f401b80b44ffe94174f0155dc688a651cecc81613ba191df2dc138090e286869b3e81447375fe5e1ebf0a2e643821b976d45f64644e8c1655754e2e0021a2778e556e813504c1e376dcb7240c42433e9c1341b9f4719e8a9f0b5335de36353417f457a54688411681945f7ef1d05183c6f71f553f0656adaafd725c9ad8facc53c951ed86097525f1118c19f3f8a7a89d3a0442db3fcdfa1a23b95329f5fd1965ed78861d2644dd40f05a5650840b670d1741a04853a49655053b453f4e262330eda8c00bcff7c77732ceb91731c2d9382a4e66dc123e5424db1bf0de39d6bcad5d1438c578d99ee29c576f302ddd03c129b3af7c8766e25844c5d1334a2d3f021c38a2eeb00555e6b4b1d87831af8dc93203339e01fbcac88f17f38027caa1cfd982b60817225563aa41db73fbb6c7a4ab6a73b8e37c5de48875a299aa15aa07b8aed0a301dd5a4710b89b1845bb9bc61aaf629b4e3e180c1e89e4ac413d20b5217257065d7bada0bb68d942165f0985c5bef8d077bdc80cc9d2f8f9cd0023ba468bdf96ac666a07d0756ee1c920bcc4ba7474b177fd32cf8ebb4a7fec4c79f1a26e9d1f1c9f27ac7a229c331d139baabd16b56d4738bc6491c46b68169ab236f68c23d7496ab68db4eac3d0974fcf1cae512133e3d14e01e36014ae2bbcd00006c4fa5343eab8b0068cd2787f6b40bdb401d28b57bd72515d273a7635f498d9de913bf2fe588f44292e2a34c4b664914a606579d80193f00447cec969d37146c92840f82367dd8cbde4b00276125df5badad5c5dd60ff683b177a58bf9a03f6a7af9b749bfa0fd13c6766a980e922b62f25a51a2f5be3a5a9aa218fa35ec649c1c92ba0b65bfc554c3416613bb0ea40c36cf4a8ceb5e6df69ba5447f85513f73c7ddb857b047f148ccde5c347fdd7eff6d32e44a6e807c489f152f566804f802d60cf84967a6b127b15a7f350f39c70805edee1a450f13283db1fe05bb4d5631be30e9ec2e3c0f6d5ebd838fe19ec3a39672ffc9f8561f620a788eb15ed18f4dbfdb75f017af89253c591d2f29225266639dbb9fad9a4385b9bfb7fa4531605481297e4f39bb0a8a180ba69ad066b6e61c14fdaa0028c27d5732304390582c64f704ec6b254f6bac659d3b317c9598ecc644844aaeb5a4b461701bb0d0d9bfcb63dde46e8dfefb25571146debed03c299e4ee1db352f88fb91f602dd18ecabf9867e1d121e2731067792afcb8ce77791d00576b76ab32b62f9d15839a3e46d0e0f030ca3bd8fe8968ae1a1bf52f48d9b5606224f57c382a17c8c8ca46103bb023fc28955d64059dd5bfe4103e9a5cec75713d27e56da4a8f595cdfa1cb6cce2ac43437b56bcc767658805e151ee9d538b63d0bd9ca2693e856f3a923a7ec60421da32ce4046bdae208a70e16eed9b3354041eda49f73d2fceda1bc8629b7392439c44d35e8db78ab672e6260d88ab8044f837c4176d5613ae0cce80d706c243338688f388a750871ed4c6f000826b82ed5f2ce7eb0e01803f5322bc7aed831bab9c90aa51bb2add190d60a8a847789b27919382e42e22c64a081dd48ea4ef8d4a244c1234a0080d6274e5aa64c66b2e1ea10ef8d395d9ae901ff2fb1702401fe46cbee219e94f20602c04a2ae3afce0e85fa2e024a3d378cf1db00beff6c3be91505cc07c2d38a67484edc7bc4cde62545ee56c65c18963532383244b43d8378210d1a5af73d03e45f791acbdf36817cdd49e7fc608e9de47ad0cf65dd5aa4f64a18da8cf419f9ed30eb4f55087444cae53e1a4e207772edb47b5113d2336edcdacce0257bf74ce9f512dbc4fac617c741b8b4e4164d8d8d7e16b5d03b2ac092fac09af876228e9acbd99aa3ef84eb2827ad469f55a5703e81dcd3852fa142df48c6becaa79bcc99dbe92746081cc7fac6a910c3abe8629d5c72fc1e3e544edd0fb8556bb687975d38985e01e7b1817a31b6b0442ec59802992f170ba1d550953f61680edf392f9dfab868dad2a82e17265bfa3e97dcb071e0f2c4c2a5e56b08ca93b5bd3edc2d7118dae9571445cd6e3db1d78b6ec14ebc25a082a1d6b0eb76e55d76191d31707afb18a4597caefada0a974a51620eaf1610e79630dfbe2e08616bb065c39abb3eb4e9594a666cc471bdbb55061ba9dac2e4f78d3f7a8c2d2bb36369eba952598b06b57167d0a7c054ac267a8ea62fe1b1b0dfc64c4ae33e95446215bb9c22c65464702174b3ea32017e946f47a8a8e0bf98443c81b3c5b0988970edaabaec5046f11e6ba4f18cd7f34ca9aff7a28e24e609df5ed155e72f7eead3a0589a31e085bdd9592a6a86771766a3e0e018aa8653dccdbcec4d02593ac4d5fd1549e0118dc6cd013aa457b1765e18898afc92e9c8f6b33d28e1a191daec13ef55e02f7a91fd2ebe0902d7464117d2d730b9b962bd06fa7744ac5edadf5bc9f36c5b6ab6f451ef7917db28455d74f1b6aba24635b4c8c0b094073a62425d83300c73f44d1db3650eabb772bd7a9aa25d1db8ef44ef9fed788335cd73007a6e7f8a5c76118dd4c78dd30abd2a4e1f7b5459c6020550d9713389ecb23e7c9de0520166b853de122bb3f428491787d5768252d076fe95be9aea6f2fcde226461a4fccec6faa3e83bebbc1f588663ee26173a54f04356c1727c59d23f7a28fe37718cd02325ad59ec51e87911aa4a964620ea7c7d906f03a526aa920d89cfd8e5456f7cff9718d1a7f2e72779a639bb642c224777aa6f0b00ca5b23ae4d20ef75e967778dace51ea837bc28b6eb2ccc7ff96d50211421ceb87f57195bf3ae441540ff91bbd9b5192b398480bfa29c7ca38fbb87dbb70e5d53d16e5f70c4e80227d403a3ba6643eae6d204c7f34a99da8c362a37761ec9cf11843b52f64cc015abb71fd7647f278ec8f34909df3de121124981b925e9dba1e6fdc528ded7810e9d80ef634aa478488d29c059c811f473bf99f9d48aaea12809258bed17cb3cdc054b97be3d1021a9c0feabd0c2e91b51c543a18d765378ff320b1b489df7853e1d47e9aa01f6999a79ef7600b31ae4b33a2c47cef39c6f1f9d32c28b4ca940cee4451120a23131a9f2427ae86374242aa597227fe376ec77481cde82d7f1549956ea80540d6e97d6045948c8a472d3e891204cd47ff7658faef295ade3ee062300f1454450cbca50fc7b076148dcd1f6e1498bd54e2127749c24f853c773d9f4f8b29337962362beb714fbd09235bde240e3d8c5618ff9c74b6d304470e42679fcbbca9a6e87c4b6a2c44d1f01cf0d3b4171df786423226bc3a8b17cfcc3a141340833f1cf9d2f57ba7884c0dd82f78aa3814e61d2d1628eba106f7b544bdfa19f995fff309f8e8509613bbb907be845a66c3d15061ca2c4a889767769d5e3c83526d090d33752295ce63cafc2c903adb53dd56d1d3b5ab52cccfe5d6bd7332c8bc960435f891f8ba7495eacdd1d53d440f580e2090fefcef4fdad1af81d789208dffa7627ac456be65a8fef38b2b8035f43e56d2ed840b2667d830cf299ff1948619f263179772d9cb84fd8434557e72ebb50700c08d43a7a6fb3be3df4f0b80e0fac0bdc78d06130b906ab66b49fdb9890ecb5a772dfb404cd1ca9ad9b69db659133c13f2f73e91b5ebf942148f4fba9aababb00e66fe236d4699f9634ff3be44c44254737b9f59630a0dcab4dc29e5bf4e108aff901cbc8d4a707094fb9c3c4f70171467a5bfc8ad956c2eaaef673556955cc9ffbd336f53c5e7171360446f6985cac2dd81ffa8a9d6dc83affd3749dc9f0bdc019d2f8eb4098361b5442d991ff6e8dca46ee170abcb25a4cd2e8aed29d9e9159c7ba4b3a02f90756b47303a4a9410a0369942d1eeed93b75c015700f58503175c28905b10331d09c874a6b609dc38eedb92e2962b40576470100c65ee871e23477dea87437ea147d72bc21674f8a580034a8031fc95273ddc4b8c8fb7eb9fc076e243ff5107d9f82ad01a69f62df3de129b3ca3120c8fb5ff8c36fc6306520b8a2909a6ab2dcf88a0d9701e946214db112a7ec654841f13f515cf0475c7581b9e87016106063b95def1b723b7284cc0e329c4cd1540902ca68942a5a1c6ed5225d18f9ad9c95c20239f4933f46f34b825ec2849d031882a49be22ad545dd11a707a2921a89b3403467fbe060153ba167aaaa6b33a5091fa78f52085253bfbb27157e95851c56eb9d96a7f1e6addf29c44e4c1caebfa3925ac42e4d8d8ca8f7554a8dfdaf4fd93f4aaf7d97400af84ed204a328ea2e9692c2a7dff22592cf4a0af46227cc4fadd1b7bd28c4afffedc06fb4f8a96d847aa1be4dc4467729190554c526e1327798be91f338dd35d0dc4ece4ed5766fb2b08bbbc56c35b3d74cd56bc061515cb8881c5662f55f4c3032ebe2e34f6cc64bb29b137444305a00279c03f9ac362f3320ab47829cea2ec577a530bf7be379cd5ef722d784c061fcdc08e116ff464fc8715010d4e059fe7c7dee62ee360f07aa2fdc19d407e7949fc902ecb1aba9a90559140387f7a84dba5a6cf8abdc2c28370c2432d690cffe8aa0ad5334126a4cfdde5d844792dd6c013ad5b62825fe2b3a6e44dff3198c48df43f5e299b825129fcf17fb3aeb5dc5fb3e200f0d6ce5ab8730de0ca258e1c539073d2cc7f36fc9794c89f284f957c80d2de20111d444068f5e50cfb0f947fe4570708001e5489efc4dc3fc6fabae25a6b725121a56c4d887e6d71d6f711013e8ea8b3a273b2319572cf9d761174d83585e8878b298cd2f64386dd16bed1e76c2cda9e4c49f8d8c6938f24c62e07a23d4799b79d2903abfa3bec9bebbedd3296fb437493308797a0a1a772485bbf5e555aaaffca0a3f95a69b40da157a4652776973e1efcf262bd032f8aab5077e0d5574865ee5d4ebfec74dfb8a21242833279a07c6c179daf3275f52a4c2cae43b3e234d216125f8ac36f3a2eab39190dcbba1f1c53fae08856756af3a7b51c6e1a0b98d1c05d74cbb5d5866e5c66650cc86985fec7be45180cc65bf4af6fa027b915473b10779c979c06799735d603eaf2c763a00e3c2c0efc0fa58e161728bdec1a98fdb054327b389c6e3d135e9fd61660da28636ffa7b58cdb7b2a5ef5a443108a58ec0d75950847cd037926b7f71dd364b785d55f14dadd0b0474dc412f9fb066825bcb8939ae451eb499fbc64ddc0731ff0361d2b0fa4b9424b5c81b82fbda54448a5f4f39c552e11312736e0e27ff6862c393224e6f6cf918d012be9feeaf133dfa1011ce36b6e9c1fb1418f970835e8646635ea3ca78cad9986c5f6035877700beb02fae8547a32d9ce08fae7228409a9a5d8c256ed94b72aa072b0c0d05d2568943e834922c723446420176098d85ce2e70bdf8d4606786fb953f588b7c0ae6c88d4791855bc94629c896511a48180f269609ab351209f0b39f626df60df07d983f804cbfcc78049aa6fe54f0cc2cb4520d3070bc014d14cfb7184db5a2dcc806b146a52fced0924aa992b3adc094b202e0466b84e153825620c2913971744e45e0e2aa63c13e6a362910642590da389a6f281dc677d50dd1d23ff2fa159e9e20ca49a7a53824dc418e216a3705b0fa759f8d335eda1a55fdd0ea79c108fc2fa4500edb9ae529f38fe9b54bfe95ccd9c56861ac1d72a911cc46268ff217b45094fc3d706600ddc67e11e8f6df23dac4169f6f3dc2eae388661ccac9202fed1df738430e9dc201d889f790d704dd27622683950b9bfb9809be64b9ee92810e50c90a727d34c85b98563eea7268775b1dc7c54e8cfc67bd129d500e1d98869870a96fcc84ec8d3426ef21d643cde375baf3644920653f3d317d9c06f2fb70515c5060bfdc9e51e3dad478f7d25d2c59532c50194fb8484b29edea2ea205f0553dadff68718b6985a4514314f0297048a26dd045a72261a8efc139c98336196c17d5c2f1c9dbcd68efa3cf38ec9af9a3cf6f2ad7a37f6737fc1accc9b5e6a41f19a96a17e29604929b5b61b23ea43a28ebb83ee60887258aad044681ca84079712e24d56d2bce74e3176dbebf47289072006bf4d2868897fcf79ad16adb346ab9b266db387c27e87fb847f1c153bc8b7fc1a2fd504b10459fb84f55d7b6fc138d21779db86dd458a57e396c45ad19ee0ec3830bfdeca7a47c40a898c8e6a439e7eb003770f998999ad567dd003b3587269fc098b072337ad75bb6b907f1c07a39c775261d33c2033784bfa134267256eaa4b906d51a11f83099e0876f1955cfda6ffc0b22a7a61b37d2583e6bd13f9c3b3d91febca02785dc202428550269f33a7f1de0fe842d7a1ca840daba8495826e105240ba2f3d0e43561ef38f74947f8908f11047d75767db32e87ea997380cc1262347eae242c04bf981eb8e49ffa5068930ac36b2c3143de9044a7aa636add7ec3b806442bbcde4006479ee2647d4aa8f4701c5f05e87ac09e149a9c31032ff6e1a56e77a2e97a80c2b30a1191601a775aa3ccb29c2dc337435aa573d9864e45c09c1207cad17679cebcef1d7abe45624483be265d467d5667a459e3aab0c6d544d8ccff0cc95b877a42f4dddd808995a7277289284ff2534f3fcbb37aa5d25fd098c7e27c4345c469cfd212171a5c90eaa592f165f0117d9b2c24f0e9b70143e29655ff5b036a056cb805f9c9b6357b4a197a2b98c0e6f87843824825e11299558c7fe493e32600b19c1f7e95ae832bb0d3e15ab2a792dc90803528c14c82df483600a63335e012f93c8cade6f9f4609f49f0d123cfef54c60069caba4c3315b77cf763ff1341e3dd20192bd21339b37cd6d2c6b2989b3c08a0786562d90ddaa95b8775f0843e01270805ed46c1fce2bb7b756c7d8404c062b5d85918e11815df5cc1d40285a7c07064fdc2b2bc5a2816c921ec4301bcf641e2c9377e052413cf18b1a1efcbb2c144ab2c9ae6e18c79558e2934852a682f7ee4662439e88901b304487762b2050293f05b899528bcc5a2821923eb52f5273cd043c80d81d2e203f7a2d4ab6bf39d5e66c599319e42dceb3f79e00a5558cd139948f77518ebbd496e1f559b41c416d70ff70a070e435d7ba13b7d2914fcaab2a28d56ccf35f5f00a7802d2ceb4567672863ddf82e88b0aa15fbcf4ca0c9985bfa68974216c5cc54eac580f24425f82c48f0b3826b6573fb14bc016be5931eab60ea871804fd5fff171f395e40508cbe1109b20c28790a91459f299c4cb9157fad2e6e33717751a8cc50e571b315e17bba746fd6bbd9f11a0225ed3acbc838824bb932d3d8eeaf151fa3c81a9fe7f1f2ebaf1735289ff3d9b5de6e8547eb34f0cfa20625170c8ac2f092710d2da054985fff3f10ff1751f28c59c54b9532d27e4d1a55161befe856a61e389bd19bf71c069196fd52ac54eacd8fc440e5de01ff2cbebb6e3425d827d6b8937e859a58e1d6f2a16de2c067b3f1723c39af445e35a9c71053046f8c0ca6b6fa760bd510bcc7f88b7c816f4472d0ca8b80cdac628afa0e0b817f415e12b4a56c1e988fa2a7dfa4de6eb92ef4f60244929148061000d41f6d47683b87b66b0b78bb6d801abbc59cae47c420e59cbb7221ecff1c4a7c01938eba1209d3acf33c5b859a753323837645b118cbfd75bc212303d49a06e526451db005b1e1c841f41c938c984a03044eaafb3306672ada3f58b48908ffa55085c9dbac47b327dec6b17ecd29116d1b3a4dedd804f12e012ad148c4046f79fba58a23bebed95038f8dcd58bf643b3e857fe5d132b0ee8cb1a35994aa8ba1a3bca73ed805f4a503c6e245035b4ddd36d1498f07a5687ee386585b501e3bcf6540289cb7f92159165ffbb33283021d2b84f3efc78f33097d72a41c63a2a75d1cd93ea7169c04a19b8a90e6a664b57c70faf46b19ce41b89d56cfaa69cfa64f76f5d762196b212cbf411acc6bdfa4d69d3b354b3ab5f6eb34d59dbc3191db6cb74f78f83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
