<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1bb2fde1ba92c536180719506a8c835007e68db89f5760205005581a08d11be555ec9295afaf3d25062808d85519df42b2179faa3f53acaf8a3dcd0b2a4de7faa5ab921d610100173c99b8522cdded2fb4abb3e0f36a6d006d82f7d289199e8ecae2a6e5a121dcdcc77a6f2091c348d186f373bab44825f74dd4ad9584ca448617fca982d6c36f9b5d347900fa11613cd7ffe0b8f096360c207162f13f8b40bcc0070d5d0389113f1465f206e19c8542996383bdb07f8ad0f94baac201cc055593361794f1c6995a042419a6e7ae6999cbd41b4bc8cfd004816693ff61ec491b0480d3ce3fc9116931fb8f3226fe32a1a04b426128cb60cafee70a7be4464c6b0e30801737092ee7c7fb91245f13eaa95012b56ca9561be995c2ab07fff1f45d3f2fc4864ca6bcba687f80ee16b0ecbaf9ac084b26d34e5f24bb0772274aa10fc3ed450544db86d127430bc1cbe3f8cfabd330502852441807e96fc967ded54e08c1dcde1173ee1e8fffeae82b2fabfbbcd834a4b649b7a99e2ff52c3bc97256b9841b90e54b469646419f98517196e89d8668e6c5ddd24e756c7770a0615f631d3ca785995e9a9867ee16d1a186c54dd28475762748b19894989ee4b40614c79061b09e5d6359777f3cbbee30b3123c6b58f041605ece4524d355ac6b51bbe2e24b53a23acc0ccda463dba735cbe911caa834089e3756adca2fde15a3cc4d368e15065502658741c961ee9af1e56f3b247a6d1229b2d783024fa749d86263bbf69b1fc5ad54f7696dc35a9db9cb60ef808a6a02735dd27b1c3dac8fb2957560c2efc5524bdb60aa10f793ff2a900505eda4c9e0d2b7b0abc539477472a7ecd05ef5ea3f264c8ddaf6a42fd6fc0ad196b1946ccc7aa537d8600c1926adde94dc11f1d9b6816ac36d22162fcebe75a9ddfdb8d6cbee5c4d182db353a952828ff1b4da0e39e8388dd0c6c49a8f729410d97cd71822bbe3699e1fa91e321647edcb73efbba116cb977d164eb5a1682684dfa51713c7378ce7822da4d7c7f753f29f5053a304492ad2c104d05839085aea4f96155e4d86edb8e1cd776c3f227a9bc71e46b481038e5c95af2118b91762a7db5410a1db964910406876bc10d25a66bdbfca87c762da58fb2ab8ccdf71361be8af7f6dff6b77e9558ae156e1726847664aa0c9ce5a71dbab195e29fb913314fec8bfb55c193db8912603ad1f0fad7fa035074c5aee3ede304516d0b2d319e97ad263010157999e7e4404fec0b446adb60dda11dc452ca830a3fb5938af1f2118b1926f292bab71f547bfaa4f8fb4369fee11b0fe1b22be1342a31bb75637c300b40d0dd04d6d25a3028c65623d9856df6ad3c40f19e5f6149c0236f13c91846f615fb69da58f201b4bb7ccdf4c45cd20a9f8490685cb1c96d984c5173ee29d72ebe342aba53b0f9941a1916154eaa5023414617b5450cec0ecf28ec411d5eb5fb7ec67c6968b32506642746601d7a4811998d06cdd8508d6fb1c828c945f499f2fae04c6354fae957d1b3c26b66727fba0dcdd6c728e2f1efed1bd558caf22ffd7314731e37bf47b0c7acc1c4d02f74abafc438c6691c50e133c86c5b05872bd55fa95414097dcb7a794db0463b2c6a0666247f96e149d24083d21add03162abf46841371a8612c6cb8d2b41235f02a9aa1573d1f8067c21cd3eb52ff984af7cc80e19d378b9f555dc9bd66eb15a739492ec43b995d9ef07cc2df51e99b5e2bc7127a3f40e18aaad6aec99fc7ad9008de1e52b749012fe433a33d3fbd1be75313879f46777dcda2d1092e7309a7629e634bd10be358b7fbde87fa7a8058d07a53958a55e6b3fc216c90a00e54a5559fbce56c0d33ffbb899a1894c5289d1df8a708191b2effe1ece6836d7f928094e51566fa09bd78777a4745e6f9ae0a69b5154863377a7f0ae7c58e58b62fe935e2aef2db43c25cfffbaf5cde67fcf50d743d202a807d9b42cee41d47c4a00dc88cf531b15a131b919b33e93274ef348c7ba8703450841eb8c6b3fea83e8b524577c702cca03ac6a5c78eff44db596b13b890d48a6249f7df56fcf2c1d19088fd33f49bc9ec95861df867d754913d56a3a22bc11d41008082cc0fdf94938d5c00ebe1def9d9e8bded74b9473edbd76f824072296f367b0cfa3719e29933c694e041b70bdbdf296ee269f41665e88d05cbdec651e7466b3f5ccd7759799e202fdd62e72a4381ce3b7db3e6de43ee5d14a8fa9bc91e7b6625e173f8daf3034953ebbe7cb47cfb1c461327c0e3645235a695cedd9db8c4eed5b0cd4e1e55f3e1454f9e3fe8ced5c51caead383ad1726f50438f2db4c10324536840b2930b51c359201f23f0c99ed79f03a57ca93fd9472107b30781de9ea8b2a1dbd2e11bfa5521b13ac63a1bd83f504585ab4f159628a054c96099c3d4a2b371704c0a78ed0ecf117b34273c1fd7bf193dff2df715098cd5e93db4db799b221ff6a17bae710926cbe1d3aea73230982d823f001521c0afa68834b801628a9a0cd3eeafedeccdea2228c3e67fc8cb9eafeb95b4aaa41f860dd0e4d32e49cf6e924e34366a902937b96c2213f3c8a6ff1520838d76eef5781925248801c30bed0711429c2fdc4d77e9d30917bc7547993f3a60544f4b6ce39d94e9af74a4fbc8327bc3e21ff5b8491fdc907addf849069e38c21b46d3d720b0ac1f0223cd489222ff68af639ba8a7c57b6a8d4cabd672589053b439aedebcf93d9cb4d2bff83e1bd7dbe00e93ddfbdb04fb75d48c9ff1c95011f99babfb3772bd462ee4b1c03f8db204a827b1ebcba46ad3f92bdd71dc7305a8407a71f013aa7f17f177e286d8aed43f17eca9e617dea53e31ea455d957909c7d8d9a408756d14bf681538c9575f5e033ec9cafc5067c83fa23ba50763ea586c605d3acc1557bcf22b55e041cae0a41840e9b4ac6bd74fe7d268dfcbbed6fc89fa068522096b7270e7762a05c488d86d9b2c9a8d1ae396e721c1f2ff9c00a1550449987fdfdddc30bd70e168a8860cfb651ad935743ddfbef8a72d90dbe0c494f915c7b2c9e2692e6e2c5ea67627ac3a5d7f266ee7b86d464b38ebd04e63a69e88533ad6c554b991cd9bea80eb61fcb6e15ce18cedd482635ecc52e4e8e9091412a3b9b2e4983c5233c3bd953e3b51aa83b4d69524048b71ebecfec0faf9ee7e2b845ebb693159acfe6f6f66bd1c126b0cbf09eacbd274aec64e3a48fcbd5391801d189256b740e2181808f038621fa7b03c8a365820eff148bebf607ceb0289296e1db4570b034fbfd76bbd68b5b7e0eb57d054f796d0899c3bcf20dd9f0961f3a2d94a4ae53d12a7cd5d95e9cbf6d4b371624acba2e5fdca572699eb7dbd9423e22f0c1379b205959cc5f5a2f9d8f7336ebe54a2d96f36a72704ef39d63834708b15f4c18575016718cdd9504ce3d62618dabdb6a778a64c594c658d3b5ab65ec4c3968ed8c21cfeeee0c7d851ebc8019e2b23ae6c0bd0e9d6ee5a7476c4f1c7c5f2f4ea682d9d177313ceda65a8186358d5396a22b40026ee66ac1473d00a5ffc12d5cfcb5fa3bb70e1b03d30025090dd3491f5496a995ffe0ced29bee3625077e2de1bfd497bb88712d18984e17084349759d33fcd0a2cca18d971505c0ee8a8ab4e13e18a78d87d77e693b92e4415ce19b54e30677ba3de1e0368e751c91571f981ab545289eb8e1129d60499dc75f735778eafb810a99eaeefe86e81e1b126ebe73c604a0b077c3977e6aa83e847fb4c617537f3398c0778be0f3e5ab01e3f485bb3c18bd3801950ea1ef7b4ef41b0f0f9103b9dd7c5ee6f15e8072ea380563d1b3c3646175a60891957ef5fef93f6152c217503379d29dfb013cc757f2e50d0dd38de01340d3a6f483b49f9206bfa2386f0e4448ba1c1a06375c85e7752c7c8452a0fdebe5f76961a339ab3b63c2dda3133c926d93f90ffdb097b2bd4fa8ab10772a3217996ebf1937bd9d481ed3f15af13761aa9325dea32986c1da74e15edb064c2edde7dc78dd8ba4df069ca10cb170d5d3a90d6c75c15724cbd22f32103732b974c19983d34c1c80d8617b0adffe775619ead1608c4c82685d72472124ae3a961a3407ea703cb486cdfea6fee4cf1260257f54b7d1cc4425055cc7a6f38e52f9ee593ccabf65b0058a3b84be7814c58023e84e2928ae7d01b99920b2cdf148850741f2ed96409cb96fb60b58b577a0aa7a34faabbd9a63d710ffbfdc827a84236fe23a357cb48a8e70b171ef3431769cc8317485d82c2c7d87b4e8e2a5843f42327137b2fce3f4e6f1020a0b18537b32af201523f90188876691004dce22a32f2d51b7c92f30a08918fe157d648735ff18175a5040eb343856b1d3e300de5fbef63b3c12cba1546a224e91d26d71b712b2613a736f49e38018949c1dfc9e28757f90ee4571f2aecdec2457ec9eb0492abf36de3ceccf25902e1cc9f0c870f0761323606297cd23cc958cd97265b80e7268e60dbbca7aadbf23959f8ab29d74f16a615d6de743d8f46bb4f69b814bc6690623212388f111c2aef0a9cd6745bc9d093af80915362a868de0cda121a0148c64f90b3f45e9f2f0863a52201ad280f1dffd4c541eb65b84636f3b3c9953c683b15dda0c29a4daaf65fcbab317851313711137e02bd3f688e3e8aa9fb9ba76d5e75ac9216a59fb6fd5561384118dc1ec0fcc253a99266c54954462105cbb34a737319131915bd63780d0ceaa21e7100817fc347427b2201c72cdd13ed55f5748952328035ba802eab4c8c5eb988cddb9ae7b9a4c391e94d696d3f43dbbbf0b1f5dad74d5ba160300f515ee40d305a3aee572300afec306d3e4f5d4df66432c72124910e96f70c69cd6e7374dc52f42ae3f0fde1ace917d5d67297db3fdd691b1f6b909c2df29d56de0e0f9a7aa42d96c075bac1f6cf5a55a5e0e349e48f0fc5a2697249e17f60eda7230a6abcc870164373debba8ed21b6945909d3ac620094508409c63e5dae77908bfb5f37b4b61e79ce17da2ab4475106115d874cc0ddeeb72d518928b886c4c0abd9d534da9f776676fa1b4a25e538ef341adf9c2ba5bb0c2de146fd6bc7be3cd83f122f160ea2d65d5db138490685b100186ff95b87354173650f2173408195b78b3cda9514bc3a65accf55612f7599ddbdb51121ac651b3c54f4a85925a33d6b1638f9f960faace41bfca7a4ca2a2b2b829a10366b1c794125249e267ce288667f008ee30c61bbb6709c0fdef046753d792a8fe0ba16998807c5fe96e813afdbf1585e77a1058c6d1999b1bef7cc4568537e93ba46f5662d1ff4cd7da03c67f4afd697adc1a62154a8bbe1633c8d66451db39e51e90bd43b50abe5e748798e82ea5647fad6333303095d78e57cfe43aa0301c262c8398f35ed2ece8909cc3a7490d4b48fc8bc26e90a8d219a94ad5aa80faeb146764af02a6a18ffb78167238944577058aabce6004e0dabdb38a02c8582a39ff1689260af86b73967c83dd51ce544d5d6f9466c117300428b82e0147789b73ea1216d2d1d1952d449dc9d20a67d2b1262271dfe862be81c4a36be3216de8f89bf6fafced5606bf55a4f75466bdac645d1b8d0f9a0e83fd8b71107a5ef6bf7fe398ebcaf5a2464f089220fc9e335ccf916d4e442b213156efef07dbbbf3f64f525d043d1164be5ad04f33d458fa201c3fad189adf1d5ce70e4ed034302cee4049dd1819f029dcc36c61b94d28a8bb2051fe294abb21a0d056715085a3bd9e39d685aa5aca6e42161456f7f56d23032559f860b448ae450439c6ba95b78fc459afc5c09534ae12cd9a5de1c777fd78b4b13335a4962e0454c68a671acbb2a6ce02b8daf09f60e74b628834d3814bc4f2edcda3290fe0bf20f90e0a846f02cea0146ce79f56ff2f39a9f972392d1b1e80053483687dceb21e9ffbf243fca7ead06a87affdb97c70a59b30b7b46f16e3bf220ffc23ff11986765bcfb5704e3a01b7126de15031b580de2520689d73eec60edd9bf7faf8a22d9758f7b048b84540482bfd26c554327a3d79e10702a2fd42251d9c53fbd269d33cfeaf4072b8b548e833683b2762f59839629facf431b06f094ac47ea449e0895d987d2b30a3a94a729f31edce78024394099517fccdd4ea9c08e3e8b091fd5f2a0cecbd9b54eab2b926a7d6de0f6a6864b8dd83027870f6fa7ebccb89700b0edb0fe7a0dbf2e394b72b8bf7c090c93b5c28341dc778360a59abbd65da7560d7be62426a5faae615755597b07a4585d2b8bacd4f6f0b904962fcb73bc6e39ccf8ba9d676cf28bd880d4788ad91be0cea9ef589600b2e4321ce2ba0016f093301606956a2b0c75765d07064d508686b65dacbdd6ea5b4cc61f2731370dfa6cec28aa595ac3fe8a89c2355dd5cccc64904ea6b5546ae2507620c8dee7e8870fed9218b805e77822afaee66c7cecbcd809d7a9103c336f0f565e1d1e167df125d1e7d2a61b73a3c5e60776795308cf1810e382389ea805e04de3322e46ed0ea0a85d0a0784426380225ec26a22554eab39c9683963794ba3317f03c1d252eac6b7253c521472ba5ed133949b255ae05fedf70ad3a481765899bf73497717f5f0cfe6c9c8594f31972f8ec1425837aa7897e756ff21cad93e67373f63c7c8557220ef82e8465215c1c38a8502c33e158e35f1052ebd044d16cd898b2c8c7aca280ef77733253b422c2df63893a4f5e0e341bda455ca45cc118618d5941b2a5d726e5f0b14669ca93cbd3136ecc7dd98135f27b9d40b88177d213dd7b0ce0c5519530ef3f718ebe6ec04d3b2782497ca48b8cd7e184aacec61b42344311953a6485b43e27f8ff6ab91577eeee8cf01fcfbc8c322e3ad41992b7058ada6ee622e83e6dcaacd48da7ba3d931630f3814d6b5c17ef38c43f4d2b542a3d4dca4b5ea3fa284b39465d552293ebb041604ef4b8097a4c430b27a3b15c3b51f3ee67a257ac7a1964b0e80707c1809faa2f40c9ca0f857d27843c70db867e8f68d5ae803ac2f209ffcede49b65bd1d51b7bafbac57b4bc2e6794c95ca018324febd4a76324ee668ecc0eefe94a7c946f41c2e157d7d4e65d4ec9c5cad70cce09e2649b4dda396f48a6e94f4d7169458641c83ef7f4b1e3b22777c9d3b13acb567eb786f61798e902fda297911eb779b3bee69b16937684230bfa42ff6b559506e9dc29fc085a04f4f7cd01cc8b0c4def01e9598fea4ec6419cf05ddf8ef7663c9018148226f4e97baa1561362d4439d3036504d1f54cbe1f012013562fdf4a53b28a4a9a83053e02398935b5b7c44e83482521c7998c6e79f0b27c605fbea1c66289c9e690c81594d03306ea987a3745da0c8411ba9d0c6c737a15bf61adb329e5560bad891aaeff78dc839a38ef4ba822d3142f306920562c2681d512826447b5da7a6383dd2d96414e7a99bdb2c676df02da892e52197ab65aaa577dcd7533c64613b399a8ebebc2357e1d0f2638acbf603a6be34cfb73ac89c418127b65ece6a3676596505e3244aad28964aeb40b102d8fa1d5be90653697219bd647fe5b3afd46e0c3e5f6a432ae3f3276a227a1f20328329b085b79cd94af17b60781c3ae45edab6c1f869d791a4c17476f51dd701fc0cc750132f24f518eb50c9e9c226e04ae5e8d14e20184a2c5281828910fbc8f20eeddb3db4e8ee1338a3e37ecb00ed5e6772678c9fa3911c898b1f6b93dda669ac698811e9127c45c557be800b05506361f0658ad347e80d3dafba53f8887a5abc07dc8fb2bdfeafcbba044e1019619978b80b6606d9cbdfb94f52ab5318ad53062e43c7389efa017d861baa1af85a5e00635e37d6de1ef45580208baaf9fcab5dee6c920b3437fd80c7801c8c641acdcc486695a1a4e3ec9353435d486580e62cabc3af93925bc7d227b75c609b2ab86d5abf2c1b9405b1ae3c97a392755f44723134430b263a1f079fc6859f600a61eebd9639ace0ef7b5d170b102e67bcd541b8e2c2ee71afd1400096830b48d424956c0fe172c5b06bef18c5a9aba0f75f680f5024266315d32128a8b4a81caef493f3400c385ead1c4bf47f9da1e415949b8d953a3c23bbedf8ed10803fd300fd124ef73de6a82d7fc164cc857cec6cb0f3569973d00d488cffa39185d75b804bcbf3d928af4f61e53a0bb53ff9799f5f41d50421e35bcb894d5f19a3ebba985c83c30c04bd2f622bb363cf81d1573304e40af00de6aaa9442ad590f8efd18d94c8671bdd5681ea9af43fc046250e21fa2afe4c9876f615d9b79509f6f9d3feda912159984a0e998f0ce2f2022c8acee514d80ce2fd60a1a451f5141a851d329014854a75c0bfba89fb07582801fa64b320da9d2b2019858b32626e2d9e795ce96ea96ac61ca8f51a4b8d99f38a96154f3221df95dc6c77becbaa433cdc897b35078f4a583be49d2cf3f25f4a6670a448142fd067653e36844c54ef5e64566be003e8458869e3e9a1f0b1759d07cacb2d673e43ca3f87aa635b53f4a8bd66c2ccd048b8f2d60db5884ec7e15fe696d18a47f8577bed382564ea3c344fb7dc10c0830e985f8ab92ddf463279757df5f6f407d811a0365c6b009f335636cd65d1053c89bf463e848065c188f83da1978d0faca42eaa26e977772dfe509fd1c48fb1573011804dc01fcf0ebf0edd9be7056145a23ca131e97c41eebcf8459dfd953f7ea7ac7cc3923e117ef7c3ddc4ecec23104cf56fc786972339b7b9660d9ef63633f8c190878529363457f5212dff775cfeb2814ffc8263f0c9bff0baa7dc56878da5250a8e3fea007838a00570c8998fa04f11583ba135f58744e60b5d44cd69ac58299416fc00f03079c5739e3787df5c62e44efb16da785f1b499488d0758992eaf6dc53dcef490027de650fedffb8b7f5703ecae77b1b147d4ff3395c1def43f8fc5ea74ff200f29b4778c90d9c02d45ade55bc586c4c4316cf187a59cc940f0631fba8e438d6f5f6045906dc4b5032afc5f63492f25b515bf9b73dc6b9a2beb23612c6d3416858251714a43640779d4d443b83600e2e92ed6d33fc72dc07ba4047895cc7d747893b01e65223e308098198e625e42a6158c60d6b8ca8e64cc3b1cfd487878d64f73e6a72825c016b55d2df4aebf88cf15e0e146f4fb099efad435c5917acc5602ee51fc8d826dc5691a5afca5eae4bc3ea605fccd449875fce30f66f7aed3f105cebcbf36ce40691b4a69f8b54832b9b02c470c1a9353c065abe16e63bb02fa323b8e0b0bb1ee3638fa50678da2623009d50b9f1e39fa73935e8807d4424c4e183f52cb8af2deb6e202827bfe6bab04a76de3460f41ea2fa52302b05611e79ce65aede7044bc877bd1939d71ab3df28166696070270816d09d7a36cb0d97cef9d9862711f989c43817405a4002c84d8973b5d832bf0b2e0831fc65eacf672f0173a401356e6d9da43af5a39eceeefb5dc30f4bc6fda7bb17312c34fb98a1228e0f2d14e54e03bfe209f76cd9e3141ae894aabc20320c0fcbd1d0a47daf0d2e4ee7ab4d960206f6daf88815dd3295b428129e88f41203200f673f4975f29a7e1243eb9e67bfef3aa90f084c94a133fbd0d3fce4c3eb726d4c633bc508bd1aa5dc976fe9e04520f6392d16157a3305d87eaa956c3a7ba9c573f6d620141773e14333805c2d53587e82b2963a751b0d08059ced1693eb72d87ca12accf517e95233d4fc3a4dd9e5c1ce374569377a032823543103e5aca6449b122f40e7211e6ea31bd778bcd0f835e944c94c2fdac59f64d9d0b81cf727ee17c379ebccb59af6f6d5e739805f1b08834385b9201978fd0c45e0d8e2524b30042118412db5e1750ffe8394160ed6053b4dcfeb49899dd5542b1fb7fa2a78d605c7258bfc5c6f29e634c69ae39d8bafbb7382da1a9f87e8ec22e70309c16bf45287c9d176cdb544aae083944c68caf0222e4adc69c1dce4246d97012322003a4429d5c732dcf1180e39572d389a2e841562b873f22853785f31ca71bd54cb18b2fa66032d2c6ae2d82d3edfb42aade5d0478579453aeee0ec66d8051075416d20c3287c900dd8eb5a761ce4f868926a479b06abfcdd1e5a0f5ab5c3eb90983ba300a5139d68e6a3e54321ded5ba662bb51a61ee2a3d9a10a56c570f41db9267449660f2fbd5e454c80854b19667f72d07d0e27044b3c21deb0053f7ad199b7a1ff4fcf82af63115da17543d36f8934887b0f12c0be6f00ce6d99a60f8a0dbbb5efcafbfca3b8dceaffd53d728c64dd9f8235c41480e84a2a0d9cdfac11f3ab1a434146f92c6eb23aae016a90bfc9bfcc30a26708f46ff05eef78c5121e4ca7512681b7d7f3b49d32f110026c4ebaa4c9e914ee1f30e418f9a7e600db4bee0cd2ac081c0d6906763c984b66410bd6ae35ac41a0082f88eb71c47053150bbd2c4dd04e465da4a6eeb2e2bd2f9a4ec42e5747c0dcf5681d998c3373ac89a0d5029a1f2d717b84ce19e1e72c65436cbaf76e8d1a71b392d92ae46b8dabf89813a37ee2b97e6bf38e6e3e1642c1152a15b27ee702fd0d5126eefdab557df0e0a9bb378aaed3a7a10712aacce0f41bdc93f0f1c8b617cac6c30d0b59a8e72eb6f00bee414ea03b6d20f374cf2202b728d12f52b67bb4e6105925036e37336c8d1b36d063251e3cc83cdaa8a0a9631a47d82ed84bfceb9e503f8fa0758d8d80d8836a60eb3d770f6825893b6617d2de85f9f395f5d5f82b5f3cca49d0962116e488316147f5f31d90760034a51d608f95ad5b61969429a8ee2445ec6569a3e58cc88a91ba270f7bca2ac81aefd421fb4ea459de60b92d769d51050b0026560f893251868e4ba99ddc72cfd169e67fc2daedc9b4157894cc9f83551df9fe254505949d01214a704c1295adfbd652258c5f722917933ce548e8d2a2b95d645b6aeef459d81fea1b81be09856a94c7228edd27a79a9bc81c9596603f48ed4c388dcb67186b8305b61b330b9e2f13ee9928e986e11db117af614d6615cfe9d2d75e44cade32e56410cd797ef7767e0b9c5d624321d2ebcf4e52d477c05ef8cb051611fb8d323300eaab62c70a5ec988bdf0a74e91283c15938d998a3911028570fea38e8f27b0935c1448c42382acfeccb771084e77544d482fd8fdb53910bbd3d89895f01f0305221486e9e36b94368f34395b37b5c475c397c0517954f4bbf1410350cf22d9fa82c6be4034431ae2d7db2eef61ea62789660530589c635f06a97c7341c3467a44837570c7dde93656c28c2744e165b87e45aeb78d1295a3265b33462697b5419f2a1c9fb20b7a0193b9c594123d6f0b88a96f9bf0788a7e829c50a070be1d30303f5fd69162bf538a03f5ac7ebaaf3e106806bd8d801c8292716d51bf28fcefda20868572acea478a51e0758a940b355b138b1a6df8b30a23331a8b43170a0671715cf0663047f51a15a76e3993c8967027c0477702361c7fdc9e8385ca066dd7aa83d6a15f8bb16d7d969a831ae2905b2a4d395db2dfb124dd65783c505cde48e262aeab718cff5b5da17b4b0e41f58b7965ebc5484342f716052c4e870fdda1d4dd478223cfa3e1b65415566c39a0596d6a647f6e83fff0b22410aa547b75664100b60fba1067a555e76012a7b0d2de1dbe1343538421bea14482ef55e4f59efc21dbae2c63c9c62d6e05c5e890e72e6b259813b52e98bf1b545bd65093e0e15b26561e6fa28838e6e0dfc7518d92fd0e9417f4b8a4da787a8ef792ca96f2df9eb4d5ff03dc75f7d72c4aa8b005924a2504eeb6adfb2033c9c059d7da4cd1d5d63f52ad5617fa1b9769593ef35b4a3c6434c851a2472ca02f87325622da1000ee48ae81f9808883e0988ce787be13b97e96d096e713476480af39b8cc9c7c95a8dfe96cddc2e08daa5271c57958a102fdedbdd97cab0850bb83559ff089091f5822fc72f487680b5b659324bc354a5f19e3fc306a268082116ec9eab3de0277c37a6c7f6b5b38845249ecff5090960794597727669675a96653fb01b401fafe0a165ab105d379669c3b195ea7c1497be75eb9dfd134de776ff45d285546e79445731af6b1e0e80dc93d46f3f6bd732fd2a1f15201847c5592cf4b9fa8ed33a04369653d42e0616721e8950dc9ce9ca73444120c93f6857b8a6213564e7a008e199634e8618600a98f5b5ef887edb9d677544d56f81f65ceaf80d1dd81482e4f26d592dd44b7a081222bc7ab68aca35c2fe9f5546d0f3b9fff0d6d23829d0e59d3eab6719371fa7cdbd552be866232d40366001026f2dcab0f07153da450f8f1cfa513d793c37c28e45e8ea0b7b9107a2f51d4673140eccd107c3e4362517248cffeca23eba10e76c587c51c74cf8c403fad3a4213ec74c7d174373ed6d33be34ec034eb5f9431fc13755895261e6af4f2a4b7760f64a6f8aea000daa22415526ef75ce9fb2aac39af4d9af836b596f0475d762bef1e8789d9639d34b9934153e54d34faa55ef21817fb8daab09274532ec5bc157a886871cd00d466b4b8c56de1cfc0d50d115b8eb4a3dc25b72d143a6cc48c59209f2327c68eb74f81f36c69d8ad758947932e8806fc255f95256884c148ccfc68b79cf491790a96a82b559ba6b0f45d438948de6965f2590a525c8a07224637baa216b610283b3440037cb660dc003c8048f1c098e19de6812b1bfca17a06caa9d89ec8adb24674c99d349b4045dffe7db14432943207ba02b9e41f9a267ba3ca161873c30f8988fdf3324108f891fb132087d9d92a54da6a0f5d7dffcb1473162fa430038b59f9c29b1127d65bf6f51c93223532ce3cb9f00e712bd9830a2df21ab9c0c1802799258210f55db61b299abe1509c4f4b9fb3ad2e6ff5ed606b04c3939e2348ff27a5e9a95f6da0bd4ed8227c8360494a3252001d1087ff7d41a8cd2d3b98ae4b805d8cf5fbb3fde10399953c0293f38285150a4b941c5ea947adea1d98ad37137807060a6cd0d3a3a5ec97bfd71657a1dbebb68052fc8c783d8b731511ed4a84e40b88de0c88ca120fabd0f79689086e40d2e25d7d27c6e4b80d52c84e8d3887ec42266573785cadc3f347dcfcc8eeb77bd5bc920188c4fb2c35a7956561ccad6fa95be7c7555269403938b7a96076282c6852abba8590c5248938282591ae30a1cc60bd45ae69bc8869f2d407612b45b3235b20f6be332fe4e8fef954aa81f1a8b97f06c0e063558808490f3fb03720e1186d0068a36c3d06525d87d8f9e6e8c66b117c1d8315d4387d3cca831dcddfc3bec2f278d1046446999f8085c7114c35db6ac605ee9ab659d02f95ce5e3da0b7a683b735cd75716cc794a3efaeccf2ff222b83f8621995d8d350e793d29e82fab8c9efbba911daed0ccc5e54eb899a00e5cd5d834e20947067d0295e8d42e90ff33a35d48d6219c549391f8090efee1a8738a0fdaba8c54a1001e3f5217a98dbd1463826874492b7cbb43ce9d6aec33577359c90cdd0cf1f1cb5766a2a1ff1c978eb297745386ce6d5428aeedbaf45f67de091a59efe2d1dbc8bc5e61d9c961124799260156ac8b39905778e3093e62c2ccdf702fe4527c613517a4b2b4cfa8e2bc2e1f0a379991db4d042cc601e9689a6513277f11161718e94f8e1e1d1997344b5ee67a66c9cc5b6559b14d68aa46c282072a001fdadd057d11e7854682764f309a513743bacae70c6822fad17195ad2c843bd226305f22909d6723b528e26b4eadfed1cc5cbe808a3ad332c2a31eca8667feafa26d72b5b1bc008798f50f8bd3058495e7a92ec0529a7290ba815a24ed74dab558251f945dc88db7c25f28ff207aad3cd16196d12299213db17efa89ff4b759efacb3188b8c99d6ef48e1b1a99007993ab147a9638984f0ebe069e91625ffc6f8f8a3fd7d7754a68824eb2405e0a8bec9f001df3b35661a59923fea1c4efffb5a6a12549d7071e8ba66a5d4c2482f8fc2e26829075767a95c8d0d10a43c3c23f2ccb5185d10bd247e7ba34bad9e2ef8e41a2345bea542de9194a858c720a0045363578ce5391aea0207ba6d508c808bd5a4541173aaea48fcea15f53b742b8d8053a797c9d7796722c1a8029c720ff498bc5158bbf6147d9b4e7aa0d5176cd823cf01279e0674769e83139c3055065d0fc646644f7ed9a0ee98376c476c9e3eb959d6f53c705f27e99db9fbfcaea7195a719a371f45f9adac05a6549db4aa16129a54167c3928e2a0670083756d78afc8cf9c9881267dd2040da307c7251952ab13640a645e2dacb40663c19977f6a97252a978d3c5ce08a8cf27544ba45bd0a5fe1944b986ec43bd3c747c310d3990e927ff5040f3d1cfbae24e5a95d55ae692d6f3f2e7085c4c4f728c35baaf440cbe4973ffaff9c87ac269104dd5d8d7587dc16a887220f21ca00c3c54195a3f860dd0affc5dff9f156dd4cdbda30aeedc27ae2dc100f5f873fc37a8c88df63a54fae78a4b34b31d140035d12fdd3302d9c287821bcb9a4cc9515a899a7993f6563c9a7f4668ba8522b6336746300c463197b6517d40ecac5298cf0e85621b5dc4a85fbc300f30358e7fb11615eb1b9d1770ab09920701b1fb3371991474edaef727642eeb5e47d476d7c2db078b3ca0c30a137dc6716304d6c82fbfe7bd557e61128815310c10cd9c2d1342c0307aa2500c9e4cf380cc1b98d2bf83a719363b4edaab7cacb942cc7cd6f0ede49613a7a4509bea39ef196450cd8dee622da0fc43f728a29c08dc18712a51d07d3089afa3c883ad5a04aae3c61c9eedfde16e128a3498c029f04a74a2a28f713a72daa34264d28d9fb637cd9c9b0b17cbcef184f8d6f6fd74139c18192eead0af119e1c1df3fd32b78ddaebd4984d0436bd31d342fa31edcad82b679b5547a732c8301710e2d3d03bcb0baa9ff8e3892bfb2b6522943427bda35330c3db038e7e977cee50594ba33fb6086f5666aff424e3107ca7ed1a393cf4efbcfa5f2b14dfdc8448b347d70d9a4185b30f4e0464103473d8ba4dbdc0579ed3546090b12938000f2de1cfd61f74287e83b9d2a3148dc65d4eb42b01f08f97d32e14cf77c5405930584509692396d077a901b270135dc45b18a38df9025e134757681947ce671638141a2dbfcd06c420f692cf8186a0a83e9df486ef5cbb291f3fba13c20620db0d1b4167ab3c902527adb114d4bd448e9dcb3e96a70ba368a76f5e623a46167bc99f50d5b64f5d93038b42d4948739c6d43e1414e864d13bf04bade40a3d23c4d846ad05c3f535339832e3415c4d6f4c82f778b4e5fa67c26e8fe768775a0699f6ba1e09eb828e64f9795ab7247e2b771c13b60f6aeac4bfb8f16347904d736946c3d2a1d1528084acd6047fed9207946213ba7773e0b11132954206b2bb26ef586ef2bd8a53476e17581f66be43df8f3af1b8c9a03c7d8068e84291f526e233f2c018ea7bbcc9a8681c38ff0b4603ca374c810e579d9c07fa313dfbf989add8587187ef0501d11e864b54f2b4625a77494bf1fc979036e7fa61e0969c1f840278287d9d7c5f687df51f4070cf20b8dca94fa12806fb4957859f657cfb8e2409e44fd161852f84520e03ffd7dc3cd906dbdbb175baa62ac1f6c6fa52896c88fa81960d8a691d4f66d264fc8f214662c0b5db02e8d0727b7fc951357b1d5b4569bf7166561a0adbb383232f0843c0e76e15e94fabaed8cd4d843ecc916efc13bf16cf7cbddef3043df6058f1fddbfb208976095f84820b53c9186bfe7f298b056b0ccd813c9cb33c2f3ea161f50912577ac6be6063a97bbbf8987c198636c97aaa8ad491b7239ff9a90d4b475c4e787542e39f6a6ae3e2e24c42b03a2550797fba7dfe4447b51789b0e4cf908a89bde5b83f6915d001a76447a7e5fbb402bdb742423aa690215e06f2dbf6fc6982ed5364aa5467542102bc1eaf29b54b0bb7131771a919a1592a1b53f96838343c96d9e902f691e5f0e748ef4c579fedf847b97fd390c2a7704e4e402337fa957a5612fafb317f7907dea6d97fc6f9ab6a08d35576ca2ba2cff2a3ad0e1a9768bf7039cc30c64c1ea98829dc2ea7f3c57c0952682d629b98ce6ae622ccb2fbf43efa597d5d6afb705e637d2bf4206a88290d0a716933d18641d0f9ad4fcf75a0b919d715e61259356766ab4c3046e7ce39241f60c9174a6d054c3e92a1da50c2ba0226acc56e398d6110a09a383eff220a024b559e1e713c5f70591b3b66543d74ca6cb9c4a803ee47a4ba8a03a9d75416cee01b5a24590b264331efed6177d7cd3a028b6f6199896b579099238d09a53d26cc30b80ed2d0f9a35184799340dd65bad18e54a1970e1e81ad8b12672d31e03faa97f09ea7118f2ec498fd054055a347b7c1d265a56b731e5c8379de4b925127e8e24a4a5cfc4d7feb2c1489842d83f7d05edde3a82ab4b2a63828391e72061596286ffb03bfbbab07784d1d8392b889e0614020b348b66523b94542d02e072142cc3733c22c1576da412c9016f05f057a539d8060efced728c61b0b18f3ea1a58bcd9fc068f3919f8b7aaa0ed9394862af7482c4ceb5f9ee914b3556b9dfd8f7e39ffa13bb7168f578aa98418e5860f2523110f2b0787b9eacdc5b11031c5104829c871e982b09f854b789ace4b266b16d82874488258d352045d4d1e7dfe7cd9d8d40f6890dbda584b6191cb52d8eca337290fcfac2723888f82ca10208cd7096ced0696d9c11ac8c3f1a6f1a5151623ed2a3a68bd1f4064147d6706a3d95cd7111178adee203b16e6c98a03a97b80450eece4ba6fc4ecb4935d320770820ae0f3fecc7eae16054554fe5abcc41214a787451695092dbaa5a146668d34ec836326d02b797054e8f8e3096877b48b2c0c056a9877b5113637d041f94fd116c18a7dd53afe20e73854c877804b6f3202ef600751a3ba1ceba2e0b3f8f7aa1d2bf3c0e9d2068176862e99c0edc308c2f18d46d890f10665e2c217355b99a7f044c58b09495ad4a7864bad4be56b97fd7bc63d7b6b7628a5a5d1d68bf63777ec92afa23742f6ecbb3c8122537f243ee234a3ed89cd4307580fc3d9f476b46bc46c544c5c913cd8b27ce85cf209f855879e467a410254d97d5fec251b32859e1319f87bc22274580877bc2d1bd29e5be7e5a1faf5e5fa17bc84cb64caabacc991b0de23b1a0891672fc53b643a2c603a23e0f44b4546e80d197e8e20a0158e0d7f45cd5e9d28295e3750abb0a19daf20f8ba3961d851ac3307aa4e509bfdcb485577a89c458be371d92e2ca89442384e7b7256315e337121632f33cd9d191b2a7493fb23ed2b14720b324a3994974216a1d68f1a8f14ad1e33e56fe9a305fc1eb49f2519526eefbb1a8fafd5d06a6bdd1e25185c226b2a2d848671b94103261d7c909656501717c7509ca5b967a75d204521568d45daa118c6fa30804c87bdfe25f6e23d7f36b43c8a760877f6d873ff64a03f54de249a57908738cf9a30299a92ef0196898d56089480eb7cc736738b2e1ef050cee2c9b0fe747e339174eafe99d6d4cfe1d40961c7951943c456260ff41d976f704a965caa76cfde5f72742f573aabe1e910ae8b2beb288a03155ce22ed0115efd7991f1140105965f3275a8ea238c47055503e822b08f99efbb13cb166fb9575d0cdccc7b37767552d337679c01f2a2f449ddc8f55786f57038eb8a98e7ed449e58057233c29c12a13ff110a532178cfc0d02a94f3fbb1faf6f7ddaf837571ae76d37a3368444a0189382a19e045daac76cd2b1560e3a305e8f393029e9398299ce908d4c2349d5f0ddf231a3d1acbcc2532e1f7c819be5199b4d11a5872a1ec5199878c53c03f8d4ecc7e285637bcc4c5268ec92d792152b650aeff4c6630d2d5d9cc310663687045eb862e11ce0f3d483508ae304aee6613f599c4008bb5e41a43a4675ce0fda07ee6f174fd45dd6aed2c595ffda856b474790cf5c62f044985167c4d6c794659f5db44f3847cfbff1209097f4c79fd0c1ec30ee00632f279fa8e8b88d1d6507cdf3a218e7934b4738a7ba81798190e5333c7b4bf5a9e18fe8256ee7ba5b55f86cd089f5660a640854f70d3c2836c921558c5004562dec45dac717","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
