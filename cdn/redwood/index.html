<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1c2135a5e791ba5ff8c4d37ebafbf847c486c1997184977ada64a723d774d509f30405e15f78a63006ff5e505cf116415c903808622d9905a528d3480ddaa706698d0f79ee0407919ebd82c2030a2bdfbbc25f017d51b65cea00d4f62ecb2a1200a4cee98f5be11913d650084d756751c5e32de0a8713977105a83ed3708a26ddd9724c254a390c826c3a66f72600c17a0dbdca0db8cdd3c35fa64fa1b9a55048e2fa4841670516463a04cd8072dc981f521b62688314aa2390d0f26d368ec6a9e80f4927d84987dd8ae322f76407350743fc6b2620d73419077d2db34e5f5dc36160bee902f9507cba2c93333df200d6b5c7a61b22355f3e521903d83cf9dc8cb9778cd3e2065afc73ee43d7625b810d05fe7c996e71c35a5b7648dd65284e26cc8f278da454e335403732ecb21a4d4c0f2898cee13f5754b94898842a3b7d10a0804f9b32abe6e51a0af25307d2426b0305382d4250bed137b241a9b551de673eeb325771aa81a5d39df01888dc5b4b151cdb3551e59c710e1f79039278a1cbc1105704b64973fa0ee408534287f4aa859a65d0e5876c0dee376254378724b5e183b30c3f4998ceed32b2b6590338f1d7f0e05fa4ea58e7fd7dbe2a81a2d649729439fbd7c0cd29c7bbbcb230957e3cc6f629407d949d51e9f9c2eeb91541838239ad02cef8218e36ff4bc518190fc2bbde1c31bb5151ae37080ee8b16dad6eebc2935fc4e426e1b4b0524b947c6a1db893e0ccec0a533bea8609cb8373f8476fd60ee9f1debee71619811638aac7030e834b97c4b44b92c0887b01e176ca4cd5c25421dc28fc268edfed4c576b6ca7304a0f42eef39752396b18249bb9e7e16cf4bfdf337ba8c1651ec632ef99b9a68909057b6125ee1f67e8c7a17bde11366b75f78a72bd183ed12392db69a0c815f69d01a0310e54a95cafbaa6ad96a2955066fb9add008814c019acd4987418f5261c8f59ecfa1a543a07aa9345ecaa294a656d0983a6b25fbaef3d700a0fe25ef7a112e632bef65dd22a4f50c1962d049ba743cfc376b7cc6d6cc9d2cb0292905bb25ff2405a5be0e218e1ab9942347788ae8b40fcef3dd237996c34416302192e5dfe977780d3209f5ff13929ac2458d1924b460ea755da42bf8f885caff76292896faf0a9128983ca37388d92b3800c24889619b251577a7b9ce6825283308664b7268baa9ba74c6e44d7a8c2603c7e6f8fe800ad5e369e7e63c7091627b8ada327783cd1be31a489b823c1e98764e2cc64d5b646ba86b7cab95bb00c086d4e2a3c52e37e387139fffa11d23a4210b90178e92ab13756dfb6e04c98ff7247675fae48995d285e4b31e42e6f65898db7362f0d5c60022f7c301f93458fe28caf8234ab29c23488f6c9e920b1ea924b5a54ce53bb2786a5dbc684d76eafb04ddbb3f02a87f26b76e0630cb9ea78e9c96f8302c58014dc1f310f347ba4edb02cc5175afb3333bfd8b2c1bf7383416a3b99170f79da1723f250b3e8c4c06d78169dc839e893133a51b07bc7af100e21ce5bd30bf2cd4e82b6dcf2edcdc1f1abe7ae0c1f7e2528ed7387aed90190bf3518fbd4de4f1abcf4a47fc10fd123aeeea79be468394e4f0c884b5a3bf25bf19f64718694db8474061cfbfb7a8717313b109169d76639cf01e4267b5ef20d7c09011d0345b5a1a0f6254248c3d8eae5bfacd2532afd6015175ef36b2dcd3472af8ed4abdf11cb9e7837de7f9826431ae6d9770a57f6ef22d916b0d0d021d6dce264927e52e9fb4e2ae9578def486891807a643a49dfca508bf318313170398440565a74e8a7fc8cdf36d983e0220e377fa46063813989356ac3fabf6a3fe4a2fbdef73f7b8618de71816659a7386105ab8f5526444f3a7559f6492952281fb715f1b390def5474791345e80a1c9a49c6db12dca369a2164b8577fa491c3abdd0570f895882331c0a6284d6a6ddf85ed20788ea50ffd0f7bfeda2fd0d57d1c819bfb90ed5965262ba8d122170704e678d9d606d711f01d7b7f9c3a45a33e3b8168cd7ada8f917c3e4327c78644bb9b78bff81a1131cc1c616879eea07a0f8c117f10a4329e8381e24e31130db3e0eff054ca0297e3cafbdbe7cdb29acdcae45b0126f0f0851c699a57dd40b4e8b250364ec86280762a1c862c2f21b55c7fac25be86259443cc3996d1300cfe0616cd818918c988ff982e2ce5992370c655f4b901946bd6f78d272491ab8d45898822c2d5debd0e02cdedaadaad0c18e52708070bbd0331c7818326ab99c5c622682f691c595c07e4ce2e844f48f0404ab3cdb867cfa35eef712766c2f139307999f7d1f3ff96273498c4e9ff6e305a9c1074ce03df92f531768ed00e14315190e0fe8af8a470488a30002fb05d5fa0c12ff780f17b716a7fd6126024ee975c03fda60f5694bee774d8ea55b827f76ce4a4ece48b7150916b9d778bbc5f499c4d093dea8a57443c9d7648a941592048987ec2ff972150fec9a7869033c3d9cb593935c480cf372800cbc12ae53fcdde53eb5c1c13534df42e0079b0facd29a1c888e1990d9cce7475cc09deb2a051ee5a705a1d228823b209d21431b5c53fe13dab7ef0c0b0dafd7ec183dddc9db8162233a7ebd0ab91aabf06ed459503d847a8193316501e2515c71cc2a2eadd91d7ab65c0764ab8ec610897bc9b934450bc00ff24f5144293e097f0837ce4c530d1aded1166826ae0d46b6cdb9932d45a2f77b1c20c0728b8481dbb9ed4240f4800e933f64a77454a6ff99eaa83979ffadd29d95ade95e5faebd36f56b1815e72f4232db2626700cec029df7a39421d312885efb6a94fe6a5c68056b21ae9c66f2794c3134165512ae75fa1c437b8cb25db5569e7d54cafa6fc5f70cec9df8e8bfed44554f0d3c919fa467855a581492104eb897e264ca665ba61c0afb35f9ba3fbd2cecbfcbd11943da2bba594c52bce89f62455a642c0cf17328ae9a46b721411c41e9b3f61932e7c729c6887d6b8d759f1dd543ff05a3f7d8ff8ae22443d81cb9899fa2b26c4b5918adc29b243a272923a956de56d287ce4ad66f8166360e0bd1e1120da851b65be697a337e86a9dbffdcdbfb3ad05cfc287a5a47f1c88e56454f61a65d358c235fe8da37e5881446bbbfd661cd046a4125874315e7737a84052befcd1ebb29e3267f17d086ac7c4d6b95102e2f15e7893c6649745a625e42ceeb81200baebce3941914e4da671d1d414dd444dda095c713460b6bd40ccbf80aecda87dd8f231a37e6c10374d7b4edb79cfa3a2f868045fc6c001010e94effc0bb33d064bc005c3f9eaacdc17550bfdbd0bc58c6328a497bf8c022d555cf82453bf119026b2955bfb1036b303d95a8585f4a24669706d1b4203268b7a40ce0f753d63d07f5ec5aeff512e514b7b5a9d864155b68ceb96b06a5de8cb6a33d91897461a01cd30573789a78dc4151117ef4e1389523804507c2e4130cf34e11190cc510c6406f8b21a5adb4e2a375a4d06a84339029f2733931e441eb99664a70dd49059e0355c1858ad159b6f51e374b62bf34d1929e6315a1eb29fb8019cd1aeefc447989307553f2cffc930f9e6e16c9382c2dc5a0b2a80bc17839b181ff79a8327aa1d3960cb786b7b71ebd0e6bbe2eca3da4ddb5fd3ee5e888220fcd43bd1cc549ab06301df333a0573f190e8ce1ff54085c3699a5e1f61299f21431e1c00a8ca4360923b2af7ef5a564d04c9625df0f39675e08b50cdfbf5feaf59733c7d72ff70bd807c04868170f4007fc4daa883d7115368394c6b3456d27022e4e8f684a7fdf62be60f207fb9c04230f6f34132b30d401ac663caa9369dad7d2a29bec77dbcfa94eaa5b4c95b8d6e1abacf52d6a6202e22106243b23f17cc3e419a94639106274f3e64e4429b22debb0276fc0439483e33763a92de60c22bf995e80b993ba775a0b3e2b4a9431e41d8242c45a85ce2f2d7918a1c2fcd26c385db8bc67be62a0b4293e2cfefdbb9f7064015608d83ae34463e2460d2ecbd3c361ea70090ea9a1d045c17af76d1deb608204a064230f231308be9baba1acbcb69d0626f9acf6a0cf3e5572f78a0e677b29ee0590f4de7105f1ef05835255f11731e6d02ec4e6b8d03515a6735d47251558e15ecd20f429eea6423c903aade34713c5de9442f995f3e3aba4b61291dbe153fd29220e3342fee1657289a6dcd93e90fe504bf71254870d7d42487b02c819a67f6171dbffbeba3b82904fbaa264b37e2df5c1bd2e9373449fb7a2930eb0f2c6652b529c0ea065fade75da8f11da3dca008cb558bcacd4fcaf269d0e3c3a0f964308a1df6ba714137cd78de88c68fa27b0765b7ed057e2ed82a2f857478cad8d50d794d5b50241d4c438d26f957913b6983ab9fff596361ca3800cbd75f2886bdff8a5335ef00a19675d9b02fc7f2c890f9396f4e4351680e2a4ab42f350ece60254c89f955e68f4c17459fe6c71ce123795c5f408ffd9cdadc33ff4818ba3d7c3ab450faae974537bcdd7bf340e8c7f5ecf44df1420ce2be08d83531c22d92e5145e6b335214624ff0d7e0d64cfd283ea6a75ae66edda8f5e5eeb429673d7da143cfd14a69a023470bc03d2fbe2b3f2cbee244be3ae9898bab22ce7454b2ab710d8144f50b186fa86ee8e08dd62f3b270c0a35c6fb354b2167d77e162d25651c4a320b1fac8df390eb2f228c4f94f7cb9ed3b6dece51d65b54dc9f0eb9e87194e7817db80228ae3b4fd44e8d30b57ff807df80e90f53e6444cd7df2a8d783ab15a2e9aaeffcaf7307cea4a3ea73126e8de3378cd6d8d2e4e2d8b214998ccdf2ee2b527c41de0477a0210108823eff8510a8669417565bc4a47dda4d08d879c2081316110d1c2ff335e6846552e2626b66cf6046b5c0e2ee4bc3b7f524d012183c273aff39bf8774d4ef8516614573a7b9ef8ca11a307adbeda3cc88aaad2b6d2a8152cf3a872020678a4646a0b4a4d37520de70174774e5c7ce8c422e06836fd2dfa248698ce68306ceb4d2af84558c5bed8602b5a8617048a958716932d3bebffe1386a7147fbf76050bab16dc60d46535eb2135551421d1c3a3454ad1c6a7a4b2d41f1889fb8a47ee549460fbfc3335114a3fc92537ea0eb6af0805c580076c2c89ddbc70b1b3927eb15026a0db9378bbd203d1974f28abc51c53e0f5a6cacda3ce29e2bd4d7b3ae9b5ac11dc01351db3a3f0fa2e7533b742aa7f7561b859b839f49850c5ddd4e9fe90b49b523c262e7364d30302c785677f0c073fb92347040a31d0a04bb893476d14c9ab8ba1794da7576d3f54bf331d152d8f33034081fd34d0ca980b21c4380b65340b6d7105dc2e07faeb765bcfb7e57769f56a2ec42f03bcc91eb25f2fc8f943d2fc64fed38c12669e610f16ba8e9fe94521fc9881fa42fe293ed5863396dcd02a7b97fbb526eac3ab399b0fe84789d01ae5244115072dd73be75ce236eeee62e0a44255d7a3cef0f8cce067b286e4583950724c70377c0b68fd9ff518573ac86aa197e1f0f57e369cd670631d2f2ccf1f226065a407cdb42f35997a29e14ead4424f3a012c044fd298a5fcb8f648b2a9dded89b6215edcbd0da717bd82a84b66a6c7e77640196be4e69df0e6182c6d083193289a57ec775ecdb850811bfb615ceacdf6d2ad6825957fd43b70fc7ff42c11c07b2fa1fa72705b5b93d0df59ec1eb67bf3a87629239faf69dc9607d717e30d0cbea5a76c68d4199fe31959d3a96f046e7a85204652f09280ff64d3111151e94dd60425dd307091ff5ffd2cee1fdb5937cda7c28e5ef09a4d3c007859c939296bc34a81e1a687965e5172c7fa84dcce8c34769b510ed15d91df19e40f162b784eb747c1b11c089413b2ad94be49fbbf6bd444f986122f591b38a7b9b4a51e6d969c6e76c7d3c8ea9549a2594cebfafb0e411f978d069eb6096a6fdac2a788508def692e880d5732997029c7ed24e5f2a62d69a2e89f138d439a7c5f06d3d886e25b1cadec8804e07bb9c4d6e1452459cd6fb21118f6207c6d4d7b8aa80d464ead4a13d01572108b80975648679b5bdeda644bb62061ddfa16850103affe906fa7152b9efb8f3e020d86ddad15f06e5f038c116ef88638384a23b6f8fd41d806daf8afda014515b99e6c5cbe7afaaaf561e6f5a331206502a4626759fb564c13f96ad1548bc0dc5b6b9e9456054259f68d5161f50ce6c1c7a564236d1f1bb5bc21f4ed3de50efb4548f40b00f7206cf33ce90fb108bad7e1705bb5085ffe97db32da6b7d61b68d922df6539c94f9c967a57e77832ee2e15264c90aa7dababaa582b9eef2fe41ebb8d9b39d95e4fbfe2f8d01c91f15253188b849a9c77e2e7b4842ed075a70200dd52312c61d9b1f68a0e5bbaf40a09c517910ca4eb17ad6c9a1632786f7fbd4e1547b5303c55227337d5b3a051b209b06288ea03e719c6d9914467b9aa9ca79de096af1828739dac88e5a9f7952836cdce249c1ebf2b2e889661fdcd1c1e13d08619c001f18dc99d3a952219977e4ab0cc951b728c5ffb8f6508b37f7ccf2a637609fe8c7a3400f03c41c535eb18fb5cc39cdba941f05af2f9825d48f2596cf5d4ccc991157971de31fec9c748257efd5e3cc391fbf9838aecc3429168a235db06e26a97ec97a6a0a4b2493b6e34e985fdc9c8270794e9dbf8a272114f1482e24ae45f1e1a5691c6d3d3d7d4be92c5168a9659e9323ed68600151485c2e8f3108c2025226790975ca51eaf758548f93eab3dedf6885b95b613b5dd483b99ba65e662b3590f2d09346b92df52c853088e4567c104e6574c681d0d91d314e793f570a8b30f16709d35eb18e024293af694bf69ff3704e61a4cc38f8990db84b0299cebb208fc0b69bdb6cd985bc38664d8b794ce71b414cf11bc3f6d90571dad4ed24c74c3505bc1dfe5ca123b484d827e6a4d0a2caa8e021b43d46adee3c3bb3bed416a1d9d80d2dac5fa9b55b4cb9a9971aeae66c4626d45b5ca15f85d8ef32b9c8d6c91d660c7f5cd179bab24c990fb1059a50fda5a612959f0993a1b8056bb06e27650d0d02b83725edd35acfd710e62b427707b83091696d522e5b835968ee318a076db64afafb4d3b1f97eeb947f618fb268ec162b479d257c73f3b2b84d7b66a11546d14fede5c9e67a597448ad801e6f4c23cdc51528bd2e201af588d65b9a70cd5a60578df62abd14bf0aebb84b8974542053fa31b8b3e518e864a44064e59239a551d78d9d94261b11f5c4043a214767aee16f190af685220d0d6532dbc1b63911f07a60c1c234e4ac57a731810a059b8cd53435ccb606b7ecbac4f7ac2afac22d946ab28df94f4f18c5e34c0f070e1c2697c83a2edf23c5bf263a732f378b3672f2df242a0aff8be3607c7e15994d7680991fde2df3b510dd0b48985d9f6a7b29fb45f58c02339e7eae9252c135a3182f2dcc6737ffce8ed0f06010ecefb78d2690950fb0814e3e015ef52a9d8d2d4ab15089b4306038e09ce8f428d44d218a628d02fc85296165419d57237ba79eb5403a11231ec657a313cfc931dcf31fc6261fce1cac6a3d9af9e9bcf77b64158331e62707dba6952f300d07d5f80ecd385264da133e60618e423f736e0a3d521fab61c18823de30f11ebe0296f585244d5d166503c3d77790969c5f5f0e3808b14e75b9f1b04398b016dcceaedbcb4f49d6eb31e1bb3356053b13fb8194d4f6cc9adcfe633133b93cc6d1b78f5833047e4a0126cdec591399ad0e3b9668f2bf0d78487f98ba5f47e5b63b0444caf771606a117d7479d1d48797ceb3fe831d3f503afb77527223fc9ebe47fec235ef23b92c726196cacf169725c2973999765c05d7bfedc1898d6ca34f91cc84b1b718425fab23b568e7f31f6feb52f8eddcd2ad1900a74c6b0a882dd4d20dff7bd15381c2e56d8ac80f9df3adbca6c021c4b278cc46c59b0733dc0e9530cf66d0b43b583bef034cd30fb943c67738f34624b4bc7f0bcf4acf4db76a62d23ca47cfccbe5079e4a6e63fa36ad2c4274a44f8dae1e162de10683f641ea1eea8da60865382c5f325a3d39f4b189cad66bbc6d51145876f5092ff36fab46555929709e0963692d23f666aa5826a727a55b85fd637a083978f7692389d85231dc2d963291ff9c2654434b01af5ac1902f62a87383c34ffb7d6a2207d028076dd3be6bd69fca4ea294ca75569898e384e72181dc8199da692875636834f4ae43cf73c9679a31b8c319caee35c26242790a56a61cbb6dca79bf75f88479acfe185a7df65b2a976f136391884ae75a49cf5adff8a1dc97e3d1ae9f5539e9a26242b284aa44bf44811601d004f161fa11b94045ae6b8dbb188d35a211aa4a50202d9e1befbbc66e92ee9679bc33312afba315e9cdb1b9e968f2419c084508adf8e6c303d50f3d2e525072c1d16d9a3803fde867e0cf3be2628c3cedad2fab2bc07aa4ae6f559d7faa406776847e7f7a7499b2b7f13ca7531cc5fc6edc246bd6aa2d7f21954dc67e811936f8846e5274fb14210277aa2b552cb15953245053756f4f8724c5bdd18358a95c531c6e7f624b82bea0fdb916f7f46c7f3c578305977dd19b1537950e1fd6bdca36e4c3a30f69781bb4b26f8c340eccf1d012ca56f95986d6f86709da269cae52d2fe33ae6634962bcd45c54da322c01122592ad44e6f772c3a9c13d0a661e39c248cb99ad988ca744d0452965dd968cef0fbae7ca281849a1696c9642d1b169b6aa981be0e9a6fd1bff0182a1b39479c02f575ae154a89beafc9b78f6af4a0752377b4d648291a79f85004aabd4271029d1800954acaa3ed4b92702ff588b737cb7af7c8b7b846a32c9886d031354167f585adb52a71c97d0c2d9bfa42b543bfef70ee811990127366c047aa3700de84c0cf6dcec1e2147e6c4b326a4ca9f675fd3803652944d1909810a2857d033a658e972dfa6744b74b75342023dee646e9114d0a04b9b02b8be874574f16efcd7fa2a39a6a9a8afd9c31f2e01ac8958b17faa6a652c3d9d51d6f10b19add590aa13f613a97299159b0df386873aaa4d038d31171425896161a060426287f632881d6b837097c7dba70c4896d31f7e9e8af6fcf37719965e474a4fc7e9f767e74dd37cfde1fbf4629c29377836acc9858f5b1a0a1ca8efac430b63f87d286da7525f1597039642746b31ed19ebbce7b43c6a5fc6cc7bb5b0324653957ed1e8dc03b94d99cc069145b2e1c64ab5ad1d7f102685872c41e128b0c800fd20d77f0cb7e6e9b754fb669f195f612fca77c19edea46a4cdf27901146d2780dba9be4dd9995227c6add27a8e80f4669ca4f56ef784922f156b55041aae8bffe6bfb487aacd4a6b304e8efee0c4aba31b76fcb9ced5e73fd84c8a8c0d7d462f16894ac470a0815e9b7d92181169ed8ada3347a8338c04b289fe5c1a6a89af69cc1692d1d78864d5656015234e2300c7f833e0c03fcfda8548093d805199dc11cc9148cdb6c4a799c98cbd185d21c030f5c5ab5c10d880bda60ebc08132ce070d726183b5e6feda72260a0c9106d288965b8f39661a7e36b48740723d396d9ec6e17d7eb28950ec3d82f4250558a687bba1c5ccd430320096f6d5a30da78c0365d26461a9f759642fe8c2ce1ce2c55cbba72fc4247a9e533390378586f2c34aca7cbc5bcbf1fc3e70a542a2124de4bd2320868cf28f514159523299eff7ae73bf56aa25176b6b7ab61b4d5988237faebc2932f7c8076d4e6b0eb7232a3b7f077427ba035f5009b329d089affb5b3646de4b7ecca51942f4ca7288c3d3f0ab9cbe1fb5e285d6f22981a87fbd784ac79d1a107902cd9165971a02b08b601d66936afb8c9c826cfd38e1f5094bf17dc4f56215885907fda98e9a5d96a40467622996fc709dbf5b5623150506fd16a90ccf42bf6867a002610735bd92ac1d5c179a05dde9d2552d180e97cc03b92a05dbbfe4a604f9784c0d84568d11cb952e45b78c0b5251efbdde3255ed5361ec7d441a1792e785d083570bc6c8404ec08f2c8cd4c888e61a69f21003289ffad6f5de9d41de2120dab7579173965ff25d4250f3dee09f47b70f5a71870d6b3f68aea8490302ad38d8fd4f28ef4a4c4dab1eb58ecc57bbaa6f6b9954c3d607de322ab5c990d0e193ba04da6548c2458d5caf0be7cde6093dc64e8df58eaf1b1eefc377f9c7c51436b2dc1e73af05f2cc73fa39e1dc321a6769ec97b8facfaccbff613170925bbdf8191c602a472ff5e976b696f8a0e0f577c8f195e23e0d3cf977db7d0120bd5c5046a8bbbf41c18dc68511b9debf046a2c7bcf9ad8e629cf73bb6b2532b1887de95e969c1b2bac296c81b9a6ff70c43dd581679d677bee299a0b664745a4f94ed0dbf716004a22f3c4e4f92909ad91f12339ceb2f2308cb81bfa6e9ef0719b3260fbfe31e3b1b4b374374729cc75eb79ca45e55cbabe2ba72a03f1c1a9b0b633195cbcca7dc0d8277e28056ff3682ca2f5a637c397e5b013e2613d35bc41f119d31e4144c20683cad5c5bc44d0eed9c0e530807c7de25e77b6928e0ac6821a011e7fa88e2bb3f464758bbfc9725bd397c3ae7c8eba0e007e18fbc1b2e8770ce999a428514328e2ddceeab55bd372ca88ec93c0433a9644bfacbb0f25f658bb492e9cd6f4612f1ba66734e9402d6a3791d98d4aba794781ec09a175e0e4e368768b6961100b77709cd6b2a09ccf5dfd8626f3262f355c28592d709850a1e00c015823f17b404fabc12f67a5446a3da55a51633cff75629745d3d00ffd7dc7c2534978f7fd7f82ac1793bc6d5ef5b588acdb04f5d4f90badd6c31dd382370bf5ec4fe34da0ac972f23835806e52140d8ae5a4e1e61688ad4470c45e76ea4c30b8ea58c29cdd97cfdaa3afeb8cc7c6514ac913c0e7587322222fff6a7eef440f02a7af7ba90ba64af183e635830ffb55a68634b58707943a90a2077234b8be825751d165eb849c233243965616101776b772e875868c07681f4df869d4511369df4efd5cf3464a25b494c03fbaeec8b5183c6697448664bdee08df4c29cf4cd45339140dd7cc10ebbd8d33e1a52b6f4bfff608e2e1fad15cb563aad4a9db303757f6644856bb5d1da1f146d6f9a0e9ce6dda297271004a4539eb094b25ff25936e2cd9c954ea603c3a201004567792189ac0b5ca3f2bd5ef87613c79b818516ce8392880e721bff087acb34b753b8ce8e8699cd91bc44070b2b06d9979ef5a844325b3148041d63684de30316dd983fa481d16c14999e84cc3d2a6d4cfce1da4be2cd3fae683ebff24d8a2b7067727b0e55252793a86a96817bc8b1047595edd1e7d83389c51560e572477e5f28fc633f92ddce9445f0b2b1740e7633ecdb5a47f1205af1c91be3b9399562a7ec6504c1e6995018047e2b5b8a23e747f2c359e75c41cca9d561fa7a4bb4f3600f14c026cbd65ff163caab7ac32dfb9321126b1bce6801531743197f41504c052e939440c29d1f08dbc69e2b22c7b3c566943658517e18cf89fe02f9179fcc5b27bf4d1c9d2b6c49e3a5df63a0da246428dbb4d858fedf8953d8909d6215323f9dcbd9c42c695f47425458d3851a9a00a45bac7383a964ae4f338fc881d741e9febe3e08f32545544a9fc635800b62bce2e5117be3988f7c7059b892fbbd82cc6fe8edfeba7207fa0157ca86b8c7529c29ef63dc4f0f800b46303e43a7ad336352c93d5bf52f655bfc0e5ee58c658f01df7f66afc50ec91999bbd05ab88d1f31353d76a14a11ecaccde3b243791dca505962707de5a1da2747a4989ee84c62872afcf9696efff2556ba5e8b361feee94e4bd0789a7a2f9dd75415bb490a06e84502e82ecb4117541dda9f5e48184bb56ba1629ee757e84accc78c0f7672fa85f7d8af9f7348e170a2343f69f6f44b686a11062cee8990139620cb261dad6d3c0c555870bd08e6dbae5ae353caf753800fd3022288adb466e1d1a68b9ab0283743e07abe10eab9bf5eeba3684e257dd004fc3f3bb4187023f92baf335f29b7d783ff6fff2c5dd7e66ccc01bfa55e7abd60f8f4514e5cb44d8acc12a89cf0254e749c405e12f0a22ab5cd131e556681ceaf971938a299c70e21d42da2c05ae6b7beb03f3929588344a331cfb96f01b5b5fa3f2b706840543eb70938ba244158d322086c7a29cc9e283c284243d8ec5fd6aa300ef92363263e225dafe150029ba0aba953c06e37bc9d334f6c60577bab9fcf30f9884864d28347444cbf162e82b724f6d9a6a160476b259f4220e0f27f25226780b280a58455b520606265e04eb9f1047c95f6a2ea582640176daf1107141998f74d917a6cb73caeac66bf30495cc08e1cf381c58ada53d13291689a22d32d7cfd3bee105ccb216e126ac4b9639ff1663c22d07bc956ab679e2830b59ed97195646203d5a858a0397a2cd3eb40ae90b91a940196d8f314ee5c918cbe43e137628f58aef0748cb515efb92a7114aefbd6b2e4de272d39acb7f05aae25497f50117411b0ed6478e50d6a60cdf5ddb92ead7b87fb536bb010e19ed8d7b058d5b7629c65f8a9509c0774dcf125eaa385f08358045434c3672712f2f062fce76d4db21e9bc134dc5a7873b2f0d1386e0ff36e622746fcea72e0dcab5e9ec9de989595916bab236fda0c49cc4c8274891a634ac480abb7418079cd1664490dc3ce52310b9ce4e73cef3bc4e48dd944fdb6f35a0087120765c0b5c0bd1f117bad95f8d2545ad985b4b9c147d9f2f5c77227a3402cb0f83c91aad4acc536add8cc9ca51b0d7a7ac1ff40995f82c9da5146d60eebacac2ed5dd84a96937d967285d08517c39bf621bcccbb1a5b8cc085fd6ae56f7437bc2fde90e43936309d0b3c7ccc6df3183a5477241e2e50f54d5cebe064345071c06e013fe52e395277189ecfcec40ceaee3bf05b31d60b46f05b336c25fcb0e08d65f6c688fd3863a02a1e3c42da2e29555953b7c9ae3b256e9333c942124eda6efccbd82d13f1bac7f7eb13c009b72e64d16b8508d2f23c1d2938b40a3c0b8f2c2b75eb132181ccab3600760be164d691b11e6dfe92158a09623456d876da08ff7a4e0bb2c3dab585a943a76bc14679d641da8778493e39735ab9d32e882fd1013dee3c8d0d367dec0867ac04de367508dd4c40c7e63b945f83615ff367dee37de39c3458ae1ea1d371b4b6a4c3e740adbb4cbd7df9914c9786902ac895afd9bfacb0f1f6b1503533b5c86bac3eeed666e959003876d4c4a389ef8a7dc461c99633cc3114263ab4d737ad979874af037ca507f0a32879db59208ea68d418ff17de5848808c18c2dd89d23b98a83b5a09f854c8a6a464a86b6504231671b3a9e5bcb135e6bb13b03176f4b2a973ff4913982ea941f0bd5160b06c391e9ce9968531d43096fad30dfea1300533586941a4eaea3734f30f5ce6b7ac13bfb00ea3fe2045da8c6cdc60b0e5854581c61295760d3ba7151f582e10fcfb4aab14ea201afe0d1e6b8987eb0920d7f7f07376f89cf24e785cbd6ae1452adfb409b676c58c7c7cdd43e3c421065b42d03c3167edb05dc81270db550453d950060e08830f4f477fd861c14bedf6ef20a904182fbe7fe20356d5a0c0b83a5446893458a4c2aecbdead85eac5eb2e01004c1f93547b7904caddfe325843a5a2e4ba06b92897790d6856252e260a9397656c7083f74ee1cb9ec351d3423dbb339d8a7f4cc8f99705e71064e050b927560e0b80d2444e8f4a08ae8f4440d6d53ef796f7c16fd23e35d5adab05910f536b27461fa93a42c48c6dcb37568c61a39bcc410d6a247f83d687b355c6e67d17ce9a546264cca6d90c90fe5020c1e03fcec180ce35852e038cd8b51ed1c26cd51cf690da5f6d1955f155e69caeba2783495a53ef2fc0e2985f400ae3547e63b8f6dabd3225ac130ace3d49b92671f74dce813c257c9b0c1a93a01e69aa859a9f9d53c49757e507c2236e6da873d92064c19e4c9903776db846b3d8a6b6823d1ba7dedd6d542b47d611f1f09cbbd2defe7904bd1e0e8cf4b9cab3a6bf6bb6728ae42a6495385d3a0991dad8603163c82c38ddef779d1921a563ae5f80b1b7fc188c61623cc07e9d3de777a191d64ccfb5c111e602693febce7932b9c2f9e42bff6675609a1e19c89c1cede7bd852a7b4f4b49bf0b5bbc2d3e55db78e556eff3c272f848471416a2f5b37421b95eeb32317c022f2a34fadf4c6cb25debba99d933655ed3019cbca6c5fc1309c945708c161c776f594010763c969b6a582949e73a10aaeed672d2f4b7c6878385181533457374eb300075e83691235a97742b81483475274a89b7d7d54ee69eb6bdf060a74787c8bf41975055b1f2e9e5e78ef8cdc833fb81b8e499263ce3f83abed0e8f04608096aa3a4714b6e22a142f1c3d75bc94ce3a3dc44b711e747699d71233610ac2bb20d157911da9726db49ce791d4ec71cab1ed1c6be7364b7491b9cdbd9c38801addbaf195d6910411397b85a98e3441acbc882577687a6793ad4b87219b9bdecdb61aea8c9a4881527df316593b8e9d8d1aa6c2c8da9c74c44113763e0fa5671658c72095aa3cb5c1f763f4c281d671c9b5f4cb91e39c90a83a305bda79d7a68f61f7d7211cf571dad4a52764c627c9ecbc118273614ebae4a5b2ab6ccae094ffe35c96a25f6ba2514d5beffcf0dacb92fdf7049df02b3fe488695e26d94b4fc28b38beaf61a13fa9948e6f09d886a3066acae2b2b72692a70ab208225a86dd2b1902fa96fcb369ee33d6f70fee9b7dbf350b5afa72fa5f753cde4c21c12a8d95688ab988b4424805463a17ee549b7cad7fcd6b82b1bca0d9109d81b3e59f8a277f9c63ea64cc9a0f448673b40307655e67adc4d8833cd7a16d2b32f8ef56ae44532a2c35fc2c8bea3da4a48c3de0b5d10e9169da44f67f9a961244f91b101dab9b966ff2ad28eb38dcde3f7b2c3d8ff8c910233917e4c347b52f7fca4e254ebee0349ca6d8bd47f2704a133ac0e01236e1bbd57010a4663cb323cf5643efcfaf8ff6aa7f55382d4e6bf593678074df63624f9bf3cc8bd7173a4d665082390dd74b0bf7b7f14ef0718fde991fe598abd967e8ccce17268b80f4cd8bbe407f51f1c1db75d06cbb23ed43d2893e2c37e01875d97cab6304ea0c01bbd51294a85dae6de466cb169d64db4e7a3bda246f0d9eca0ad788c275dceeca2323be218f25549b7b2cbb5e48e56c7a7717332e610b336dff7a77d72b8171946f44e23ffe5fe34cff01d40566f64b03656d4c71e8d0a343c886988225e76307dd4156b3dea800dbb9068ef3da45706e5b8975775c04ce06abc4af6920518533785a8e9cfaf5eef1b4815532124c0988895f10f88e1b8a1adc32bea97f60c8f3efcba1bbdec02ca54c06acf72b394672291e3569898fc14ee467f9f05ec8739f7d8aadf435fe84161743e3369c09b0a665d470a2be8ade51ef4243528f7462cafd320c5270d9adef3321344d98e8e74f64dceaa04b42802ef18a5c3a8e9a558e3e457f514e7d5cda8af84b0020c3ac255a85a73199f6461fa954780e8eb279367d18ea15463583f8b98bcdbb4918a7535cb3e886dafc7ae8e426b33bfce0ceccdf2370a0f1cce0bfca4e4df8455a2e3d1561d6396b9f9a4eb1cc4b1ac7e9e89edc1265478c35610034c9002abf3feebf38ae7f2040630047e61f4333be7fde997b0898a89409f1361e2e40a72817baf06c82ac276866dccfd51846a9e19c002a662845f7afe58876b8c4efe9945a67e7b73416cbf416a1fdad7cffe2be328468438207f9cdf4eae862a747bc2c4e7874ff0ff82fbcae5a8f663961734aab8f3ed3cfeca9dfe332ade1967c8bae98d199c2108c8a37fae8b77b9bb3953fc1e3845a595fc5b735ce153dd310efa597ca1e276d57987d973a5053e526e89982f0efada9ac6f774fba6b91b1a786368b156684a2cd6e5e4b428d64e6e54f21cb9a63cc889aa68d3c86f4e98d546f2ca28804592d0ee8ececef78f66b86c5c444cefb7de84ab4756771953512f994731e348ef30143127cc486dd50ad1ac61b2df9fa37cae0ce6092a8f967c25bdf02e83a1bddb30b952203d5415341f09dad1e5c14c0ccd229b2522fd893cbaaeffe0fefe96372eb6c9ba1dcdaf05665d6364990077f1da215fdffbb486ad82be36839f54e40ab9b251e6c2230447667d7e14b3f31d65f0ec846042b60c549a452df159267e640474b61033e7a63e717212653262810d5edc1e9e00a31e3ec68507aa0ad36910f04281b749f87d4ff0e1fc09563b94a4cc977ecd2b057813efde35047299c059053ca6df3500aee9974d4a3d9ba39d2e04e65f9d77c72d3a9ddc3a0ce41fdd62d0e25e909b2111c1fa0b6074aed45c0e61241d288cfa6dabdbe99dac526c3c27be7c0a81a44fb5514d9281abc430474bab6750d381344f14b1ef8a326eef89129cc520a69853c7980525a455fa42fdd222c07e8bef61b85266cd37df2bacad62297cf364d80a53c549d731210d180857c5a337f8b735bf44caf7bc364c0be6dde58412aa19cf9f0983dd2d773d52ae976770084472d45b9479a83ca76d27856e82534810a0cc04095f8bf7048b603d504b70055d8fa6d7194ea5678d8ee54657daddd988ca205d4c782c519754cfc8b17c99ccfc45e68926063982ed7a4da35b51b6c7d15c938b2695f2dd6b84a3a5d674fe81061c721e9a5eeba44371b7a1e47a4d2be214b6f68ae03936dc0f682b28dc7101389ffb88d4d1cde9f6ee214d6e9f1f85f98e3d4de055d9b2c19251cfa5338413357f63d975b159f3df5c79e91e0f48a89339b8b44f66d6d35428af8091925d6996184d89908bb99b5303348e17f4ec36a90e74b90a546eac1a1ab604fc8e7f34c5fa8100dddcd3d9ab6f7bb81b8dab0b26b563c418e3c93acd9eb9df6446e4a82341bf3670dca28b4556cbffdadfbab0b42bb7f282af8cfd31cc58ff8dd2d33770634dbfd8404a701766f147e6f7626f1101eb5e146772d81a3604f2974a36a8426e9720b019f0ea2b56b12c92b5f52975d13128617ca4fa1fc0f257fbfad736f74e83fc995fbeb9d88ef82a3b0214d688ad838fe1ba9a396fb0bf89bce31753c21cc65e04e35d1e55646985c87d65f3c0c8f45ae2bb781ff5ce33d17286da7a8f7bece2ba43ff949d254170efcd43de69ab5e8c399d64cc646fd3a513beffb794620fca0dcdeba9b1570ff24e1691d26ff18a6a0e0aee54a979fa6c16bf8d330f247b7375241eb8599b0205906df368c3650654390344a81792979d08cda994e938d3c613ad1d2705a7ae19e21c7ccab913151e96182f24f1021e2db6eee4c92a00c253d64a6053d06702fbeb7d3b3c2b9e06e97966f70a0a9d24f85bf1af089c29aca187e832f61056b35275a02548893f9e4dc91acaa1edf044615966e124c5e7102f3b4e3bc7b9ce8451252ba6526954ea866c12f72e7a68211c224148d8b5be7538366ae0fe61fa72ff6ca1408e269f4284b64deaebbc087e930038982111511d371e8d8f77d91f5b3784a1ae4b093b5d678070700e1c2e4be6cd245c647263967d6551bc4cacdbe44a215738ec94d1ceadaa67c2a28d17a7e6e528c64484cb5aeac946cba89c416a89094fd777d681369557fb260da6adfd859772559b14aec1107998c471b4947ed6784ca171baa9dfac6a036b7321f1b47e7a243b3171e897cc527b7164331f688331624123e83c5f516964afd433e81f4dd8b184d7a41bcc4b37c0707b4474779c1557e1afab724cece2e87a71350ea19eb54bd550715640bdc504341bbaf0a1dfd69fb556d023098fb29ef2d54ba0fcb5334d3ece8adbea0455a98f3774930e946dc1d8600a8d415776f249f45f7a8d1b5abfdfa1721742ab052cdaad8d66d3ab46f2c684ad54d08399a2a3938ed57a48af032769bc70679ba0dfcd36a962f030437609696c398ff50b8affbd0368f19ae701e67e5f121a1162737a673c7abbb1d9d386917788a585d0fea897ee8db542bf69717d6ef74ede9df10f02779e0198959bdca479856c85546a7b34ff621500aa5b367e2d7b779a34614885253d52012","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
