<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f961e19ccc23d9c4b2f7ac93fbaf294374bb39daf9b68378a1f231948ac40291209b634d61c7d3922d2c3b2124e5f1a6899e15ee3817754740b8e0ba6024fefa661dc3b0805fff41c48e30e11e0e478995dd84496142d8054a86e742246b0ed76b22bd1ce68ad16572d10e3446f3a58858a454037cb8d1eb522ace27251dbdbeea6cbd44b9cdc68e433ba271b990e763d2cc89b991d3e69a9ef83a39b7abaf5830d0a781bf33b2e598fa299bca779f2d571df0b6da68a4a34b8459c96d9fec9040616032f488ec1bc217706345b3cb1fbbda0766fd2d86b8ec5b5775a875e9ad9106077c75916a056a4b72ec4906efa635fc1601d8cdfb638f2f3a7c3b497cfb17ba9e936afc5b33f40ae33e4bfae8d4d42e535796fa8428e6e06b2a37c19636ac9b57f3de00ffa9eacdb88b24d0e7e9c3947924c9d457299d38ccb89c10899b118ebdc8a478ed029a66672df2d350bd539b50e0cfb94d6f08fc0724a235c82f098c4ed41da7de1c10b17dfe98efacebb14002371b996655deaf8e79880f3e995e84b1cda977078cc385ae1b494890624d197bb95741eb6a6287b1440c9b73f5d57440dc36f9df3c4c780606a96d56b92556662e8833a228391146eec483f0935ba73555cd399bcdaf63fbc0b708967f2ef97d379814874b06301764bcc42f7d6fdbe5489e81ba9dac606b4d1fe36ea391be415c6ad2b83a8df5a06cf3ad105f30d7d84b1a98960ee3198ecb74f4ca4a1d4df51bdc2f2c85087a78d88a7604d1738257cba869e0a1769ca0fac665d4c49dcfcf9de3313ccfb85c8868b7545fea69ad3d09b81eb184942065eb1f1d7f0dada174f13ebcb534952751c177f29608f062f7e1df1b69b0a6f8b5d135acb2508db221d6f634fd77aff0f12783958772af1de4417159196b1aa4e716bd28cfb35ff5fe285579bdec2926636272e6bf2b65031f410d3b7e278bc4378f840ba558b1adf9cbabd63bb2a7e2e39776f9f72d53567c583ef0eb7621358cff05fe46db7b83522df40522f7b96d23c444a919f4db224707ab4b6c8468c7d1e4845ec4c94588d390e69973262e74b1d8af3271e4a2594e31113ed125715f410d9b293ca74219dac716c0b6162d8dcabd9c4244740094b5363db660354f928925fb1c4deab36202e2e4ee6f93fbc4261e067fef1e43b6fe9fb80e43c1c314ac20866ae61156ce5bcdf226e801a716e016c35c99e29d57cc599f11f6110282af7ff7e226fb775e7b15c4335879c9e4ac80f6fc8b17dd96a62bdb860b94d40f5e022db1c746552af469c57a69cd1e4941c2bb09dbe99e2ee5597e2ba8179f10a9302fe5aef73fcff289d926a19524eec29f1e281c4ac24fb990620c99c7cbbc16cb7843f177987c2ef555682ade06fd18208523602efca06f2f2d30fee0abb34e244e35c5c8096a321e7edae092175d12a148cf7a159dc214e89fab50c3519dbff21737599f040ffe1fd8d9f3b531c92bdb1c8e06fcf964191cd5604ba0bbede916028b9840f04b9b7d242d2fdbad7482ced2856abb3f8bde409cf4b03262eacab06b8bab1ab0476002be057c0998ce92a4f83231c9c1d9eb9680f916c0f79ff553fa59612a26bfc160e85a6eeec2bd6b5e4532f504b0b09408a8fe28408b826d67d09daea6eb6ccd842d976099b2fee46f63b00fe20eee95978ab5af73128a1ba65d73805538d7087aa21c444c62f5a2e9dd6df68c0c540b8f7265c274df3e750be92cef571b4da46acf797da4a225c5b2537a824f645c80a05267e5984273a57e995198bdc2e13f49c75e07b49e1cad2f181487c3202ff35f78eb00b5b1f55310209b6737cc5e2d8322cc2262b5326c49034521c388748488a3b44b873857aa8cfa737ce2e17360bb71f7dc1801ea1d50599112b68c3f8d752840c8decb1c087f4620e82a5afb41a1864eee0f2d605dc59130d1df4409e5e508cb502ef24d4d20bf6c2c0b07221cf7339a6daa78a0a9dce395f928dd8a21eb1c691fcafe6fa99feaa9cca22933c45db441d64fadc72a3fd5d2f9b45aad187664232d0ccf23e2605edd5961532479be69dc107173f13af03bf00feca59f43ff0881b01a246163d74a85ccf22f206afd4f365153ce6990ca002823be1c8a19ee6231878b0dfb36b5f330ab68948c0da78fbd35f52693f166c8e7cf3e144432bfa453128f22adf9cc285e19ed9fb60bd13b6ca6c7585efe62277ce07f889eb67387373b60fb5ea077575e10e9c3e1ef588c1e46dbd9f96189019a0e92f371748ec5c6fc78c497c63794310a27203fcb23c55c0f0762251bc65c28e1a8915d4ec0ac736eeeeb459f7db2095dc46e7eb4c77f32004e0a1c8eb6a9a7d97968f7aca6a9b2c2c5b827f0560947c48d72f266766ffc685516ce606e6a753f9d1be364e82699c24e7488b0e48a184995af552dae4f9b228627a447af3c38bbf200d7c4a70673c7e88fb7df315c6b0edc17f7925e1ccd322710c4a8932cfb6225f9b576c15e56b2b6d262fb115dd4954b4d6780ef862d25d76d8296cd10dca30aca8065479eb84bcda80c72182f538b3a85ace5d4bc7b82f4f86187ae10d815fe293d7f7a21dadc7315e74bcafebceae4151da0d21a265d1d6997926fefcdae96551270c9803eeda7d618b06529152133f4d1d9d179a579be96bcc00cd5b68966f310f051688f578a4a1b0301db783b8f71174b4a4195931dd449f2f2352a4a7bb5c657c24a4827335627af5c2bb3a625c3f0065b88c59a98079c6291658184b53cf867d6162c93caf0d3ded3f98fcc0d474196ca1ab5caa4a609a6a3743ee60b348f7e3d71e32f8be02e0cae92009a0b07c2aa0a286ce487127b1692ab36387a40043aa42753ff444c1e8602de154581770847ec9489803fbf8dbc2ef42800eb0821538bd1668f9e9cd06daecd944e70de3ccd27af1ad7bab28d0fb151ff7ba93bf42ce2d4f9c896e72c01739dd9b3d70e8de0f49d4cb76522a8da05e5894ef7c1a095ca7f674d62283e3c69ad503629b8dde662dc7fae6daa38584bb99e24f67666718aa67c9b413401554c748d3648102595d32e8d377944f2133096c800f020ad0618a9029e7ae915eab81fe34bba188eda2728699d29df36cd0c44a29a4d64111264f777027564edc78550073b8a372a7cd2d154ba2904de14e1773591b1f64f88f08ebffadec8b9ca07c087656cdf522c51b2baf059cc4d5744d20d9b4b0453916e6a7529a4a724ce79318aa021d07dfa29bf6ef2cc076e481565ebcbac3c951f3a8e961516892612540eee6d3aecae04da0a0d840c99e79a2e06d882fc81a0648304393f6366da0fd5b3f63a48d80a68d31007d4641f1ff0c6f4c559ff6c1dfc1d0c35120779b03992ea8e6229bf60b3cb9ea34dacf403003a146d1a0c3803cea32dcf4225344fc2884ebf4a1104f10fd6cf85512e982d71f31923eeb1d9edf296a277cbf32ba3d2476780e767a9184b5c3ccbf5b6b2c465d8ac92af1f7e15023bf290226477c4279d6cfb0507a521df0554d708d0866eef5f48667f58815baca03dcf5acd09da8b3b9baf078ea9c48041605b5897410dbde5d3bc1710c8e9fbf8406d570e938ea360dd386460ab61cd25ab5c2f4beb690ff8af7cb96341f1315be79cc6a4dea04bd03f2c42037f6b35fa2f4c417112d14b8302a056f283d716fb167a0a6878dad9fa1ea27b861656190d42ed70be046c1baf1718d00cb0d6df7fc492a4f18395e3e8c939e75e481ffc3fbd2000a36f81ca05c36732987953524cb542525f5afacbc7005ebaf5e73cc14e4d426565d90f87b58344d87532ef53fb134a2acb178e34869f0b4842e73c2021fd5eca8c8f1a08ad90242871df524425f98c9c9eedeb4e5bf2ff50866bda7c4251437868e21d9dc643f3b8c06cc97a7698938f0eb788768a008341ee02101593105d03e13fafaef678d172a7e5c55f8352e0a2ea61d24e0b4ca2bb3d2a874ff3bcc696fc93b18d3e94fb19ef660593fd985cee143d0d8253457d8f7ad8206aed69ad5577cc0d4e7e2bf99412afc47749c079865f2e912563ac60c16daba92f8dc3d49d09b700753432bc589c53171369a8762271db947fc9e0d61493a83eab2ac2f40a5f99b0579dc68273267b83dd19e575d55a2f7aec2f804a5cfc27d8ef6f04a12acd20c0a56a2b60fbab61bc340335bb8e6e097771d730fa0cefd673022d4155daceb6dae9c945f9b439a28b9c4082ac7355c2333f023eaf51e7d3727dca850e3e4c583f8219543f6b396b536c6e61575570ee1b255b58d53c80a326d8ed8e8d820717544c32a87b169c5b537ee98841f50209c50cca046ab33176b18f79360ddb5e67b77236f14d33c0a9746e4a85ccdb32c1609ed89d8a0fd3997f5da7f92c9bf7e43b8221890f2d39ceb2a67172a01a3d3d64a0a5fe668b6d433011a96e15c023ba71414a4bd5ad4123d1ece16ab9bebc22753005588d1c8f067866d740785e281fce7f4b2dc58ad6b14f1cb830ed18fc1fc5b252c26ed54ae88525feaf8fc4fb57c5020a0031e7361cdd3b4ce7d9b55fb07a0aa01f1a677244ca9fc7d00391ed10fb1f99b5785c4a1e5bdac35ce707273591c579584401e1e754a2984c38e9df922b722eed636403cc2084640aae58511ac1f645e0b01e4f4620ef42b848f90b536dc75468153c1d359416fb2b434d548f4805f13b316ba406ca3d7ca077a53af97842aea74993fb5a362819439afc1daf103a236465ece1214df7992c8d01476f28a9ca136463417369b8784f1a7566ef8891b16e137f73c19c7405f7482ee26d60244ebaf9ec6f16eaafd1e56974233ebdba45678c382067050be38c2f5113471aab8ab29b8cea0b66ecbecdaa033b0a7755a1bd14f7548d00433f13fd523d8374ddc45c6f80447ee960bba9f6deaf9a5900362161ef4e0af14d199edc597084d78f98004d946fea3252434c6457f7283ea806fa9b5e05c2e3f8a8a8f136c040684c43c83140a65d2e6d75673fafcb2e26852411ee09f3cb0a3f5d7ac3792f6f8e589ceafa305ab7fe9abcc86916e1933d511998a55186b6b0359cde24c7bc3efcf3cd6d180fc9ace7de72de16cbba54f9dd7ea1543a301974da4319f33e39714d61bdd391129f012ee5fa20137ccfc0a20651762255abac65231c2d156596d10d4993ff9e66021697bc1e64065ded304bb63d8c3a0a1221d529c2700003415dda83e50004e54a105c171797d36a8c43b1fa2a97c0e6a7397ec5d7f6330b584e8c4c3da5501f31c1f330b35c512c8cbd296aa4c41c1d66c732a2ad96ad94912b529e79bbb20f79e631e5be3ca17a0361773fe66e8d8a06d2c37514c0d17a82226d8d9b3ab054ba20413d1937c5e8b8e81cfcf6b487efc0008e4f21739dabc3e408f5657147a3c4e8f1239efee62fb974b80b62bcd95e7c19d0ac49864bed477c6b2c37166819d4994c55b057e927ff6982011f399a05288166db745c57c6f19ef901d05cf257fb6e3937f1e951a43b0f75054fa4607b9f1e8774ac0b6980f999153ce0b5fc3735a0145681f83e75d1e85fc6b968e78e99da13e4ced825f32b35c8367c926055a276e993e9b2b593f3ddd6b6e0901c70555ccac49d44ccfea515dc156f9ef6fe4eac59609f69de3b822c19771a2a980cdc6c636ebbb62e6b5eab8c7ae1ad47cb24953dcd2af1890b0c5af1d548df9cbf60840d0f9590853583c396095efe91d0fffd17405bef8d6cf33d9b8fbe47bc01eb73d2f44417a7e3575401babba02257c27ca66e929a3182713f97eda58013e915487f242db8993eaf07f0219d43342e638bab1647806b1d94cb144a18df81704fd1252152cb6772bc01292e82986665cc768b6a5644096763140f76ad71ba193f63473abcea33fb662691c29e73e16564cd41a57c298f557e7858e42f22773734c02e58c4ffd3ea28c14cd64b78c5c165e5cc6b4fa0ecae1ab1ab179d89b9a06dbe0cfb24951ad15b92dbe15a2ebb3fb6929b0f550f1901e439e031644ca094f37155c81abb1906ac0008933dee786bd9462ae75ff9cd4a01ec59a6481ddbdee83bfd4fbee11b1be8c510146bbadddfa8acfe1ad31a35cea72d38cc021aa7904b227834e55abff7f4cfae90fa3f56f3de00a8083d0208a898b853df7314ee8b892655e293e3b1817ff6585d66ad59fdd00425a7cbc1dd72a8a18638c87eed7034ceb5eb3304cddf8f8d7a89a47725c23062f8b6022953160f7fe8ae914b1234e69f681e489459d702746dc9023ecba90361c2b14b1e24adf8ce40f02c1f1d210c7961e2541a567e5f8c1b30cff24b09377c3b483374e56eb7626f38de0138a384c7758306522989c7695ff234e950c280deae2369a3593769df4340441a980ccb6fea2dd04acab2eba3a12c256c0e95b63afe24dad52abc7a19c93139df1b21e30c68bb1149f7ade2ff63645b07dfb5dabced1751f2272ba6eda98435e91dc68a9647bc0e3ccfd6c22ccddbde8304a04bc952173d3b9b6a418b839b4194a18a0b74f1895ddf5615f662c008aca58dc7d9f76eade9ed7628c401efeae2a8cd8993c8172bfe87491719d0673eb5fdfc42790518ae65f1e09c72484a92e35ddcf93d47e5e875a3a2737c30e5346ff7ecd124f6aaad40f15ceb674173efe08a0ff59cf3480703d23d37536c00921846c099af9c8eb9cc1d2eaf8e9b0df63263f92e9732df204ec6265f1347ae78077c43e34f617805954fd67fae4c38f69d0d173fc0667b858de3f15683ecb4e4153ea8bc2b5ba84f8b29034a7e556204ac8f8fb7357961dfe7c3e3cdf2b264036feb674b05758e5c118e8aacb244a6bd8f8d796d9c58dca60ea9f41dff3a799d080609c3092aa6279f1dcb2867801675eaa391faacf8bd5cc0f8304cff3ab6b5fe48c7f0fb1c48bba867bbcf046f93822b9997b191a2db14bdbc2ad6bbef292fd0d891837a1725970b2d25f46f19be5aec5b170afd643428675c7898105c1e69435f18f5b57440363d58a82cd37420f7f80521ab4b47b06975635422c8b0eaf5a6d9e34a44eb9bb8185c364a3151c957a320cd0d99a974e5d65407dbcdaaf7b49eee27213fbfb586a8af3cdfd22e6a2a7d82a91bbed0e55f8970a93cb14b01176b69593e66c09eafb3cf71d8f231cb08ced0957475831ee6f585851053c7ea5ade43c16a68e59966183bd3faab03b8b149e2f6b1120fb0b0f497887989983f5c5774ef2c9dc5cc4ece6a187ec12e039236daadf94c2b888430a4cc7e960c8ec0d6e90505b21bbf6edd4e2f854c54d310c5dba214dcd00b36e173bfbf121fa420a48febd34f0f9f3fb960ab0d69173ebc84ab0c52fa8f87198893fe834de66b5dc9eb41a56973a310e45e555a751d743c1d6ef614f38b9553b637f4fcfae234ef72a5545066f8a28ece9c76929bd53f0ca5e06779665c6638dcc18c5b540db0a44793b2e8a92232ed032e8ae4658d5ef7e90fd5fad3f23370eecbf14f805c228e1fbc94f8479f542581d19e28a98b6e3261a08f5eed9747c5ceeb6a930383da78961c364976e1d8af9a5eeef7fc0eb25bcd129d2dd33057c301526e46770f107e640513a29b6f0592b53e455fb998d701a6a04c5969b1bf8774695134f0167d7c17be134978c3c8a61a1c032f08d41f4815080f9f4a1a3aff905dde9e8551b37b8070031a3c51c421c4eb1cbd10cc34ee41f964e98144462e3d756a8b1b3592ac37322494bd6e2cf3ab00a858e1e29018f6ceaf13355ce894d3dbd1cc95f6af6fcee7882dd9be6e060b9e56dc3aed4091d0b689f3983528cfe081fd901fe8998600053a9329e9b11a03ff105fe8f9d74d59855a7ff9c6e83154b1e91b63d192f63f5501b2186fa3cad2cbc5d49420bdbeb42c9eb74a02d8efc9f3c236a273d92563891b43118251c3bf7daaadd07ad0076bf64facd875b52dd4db85a15361e93f96d5ef5a9335528527ce2e4b52104f4c182fa9f50e03674e852738bbd21a61b9f1d91bfb092dbcf5a8dddb8abc9c32afddb7b45ff2447461e89ae564c3f9a10a783a91707dccf22eaf716f22a116a4d602050e34715b968986e7697cc1e82c8fc9371f3d4b2bab0daf45ddd9c2930c53d101bff2bee3c1bee52010e78fb6e56fea473ef80765c155fee8f167539d56a9b0f55875842841a225dc57151b1f909d6b819cec30d325cdeb97810cbbc415dd1a2eff33995ac305d2b06072fea1ff8c70c58e081cfc28628fe4e66620af83937a335ef52a5f56b9c4c2e8d5950d0bb32e9f2b42f5849742b7c290bf62926fb2c1f10c7be5aee63b81d7382f332c8c9c4978d5a047c2f24e7c4b142d6a78bb29096350857b8661a9fba612cf8433d675b773cd1c4994324f8eb5eacee53f71d27544190e2e1c9f1c8f514eb0dc9e183a7f9576b987196cdb9ed2807dced7b35f616499ba6d33c976bc82342a2a94ab03e31fd99c9de559bb46f8583a6330d3bcddd8b3c0d4989cb717594b2fc383c2ebf940c49cf0214aeabe7a406d0808429463a033b6b6c14a21d61db80b5d47d3e58ea2cac76070f0238f0590c9b25f6b8a4acace3cecad1f357aaf44ae485b4cf583a5c8649f02378467e6f6c9194d6050d556add37ddf155d0563f866c55aa916f5b4b5290924c33b73093f1c6cfe9d063ea73d81afff5c0c9d011a57151b9c5daade8e10eed5d7ec9985421b82b1fdfac6ed079b2d1d632994f73531505f71bdc47ecddde8fc4211b1a560dc947a5ed63309506058648909f8b5d450286e5f24069c81bec1726edcf0de0cb3e71f58d57495cdd333cfb1a03ce1ffc33d32c78ef84a20927e9eadbda8b85a71b9a42edf35b69f718cbdcafcc43dce771e570321e12ae98461adf1129d7e07f2b94941924c83da177b7a00a4fac5ce21ec8a60cb049fd0ca6ef6b8bbaec716e7a935b650625a0dd4293a2f2a66d2d474ffa58e3c943fd71daaab5bb9fd0e9c02b748161f6278e51dcaa01ea8975ecede4f8482f8798aeb420a4773a9c2bde22258c74dafcbd62c4f010b0eae3585e0c6997d5f917cb02467ee5eedf5e455c4a5caba25a979c35b0fa62bede82a5bd32a3fb7713562960b06864c01bc3a9e4bf032ed7d926535d78be8d3c4eebd7c489818339ebd8a1af8d44767b491abf70d790b164ba3c34bdcb0634424e2c67d842470274f444ef255292a7a28b9a865499fe000ce69262a05c6dad276c6bd16b639c775672d66e8be63ff7cde08c4c75e2cc54a7c1ab3695ffafa50e595437198fd01c29e6d2d423fba6c85d256f72eee908a824fe9026bba5477a50d283037c3ed9376b3dcdb4781b9d7c1bf29c3c93859c67cf660ac4805336b47ab6f33651c2a291e87477d80f1792eda2eb3abaf518fac610f5f4cbb0692d1753ca8564205bdb8fcf6e3f56cc3e80510869a0de9246add5f6f489869180adab4f5bf40c111aca981369bedef5628b9f799911ad254ee8c6f758bc0f77a0e98dbd8541c00e40c72209c249010295893f29c18431777b1b6bd5b832691181f24ac9af5d28e0822f024c35cccdb4120cbb4dcc338aa22aecaa04ea5e3f647467bf58ebdbe9399a80b4261b29f6f56c232f0aa0508cb45a2606c4109ffdb7fabfd34190d28bc31797f1fda3616865e410abd7c777841c4052af45b0c72ddfdf213e73f3262eae358edeb82624b81b081bdbe9afe1131b82c40083241b28bebc224efddb0e86a14927ce98267caba69b64e39507f9e0deefceed6b5d8637dcdec58bd0d421ba42938322964f8c4c0b11349c1568b90286097acda96a4fbf3eb2fd7c7026a048d0e3a5503e4e7624a5158354a9c32e5f2e5e285f2bee1302dd72ee04bf8144a4626980669cb8c77d7bd17856a568606daec509fb5a118508590dc0407ef2fb874155b009930221fc5a403352cccd4ebe2cdd2a4166a8a39f412fd4905057fa48f337a8542ff64eec53b2fabb65701335c7f32fa9e8d8b702d38bac6daa4e3a081a9aa4b542485f13c7a85000f4323a6041b7db5af137c0ffb3cc32d367fd42c233b0c6ad88a327b70c9cafda4ebd842189b5d33de8a3cd018392883e9c73d20df91c90d31c6f1dc18f12fb1bba6107b522b53e448fa29a34a9067085fa7489a0b2ee52504ce279369c83e9e249d49d5d4c8dcad28c7825e0eac7bda2b46e4902cc8e73cc122ef8938231b665bc64fcdf9c2a7882b55e878d138945a6737d2a5dfeb58bf9fa784f33f5621793aa65c5c4102752f8db31005f301e043676dce81a9dc556d89104db50edadd93ada982e79ea85f3055136a1e6e905ac660e257c3198411f8ad880e7846dc84a3cd43c3e46a936d8fa8fa2e22705bfaf38f5f99c8d07dec67e16fb2f9d24b683538d65a688f58a23d1f8e1dd9f627d5ea0e2a515c9a9f6700d7e5f7fc471ad18748087ca4eba5667f8fb98638f6c461eec3c41a50f25c6035245052a70acad13de4b0ad0cecb2672adadf1d6a68ab61c3fb81505b2b2a04999243fd8225950f87aae9f0efb4b34484c0312a7de34cbf85f860357b90d6c61d88367251fdc4352abb6ac78d52588bce2815d2662499eccfa7a63a28f5bd9a96c07a17f07a1e238f56e2c1e8b838f9a58f213716b7ca7a98511a16d6f58fc9ca3f39d4abe9be2080ce8da23743d2bf73e74691ddf7f573eedb72537c841286c219253a0774d3f7c7b9efce5818ae3cb27aa4b93e370a4ef9b664f15d5a3ec8d3edb1d2d04673e1bb6d2778f61e7d1e1c31926946ea16408d1e63e80fc5dcf37483f20dc769c919135b5fb1dff81b4221e4d42562ced98becabd4d0775c5298e4734fce8e6219f3a66b72a4023becbcb954e049ee9b53301e36961b5a5cc90ddc6596c2cdca41dbc20ad97be092f1cb3ddc4d9f7bd6304e086ee1917d242b2368a8a3afa10f212d4ee544f6761cc979bb7208e0cd5da17b87b8d43f736fa2f90e9adbcf6e525231b6394733868f529467d6df34a06cbbb8ad5164e028a0a5d2752dbdc30b15c3a4697b4d0308ae1051dd1235731b376d2c97708e3f29e29ad02b9172d76524d23960d0caf12ff4755b38f1ca372b413a5aa0287fe74b982e38a48bf6995660bec5389f27f4d1ea4c0defae330207ea2587028b8f300731415651cb7b092129ac57b1f43fec5090e9faaa8025487a55f75e18b053b689d6c13ce1f75f93fa500f9d3942baedebe541a91aca39af4aacc76d56761dccbc291271c1f3d887d58e8af4071c3dd7f144bcca508a04719a441d2fdd29bab83995c53d8a7b742e927fc7324b27f737b547bdce3ca005686120a51516f189c785adf8d56fc1e0d7fb10a84fa14029026699e705df2f80e80dd5331e6c4172c24db0b0609e43cac4c1fc73d490eb1a7f380e24e99b182611b577b5de0d5dff9bad3cc5f06a783c92798e1e6d8761bae2648cef60d81ce8c6879af49fa6ae09566989a059eaa2d1b73899c7b48a6d8477a68464a4675cc7b61adf38bd226f292cd23b6bcd88b40f4c47bb01eae3dc8643a7c1ec29c98ccbee29d745261c8fd002b7de86b42dfcc94ae74c09ad335a6d691de0ddda49b3efa6d872b88ee0a56e0b7533cf5911c7712a2195553eff12d8a05110675852327d5e374d956661e9eb990aa079f5a98f452ad2b181671e11477d287a736358e1118998785de66020b882f54b0fa6186a553d91003e4ce30b2ffe70d74d64ed0ec5ee4da8593a41db82732505aa0097ae9a4a144b6a2f4d7e59394616779a6747de18c69a126cae520247726d29886ba06d72a33963c3d11d1b5550a3e76287134be286761e6ccfe61947dd6cbff3329fc820e96ae9dbea886f3fc8dafea60b932030930dba9f461daec328a8e33de9fcbaf488d1f70e34bbb1c3a374e9c641428dcaf9211832064c7bae5cf1b803c9aceaad94a038438a531755925eafa9126cf8c293b5d3c2154a07584fb43b6dda673d58f5c41efd96cc9e382d1d8929156d25c876272194b60c488df442de3cad64d3dc1feebdd15b66a332e52aeee61be1206018be09d5f607eebe795d506b43a2e2e9d22375a8dd34531dfb59cae9bb0edba521d12b0cc184ca961874338d32c2bbfdc15879dd75562d6a4f7816b37555ed8182957ebf323f1a25f1ca61523916b944f0d42e2ece296df58ff97fd37c933a3945f33325d648109ff2b13a7f2d299d738834f4d11fe9e2a106229b015926cadeacc41602d8430ec90cd0bc6bb2764fe4219ca2d420703451cd8bb97862865260f75632725deb6171c262ebd906edb4ac3b8b767c65f5180e91cbfbff01bc2db985151ccf234058a3652080ca15c3e0bf9041e0c6326c79cd5cfed8353cb4f603db2a484c19a892aa698087d53c8af3ea6e8bcdf745a223679feb9ea9e674134bef4c24951fa747e6bb8a35cbec16dd0a983c15c43be6c270da15b9a5e9b13bb959924ff431d99cc854053faed53f2f22cad2711016b0ffbd1558277a8d0f2e64ff1dff5f92383d4ffec5204d6b059297ba3346302ee3d61ae13588b9e2e8b3979adb0f76ef5852e321bb38bb81f5867947dddd9d1ec55d1129b3acdce84643647a156ea03b60cc742a41abdc3889d9b3657a7ad852abca54725ec8bf9f5e7b497785f95f204c92fbbe83af32864936105f31fc3fbfc434a441c55ca3057db699fca499786306a68c3d0e226f1c8fd4e9bfb3a82d6c24362b7323a1727a02afd77d200d241a57384c6dedb0f54eff0236b90758f3b98b07b0affff6c2a9c99f20e7d1eb356dd925789ae9511a9674bde313d2ccf622f6e018a2f886d39e311eed9bde6dc28e22bb532d8a163280e461a3c9f719577bd85c2a0b0c18da585e7ccb483cda0e274800fbf44955c9098bff0f5338d27c22b3fb211c9081c527dddd4a31985a21592b009918ac92413fdb7542187aaad2cb3cd413331341208230ca3add5c0d28e3b459228f634f0ea3f1cbb99b2ec2a17cf493f9c80143d720f8f71e3ed71106c444372823bfdfa125671a98d41df743ad709cd5325109f13fe825de65667c50b27cb89bf2ac03c3101d6a1531ff8c375b356103fe8d9969c732f1611beeec6f6703ee18787f1129c5a071204af95281990774f2c392f47f0f6ba4f22e03b5722017faa44da1321ba5f32fce6ba12b9d8150c90d5fba3661b51ace457f8fac14e7a55a840ae183ad4006daea8519e46818172da3513b81c913210e1b8b72029c0594ca7daac9d96df28300d333ff0d934944efc6dc19eec5e95868a667642518dd90c8dfcdda5e050db15aaecf6b9c39704063baf042a1c1856a3239cbe2ee180b7f12707c1041e154af37bc88aa99da3b3a345faf6756489fc288b78c07e97584d5266c6073470cdb3a29b1c3c946244cf5c6931eef092553cfa25f4b2bb31340e24f7651416880fdbb9be0dbbfb52fdffc0ae1c1938ad838219b621aa57ca01ab892559223e2bff80a7b860a89673027a45a47d0479899566fde74a4d7679fef69d2d30114dca3b3152dc2cc65058259eaa3cc0914ef191e488748198bcdb8ce2932ba267b961977d12a78fe745cbe1c2d8ea1769905899efddd54d7d8d03666f2472299bd3842db7b4564c33cbd3bbcf77c2e20d8fb29bd2be226a17e399b80fa747f9875f77a4474da8d661f8bd419c6593cd1c64c76207feb4ae8b5aff0cea85abcd6f8cc248777d85cc289a7063ca207883ab0ef56e5632aca0db5d452c9b15f84773a0b2942a4742039d563e3c2bb78af5f64c10fa78b430b11d665d315acab6d34e3fc07cc005ccb33361d8d5847bc60e19a3fce74a495b8365cca598e66d4ebafb5643055062454eb268a350a0ad0e567d293b4edc1e1ce38bafecee909aa6c3f5bc95cf176f88d55a88fd5245dbb2040562a471f7e050b87410bd797188420caa25b35d3e1f07511c998536590ca33212e010ad6a66fd18df01091299ba14a8cf81db8259ecb572e0cf534d8932bd119f2e4c591f35ef97f8cf0af77d270646a778e404f21063b6c4f467c44ef72eb4e8b75423ccf9b7c1722ee02d968a871211ca8437f36b79b2668e3b8ead16db2b02bcd968b396a4b1ab6995719b76ad55373bf8fe4c5d56ba8ba194072242f778c15c77034dc6993dedd430716037a6ddaf814c39cae5530181c6979e58b8f67f6db131d6b6eb9c6ad61707f865b8d2139fd2fc6a380dccbf1fa1857ead3ba7cdc7ec4b28041c3902eb07de8852194fa1022c78e9fc03b02463f73b4c37cd1db40e42d22f7c17b12cfbe01625dabf8a6cf472d3c480716e8e9b2a11fbb1c1bc9a148ec87aae4beee6b25e2a032335097e192710435a075f7b4f8710ca1b81e8dd2276694a149a5c3843af8cf36c1628b6bd8260db69f8b31935a5dd18fc5909f7cc0d90ea90a6b09958f735f07fac6f23bd83e7bc05a5565719e20a383ad3ad60d5bd89d1d520d7c494fc6a65c837f77723800f1e2dbd8acd3f60e6a8d6297d6523494b3bb379ddd685cf68320c0a4e2598a65979d451511c24b2e0d941364e83bdc56facbb55f039f457ff15228b2aa4a99cfa4679542a9b732b8f8920ad2badba6250360fd5e01f32424061ca78caf3484ddd9ce531baae6289eb56615767c96e50b4b8fb4a6ad00512a80fd7f3a61c0276491e980c93a53040b72ffd9dacc5cd42a839625915c747e2d7bb87b73d044a06d421f321813dc820f2b4e9b9dce9ceaa0bef64aad69758e448eeb741c39b17f3cc86995e6a3e221c8dc7d4405726bb550167e954a7709541d61b2d56a7a2deded33f36eb1cb848051fb54cc6cae9a54105c10c6b47becf00a96edab8df8487db9cbcdb070f65cae2462d6e16a1aa2fe744e12eb9ff757b86a30fd6fe0a66e99ed4c3eea2f0cd7f8a5e42bddfb9ccd67fd150a60413c979d6000c536527dfe15a7fa990d13c54cbcb31f2503c67f0e6e8191b28ead46ea1d72ca865cf1f5104b8fab5d4ed40d751e385c621dea3f689ac48cabe4aa07f605f5a909afd49e57d8c6b47e9c1c008e4a8f59c674b5e30d80436e96e7515a2533a1177b4593817396940ce9d0e464799d4ebe543159becf0dce80071c97ef8a0fb72af2febbeecf43fadd184b0f9fa9159f14b48ceff80e4252a6013de5344a10a31eecc5d609038a765f3ed60c609e324000110faa419e6246bfa514ea842ddcb62375a474dc20ae5e11328867c8873c36513d0cf0efd0d4b7bc0cbc29ce05d4328df79bbff43086c97cb60fe2a48c273462b7d22f059d3904a9ae0dd791ae261133535eaf8208bddd710ebd857aac5dce930cc4f921ac38e6cc2bbb8a74195aeccff134c8f9e5bf7ed9deb51ba83937d176cf88040dac3f67c89c929fdcaa1f84baa6e8b73e95db2397422b978a81db8e3f0d81fa42ce9e6b98593896e50209b4b9104616ad9b3821961ab0838bff211135a328ed4f0197192661a91d4b2195f896bde03335838ac8a766f1aa67be13d98d204053ff6e9c0e5f882a8a61ce3490361625a5a0a4e7a7f4051a3db19eee965fe6aa472af10d6007df9a8623fa6af0a528794fa9702c593b8c51c57c7edc910511c696921833bc5e77434db3094db82e83ed5c1ca48ef048a96d18ab04855d89c0ecf4d4cbbf3f1a14cb81793a7fd75e405512e4235aef6fed46dc1d63b2920339497b1846df4ed204c6dcf4e1d1e8963494e33c8bd5511c73baee0a325e8eb6c21c073da7f89d5f452244c357aa30252afdeedcd02a2fa4ee8ac9e7de9ee6eac7f697da8dcd6f13e2b8c204fc95110cb21e35ff38008cd1264f2756246a32d2c294dce0cbb7d1a38a9aa5159934a1f55e9815069135835e453ad1390f8c72ec9f6465593149bd363ce551b9f9c706596ac42c50365c4cf3193c411385505ba63fc1c65f9641b818100edb466d5499bcf8e9f9811b1ad2f24fdb86b282f78e5d41817a2a7dbc7cbd9498ec02b706737729b538c93d198fbf87ed23829e7678c9215e81ab71c04e6e50c20774048b62fa285820ed7be23272e8c744e0ff41c6d7f95d7c10307f1f4221122be2031668190322c2c904401a778be5f56bf7446da95fce7a30d9aa8751305de8841689134777caf20372b2ec389c09b0be3176d84fffba76fdcd0f6ea8337010eff704a49e9fc774272f986f4c3b99d5a47565c198e9d8b2fd0fea884e49c960b72719abfde029d71f5f908158994b9a7c98404dfbc1e7fbf290a451dcf99616272864c1a3da9b7d7f3766bba3a4d350ace03da62e96ced8f4be89494973bf15b6a990e69d7cba353e73baf952476b0bcc28532fcfb6ad9d6732f2d1ec3a2a28294eeb57379a7c3637f2d25eb4fb26c5d95c7c5d1a3e996fbafbd21379d0b592f86b6ef91c8f10147f8abf1953deea8f03cfb057677a449d0749d0ab52d3b8b913e9c65e3826807a30d839550c07a266bba510085a78467d48e6eee91457ee4cc544e41bf9fb145e84f61d681bb65dc6c7e381aaa30ae39117505bded624fa3cec9ac1e6f05932e6f175a8152728f7a7d28b84feb3844e22365834b91cc152d7164d61ea7d006c8b0dd0c5f05f06a55f3c19d5c479bd63abe9cdcf37c60d879b4c070981aba3c704aeffde4fad9e82ca58b844b29a41d6f07a166217196d1357947ff6238bdf199177ac4bac2bf985c03fba6766988b1aa05ca9756bd8508d819ff38b4befd1ed9fb68bd257e64105fd385949041dd15070f478f09bbdaa51d0823d770754b37c1eec04737aa3b4d9264cb1fc2dcef198a61298564bb7edb3b3b75985346c271f65f3883e9ecc81e0adf8f11bc824ec8211bc61efb6996957065daf8d6fb15535501e00c3b24eb8e7dfbd30595019a84e2536499c55b094051d3d2150d1b91cb1ef5b291be09375a0d6e9ffb4ced9e79970fdc0df4d747ab8ff637b2f57b0a123e4f7db903a1ab0adc467b04fae97f423046996afc0978e92663c4d816a23f26f4498641ef610d64acd5fb58b618bd605b057e23644bb4f3f202e4e9a1d895c4568d738f753b988dd81fb662de9effa47d4883e88945cf14244282951346d79d9bd2667ff86c42be028c032a688f5ba8576a388a501e887ee8ac346a761e72fa971edb6843ad8920b8b8a5d564b26475a086a1c8fd60119b5cfc5f91cda1be10152d9a9ba0f45845c34e1619fe5216d07109369efe1fe66ad4c3b91a691468a85367019134ab9e9c2cf8f1db8f0e9baaa578853fdf0c2d7727c4102e85da83fc536cca00695cd5ea1a8f7eb263e1c00a65ef012dffd75b7a80d2367198a885d82d96b6dd231bd24f17eb9ee9cf7e4b275513d78b8d06c349dcf29e7227ddc9fca9bb271200abaacaefcb905402af33d99f92ded676b1aac1c3c8b4a1a7998b7d43140198827bf535b02b35c4a265def43dfa95eca7269c22363eab76529148e152e86c7278e6732bb92bf76b5354e67176d98cb93b17ada5fa5dcfa6b92d6426b0e1eab09848b1b84cc4063954dfc30bbd50191d16ceca0bc22554310d0f352e5aa363230c7ae02faa04a95fd46909cdf1505057f13d60f62091fb9006c4f9d331f29fd3b28a678e900a3c30707854dea88af9e850d7fa0eae9d1223f106deef1d27264f7b2000765987db7769c73583dc64d063204f1df9dd1a36958ef438c2d2108e0275c6da760eac53f6c20960c1e5911ac75c8a652ee9ae5d461607c096f6a3bda233bb0b003d44c92a0ab138ea7b089f4e60e3c04d64d94c08bc4d59595b19dc0e1ae125a790b2172bf072412ac2616d30d11cfe890b170c0374d70e52507959e8e3397ef67fe081766f3f4d42ab9550d4261215c2c61c603c508efdc3e9d7d531e5704c3a55a6b914f3a70b5d43da484756f779a331f8113ce91d135452b5bfddd0e558ffae702836b16a2e9c438cedb9bef2d3507fb6bdd3ccf8a7eaf26c045299e4fafa782a176862e21c58e42419010aeddf1bccd2f7da9bbb95c7ab1957c32fece88e001ad01321fb1982ee205f119fa807c616acec7940e43e770ddf1939db4f1b9ddac400580dda394da1f3a7907fddd56acb4a555fd95da27221c51c2f61c9e87dd8b388a4f3b588ac51d3d38c5b05cd0d930f9f219bad6248b47054c941e2bc98b55075fa829819","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
