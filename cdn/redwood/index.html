<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee49fe579888f6ce63ae3fae71051881d1736485084ac42bcbe18a24a61ca657ec1d9b1c649bb98380fe5eb10fa11916adb14a9b500266faf55f0f1ed432a22812e319d80a8094bbf8da6188567c690ff30a4c0121b828f5783511ecaddaacf01397ff99d9b95dd8996ce0e3b083b2cb0409750f493dd8780204a50a8c587555332bd64887af8de41322513e647742f5a08fabf115c5f514b7f64a0e6eee1bd8669f28e689dca5813dce0775a41361d00c2fcb8ec17b18affab1b12165aeffa0b4a1bdc3dff260e8be697e535d564b58e728b5c500a22b08f59ebf0988c97beb5b1c053814286f5a4074c00b013d41061d7810f05aab46e6e2665248513caee4f9f7a908dabf66ae85ef2e76c0d6ad4aef05b06a17aec92b9aea4ae277aa773a40bf8841401c08e78ec410068e2bb048ef27a4d2e866e7a0bf48b5657205dd7fe428fcb6050655b96ef677679bcf5d281fdaf48933212bd3b8d657c6ed5775767f39bdcfcdc96a5d9410cbcf2898abc1c157a34f9854d50323de2732254c8020875fc9707148b3c33e4235a8b3fd2ee889079ff0eca19236e5e24d3a1e94d4eacf282407d5f7d14a87874e15e250e42a002ba028cbeae5ee57c27b0e8461bed5a4d82308c60495a217ade16b1ab25db52701d71efced2b8044d38e364e746e2ae08d36dc87e952e43ec4c1cdd3697879f26f780298fd0da643bba49f3f6c6bf20bfb52285b1841174a4e7f4c9e024ba6eb5be971a63cf97fb21ce479a80f7f033901af936195b9bc48dd7833962735ba07a408549a40dcd72c16e186c16c19c981ce7c482cd47199bed58c95a9be4ddeb0b89bb0f26effd74b7bafdf0943617e34cabd13656e9f9f253edea964290f8c68b35e2ba529d482dcb38dcbc8198f958b69dd95cf038bd6a0d7117b4509db6ee53946a9aa00ad9494091da0ea533ad3eaf708de89be84fe0dace000cc7717ac7c18e4b6fedc77e49c533ebb50b2189c4def81496007859cfa363ede3cc45491d70ce5324bd794c81a532d66dac89b5cb7f44b3bd802e31833e5f9fc0cdbc1280a96346fd145443be3543fb5da1ef3efe2b977fb8c50871bf4d497e924c63aa998aa63d03593f2f2165f0629bede450785d0a7c78c7ecf2e77daa804ac53db056a1923f249f89082dc8f46fc861aa429b0ffa62fb32bdcb5ef668d5f08287ba85f163d0fe6c8b0f94cd252661cede44e1684668cee45cf155bb7fa972d59ce74f069de437e81fe60b05d86589afd4c9ad71bc7ef193ad1d4f9e1deb1c3b3583588b63d50f81b507529cea3cc6fa38278b74638b7c5d8d1cf1f733be0541d8e311ecc910b82f24a45813f27809d33bdb933e65383662f41ae165580ebc61fd1f335c6113480c90c51b32316ba821eeedf0e64c5561c2ee84e80d926b2d5165b1b39f507d53c6c2a4219343378065e33e9837fe23fe269b95cce84d6115b80d7e5dfbf7c559d2955e98798131487e8dfb9d578d9dea9a28b0802f7767d7733d55450b5aa79d53d75c4585428b287a60e96f99ebdf5c8e665e22d68633d4a3121d482ea4b371f61e28c3ae4d0f2c9e4e6e78ffe6a8853cba9dd5f69dfab8bb3f67b434044be0cfbfe62d49bf40430d7126d0c32d34f58bfa307b0f822b142a20f183df0eb6f99babb02080a060a0e3be784a6916ab1a3a7643b400af4476951e0d23247c787ad9609c2b3240e86472aa820f1a822bdcf65320e98f3be45ce02e5ae90a7b334d2717635f22b15799ffbedc9ee1eda2ef6bc27c6375ee082d3b5f5cf019bff34944addc4a34781c167e6c2550958cd5cd786093c9257aae0db1fedc0387a7207b28f137b390d6762082f55a35620b26ce886bb8e826ee08525f0f5e0a59aca49ce6d610ad4ead5334eada2e7e0ebf2012b9ae294a49c73001154d7c24b71143b2255644e44f4c391012380394386ad6b1d226d5247239cf0b374489a329b7640b85e9907cb44dc5f21eada3c3744af4e067f979705c0464ba595f2e34adaeadd66fefa947c79d7ca7a3fc17f2d3dc7df9c85be1a49720d5c12a453d757e927682819c6772f28e41293f1c93758918d01ab0fa265171bb77a68633b420a2e568c6d2ea8244feb24f915d774db0f2cab7e399c09261559386a20a86dfe01f39bc9eed74f7cb0d04bf0b2978e98bea035e212dbcf129d0ab72e11419119951040f514e79a027e1e2ba70274747bb73154dc5a63d7dcf39c9d52715e314a4171b46a8b2818c7d3dc470a4e65a8e4b5b90b2d24bfc340cf2e358839d0cbe9607eae9c1cdf12cde25ab4b250c0b588d94736e2aacc551fc4dd780fa1519e6af9483724cb4731fe677ed4ddeeb7b55c9a1dd3cd4c52aa0bd650c826c3c7b83e04c708dc52ca7581141d3310b1b44112472bc0513c639e3e09e833446b78502c7620a0504d4e0544f5ce024afb8db9b396c6f06e5813bb43bf652f5c70b5b1cb9c574c948645e456e5386261e1452be37e855f2224ce37116603d45d7df4666ff8f83480784859b8c0481ed151d4bd87ae2c19a9adbb0598994c172b1892f777bef926336d8ad675625da80eecd69bed25b6b48d257113e0b5451b5c662f38c9c526c41fa8d8685d02b070bc5fa42d7b489565217ec09eebe963a8eea2a39768f8adb3284cd6ed2e60688449e7529cb5129cb5360cc6d3f6fa9be426dfee953ad96f0c9ef40008b98ac37529c7d96c36f8bb12377bddc0f66f8125cf275f8c3575b1da65985dd106f9317231e4e376b54529891aba481497c497f8a25d32d371f202d27240ffb98be3c8c488a20356efc9192b5b24801f99427560ba48991ef80dd0ba72fe7de2eaa45763bacf2ef29f0875cecb428a6dc89e5f1831cfaf78b6bd0674c70e345cb721f5d585caa8f5cdb684ad6687bd1862541181a99b656be46dcc8a2b2366a7ebbc07d55cf2ef965f4dd532bb6b55062807c8c312091b0f0763fbfcb2448ca4714e4ec8413672ec0d9f5a0074f2425842a1649a516f7c539bf6fec2aa00a716c9ec8be0f010d2c8873b938f39e6008850e4ac3b68aabb593e7d5519c8e1f861e883da43662e4a186284ea10f62d64c3cf60c6e9c7eda48dbda62ca6b78d6cfda1e47024c0f54101019591c8db3cca36a9fe3020f9d78bb7d65866d3b8e49c534808aebb8a87fbdc94b83bc8b5325ea2da64142587d29b5f82c72301dfbb8a930a0b279c27b61b0da4700c24839d8c7987634408f5dc51f8a50a57f43804fd06ce5fe9a1ad8f1b1328cdac13e472485580be616300d64424d2e3d20465864239e4dc5d8eb352750fc0934de9a9e913498885fbb4732f12f3b935796f486f4b7c2ae161ae856675ae3826faa36414600afdb467073296e31536bdf9d7206fc3a18195dfdba232e16fae685ca26aa3a8f48538bec0da1785b05e42d25f9213ba1bdc421b9001b43f7693cd73eb989ed7dc7d35e9fdebb7cfe4fdd34e404fed7c8e1bb7487e9430199f0d61f560da70106fac4430cacd9a78b8335b6f16cb6381962a870b9fb82c837387b7336dc23b4466fa1a8cb8034bc33d352ff8a158d4e7d156b13bb3d1827db61a8fb166f97517780cf03a76bc4c5ed2b9c79bb360f41557a8699f6cb1851dc9314d084fc751287f4a7f43230e26f19b97252455fcb605d6e38d6b64bb08b103063482a02d605179a0a596ab7b993deb5f0183c9a54a7030a823ed5fdb040b48e85715abc4a2cd8b02ab336eedcc5378391f0c2f1ca7630f03a3434d3b816fa8e7e77dcdbe531c0ca9d86cbf3ad702e7a624ea341384a4ac504ef4104fa8047c2d98b34b912c8da0d0a858eca1258badda6a5bea0770289604eb2718d526c2b798e8c763de4ac9b398fdf66f10cc84413ca33132ddc7cfa945aa92d9370159dd17cd6fd4e71bcf08581d1ec9f841c4fdf00b5f3b03ecccc7b9a8431d3867cdee6d9c2ad2fd94bf408d9c51f56598d0cda482b802645ecd538c8c194ed55d420c9eb426987d8205a9f3e297b63749d2d8b4ae2659f7ad138f023752c04a26754712342afb547d6b57ee46386bf3c7749cab02b5dca05e044685e756c408fe3100adb7848f9a02402c98d3c08bf90e01484cb121fa266226b8d15bb5626203883827398d27bd84859b3eaa3ed376d853d833d594fe684fc746bd4b9fca439eb4b7393029fbdd99a645f27763425b8567ec459f7d7c22b2cffd71c031aea2e1058a64c799b72c60c3a1a743a57a2c632d490360ef549f0c5880730d9f06ae228ac3cde7a2f64943666a048f57c33afe459c10884406cdfd9a9db83ec64fa8293a98f533a28169878405a97cad652edb7ce9e66bbb41cbb0fb1dd9c01a97a17ebb83bb85c28bf487da1dc73e3b76d629933c804c50782726a8608219ae1b48df90c29e375bd08d305b90c6dfd5dd62f413fe4ab88ce71257305de297f45ef2e362b12ee7772322cb805e226dd8b38def8af3a228742c26d4279e33b2066054f5a3c00ae60c9dd1f582490a2dd77862d4ea0dbb6f10b5f1a8f454ce563b97c8ca305d3df10d903d933819e3b71ab3b5081b951b51d1925de5e4be226267db3283ab67f5c8b61ee7af889b87ecc9db4196b6658b7d5da432f45a8c11119b9d7abe25dd4e4bb73799766fbc26925c4d271f5b55b0fb6f76feddd627d4be5ff7115f7053b0774e6960cb6b73effc51ac3c48f4da77675c4386ddcb33be61c8cf6ed540a6bf08c99d88444c57607ed18e29404bb8da66587f894cc297a2d680b10f68d8ad15d8420e0471f35a03ff4dfe674e6331de5e9293dbfb7c6a67fa3e243e9dbf3f5450548af94859b5846c7d092f6ad0f139db23710aed468f3fa995d9166df12cd648dcf56961a46c5b86f624c3b9ac8e372e3fdcc4be48588eb68c66419d2cd53b48f7459616eb02e807e5aa420e6c6c4741c532f48501839f73ba71011445a99f9a86611a5c4966bcd8b031790a3ae1dcb18e2b8a4bf50105776cdcf6e6d0a6055dc4f1569977536f746d62d7d3f8b27f65fb1f27ca02dd321db102eb9ef3d9c3f92abe40cbfc1aad428ee4f5ef07cfbd7af0ca1ae63b123167bbeaba44d0ab58a8fb19d6af1e40a3f2923bb73a8912d3257c468ce0ad1b6f9de20839d86793bfe7ecee2aee99fb9cf7b4cfa5412e743c9be8aae2f4e051c1dce59f0e85ec657b68e93cf63ecc4f44c22e15c61673616bc8084abf65a350733a2373761cec93b2e072693fa4f723e22d90135f06378873ac58704885edba2ead3cff10d7df634d1484cc4c274158dd3a33483c102328b04a70860688604025189f96ba62bb7b62972e5ab1d944c759fea2cec27999cb67114747f1ffc1c581ef4ee166e70683573426b2a701eb161526bed6acb07776f05dca72d6bb70a2ba4d8d7cf5f0d01b71e95059c2bd93d449d573c5d923c05bd4a4cbce9f54d405585ca9447c9b4db5d569ac96b920ede1dca620d1d167a4b77e1723fb16d3d68b48092130717355d8f463dd647706be63feabd062c607f166549c22c3cb644c49427a79e7a2cf2dc478745e7e8cbb3af5191f4882c435b9cd8c71ae86df62bc3d5b68db37b41af9ebff7eb22a169928ef78dfb8b004f988a38b47ae9e239cf247839fc5c28087c802d9261121cb551814f862a8c35dd29ddcfcf6008cf1949a354a47b73e21cf1cbe86d109d6ea04cd9f814d94f0e56cf9d410e4b35e074de306c074b58aecf6df2d1949f254b2df576e447fe0a0901cddb62d0814a5ac93d6c0bd1b1f924968f488f20046a25aac105964177746eca1c0e9a8d9e56b247d2aa97d87d0874e06c91ff63f8d652e19efc9dae2f9988052b3f3693761ab34a9adc761e7f8b78900b14bf7777291ef84f6144034a93483853027b7bc2ab011647bd3a9a0c288ad24e9a3da154d4e7c686e89e5092c7701864a6a766f14edbc857c053aa0b05d311cd19401f3965125cbc73e21521c7e7bbd69305a1bf55a36928f6c10034a9fbc6e8ca6c471f6bc9fd144a503a7c1e40724da9a2c9cd9e9b3ccc5905d0b378984f54128fa46fa9eebb7180f4864af9df451a4f44857e639fcdf27727601e06f189ec9d05bb43506478d387c514c4218123c38508b3e388b3b0528e7a86f06d13fa1d8e1952afaa3a6837fe5058e6d4e87d478edb0033c22e8728da17dcb6fc693cee4a0707dcf63286c0bba84e1f46a06f0222097a0730373038c3d7979118193034a49a3f667cb26770a16884e33a8d47358159e513ed0f0ef50ff629eba8dfebf17a81f036706aada2a26c886fa7da15c8520ce32a6d7ea74ea408f282ec07fe9fe922c246f9510d2f458217e61f59ed4ee66b311ecef78ece16fe41224954ef832a13ef965c4db5ba9681cd97e5b3bc10078c121ebbd0fb38e2b526bef964f259cb66d19e47bafd8650a11d76b4658557e0c435d4a3eb2cad896024bbcc41ee9ded42bcabac0373ed033996919bdc074444a6fa892bc3a30c60aed416d087c7d23147390edd187ca7e3bc815b5496b3fa8842d2c21fae336e1b7eea06c6f159b2ba478d4b637edbe63511aba7480b22fa4c07ebda90bbfb78979b8ca8bd9e7f301bd847e31df894d3d57fad1d9fdf94b275128b96ca8cc9d528bce6e5eb7960649da32d63468a03d57ad480953c50eff9c190c18d4bcf2c93a516db687eb8c7791724774d6e1c0b61840a90e31723b52797ffbbe7766060d01762c620f56dc96625b60148e0c9d0f4620256e301ac4e426ab16e686e826cf7aa3efe78538d3ef5250de96a2f6365d9a575e999624c8935e51d33dad6c1ba1ce1c4a461f619287c582e80c47ed2170c9c4cbd563c8d40269efa095a65b721b6d1a6712a52f3ce02356040e7d2f7e61504aef9695ee9fdfb4833d3ac0d61c1194713a57d008061eb6f94d9598c9e5c8181df9b53f715eeaebe74e188d0556de73fd198644520b0e64babb871573b5a7d78311836735e66efdc304c7eeae70b5697867667bf503927cd0d76918ccf6ef1e376176d15c7b32c57cc51529f0777938945546b8adeea0f7677af038ee5d4a90078b189f0f8df698cd87a18d38ca4c84ef9e6abc36caf176f57a8cbf5102958f6719392ea0d9f930b29cf0a339665959888cf969b450aa67a1fd578ab890e98d52dc29a79e21804a69569929d7fcd84b9db22e64bdb9e80277464ce246b354a66fac03f2e49236cc7b910db3c5e55b97c48df8e6e54348360550f8df35627950b1b4110e5e209dea6664966c0868f826221438fe962ae9248cc2f891660f4cfb2188b45ff4c37eb3f335cc706c732bc5581a873c6313a98efd6bdfcb3f1906c1876587493e79a912c6f4ba33c1dfb6eb9d62c1b66653a391f1d9ec99ca4c40142b466e5e7fa15ae8277bcc5167a5804a64be1c9640d0f8ab414d4fc4c93ce3d0f453f557ac62f991184c0ba927d396643856ee44c9055a0b47ea156e0824e7e6b61b76c8ab776c49e5809c2380fce324484c8db947827a7e028e83b90f6b4ea1cad96a57cf6ae053bb2888eab88b29ef697aa8ac8aa5eb5d610406a738ed130d000309e9591b6c4667627c1ee6b654cebca437a9c02ed99a9ec251c4a292c91169bba81f2b1c31f8a1cb337fc0c27ee01368416de5a8ee2da797d3640f1097d1e6f6986bbaf95f8913523883a6faf5709f544ef30ef1fab7b281e09f59ccf53517c044d299106c32ac8ce42c9e335b9e43937d19986a1654c36b5638012bd1adc6c6cf5f3c82033f104c1a9f9570484f06c96a26fdce651e8e0c3ecb027c5b8e13dac56f2203e4ffb8047a65c8133dfa6fce372f998f030533b1d40d9575efaa1513bf63f268bd633a2f8eb27aa2a033ab7adb0e001381eba42cb7f850362d69000300778b630d809fd4db3582c07f05adaac47cd8e6f65eb6fd612b260a89a88382633bf68675ac5590ee554b81428b4fa81f5d9d06f8f1a920a0c1de7f32c810578da36bfefe0e33be0b51505c34d4bb69c7f1ce9e55b0df7cc24e7924c4c9cbe663b72c88bb895c9e30c7ba3283ca7adf21a2adb256e97911236e3a0da2ae45ff8cf4fe7f78abd2ba0905fb33f13af9bd1f683f776720204f4e7efa7c8146cd244008a87f371c8c1c0a429ecb9db4f49fe6b4feb4d34bc8cf771ca91e4552389b7bee11942c2780b222e8c71fee42048351499d8498e4a32498c6ede023c63f22f2057a93e8f0824965b193f0d77ff5813fff52fd3ff999d7532261395259b71d5544b3e0e9105f14830602d5fc0d66bb342190840f2aecfe982bdec24b24e994fcf3870e22c13afe96f53ecb9c14a343db9795a6c41eeaf701f52a3bdffbb60a1ca8d5332970738846e549e7b76fb0721a813472092deb5b8a3f19da71ca3a6f90e25eb69a0491d72bc46bf46a1ba7d3d2c2805391cb7b72c0db4800232058c6b79cd6cf9a3865da15e0aa55c46074b8f455bf6d9e7d3dac38db1bfd3b51aa1fc32ce75e4b3d1ae5e01699736a37b5c05a989692510679fdfe3b6cfc3c8f3b6bdc916301c3391df0d67343d446d845b22596ea22a36e0af4c9a57671287029de46e1959435a7363fdbe93ba34861e071262fd79ea3df5e7740c2007f9402839eb835bb1ff7cdd97be3bdcf5577a360e98fb6631f7bcb24811a3c042df2c6947868ed4245010c8c3ca272c109ba9b6abf0e217b126ea16d8980fa2fc6914452a72e5c4c09f2f4a0eef4cbfd6da7dd3723577ed902e3ec408beab27f084e0a20c88f79ada247476d6b2817f2e1505b8102bc5f3e1731a4299ef2bedb871a7af44d25c5f4aaba85cb82506dcab457e9c9452af8f5a13ed86a25c16d6387249fb3789ae04967eee9c32038ae53b1c2d426a5dad8c97568bbd528aa404fb295e4b6911907e91fa9492ecfe32480dce973d0b5c8fa2316430160a0fa8e24d2eb8448b280bc6b55a90a6b94bdde3d9d826c5cbbea815589788ed0a4332732242392fbe19818b0a57831bf58063fff070cd87284ff1b18fe8bb0c5fb47dde14b014fbe4ca4f1bef1d1b1e84cbd1e618e41f7f801d21fed50a4c2cd7f4be8a96de5b14549ffcd19c35ee42726ab70d35cec5da84b6e78da0924f885eea2f23336647f700f161ce7683b84c1a8b73a77a3d2af4c00ebc81e9282dd708409573457229a8a646f11c2bd0e7d25eb10836dea136af92446466e5139890db487315cd6a3b9e328d7163e99af14986d3f857c31a10f9eb68799354a36a15dd1dd614e4bb6a772215d48b827160feaeca0f5daa2d644196982074beb9822dad221360be99e1f41e092640f429da1aebfacdec25687ddd534f27e81ba2028f714aa3830f78d96ef4c0837bed1a5fe6f51de2ff7ff48a7921f48e749592ffc9c7a12df8ccc1cf48ed23b2188575cda883865b91ef8ca3fb3b5b29b536019a8ded6aad9ad1a4fed2d7a95f280f63d6608398dd9dde6026a4d7d4de5799862af55132a43dc0680a12b0dd627be25175854e413387177e00788782a7120332948c993cf6670d49854e359cfc8b5d1cf645efc003b9172e25f5458731abc34905d9167c8acc298c1ce75b3e72bd5cfc1c1446869435e236308572f7ef1e7be370441aceed49ce6484fe883139995a2e84b6651061b92824615a8a751e67df8300ec13778045828097a0db0190b434f4293d6058a9400ea92cd5c7112d1ea008905e1c86f47b3c2561c56e29215940a5b4d852885bff3858229d63d43d7a48ab608665252bf4fbc3f06e90f85c30b1c3c9c476b453e508534785a940550bdfed60678ecb799d5e756b05878167a9e31de2bb089e13eaee604780cca6a958664e49121cf48daa2abb1fc60e0323ae2a71130d365fce3840e4f1f0296f09d61fd21abb80b3a2940f2704f0e1993a6e5cdb2913d5cfe40286aabd8d61b936147a0c488cf54b9f39cdfdc2f5bf9c1498a5c3004e7bf1dc08e7c433fba019857d406d2730ce1b951046eb60e0f2b92f7c0a1ab593807c2a76d181b7476e4353e59988504c707c27aa440afae9271c6fe70f7df3614031e3c22b05c6a66f24ba524e0693c224d885e78f25f38d1196ca8d45781ffce1c120128e38bb5b7c1883c97d3a572902d8bc4964a561adbc6f9af0be58f13158abc31ebb1084febbfe1c5777562157dfd875da0c42e3cf97ea8d05c99e7d2f35fdc9238c2ce84dddcfd391a432dae671d69e25759b76fbfc505db68e4e1a7fba78a73c846d6daacc2c74dd6dc7677e07d27adb198f0d8024e93abcdb6151a5ba279540e630216fa274f156336ae00316ed470a0abfd14f7cbb84500d68bc3dc9696cb0df69ccb7a44d1f2f3afad2dd7097272d7fd1ef6d1b1518e5550c8db8dd46bba199b3944b02080651f84bd2471c2e803b89ed8fdd07d3935f9708bf6acfe92ec1897ea35a9218314bf21e8e9ef40f4422ff28a71d23c6786dd8fa1d3e8f7c0bf381a3a3484ea38732c0ce59d8738b5d6683397e9767d44cf3b805a7be594f24e48dcb92f9021f9d6c8a7eef8ec9223f4a2f4e084d99edbc959d4049cac0c29d31ce6e2fb336a3ba5c4f3ea8b1d66ae687abdd09baaa0420d4c448deccf4e8f7abc233c23a8697a4d5fe898e4c287dda95880e9637c3f8aae2ebf200d790ff0160996c8e7acd4de617bcb9d192e7758b57ebb0d15cbc19a45cb87f7e68a6939805194c824880f007f2243edd618a3d7959d86d4288d2fa75770e0b24a90cf92e5e8bbc2fb60e28cc6f90c3b4af85b18c002d9ac9610afca4c6f919b76f5caecc6c6af9787cb759fbf83100c4714c1a85b46f55e4630bdcf1f567555fc0d49318e558c51cb2c33672ce130050e941bb1806c529b69f0c4a836b40d669a52ba500f7b4f0628522cf598493bd764c653ea57f2a1398d79bd8eecfc942bf99b395a064e96cdd95a5ab6f1f82f4423a99070a5abdcdf88c4a0cfdf585ede6127d3e084f0619d185c06d767da5838054103aa7bfe965548aab20ce61ef76ec7ef0d33e04eb3d19f1d1d066ad7426e6dc3c3724d92b32ab0db0d529e06b52b25ac243f3939dedc7721a9b76921c0e0848dba5c0c298f41ff7ab9ea313d7b0b057790c47068c85580517167a794f880dbed695466dbc5da0913495c3ee9e90c1f9d00e87bc8d4cbb300e32e4b76ae538f025124eca2d4131eac64d41420377dcc3c7a524fd12ddf6fd6013423cde0e1e2d8dee16a14fbed7d62efaa8e4185207d0b662d389519348ea1f526c70aef92c493bd23f86e232ccffd3ad7c264e9d70283eabab1eee10d0d3f5b2c24cf5504ccbc3c02c7b9da2f5ce0c0934563a4bdf7f4e4f13e1a1593c7b00f2d04e3c29c8acb384208d22b32778687720a9c0387be5d8f72e1fa357d4b8d8e6793c848c6f0e99ef27f2cd0a6f8890091ad1bdcca7b4c0183c61142740a622e391a11dc38da1b00bf0be3e2e4078979f1db79d4706138c7c358ce31a46ebe25ba1009b2b8805aea9c2d09864104fae5898e84365c508c449fdc19dcae6bc57500ada7ab6a8c2781e9494327fe873beb928d60107b7931512ac09a38759f8dd2be68bcebe81521a390a2c6846820b9a52b038935284db0c281a793e3814899990e8ec988e677800b7b64c77a8f35b66cdd1e1f622a73f72633b975200b23d7bb52634c75c6adfcf6bbb97b64b4e05708250e97361d457232987f5f84c76fa6422f31ccb2c305f5c615af8bb0fe53e2e1ff493cb932d201ce61367907cdcf41aca135f55ee06ceebc562148441a63bf8932bbe4c39e8fee797826345311ef215f6df31adff74ff4e04813cad5c6c142f88e98c2c796cc6d9883047feb911a882374cc35e9b4f3491dd2fc9d7614e9e1d024ee6f8c564de379e32fbfbd09071ef1e8f75ecd0e986439239fbbd5f95a697168e07ee2b5be46d2429b692a7422deb669921a6880a874d0eda596e6d8c12100c690be2216f3803ecee3ee7ca7e7e902301f121a867f0e25038b2580d8805f926e67abbc6416fefea044d7d7e6754a415d62b8adbf4f83741fcaceeb586a09462db1125ab58e28951ec3e921893c911205f3a9202ff53429f3759b2ce79d099d09d94fc2943583e61e8b36a2123e6c3318dfaf7d5443e68ec89572330c28983a1d5154609a3878fce1f24d0d10c550717e0927a36e656d444cf8e2129dc06eb6589e8267faf7032cb45f7c691a624390bf3cddc4d8e2c84323b1cf31ec390ffafeaf3eff7d4a49c1d09c3089624a1fd0f1db6e961223870d581dad714cfdd44a09204d5da837260c3ca1db93bfab71c6ee10c22b8079b3bdd2268e53d23c88a62392e871b57d1601a5d67ffee23fc2da5a9eefc19788a360bd8f451c37225b32873e5ff3b871bfb132df8007568b1e62db55fcb11a3292a63f552364d5258752c3528bc9317699b89f22a48a84fe77745179b9ae831ee1419d485bde0efe82c69e7f051fa290d0aa923cda2478760c62b0391822149aa508b7efd03014c399f34e8c9b5850b4d8c7e33d6f0f1f7f89987302c0eecd98123c936430e6ee9e763b2afb1b126e79ecabcc3b5ba0e39c73debcbaa61aada8d57254270fa2d0968aa030a1301c4cd095815019caa694f2f6edab348cb5c2be0254bd5e84b79a72ab978125332d1698bdd277f49a9c05087349994e56bb0c5c1f2e17ce497f1f94b152c531a97cf7c2720c126b8890195787be346088e3117daa66b4f9cc85db5d2aafcdff28108c81c98beebc308c3dc6f218b5f039d101e1f0850f84086a5c59fafe3ee4ff592df5d612b14ef87af9ae40c9666a90d134751d59cca1eccb27b639c48f6ab0f7f8d25588d467feac909c04ef5f5b9092a33f74e0a49130ae49904635c2dbfa72ea27c01265efc2c918bf9ab9c589c60da7607f5f07350a79918398e8c307bad96a13e01b16990f2963dd25e4942f4b6b45a9bf74611257fbd48a9f8e3cc07010099a29c0209997e943cfb43795c1a2920ff31bb00314a70c4d3bdd0820b1e32d66cede3e6eeb5b8d0654adef3b3d5d9e46ed7be8bdf31fbdd317a49e34e4e6c7b6cda8ce48ff7f7f798b8d6290ce3afa03f1bb8f65c036ce488d6ce7d46a1605dc7ba9a3db5bdf1b74dc030f9f736cb496da5758f14ec5183b39902a5c826ed9933100fd9e87f1553cac7bf97630a6ad3a9a6a14f07ffcd4d41dd10769e3a50dc673204abb0b9565667b420c0d4f41870d79f64349af5f0d39d812bbef23795ad6f011adba742d5eb0ed0f92d5faa3b221a546f5318b4b5ec76d90c9f36e27d2609891855aa734a39485ef36ab36ca2e4680d0bfb7943abb2e4cf880cdb125b62ff526e0f15aabb4195f3e03835ebf42f65b909c306e776052a965fa17255326f6a1b323600435647d31cd430982fdfc77256bd449d78857746b60d5af4106f19805a1608bf1f4e8a6dde3edf2a9063890aa977b878f1eae92b4ff504c502bd29a93eacc521bd504f704ea635b9ae8617037858e869049f4112c74fa7aa6dd1bf356a260d4e5a6b6572113c60b7cb8cbf74330fca146539c27df7bc3638d0f3139e42858a02d53c5c9a8e0d66d2ec53aae2bca6a024d6d5eded9b894704efea52ede332320780c4aacd0f71a68504bb5092b912547794fa74bb61f466b6c231a10d07148a57064ef6cef44f83ab21d04bf51662717f3189f407c629641f62e8f6363d68b27a89e9e2864a954b0d87e86ceb6b0eca188c20c4b85b2986eced035e85471f2530f53fa00cbf4461e4f5ad45df9c22df362d68662bb97aca74d8b7b54c75c4dffcfe51af1cada3bb5baaa453e36efd65c904412dc5fa51103efef8ca0b4017154882b0d64fc99c8a74fb2bfccd222e4de7deda111c9bb4acf101247e210e6757bfcb5e00dda29bf68da5cd9c329bf9aa22093125dffe92c27f42e6b152f79f40af5a19ebce435e8903e637fef902789199d3920b348699a0e616093e9d4d55f30777e1516edcec118f48ea6843c34a847849d6ad67df69812c3780821f48da75f5b06d0334dc9a65c5c00b0091e2a1ef692bdc52ad3e6e5625649e5fc018d7eab52e494cd89084b7ccf98e27696ba09b9d629cd53091a2685d277e039958508d96a82f59c6fc913ee7f8f54943641a7f7859647815a4c6fd1236be38611d70e8e121a1ffe026115c4efc8b97850e341c7746c8ad9f2b82befb22fac0f7962d96f16087496f2d599eba5d9fbb3d7efe5723b2b6609d58b1b24e7965cbf1450c18ba05564503758fd298934b97b19d9a7516aa26a004e900aeccbb6fbea1a3d92d92ed8aac446f5007961e37b75090915e5e50f7b8a48595d8f9d8a26d1b9f053b28c816eb442e237de309a77c2d3de3e63bfcd5e54295156060493a56880c913c630c95030857c82c3ec19e032775751c6274b1b8f0a0b27fde092698b72c65f70a09c923b9bd984dc66d0f4d5ed162a99323678e8e6ae1d07c3a1957d1d9797d05e58355acc17afcbf2051aba97275b1477073100e447e1c6fbc993e67b3d9c97452b8db15cb1445bf253ca012e273b5c18c3ad4ed60647d93f94ac67cded2c6cd04a5b2e1a573951d362f523f15bebc35aa3de1ac3ce8bf009019f0d4dea04020352d5abbe0ed74af5fed7b117c35c7a50c0445a020be9d0864a91d3d7425807662411ddffee8a645e3fa7a509052e883f6c7d046061da7ab667c2f9e53699778a9c649293358454bf1a47473de3b2fdc3f9f4f7b93d59f2716eed44f9e4b461c69dca02152be14933fa916d64792ec62e606ff33a9e84d46dc4f18ce2551881044433beab9f46ed485796ab5f4fa2f34fd3e52b15d461a7ba331aa6bc077a02b0f354414ca19822e80197091a753ef5e175a5420d8ec4a634dc928f0ca83dee2669f95766a02fdb63b5b81ed74c1059cb2a396b92c51fcd824366b779878ff686f33a060b78361b7bddd632d92eb30ffe95de265c5274f44f1d22e3589a93b45e248acf32c88f1df1923b98ea077f3b19f0e71cf76e8be439b05e3e5535ed2318e3cc2df79049aba955f887fc6a0cbf71b38dd8b9c702cc3e02c56a8e00bd4bc3c0fb2b2c94a1c514c3d5d9319b75eb5b62f198bec3bda9eb80cbe507ed858115e7426b9296959d6b6802a09a375f62d5c793d94f852e8b0b4884332a5879ce5345e16e1e7aed3683ed3dcb4f0f49c5db783e207516e3bb6221cad0ec9ca6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
