<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be0df199f61e93a89f50cbe57b4e08e79aecbfcad01b153883690568d3bb463cdc24a51ba9e1fe93e58d995d6305cde668d3db10a0007658c45777b5765addc60e4a5d453e79c136b7260d73c4b4703f383272474dde5b66cc11bdca0cf74abb6630d25254d243cf816c1a0ebfb2d685c47bc54d88390049565868c6e478ee2c8b362496756fadca832f41e493407156cb098916f0bc0ec66499dc66c7529bdfb4995fa9d384dfbbf84db2882ef8f2efe284c25c31903d3c7005d904dc598cfd9c4deb24ec0fdafc82dd84caea70701a3e582383551a0496895387676c93bec4972ad188cfccb294aee03c2bf693c91654ccf277c523526fcc5ee849f0eba32c32704c5713f40754e48fda2590dc0f1de33f41be4b38435cb1f28c1ed485f05532743c87030254e1bbb1e98efb38835d0f1775e3a982d49366f417e2e4af3d62109297675aa15462edc4ed67e626762c42798bea5c311304b0a3d3c14a813115afe9929509af1edc60b50d75057c6d5a9551d9521461ce808faf0618df1b35d0552008f510b6e7d2ae7b6a4f85e679e0f3a157da5044c3d5dd98badfe7fac3de7b5bdeb1f419c549c25a41a9fe64aca29a31f1a744197a2a496e6a93b501219e04317915688371f486767760f7dcebd9bbb5396215a7575d33fe3687bb432c867066b1fbd9f73a76b4f621af8dbcab1a4256a167bdc53234d8fe714adae9155da1275652cdfde4ce0cd73a7ddb3d83a32ea07048987adc50a3b782d7a1f3bc1ff711dd0facbd0c2f222a3d7d76fc585ff6b423aec2d06a53d43ee9bf14c6f22b02262659d3d5fc94bc67c5d633a3f84df4e679c8cc7b4ee85e8e9ce45240f4b5ac62a01dd4b2f7510512a214e39f7cdd2be45015d99f809d06b7b340290ff43d1a050f3fcf5ed802db3f0fedc129074281694523f5ef85f1e72c1ededae9f25f75370d14e49d4a55709d43707e7127bc40c19d1fbe52b5e7a3204fea8fbf16fa71716a98554de5a810ed7c7c9e6749be4c505460948fcb486edda821a918ccbf6f48b53639ce1672f66f4b2347ad1e2f092f517e376ab58ff11495dc9035a913e48fa402969239113571664891ca906acb8e6f890e25018e478cfe74b2e4eb157e1510425639c1dcb2e84fd1f7d4b1ed2442506eda68cb2f3858ff1e6e049727222356bc3d1ebd6af8667a8be16e1b2a37b764d1bbf078ca692ca02d9296721ba94b9bd26a0a3cbd15766b1e66bbe437f5e0efe15e1cc842f1d7ac223a61f08dcbd2922c952bda81b82862bfaf51480d2cbb7896b5ce53f9ec56c2438fecaa8596af746295e8d6d8b15d6803cb31dc89374f87b71142c47d1a08208a20452c0dc9133e231c99d3a617e05f88746efd5664110a83d74182fc4148bf5698348f28e1b996377eeba7fd199a2a9f142d5919fa4a7acf00b466a8e2ca1f4e480f0238122b4c5b61badbb6f1692f269d21a772f09b26ff823f9157664af807d66b8d317dd9f0f838af7002c6034bad50ba3d92468ad4ad16e0d871d136c6b59c642a3592666a648b459dfca93a6ddd65b3b87391ed526b1dfc9eb8cfd82ce7f34f6abe55076462240910e8b59c54b8518e19a3e2c559ab25c5267a65af0dd4a1516ff55e35ee64a64d80e0f0890acb5145e4d1cd8112a1b39a0cb9a0c62b71247a0981726703347912faa049e8cf64f0e23357dfce36a861413c939edee38f6aefc02742da39f57552471c40171f817fd24a664552b0d998f30fe931db02c6ef2cf433807f0a61ccdac35d5c273a40f8909ed39f32999cc7fe2457cd444b15256e7f2ab1a627e6b20de39d92cf11e1be55b2d6a4c9c283b90291ae7e9a79f9be7a2b9b4945f8c47071d9509cd82f854c094abaae43b461d42d96145cf0b9973d493a9f98b75e531227ad814d55277783206ea4767352dfd3cedc7b693199a0300a97eea3da7580bc4e3034011c7d3de7fd11969632a48b05798ceeec6f1559a0f3d6fbeaf4c68d7c6fc07328bda331ecf3d1579eed1fd64642cfeb3f334734de9e41b4f07408e705b457e020e53acfa4359a13b36a26bd543e128f3e606126021595a416763696c9add9c87ac71c4b2634f710bb9b263f91d3d8f4753965ea02d2bf44488498adfc6a12e8a2047016ed9d84dd061e5340e56e29d26f42e68c07e0a6a1d5bb430a1842b2e9255af3dece97929f84cfc6bac4e5b97508663f2b2a8ae303add05761e0967ef73b507d4bf9ac6c0e86e4edc347cbf4497dae50595c23eba0d4adad9e6b87ae359847f965271b9047daaae11fb06994dcb9c20076da3127b4a0b6304554d70956c9181b655519efe12411163703ca8bfe3dae99337a43cd0b3c6891e80c982dc6d13f68b71623635efcb0025c7f8485e7899a6c80fa281a87a961f8106eaa93dd86e2e16586851c0b68f2b9cef80c757ed3e12d831309e6fe8d5dd69fed4d9d3cf1a6770db50f41d9924105325c1ed37adfa10351a8100bfcd1a6085f7a47465b7e947af0cedd3c3ad5a9a1e38f2d7bc85fd32c5144bcb96b255f88f28e928998cd7513e0d60e5c69a6c7f2aeb4b211fc6288d5a97a1e73504d342082ca90a44c1d1a48c6bf484f3617a0299632ccc58d40f4003184197715249bb05e75245dd0c38e723518fd73ffcadfe93a8c9d5908c686c44d292dbe7fbb50f4085259df418241fe24173369b3ba0078927e845ec0e928667189b9f22f813ae817e46ee0de2dab41b0c28b8b061440c4dea4adbfafee5f9a8f665cc5b9b0f64ab38f8493a465417aa18b705babc21d6b995b6baab0b415c2d6e3ce3bc8ce3eb306c76f3d813c6714e760b001dbd25d7f200dead7294defa9aee8397619c5ba82c3ba451768b4d05b1f68317003aa6fe804e5b1e07b25f4e7d8bb6fa258ce603e523d3cee68712b9088268f57fce5881a7d6f15adb420fcfb93704eb54d49dfeded16348ffd03f27b3ef97fcd88a047e2013d19431a0c6a6ff74bf5c9a820e734cc2cb5c53d6bec5ebd29d971b42e588f4267c82ae0a0cd5cdb7d5e5dc5699ae612029403c239041cf4badb1406863cb2caa4ceef22460f0ac66c8e3d53d1dfd78595e2591e871a7234b3be1882216bbd4999021ec1d155bddfca3141b07e49ca5bad3ec0e11ac1b095bc0467c9ae1cf62b22101eac0dfc9110e4c9f5e6ee3ebf68881c0a92a952353c0ae00ee68af7f6d0c1cf4f241de5fedddfdc9c0ed658a89363393d5ae875495735ce16fe6a6dfff562c345dac8feebbc8b76e1864545331f04e5b408704928feb306f8d8f18e213d457b9c16291ae7498032a05975f1ba88d05b60f962c5371d6e608786413374b05d7eac4cd4dc5418ca9c40a433d877f8099d8361c08dd5908946febdee5bd6c107a8334cc383196f24439f94bf4c6762f0f63b097476a7498d3ec7879ba578b7b9e4bdcd7d76cb11d0e85522c82524c1bf5148e6c59c72786a024d01f18ce9c4ddbbf6d0755805f34e615d2d15b16cba7366a3149739165173820294d3111db8d1f250f56f7a150b35a978ea4efa9cbabe918aa0a117e071ef353d47e8d900a2aa56c26a64bba0f01d759e1e06d9d0633e0d75321d70798008b954c1406089ca0768128ae2286bb108465c3f4a3cf1e8c37769578968d3a4a7a865ea6a318dd41561eacf028317c9d32affe9bdadd0eaaa4ac6de6300dd2ff430938e9527af6b0112fe4ec925cda4f3acbfbde6e9c100fbdcb5ccdbe800769349d69f90a62c7e0503363ed7fce11d2a1516860d4efb8d5febc18ef4ac455c46698a004baf0c9df596d44e9d51f3d1169f080f8432f88fa06e280d32559e32bc0469b6ecf6a93e222131cdcc3489c03f7bebddf3862b780a88c39d2dbd28cf8c6f0f4dcb95d736812cf0f9a30d76a7ef504167a2c2675d88fc571fd12f4d67fb8d13d62697af7197034bd488bb396a826891222ebdeccb7b13dce47dae58f262c3be63b868aff85c484b818dc46767397eefcd41450392c5fc04117b57c33989c82b8d5523909bd1aadcd51774c55c824a4ffb38959a14593f18ae038349094551e5d76d71f6fb89736d4460e214a86c7afdfe1b1805f83fc51aace9dc4a7454a330067461d762a407d9fd06733f702e05d4a216488994ad8a81f5fda65bb9f9dffd4f2b598c7dd0fc8f8ff782f88dee71e56fa66ea60c0812d853db6ff3f4d8eed109b036548a3365d507784f2701260e12c9de1eef1558199ee28c9ad8131e9012d320357bf6b95e5b70f00d273c83a541ace9649fd4fe41af1a15537d05f160c744dfde78df3c19bdf45c8204cd8afe0a71efacc8ce9f6ddd2467c949a9c9b3e91bd83f4f1238177b910c3983146683a1ba46725f02ff2a0b442209aef5a1f1a4279e7cc1b6af06f601f1dec60ed8b74a17c6653332f7ae3f9b89e2ed99ce567c5c5214e73c223b6da3c6faa843cc3c9323a5c15404b29b3c2b7fbe63b2628920e05ed23398a47fcaa7a747783bee1c6b49ac7feff45e12b8097440b0c3b4077d5fe016bebb4cacc9c8d36f65d139766909d6af893db0713a6042c365c47de9e3606764f91d5e0116f45bfb12912bf9d176efcb9e773c76cf3e3401c1724ac85f2722a1083a1520fd022dfa9b60d6ffcd577b1d4f7d49a852ad9aac11dc12fedbca158ad840d5667f915fd16e1145e4656bdf6d6acb9c6ddb57174537e70a9209b05c519d5727bf6f568ebec7d5691faeef98d419bcb20000a900f1eace403df86ebd7e3a51b75158bca3e63316b4356cf045462e5a6654d51e170dccb681aacbd2b038d44458d5806aed5250fa51cbecab15396ee647f800dd24386866f03f92f1d97febf74963aa180f8a93b7cb32b5fbf24a2bd74a708d1512e969916d8987cb144b61ed4f31a178e462a527923507a63824159a8dcc8e5ea62736cc1b87ef3b3a47964303961ffceb499653ffc5abc9c03a76c09a93127b759084feec83f63ec28b8a838be77433792ec1ed9a528a11a065d5a2613ef566adcc0de9437fe42b246354b427a7fb07e900d5f6b7e56cc23decb3369ffca278aebb592dd8c7efc548866542fd95acb09b5e07262d456e39875e0e8028cd89147480beb724324202159515fd74c016f5b66adf2bc5314c863393a441a3cb095f7d5cce434c661f3ab5f53d100c1a522edc66c90add628bfd44901ba094d4b25bb2fb154d4586e3cf3fe2e388cb4182f401ed32107e67bc9f2b2fb3dd745aac897f35fca5ce9e029ecd285e5812a1b38185fbae74580bcb6f6d6dfe5df83a021b4ea427a249d0f80125995327ed5924ced3da1baed3f8be54857684d2f60750d066652bf26cdd03b350074e7d1ed59a04c3130aa17ec48e52a587ca488ffbb00613a5094f680739af9b8a631596ecdc813bf61e10e1aa68c8f44a5f02525a76bf959ae5d30fa6d17d8a25b2ea093593ebd86b1f19d34356579d643a48106f310f291042da0d8786ed249ad9f74e27098dc1c351bc1fef62edaa78311239c300f60cd2dbc38544e4b7644ca89d08ad006aecb1f3f95bbcf0e6c0e1e9ff63a0157c40f14954a2266fe49beb33792bc11857a336c6dc936657e3b00e84441978486984f5229918b2fe5ed41aa22d3edf6e8694facd6aadbc1554b7f986a81505cf311307617179a2712e80422158c9e3b36c07ff8bfef08ad8e5d00bcd9fdc97e998ad3dbdab58e922e7fb8a620f8f08f64ac8ad919bcc44ca56059c43cc27247f6b4b5b257295333fd4c846710d154474d7c80f79ada5023f964ba04a4c8876483b0e778a53be393a1dc50569478473009b39bd0c562c25158451956adaf16a760852d17d1dc493dc83c385a245ac46615bb612a58ba15e2cfa3337df6f1e47f28b82c160c74c8ff09013af5735a4d8e06dc90e9e3f1b73b440e9a50258d2883dbf3e73ae33b2ce7af3065573abdb74aefee2e9a5ef2927d9743672b832c0189bfa8fcc9b678642efd6cb80af5cf904756b3c97f8b41f43f2897e33aa41afa3d63abef8fe7980057ff9bf364cc1f2570925097c59e86156e2093fd9eeac790132873984502171a9557b7e80ec4e7d352887d67fc909eb5bbf351a9f47fbac366f1d66a073d1dee684a78142b0009b4898a1f21a093517553198cee033d22da165448862e278365f38b8e144c208f115c9eae6fbce27a541fd118b25232fd6ac14d233f0656ac141fe80b2fc44405ab0e5f91b6ebf769c4612422237f546dd79281e804969dc19a7e3ed3ab694ed387ae22bd9db07c533cf492d3a61ac2eb74019820705d08b85c719eb2ca3316a099ba972aff6ccb931a4e71e251e924daf9137ad8eb06c84c42e6a9c50ead679c15df18fcba5d6d92aee868662b26f9f60325ee7a40dbc456e7458aa7f3a353686ad1c04fc4f22c4c65c15ab19421d78cbe91106d0ed9c54407e778790ac1bd864f31d5823538a507ecbd31f68ae5ff2c01beed4befdd69da78f7890e539a71f6da2a72d6de32980b5d302701bcc551b01a61a3259e8237d2dfde2009a1fa131c5ee515d053f547d3d8ecbcd184d6c582ff73891b7f3391a46f459bf1db48cb596b63ef72e29d12e5ffba866441fbe93b79d4a18e8dd18498579502e457ffdde92cade8e4e2183218cc0f5d4217d0622de5fb9f3c539ee5215c9f5ea532bc10e992a2f3ec330725ff221d039de0984642565e354569883c6131eae1fcfc8f1702293f00411ead1ecb6e119c1028ccc409dfeb64414d1f4adbf7b3882f67d29e67f536e6a7786920d8c7b99f3df4e22e583b509bef98b3d723d462ca0a888a6054b1f62d2a9c41c3673248a5ede245cbcdb188bd4be56e0bddfe21e4e238a16d4e884d279338c6c974be03b2c693ecd705e0e40e77dfa6fd4ff92acb8a6ca469b9e2fd1c29ae6a92b1eb706652f247806c907a2358ae7b7bc6db49faac7219fbb83d32dcbd75f10006bd434826969825cc0bf97e459c78c56c7c931083f61606a1c5bea836cdcd8f546a26d62498b0c4de941fc59d4a3944fcef73b34f5b83899be267070078c780a55114d49b6b7e5da865113964f4c9a42a4e225247c2e0c74409568fd7477bbc4f5f230be5615972fafd0c455f99b48b4bc5a1924946d5aaf7a59918eda2687c1e90c9d872c046e802a9590d57a495e70d95980792c5fa1709f58fd50191b1b8ee24a172c9dd29c35bf5ea87419b46cb771b1a78aa4c5a4dd5644cced7d1bc4a3e9f12b63fe94a2c243a5e391c5257b5c61fd1c63d62b6df890fd75f4c35fecbd7a83c627a35c0fdca69ef3a05dcb55d51d08bd8db7b54289705495be41827f6598ca23a9fce15363a886c01d1deb226d8897577f544c90aeb4255b273e7c45146029431a109c3faf66578b8e57753640f9072795d67eb0e346bf54fd9e7a0ac374b904423a354afd3577b4430e49b27c6b99d785f299c76a39398dbbd1eb10d0d1b68fa7eb3a06c14f43bbf2d049591ef31ae20b9f09d241c3018d43e4a8a4295dfdc3d5064a02bcd04f093e34bfb245b022094c132c16288d99bd3d4905a9331de59b672d05986d94f7b9c5e06379b8a1da42927d5eaca4b5bc41481d1af693717a35c2b5d4b58d0deb15c2b8f3844483cabf8f02a26ba1507910e2f92a7ee4ee267d9d46906c29750d2aee54e3459ad79ef6229ea6faa13961770814240aabe71343072ed9b79a03578a1767b0ffa46dc94583ac013b0b93cde594a42f8bc880f22df95a79cf1968037710d25de89e56bba85bd8083a9970fd02a6f06de633851b4228a3d3a8fc05d201ed529717d838ae3f2cf973e7b1b97c34c86fbb937ad46d672718726be3fd37c97cf63ead2651a8ca29e49d9168975c7f34afb02219e88df3ce67380ada760ace2c96874ef4322c9100d5e11ac02ae5132c3e13a953ef344bdcbc1db538a0e0a1e59c0c3055eb334bdd93ff9cdb99847c45ebe1cb410c72c3c8d7d1258edb3b494d693c623bd2cbec655410722b32c4541716dac1a24392a2fd8088d1aea0b5a95f65ccceb522137047faa2b25f04ceffc009bb6bcb3ab7ca582befa9028c1f98f5525050c1694576894535a6bba22379373f9869f2b4636768b975b038321e58b94d840526cb9a18f97aee095c428970f7a97b7beda2e27d243c6b37608369ac50a6beeb7400ae83153aacea593c86c9daa91555140c8a4a5ca7a33ed085f0540165d00429f9cce454d9722d8da5a32bb75858f4eb262b6635f88dc43ff4e43f8c8bdd3df3dc2917508ddcc61e35ceda72a90dedc418b9d0a5a40f4f349342b9af0440156857971c69621ee304a74f5a5f7dd1ccccbdefdd4d3bbb46c72e8df1bd59e2ef7912652b239406f6cd98a7473b33be6873bdd045da716a7dca5dcc765dcb288b84bdd62de84af737072121dd42d60434a6ae6dbe2794883b7e45551bb0e87719688e7e1a0a92ba73dd5e97a6c15ca71676a60d6ccc873b1148fd583f39948b65907c79debe040c895d75d7387f975168a926899671e2d8d1c5071446061db5e768ef43afc05f951887aa190ab1e5bafaae96b4b8ef524c7aa88e621b0d7a77e800e10c982cf35224c8b276f298ab9aa3d523cd85b7ab5774104451659d5a7888c43ad961fa57aa2c826353bf9f0c7061b6a7939677590dab48a0b37d2fa74884fa07cc281adb7a4c3aadd7db06f6c93146164a3e857fe8406a58a2172543eca39614b66c301155750d41640b4a559719e2ca8969df3664c0207beaa6f40c4ddfef9d41e0f787f9ee86185525efcc831d27f7ff81d8b49e369956d8344259d4d6b17cbe7ded8bda33f8c4514d5291d6cc439b07e723d21f91928f8bc2fd920e741810de004fe238797c29f94f7d1005a7b2e12fc3d7795613c51826d02b86e65fde22746db13a67cf99aba931b144a69b8c04d4afa913150c5fc69f7827d9f8dfd9b417ee13f1e4891e12324ef02e7ec16ac1bd3ca3245da5427e7a1329848e6d13c7023d8f0e99464c2c09d2786520bb1f48a64c3f9b6763787ae0f6726ac9bf627f518818a4ae50cf5b3a8849bab9b51d65884530cfe0377a56c06be7dfb8a438bd59f1130a1c4b697554ec70c9d2aa60f48c4e01bf29695b61bb49386dd29597324232138d2b9ccf9882241d520a41a6ef9f0761be0a618e13fa42b0206570ff45652c429ac8f19857ed6f9e658988a78c64299eca211bda3ff315335e501fe933fb1b545195b594540e456cbcfd33785bdf30a4609f1171bf87fc3073aa5e75028c6b53282eeb73fb5818f8717c9e7fed28e5888433b6f167b9b33d0cdc5a00fc2fe65d60b138c87a0236fe73902f90de7cdb11553c016b86ce57673dfbbc1dc749df526816a801f0660e1d527a9c3f3d2dc04cfa557b0e052fc7c19526e257548057e251aa525dd5f06187c33d914635dcffd3e355d50315190f7d09b3f793c41ec93ed5b9bf9404a24adc9d390add1cf55d7e6c55542b3e4b7d3cef7ee6ad3f5dd989b2526e379eacd2a18c5743ff02f1c1ae525fdb66e412a72065a698e57a50659b92e7a7e73bb235d1244fa2ca28719ff010d8376dd45e335d55f64d13f0db9db0452726c7257b88fa4280130fa80bdf5d9a44299ac4467e42a6b347f46fc849cb6df5842b514b504e3bac56b6bdb967b791acd0872e40ac7b2ef2b48611be81cc70565cd9e5db3ed35f803e570818209e6b0357c580db6bf19660b0121012b6254ba7bb91ce7f4da476430bb1048c3713456190897c53ea6f04ec329541b4c068e134a9707cb8153fedcc14daf6a7cb6eeab3f975d46af630171974344de3284163dad9d4aab396e24f8de6fd202a523343c398ba21d37e2af3c59eecefaa672fd395f2990290d66a938a2e5af1b3f51d0842606556c2c8f9fc1de85292090a5a02abfca959dcfd06ebd4a34c7662357daaf01dea3badad3acccd8fbdf40b6276af2adde72fd04f5469291f30f6f921b837b1dcf844da3ac29730b45a71256eece4bb9ddb36501cad742a98141a7e80ac66cbc74c73dbeac3a727e7143de8014c0f2e923f254553a53d924481a405421060307563ca09bc8e8c7556909174d0227f6f3df467ee18ec291fccb7c695b649004600d3cf7e0854dd6ded9b696ba43f8a393da1519bd2cf35bb647896841e442976bd2f29d4048430682308bb057ea093680488793206073120c93fb36b33a7e78e1f04ee644bc03ab1b6042da893cfa93e3ccfcb2081a968664ed48ebbbf7671c610e90e68ad4f291f7b7af4b91df0b73a408ed5d72a524d19e935fcb29da5ef6eee67c5c1592b596921f533bf78907e3748e3ff14e8c23e91e4dd429b75266209117d50cbb4b80f8b1150896da8793622413e0c1dd47fd51c1ccde12dfd3ecdf4d4be83e1955071088f2bc23bd253132871d7dc66d9c866b5149d14042d2b74f85d39cc59b5cf8ff96535f5dd0cf3aa08c445f25c0c6c494a5a5b43e5818280334f8be07f69053ada7ca84f46c3e0bf052e14aea5d7b27a4632407e4b46a29bbf638a925bf015af9c70db4bb3663bca3eb5b5388b767894d160e92a0f20ef89908894133a0130a143c2517e9bb264d9eb8aac4b1780e2db990993ab51fc15559ec6fb7ab6bfbc025f19b93376db5bf6594e58d3fdd6ee402d5c1063dceb50a60ace8acf24f54a016167cf219c2e22b1a531f13ad912a8904f5885c42dadc79208973c84be9df6fbee79b025d9ae3055a603df7b86efb38441282fe840d10263334fb45854a5f0c11b93ef1989d9c892c926be1aab55187b9614d517df0305472b821aa3a0d5162ebaa9714ce648e973e604205586e43d551f530e73b67c29162e96221926933f7d895c1ef5f65b46644ee412181f83e2aebe4d2f792a3da34599c20dd786672c73e4a76b15b70dd0ca4603e9d06de63eb9b56fc2ff30fb39a595df7c1a303313132fb464a42d58b7db377fac99e647f8038228d59d395e6ec9912df0191439105e6b6fbb95e5f4a89c8c85a113a276c77c826e0165d59c278d5f082e3c7718b29b5b43fbc1e8be622ed9a3c05b2dc8a0ec95cafc4c6744e900306ff84ce7ebfb51f1296f83ecc9cc88c13f22b75f1a369cad56b9d57faf48b5a1885cf280369ba2876d523901715660e3601be378810fb0d0260df8a98d9e4adb78fa57f3ced7c1073d56e84337390adc941b6a0916b35c9c8eb6feb0c275ae49d9bbdf0fe9bce2ea472f23a0d76879386369817b85c15e19827ccac9f4728fdf3c2e23d4fb78bcfba287cd7036370afde3f2c8e785dc1a24d34d5ea69ac4ba09a36b10724de9c74d3c4204013b14d66d5b7bdec1b7767628074a516d2042d8aa96db3fe064c45cc80fb525a1706fa0aac0d8b798e55ce7244bb85d4d6d70e21be97b3c4b6a5f36e08c4538dbfce9f3e044697306fc92f3481a99a1a50e9f14626b1f03638c3da36f90f6597f566a5419cf52e7740b0b79f6dbad1d9c53ab4af24ac632ce6e1099cd5612fa738f676472aea12a072bad756fed839f84a3b9cfeb8aeff89e0ebddad74299e2848864abb4756334a5888a1938a3d0ed34f6a10aff4b0a162725e8e6349db022821b89fcb28ee5376d8573dff1edb6d7135d1c1e7b0aa0609f29a32843a78998a641ab8d0807ec34a27940a7644fbb0c838eb8aa5d08ded233b87c7fde198c45de538f7ff8321d4fb2a8f051fedd42c2b76d650ecc0a703d75e6e9644285d3d1ed97ed4f11eb96153661e9dbfb85131d0e3a87e70c41ca5beedf691eb428687c2f6dc9bdd1eee045d2b16615234cd4e9b1d6d88838e67befaf33b2bd719c57f656e6f018b3b60cc8ecc2c4979b8b298cd4cfa6d069df4d5ae69614a07388147e5c793fca378c3a6242e794569bc2784dae35d375097da8381ad2a3697a38a5647ffacd9b52f5062628552ae31b761473d0234c46c5543785381bf0f07d9565990849282e5d610f61e12419f920bce1c0c0aeeac30c4abd958eec4400b8e4f7c583439cbc3ab50668319baeda2b3e7aaa1d91a96fcb7c6069cab79e6bb6f4c2c92f3e5e02095fb0be41e32223023b7bd5e0edb14a8b82461ac5143518a5d19e4bbd518c09d42a627a4418764e2e969a074c7726374bc1d76395c5cc2c0416acd11aab57b9f5ca05d31961c57f2f5c00dd9c3f71fee67f76b16555bd75b3eb8bbeed5a4bc83acfd0f1fe59431d08d54ec78a02bbfa0922996280efa40a017206f18e509460d1cd3b9ab43aeb3137e5bf4f4d3ce014ccbeba7de84f664adc15ee013e45c339258e4225213691b2a7b4df1cf47e3fe8e06fc8f4f113c07369de550ddbd694c14bb65f744f1e516b321eb2e87c31a39ee8ccdb392ff8608674d5418782f336a3acff9278d5f769f3917da57b8c8604994350edf3f6a0ea7dc8204f60d8249d417949ed31ffbc15ce67ee0cf81aa4842d84b55ad107683ca0a5108a3c72293df19e0b3ffb9e4333463e9d1d42c53261540b3ae08b4e933fece049026620ca3fc72081669e39867a972113c44d839122619c7e6f89fd212f69fccd9a9975511bb8bfd1f84e624238e41ded61196e0993ea62169dc7e33c4c9a48a4007e60b4adb009c237bf44461403979944159778d0840f20c06081bc1c26af42668411f761f625d003e1eed23d15bc7547152afae302d4bd534e41ef59afa409c0d9651cb22fc994b2978e2e1425ef9f3661220a3f88197adcadfc41812051432a91560813f2ce52061bdaaa110864ff68893b731645c0ce9b41c1c7ac87ef5a1dcc3454077ce25f5e445c3e7a1dbbc1995db8a09ac8bd5c9a6050b68b7d949e8e8dd076428cac1790cc1c5658cd760e21eded0d25e6482bde626c21ac845c7c2767f480fed3241c0dfd412b002c3be816152521ac39c2d6ad718a6473e61f921fa05a047c84908c988c7d80257b83be63cce6948824f8ae49af67b973c6bcb3fdcb125c7add6a87f386ec9a929ecb18642631c689121ac96e0a799cd6dfb76d9ca9b375994e0bcf88920ca7bf8ac934771bb0d7e4298239c039fa2434efeeaf6e45a88b91b1e1a4dd305cf483c5741cc427dae96bfb86335cb1ef8ac2389b7d253259c13dd53d56aaf1354d90eadd89ee0fd271d790a7cadc52ff6b1f8cf07b44907bafc695e3c95a911d5e95c1e39be920dbf782debe892b055ff9cf60398cd7ff187edb36119eac29fc0b115b9feb85dea6fc8ffdaa9b4fa13ac0e8a3b7fab011163eb163b1d57c7f4ba4bf08f5861a5c9e28b5d04b262eeae2aff9592317989f7978735e54fcd94ab0668f99e1a5d6cb034bc67ad9e473d46d0667d27082535940ff31a66da490b155057421256a6a270c92732a2733c2d4b10ba7c2a161a0069f5e9eedb06ad561f362aa40a20bfb9cdc8c49168118763b681ed3700b495f046c6cec0c52d3914d4bc4aa43c5e4186bd9a739221347d854f3fc83ef50024feac5a14598824b202559f8016fa5f0bc5bdf6c0cf824a467561d1c4f3a061035fa579b333e383585c18f6ac1c052fbc0bdc6e71cdc3f906394ab7c65b4d7ca87c8df12e077acc04212ce706427ae6b0f5ba7bff7a0d5f147bb3c0aedba5a5b1f4ae2c684c8221c1027d3c220f130f99366d9b1fcf7e66cb82c9686132019738b57318ee85e4df4277fc2c05d63d63920e2de3a0f90c13b94ee3648ef9aa45ea137c46e3eba4d400d22daf46fc7bd20634eee3a1920ef6198ac4cdd2d296d8b31b24ff63b29886a1a75c837ccd40c9a144c2f9877d9c150c8be41ec586d66c6e4796f7afc0a44d6dba035062c3df20e510e932446fdd1878639fe52bf35a701d64dba058f6118cc8c189032561d5f701be0d72d4f38e40700c5ab675bc71fdcaf185ffa4474b36e94488e4866c3dd8526699876b956b858bd960a0cedbfa0351091a0f6ab16c1d415a08a806d68eb31cf822c7f702aabd0636a08829ab0e88c9d054a99fbce5ee5a836d6cfd113b6efec8afccf6fa9dc1c62590fc310aec4e8a768b375eb7c223906ac58be09068c77828c3a7665f3339dea6698cd3e6ca79bed7e4b8b0f0d3e31a66e5394c394fe222d30d265e5b00e2f414549bd63ff6fea8be3759f14c4eb43a041f65186a614e5e70f1e71df284329cfbd203041bc8104624972f3a924524087d8527c8ad73cb644b08bd0cacac0bf79fb5f8581c7c7a6d4cf97fe7e5abd0209db9cd5133b9b502c783695ca9f3f52762a680719a05a39447d8802140a6ec0d868386fe64238a8f608ecd6193833c7ab1f32d9035b184d41394ebb4dc1d4f31762987a27fce162809f816ebe7f96ef78b9a00dec64f04bbb873a078e96c9fc60e2a08a792fd8b0c52d5f40cfe7c1c546cb8d402b7df07db148ad32ce054df1cf47a34a350fd44676b58440babecd57df79ee3a9ab0ab9a49e714ec152d3f4ee48d24dda97a1864beb91736e6f35967c6ad4bf024ac967293915bcb0114fe8f6ff160a984969784c08ac69390e9f6033462cb8b42eb181479b06c80ad2fd281213441e0d10d66ef40fe050eec6cbb92a3bf3aa6385e737edf3a47befacae9f01f08b9d760c7c0daa11260ede2b70ae15bf7df602d0d9962503ebfa5c772e47682a4760c140109874e39c01687e3471256774db0e8d4002007941dbdfbd99075e79a4242cb525fc1d2815d66ad92e5fca9ed34a6ce276e5ef20555f3e2688b61bff2d95b53a4edca257a10f5727c6b689c41e58d4b2b001b794ad6f23ed22b03fe8f0edbc3743e264620dd0748439813686fc8fcfe730c202cb4a987732cdd0c46c520da5c04e6b3feea6284fa8fb6dbe0c085300e3bb8e45bc7f42832e6155533cd90b104f6973172614e93e23de5114a19145b95e46edb0674c8bc3ee5b343306367aad5510529e408e3d5dcc9e1102b4af324d2207ce19ffab7baac8d9c737fabbaaae07e7e26a56019935c984d7a5e386dff867022234b4fb2556746c5332e7ae1e3b8a2c3c6c6154d6e0e4ddd18117f6c08538c8a8cdf615ea5dd08ae7aefe844728c821e5f0dc58d158d6c9a8d0e170b428853b7c3cfd65214468b301dce672f10514184ebe3dab2dda58b5899b231fd37bad7ecea6102f94eea215e32ebf2829348431cabbc7b7f117d1a357f34e8357fe5b7dd016921e06c1e4e59edcbc0db6b33a76fd80baf339c6a1081f697af70ac7919ebca97d1b0e16f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
