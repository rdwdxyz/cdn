<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"474a0bf2219b0fcae43ffc211cd9e9817523380d59042d90fa342646b7b27be9f4402205fb695f6d65d8fb71731ae95e32b0bc6b3e904f10be1c6551c3e590a489a9bc682d38e0a814acbe30915960a035e6119627fe13eef34c00c98f182e4651379d59c3330f24fe89907de6073f27ca4f27cb7d576b2f4114c5364fd7ddee7f361260f84823b7dcfda31c58b49341f12292b5f015036f34365820dd8b4ed3f23d7dc73543290228154d9f79846c52831dd69476b241c23e230f1a898d0064fe08103ab75418e56709c1c6bb6940550fb54bd4cb12a7a9bfd661d7b318b3ef1a29a04098c5b0632c36ac7250f25d356742d90b537822ca94fc40ebf57d03f02d23b3681edd07434083d5e730e0dd2fe561052167a5cc8d804c3d425e9b2987e6fa2d76fd86e25e7bc8483b9f8569d676fa20187638d8a9ab3bf1b184a52a04a15cf1a36ae2aabaeef81634fe159d7fa760647c5f2e4eb8690c62493a1f40e0d9c5ad0391e33eae505ec0697b624d1d0f9d927eb62a392695a628277e7ddb9b25c7560b3501e63ee48c906209410bf65f8115a729496567e7723c1a69e5efd3e5fb87eb97264117063275b100a526f65ef2ac93cf07cc950e4dd0c28e470b854af5d8b9ec6a1f51bdd1005dcfbdd30a31db73621381fdc0acc28c223856b19d90ab2797bdc289675f31aeddfa703e139dc8f0799d68c157b0543f28b27a8295f8dc0820f7b779f23185e1e8781a74823b24fd790d27a3a97c707767c23553b68c19dfbcb1037f1f66c8a987d4e7e7f6f828f4119eb5403f96741d404e486a5897d94724ce9622fa1c5c269eb302bcbb1249932b25d338c8be0c95d53a65b0e0f22563c9a2e60454c41190f302b76e30db73e0b5c37f41231ab3716cac4583fd8ef5f76a5df8eabc7beed89b6b99aa094bd264a2590b68f80fa4cd63853ef10a366595045e9fc4794e556e7257628225ebf9e478e230ff984f6188e364f8c2ab59072a6aafb3699502e7e3e8fac30e30c36c7f16847d0a7d72081a003cbfbf06abac79cc89cf2944cb9363a7566911af65371b11c00362648552ebd4782303c26cef384f9369121cedce007c7e8f762496e88460f99938abba4fd83ea1bdcfc7de8cc05b1ee406ccf18f39e6c396f15d583a5bbcd1f7fc1ca26e48c40fa1af4ac9b8fb9cd7880d9e2b3da0c2af404d6e59be1fabd95a0d614618a829ed4c525a05af7a6e7a9eae1594029f8567caa037398bc0a1b96e2285dca9d8f1302215694a0fc3edc577ef8fbcdf1b5236a494fd6c77a949b42a174aad03b2465d127ab752e0fb60162f5cc61327fafd46a08c04ba279e71b0dede0f00c04024e6b485f1e7ebd6c3036f9c4d5ede4b8b79b446f5bda0e215ce0cf70bb24cb79228440c0410fcd4a548571cf44818cbe3c34afa0dd05620bee041bd79e6bbc7a7baea9f766d958cbe787182565ecfeb16f5232456a7cd99ccb148b8d3ad37197461c554a0ab7ed5cf226a4b2d4f464cc99d83bf776ee782cc254db7de3e76750bd2d0c77e914e9bddcc806d47a36ebac7b3db5e808b26d314b2e20db1a090d3df9f836e87b11ef1ba8f392fe5f1a72f26d837bf9e22eb3c039bd5fee0ec9f06a32fd8de4296e4d1ef282d4b21ac0ad722b0bd4262289a94a55b49f203b4349153c8966f9a4671e534cac4f2b4f3af630cc2c1b7e5711cb83d12dc9aaaa7b89b6eecc8e597949f40d08f7f900a16403d4c58996cc094bf9c4444b4c4b25fc91b3cc751c2aad059a5105e2564021759042a1cdc3552e186eadd07b463b58a5fe197b868beb6cb6aecbcd06d06d55cc7106ccbe5b3afe3cd3945823475802490701f684a6d2afb793f0cbc476ab40732d06cd45461d25e0b9827b5460b44e8a2edffc103cb9d1ff499e73b9d6e5f046bc311de9395168f0a0012a242e3b6ab1e4e79a28719b2474a2a8c4d5a128de86a860b0c0a8b4959114cd33b0ba7735314479cf42ae57cd6227c399914af400c5ea12ca71d9d59c70910f7fc17ba57fc8b705e19d0b52adac14b5fc3872acd62453f70e4f97d027b8ce202c0de5b572491614f686bbc96cd7aeb6284a74385b4ca5fd284ce1a8f58b8587d9bd400736f576e651728d652e5dcfdc6877151d4f7b9a95f59374ccda1eedfcb2cede7fdd00bc45c6bf1d8cd8d3efdab1b8013bd10b38c0912bae0428a41addcd08ef558157cfd500f5437fabe6beb20524f9cb013e73bed6f8623d9d8c7f9d2b48053458eb5aa7def58fb9cfe455f1b7a288577e17ba2cb5118a0409d72387f9f56faba57b7edd63e7ad6d8936e5acbd45a23d75aa2cb9f11f6522329874ea114e698b00e252b56b1cc7471f454519b929867454cde44c4a280c78625357c71aa4c410a82b468cc1e8b460e74bcabb7399d6499e856c961560ee7f09e8c979d11955f598a683bd5ff279f383b74eb80235abd6033a2912f5cc3cb18e1d0c8c823c0e82928e5f855140b2395e475e2210b8b271d4e3c931c888c5d9300ea8f77ba2bfbe5c8989ef3a6078a8aae845bd39c55f5b2019862d68555ec471b1f3f7eaae15c8c35ba905bf523d4d2a32dffdbd1b40a929b7e7ab22397ba83195dfb0bf9a629c80242f84205318f8fa8fe66eba7419bae07ffb7ba5ccb201d3c72acec6b8e604358f67099cfe1b8ddca8b3f581e297068d06f54ccf6803ff644aa71f6d5ac19afd2142507bdbb3d4ea5839c2a3b23f7b557e282ca893c8ca34c49c1e2984b330ffdfb8822f4138a54111fb58f51ae0ee822418ab29658595b38d17cdb4a6eec1b015b7e999a8c646c1c4d9b47612096a5bf416d3c46dd8849509ee969c8e093fde32a89e2175d621ff28879b8d2d7e966e30b56451ce08d646f03bcd2cb343b430f370e114120d259af2e0c3c04262b7cd4212a8f47500900ffb7ef87e079563218eef8b3d76381b3242d4aaf6d32694bd8d09a3c4bd8cd01468ca57cdb7591ed1a12ce56ea86de0feb5b0b1fe2d606a5a05ce58ecd7de6e4adc7ea7b017b941e39fb255d09085095710b7151806ebf2ffbd6d605e607eaccb71ac942e80e69565176d724a67729e023bb0f13f4fdd95033202eea6c70e1e4b9d17d4a3425a510e0ae6bcfe4857173a59b3a34f8010b3f75a46de4d8c3f99dc46e1663af8d1e0fb40479be763648aa91d352205d9e408c6f4f9cb67aadd01e45252e6ebfc9e1d4bfa5a5bfd02d4926f51fa8c97bca71169c751b94be07fe451a0ddf8b3381b86355321fbcfa548a4b4c8892debdf3265c1b6834df17b9bcf0496c6dd0a6b427c70506ffcc94bb349bd2581ecc07a47c841872d1914a7720598c0bb88f15d20360ce982d2d60a85c92a61ba2a80b3d52d2f70708898614dcf4199ce8bdea783288f910a9223cb12b5510a907612ddf62c3a4ea17c549bcda194b1fa0d837368413647c6bdd2997eef5863c5efd6f47fec23bbaef97b34ac5c7d722fc5008cda7af8c1b3aa372b03a97c09d8794d80fe571cd382f852a373aacf8f9b4ab6b8310ca5a0b26f806adb5f66a825cdd2c72b422f958992b422492a9ba43f731af0e2497336e3fd7aae181d077cdab3e9a9e131c59de9f9239d185f4b56cab30e223d3f362d1e15d8b3548bfc4e05637bd33273edf297f07802c94a11f36316743a205d0c9ff30ba954ad48758adc1ac4c39dde8f1b3e0a16e19a6202be0754da655929cbb741ab36cfe475a6263724c4f325bcb14a1fc64523559fa31cd54d8e7f65333134efcf99ad9360c456a41ba38f27cef744f5d5503a96e35807aa604247bc21723e0f74d0cad6a8a0cc5c363d9e318aaa5f49d2e233dd83e57e2a910bfa77ad1bf9473dc8fa2bcb6382f3c099dfcf1529150068b7ebd6c4d4767e72f8dfdd6b68d02c091c3c1c6d5d794bb3b317e4af7c8d87b23136d34569bb14cf9e94172c03dda4ac64117bfdcc22a3ba5758afb261b5fbd51507f8eb99e8429d4c73d36878f9549a797f694a71cc7efad511034f115deca894507879f7f9a5b19162d8593d77001b60158e9d6c201800e157e990efd2ce9772617b7c1f0975b2828f8fb4b7e2d3016c5037776e6bddb94cb3f9e973023c2191e795d4f2a20dc596d75bd5a514902ec7b208cf2dabc9003a5d4b2a46d15a24104feb4288ad473d2c13572c2558e9f2a2dffc5fbfa2010ad9db8e0c4722888fb727725bbe1e985d17f47e915c4dbc0b35c3131d02aacedb3f67c6cd1e296570f23c0dc8cc892dff5384fd3a4fc69a32fc336c17242f10ee3a444f2c609a8db36eb9dff1fde1d52a84b0be00f6aebb770ea784f76d5ae5c32bd7208d43945685785d9fe9acd03d89d007528c5c375ac528e3448093abfd032646181bf641bb8ce66149d0a79ff4a9bab5b96a4820c5e828bfbce1a1b743b571180064cd2aac5579f9041be2d4c32db40a727e9e6792cfa230988f96c9ed8ff62ec74da37b5e1407f1dd9506c3283d38d61e05e4f4eb3c0b1daf1ab87c1f2f1536d2c7a2583363622909407a96a0670f1f2fb33c7c64a3562097874eb4b2d49289169aeddb5d6470ca5712942c9eaf23c84371c7e333793e88126ef8185ba54197718389532bd72351603b698c0bccdfa9c4cb20e84bc215203d3001e2962c8b6eff727435deda61c457cd624cabc8319fd7e9e84c654a17ea96137e0d018b5958b5bf4e801dcafbcc20a75016b7309e056f7874516a943677e63df7fad527decdf091e3b25211e9df7c954120a439bdc9b0213eb84915d5ca57f72b8d44ee73b2f5644ed2e142c5eade9eb95b642f06ca5408829388001e809a869924286513fdca9d02dd846293eb59f59af713609e9237cfae373eb3ab85247138af05de2a42ffefc3f85100f135d89cea091899909f8ed6de9cf0a4783d0589bc1a80f20ed124a99ba6299b1a459d5dc74a224bb263fcf772ae2d52ba0fa480a302d573828d2b6430fde336fdcba5b1bf36289f1bc959f2746f36ef6d5a637e5c20ca140a7360ab05fbe40e7a3cb070a5458fe6e0a2b2592c72a7888d08cd0d769943536a1baf62b3885680b933a29717ca2cc7938738e11ca7838229bacd86c15bb8d78a61a436d25f38f4d4e34c4c6ab6fe96708b4b36a9e2dce308bfff3d89494c7181a33f97e7b746a5f515fe855b15c3b781103d100e74b26b4a6092c0cb13f0c693406cb5846725f52ac602259fe93d80cab1da3d64e380b594ee5fe88ca02afea05b868ad6e0fd5348ed25b5831db91a337b6e777dbca5c7c18e233cd9034e8e5465c4b7ce609d810597c7ea3d1cf11830744a5124eb64bd9d3f7b02b747012e5c3bc1b4243ed454addbe25cda99668feb9e4af2086eb397a06b093a6cad9b26ec2c16238c5bf1b63f1c7b9a9bbbc30c27a4b224973124e670785e904a8999b4c942931ebc8c5b97f5cae40fa81037733a7e83b12217c3640c142f6b77df74f0af79630f4bbcb291cf011795e6b3a9535677eb4126e326115b03907bb28596d065296d97dc254d2742b415070c652507d0aab056ac3b54561bd89864be0a6c98c0890a74e0ea976506ade9343898a0b3503c0f561c35cd03d265e30c2774525569d7e024f67a4cd9648395bca46a2eb2329ae668093e2bae3021e3f66cffb903b534bccd0a4433c79a038c8be6ad7a67d5663babf437de571adf2d662770da6def192658985bf63d3eda457f83253e207f4108a2eda94c20856a0130fc9eb5cebc07c0d9da52a5dba16cc89c2b7fd4bbff0735fb706ab1955b3786ecb0a6dfa3282cb878c1781bc260951131b66774344dcb530440f52f2cbd735bcc9d19d6ddc704a47c17653083b1bc1a1eb9f27b7fdd22d9c4b311ae567f42bae26850dabd2dafb82baed1005443732d75f931fe9db7c2c02efa8f58a718e9bbfb232d155a2ef6cbc81f88e62d83a12ca83c62c19c72d59761949e80aa5d2ab96b96a461c3226886aa4cd3d1abf801ae5bd104a139287b1d7b2394e68f5381bd64834bb3dbe8cc5af3e65c5d85436b6e9a1fda5f6e8d6b71de72983a82140bb9dae30b3e690d66f30d12e7d538d882a852a5d02d6e819fa94025c9478526d7fe7ca3d9835fea8ee093d192c0affa253d4aebcd0ebb6b3d3bec8e750212062797c39161eaf56837b4f06ca2687c61f73058f4303b833d3308b04f2885adcf1874e628d9df1aef5dadee820994bb56f1f1ac05eba7fd2ced829a29d67d38d0228e0cdf02a18cea5a8ade6d5f30a70ba5c350771867cc83d983bebed24964e80567fc1e26063d6463bdc592839b2782a55f3de2db0f21bdbd0f46f61df1e4f0f20808ffba136a8569683c7fc7fb412a73081aae4d216e29a0c0f4f4ea72a663bfc8e253cbbd52630a178459ac76fbb22a608ccfa674a5c367f8b4b79f49fbd80e210642cea41d7d14e6d3927fb461c0ebd2ceca62b3b83b1f0a074f388dd4f003fa7df8ce3b12d0fffe3d899879670d17edf2403dc6a1da1b1a97dbcaae583ccf4d2904ce67ca621cd716bd27ae78d2829ed3abbec41d2397966cdf819fa5edbecfb4737095ff83c4eeb9eebbd2f20189c70a9e2b84ba6a40aab1356a30ffadcc4184a707dfa6cec533fcc1e45ac111f7a9e82755408efae63546f00fffa766bc5809cda181cc050ab193f590e10e1a86941737371882f32ea6970936ba884f44cb91629a0d47aa2829d6ad608bf6790c914af78b9f3b739ec12bdedeb489652c4fdf2f0c492819310198e3ade676795da96d60735f7d7196eb6566d6db63184bd0a3580e91bbc510a7f2314683afe73ee1c716cdbc17c22e0a88502d5143e6b11d647c669980ea7050298acbee0d4c51a0c82686c761f9dc3434e1a9799d89aa7f27d3eb5bb6a20d8fae1ea13d8c3718e2100c11a8506eb6b8aa44f149873dfe78b93e57791f0e9c76f6744dd5f09031aefd27d30810b1cba6f7c578be182466b1be80475997fba6dbad229c922dc74656df3704a3d12123c1ddfbc31b1fa89d0382bc2378f4364a0d516b555a07c6c7afbcb41a39442ea606a3f491637bc33e21e97853272ea62c1d475096ad906bc074dc6df9f4523274b41d54084cfc35a24021c93a613ef9c4c2e7a555f4a4d173693706c20030ab0c35299113e26f4024c77b14332f93e7192d1a8a1b6509c1f97c540dab3536295b88a791d7558049e9eb9ab2b2e04878088dc952876eb60b79d19f198a1210688c4f372584826b55b661eef35e7addfb46af3bd577af47c3273036e070206c40e35063e1deb47b2a9f5d27dea4dcdec3f0760bced25758905ae1b89d3263d311076363185f2442e2794d367c8bb709abef6a80e03417aeb0d38368d0697baf187b3b45ea870e6212dc813b9ae02dbc401d09dbb0d0b9f6e657902896a1307e960bb38a0dd8bcfda9f4e5db672c7b52592cf76d6965619907116881abe97e0bbdd097a952525cb59c6d579beadc2f8a2f0ec244679e0940c2116393205c91874afc1384f7dd721a85bdcdf88199783070f5cc099709895472e6f44451dbb3c5b4d6060b8b500133de3ffbb32c72eb594dd6c8be21ecdccb9c86d4a9ce5a822fc8eb814600ca6bdf875ff1837e8f22e7bd0e114409f506b585c6b8d4548fe21c6db2b892eb31cee9dde687232d2df34301ff6c64ff30efe5132e7e5e955c8b135c3c21ac2340f6a383197c11b3de9bc95bad1565a2391995cb3e1a983d7ea006ba4accf2f97f6ee40a18b19b8ea498a185ade3256d9d0c3ef6967fb17d47cea00c107bb5bf1e3693fd09162f259e6632f3d8766b91c412809f1e9073d1d6f00437a3168ff83e58f8268ed49e485dfbc3e1800959e1a44974307995c2266a0b2ebe4e35983c71e1305f15abf41c8cbae33d86e9797bfbf086930d04f3a2e8c7ba87441977f8a1f07d8e19c4764f3e4bb48a744ff18aa24f7ff047335b4d9d453dfaf33a4c5f3f0d2abc9a1385d7b5cc55559a5ff9fec77f2226c3f009ab3f45ad576fad8ff00452af82e161ade9ce1835f4ec4d9a4df7dcb47df650f5dd78b0d64362186448e513f5388aff3560d2b2079088104c7ab29d08a3594f516d05d5eae90e7615397afe0a7b80c91490a34b2dd3e1661bdc2bb9071b21404f98b748f6a2f79f53613680fb595a451a679b0c511405f8ce293f186df6cbe488a4c7c8999429e4ffd701e768bcac77dc8bc701109eb834eabaeea9c8dbbedd4d83fbf03d04862491da82b73b3ac96a47b98dbc8936d613e2fe0357837a7ff1e0abfbf030992191751d00d8c7391b9795532f959a478e95ee8f9743fa40bbfd60b80aee4448caa342c204eb5ab14c194786b1d40d611fb9a7b335258000e6e19badcd91596c15ad2e1b74640779693797fa36de072e00f383772f4619dbac05e4086d43eeb6b516a847b53d6ba599fb568b75c0f9710de353753e3f73268a240aa97403c966454b021d5bd9244d212b3a6a3fc1226309fd9f7cfd2e55f6138b6ca179d8d3a60758f33bea1de44a06ad94b33fcba8c1636c83b353ef4b7685c15bf20ff2b54e5bdfc4d8faa077780c7fbbd23b52fd8e4ee56119c0964585a5fc3df37e04c240980ed4b212387958a861949d31fa90c0de2a75668924be0ce70ea6a7f81e49c2f6657659deb51fca471e15cbdd19538b2680fb9d7737d22b3995620d7f43c47538bf641d1a0549a82689213a387b4429f378406dcaf4cd9652fad389d8859ceb882e4279745e39df44e0fd7a4de9031f812d1e7bec5cf4a53a1d0b8f4fb91d574ef0facf4a3265527b980486b5324a348297d0f35ab5bc96702acbfbcdd2dad84e5fbf2b0bc66efc0d5e7453d9c82a37b46647e492da5421cda09bb2409c0db0e7b1675a5530cedd6e4a5de4abc896cd52d97eaf8da745e36ad7bf94ae8ef6e0ca9a37b0e3b92f3ccd362be19378a39c6a2298e9da52e2e40a25fb489f3354cd58ffd7cda2037c2977c7bfd10307a4582cbacf1add58fa7fdaf3c7d253822b43eeafcc548ae2fa9896291966772ee54c7dbfe4212924279fe620efd8f896a23fc9599ab694c0fb2f75c4fba2dab0b5e76a67cc609e71bd3b8ad73fd54f7acd0719082f968206f1e551878d8f0a07ce0ef39f149e93e0da784fb169db5fc7b290d0c4b94021b11aa964ae832911491e7d04ec2c9cffe00e18a9f6eef57f3caa5a983de8568d2b09ebd7d4825c1b41dde3d9053ea532d1cd6b4c0deabedc8b45e03795d59363183312b84d2400878ab18c5acb3ea7c61c054e0dd43bd559069115b61e23f1493c78acbb4b1490f44a7339f7a5d0234833b0447ed4939b120fc3fb546207cc328288de11f34eb9ba9ab7b2fe5dd5fdef0f6f2580ddbdf608718260b42132c7e350cd0a27f04d00e96ff8c7d184397fba1555279525b08140aa7e400d8a5e551578f7897263b69580299f4a22a2271066ba81ec686ce816dfc42d4f252fabe3d33ba0a988b2257d2a3799e57f7ae49e14355c8800d8ebdb3d6b63ed8693b1a4a5fff4db7e7ffced1225dc9af8a44e283a0b7e573688400a1c0e8c4b9a4558190ba7dfc4196d2d591d4ab8dc8ad889175a5f803af694c56853391c122e1b3621d5032cef056055c8d8db041ae3e1779a854f75672f23eca8daecf66205c1e8aef1f6d114fe7dfffa80f2956891c78a4fccf0dfd1adbd2c4de46bfb9820b22931b5a13306aa98c57608611f111b81e75fc95d4e004f9c060c6de028254ecb854a56368d50af49ce26ce31c8706d4e0b51d1c71f57c59428a6b8f29ea6992d612a0d0f650cb7d7011e251ab83215b98cffa647de2479a5e168a4e642db69f541b0e9517287537f29739b014687524607d0d2823129e36c4e0037e44f87438350c2f4cb10b4be66f919b8e41be2b863533f1325b6d638e47681c7ba41aeeca31c20069e8c6e8b9bafce6a1411a8821863c69756fe5495cf96f23fe85cd763e7074db53ec496ec432c4c5ae5d73bc765d116922e0430a4000c8214112a3784d0e20ffa772ae1343c1bd182cf7f10b5a3ba9bb549a19a4bf84072a807e1eec7406a494d5f7511221c3774cc4b24f2d91dc86a4733b1044bcea43ba6690a2f79e1a0fddccdbe3b0a4ef64ea24bded0cc1229cb86eb3fbfdc94a0efe4fbd2fac3e3d262be7063517143f5751517dbed7851c46e2ec22258811ac10192e4b662e391f3df9f3e7549e6eef41ddd625bb382ec8f3a300535de59402238df52f7f24bfd2e1d17b2507431d830c9918b52617e7b862071f13c474da88d7bad204616f2b0b93804066c352f527fdf8d2a2bc4d5311a0dcbd5eb7cc6d92a200b3b2d7a236337da6f323639459a88aaaa7dfb8878e86c2ab2c90041812bfa084e25f4739fa78600e757da5499b98fa8bbc7b9447f81b52dcfb3b828593b7c49397168a2cc256867cdf04889c1582dfa0bc707f7da8b4cbede3aba54002cd2bc40582e9a2a145f217b7c540d46ad7d148f33a1673629bcab688ae891c74ad230ea21c34779a137af9c1683d0ef45107ddae383e92108d6d3299d8fc3dcb41b574ae4bcb505c8c64007ae1c1a9d87255235ed8e9e579715f4a9e7bcbb7c6b3a3cd85b3bd6444e6e1fe637b7d436b06b2d35d71905679cefca48ba4879e16331bc1142b0d9e0d386593a7fe8872d43050ecfc2592d0a4ce1b8decbaffdb6aae30e01691e4ccf945c9f53ced57cfffd3ab1921f3108f3d071a21c146f57fa4903c6c8aff36d2c6d3cbac9abc6f41db2ce9fd94871aaa215a498f485ace1913a9f2a9586d2bb7c4e419e5ca70a7255dde213378e49f083d05369890b4b9bc3437d1e3b5df15dd8f5789eb35eb32572665abe847cbf46776b23de9958ffbb09fa08aa59f7c20954c6c3006feecd440d18daff5ea7616e03ef0b7072f71c5518b956d4460a63f6701e4a415af3beea6b2ee7edcb09732a70a25d9cf5105f8aaca5f17d7dd8a48acab78dabde52ac34e6c3d3ed97bafcf9b577c4a8ce08e2455759f2612b5f85782ca03b5ad1ad519ac565858e0d86d6228fd642c79810ffacb50a230a5b87b56cb2e7d4698ddb8366de63bc016a6102e16adb50e288cfc6df7051ed1932fda4a2e287698be8d0bbe2cd6f8276513b31c6b736ec799349b0159338dd2987eb6df87a372c3b8e387dbafcf4a390b2d02dd407587ed5888dbc99fa913ec0acdc531d0af1f0023ff7e87c37e5e554792680e8041af0783a36e0630e4d184c37b622c8474b24e91dd17c2a18d8d71343e8a71c2d49368456d2d57da2733df2a53b5832df53744039e15c9b09aa3645024aecdf46e8091be602fa63c2a42230cb6fdde3645b17a5608b1488a8ba8fc04168d87d0c45939edb3c955e0a13f4d151caaed09d7caf7064a27229ecde2de331e85dc3f522e120e80b424709bfdf2d04d8982fac476cddc86dd078ae8fb3dfb06a685eedfbb42f91dd13fc13e50415eb8b44a480da9686f370e409f22cf2c2655d421e6554b9ab8760c7c1fdf37a461fe95e147b5f33c1f982e7b2158bf1e5466527fa858762760e55da4f2bc34f50941f4eff8d1cab26ff8effcb283848b3979cea05dd8695f4e8b85441c2da986d8f7fac0f10cfad5b4462cfff499d02a28609f62fe157d14b233d1eca24e703b7f2071a470d209923deab57b9917592dd6be9a5ee2ca75e7401df2d19fc3af4e2273a2d65cf6a6500f2713377f39278d938688aefbca5c8c90d88cb8deab55aa0a572b7ac358056fae12cb416bc167e04640a06270ed74321a206bcd1609dfb6a6c667d50000ebe14e862247efc29b8a3ed5b71c6fa3964d761a11cff04ef3ef39478875db7cdedbdf8225d760732feab58cec11d58ce73336f430b9b9b66ebce3abd5ad8da49b9e20ba266f029da23db6f29b30e5e951bc43e1f2663018305ca92cc1c1503273b0fa840ad3ab62e905d64e5acb0bcba38022bdcfc14729fcbb0563b5b36d4e8427b358ca32ae956b12b92cf0c5c647a14596e7db39ac951f91a061da3243684a44bca62853703896822eb2c4e236759b8bb29dc2e6f18cb63d6f9e69f2f2f22b65b5216be7f0d0e4d50100ed1e3e053dbf7a78bde77584071c6abda9072e5e15e209e0a29236e66347b6d56c31e81f5f6b66aa7a3fb7b000b8ff18e694f37a5e5e2ed5cd62cf10c769941c4039366abe911f4ded0d278680f78264069b060fbab5a80201b85b49ee611d2ca66e26213e91f139c39c629ff56ff902c479b734d547dcde351eedea77fed6df181c391e5db59327a49eff7326c4f74c09af4b5f5fee7d16eb0d616cd37154e86c6f58e2f192c49ef973888a64ad934e6aea58c23441a9311771bc8cfc44d43f8c3149d28bf6db159a65c7961a13a1d2dd0157a4ef7be2e3effdfcb767cf204b58b325be728d5cf3c4c1709766214fae041b7cff92f097812cbb888b0f639551910e4e66cd5baeb6e1d93c06602a82b9dd48f59c56416a3383f726bee487944e6ab3ffa532a8571d6d0b68531b39eb056b8aec12c036e423d8abf361d1b7233e350c8c480c9f65973be8e1146a9ac83addda3d3f2069a6d8f279840ffe7cec3f55d1b735851bffc14ef26453c9a472cea54ef1aaebdcb193e49bd0a2b7f073fcdcfe4cf2b7e157726db415f1a28cc8f3d5d321df3e660d85d99a721e54394d8b03501f0af54f2f785c274720e1d12b65fd3238b1383c0cbe8cd4c7596b0ed0f205e366dcc78ad84857655dfa2bd7707a271806c09ff6901f50682c8f4153721e462162e97263036725c0ded174fb0fbddcc4fcbd43dadf382059209e50362643cd3c4d0561a8d61d090aa1ecf918b920e0f68b1b4ef74640b31a0346bf28cb9d89f8b467379e7404210dbf5394623d11893d73253b96f3a153ba2e7833a436b85606bebde1b9700a25f886ec975f4354e397d08678c0f2602e7822267a3ce0430bbb782de9787c571faff2781fb0cc6ab4ac8f0780e9799c5f6dd8b74175c0f12447dd0c8b827c6c91da8a704bc4921619d50ffb8fc480956a6330a7214832f31e5c2ce856c5d7aafa8af219d237d4e67b4c7a86fe4aaf28d8b51641a0eb015659a512511fc5d982fe415ff3fd9c88c11a23bce091039de4b382547a20339a305fb8b64e9ae4d6db0b557cef0c7d16bf21362f33f570849501b843eb6f78b3c8e516b528d2e5baef96c3e4307b00c6554db08b8cbd528fd1fdc2edf082c1d62e9860368efe16307ef4f8020e8e192ede12f85f4ccc8d2080395c955cd1c2d456d1184a8d8fff74e2dae9ef181c4527a6268306d58d291a141d2355076c74d09a798cb2101515fd7c57c7297e70acb57003a82a9598f40ccc4ad43e7f7280da9dbe2386d6dfaa5fc61c1e6f2b68b01f0fc03264e5a87ca1552e295dbe8961929a61aea66f70746376a911730cde479fb8ce83e0ab263f156d90a4bde18c58453c621545a308dd520f7b2e59335611c9a728df720b779c15fdcd6385c69d934a83ca780879b066153af74db7ad24afe62c7869596abe47b8ef391d11fa4331a118c790636c1d3f8f108bc13c098b3691a62c114507fbf450abb3a2f1a651f19b150d67b3227db639037d5a5b52e99fa62585149f8b71767ba5b305465b2ddd1c4d534a076e62ab9b76012ff010f837fe3272f25a6230dbb01201def2787d9737644d5b59a255b1919a338a1c1627c9f20dcedc65b129f8c59c22c22391b3e540e4bbd94b3e0508a39100f8c96d8a5b44964676ce778ec72911c8ecffebbc1f4d9837551cc22fdeca3b687840e63705d0682a54ab6057d68fa6641c34d75952aa203a9f04c79a617f421f9a8bcfd5cf228c411f0b5b2850f1c3e1e0d6eb5fce1e463ee1860f2f6948243c29504ea1e0b48645355403c45e54f99f0565e92390a07ad005d8992bf7a61d9c3a0218c5dd936375869acec7b3fe830f2ebffa1597b59f5c3f320be55f3a163497524cab274db02b6fe53d6f4fac687f02d2edfc697b654e44dafccaa5fb3fe85c753148cef6f0873a0f7bd89d56e0f5973196d7e0c38843d5feb25394fc1353ebeaddea54634b5d856d8c6515c3bd5a0f61b3f1f4b102684c39e53b4a2bf42b6e164811f70a0f2d7fb296a3e337cdc402431df4b4401802a5da6588f13fbb18be93b8b0afdfea97fdc76d180dcab190ba91e434f2d2f9c37d28c714ba55e89e5d3a5820b24a1a1b984dd67916410a3e632df60a05f56d253c6c24789adb1faa39582df72c1e43d867b1f272e4e6110479ee46a2c17f4f80a441971f2a8e3564958a88a32093667914aaa945f30c1cd747e0924a24f9ce3ad7d347d8d99a44dbc5734473c88af85e9cfc522a0d633ad610e5c07418ac79fa9e4c3d7ffbfdc276917a140123576f646c46f598d73be12e7cc7684efb502f8b9b8cff5e5ae84a443bf095b5cc7b17f3f105465394b342ae6ad41b5e329783946b29bee9e6ca1fd26ade50463b7e4c6510469f1b492a4e71d751708713a690fd209cc7d66724a4d9100527f31a17d47aa2fef2c1f7993a29b146b506dee89c04aad88b45547e19d9626d160bd7be658a7f58150eae3186c1ce74d7b4f9a9177148c52dbe48d8db2b4d9efd9948e05811e1747e68f89d34de0bb1d9a315c12a1c73d2f7247e69afa6a29162f4c61d25561545b52beaa3df769a38ba88c01a8750bc1489cbd318e1a861c241f00146f901519f51bb868b4bc2118679c3c73bfd0cc97edd6ad16a21599168e7f712bbd111f555fee0c9dd3e3054da7e57dec897aad0a715a1f7eb658d0b33ab64643f8ac65edaa2e5dfcd5726ccb9efd8fe5d7ba52ec716c4160f5c289e55907a4513ed042ae2707546d2954ddfd7e7250d6a00a489a1569218f3e7fe0492ba930f6efab0f04f8fabd0e3b090364784770e0be88e11fdd7427f9af4bbd587ace7d6c8327aa2da994eba684e4b6159d587b3bc258d8e2f025e23852d3ca1f3a6358f2331270e2ea4424bfba00119d02cfeb5edc7717914de04f0ac203dfce35b15f48d0c82fd7a591217cf5347b20a4ed9d2a15442853e009ee71b5dad1d42020b9fae03e9b5af0fab8574ba4a68dbbafc80745c6d99fdf71e00b976da1a2c4b629643b807def2d6b7dafb2b821455248780fe28c00f84b081756b4ea002ae4f16c81df032e197efc9df6357c615efceeb5b952119d41c4d8a3cb96c63bbf7c9cd2148aa13838242d0afbd5dfb7ed11083286abdedc8aaa4491fa7582fcf9b1004d24351a1d8da4d48cb2e0c61d9ec01b26b37a969d45301ed9795ece90c6cbb7ea4d5efa09bba6c6db51077d7ce2367edbcdca947b74f0656e0b313e782a7411a318840564060a03db16a2f27f4a0089f703d140d65f79aa41b769f1ac146d63f7056732bc64df69873d9ae86ebbaecaffd10c2d8764f7f8d58515a6084ac7b7d3619f4c256f300d611f01c0ce0d1b1df902b5ae7ec3d08c8f03abc5b13d2f6994d8d361ca5803f36f42110f6017c6e467721afcb210e764e263d30168234fe89ee90d02958e8044bb05f57fc568ba88be60cf368b7e15fce271c8a9554ab0b4f7f51ebd61a4b54d96b8281803b9ff3006029433e8b981aedae6dc94b9e96c9e5216f4f9bc911ca37e63e179d135a9d4e523b80c89e524943f69b2bceaf1678bdf638c5d261d44e1ecbdf60e4a6638a8b2e485d049ef30f260dafd312a26b722726d0fc5635b76a9dfaa63edf698eca1e4a3e6436e99047512d8a6c820cbc5ac98ee3584a4e85927e21f1b24c58046dde94b8b358b58a280f40a1064272b9e556391f3d7c9273a99d1fc511594a1763a5e93744ca554d5769d78c738abce4007f816885c8944734ba367af9593f14e18daa17371ce879e7f483c36c42b41a6fe565e50dc708c8f99cbe4e8b418f6e340d92c57534f011ce99c9e0d9ba78f707fe493835bbc62ba585754449ba9d1e684dc387d6e6c671af337d73eeb21bf0d50aa274dc6c6de497a7ac607730ede8c612ccadda41654bd038c9e0609991df4e2872b260e01fa74b117cc64ae07cbab1fb0e36831823c110b303dbd7d677e02f1f291bd63856262a9afa21d7110805402d8ba6fbfecf751839967b50de00d29cf2ee249582abcd63415c9ff5e63d9f4825a0047430ab0a101542cc621d1b32fb87f5e81ce0b602fc0a4a060b67e7e5b8691e554067203399c06fac08a84e0e709e4fa3fbf2277d38f8d6b5e3f8fafeefe1d627d50d4043168b8a12efa518fa4e20af3246ee7dff56a5a228a26064643efc1a30444e9d9f6951ae064f9462cda04ad07ae4973c4675dd49f4d9acd7bc0b265939d716c7a112ceb5a2135c19aaff86cc4babe2a7a25fddbd065163da962dece6c001338cd0f61b8caccb518d9462ca2a3c62f78a8cd9ae35b575aed7b26f6bfcb92263b0811f5cec62fc840ff5ca3580681177af8f4b1c70a7abf34703137fa2efe26752eb6e00daa181f3999edd14163365527d4e9295213667f8caacfc28b2803ed0cb5ddc31296ddb2dbb4bda63bea6410253706f1ea9da5bc7c3ae327a1ab75a3a8c012542e378a203a33f5738defc40d18258323d6bd4e1810e88382cc4b76148e4ca7bed5ed234d2aa629b5879e7da938a8ee0f0e4469665c9d8ea6699509441d9ba2a0be8908dece451e1728740f6a3c20ed88ed15cadc5e9559916a2fee60a60fd23121301c591a24a40149abb778a1c00b8ff3c0a094fea8432d63001da07d29408416c11bac42e14d0c250c4b873caff4d9cbd082d4e57676657053296f602fa23ff02a49e99bc064a88a79c6949aa691275781922633194d611cd3e2c3871a168221acac735e33ea3713e8019c8f07d9a2ab4f3747b6fe7723c8309da58fbf358f0903093b05a3915dcd9f234c904dcdc4abf3f5d1f2069143a9738373313bdf0810d49e923e6c43e0253bc6b2e8e8c8c6462e0e24845fd4b2040173584eb5dfbd23fc391ec884565db07cf6ae1b930639bb0548ad1a619edfd1f488f09d93e7a6430dcdf62b5779f453de207c203a7fefb714e041608eae7abc176fb31e37d6c6f19d0968efa62dbd8bb3a5704fc4bd0732457b676c1c8bb2f751b1fb9d8b0103398269ab67369e22d2bf9d045f799f5a9005d1d5fc214cda4e3273a75d3e8320cb3a05acc673f84db78b62d1898173175b20a0c31195ab77480855442196b4718b96f6c0c22b904492f61e612b34ad943acfa33154a0712184b72bd3b5f2fdd8dde68b2b99e1b1f93cc9ccdd8cb4b8ddddf17857907f878bdee11cafcd2e56b476946d785ef79f197122806c48f7f306d55e7324e2822d81b1657f2fd5788a8e2f78fef02f229f8b4f7ab0e0af289d932171b58beac45b7340af5532f5811f44b2e57cf96f3bdf99e0884727b167427d4aa252da6abe49d47b6fad711bdea76b5c5de7fd81da54fb0cfbc86cd9bd935beb98eee5fe3b2b495c48fa4efd141d9ab41a5a7912cbcd7e470fdaf800d9d29907d26dbbd5513a31373b3ddd2df134bbb11ee576216767bd9ea22a62cf62229c76305efa5d4cbbebb090c9cec82d4ecf6f5a599c5596124b0b117bd6ff7800d47164a0b00937d210f871f6c9ade4d04f2303d8348163ce88fc59aae7fed3c6267f4d7f4bf54af8718969c15c6790a6fbfacef6ffe536e275eb6f3b2ac20ced7318c6c43272d03aa081613d9b49343e2ce819e66ab310cf3b650dd4171e89af589aee765ec1a7d30cd9545bc896ae98806b8b005b5b247a7037f7b34e4415a425b930585740d143938372a813543c25b983db8286053a75d85eebf665a8ca38c4fa7a7a201c117e2f37ee732f70778d374a726240ca3d3c5a483c0a7895dbb5cc4d06ffa1834a1e2035c415e0ac24e6d79396dab41cdec0df15e5254d823234d9b68f8a5da6e965cf9065ad4e4d13c78c90d3a4f323724df0460f45b3e18e089b80d10f1d06e2d20508fe9d6e3d87c47d86598326e011d630da9a8ce32cd09a0b3742a614618125bacfa3d246a2dcb9f44391eca35d5623edc3d9909ac08246ce4591a649a8d2c5b218dab8c2e43c6c58a07c98f69849fe82c2355f4596fe6c67e2c789847575cfb9847b58883dd67f485611ce90497a0ad5d960c0829aec0cacf37553aa78d71adb115","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
