<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91475355f643fe5c67388871347122db7e381382814febe11df90ab72ba6b5a7209ba609af68fbf90e24c8138739771a28be00f49b3748dc38e570dd944f49a0d65631c353a7c45996ba376d5b5d744ca5ffb497098c91a5e50decfcd8d16a86995cdc5afac7951bc925c24a5d74ec2dc56f2afed6f580963f518bf00e3054b3abeaf00f151fd3b680fe7afe2a923f32ec158152c9d66fb1497dab0a04ebe12894f16870838527dc4bf811bea466907a37b36b126c7a336f65d47977cd59813b59f09a77a46ec4d671b7d75021f422cd4692539d54842fd4edcc1bfb76a2c4aa76f2c827ffe958314a350bb657eb453f72d87d93b6ae5bddbb94a4c0c180ab17d46b93db25cd9d3456b358ed3f350d2f74ee3d0c9faf35ff8e3dd416bceee6eb4bdf9808fc0c55f54fb2babbe5799ef7ca6669ce06469fa1cce7f9ab86275675c60350d15ab0fd4a28430249c825b0064d83509d4688f519f86b5002c1e5a0d0f45778dbd9a2f55b7991fabde5d066cb5ce12d008f48103dc5a99047ba132d0554e1c9bbd0638b9c01f7d3ab19f586dca76e2be833be6f42917317f15c629c2d269a7fcb08b9e2c3afd3821da1026f1eab3f9bd951490eda1d5ef1daaa7de8ef85da120663b4e975d036dfaeaff54c3c970916b67f6fc2df9f568a40d74586b874c1dde79d029a8c51e16188046f6be8ca4349bd9aff31d3ca47589911ede00c5e796f0d50c629bf5d6baa54b46ef7c8521183603148a2d544d07ddbbc0a3d552afd32a0a3d6245c7caadd3b063ef1cf92d73eadaceeb902ffe02d5932938e54769863a0740e6875a781a173c401e82c1d0626327e340479c2a9c46c051ad7c0ec321d199584fca9e270cce644886c789c68ad684214632caee9dfc596be1bdc5710cce8d3061dd7a9d5d9d128ba0ab29e61bb48cd1e257db611740111bd9164b95aff701c1cc56cd93e617fc9a837ac35ee40319a48862e87b6d7aa4b3cf3d52abbd359b6539701e5d4cabbf9bdbebf161756d369630e3c2ac170826fdd873cb056b646b6464db9da174e1c8fc3fb841f1b9f09f2f89b69c9e32f8382e2637bf969897e90bd91c4f040dad323b44b793d6ec325134d740407c9c8774c1aa950f56d803774512444d1f145d924c4f755d5291a8110924a770298ee92e70ba57ea711f7c175ac40af3fc62c80eff1c35d581c1de9f9ab60e578bc03baa931a0267b1259c6b76387312836b1c54e8a5d939d0e3f0844eead2f588ea3de639a6269249e6fc8d8a4dc6a0eaaeca4b89f0cce6ddc517edb33a4b8be6bb53c857c9e4c8535f3d1fe2b2bbf46b0704c2e0c646050e80e3b6c92f60027705784cbc3479dfe9789f329c2ab47e1e04b252d5f3a4deb6cb720aeecf51c7df16d5df4ce9e5395ab001166de8109f1ec1b370d08ce6e434c0d8b2be305a4a879af1a77fd523855e20ad3d0ca5cf8cb32cfde6c56ee096efa49e54f931bc899a3e68cf2cb278bc328fc8ae34d7695a6da7900045db8861c98c16cc304efd9e4601ad11d9494cb894651e85d54a62e33634f217eddc8673d92c21280f9ac973b2a3c1bb66d97e83bbe990be14b9dd54f62efa788e5f372a9b583f7282af68f2a439e5af87b368a36c682a105b42c467147f5d3bed2d8796d15b59fd2b71f3cf903399b195eb1b7ad2a8e13ac1ad9bd4d34939a91be43266518425693a526e6c84b3fe00a62a5b7dcee22d6ddf19543955ec22c70bdeb0c51c8d2a56f7ffbd809319221f5c90f18726790b626dff0b5c7d1171b3acadb638c81c0d802dd4fe7a3be2f0d75491999c6610ddac56388fda214a5389595901bccca7385cfe54973be7b817ae8636dc6d313833cceebba6f0c3787b9d951b9a513cba21bea828b2d0896d285797e0abb21003cfae28bde14b437803eb0b6176f4c39f38ae5a4d47f450f2799c7133c0f99dd536accc6b3c500e4541244677719a9de1af96dbed9a704a5a36c80e29f317554894a0baf2b201de55b28895e8e1c6578d576f6ef08427183f2f8d687292651522a4121a6eae1265db4f425398b2ef56ea3e58b3f3e01076c8bc87cc7e4998616abef2b4e2cb5c0fcb611c74b1e662ce9d61e382840e7462aa7bec2029445561e9eb3d531e716087e919275518c9029e9b2549eac0680c03a59a80deae42df5d5a6a0470c0a01b45ae1bea149f886cd5e6e1e2b4772283a012a0cd802998ffb4b402ffcbf46de62def23e529656d507aa07c320ebbdf931df371747e60b7c8d1952a49a5aa97a593fe9d77aaea5a67a7476d2b9cf0686fded1e03e4b86535c3f7d11c2d4101f07144cc8441d2a26e3f0ca0c13a4835ef496467cb1e4cbf32a2a78ac17590d02d499695ca26361eeadac49a5b1d43a4ecf7a6141e8d6460b0d3db84f6c95318f0c61c2bedfd9a32d6280a3371111277cae340cc098e02053e4ffee30344b5f37a2dd630d6e248fcb569fbedeb7ae0016f538f9861925735b0a8aade3435afaf2d1cce0ffa714dcf93277d34b05d1daa30e1e3e58b65460529042cf20b5638d5b7d8ba52bb6b188a45cc514ca8ec5ca905276a8517c779bbf26f6965bcb485c217b0421640cb7487c9bfbb6865c13772ce52370fb50d70c54af1f45994de0a1b9da5063e04dc2bddabd286a2bf40247768d4fee3db00c73d0bbafa36fed20f27a60cebc0b378304ef918c0e98cd541e9f433a116b8e2dce41e8a18f1576fa174f983521faf52708c1b5629ea37288853c668b845347ce16f0486d337ba1047e68450c15480da2c9bdc5b3246e62823ef5625094c32128c1420b642763841047bd3a94555c0abcdc15dfd0c5106e720b448cfba1c671aa36d511839e313262b12ee8718873cf9ef39743b1ce9dffb3c6abae0f304ee41f7fbcc1d58d25363f7fb4db4c27c8706ca6b099fa3f79d57851d45324f24f51b6a186d229c4281c0af1bff5bc546e06c87d20fd4389e9cead1709b01c5395505fd6e0fe1ec09485a87684319c7ac300cf0cb5ce61a15d41167cfc7170b54bcf1aa63f4ee5d3da2a8d172b78ef5fa6deb035fe0359eeda5cd1d65264e7ea76f1e2d3ae84910459c6e71e1d32f29a64d800713229c35a56be13d5c01c510b12ee35a52cf71aade6ffc6d45303e0e553b2a214dd12aaeec9a051a7304285b52cf493af549ca9ce1db8677c31c6d9eaa5a3b040e655375c3b029ba07e6bd450240192e7be9af940cba0b00d967a439f155ff542a30f5ed4835d3fa874bae54b5cd98a8967c6c830071646dcbb3d5f86885d1f240cc95b50deec645d4ffefb97af0015905663d182d735584990688c6929605d55825d8c64a5465dbf89ac59ca53101b07f0315213f33de50b1207e3c147fbaed4bd8ccf1a0fdebab237cec8e57dad6f80fd97b4418b6b706005cee1781fcb62ff39d7b9a814ef868ef79b711d915cd047f521f1058ec10392a67fafbf9814cbf21f46aef95579cc2cb4084bc4f8116b9e230f2d027fd093981bea0b136fd4c8e1ed176f1697eec07a216dbe6bc771fded60409d6f2397415daeeecd1083996732f994e7d2567f1ca08afa86bb7a8f36a0fdd78f4b739dbf3781bc19fc7f6d4dac6c47ac101a9c322885eb8fdde884cc877d43ffd3333ae4b993f1e15d06a637705683219ed8f233fcf5ee01f18c404307a8004cb0a15105a2d30aca5e1e1736276fb4b0985c673e37b692d08e5dba6e8ea8220f6349a58010c43491861c5e285f05a403d3f2cc9c99b495f5ceebc8ce516f866e36e7ce18e0f4c52e32a1bf44453800c07876df80796b651b6f158c9799acdc749803f38f085be1d01a102e7580a255837a49ea1ce945ea640dc520e65ee9c0faff705341aa0362ce32d98039ca9464ca76f8cab2265e42d32637c448ae9eea3e502d40e93f244dde08743769d2caa0c4f2c0d307f33077764a46e67d63b66fe8d394531b62fb650bac0bcf2f8c9d5391ce1c2eadff6e5905c9930c3ca0fed4e3d2e49d4c1d9bf9e6e3d45a86c0a6c0cb40b3d1757f7fe4ad4385c58be86713e5018416545afaf706b266cb2c7ee7c9b58a4b7af2a0cc107209fd2eefc1172736fe176e75628733bdb1450d88084ab86af8f89bae5851c4efbf407262316bd177c59c7d103caf1141e810b8d22dc69e607bcf27210ba34893b5ea30da03e15df9b869965a4a12167644652c080f74582c05cae1826da8dc73d66b3fe6c403bcfa3cbedb77b089b6bc6057dcfc4be63a9efeb9ff383b5be5e9a5c02c540a9e1dee8afb63b227d9447ac1ce36dfd0bfca2801322c55bdf40659df0fc88b958c6956c487d156c48afb5f814660b55b395d36bf44fa5b0ef53ff39ec279e474904c7dd04b56f4dd25163f1dbbaf2aacbed0ce291d9047b07d7f9367c2a079a4f9ee8bb2fe48976a896ad4a5ab97629e7cb037a860da379a38748bb3943e0cf80343ad41da8ea2a2bd08c72eb881a25ae8a3ec9293b094366f524e453b0dc0926e4e783e9b2dfd75ffe24bf14bc4226d91eefacd5ab6d899b8294cff22ee39a2677025763439d938fba040478e4a03130d2982cb19c7c78364698aae9e81ea489c82cd2aea0c48f8d0ec03e69d58574d7eebb45032f6af13fb832572f9535fed5c4e92775a31cc347a323c9d66d1388956703d32d08661e9b6039795b92a5dabccf09e5240f9e49cdf9f50dd869f616b8eed69d72261650153a029586eda5266e649a62115785e1c93b6e808f9cd8e78ba8493438e0600aa9e8925dfaf43d2e4d6bcabe7eba3558bce3e7dc88afc6ecb7a4afbf6bac5048cbe4b269cd1d2fc6a04da2170e4aa308813ce4299cbadb597ff67567c1950d5a39f2c17861e123218260b9eb7ae656ee53ff51763fe434fcacf19b8d573e4bac5a24120d212b219e914291b549dcaa0463f33a13de4c1a8ef785ba3a5b8edb609e02e9a76d67db483f6da0da7f8d8f2099ab12d71b5983acff4ab09826b8204337409e4bd658ec50be419315fcc747b982ff30a5858b2d3ef2bf72ae94099db79b226adeb1e930307577106fafa23623204a0b26f143cebd868f5ac4ee838505b30c644c97dc9d0a19e0318548566d74c8839be61ac8acb30d4c2410a1e801c73d4b1138f8b94e2e153e337b4372573840e9a1a8ed5a0f4f53b4e74987b69389be510fd3cdd1f6ce0225c92146e9a172e0be33adff7eabd37ad65dd0af420fccbf68f359a448deaa00ea746476799822e0d38da054d6c1cafcdc3bea985ece80f5c7de375e7633c85063f43367610f2f6cc27a0a45bb010047782cf5fd1e8c0eb1d162d5d8ebe70c0c5c16b3eae761a079a85c02504eb3a01e46ca14cac0a050c21dcac3c95a3d29f5528ad7863b13baeef3fd36a1922eb5e64b155133ed51df922ae7818882503ebb66c39c86cf550f4b74b47a3695342239de8814fbfdbff5548a1a639a088577838a0ac13bac336320fb906e7a74ab1deaff20e548ba63612b4992e0701bb6ad4c95b68be4cf3110da233fabc0a97c31d1f11fef426a4e12568f8429f9acd85f55359449600184daebc159286878e57461581d961561887984ff19afd04ec8aa5a2cfc95a4d3a29eca2dcebe6588f762263c9941d773343385677d890f87838ea94af23734f0fa397e8bcec09ea20348acc2ce0696184bbf36befce9aa18eaa3cd74a674838e2feed035c78032aee8324cbcdd19bcd62fcd2b54513f31f05f4c3c101cf5c4ad828fb3b1c95b061a4b9bf9dba1e3b38dc13510623859d4f1501bbeb3356d2dd136cb62172a5fe3c83b3b3bbd5cd35f3363de674c01fcc970b370e20758b6165b12005fa2f7273eaef5c352c7888866eff29b58b48d66643ac347028ca81b82a0df8c5a2e3902a145a2690c8adf7bbb135395d83287900f75adfdbe2fa3cdb36349007805e2670fa403107aa4e339fa3ce172997a3121bede95f93474274f6a918ac81f487fb087777c36a2e4e4ca7c8222cf98c55b92df36b01410a7446e8feb7913337e0dd467e9609ffe421f1f5246a5ea843057b4cbb3c60fb424571d72c85ed4acd0473e3a595bf89e7dee6310860f9a914bac1b4c375d561a4439f56ace56c9da960554faf5595212ac6270e8dce63a0abc0ce477c3d0859fd5129e21cbb79cf26f92fa9f69e49086c9937e96360906627f297450b1f8293b269dc6f1427653b3296a796de6b3c0dda37ac596ffc4dd4236c4c01f3b96212514955d1f9e84d796f431068d1c87b7d147848e60e56010008a423273e565c145fa4270154f6c8dda6a27d3e64594982d2b6565eb2dee60d773218bf4ba2daaf6ee1e3adbcd2e3d3efc4cd038073f0db80af233fa2721317c5d6b1141ce1b564789f8a98a3e67a52e2eea1034751bc7abc4cb75f94d69dabd76076165e0350096c6584ceca5d4e25746fab2430f946d73f2d8a24abcec629e343b37f7328ca3c2ba73988ea737d58959a0ebf0514296689e72a743730b1121e8aa485c9262af4bf134d2c052b311876994d16b79d4e624fe0e3dd8f943e8e9c99c00799baae863e43c2d699b6bb800c96f37fe2f900211e4c3bc3b65a5b7df372bbf91664ef00dcbe5d4fb9161721b36db203168df59974da8d90f306c00af25c5a734222ab5cbf0fbdd682b81a8eecdf9d3cc2f09ca460d809db9801916b97cf0f6d96b6fcf0e20c2a60035acb28fc514cf0e0602853abf68c80f48def7e0aa60895f5cd7054ec990d5ae6fcdf1a98fa592b1e0a734d811056265f4205151ca74f0c274ed8bbd8c0395689306b69416de7b2ce8fd9be2b2b664ed711577b2073289ca81a0d5df70207ca255099487a83caa9d26046ca26ca1a6b9e90523c5551110ddafdf9ca700b98fe8c8a5720c0147452fa82c23f1ac7ebac80f8d2028710a53271b5918a303ec3bb1379aebea910143636d97913c1249dd6af7b61806b4dd03eeabf22a668173230fac543c33cf276e0e19f90825cd2d82d92c69c0a7383ac845ce39e51cabcbbf952cfef6909399556e20fd52e499818ffaffd2b496df88d820315d47f294abcef2ec8de56639eb75797b6347c622e64e0c28d65b14199a0963a4a4264f61d0a7b2c3bfb6421ebd85cbc48e06c4151744bda3fc90e9ef427d9bacb5d2d37be24269ef34ff4dcd4dd0292ac908d7c962d34c0d194519b79e14febecf7c31f8c4d074079b5f6f8d5c52e7dd3aae8f1c4f56c7293e586c8e5dd16244cb5c7d65aa3037a0929110a895dee5896cdc9a3239c1d86e536a033148f1f57d06c0d7f86a599abb6cd777148b10c50e38329b2827d06e24c4ecbd7a6b73cc33026873c3bde257392d1fe3351c38646cb9a9d45879b22adac98880608007de1f6b84689eb1a205f0a1aa8fc42a0f422fa71d4189b6e001cd701b9f5e5a276e8c30bef15520ea3dc923d77a088b65bc6d6bb9dc8e3a6d8941a1cda9b90fdc1bced217d35122d49b16b5e3c1ded221c9f99e849ec538a4b60c01176fc45eb05ff17b6034b7ec8b7bf86a67d2d9a0cdc91b5f06664f1d43d69ea45cde780eb345eda6c6e70f239ff1f69dd09fed056ec913dbed06e43fde31c9be979cb68167b7396b7a4f78b686a60666f1abb641f69701e2cd8b2f372b3929d6eac10dc502f8d847ce59e97819b9b9d5437902e7745c09be074ed1917861c7f14767a585f104ed92679b6677bc636ff4b69ffbf283c07cb8413783f7eaf69d2ba55f0062cbf1c3e7a561ad8d86c506ae1f7af3bf615e8a509bc517083774e14be5c2c42fa724d4284d1069d977202de1a5a46536f5d8c4f1772f06ebc5c391679424f7c5a7c60dc7381346fcc29fe82419c6847dcc0125b220d4b1af2a4b3ec59816ef93beb5e100b0108ad49ddd792ecd1e43a20cb585d00f08210bb8f19e51b6d0540fbe9f30023be5b4703ea2d0afa2229a7d30ab0e88b837dcb1fd8b15073b9adb72b408172e1aec6c187ea3fa54547ef1963c4bb40fcd61162bd922c92e0e31a562a3552c1583d9a5cf0909caa941063429d92df11465fb5f26ae81beb744d54e6247b3ae6b1be9af841638dd1af4ee4a46c67cfb53303b695be57ff4d631320adb8a6e4d5fc36ce740885be39777c6ff0db19e71a25e36918b85513961e138ff91eef5c2778daae0bb3c727244ac5ab74eb353880f7e80a9f634ef622c1ca730c05ee625c019ace4e9782b6341fa7ecb9d3b190561e0ae668b92fecc4cd65574cb4bd5d073554fc5cb3f2d60db0eee9338e13b517b96aa2ccf29c4c8152a122c16f3092663906889f5fde592266edb889d728695529eee82cdf0e0be96e7186fe97b40225b3de3850e2c844eb46df10995487c87bf4438448021e8d175ddd3e5a94e51505336baed25b3afdda8227c91b4dc756a502c68b6da804579162605c9953ec915079292b3a3d35c37b9452740eb5943f43d06a47ff3730e6e0416741f2db80206c423f4b1e8851ef3c81d6aaa8fb611ac4f8a747fbcb00035f5e17e7bf539adf1520ed23f8e0276e0e9fee6883dd364a0672c598a3629322da7dca74154ef5cc0bc1ed22a0fdc751262faf77ae071c0ddd2aaad46efa19471c8272e292ccbe3ed7f9536ffeed3c9306c23d0ccef7e499a97538ad6e103999b487a38ca16a17fd809ff845f96b04fe162b4163c08b79cdbad81988972ad8e6f3bd0a62f9e9295e97af0c6004e9ff9854cb75b067e565af03915a8fd8e55f2098000d34f428e3119e7196d9188413c41891cce09715686aa9e58be4ad918d33aed13e618e7384d75bc988b1a82a483988617c34f0fdc1774b03c002775a7ab6ac209874b25cd8273053966aca3e737fcd8040c30446e71d5c0212ccdaa3581bcdb25e18a57047a211ca68ebb6bae6a03e711dbb2f8d1af58a3c29da8bc29cc66b4fccd5a5babae271ba4cce906c9120dcd2ed91519a356ef6c64ddcb3586627b34bcac34583147bda75567d01fb17ab1adc426af3c9aa6b3931a128e91e1131b099be7a91a8d565cd2ab7689990b37b2b0ce4c1b08b7b11d730335c2c8fa75c0e47331d173c135d754ce66e495393d31c1d10db91abbce7194507a8800b944ce4831b70b3a3c2513378cf97cc24c551af0545554d36a47038e51082048c43d3fdec2aeab22cad8b093dfdaf9496071c5181953c38e4c90fcdca9c5a2453947964fa12a74d57200d1de81f6bab98f6cd4384e2777ba0ac1fe931f0c2cbc692abee6e54bf75b0310b76d4bb46743d68abdc22f65de198623775dd2131d97497432e20587ea118c20cd511471d3b813eedafba777982182968093a1eb51d1dc110f238770258524588e6400474b27d84c613d1796c3e100a942a9d32eb0c8985f487397685e6771ce0bdc3f4c4ba5ef03d3a9aae13b7af033423f90859f7d4d6252cc7668f94efca3e8f42278152fde5aca20c1cb741d899bf8252204da2acb9144555f64c694faca89424149498c5adbdeb8443c2f31c84aaa59800cf4bb54433d371120a85ff6c89d03e3f36ed05c6760bec6a727fb7a411847edc9a1794005b3245053ac6705c915778402b9142fca8c9a890b64c19c95a391f785ee934910582de59af704dcaa13752392acf762b4a440d0f01303a4b64d1fbfcb07e8b3956c235978ef1c34a4c3004edc4d611f133d24190a76aaff103dc35bd8fb9c970771f3bf0ef047dd1832c6d9857a8e0c8599b7e9426b7ad81390e5e1f3a5fbb261f68af8219da077aad1400e39da165fdb1b4036828bc5d14abc3cab6d33efcb554e913462852a4499d8e2450d66737856c9c15d40419a5408f7dbfe4debac75ca20f9af49610f4aabcff70ba7adff28d9163172846ca368dca4ce6b44b68b5600bca25a863d5e1fdf94626f60647ee6612482b72853b7f8e140e73907bb8fedb24e3b7a2ca13c9aac8f3ff344162277baaef92c9bf275e0c4df953ea23572f3d8823cc12a85e5a20811e00ab42f757005ae270a2446645a1d70b8e5044d4ba5329693595ea26fa8fba2f9a8406367f997b7ade948af52b16a5b4ad9278cc7f77578935dac0640947cbc56182e59657cc6a512bdd2b95a5e8f1bf73d93247883fc9527bfbe83ef0e9a7c61ae0c6287740fca80df7dfcb53c3c861732f15d1a3a10ac0a3e55763f17c3ddda27f75d60e307b5fe471cda41342e538eca646394530ad714598245cc951fd0fbbf790a2ce79b83cff9eac9911e7e733037e84286fd1280259b8d1f17ac655da254f53051f984300f2a7a77252c01d550074090fe38b848a2a5ef6fdd87530da0613e70ce9d927bae7f05fe41705d43ac8ab46d2ecdd0ab1af7c60244b8a1866c1233531ba4e39c7174d72a4f59c41531dab12c8f2c9173724f677e7a553bee9e2b2a0f8f00c6aeda116eb1e4cded418a2012ce096036f357fbb6076df8a2948643957b7f59a4f6df997853efab4f8cb009035266de3b3c169114f6b1fc1e2567e192fd3ad80ada3c28a33f95d6cd71dc5e9f9cfadea4c88d2dd5862a27b3c1cab638dceb3f0c23b0d0f24af1d4ed6377113fa0189e197a506153f0bcccb8c48e0a7f4161f83e3603145aa146ec4e5539b8d44f5c42b885d0980532fc7232c220b2e9af910154de65df5ad434ab3f9215f241169dd0464aea6011bafe255fec9baf92b51ff3c0192dfe72e67d0861bddd92a619c2b1a9bf85d9fd57ad5c89addaf5b2a07af65d776ce1b3e18ce8f197a7aa7a50c86d86b9ed7e55a4f4ffce3aea1a4062b9e5dbb630967ad72e349380b09140df08285cf75f490b025080d9b9758784a86e516596f3364ec626db9d7cb2f1839458096ba16202d50778804ac0c71d14df004382311821380bc449ffaae5daf299d143aadebd367f8034c8fb709d963482f176c7ae05d6f959f05e29321d88dcc8a69f0835f4919a1a60e8de25b95bbc794e55db5cb8f7571049d4eb9464bc5e1bd18f1684b54fc222f03c799a06a3a288e09ad8777e68f65b7d52c42c3369369840e7ccecb336ab959968c10c3564df0ae0b686a86d40bcec688db8a36e8a9bd978679db06340a1455d082f055895a0b01c4a60a0c9a7738849265eafa25c5699bca379172d31c1c9e3b35af6ecfb0c43a267d45aea3b1e26ebe12113ecb13daf8eca852891899eeba49bff7641ead4a2180ee938b6f1177d15e3f394c3bc3a70aed10d8381695672c0534fa90df298a6f150fcf102288104c4aafe90699dbb1e2aba955fa05f602fe44d1bdaafcca8e564dcdf14556c624da0e88f7f50984c51f19a0c94971295511a768bca97cd9cab432fcc44c09613cd6d33ae211d9c08ae73ef5a0245cc270c7222ef586857ad3563c49583921a868e36f7ec0a78811939f3c18c983bf1145c9244aa49f94b5602409692216923c25bbf2aaadd16f3888d72713fbc60329d46287dd2c6eb5f1bdd0cd72358a5f0dd7ca990be42fb8e7b42b99c03433746b8ad08391c7682c754577f7c8f4dd3f18743fed8ce8822ff7cb3d3aafde7f3b2391a6c8a4b82e60c328ef12550b57f6855ee4709fecfe818657c48637cd2bdccc9ea1ac1c58d1994ed92e4501f044cdd16dbc59f48ca292051238718709e58d690b80745a3dbb73523c42d4257e618664b309178a9c87ab5cb248bf86656b66900d52d0a07fe8e36f7b9bc491f1d85493196e7e0a4ea01d2b6cda3c18264c6b0b5737312bb27b0023dcc3b172e6eaa921cb04b0c6aac48cab88c1186ed253c41d3429782e3333bc2456617698e02abf36085f9d743e9335d8f61d707f03209187c311f5b35c8a4d593ba93b6e5274f1cd37e55abfe12b66cf052a5268b9797e5dc829238a9e9c15cc781eb2141a5660b71e5760d050bdb70eee9f1a31cb1b6faf101fe46f7bf6228f1c246b39767b7b6695aeffd76ea99147f9cf175f87ffcff4a8b4f307102a2fd21be56e541c49fd0bd80fce8d0508e6b45ea219b03a11608bf5a802a396925e5254badb57de9dd60f00d499317d87ab403ecc0e0854e5e9ec4aadf94c4591047a94b05f5d5867d8144d567aa79597f922ed64ed801cc975bb22f7ab7cb959be73d4ceac4e8cab4d052b0a39faaa9bdcbc25407496ffdb1abf522a143235ba28cd51af465b7023b9aabb839c1e21e541a06309fc6e610d72953c19acbc09bc70fbcfd56a83236b372da93bb1364fbc9db901b8fa45169c2d9e6e6aeaf339b84ae2ed23624b39ad192cd7ceb5b27869fccddd2e190775e0abad054299ba83f3af7e3cc4f45aaff1f8da4217edd195e1e0df2e472be9f264139b419dec38f23a1f178805834a128806a13525f8679e1f3f7d0195f3a638b3f3d424937ffdce1577dc7fa2275bfc03560cd9e4c3f86c93d6a07e20badc857f996ff9ccca7977ab80316f5b7c285b339fd972e7555d2b5cc0aeca321a6ad022176e04bc48c487aab00573729670440246929492cafd17f0a3a2e04296bfb8228567522533fa07b04f0b7647b4dfdd511ee962e7576e5335a46984b77fc9db76bc360084ea08296c5898ac003e50430b34f7e565dd3fc6b73d6a20272aabf0ade03866b27243040ae3a362390734829ab235fd7c3d9ba9e96851a5a94426ddbebba884331c160c4ed3e071f88546047f0c1e86511bf34d5c3189098a628b6983fa9cddef75e383d9bd8af3798ed14fe08fe2e60be3428a7b5258bbc2bbb9bb99628235bdb5bfde7e0a481906f4495583a491468791a614337b207b7a8164e6990b59ae80090376a9befa623609b43cc8a4f68c45f48cee6208c391acda0580aba6a1ec5855ae232f5a2bcb36e25faaa229afe2b58df43f8c587eba5936928e25476fb4128fec8eebd5a9d022abe1362180d2779a1f0c47eb001801a9e45bbd2a3ed6c48e3e8d9a52036e87fa411fef21f482ed203140be32de07424e7a9c54ec75d3d5d0f7bd7fe46bda027db7517200728a6084903dc8a7e39d6a6e21573bda06854b55c18bd8c493a0eb2d5552cf543900f930b0b2e95dd96d7baa45a77329bbb36b4bf946aefb36c3b9b31991c2b1637ed74e3e50aa772cd3e916eb8cc057570a62b9d58669f04900abef2cdcabafd68b6990b8b47baefbb849c0a8a5667ec247b28afc109bf43b2a2cbf12dd043d731737f1ccd0c5b6a1e0af5933ca92900a3a7e4e05d07a8a1c6cf5657ece5089b1e529d7522cbc6feb3ac27fe75f26c8238779608702ccc8ffb4fb19034336d96e3e88369b740c7e9474d7f15dff88a0de0e000552d7b3990809a5ddb0810a6e17df48355af88d2dd5c948782763dd1dcf2876cdc91430bd1f5c716ea962149ce49fb1e5ba84e7e2b037c0c246bcba54968f567d11c3422fa37a89a08f9a473e76445d4b1b7585f9c001adb2ab0d9eadc7b12a340163e1abebbca575efcd416ac046942ab02f845ec90f149b834b8ac39e20ff91324a32e1d1a7eece40ca05b477873d77343d79b04f8c3377da5f9245030701d7cf470d33764d9faa67855a12bba01fff26cf93b227430a8cbbc8c327313e5ed02719155b9c8940c2a607b4f3b563f9142270d1d1067f7eee5d4ada3528c6f37c713820ae9ce4f633e407e649dad083a45b5fdeb1ef2c524ca2f56d25ffb740e5e0bd599b9057ff62223bfe8157a5bd35dffa47c9334e4f4732ece0652ae685b9f822e3d7d72589554f028946bec00611d01323164ad8ebb3d3e591eae6bb259b4226d729306df10472e08295f4bb3d0ab7eba34aff8bbc75fc1fe668fb48e2d4ff5490189d160f6814cf61f795c7b1fcfde4122d7b17e357582d0c7a9d6f6be0445260bc13aa9366a0193a37de88880f83aa82ea218ddb48d5831c4ec8903be4eaca8f7a5bd8824838c0a6b72c005ed568135e7280207bcbff0a13123c3086c7fa14b2f75be111a137f734d1fd6ca99ae5e58323871ce50d51461e10e9e883566ef068e5aeab777a22ee895f604671ecb4623321c615f16d9ee39ac69d34c3bdabfa168c9eba0032fe42df25ea7d7ae1e8a5ba08cfb6882d5aa0bb640b5afb058b3078b8921528286f5d16b5358ea3af38db0c68002e998702c7af9c8104c83195f6d94460cc89068c185ea4644ced38212e7af44b394e70e3c91fc54b848efe3aaa75126cbebd13571236ed45ad4cc94c2507766b89f59b5bb52ab7b66b257b1140b75ab5eca5aa55db79c5c14a37942a2a2df631ab365135891d5f37cf81d3490d2aaa9116f2210a38962050ee3c025501e02d5c53e84ee29de4b2232474ee245b017e4b9d9a2989ea4103f4ee5d2241f26481ef3b411c50d9f5a8a95d3c31ad8fbfd7636c19f881bb3d0b920ad9b5c38beb57c13583f1d2b9b63df90090bb5b80b4c630de52c0cd74d7e669d7724a1092470e988c00906374005769350e942bd51c942b93e069fc13a58dabd5ce0dddc49b5ca6a51e81911c09fbc849dcafeb1d9a8343013af0f4bf3ad41bb6756f23d012706011a043017f4bcbb92f96b6fa38efd32d0e6259fb75d63399fc51131e98f3807f4eb1d04320a6bb07409f78cb290a9f6a7dc3a409e2df693b6858c210eb53b0caec531a332ee7bbef67a9d7d5a33b38bd287b5c9c14f654dc9332c7b5405d6087e086d62629b322f9f4694229dfa978975f404702ec7459226eebc1675d875bc00b7decdc779cd845532b7553dc513d43072a23424103a8ad4b31b7f28fbe7d2f486bce8ca7933368d461e2f34cc4b826616c07f31bfb927629ff9a54fec89119f5e68de18e30a816fa572d4523983bec9d5c53a4eb946a4ae8b290bd57e86121c4feebda2dfe05aec866db65228d59069acfd2a4e11785fba538fdc522ee09e57be8f706300491ad172f25253ab2cd2233d53da8bb52af6a4cfba772d9fe513db5f5ad466ce617ec6b158913b086809d842160dca305547f8b125dc929d4f6077973bb8148fecc00f12f81ec99c0657ba5d4e7ea7603f1ab6f41537206737f0f1329a1a0e7ab8f13536a8872387bd815cdda913dfe76bc7ac5817f12f1d169a871d7c9de5de070cd9595a4bcb52f3fe24eb499dc80e561061786c112970b2aab6a101a3248e0be173ae3721a415edaf3e9cfbe01a4c8d814ec6df35bdda990c6029b8fa5f048d83d0c5a38766ecb5f05c3d5d5a3c141c36ec203a04f21aa9bdb14695177ed8b2f1ce0aa9f5d0b3014490d965aa03ad023195397c2ef71e8346d6bcbbdad3cfdacf18bf24d519254a556e2b6a34011a3cf187c51d5bdbcb597cfe5d67f66b55d70c5e5a3495d6f07c2207e9e2fc7f39023320611266f9db4a3da1aea2b589b4670b6635bdb7500e1f1202bd13bad455ab24042e8082363ae3a926d535fd37d9111050e449cb711a61ab3008dc9be7ea1262078b0ed85c67f6a5833fe5762dc16b8b16b782a0661f900f36cc883da0e6936645d2a2e4cb09ea7fad480be0065a7edd3a785e73a808810886b07bc66b292cd79a63a8a96add454dac523e981f65a7106b331e9cccf2f691315f73ffdc5dcf83a967ecfa33dc7c2b67833fd2536c21bd88892c07d528c8bd3f56f622a91f3b43aea6c35dba0d692868b6f74f4ee279d252c19f46ad3562993c3999d1147b381f08ef5e9ff1a3e038d361f30a678633a63324777f4b83667420a9840abdbbcc62dd05bd83aa1d21e7d8229be1b6320a57d247f0fc45bd13035731e2fdea500547e6c3d2ad03b4be23fc00732af59f2c489a1b7d7d8a82ae29b67e1128b97d489f073fd2809922b98f548b96066aea215bff90ace019c7e957d06818203ba6628b475ecceca1c493d1f630f60d5d7fee2c70c0947df71fc7a662d26d04ba642ee195a32292601b101949c51b6e514f94d249f6577915244b6ffffb27a58572d85d2909ba67dbf57611cad0c236daec234522ee3a486f34472ccf84096bec37096e456709dcd399376fab3b46eb5e9ac7c30feb05eaadce883cb119923d655727db21f175d667d0d6db7b083786ef8d4103d591274d3904c06d5f0b83a2cdf213482a1a2f668f0dfed4ae6e944bc072511fbf1e17992cd9c2823f97ba6aaee9d4169a068f5349d843eae458e885e3c118953910ac228d2e9b69f260e7478f633318197d732a005240086216c168c85c1fb9248788376165d2efba5d3604d1d1334615f99dc0eba51f5bdcf7aaab0a91bc1c4cb83ef639c36ac41f786448e72f86294e8cd1bee29b0b7f5aa6a4eb82a109a3a67087983e950d91e95f7255d99ae7980e9a5ab9bfe9fe508dbd79d7af4825afb3460b11ab7dc003736389c1af0426fcf433e56709631d003f27f42c882c1f241e8aee8829508163e06153eb98e4ef48a1ec0594038f76bbbb40559e772eb2b8bd35f67b3109cd95d6576ce5ac7f2f5760e231a4ff31144553ded3d241c69c7e1c3af3efa46b72420dc65ec92e4a951bfe77542f04ac3ef268dbacdca7fe53923a91dfe981fde84e1f83b624baecb114f9c5715d70f64eda05c2a928cd5591d6db3264cc8cd8e4917a8f995b0b761e8a3bc8513ad5c39ec4d2c6864adf8c7abe565786637892b6c299d2570bf881027eb5b46fe6215cf0df000a367274c3e3fcd9102b1d6c6e7908f508d6ca5b6abc90536d7f1f45d5909336ca96012efb72e1fef4dcf2e55bfd6daa194fb86f0ab5f1d1f6f5a0d16ce1cb05ea357f9b2dc0976e7dd774da8efae52072ca0613c75a8c2ec14c31987e88ddcb2905e72f23af76b21a7a123885804fcca43ee64cb512482034879ac248a2d574e51bba9fda912998cc9c80e048d0f6a6e7c08710ddb442e5d5fb74a210bc739ae4b00e25d1f34dd1f103e8310e13d34bdfdaff5b7b3ef8b38816e2a21bf9e412aa9b2811a6da4528f1ffe4fac99071c8ab6f817fd83109b67562274b0b8e3a8d086d0c240077696762a3b4c4a384b09371315ac315f7bf3b9b81281922b33e0d3905319ee8523a0f727dc31b49970daac091a7992616cef6c79b051eed4429799ab7a456900cb298df3b0f882d3f0698395fbe6bd760322735b107ba8ff20f3a2109928611b5f53b00e442e6a50074851d95ee207461dfb57eacf8a5025a9f232f9bbeb3adb683c033a35be6a56a8f09ccae4baf7704f7ac77043d77130df71340594b9991db6886f235f54bf0b5f88a2d9903f4d55fd0c745bcb4fea235e9af36bfb2387cadfb26f00c5dcc607a2a5ce56bdbb99dc7dce8e0171af064a38163a254fa41f534807411c7f6ddc72eddaeb4e6db4df83a36fd9853a3dc2b8c2659a0e6b827bc98246bffb20feb411a5da5a7bd6b07eccde7c4de72df90560a3bf1d5bf3c980bf51912efeb38d7141d7ed41bdf5f97ae1493cd8c73afa965d0e017c70e8bc849acb3b5fd097ac1ffffa3609be2789ee4accc0248637c86829d190d6eb00a225e4f99c647505b2091c828cbca679aed313073525a874c20b064539bfdd182505405679d313302e40f3eaa8a601947ea3d3264d1d9a28ee309f429ed51dd4b2485fcee5c1b4a94e03f37040cdcb80ad3e7ab499e7cf53ec2112357b6527e150131600fefe54df9fb105585f4919635a2f09908320456bda397d61403533b14b8c0f84bdaa6207610991585bed39967f864b8c3f369e4fa0795cc77cef52f4956fbae9c829a8814236a6a21b182bf60169b0eff97d96500f70ae21dcf8c5948b12ecfde570665ef79d10d20114984c8f79f085c98474849297d0232480352afd36f7d4b69e85e9cf8744b09247ed055b8cbc27da3216574d89afb8d1804e4efbba71742d631b470cbe016a9bcb78d3801032d438ca702581acce7c0d7e1b59578f8c7bd31e422c179a3c7d041095dc89c479eaf4bfb772e0e15a14c86b7e40cc20ff734218046c1f2cccf75aac2af0cc9300cd08741290b74e6dc628faa8fdb9f22f9be25670410c7b23004c787e8b0e676ffb196ae8b696c61e790a923552170b01f29ed45d3f53c1548065862cc0d75075ca92395c40f223b1039a611968911f7cb98b49b1e2df5c4ebf5653aeaf97bd2e438afc5dddce82abc019ac0224f2692436c2719863c86cb3de494c40fecbccec7d984864dfdf84f5a49b285a7ab1d52f8975facdace6be8dde9ee21376b6050fdce8e06185159e0cc0eb4b1aff897bc79c1529a23f249771283aa692e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
