<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"09656ed1940748980cdf3b2768f2e7dfa15ce3ed39fda53b9eff447d515bd07957db0f2b07c435d9d2cb1599dcf3ad92329bdbe1c24b2b9e290714d16ec1fecdcdf547af2135bc412146474f6dc4ee61739dfe7eee081ddb160602a0e321ffe4eb3ee47f22797c5dd3cb5c3ac11bfa210239a2a66b5123a81843ff14261f100e892eaf8cb51c539dad9a9b6a4f5006c8ebbeeb4066155a66b74cbad39fce1a9c7a0907501a43825640dd147ba33a421e4149cbcb09e6f5657848a44ebba103ad88aca5e58c169506d149a9fc638ff8f8d022cd02ed0bc773f9e34eddace539042933c56f2a64f76443e1159c34d98b4ee439265c97daf981219225fd0c992a010060d972cee5d5c595544a4ad4e5023d763cee59fa089e89fdbbf87aaff9ac67dd71090f798bb69d749c01e9edb40e2a57e0486e269b556432d748359255f5cb346f167a6165c2e5f6920a15134bee686c726b270404cf657bea2f21454b6997164233d81e9aa8ae81585e7fc4f72e6bed98ea573114eb26fc87e28598900622129e565846a831e1aef83c0d46b829752759b77f7916ee23d58433d36eb7a349421790b513d072acde147c643d2e32f3bd2802e944b5dce86473aab67aff2d6b06e8f078460cca111bac899480006b628bfc16919d1f01ec6d3c69e320dbcd1bd07bf4b739f704fa1ddea8b8cda20f294bc946017054551d6a712c833a35a1fccbb4a5770a9744cdd47167842921ced4d9b381dc2aea2a8e0dc7adca2fa81f0d58d15cba617cf0d7c24a5091c3a2a3103a98860525903c436aac39980fa3dedf0a323edf917e1f7424e8f4420ab57a7857ac32b3e504342f6262478f6c4b9c39dd777ac3eee511fab8ca714213abaa892653672a3f10dbd9a1bf4034039e62406861f7c3fa42d7a48bfeab967824356b0f837dbd6226ea09c4072ac59a483fc019f7816876482a446556b34d7e5f74559da020ac021a0d6819e538ecc7e6fb68239b1bb2f7baf752b0e74c66a4489cc425283b6484f1ac3056f27da65816deae906b5dc62750cfd5e467007119f327fd288b10fb4d9bfa769b5882e430f8f57102b57075aa6ba95e9a4626461b545cabda3922136c57868daeb038631e3d4ba71395f3529e977c93a4ae193562cc19ce0639cfa78a2440923fc6e18aa5b49d5f547716fd5e5e2579ad5e9d252d5bac8a8560f520cda8239d0bdd9911b01a09bdd54d90863fc010ecbb25375adef817b35002f3e2a5820dc841a2d30ae7510d3e13a588582c01ad47e07cc13dbbd6eab859d9072abad009e991cd3153b28c3351626d1136c68d232e393b4b52095746b57686adb538e2e282dc78ae12686c1038d0aa4be44dc11d08919b6a6951964b05f9a3dc5b1bcf5033d5e54d0c2e0f459e211365f5623dd9105d72eba2d140f9c22a981df6491d5e12db78b6c77029673bf6f9199ca882313618a050d79e6af81d970106c62799bc1c669f9f7c2824bd94410c3e1ea70b8ec61066cb35621a9b0569530815ff3ab8b0ea048b8d9b005d8b7325b8d900585b330740974e8f3f9d175dca3e5470db9ba95cf303481e3a7889671ba1e75ae705bcf21bb74a689eca4385e83456b28db94a1aa25f282757118c7ec8785411a138aad07fb969784f81deb8e5bd6ad6bfcc8e41afd4a575be4afddddde839dd5f078135fbcdd4c223f0e6c3542d6a3b4ae288d68b22f7f00b87da4a5e7fb953aa2f3e981e73c129e04b4dcae4348a8e25914a2be4e9e0b1e9c3fc517ebd2e483439e4388c9b489d4592cec913cbdef65a42ba600621bb89b14bb5576f0c1d519467fbc63ad28a7055a147a22b68cd71950edff715d8ba7acba10a849d6184992ba1cc046669662747a67f23f3344029f40f01cff1484bf5126379937edd1bbd6f7acf199a7cfbed5a528a6d8cb13e8c3c2e60f64915c5e549fc973487786ba3fa0c26a010a7dee7be726d778a8505bc12c2f5b9b83ab47808f429fc7eee501179efe37b5b58b7803cdaf0b88b29b03427c6174e2fe59d766bd06677511420016f57050380140e14c78f89e646822d8e1cb1abc20ec00d577541f752f7311ce63bc7005dcca750734d8a562b268ddb9c37e1244d41e52e407be388c6aba52f18e83d48b5d8cc2cbdccb352d2f48f64af83f25dfaee5d584872963b3c90fa65e8425f9bf0fd6f241d132ed36c34df2b9a0324250e8dc3c2c6737e496460aeaa408b4be6b9cfb151dc012c13ee9bcc9a982981c934160e89de3fed717a2c9e30537c59f416e01bc8c5144e99dd57ab868c325fecf04dc90cd73faf79c1163d581bc0787dd285af6dab13a9751063a5a4b367b1de6176c11e2e36d2090719cc780b8c1266a52b7920cda3ff1dfc6b413f354a31635227f31e57a453ee3c475107b1463f894db7ed3f1fd3042a549b792c8e9903e904a8490dc291b0aac31a9481883e5dbaa314336030e00419641440d7cfc56862fc88ef048e9f79f5f4db973a9f896b21b3bea68473005891f2aa17d45ab5566a71ddca18b92d172573529571f771ae8256f6f0dea057e5c28ec71dea946c550cb17de8877f6cd272fcbe2e75043fd2390321ed674087e8cef9b3835d82d841da77146dcd1ee45773356cac6d45e0a5250c2f3a59bc27d5844f419e8d407673b14e5892f6d39617d4260a6809aa5d7295fb4fb5430c34ca661be8fb5714230a2de8241a14ff949b489745d8cc2506bdc9ab7bc750f1bb1b9f608675ee333099d35bf1ec6455d1949d778a7f170c07fc803596539726096d674328203a0605b13627cdea7c3a00ba475002ad6f474293f8f603c7144f82456906c5494c42e448fece804d42a34fdc21403627017565271ef8ce904f1aa370b92075f7378d4174dbd8392f569df98d2b3d83e2673e281600951f55ff63366d5e9aad13fd9f2c74671e2aec0a895f64b45d42f270c3f678f3b50db0a518714ed37747ab9de2fb10d7d62b6c08e70dd90276cb1d023a6245bdfc0f30020c296ea7a8526af654db6d2f0f102ea0c9c56d437fb893749758968b71651b6bda299b4767acf970dafc16d2d6acfd59d931dc56f8473579d515c491fa94ca3da3576bab6f66d3c280e1dfd2729c56b948c3e949ce515a6459deaf4bd05daa1b9fb641d74d06a638932d67c61fec0e317f7bb84120d298898f70953088c5216953643e808d5766b8404434467da5e07665044bbef83b2dc4083e54ba2e99478ae059eb4bd961b89e3b477b4be9f416b5c5b6a333c9c4295f821ee8bf9c4e74f043e7939469116e08f71acfddc4bfc5b1bd2be89f82619e0ce815a46db5c4e33d36e5fcbac94fb6c29f4e1f1cfbbc96809552c0f0aea685d5e5a997f9b76f866201a94e4ad57b3b26b3fe6af9396ccd634d28b9deabf21730458ac45c6a5f36751eaa03fbb8fea544ea3295fc9cff6a3afacf6adc1e0c245700923bdfd1355d190fe4cad6331db87e5f2c5f5b13d4ce2916b326949698674f10d1ffe6e2f00487f5b7578efb5af8917577ae0d2b487accc4a5b46d09d56ce4f1806401de5ee806cdae91a0a48bdef50504ec88ed30623c0b4e7659e4df836a9cc76af336aaf992334f7e66907620b7801e46f5b52733f1d0142ad662125c4e1352f7b44f679778289f618b5c6833e7e86549196d8ce6d026dc578a8d3a90ead2f5c651041a722c0bc298726ebb3ddbb93ce41ac3f5445ce1c513b160da5861ee05cb2687ef4ef5974a5fc073823560116b662dee7707282e8076b507ea911001da7769d92eba8432fdc1266fa65e0cd61d487f17523d9013d0dd43cd3f873428b4c9c57070afa3904b3e56efe79f5637db8550bb92ee1cb56cb4525323118d8369640225161ecd5858cda6e964307618dfea5b5d7d2fbe682ba14538cdf37302f80a8af6ed91dda2a402638633fe69c781635b8aafcdb0cdd71f1b85a099e0517bc4f4e791ca5b1cb1db4a41cbe2928b255ea97a46be5fe0baddb7eb1740fdc0faaba4a48488dbb76e8ccd356c965c9b128bceeb936a8af5dbe0b8a030754edad1e061ba3d466e7dd5162c8439f0698a528f59c32404aad737683f24f696715f21582efad868150786ef1a34c2747a55ab9ef5a452ecc753927e5f084c8eab828cfff52a56b60d6a361394a1c275bb56f08283f26280b45465d785b2cf0eb9c473c8d1a08c040ade6a1ee1b0b24b070e945c8f4efe7ad34ccb4b6dabde448fdc98486cf2d8c8eef6ea71b17d6c7be250cd88cb2e18beb05c57ea876be1d711b23d53821c20c6da44a2b50ca439665f221b2c9974a51a1a408fea9a2af777614419ed28e20c6aa14fdf19aa6cc3a7bad4851bf4577d1bd97a668998f5a5381807ce0c85a16dcf7b07cd28fb828bc7a08a6741c292f24a148b842e2372c7e416f575d7b4d75f338fb59f7d89f1213663112d3bc468167e2906d7d5cbac0518b5f209b468e725cb7042d00910514a1d0bfd1b603b6811b0c1409427c1c4cbf5a00996f5c464391747472416411b14f781c43fbcbc2b83e4bbedcb56fa2153bd8db2c33ef13342d67731d3a74227fa2eb3882a20e1c0f4dac8adf172d40bd3e60fa560b2e41f1dfd9139ccc68a50930604cb0274b02880a761658bb737a81a9b9624833678cf7eaa9b85ceb28557bd08f886101c927f4b9cbbb8f8d3b2815f50e1b1fee5a2ec301018feb2ead8cef1c85737707a24f3a9ecdf28cbc499786784a034f5e9ba33b3422cc37629113b241da37b473da73093a52f9363d85c20d963d7e224ca7d5bf8ae694e0105279bb8b35abe72cea46c609bb554adcdd054f415d0122b93122df68eeb2e24b03328999215cbec9cd03a8a229a6f04b3ea0d07ed193a2463a04f3f294002b667b692db3bfd2bc536d2e79dcf1fc7f5206c46d48bfbdc74a5eabe1db4130dd0f57e481d307d7466476d2c8f8fb22a575686f888817f1b30bfa9129afc13ef043f9125c1393343359cc803731d05db6a3f8181d032e140462b44e2574594579993b88b8d0a32a07c17417626588fc12707e13258566aa4fcff4049d4c8c6ce16c2a0f8ff17e0d86d628a5e5e5d76dd6e6c48dd838d4ae69f97fc50b1b9e7c0ca1939c3a6744e5f771ed4a369090f15b8ecdc697dc2ebd18b1ac2c1973278c41accb4f0e302fd7b1f4448030a5673cb3ee0ee8d6e49fb57e7aa03b82898a4e1290d38eb45017e574dd6f428544f012c49838f39d0cf63822686545da58e4e6ab2dd3d4f9fb9acf85d58e43e3d9e030a9f8b53b34acfde5dde65d5dd548dabf7e7a05fc7ea5f1aa0ffba7acf8ee4369a44409cbe492b2d42ac054784c1996ee72c065afd171da2e0b20d1c6208a233fef98c1031e93767536172cd18fc47a75f1e524732ceea6f87ee6b51cdce3df24edf286993f9779b9e60b254aa44321d1c11669b2f45809ad8dc91e8f3b1de15c88436b0fde5e85c00d36e816064a98043529e256b90acf1fe12c4d8b689ce8c8323bfb4ceb295f672f8029d59dc33b9dc0e72781194fdfcd244a019d92cfe4e771ff1df77d30c97568c8c46e33a279968d47486bc273d9fda19cabe9f452c26c91786bc5c3eaf82ae64d98b84c39a927361f15491755fc85a4f0fca393e6328fa60b0c755c043c4ee647ca5dbd0dbd29050502f1126aac2714a378376611089b5ab491b93725799abf723141436e2768c4793dd5155c47eda5f84a4707de541a1a76dca297e11ffc4525be793796606aaf42dbb596fa1ec722033d21a9438f22e8c74703793b15ba350a4e0bfc3674a9de15f9f7b79fa2adfd3a4e116a6c3e15e509dcead2a5e78ef2ef8351431e6e666602ac786a33d5b6e449d82ec5b6596b94d8860804439aac0035513e496ca284b0487d367ebd6f7c8dfbe2b0fb7c74c095e62062e95640b2b4a13869d82e7f6cf483d469af9f4fd1bb343d0ecc180eefc6e6ea51cc9a7af82f463004499de814d9635fa814226cc487563551ba69310db1b692ae815d0462469e3d05e54ec8d1857f73f802802ae60b8ecc82e7150fa959d6718c0cb9098df9657219103f525510bd43934f78377a088dd3ce2353680735e8ff562ea4a61d428fa4ddce266d19150b7798e41f0509c079169f7707c529b34c1718e396d41e5250e3ccf48a6e2c0129009450485d925792aa5021d87b3fc3b693b4e6e619d9b43f25893d80096a7717a40047c2597f32c38fa9bf25dc1a5ce9c435b7c8cef3414e0066582f3eec8a25e61cb8d44da11c2ae65d69ef3d784b68b21b0bca851cbc3895f0687a75bd3d583fa69f60ac2ac9e5ea2cda01d85167d4d6728b09243e7e51a98a7b5c04fdf8e3e3a7ef8effa4dfd9c59a12aaf819116a6a3b989b23eadfaaab8d667cf61b2bb37a0b89156290f50c5d38b19845fd1cc06ddb13a09d39b369e1d0a51dbb2ec93459550529fd83c28aae4c150a0f078fab29786c7ec3bf5507bfd978d7c815c295e6f29ec71e5bb467fe109dea2b45045bb5b7a58d0d456db910b8c4e6f707c3cc7d56d47d4159f2af239bce9ec4847dc1ed5e0e5d9a9857dec5785a261551bd0ecca02d68720122b7093aa896df69e0168ca752e102613fcce8d2d9e94e320a86c1e4257ad3248b4d7caaf3e121d03b16cc764397de96908bb8249ba019990ad47feea8b03312eb14ef45a5b1853fd1fdd89ed54f6731cb789ed0e2c29030282318c3c3f7b08c82e069d195828c92ebdcf5962f6c5d179da9aec26113726b1e0a822c0915b33d8bee189b69cb092352cd6b4cdb4b6a6420f4d511351eecc4a8f4f02944edb36535901fa11da92d71def853b333624935da17714d160c59a2346ea729d2b4235866fa46197f22c4af075c48bc6f880cd0a026db82f3495bbf0f7bfe19b9af9219891f2e87f3c2527a0f7070b1d1bb5bae92536596c7c4dfaa80bd66ef9c5cc6fa60ffc1444b9b63681ed967c265fa1c1bcb6b4545020f30646ffecae7b5469c3ac822b8a0ee5ef33bf5cad25fb228aedecde436358b8e50f66e371b4145f2dc6b28b3d6f042ab1a179e31275bf94dd7bab891e2d6567a466d2be400f93acdacbdaf2271590aef4653f238a500d888a9bfbc8682d4c8068c0641185dca6d395727a8023c754baf6f1d643aff22187d10b47590104d8fb3492a56cb37bd849827bc0575f4a435e518765d69282748e85a420ad5719e05bde6066a217130b75061b111fabcf4cebe4715052c6c92010c9e00699ca18d620cde10cc777af4a6452985b6d5d102139463c455c222622d9903a01cbe12dec1695fe0e3611a84535fbe4fcde021eaaa2e4c7254b63ace4f087ca296c067afdfbe8be68f207d6fb88b2b1c3ef0295f60df20df0ff87eeef6d4c48f6460b0ab2262d278366cdcbd5ead226d313273179e34b8e67501a699f39afb7d421f92627654f7d88ecaf7fa2a900a275086bc7a3c7abd1b4ecc81ec47f41118b1dafb4d3cae90bfc000652c0ec26112de41c56a875e76e3d563719b81e412ee685e4f92ff2ea23b9dbe762d9e84476884e6692eafac0e6fdfc4c52b2d6ceb82f7abf9c8496208496f671ee596fe92b357e57d4d6d352c073c8b30c70255790436de3ec76dc43d300f365140ee01c69f20b33c4be8c83e82b0e923e7170a8344d930ea0d06c80590a10867ee34209bd7d87e913ecef5a9a019fd345f892e1ac69ef1d3ceccbeedd4a1fe50e5e0d8deb239853ecda7ee90c12a95fbc38b94edbbe689232998b9df344258e100bb38591082d18d24a15a59f681bca1965c010582b295c3ae1d468f84e016a8a526d4912d5718836c7a787877c8993780a51ee29dc13bca67a0dc0911b22de2146b63354d3a96a955bb04d003d9f13a58f2993e21bef1d58e81f7df977a3b541d222bb8b70c8e478ae0837fb6ad5ff6b632d09a5b6d60a61e15a50dcdab5e93874c077bd895d7e67e9674be19f8b648c14464bfd924cec928ae0a2b787fc78cd560aa4fd2c1c73a424e994478916d3408352c475b618553eddd7f61d8d119d53719285cb4265fa48a266abc491d761e75ba8ffacc849cd8fff3c0d0f6a1fb868267caac6949ed2beaf24cae9df6177762ff7d09f26cec4ae40b33579bace9202f5cbf1ecd6c41c619f76bd23a7c2a2001b2476fa8c7be936b3ee2dc9b7586435b70fc2fc222a7679b66bfdee97340baa2a81bc0246426059a03ea0a1c64cc100a85343b37756b5875b10ada1919e6ef00efe8ccca9164d9fcc0c04f87fdad56988a183bae45ff59a94a325101b5ba20293d60b09ed4b89efc91491589b92bb9f93a7a592fe9f4b9eb7da0027b7f879c837b4bafcc83dffc30f22ffc2f5e93019b019942a34369b31e665cf7c445d1fbf899e0d9d35479b1a4b6249b42236371d322bdd9ba90af2bedec95e2babf91efc0c1126f07ded4468a7170c80c39de02f4e07cc3b09d87c59c2a619fd6826d413207a63f5ee3f0adbcaef3556c87b2f375abd346ffcce4014651cbb9b3890537f5a3b7d1a3ed113ba581aa863aa1e9a18b6ab45ebe9da2ec15772f85b3439a3407643725503c8ae40f69a93bfb64f7600fcbed2519f427187cd92b3e45c590e8806ea305e6e2fe9048dc00e6f42c17d884f9f8b2ec8be1ea1a59fe2cf8afdd314e096fb76728c60022b0aadc27a88e1737bd462de8b7bcca07d0d0f44a4f8fbe5c6431256caaae76b0a8794fd8cc052ae13def1a55bb73a211567a9f0b578c1b79801bd16fd7e504d7fa07569ab1dad3e2fda2302f292e75eba7fc14b85caa2abf668649081b63268e92e8b2f9c6d0cf114ba61c5228e4fa23fea2e06a5f4abb7050ece6c45ff78d3fba9afc0f73eb447ad247fdc47f36040b2566e096c195062209b6cf6d321f21153cd1b01ed2cebef82f94d0bee31bd888eb6331c60b16f7f7d7f63b1e887d377b25ae04dfa2df11e86d00fd05ce12adc02a32c7ec11c7e1d4f4e827ce246b982d9c5e6f77ab07bac24501c9f8725c8fc5c459c05ddc63fcfe857ac0d11ec72c73bbbd989f2cd3ddbc1dbdca7d52e22a48fef4ecd1fde62adf667c9a8d3779c5509c4c1a5241e2c530b246845df0897c40ae42be570677b62faa393802326b38ed64791796643bfe45852e498fbe21046a7f0cdeb3305260fd340aacbc65049eb2ec45eeb3c91b742a500a1fd39ddda5dff00cdbefd781623e791d9b9aba71d65d6fd5764844d0fa2bd831542364c429dd960e298d8b5cc71e43db8be145041ed2a549c833c87606e21b558f18244c4c48b53432e7be15bab40ad8d2d78d9e1a5b59aedafbc8a0cddd1d827287fde48c3feee6fb4173224e3aaba5207246eb2656169ea725d825c3b6d684554de4148086edb392cac1eda14919cc8d1e6227220f271ed68526c3a45bf9f86e192d7e2b43f3837547b09938db483e1c65206abad3fcbea940013ba188a2cdd1c0bc38e7708d19d1162f3b761941ca229b3e21acbaa4aa9a9f863cee3c3f749fb79cc2db6c087ff515b285f7ab8d78662b15b2ec4e10979c48ab37afeb43f7209323795e0e2d774b7a836c255df56570b750a4a07e05d485c83c484b592377a747b866314ba5f3b1bac584c7d9296f1bf289378588031b68d7cef161a7909f82797ccb63510bec9e29acac1d179ee0747ef9901c99b29ac348a9f2620be331c32308d92770ce0cf8e08a7f073572a8047ac9744428ac8729a1f94066d2303b87d527d665b7543256bba538784338b9928df23535d211bd8c58875e7827d506dabea79cc34792e46293d83e9c20b20ed4e2885df004d06528ef065fc93750a92605a36e79b762aa7995a636fb1cbe9b33dec94cd8c1ccaabffcd3ec140732c7b4be60e48b1289c430527514bdb873cc33592153a57f668ef2c8cc3e19cceb7d430d282fca33f8a382671742110887043dff68e0bac1fc4450637ad42df2b6f63fb2fe2543b1026ce2c9d48247ed42f1ac9a296e2382f6a01c05f2062261ea8187c1d309ac20d3c2433bf2b7497d68c03d7dc52c9674235ed35989ea140d09b6ba32a06c9f43c5d5c30bbfc7df4855053c2c085550661b088df45a6fff817164cfa1797ce87761f4da00f6c041d74bfd3ce93f6bd56c9d75c1db050d693f7735454f010e25426d8a448ba8542517c210bc673ab12ac798a2dbe3fc7859bcda905ab856394c0b463562fc5fbf532120a969f7aac2a1972c1767ad688cdf51bebfc22015bb8549d3751ac4670edd9275d3439ddf474543c2b4640afb515612721373e016dd4d93a093a9c5233c4f4b150de37d81a05ef89bcfe811de4c15a17c349b633899ff472cc6df81db0c941a75ac43178f2902baa0618d7af4233cc098173673dc4cc8cf9b4c15770d20876d5aff6a863f70fa99f5677855d95c71e87c4fb995497dabc94c81f9e36d5e437fd2d348eafb51265afe44f5a97ca12310e3ce3932119bf5d2e68ce09e6711a3849cfbaa6875f369d3cfbd0262cccd4b98336d8e79acf340776ad966dc03cb86b50123318a6ad9c910f6eb005f87766cdc2f46117b30b359bdd323aec4d5d7772b7a4df1943798e6658d81ed34eab76181b372081e14ec39e295bfc13ff94740235f535703f82d4df87ee4916fd2a239cb9a32c8b45ed11641f0f069033a2ba568f1725f2c77a509b587466ca8620ce996e389ec8aeaf7287468d93b6e242d1c2862dcffab39f099fcc4c82fdc73fd0258051a79d3db904761bad6ad163e4a0b20194ea39e87e5686fde87a30ec23752e73905326d23162e9779415a2b1cda63d808db47b0aa1e7ff7d9144b48a3081d6327bd0db96d27ddc90ef8533201c5afdc7b7f746a31f55cc1d19ee48cea45aba6a3d8765f3bff4fdea4b36297b8c742c30a6685b078317e4fbb10a9bc5013610c57fc670d0b8d3a64981ccee4797a22d904477d97e68a2b77b6a1747db01608663fcfbc8ac714ccee1f9dad73bae70bc14decfc8fd385751bc383b505d3a7fc4a85354d2ed4ad9c29cedbfa60b1cfbe30f7792e90f2f9017e41193bde14cbc8295b0ae7e7091afd0c9750c171c7129a9396b69f6b3782f83ee1ba5d62f19e5f91e3a15bab990f09cbfc4be7d0cd3e09f7055ad716590f90d76eea907a7e557d1eece992c9c715a2911e448c398527a59b7967921417b4a215ecce7f54133ade272671eee4b932df77363563970aa3d15d1dd62607caa84f2ecfe7d5140a55d7c7aca506641850eddd5471e3fc12cbbf1a1225c2238301b20d4f39be5be2edc2f1fe4c9b62d9ee5a61328f5b06c7f54ccf1e2bd9c4d68000fd21e44ae546ba901841204c0499eb807c409ac49c3e14e6d9c3c1662e20ee2918058fb5d6ced4feeb196cc0324847cc43d213fe9cab9a34f2f7b14e9d6cafd74ae7e0b894c02f11dcb083784b5f7e59e05d38a96f980a69259c638cdaeb40ea0d9ac185b2a3ea82d39316439556e08bbb5412ae6f533d5417b1868ec44d07ce6792fe93ed76aaddfd1644bb845a0fe5bc0eba254a48d6caefc88725666a927a2a637d67ef07a4501793ee8c7d5aff4f43c86de864506d9f29c1810563c14d6caed0a79f25686f0e2b06c4aba78db39c6a54883d1f66fc53e12741e9aa8e5ae6ac121edf544d32d554deaac26780bb14a9f1fa136efefb6e404196d5ffd144144f15e019baab67f70e16df8795785658aff23cf8fe5452de11086e23285c25566801528ea43c71c6a13fe938cf7eaa24b6ace5f9ac87e3d992e0c57558a155e67fa4b7231628ebf5d48902dc17045b967f6795dc74ca87feedcef3cda444420860257492052fd82750ef20270c75483499aea40759e142385430035f95c3bbf4110c8b4f7be906d10ff412893d009fd74e84dfdefb13c97f6be208fc6cb73445932f6ea8436d4aa33407548537e399a4e15da0ef59575129e80f2ad78a800ed481d761d78e676dd20724b9f1fc2e2b6349085817cbda47f549204ad26acc59a3a0ee7239336f3d71b6839d1b6afd4b8802f02be189ebc6cee53126837b284403aba6a3f05be689e8e29cbaf48cff6ab788b20abbf96ed1b448a65939fc85895469612d3c87ed3ffd828eee796110ebcecda5085e32a123067fb22541cbecf5d676be709491e86cb7dd24ad832adc35fafd721f666fa515d0375cefb984d74afd24f73b31c2c7fc0f4823e498a595d2f91ee9814a8e53f27c16a16d03e184e8d34372b55ab1d3f84b091b5d637984709688fe065473cb9e23c09324632779be8a462de91246d00ad4babe73ae9e8bf824e14f4b547811d84494aca521aa907d594138c64295dded98b17f98e4103d9e7a14ed0c818b7123b256bd1c3ce581dbc34515966dcd31f0fae8a5d31fec6ef0e0b057f0630dd8e83e8275e82bd45f6cd31688b6ca1585bb18988c893ad87b7b7643f1c37db0ffa1920871bdfc57f40b7b3e05200d8dde45a7681e3e44aa90b91678afb110368894b172cfa0eb816e925f2354191a35f22525ca4238d63c9e38db08c5433b5ced99ad74e1d9220934e1c1186f503d1a9f0ba0adc2786bc0cc9c2fa72c0e8b58dddb71ca8951a0ac282536db5764aead9c48c4c66698b54a4fd7595a1b2869482982040b371e72cf29d9e8c8330558440ff221f01af67eb05fbe3b258e11eed7e43e682b3f18513f498278a6ec04b926dbc2662b89ef7151387306fb35f813678d11253375c96afcf35159bae05766df06f58b3972b407c52f361bce34def8140be780e239e759d368c3dc19ad9e77af76770362f3d516e8796276c272eed85d54c8dc9b284ed3d8bd06164029507e8bbeaff2d907ce01f33818ff005d1e30d5bc3208d466ccdb1f400e4e63d24a7fa3668fa9037ff1fca62a4718a73111b6056d26cdc37fa5d94d936df3de70ebfdadc2c00e51627a202b72bbd474cbbb27ddc8c7c23286f93d64395cb925d85a7a8753505f5db59b8ebd41070a23d257c9242227dff5a68bb90165e1621e8d692ed22f2df1e70f506c354a59a94a89aa6461291409726d30c91ab9f2bebd586a89b5b18e20a63765e04cc1a4e6b862fe7aa115e73645c1fbe0aaa8ab12628c2a5baaa031fa02f377219d75b1f78c1dc0e4de223e0b2180af426bac8bf365e7c6ac0b56ac065975fd1f1feb3d929e4f7a9a076cb6b0da21daef32acaf04d76d004eaa056f4b2343249f6da1d90423bed4e74a6c8736a20bd53f4bb0ea6a2f4301b4278453d8df487bf9df948874ab5f4fddde6c8e09a321833bc10157b67ea230762cf3c4f340978e13268267607b5cb414d80d01c81e0dc6b1e0869612237196fbe34bd4868829959dcb5573cdd6f14a1a0d9e8d04323896beb77eb179683eac4d42fbda8aee3af1954603fc414a89e44c47cb8dab43ed37cb9939a2d5f093d3cec8339e8f5334afc6ace4fba7ec81fcc4f4f1bd00dcab65612320a5e530a596a4a18fa5748f92d5e7e17412c6b4363beb8fb83e4ededbc03b49fd86246d65815d57824ea88e5cd4c818ed4be17904d484dd43bb390b65e5fad34bc9dd5d1d3cfd8a168e5fbe8175374f7ee88a1eba8e489d4de06a33e2b0c074a2a2a240f32661308b8cce34e2f16070712231294a8d91fad131f8c3f7c276794ccfa73bbdcf7fa1e4a827f8d4b041a9fc922197f9532daa2d6c5cd7a01df4d554f05b28bea492b1a6d85954e009211b3a669c2915929d149558feab4e294d76e99b9c2576518d2145159a0f3f81dd4053dc781110224c3ebeabaa46947afa9fc1058aa86e0862c46dea4c993f2b8f0d187b7222647f9f885b5c293444b8dcaf6ce0c0057d613b2387a9bed32b6c6e20896fc39fc866073529592e440ed407db292d13ce445f8826db34697ddbfd136310d26ab2059c81f601ae28988f8a89ca684b973ce3fbeb9d74a57ece2f2036477d7f5b1ba4e2fb53a10c628461f382b7db74f172a5a29adac21eab8787fe3d2b46c70197b30bffeb33761bf3a1648614cc2d3cceedd491c54a694e53a3206a1b970c271e4112a13e09b09cd730a45ab6783fb9343d0bcf036c9fb07c8813fde586a1b4014365b3d25893f136ea54708b0849121282f6d4d7f388757caeee33afba2159a6ac92b6b30e5dfd68dbf70329482426932dfe0a63bf87cc742fbc7c4d95aaa32b80c996a658917d766e5037b75d490947c3fdb13ca8a7f85316d7efe7122898c43df143814f080cd4d92dbf2a99dd5a7a55a03dbf6e0c5e0f228eecdc603235bce96da2aa771cd473e2d6236208f7c173cf6d3f9380466a4a6a1b45fd62c270425452870b8f88f0c25623bc0d608aadf7772e5f459f876a12924fcab55a0f087628add230f0940f3444075931cb298d5a29b2f5de618fec8bd3713ad302bd7527706157d87971899291aca45854e9d5dbbfb8352b7b6b795e5976043b0f65cdb17a49edb36423d60024a9d001f612e9b3ccc2844309a428e6e749e4d9ce8b20349ace07820c28b8ce78b7ec18050d85a99a3bdf9af49f9e89044a5ab63e428e8981f35f8f2cb379edf58e91a22826251f05ab08ae5126f9d3fd38aa8125710525c8ac56eac18f5dead7c0c827c0a4d1777ee5c5ca1ef93fcd71df9cecc651da5556b51e05f5bedefe29c36beb1c2fa2eb61b85f5f7ed8c2a075fbca6c6bc9bb4d4804bfb8da62ef6580701d0009e1ef6ccf5b45fadfadb0c25ae1980adc2d76370bd167ce429de5539ba9cb0aae22bf2dc47118280124f8136e9c4237f629aff8f19ef32b4d76379f182f236109796f7943bb2e372f21645eddb5ab73ef5b1c069fba22016b272198867a17de5ad7f085622b83a6180316350a0340361b856dab8e228ebb5ae3204a07c3455c403c2388418c464cb58d20b11e77f26c3fca347f787b45274ab99e1a6719c84f55e0d283e4f355490f362dc921bc2a6d8e35f4294413e01b20be4e553e45dfef500b8a927a67220051f62d422f03c4f2d410d511208414f68ec9c80fe9fc12d329d97e1769d9355559e4cc2220791dfcdfd3e1deefd9dcdb265912e8a362d7c3a682d824070c31961a6ca3f49ecc9142e431e7d5fd94c322cf3626ecd8eba5b6f5f21633eef6535de66494aaf7423c6e0ee08c5c29c9c89664c68df4ffe1ed7b3d2135329d12236fa091d202fbc4a1bac435610c0182e8b4b3e43013458d9f82e23b32e90b185e129b747cfe6a46784b54ec573696fe6cc3a7a8b0ff047403cb7fff9addf70293ed9c59fd78b52f55b93c978dc61b657eec2dfeafc3877c30bfd99e0f1aab2e3fb6df94f84c44f1508fe04494a50f768f391db71d45765a22a7c99f4ddc291048357d004790abe743d88815ea31ded273c7071aefa3dbae10efd59cca787b69b6217988f6304a54d916f757c852ada843e681a8bfee6dab5e60b5c068fe7e8bca6a647e9e6847f24ffe9c68cb03d4bc499dba81af5bc5a6957837899812472ee35da9a5acd2de4095eacd063a97f2a82a996aeb3fa283aa5947c5b4a82b835562e4b6e355f2f00195856002d373ef9caae1019a4fc30cdc0c9a35f1cad14d28a26941134bf542c6816b6ab8c7672a40f5746c78f8070f1463088d657f1ef37cfd6f6cbfbd24fd144d9faff93840b438cce9636f8fc7134edcc0d3a7254a0bc0c18fa3fa65df6c74021fbd9a473c2a244858845a5cd24c73ed385225bf52d0f2d339f837801c0b25016b9425c396aef08849c95e01e467e7b1e475b4f2140bbf98943ad80c50902e10ece1955106388c21d5b500fa1e3b2cd30e54428bddc052920c0b1b88cd3a2e03798d16dbb6c72a7fcefe06580ee700764f53303ea94ef6a4784a61ea9f8bfe4b1230c2ae42ebf06c2ed01148c4ef6a4cc96d214ab28ae833d035f195fa19a3c4f5fe2f8ba1a45463cbe8100b9ce45bd7872690e20937e9d7f0459fc1226a1076899c2bb99661324a70f107c5843b73134b2e7ccf78fa7dec3f9dce764d0d48d786f8f3fb97626ee1fb1c68ebc37f4b1fa8f890b47e50843418f2bec50728fecbb16a56bf0ffa0db6f3a6cc247a2c48eb92f1b92ca8cb292da05f430844fc03f75ca3984570ea9412626d254207cf00df2ac8eca92c06ba6f045a97b55e449b2551fe22687d26b8248534e3030d6d8184de81ac609781dc09c83711f2d5f7e36f971f920c75ae3ab349afa4a491f3746592799ba2b7e0d7137088e248ec4d3d395047b5b1304bb1d7bbca095a85a451787f23f09bae5241ba0f172a5b899a8569de61067e53183f7d598cc5677d10ac344730082ec7a1fb1938050bd02bcba9b585e9b686b6a970cab65bbacce65b46c3da02df59da3ddef6f6ecc8fbfec01a57c8eb0e41c40cb8c5e50e0a327fe6c9e4065a8a3759cf388e315a67fcfb254e52f6d50b0c4dbab606cd88123f967f3dd4854e5a0755c4d6c96212c5256a7cadf7db83fcbfcad0bbaa523662334d902447125c2223a6dea7e82e5b16f74347c2bc14a2b93aa4477adebd30f4aea735fd5552e5e237a75e02fc58d02354e03af51662891a9df4f3a1009ab380f13443ccb6671e08bc404b15a55fcfaa1dae5e552a57fb247eef51e1bbc676b89512241e517909df7886b88daf2eac6306f5e14a5dbb485e658306fbe5b501cfa14e2004d638c24b768eff4a55c0d7a7653639510a4d6bf750d335aa13879854365cf1431e0fe56ee6d89348e7b80789fcc1e9c1986ac97961a31563bec06f926aa78890cc4ebaab09263aeceab19e7ef75f869f33142497c079260401e583dcf95f9a86b5417c1c079a5d511e0561cc3203a6616c4458799f9b5e343be638c6b7f3493736e1fc0d154a0bc25823ba5292b99a6a666e45e844a41b983fa086c2f09f38113fa902d141dd06acd8c02990e0c29c82e35f0a34eddd109b275529b8dec0271f719f687b66c09ffc0967a7ab7030c2fdf9b07c69150a69d995258ecc6b00acb80eef798645c969ca7bd7a51ab19b86bc9f8e7c041f19dfe9f35e2727abe851f9697c2c81f576b9e82b75fa5dcca41c9428134af6dcf8424db31ba74de86a6471c45d53455369632fd59659cc047a182353aa02dcfbe5098a497b155c155ebbb7c8f46ce998a4f365d570780ffb553101cd867eff4d9296fab8ddbff134720d1a5be5412358c45af574b4ea9b2625826b3329b28dd78d8bfbbaf186f7d82d2c39bc558f921e81e5725f3013fd52a2de366eda851f169bc35fa97793e4f5b46c7c19b459e7f73d37700ccba7f35a4afd0237dfe8dfcdbaf3021b1b9dadbd22b3f1d0fc343ff661f9317d7e893e818d7233b4bfc154a6db3ff63d2dc83180196d4255e52179496a4f8289eb7e4f4561086672798b91a7a6c4f11709a446c9170691adf36cbc2ff0ec42971c1bb1a2c750f793d5462dfd6f698ff2822c754c05c383b3d449e58dc718c268f3b390f7df575950d327dd5015af97d55f5b6c6132c6eb6082b91ea934b77b61f8b473d2fe203bca9b973574be0af8b49fdaf0b04eedcf789e852da98f463424bb4beeb6fd7517bd18bd16b637b22298f60dfdb7bcf114a362e09b83aa66d79a372a32e193b752630c7ecf960278c4c76f2e1f0de91737edcb462a4d6ca85f6b07077f95be6f5190e403c06e8cc62a2c70a244f60864a017c5fd51572ec638f9620c43d744156d5c1327d3b6c36def361c50461972a5d82b04d1c24f0888d6e79db66f3faa684491a13c43c55740ffa41fe4b81ec7ca1e573ae9920d0a32bec10f39a2c463f0a8968d6b273e056f2e35450b41c9ada95c3b2d4fa833ecc4985d1b4b287ddc335d0fde4567b9bf4028bdd41447f87e7c0c72a763f9443578463b5df6d23b0d355b3e800d2575000951fa882979e75d6f80cece05a3b22f449c3391a144825f840ac1af9560135c7401fa2ba0f8c7704fb7bceae47df1ae89de1a9c49cfc426091ea0e86cd5e6a0b21ddd57425daa46b5aff8431fc3fdc315645b727a911ddf32563754993fde536cf33a0c64ce0e7449632f44fd5ced3e0a424ffc08a0a9a83a0273fdbbd1e8a3ad0be6c684de918fe178e561dd242d4d4d36ed39af017be747f3ca2a11cbb386631175bb0590b837b3f0f806f53defe5d6c59548c2fcdc0038cda9ce3e8cb05acfbcbb6f96f69d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
