<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff94c7eb5ac665832496ec068d1574491846aa711edd3360484bd29140fea40d216e0a53e4cfdd799468a0ab5457b5b909c51cac6097d72d33463aee14eccab4bb080dc37d02ff4d818dd8983a83c0246df14f3885bd194720b3c994a6dd1a2115e7eebb1edb4e501f918f0716b5109cd42b4cf75ed171d8477eeb203981c585c847ba752cc68238ff77cc4fb9bc8da85327b34a8976bf5be88d97e6c7eb0e33f83fb3980b105a2bd862219464b044b7f1852af8da79d3730db1d56bf22b567e696e430e12b1f01db876fc4110916bac66d5abdb1746ff7a2aca35609b896c9f1a2693c206e5c290cd2c81cfa977073229d8e8c8fc40c85116674c3e36eb7ec4d343a7fc6cce43ce043fd450448823b94bc52d35329b396911a8bb412b74255caa2bd62c8a6f73237b0b766027d76ef1687e647ca5fad180f759d00d5c578dca7c6fb3f855e33db4160dbebad4af358910c6ef9b6a4812b29a37ec5cc85f424526d4c49bdba0ef577bc73f6230028cbb1bee45258beb1410462f7aa509cceaee62b5426b49ed45c7daa66133ea2956ebebdd3cc42816197c1c27ed84096c95c289248c1d01b9a7ade0acd0843e972b14f49f3a2a9c353a0972276df12abc70b9161965c1930cb5e46caa65f6ce426ac606115918ad567a6904968718cb26a0632c6577de309aba261484d47ff2050ebdd23cf227d7cdf5942408109534324d8ba44973fda30253390e5d1ee751b1d27adc01ccb6410c029b1811a4890d030ae09504b58cd5fb69eb14b61b6c14673841ea10dba27f852db7e6573ebe7c19c8290b7eb34eefd66ea051a821080edf1513831d21041664433255446c8bbfcdafafff329377d16be16527db4d930df93be4c071328dd853475a256ea8a378d508cdc7306945e576ffe50f0a5f6eae8b2024e5a786511ed1ac6883f678b1634d131f8103415e56d140cf7e4cb0cf568fdf506406ba0fed7273ddf85338cf28c4de7d4abdf13d08d512199275d5494823bc84fa94e650e0dc808648cf2d3951ddb0029c194456591834df585fb9177bbd321038deb3ee98218fc259939bc1e5c0434641838478fe4af3f196702165db5a9bcfc7b149801563bc8a23f95242100a4f2ad99ebd6de165590aaa9906880d4341e7b69cf62aa188ab5c010bca4f4eee8191c0759da376ba4ec47294585d78435276878d705c193bc92259b55ed8dbee9dfd33b9629a0bc32e38aa68a1fea469082b1cc49b37c9be6ad8aa19487bd85f8aae8fb8be01440609bcece9fb4748e5c5ffeee574a4b5108869b42d9a0bb11dab26f5d1bc0ebc741d0cfd45aae3347ebf2b57a74a609937c1ddd19aa26a08563f315f1c8aee3bb599c381662805d0c9884e82486bba26046115621d366aab255e005354e3b476725e7a7e8c59a9e7be145d4720537039cbff92e0c95848bcc187b7c0fae632eb5c79a9b1db4bd9392f8de4706e62d3c96aa6d9373fd2e2032671c56a638f1109b760a6dfd1a89a971f665e8119e5e834640360838cc459abacd7271ad65bdabb3ba6fdbc6fdd76c68ede6c13004bed9cb9f6204d8e31bc693e8dc9ad2ccda251739dabaa568ae6d0831e804fe73ac93513ccb16462d487cc93b71245b776f5ed0a5fee683649511f19be167a7887c6d191ab06793357d060527ea5d42ab6325cd8baf49780dc1b546357a2a12978c048321d1d5bd7a2bd6708654b0dd5c7ee5671c7181de085763b84768b5ca6980d32956937d9ed0b55c28facf54f1f117c6a7dadba7c6bc887ab2fd57c9814941148cd64211ce9ef9861191f8a68a6ec38c0f874608d6f068ec32a3b280fe7ef09acbcd148376cb7b005692201f6eee7ae52ea6f8584348e1a95eb92e5fb96b0fe3e62c88cffe887ca3e3061f7053a18bb30e475cda8a1c3cd8e5aa3e5dca4f7825c92102902cbfe5080e3f4fd4e879e6471bf823d8b0660b9c02c47924181bb5d5151e5c9bc500cd0eefdc75a1fcf7142d57cec7bc3dd6426878c103ab9f79776c3ee13c18850914079062b55bc8db14d9cffbf1daf0cd4f31cbe18f320bcc334abc6e510ef76bc85cfd77de9740619b7ad2a8bf3226389fbd869e901e41982e0054378b15db1d9f7c99fb72feb6c28f324017cfe9c10453cdd8ac004add93761dad921bd0eef41edac2a9d4889c70dd885a3b05a8e40df29a01cf17f319c30548190100882b55b4baf61f48159dbfe5973c4dabee8323aebef2dbd7d94884f6bb63c0db7d6611a15031b80b579e2d8a53b1256f0723cd1c5531c753ad16f4ba9973587bd9cd77ce8791d04039dc0d35d600caf0cfb354e7c381d407124f5a712d9cdf410bf9f6309cf863eeb4e23a94ead580e9c77167ebea2cb6438db0301a43b81da017fa147ba24ef924e0b00b9d0e3ef61e1474f5989b087d0db38f1cec62a45028dad57ae12934cbc05e8749811549efc448deddd6663ceac5f1d958fa5726dd438a64452320c1d0fd46c5d31d62348490298f099f5d61ddf819b9e7e43c4359902af44a704555d74c90d725c07d67ee3a1408035e7f9585418d0471c7952a8d5a8edc2adea9bc136fcd61d5b4c3c3d5efdd5e21f13ebcad60bd43cb6929f371aaf06497f5503f3d01e84d383449133ab974ed4fc6d77e8b8ccfff8d18e5dca96c02b8bc63d4c75aeef7424af343e8906e2b178fbc4fe8520b74c5ac794ed46c46982ab5fedf14c514b59369471e0673caf68d69283ab670c905e3d7c3c44f76324a1cf9e74b4b5c7fdfd2b424285c858c624414a37d11394aa95d863fc32d12fe5c3b6be94c1804bec657bdedc2444c1e6c4cf13f8c39a7c15e6ba37f5055cb42d45e5ca11b8f873b5529c5e30794cd54a089d6941c7d26934942cebad982d65a85633000a1d07fd4d95dff257db15661d3a64369f96f866b162db032d56f24abb055a1e557dc422de1aa69b3685557617f0a83f9c4504d79a4339eae0790fa96abbb1c3acadec26ff2fc62ee4186f8a17db90db36d2338f63b2d7360113dffec10268eac6e0df7bf36f1ade0367fea2c4dbacdbff1a2c71f0c4fffe7398bd8b0137c5e11c191d6fddaec9a146b148aa19c4f00f1fe620a17eb418ce392c328639ab470e5908b9b7575e1d0ab8ac1ed220fae0d748cb5a93f47d405c23cda0ba5424c04439312cee3ea10c0b15492c16e56d46945883e47c3cb1bbc0f547ba3fd1737bb4024e685af7e1b0214a573cdd37f3a22ec5f10f62bdb15f697bfad01fa496de67e1d351fc697e82269fd306d2ffc17eeb7e09b0677b37119852bc0c46a231e11e90af1870e6ed42a32b72f177a55be679a10b3e1e6e7ca652eafa3b6118bc0cb9059f7e3714e7801261d9b5b4fbffcb06cf48b948ad082cdc85a26120a9b56b60f673e74ff8fca17d1cc2aa99243c95404a3721b8b0e6e5258093d3a53cb125b5fd9b01c08a2af9f06cef957fda49aafc261b05a9f2220dc86603a59546d98951b03f608a44266b1468f22804d084dda2e248d5d9bff8573113d439a3584369e9c3e46d616c812395cba7266274057037cce78265e0b39d12b961d875e8dc2053be41967055a3853301c0dd5bb38ac828b6047e268b5d0ef081305059481356a6da6df43be53aa3b965446bbaf6a82e93c9fba188f62ff68cfe723fa66b4e7b15dbdd757376e8fc20aafe64a94f4ba62e2be2a480966d16b0053b4848ff1576a916c2541e9a69ae29b904faa630829ab26086a153bd7b72972cd503b58dc14f5858cdf568bd80be9fd122e1cfc3a93b07926ca985e47840912a36e3af40f982a4de33388ef8f23f6dbb018017c6091e719fc427e7d25ccb79be0e772d63da2a8892f8dddd3a4d4037ade052fc905d195606cb9808a8ae6b9707bc7f2d190ccc5706d948414a672f7facd7709fefae826929a163de7a759895f8ba3b82fc527b97b8db708675f444343bff6b6760c830fa62c5a985c8e5a346285fe58d739bbe9fed4a2989a71d9f422935388cd9f98dcbe7e7843c091bfbdf68b450a5d597c3077d8c15d428c2bbf345d651ccc0aac59f8c2bcd10f84041fae878cf79aa59761fa3e23a6c1049892df9d75e243a3b29564400650e97bcbc5313c94f4ff128bb142a1b517c2e2155a095e47263e072cc2f80fd608380dc4ad78536781c9827ecfa38e83a40c0c36933e6dfa3c32255c445f9c80b756ca45faf4bd3d476b714b6cfc5249aaaddb6cae8b93aac1fbd81a91400a310d0e372d919e01a96568a00808e61be6f403f09e2e06ee83a21d40b3370f07b8f2b9142cb55469fc12d52c16299387f954386d1508617b1b4da11d32c32136cf408db597fa92bd9cb1aa3ed2eca38da519de712dba19226309c76f972b7e148497e70f6e4e9faf04537a5e93d0892cb89a149d62e23c194e465b6f7921d56a331f4f9139e73f6d051ef1fafe61ecd7dc0a02b093953cd32f2b2a9c255ee587a319099e564ce467f0ed4125302305da84a82ebd0a7a4a056a9acf00e081d5783a29ae0a2bf8017b31bd83e1aa88bedcc46f6e7ea0d7f803d6a4868625ded8ab9aeb6c6d3caea619e5453dde995bb0f4da3d137d5e2b81b6176d01dfa219cfd713c6dbb60a602481f4e274e705d524e65ae97f330afdb5d176e0f0b8704b5535794ac30ef222704ca2562820467683228f466c81dad8328cc7d38e11e983d5cbee576ac938cad391396a904109e02c28c689f05c87f3f583e8f6e361db5abadec5d9e5e34fdf6cd0d6a79532c5ce2d84e3dd584008889b1999d682c91c2f2e1b245e80f66969f8c78c384f07cccd5147b6987eb937effddb6bc7fa64ff73a5f78f8626beccee542c321424836e8cc759e6e777dfa43237b3e4c1fc683fca48e8fd9ebe88794866411e4ed94cf81ce68ef4e437cd9cc5e227e9fc0ca0f265260f3803fe070e446d75f922a8cc439d9162cac66fa9085da3b30271f64bd699532ef9b7b15a0de62ad87439a530687e0f79343993819af902271cfcdc162caee8267d560df6a9c02c288eb42764611d8135a7e85ff21d3727f939bfd1561d76eed3dff2c2bb60573d04cdec8e10bdef17b3294b8375a8fe68854e112108f258fc431d71c7e5c40c9bf50e024a5301ed3091f063c9cfc09cb35ee92d289e2bbebee4762e71320551e5e9d72f0b9ba2582db5cf8eda8c74a07bfa75d6a7a44d285385ed919c86675e906192fd1ae5d607c86913c306f38bf30e4cf5d1c25d962ab61f770aed20c02ddff452162d8777f7ebed2cdea8b993270e791dedbfb4cd14330c0f0f7ee1c98e23ae1c148856c47208d64080e6bb34c8f9a95629624d914bfcd32d97e8175d98e9100b9c4a8d356654c53c167782ea0061947a2cca1650f8b5121c14a107996dbb9d0b2b7e5945b84013d0bcdbf4e5c650c21cffef9e288f79cda6143ff39791ae3c88280f33065a114b1566c77ff05d900c19227ea767421a6e61a71c63141cdb555a04ace650e635235de7535972588e793101e3a4fb9afe8e9654b7f05600779353aea11b435a16ca23ae9f686d2df37159c4afe14d2b4849640ec367220edcaa3124a31f44e4b6c75ec50deb4fbdb3e007ab622d5ce47c772a8d2ef126776ed895fb1fdae72a904da8340a8a1fbffc36ae3c12754140b18cc27f9b3de32c9985a3939d2aba3c0e0bf088778e4c0696a2472adfb26ef32a9455a81b7714536db00d89aa093e7f4381192a877f9576d2bf2e00ffa1c790779e7b2986b05cbc0d7f76bd4493b0496c8ad14f684621c7ecabdc03a2a56e855ffb826102553535a127924d82a55055fd015b7eac5b1fbbdf0de4e1e2b38dff615b769bb875264a61d570303d1c64ee00791d07882700199de7df1feead427df6d009e565fad5ee41db84e47c65966aa81d1c10196413c78e69e7f13a096ca97cd23140c457c313d19a90747aa5666f7236fa7b8d454da40695cbe3afaed6e7f2adf99ed4dab62a99f704cdb9582e5c8684ba2cdba710875358599439e53e1d2852aef6035d1d02d5d79ea38734c9fca57ddb1132978b3440ee7edeeae708f854d438b931b9162f2ae45eb4133f5b704b1fe16dc75bc34aaf37b06282f720b1f66e1114e0e0a5a9581be06307ebf25931ba92b37247e2c82325cc524ba175c80afc54448990e19240516612f7b4b24b7957066aa4fe84e2b8d6a983be29ff1d6af25055ecfd67c7969215efc88128f4a21ea17c1e4623c296e4454d65d8ddd9c96d2299ab95aaf5ac0c57251df2d6816ccb71af4e79560bc22d2601ec940591a220fa49b95aec05bd9474b87b697f8dddc67bb20c6ea79c74226cabffa6e03c111e2aa2eb225f0dc114d582ef5d6b5d8f4780231a489a0bb3b110399ca5d999b0a7dde72386953920cd0449d0695d676b3350868a6f3912640b06998face88d530b1b8e5c03777bccbf217cd84b9be6765d70cf2a7981debc71f2896c131b5568a07edb8925f95c4a46c32978eb2b3815cf3642131b9e6b3273b5bc148be01066a5c4725fc45b576bea399fb667eb2dd4fd2cd36ae30b305f0c7ab626fb5761fc9db443f7287a15bd5143b8915aa76bd94fc56721a0b25921fbfe983035a74fc1480dc01a37ea1cc2fb609e4355d35720f82cf987550017c1e4ff7b6c669bbd6ef43fbdeda1e94e0187308e4eebab7c3f3af33f4156249de216d8e7bd1665598da018bdab3f9a001d6275a46feeb5ee9bff3b3acab023d6d23d12eb27971504aa6edd742d0911f352911fc90073f612e87f110b3fa682139d42bc0d287c2e3cb4e2a328f3714ae62334657d70a267c5df723b91d6201414a18268746f8c70588ba32eee57e4ddc0aa5d4bce57f97352864df0dee297700dcdeb610307a48cdcbd20711787fd5116c80d508bd7c1c3ac0709f727310653265b885d11db18363820457a18181f92b58b2165a94793db1a45ea4b45146d111627c10b1840a3f172b33c722306df6971a090b1637b527f15f106287a0d9ddc83dccb6883e60c2b80a21a5ae92ba4d0eac6789d8cee5db9d6ba2b2ce580e4e6d57b4e53b93e838a4c591363296bef375f7aaa1f847ff77caef31b63a0023fb52abc6d8edf83c80a20aba9d4399522368088303ae84c756a0b4af10718bd404ea33cf86404faf2e0237e6ff3ab176559685d3aee3009456e6b5e687576809c5a3d2f17c7a74c4a61d7273fdd36d0b869b0a46f508de2f587b3436bab253f97c55fc8174fd551b7cd6208a0481f103a91427e214b026a7402a3e5f5cf031227e5af7667c7e643cbea2ddb9ec322831c89dcd9749e123b265356a10868d4dc3f31e30a78e9f7806e1b753aec7905d712ffa6e963a7454b976c36c5d3488ad332626a68959f9317ae1f6e8935ead9d0d67a060120e47a0956655af58ad33ae0d1336205bc822a20aaf8386ca83306f763dca68941238e70116d2cf7e9e54c0c27b224ec5d92f9f6ff67113657fba586688fcb1cc2197e605b2647bbd38d53dbd95fee81acc5d1979990d313e30ea384a3d5fab44d0ead4f362293c5fbd9c90911873d15967456dec5aaf1f71a544be751ed24045a0b4e363a568d1b033a70df7686564b2513fa9b723ffce38655366458558df5364be35df9f4b96355cb39482cb5c7d9e24722af299e914a11a23ee47c98c47443a1f2842ef20b1ec24f2dfbdc652f28b56b18d15957aaca97eeeea3e760860e0f1e4d3f24e9e6f0b7b2ea32bf71e854246eaec50372dfb32072edc2e6c62253856a7272ba803472d0e2f03d689219339092800c3a645745062fceda128d58f9561fb02a64c20000234270c67a3cbe8aa796ea4033d19764246eed96aa292c15dfbd72019f915521cd06ffce1d1bd5891c72e35e72746696d32be1f0808c6a98a162aca6738f71820361ebf71cfffc914f4abeb15e22fbc878bb2bbd3fc28cef64f5abbec437632b0fddd446a142df2f6fbd6b687d5e4c49675aedb4c3bd46beefddbb9f530f638448d28c6e7732471dcc39b56e9795d2d094a344f0ab563260e95dff6458ca181ce61f005f94dc19c5e3182e4b8de3e8d39d718117f4962e7e1a221db0e6164c83f6c5091e34c294bc1c0ee41cf9d395dcd6d887958711326e188a1d17a05eed9f9196fd4a975c0e043c8e86ae0e37aa8116e1cb1b959acf0d6f75352e904f0c50d90c84b6b2e4a607c59d25a5f0212185c4645b9994952527c9dc3b1f8612eff871b2414670b2fb7cb21f73527f90f823621be8dd91c693718b1ce45b27e99a2acbaffba34fa857f546da1fc5821f9896de9c1f30c6ea20101386131bceefc1c9e3646b66bbca2af7b571ed0b7120386660501019088c77d2a599d50bbf4c614899548b3e08893ccf7ab3785f5b6fdef08585b1bdff710e74aa1cfeea78663fdca86c925aa96c3b32b56639c10b90ed1ba2d9dbccc2e93423e51e9c5314001cea324e0c9c0621ff492b2ccce3bc87c99fafa73727042e04f8db6a8715e9fff483ebeab9d295cc46f94a06b6a598b2d7dce48e58d5ca1b9fd93123b42459c5c75d9fce2d2b3a557c93174c36d5454c496415c6c0f676d872540362088595df709af7cb6c12101ec6b650b22676e5a04e1df42c79143bb094eb6d8508f9b7995f4ee2dec55179086f15314a8fde73e02fbdf11895dc59f4c816efed712eec07d874684298ce679a2baeb00aadef4ae194d8bf147bf29854e684b7c3bc6636f842f64f9d09c23b16660821abb878ccbb9d3e50df24620e59a0d5c4d536a5b44f6567c34731265011b4a178b0878dc01fc41079df70b7b35ffde55373d4dfc05e181fc4c9663bd0c7833644f933e5d2ac4702caaec2e06b58e0d9f7f23987004f425e6ab4ad1fb7263dfca3ffeb7d4aa9aa95a0e9c928c463cae55f395dfd796b0f64093663f0ae248c8340735e4bbe4879cd27373b787b158c1367be1d04c2e67e229e158c44f803d7b267809c99c6797d44fb9ac35fd6100a11238dcceaaf36729bb853acc0a67443f352e4be7fdca3d07eee1fb54de80be75957754bc6331620a3d679ed14d5473fae8fd788d9f9ae66d89743f7ae51ff31c0d06f091a6f3b143f171fa1a7b78dedb22f2ec5212e04caf2bda74049b454238ca225550851073177baf5f72023d1ecf9171c10d1bb309320ef1d7f6d3106934f203d36ff2cca7e6786101daa871362ec7f2269f1155135657f66b7e5f74d5ba8d2795f2e64997203ffd53358a3c11668c5841fa99e0e44cb2440c36ca28cd6f8ba9496d08a2bf93a026ce15873f7e203c44bc10ae60edb2892e690b4f3d15bac789e0b94d71b110f4b1722f229d96614c11257b7240bb414a2717844ede5a033a38dc1f77111387ac3d051775ae370916f502a175a5879de6099d9f1c94288bf3cc1ed3ad853a762c9d2d8d2ef053b9a5281b19f3eb6281e4bfe33cb9278067df3ee86e441bd5199a48efe1cd4bcc7b17d946d0807bd9d1b96bc5fb8c670a9257a135a7a8953316248318a2690625ec128d88a1a8003a0c8deee26debb59d7e2e3d94ed9d25396d5d089e333562d7192b3c3d215ed54e6845d1dfa98889811fa151a537c15365a9d52b27d1f9aef770e1031379bf32424e41bc5e920c015936258d9c16851ca63e5189e4548a8c9c7709eec29928181eae0bb9946c9b5a4b37a10e685d9d58ee83f5fd026a0b38f0ad5acf976f1e09c5dab56859f1ada87505724ea8a290868640e49b4ec3772d37abfe7143893a8a592dceb5ab26f4cda8d72aa781f3df5199932fc86367ff2baecb8e4fbff57866524fdecb65f97d7cb861208dbe3066f5a3533a7e65c71b1ce5a44147f3b991b02baace545a36a9dad111430b1bee5a9ca12315e6fe6cf451e628a44548d8216f476108b4da62e91bebdd5d02dd5014d584287666c9290fea074710d0b5286f464fddb811d10e7a50d7ee3d54130edb9bf59a3f2913736d8569b02422bf2758fbcbdecdbce2a8bc422c1cda7c5ac01d0678f43992c823b8091e13266a25d4fa3d786a29284b1e024fb79c4a9b83138bd6490cba15e629a8437a1a4a24d4314919118ec64f8734a0f0eeea6a8701b60194ebd130bd6e099c108a1f0b766cb5125d5887dac8799086e4af669474032ed8a46686aa135ddc5618126becc18a270cae833d9ed3b6ff944f524f778a569396a61e147bb8d441df2c991a1f67c6d9923e7a61e22f37e5171fbcaccb6cf05d86889c8c2a3bf02a04b3744155cb2c748166f71361a7affd84483f5f11bb52a9679eddf9b4b3392ee05801d95f83855ea5fcc3b048daa533f2a5b27aa31480f94afb9e0e49223ecc9d12d08cbab5f667f635ee215831b53d61e99d11587cf98a6c9ae4b91ce27e7ae7c7a2d26ae37e5ee059417aaa89bbaa1ca2acf23796df407544571bf2b16a795b8aa41db89e8dc1a13a083b71c052f649a5cdbbdfa0807c29c387fa3c63ad9c3254f9b0f348db2e8dc4b449b9ef279bb60eb519baa21e37655fc51995216188c071cc9404bac48de0a28cbd0c6c25f998e817019ba629b59f7aa4d21509ea927f03680f8b0965f8bf66565391710fbf1889db0b9b30793b48e72d9a733d6053facc0578c59b63445da918f319644abfcff2fc94ae1e00e6c40326fa7c0584f6456d56bb8cda8ec24385c2ebbd6fd0cdd1508bb4e4dc79b4d7e034fca147a17cfba24bf8a2be4264a4074286a115ed6f199f68251074858a71e6157beda2b50f0a85c0363d1b66a90609d3b241131633d857e8448032f5cabd66f0d01a3c58cc00c601b7d96d58f786105b4df69b012042c73697d4e1fe498b5a9216b3fa97f0520eba3d16c8113743b4e461d48e15ab216d574a99058f8f63fb5becfd4784ed137071a4286a77725593e0db70c3872c3e24ad2a2944dbeb66b41a70c27a5b4ff910bf6e2f4bd0565d55651ae937fc04da6401e32216efc24ec6d70927875a70cc6be6465b6b7121c820a773c0d8e0c6c28d1ef364cd139473be733a27448edb8e28933c11097171085e5dc4b8a6412c4619b04d0d98c3781f9932c113ccf4b0debb71eb803288c79a5c50f06b39489a5e813475369d9192b5b8f577585af9320a7bc9dca2b99104dd2b28b55f719fedecfb53db932853a6db1105bc4866699ac68eea1d006afeebf22fa6b500c64b442be368de67a8372e7ff1656ee5af9e8f1ca46ab1f4f0d7d57ef7d81ead8aa993e0ed91362c72de28b171bcee1ff85c381e085d16678de1d99815f80859a0a5b00ab0bccf77c2924ae64e9abf3c5c875340bf56bd9689fec187f8de6b8e2a9d4eae77b0cc372d393cb864df95415a5ed3c2072494bdadfaccd0ed8e927b679f5cede2aea79eb4417ffb33af78619eb8956c232132f1a3fd97718f21aeb1f764b525db0836e961cc2b87272d4c4de04e2d05c5eda76a0144b0b6ba4e8aac3c7476d51a4b3c8d2c2f66e2aed6b282139a60f5e015a93819d1c3c327c42823f7d2ce90e27fb67c9809f6faf121b304c6346b590cf637be1353637cab7bf468370c37a6039c003b62b303fd46a9931f346ef8478328ce374866dfc955355b585085232566491e46f1b1e4195934fd074ddf718a0ee9d0c096e8b16483c6cfe1e1eca853c858c7507756ce4df6220ec40800a77c7d42bc95ae5a1aa4bee188a0ba2dae3c00187766d9c32d6dd86a8c4e85bd6e11cd2374ac4158145d3710df6f8ea9d5f87f3c8644dd20d6d03a731661353861c763ccdea1d7d2efd1f61e76e8b3a0cc3c7a0a76b5d470049ab1f379e9766d649118ef496c169a8831e334a8178e6bda7469636107b6826956b5c80af44c6508dd812921165f44a1053de51cc23dc56b9fa68951caa5ada30612c3d48946c8ca8ca5d3b3cede7aaa556346b23465c449a1a8b16e49039e1081cd5d344e44c402ad89ef3a4edd789a9f0321bd17b82761799406cdb0f39bc3bed03b8edb532fc342006f6e8be96735ef972dac84c00eab6b42517dc0b65a00fc5b3d76d2bcd066106712bef3bdf7d0b0ee43f7242ad3485af8637595ae684f06e80453c61066e2fa4edcff452972648cf8b331dc6233c1cce546a390748b3f357afd41bb5c811e1dda57acb97463c0eb23d82f1bd120a248fd105b8eb1f7be4ec1b0743a4e727dc9f7bab56fbf4a08c2a9a6044bb8e0821521139655d71718b4361b978b0668b7e8e5646b5b5dcd181d97ee9970d8fbcf43308d411e8bacd8ae7b53b9e0b0e6fc3fd039e1bb106572c2c75333c39469cef024c188301c5390473e946dffdee7ad3c590ccee2c4ed7b9864e982753f35d362d61d0815750b4c8d390a9147253d72fdeb7266b0e341c1279c39b0561a7c2be26d348c7bc7573008c68198a8088941da18e20900d741f6dc24c5d6df9076ec100a2460bdaa3107c2a80063318a8464079250e272b4d0b9917375f28893f69648754f0b23d09efd404d27c7d667383ce9552c6f735350de00c7b5ddcf535940ced6ae863ffb262c9270726374e2db46afb6cc72568d9514be8233a3592d9b211ac7c991ce8d3ce4e0d7e5eba8f43dd67de8f223a8c2deef7a14fc8c84a4bcdbd840341745432875e7d9f99fb5260986a5414bc343ec7e2dd56605e2611719ae38c1bd62c54eb0f7eda65f2681f6edb1259727098853268df52aac4b9d28af45afd8744dbfdc62735886697bc4dae30a1863a64b4f58ca59a0e384e935b4307033520b9057f16d5c6f37abacdaf42827eeab8b09faeaf1b99421bd99a07950a949ea636bf0aa96844b69a92c09f8401bc65a63a8ba1b6d860e63815977079fb2b34c3d4452b3dec5efbdedb57f5bc58960b67a1a14085d5260aa5840457a7e1a5e4252d80c6c583172a5664c85179a684169eb8e5eece4532be06267bd0fc4eb4bc0c6f6468cdab9609be7256e8d90ecad64f92839b652008988a270ec260c7b65a73cf570784a0746b3f67419aa708d34e1ddd23b52f83f1f05397e520c393405cc4dfed3fb82876fd306e84e0499785d60b379433e9409413aea3e749065d299cb7ec260df665b140ac707732619cae9a35d66aecd6e505af3707e8c078845676b58f0004861889efedc907bc3779129654915b76feaed74193524c0008b5c861cba8890ea5ab88bcaac0eb65c426bfa5d74e3984f2736067590a8d89841be7b007155a8ed53e2b598f6ef459ff47e9a154aa29fb9075a74a47546c59edb172a9f3314183ce27beb8b21dcf22cab9712e60868b8a6c05283ce6155ddf5c465929dcda67de6d3b192d0d289faa1e6a5660d55475fdc8a1f94d6f57591a5bc2373c825ccc9c64f9ec03426fbe61d02c8f48a26fb427e5cf06c9e6fa7dcf367632b45a0d8a666b1aed98f9b3246af3735823c92666e812d990882bf89136642ae96dbcba35c14a4902295ea391f65d2c250f0b8a6e6f383c2096e0dbc219a37c8301e35683d7bd4f2661295c5a3662b126a0a9effd61322af8a80356ec99a1190feef276fd07e2c30f53b62b60f978445c96fea18d125435421f4ba885a4402bf1161fa201e39d57db4ba24a3d6d517380f8ee2a6140a801980653ff072752add851ad6959c83c02911bd879e19c76f530ba7296f32e196c6f84925891a0b4924de779821165fac760e68ac6f977fad0b28c733d5c72ae028a6220d3df0a5f606386e9c1e12c89aa733b4eb8c70a08a562666199b919c0f3b76974bc980fcde9791049250cbf57ca00a64c619de0473c44e71283ccc12b69361a3dfc13e0ea66fb5d4544a44e79fcdd62586f7f1afabc3e56a628481d21f5c5f9e5d0b030615d1234c9c7f00ca2fa94a83a9db3b2d373dfab12e4a648ca8daddd82f5bc8ab37ebc86646cd44b0fc033b93082d3f5b21893abe7283a5b6dc6b57d239d23256d7a96a7c9f7c4161e913e58ebdf78d97135a3b180268ffb66cee12315bc1dd9d96263608bdbd87f416f47ae3bc0c308a34ed1100fa7a3f2c5edaf4842cb939b9412ccd64aa98aa1a3d566f7603f2c1e7204f93fd2f6a319ccf14ab2c4533e0ce89c6d277ce4aa96bf13af0919b972ba5089fed2676c982000e514b17ae46d73e1b3b207e5ac5c1ef92336fbbfa549c04f9b335a929a39c57e472c74b129b49052588ac53a4b7f1e2e8aea94e2c367e473e41a3d9018a99b863b728ba77ef4dc6496b74e28f3ad8940c6b3b5b1745af30f025b5a7900aed98521b1cd2cd30419137903ccc19e1185d23894b628b15062cf18f8eac65384951d69476602c65ea3dea3391a568bff59968ed6ccaa0d4c3f44fff186ab6003b3478eaf59d472db932bedb2e76f23c40d34e605ecdbe9886c04970293b4ae392d5f8a30ab896f993ac1dca50f2dab44dec833ec6af03b209ed473a22bee57b65af62874d8dd01200a0b54ea290a1c3f062b98271a9fd96035d3129f66975d0db3166fb89b5e4b249ac1d27efbeb9fe87cc31943540e633ebce0549315154a7802d0ce4d97c5d0028a21afbae8dd0f4cb80d4df12e174784e8aae947f773a68c4df60de38756fb70726be59120cf18f826db8e77df89b5e5c5b8bfd8b1f1fe92ef37fe0301bfdc9a1b41dcf61351eb3690305179f2a8d226c964a4865afd1b33af17e31b8851141b9470c807a59683b57d616fb3776bcad3787e352f0429561c962368665de28c00b7aaa3df97d3217ebe457c770359a25694aefee4ed1ca3b05a8f4619ba76ec7fcfd92b2135e10e53a7cf3b2541a6265ae236f5c82afc3845ed5271a163d623e76d345aa4f124f8eee4ff3d716cca5d69b40351ddf931556efa4e27d1b6252565ee21b04953062fc73ff09c135284a41178c1c0efecefc7f3ad0f5157e8d2cb7220956834849122cfb7e6ff2e97623af2190c0278a89779ebff455951d56cea6ad1090386551e87fe09f23bf32a1d7548a7352772ddd700d4b1fe23eb7caf0e0085a779ae2f37f70d2be22a0b1502a36e1104e4d6c5f8a58e02bf31fc97a2ebfb6e2d846ae9be5c281d02d87cf2a80529034ec12a78e9c54013a4417dd63ec8ee7412b739568880b6096c39fd26ace0031a4c933f2d2a787a1cd1aa2522ac5dc0ab7fa9b664a07622f2f92cb9075581ef7ce302438be8130c8da63528146808356273822652ac441131de2ece9c7c5e2bdf5227c14529e189fe5cc552e30cbd661bb81167e3cf99b251b81e09d1769676bf09a4b98bc7099102ac052fd2c576b0c12319b6a2f586433a672e54a905efde462be3946fa87479f57ddd4eb13b84266da74e35f4905de439241aa30a593436c75498e8a0855651e304725a8997ead041ccb351b859b5f479ed9127e2dff69e3cc9532e0f0c753c101b3d415c5df06de76642ea04e6cc910825b3b9831d8030ced9754316560e7c60011cf3c14d2b85ba80d38cb337413f7760c5dfbad79925c16cd6b5913009b4495d07c3fe0e47fc2117fcd81d929f8b9342293bf89af4359466e92a9a167285d9d9ed5e1f1e4eebb1df5673beb4b90a3ac2fc367cf5275c3401672a6c0a12d30a95e7396de3d8c8fee47cf08f64459614485b2c4998166b446064e89fe3b7c42f2bae5f51f02ec08b16951f7976dbd1418d6632dcb8537ca46f60a75b17dc4659fcd17cbd0cb1d296c4371505e087f6aecf69ed9de31150bcec5fffa19ab089b08002a2740d1cd437fbc69de40fb6c0fa0fa5c32c3aa16f2a78cedd02e9418acec36c9dda9495b894a3016b9dc82be0cb8f72ad6bc8ec4971ec1359bc8ed47d56d9797d47dbe3e8cb70c0d368d8b002d8fd8b1ea01afc349a76c1e96d77dbc145fd8d3f843a36240338a1517213c1a84b168a978c90b23d5b66cf60789e9a3e6e310ad49abf042fa25b5743f2257fb682207b5b2d38c30ea2d46d1712b4563f3c921849e460bb331df1ef066a5d2735ebf93cd2675107fe60b2fd05c026a14070c74db053d32c10c64b51c22bcf140ec81dd581b7feb45f24bc36a71d54cae6f00faaea11a4a08ab868fec1643daa130dcf18b291d02ad5e12d8a4b028a38cd98f8e1bc683bf77b2981683eff5772fb80793e0a557f11b8ba00604cfee5b2a6b2c9035e8bdf57ad262eb6ca7253e310c6637770a42e14a8ca79b5220620aeba776058247a81cc6a22b2b75ab1d2d6c7c955a7e7fbdfdba13212773d21931e60710d815bc29feb4fcab13191ef558578174f54f0875c2c37105aaf6f3dd2e7ceb947dea2a0b053caef52e4720bff67680353750a7786a306bdf5fe8b539d749fac71a743764a1432affc7b54e5e799414ed7e45a510e2e3822c58a7b7e73a3c946a21e5a7806fb1670d43993d7c412c5e215165fe43b1800ecd05420f5d2858d8ae3f647bc4913bd383660b3291479c011177f3d75da204934f8cf0802f148a5de02ebe834750c3cad89b77d81ab1d9381b11494df7846b04e4ec0e1d4889b1b7ffce96099a1b77db7f3c018c853e63b6c8d071d19262ca732fbbbf9e969fcb1089ada545feb34c80203fd278de7b50753c7360b026872552fe191b5c5e4c8a0b77d50dda9f8076582952194bb1ecb505415ea58159fd84f0bfbe16ffe7e8ae0dfed7e27d2892ee200469e608d2933a3f013ffe40c0e9ed6c5f6583b5202729584288404d3b26d7b721e72ff2d2ae1ab5e32f1ce03d50f52d364bf44b350defd83f3294035fb43ee158016fa3aff54804b0d884ed3b634fc7455f8964427e7b60fa295a85c42f89b4aee58ab9047576c0f0361f72b79b403868b2ab666f85c2199566d55391bf1f8a01a7a1e46d2c827b47cb7b5dc54087b400b4dfadfe252a85981f2b7ccb12967cce1b046517cd850c963cbcade3fda434c3455caafa22c874d84b1813be3a98feec8d68070930dfba5269760e1080b43eff62d1ec4afbc9cbe9dde4f4cea60a7fc064394952cb52b87643e461128d185ad734bcdb9a23857639e9ff41f7bbacdf3c702e047ffecdaad83508114208696ae73f024e45d8f6c007dac01b51c4ba7c79188dc8f3867fb33660ee6a3ba183ca7601715b8b3db02fb2c299c9d08155ad4d5f180b988980a9638ba7ecb54242c882af215b794e284983a150b0b7a0c715c3b8246c363a8ce6e26ea72cd9f2852ea1274ae773f82b933539007e104f05b0fe0a4368ccd99d63e06fd290f2d6bdb6002f521fb66d8f742e79436b1025900fddc48cc443a9edf724d19263cd461824dc0b6e00dd16fe67c40a77f79cac8e55dbb05e8e7dfb309d3cd118c79af07bf1c05c2e45819a8d0c56fe09f70a1aa0417c16ff4f52054ec8e1408222df26fd66ad14debdd367a164380cd6c19f5dd1b7fdaf045ec97f90c217317f35792fe71bacd4a7386d4d749d03d5e983d3989b78e5d3dc8f7f84c284f3a307f65aea6e25990736a486f580f64b623410aa71415bd114434536491c2afd71cb2451961b4109ebf89364987c4b534f227954ecdfd003f8a167394a6f57405077f7e99c5cfd1ba9e472a2ea0cc84693e2dd13ccce02d32d8a79314a64336d8cf99c9a8100fe7fb250a46ae8a30c303bdcbaaf5b572cf1d1c88835e853c3331c1c2cbb50b84b03ef75090219fe42d6a53ab1cdb9f197d621b5e6d6da07d4e16dd5bf71ca9cb6088f76a6ba0bb88c4d0db9b493d8925cd2d2c59bc703fb395a714bed19e7eb3a3123d14d9db863fccf4702254f4a164f90e54dff0666f3cb1ceccfac374cb92ba623868e51ab916520da6cbe4b4c5ddfb9de08be728c6ce1ebc281f7ba1f9e6ea7eb83346ecbebffabf233a06832778da69968ad1880d7c4da3068e30bad661bbc807820fe10521b35f76ec9cd1434dfc5ca1ac2342a01bb490632d93088abd5b640ad0cc2b10e568f3455c54ff24777f06fde5952be0e53a4b670e206b13d71bbab1723861b1091a9542800da7241a1fb02e1f18c1564062f0be2965798f40426c10da75da8ecd7d10bd214c2d15a830b2b6116f8221f25c5eeb2e5e0c16fb73138e298ecffaa7cb42d71c245751cf0efa8142cfee5ba35accdd30d32ba2e1ba74b06534a96d5ccf7af3aed1bc0ce966f27b981e35720860fd0b93708d80fffbfb7f4f9aa33685f9d08c6f31a9a3d71bdf30fa4a57ad9c2b0bafaea3d0384d550a77308","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
