<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a964a9baec0cc4218cdef21b07695fcd88f5d831551f832b580e6b9869b8f70c02a87c3ffad0dd155793f1d8f9c749eef0c70db381035679744974ca855e8054134f2539e4d6e306ec78c2e8647e4e996598e0022e936a3d83e6fcddf9a336c3bcbd78e78b8563f82ba62adf8f7497627881ab9099bc9aee5e03d1ad7981e0ea690f84c1ebc405eab4f836d5cd26a19f3c06f2035c08376619ccac87d38718282392b9a5ff9d5fe90767cee0a87b1cfdd1fa08cfac7f8f191694aa7105f13d422a61faa3f6d25aa0254f817961881147a1a27bf63bca66cbb0533fbbabd08177be876bcb8ebcb598a45379513c6d64be53be1c4de1106ad96fee6469242a3dddd99177730f51872f7e604439623065d18acd5d5bdf0701f7eba8fa43d8028c95da24cea56d4947191d2cc11abb2f5656daeeb049273b65c9cf6b48179c92fe0063b21615a63d3f5ccee2edb425761b63a7ac532380339e0db7750449f99816df627b2e6258f4468d27ded606087dff5f9464556192a723cd55b5b02bfcf3566706c999d19cd2ed764cb0ce9f073fd7be61901b76cc8ee5ac6fa4cb20b93872869f6c66ddf05aa4cb0d76221b93b537158c4394b36992764f5c696af701aca85f56aa8dd76e8d2cc2bc96bf6bac812d03123955724d08ca2e52e5821883a14056b116e9f20e7d221fff012f42cf7b7924a243022722025a65ab2e80939b5051b79eb3cf0292bd9d5a3008a38a316a9799026eece6547c0daee03a825b52f19111cac8b877c9173e69f67f9ac43f28374116d7528b43066b36ba67c88c6d234742d360d8e56ea4d8e964332a62d4466697732bbaa09bd647e39d0ec24e734272bd7726d0f046ee837f6718a9168ab58dcf3754dfb2a3822429966eeff184da5b2546837087df6a9d4dc4404c6e1c60d7ca7e2fad842d68f9de59dcc2cfec2aa8575eabae55b9f29e6f9a960b31918b3e4a27f84acb99abd4ce5a517ecbaffdb081ded8d5b0ca46b60146f22c94a41a70ca07cfd1d459e057e2e590a266e302db3d1c450dbee0afaa630c18bddd658a618bb1db01e02b4423b4dee032bed0af1ab90708d0115ace8bdc343546e2fe1018049a9c3ae0de8b78ad6d46d66a85fd11549ec3c5504d35cc0e0b853e6335f78351310b4deca78932e68c2642a080acf69df7ce9020aa9ad4ce304bc8d6fd1231c77e9526809f0ab19f99d456c0ba99f30b9c1d99dce8b083978506b747872202624760c4630d71210b8ab08aa084f8873ba64cf876144a367beda989adf97f18f84de5a52d84f9b994fe6da2ce7aac99357394dccdccb0371afee6b9082d6de0cd6a26bca03f4581e68be6e1a5c1dc9d3b19b65ec71fe17bd859f0c048d9750a7fa02fd6cd8acff9ce0fc63a43afbc2f722cd3427911eda4fc80fe9dbc5673a38b9b8d95695eacdaf87a1953676005c2e0b75b804f312197cc5bfd1d319c674046ba0ef71bf788d2cca7026da5d09c859151b127671c2f59b111ddf6843f86dd7e4aa4670d39bb10eea57356d27e0e1c43d18a7371715e1f47baba136bec8db52bf50869dc326e19f3db22c3cd38635d5d292aa4b48e941dc841c89b13fef67a3122fca3d6e09b233e74f40722c42cff70a1e695c06ab7daed962208f069f3b24bf322c98008ae9e2fe1919022fd62142b2c7d930e3da4e515c850147b5133c839a4680ce05b9c2369ede4792bc265d2f1c313fed3f987bf855fda31eccc04a1e07e563e7fcee93c7baa23f812a64cf6750a52a17e84d18bbebab028d12efe896193daefc990850afe4be4640db00fc9f15f6c0e556f39c86d800c9f6b996f357d5e28bccd43e8021a515498a43f722359d485d933cf39bf65209a416347bd2ba32cb744142e83afba04d312d87ad40ad9552cef392e0b2e12b969eb95b8104efe510860ef99e039437d9174c0343a63c84a0f7d78c3267c926d2ed49fd78620e5b89d4695c44b5953e84143ce2e99caf7dd6ed006a92805fd07564de16e062a91add2046b5192be70694aa9b27258e1f58af78f6fb77137e0e3b8f19012516027ea46edd96eef01576b5d4ae18c3d6fdf7da09cf018950d86478076b5dfe010d3a98680b7145d7ece175e5c8ee388b2013176fe007c7d80dabf5373d2713a853557afd648c2c5dab46d95bdd4ab6c88d4a507ad4beb3767fae29ffd679d3198b77ebb4b9761a566dc0953856c44db9d103545bbc401308101b482a2ed3684c5cdd48b23b2b071e7751a8026baf3c9d874370bc745dcdb4b60c90afae20168bf54004067ece04e34919ded05917c58c1175992e1b9712f7f8eaa3c5e4c87bd6d2a5763a48b513f45aa1114dd351d239be310f978e4023b2733a58e18257d15f8fd940640e6b4cae3fad11472c8dd5a95876527dbef424dd81b504c8f1731482223983b0de71b856d2d614dc8296b551c64b206a627e21cef0cfea2e88b9cfee6050264ffad7a1cbb1f15eb32b4cdf14026b2a851841a74747fc9acec1445b65e7c8e38e2c0da3e17904c5ab4cce433c1fad4d9238173f21c1d77cd3de45861470b14d3a840cd7c1fb64d0a7b4af17d55c25798ddfc9f9b19d9e2eff9d5721c750444b6817b304a9f3bf0b4b73f99f3d20eafaf4e79886a15915451ce5e582f588a42b2d64eee8ea18f9424c030f6c06edb102fe880548c499ad34b80840091224031cc217410ae5a0192660bf6ae5b2c9e3843cb2de1fc14de7e9ed0a0ee92f5e7a70dd5aeeef4b04c1bd6c1444d7005e1b4ec1c296241ac0dd2225fe085f86309d2d14c30678b73e31816f7f04f1fb338b7f356908e852543ec19c0a1c065ae7d8747e9f21949dc0baf3dfcb2fac6130f514d604ef4f28f5c1f8e63bbd9e4859173541f0013192a04efd0768ceb7e65e6b500c4b176b1cfdce6a6d21554746def857bbd86daa07a994650a83627f491535be235be1e06156ff2e0586b5593bca10ce8723412227ca31956a63239aab649f6096b3c25d7a441f0569370ad172f4ae1c801d972b86ffe575fd0d847e3b8755d0cdd1694a1c581e941b2961e579e45163c9aeacab85cb173a8acdb3e346eaf9d07dfc24d56b692e0b1b431590f048a234847ec08be7f7aa15163983451440cb40fc09bb23ff853d14e334024abdc6d0f2bcd39b685ab5f9abfe86c30b3055e7819dd46b7195215efc2fcff3851c67d6fad1f44bf48199d44a259d4aa798fdcb326c4e513b7603228ccbfc45ba9c1b2611262f92ee78f36a1a101956f4e0476465bde015c6ecfab2eabbd2d74dd6ad952784785a9aadbe3635eb978d4b6a7a4cf2c952254eceeb2d200424ae7ce26a5d51a44a208ad5d3f97c14b2e6825fad849d009a86e97882f2e5f70a9e2908a4364c05dd7d65c5083e49a2f7ca513675ede74dad9c4371f3bf87ae599ca1f43000304105ea41b060a57b086cea77c646dcff546956f279875e18f64c9b9ea4b969e074e5487ec7cc76b2ee9088ce47ae625eadf561f9e2a240ffb7bcbaccd9170b67701774fea4e50f197cb5f2d339ef01eda96e64d54decd60b4175f9259b04bdcb1ce815b38484f82ce1217687fb29250b5341f95cabdef914a70dfdf30945df6e930f910d51c86ce10a40ac74e02d1095b1263db9cf99670ce558f250b0f653297496c42d1592d8da371e114e9139846833e38b47802e018244d7124ef94e66e56370371f042aacb15abc1343863e0f5d11c45f3c0b7f412294e4dd76576d9ab768c3b64107fff16b582d8759b0fdd2f59f2741a9d5322f45d7b81b9f34b241fd3a701de57ba8fd21ba93089bbc843b6abc574f02e4ec99b2753ab1a2de60e4d32e8993857901390176baac991cabf4d7d09ff30429aba08e6f73e3c51d161fb68fe2c37524c30d4a0be7dcd66e57c49f1c9135427ddac9e80ece98c905ac688acadd9f0f6f520bf3af7671462b6f999c53d902fa7c62d57c2ca9bb8418fec561c5c896ba21ca56b5d99e821a2dea9ea13eb2e0a765c85e8a9db876394c8560dc346654a841b4cbf3392e8ebfe0fe5dca90f955397a96285bc9a103b2fe700f809e60e42a752801619173c62ab6f4c3cf97680ac1e8116edaca44ba9a49c6a7a6c05e13beab443fc2a00b0601d683380339576e1ae3ce290614cbce97cb4930b214a4f408b832c9b7a7b78d113ad4cc0a537171001e139676fa9a4a394444aa53271be34ac18bf60d15c0eb351636644583cc5027d50a5bbf6313b1171f851e0033feb42e8dd45eb3be79eb85a1473db8e114d861e6c405e5663db5957ceecfb043096abe50065c062f7ca80022585b064e7a2b8a26b9da4bf0d7db7cede98438659df99e3fe43a026df4d9e5219c0a754b5492c38ff42b75f4c9c0ab9f1c3c98dbf165747b6665ba9f3ff62b6db13d6eb0c264e8418ce715fc9d91f9ab1294ef59cfeab5d7db92c6231f7af1a2f85920897ced68af52b4ce60a8059a58419b26011ab39b8c6309a7d3beeeb4720350e6f7f237ac1be812ee9988dd12c5a989e99fd281d67482085be463de314d29c2c8243721cb4aa936f28769a914c05bea1c369f0446679a34c99062e983ce7cac67d67e919c6de8943faaa032c3a3debff20f38ddccf75b0522c72a52dd7c598b5da780e13477f8f28d5bb20c9dbdfc2efb8742e38a3629c3037322a142e7d18b9b5a3faffd5647a8fb1d6fd074b281c8f30eb760c877b1b788127d4aa3ccc153432617d3b42322cdb334d6915fdbbb49c39ce280b30850d5d18caa34f2165afb4cb0215a5d836197cedef0d5a99b0be12f6049bdb9698884295f49f140641a91b9c57ebde320fe1ec92c19ef6e28837cf349baf73f38bc8ab25dbdf2fc8a082a170f339f4c5d9732058cbf816e478736fb501cc03e6f9562c0405f186937a4775023c41de93455c76f89d14768f8cac6739f1b4b5d74a4ea74e514272162121afae8da2b1288c6a8442da97b59afd3bdba06cd6b914c4710cf5413cae8fd6c3f2b301dc5787543be8aa002d3ad4396550b85d023576fa0176f8494ba78c0302da1766d243d0cf5d3b9ba753d9fd93873b267bd322bfff85f20b249067c987d3340c49d352a26490abb59c4e329cb336b861259358c849127469a92ceae8820e743cadb2edd609489b561f464abd997ce72efbf282404055cd382d1ccbeeda2fb0db4c2d60b796cc75fbd37a26876d4c574e7042b636a85a805af9ae1dcc3814fb54cdbf19f25e0c40ae386b8c4ac9b183878e0f729dfb04e1eb3018de520f26fef8c88735a213ca9366640fc0279128abf78d44faee19cefd206a20a066beb28224b124c20d128e1d8ac5a74469562eaad13914dcba0b0b72ea721cad417332c47094c1dfcafc1b2bf01057a580fcc30e7d8fc81491cdec5ddde8c859b61e7f5c025724bfd01c36b8e778fd7bf83ef843903fd522fbcdf5aca74543d73a0c4cce5261001060b8e3d934e86ec4d394268dbec488dfe438a578388ec0e6b498f4b74b0cb528b9f004d2758bd38f1fbf3a551e21548da079b7d6bf101c29cf772f6e78408ced763fe4f3c877e5318d51aa074b8309a962a3ff7ed30f97f04460e670bf954d42ff9f0b83da069d311bd171c614c268025983b0bac7fa4a6db02cb8c13cc2a1022eca7b2d9c659422b38b89b7ab44932eeb94a17a307b9d94ae94efef9e1b45f8940240b3c4132091ab7ccc9ee2a9bc962f7bc254c1411badfa5ac95f3b8de55dce29bf24ab61ff048b6d2bcd9155fe739bb7009f5f24e907b8ed6801cc99cc933a13ce4efe239db37bbf169defab9d76d5bdbaddeb192c14443dd8fbdcffd47bbe27c2e85ce96ace3d10b0ff588b9bf986018cfea7e1d390a3b6a5cbf92cf974de8c577ae5bdff26d1b2a9611000b939e6f52999cb2ddebef9ce3de3c01b413d05a43994f5803ad286d39a753b9625d74581e3d210db00b877b3367bbbfdc0b7d3d087788f6212d7170f08a87793dfc743c768d60eb5ba7782b86c5a8b647739c529a314ee6ff071683d6cc570773897a0de4ad5828f5accd30c51528ec07f061a6b30f5386d1f26371c293c0ed805571acfd164389c36d931222fe98b52db44a97f3d9567ced5ee5c6ae9e9b319d4d0ac0bb87f78abc90efe48854279751ac41993a92d2e0485d8065661c41454ae0a2b6f4ef3657b146d9c84ece6f3aed8f8090a3e130bd6a959bdfdc2a3dec0c7857be516ad484c6bfb46b12b869315e023343f629952dcfe0cbea2eb725b484c6cba4bcc3b616f84900763914a7ca4819d9d557dab10c4af7a0f038e882fabba90f6eebadd173cb4ba7141b92cb09adeac1d1913a6c1d99e3df1f57930618f2408d8a38d7611d52d1ee17ac7ad815c39d5b6a12a013655df7709277e13de5afe69a237be80b7b44d9ee65abc101e5a833f09e1e2a30de58d98ce414a22a3459c8711f54d8ad1b092f6082b71dfdcd536dbb1c95cf90e5eeb4cdc41d3ecaca567e4faf00b47afe8b15855463414a9a8727ef6b2b141233b8075c7462233a8002af6c5676b7072cfabdb720d5d7dbe468d97280f9a191a022ac0a2bcfe9dae17a842b4488fe8ff02d1736a065d2682992a8644bda38dd9313190cb16e568744f0ded744838b4cb642ce76cf686a9132038f282013ab9140ef04dc9bfc15d27e3b905f4f8b451f17d01ff327f35622c0e3fb121234c9a18421cf288620801efcc8bb40e9b5f38ce2a3b4ea213fc664ca601570a9e77dc67b47e614e3fb13604b97ebcb0693961e4615a116bc8cf559f88160d64bc0eaba7161a593356380eefefeb12850757c97cf1a359feda56576fd5bf369f3511ee4711ea13b775c7863e8d4453eae5e2bf0beab5c8dfc846dc089cee18a03b97051c72d8f73ea2447d85997c44a92559dfc6323ff1e529f9ea9c2d28fdfdfbcd274cdb8ce8e714a1d1cbf3de2af05d15a09ecc58d86ad74502cde9c30c4b50604d18da47c06d53bf2fd073e0c94fecc00893086327db29e78abadf06e1903a4151a6cfe2adba5fbed6d09f1ded31a7558204d96eb388738e840bef87dab7eb61ba79b767681879d759d1b729b9852a2adc9b70ffaecedf57a640b6f9ddc0370e502bf0472b2ac8352f80e0b546db9f33d027235e9773ffe587e4025d3b4863f1fd830da48e941a4f4c7ab84294558de3336c152d152ee084e8d21f745a42b5705627d30b44486f3cb2198909c466a3d1694ed2dcd760d0f32b51ec1f9855ac9f96d6f10a7997b70ab8ab1d406bb6bf89e1a0fb9ef345993b34f0cbf501cd47b374a12ed2286a75f9028b3b5556f851ed4acdf01ae94628ec768622c7374b778e586bd101578becaeb0d4394a69336cdd82f6979d4beeb8ad54be5cf83101dcb8a814099e399261198f7da8ea946e6e2b78a0f42c12791c99d0e66822729ad3f05491b5451faf939e7674ee27565eb662c14f6690626cdcd9ae971c25e2a03ad1b02025274edea9b4106bfe5b5f4527893ec037253562e3818022ff3445d6e882694dd0461ba344128fb2cb99fa4840406a6509dbf8191eafc37ee6c559e8927794839bda3c9475be77e3bfe0799c47cb3d980f4338713857450a917bbd8fe8897821ae42a68384de4de1bb6a9f01bcfc24e39532aa4b86ec999519f3fed5212c34b756b10f57edc4a3d1557880922335bcdbe447971215255ec3d041c0de16e18bfd0cd08efd49f1890aedd55a4ca25e63f55bdf845c23a081851a0c955e74870fc36ad9a3bf20c5a5dd709ccad0db2e55554c7f910eac571f34a1ef9b6c6aacd46d8bba74b7b92ad1950bc88a9c7d9917e7335bc2d33c681a644cba066a40c8910981058f36d51588186d34a49176410894a3a561e8d5f5032a5c9c38646b8b409ab488f9e77143e2c13bd0891070a975c9da4da1a742bbe99747e88e6555fe5fb4309b312298f1cd1d130bf24c840d9e1dc08948eb8cc0ec1a6b50770d0592db282b6f960cf53ba2aa9fc72156793dfafd39d0c57a0a023157ad5c9da5dc0438700bc14214f200f37d273421bd486c0dd635e93e295d950792f10218d0078a9f8d454f51383415e9b60aea7117ac2a31726b60eb027057893a2fd25b4988b5ef85f065f1306c6770084a0dbcfbee6bda2499edd8771acf568042778d67ee703745037a34315a10f21bf1897b072aaf083d79c27ccbb22cbf3ce09adb3a881b8aad0c6a422d6620d4d01f6a5c59920c523b97a798b53fc5bf7dffa41ce63b7d83e8ffa10692b7da0ed63dc5ffaf7f66ead3d21af48beadf3769e896aeb2599fe9cfb8516986eb0f3d4fe8bfb93bbef4013d8e07842f543a2af12ae66caa20cbdcbe33437114585707b7afc50292c60b71101de5840237b5869ad3a4284bfdc761daf5a0a9b02ef8b96aea1dd13eb8aae0f0be381328c654edee98683b3392a0d5c7aa286ebb60caf9cc6e5e48be06428f5601cd387d706dc8508d67e2f7edb5c9cd6093515e5becba296f51f1cdb1ecfa84ffadce4409390b0507acdd21461284c933dcb7673c15240868b9edd090d6117fa220fb83d5eb6ad2e4cf95d53455f061aaacfed049633e21ebbcb88eb71989d8e66b105b8cffcfc4bb6af755b422af51166705282cd4910bac1c46d805adb8c6218c11c60dccc2194f11bec8de80da9bf788c7980124c82c70946f69fddbf6aa32d153f618301d1369dfee8857bc64ea48d92e15004f68942dc255c9ca51595fd56fe4695fd0afa583d19e0020ec704aa9931ca40e3af65b8f8c47012dbdc78e053360c06010e0891405ff11bce30bdd486e9017e0221a58c629d04fd074c683a10e44ceaad5210476247e5635e6c96087996bffd4150bc8ed08f9ba07421dee5551e127b491f5d13d01c21015b70ec6ca996a6deab34aea78e276f7204613fa3003c429748788c2288e77d50cd75435effa4e45a0a19adbd5678a5d97038c47d3fe54b4e99027f3f67c02e65d97f5da0ece759ed698b495307c22a8cff2eb47b2ec06fb3b6fcb9187e998705f1f513d4c6b2a345878dd46068de10d854f5895d0eeb2de496c0106f6f7f57ed13f921c79b74d39f690a14969b47c92c5afe1e95f3a33043481bed96495f5970bfe888956e6ff68c42b5a328a36acf8f02302fa885b3af95141d31125890108c646e16b9c41c8098fb48fc16d61966c5321fdf0863365de5e05066dc1ec0439116724b3bc1f1a82c982f17f95133db1f0bca26790526224791499c58780f40481e5a6e8c3a75a8b3a3391c35d6755bf66f311ea9f3557c7ba6bfc23636d6dc20b6d160a0a74e30bb1999d2f1ede53ee010b89bb2756cf633fa85ec7821445e1680a46873f5bb3452ab7655ac022ce2d5f6cd3cc28b6fa56a3235fe7b03b11d3958ba27c4427762019fb206e5e7151550cf019550a4ab452db54e7528b27f7835c3b5cbe82de8de028c6473b725cfdc36c610a4b7db176d52b7ac3600fef452f315a48f5f9d5e88fd20af212231d325f7a479c2eb1f1178e9911a654f0cea0cea6ec43e3812d1a8e0e75900bebb21d8bffded5e89c18ad4548f4d3bbb2f7b755d0e0a79e1cbe800e82de9297f5939b1484e6f90ca765705ed61e61067ea5049d2926ed7b81f5aca13a946e2ab2dc578190f091db7f1a5768126dfa05a4ecdc53ccfa509d25c449a26930ab27e904b581ec0af9f6da9d0bdf4d3c3eaaa50552a8aa683ea18affbc207efeb62cce3d9b02d9cbc80e0cb45806697091d5d2762879285099cfceb0eeb77e8093b879b4b52c7cb9d23d0ea02f8d65f70fcfb92e3bcd26a1c35f43168995b7bc81ebfdb06b673fdef4d4806a46f6f7bccddd9c67713a551c769480e30767cac3a07dcf30176f40ba5da49e71f56ae4a2027f2ddc17d1e4a6a6afce0fbd277ef60b3ec7e9ef3310eed591d5334e910494950be94bef572021054017501b70f776d5a8b5856ab42f8b658ac0405a92757b85b8ae6e5573d28bf8a07c90362e4adb9bb5009af82cbe6714280601da8bf4a1ace33e5d8d24e9d32d6effedaf147eee815ca79a42acccd7cd0a0d9c66b22193bd443f679f79231f35766bb95606d5febd76d8c59ec7439dd8a3de01551ed1666797e4c3139efabfdb00ed78d795eb33b08d69beba880a62950c8c6734f9be956d2b08e7daf28f0fa7ccb72cca4d2dd144686f017c9badb0e4943d2b408fc80d13f948ffd1ca6eed8bbcd1c8f497819ce2e07f1bc5e5a4cfd3ff459e7e00eefab6cde8faf8861629700534406c5319feff828197747c221020ab9b627c832a7723ea6796a84e0eb7851224fed3dbae8c998894c3e0d5cc1ee97ed90f304031c5be8df944396899118077ec1b4c2d10950c87066e54bddefcade5c047282eeefa2b0899011e32b47bade0faa5bab527e7eeb267ea43fc71c34725ee6dc58776ecc52102dc1116aedc1ac670178459b606a485bfafeaa028f7596f96676f31f0f91b413f5f9d50ab727e6317bd92b65f6f34f7d478815eb95fb89d93540bddb5840361d95b06d54912188c39c9371b085871a68f66ae5afa58be7f0249869d496cab80ef1bad44fe585c9f416fc7ed50ee435a0fe3b76b8c61aa49d47a8d17beb4d4c60fbe06da57e79f49fc73d2bf3e992271dc70d78276744aaabc6d0b16741c849718d9034dcc7ef8eb8f43873c7c9cb6c144c31ed6144f44a8a0915f4deb616485fa7db36c2073607a1a04262dffa157f5c4d2c78d13de33da76c298a6281476d8eff7462cb91e5a00a09ec3cf335552529bdb32616c2dfa3295a99b84808b47a693512e6bd07b5fe950896923bebb90d44c04d64a13c6111bb8f42bbc09f8d046dae5290969de564d8e84c8a8620dca95839f2b8e9a52ca0a7313b8198c2326996c184d10bd7a4666f5f8262472bdab00eabb37748fd4cbb1be75961f2acac736b673bf9f060ad6ba47cc63f6c2a74f6b3f0ef0fccc742bc861d6fc93dc70e0d2b01c6b50cdcabe93e5501d64306d4dd847a578a21ed242e3b84d4c6bf37473523e86f54a2dff9457643a2bc0883a061296bbd22595f972024ec596959d06ee2dad92e99b9ab1620842bc7ca34398c81da10d6c91481e1703d4e792a7d939b833f0bf23c2acfce6cdd27dff7b3ded2ef80e4fba3562b4342d3ced3d338e57d69fb92fde8e50ed9ad0db823d75e1fac12448b02da4bd2abf9beed785c29ee58e34b097ef15cabb6e8d537d76b715e003718f1191c20c31fa8bedcc68b7f184776ecff6e34804470b01f5ee46dcb16ec8cbf9461774de2590fa1e721c0a52c9ab084a0070157bac23ba8be55ed491513d9e7e5047387197975cccb913fbae769dafadf2192162c5fc151cd89a1055b49ac469e5d3280cf9f75e9fec83b7de6d207beec3eb38e6aa09f4a80ddda00652e50cf3b1d2f97613d89328073a4ed8b9eed053ef6c30b21d2f049efc10254fd0c05485a9b42d2f8c22d9463d19562f3edbf03f8d634169be790dc3dcd5a2fc026c8d32c33ccec1367ffe899bdbba863f6f742a63f179ebdbf09de34db48939d153f2187a0bd331a8c55c8c969ecaf91b3e4db275c36c61f61ac6feb83e5d670f51aaf7543d2232994e1aae0eedbc1c87c94afb4e3df8d5f06dd1f839f952dcb95846fb7defd1d5d0a69d56243f82cb153701709b9531a7624467e5f5e7076ea5c4bfb976962c06a864efa7c6146c87a1ae4d1c7c450ba16e46d7b8b7e9765fdd701b030981c3035da8918d9b94ee7bd78fac32743eaacfa75ddc654138a2d0e7da58a700be22af23e75d071c82added50e56c3bd17c0de8c28adce56a729542f0dae147ca2161ad02e5a624d7bb8a08d9c67f1a0b9235d6461f85f1f0c7d1b55b9d2fe4bbaf59dc94e0c08e52f0b2312b031903d15bfd9851b652f075b05cacba2346ad17663c16eb821034e3936f4afa6182dea4ef86fa02abc208fb2c117ab49e4b58ecc96768a9dead90bdcbefbeb9ff2cb1cbc154ca8af68c40f6bbb54fcd9ebc07a0e8ee7e7b4c84434b5d017cd521efac6cb652c5fd62d4265caf7ffacaa189ddbfa042de143b4b2300e4a543022a11c9796b46b1f92d4967f3fe08d58e6755cd3501fbc040f249157d175f43bda71bad6d7c754e8609de464bff8425f2264166d187e83bdb3687edee88edffad92ffa26791afbecd9333261634fe19d60298722d97c4f37ba8f5b7477d0410f72e5b9841cd2feff28b49447443bc7374eb033ced9ef4b416244356690181d1a4544b015b84ab9e5853765761072c0674304c8f936851b44fa07a682cfe8bd033f30f9c350f9c2cf79978bbf9c70a1ae8a57379af0807fb24cb2b259fb16da713f4810856e73e19f6dcc5423e3a620b0d702888838b0ad4d887decffa89bf8ed6c375164687a8a4964d172dfd97dd1ded307aebdece587c573eb8ac901be143daa1bd47daa131a3f937ab92e17912b2f7aa0422e5544900180778648b104fdb89078296c048840528a16308866017f13950e77703abf56d3bbc327f3075314a2c8e7c8a2e12048195036fe4456f1b27da6f28e79934da38744f068081adc331bfd38c108764d23e8bbef283e4cf2b0fa956867d5e7204a258da79d148128c87181fe151e95808981ae928a31c84d59beeaa487144ef449f6f57da6a8ef0daa1fb93683677a4e11711b0bc300b61d3f3b73db3ca245d25db3a4c92b94e6679b5d1e7be84f9e311dbdccdc0eeab9a23341744e04f625ac81eaed4a23f36ca71f38c4ab1cd7d0d847e8fc951411c97ffb49650a06abededc90e5075bb3b466a152d6dbacc40f953afd4b86be62f56c2fedf9fd18efcde85656a53a7dc258775388e60726dd98122f0086c03b61a0410610b1901203510f56871d40337a2f5306ec025f34a3ddd7b780f9dfce77019a6280936beee925bfa33f61425b127a9db2b3298f69f651050123d12ba7f2b97830e7b01a9a3af3e9d1dd69c348988ebbdfd99100800b808121981d78b386a04fc099908c0d7cd818a4b47c4b87caa4db74f244cb3af54346e1cc88e31e281d4ec1f0fb0bcf7de967f612c96ab63cc6b0de2ca75728f6ee927c7e82c0973a92f9a4596e0b4992c902d4ba8003ad8571214af9c047095358d732ef973c7aaedcb00e239794760f6616d6b6c20bae1a7a027f37abe9df2d9c34b0d7510724e6e53bc7f2268302a00f6419287efbf5fb4132c707a58f6842ed9aee96b26c13bd27c80f79de2283b1d3f8d1bd6cbddf54c55782777485d70029e9db64bfba86c83ec1b3f7951bc84b06756cf1a1f2b3e83dd0063787ad3e576991815475ff1b6a9256c29d0f1315b61c51d156742e7af90c9545a7b918f832f2ceda47e42baa5950f29060cfb9a871170b70edcf198b74e8692d7e3ceb92252f03d37989da24b111233f472e48f48360d39ff473354d8118c0a05e18a6bbd46de7ce86eb93915806855ed69f12986173dccc12462953ffbfb1fcc55358bc5d5e2116c7c9f80ba52f4ec371ebf60de9787efe07ff97b075b75026a22942a3b8117a1180f88ee0bf74c12deeb612fb11c960e36127dc552754e717c00c96e3ff71354a0979a44b7bbddca370e6e2cf50e3e7bf0cba2401f7cbc6a93978bbf707f5f5c91c379ee8f94c67de953f31e5d3041c90bd70c730c36babe63df1e340566b4a5b78551756fa2e1009e83b006c6a2db748fd1d287d39e3237b14a98fc4fd1176eb5c1b46f72262ce7c9b3172db3bd5c4c2afe113d5d60aaac60167ced74e23429daea4c14c05ae140abc8416e85dc79a1e0d6cef0738e50856852fc587a343c4084153ac30ca0fecf1981b6c668b2db151c2af73f854fe864f704e4b644bdce43f1f59c56866709940d6e754429b358736cd06f03883612cbc6c7196b10e74b0350eaab2b9dbef1816220a76b3343d01172b0b5884c068719a79fc7d11d578f4d5db42194e0cf378a759e817412c87ae7d4d24ab49be82b3893d25b23d2c08735e65fe7f2635494a3672ca7a3973029ede27efa48d7d5787a343b06c7a0043b3565d0b36a21b9adfb7e69974f0b7fbd579fb0cfa2430e83f973cbcc4b36366e8346c68cb59c582d2d6ac8fb2df7171c39723f90fc95ac1c71c14bf7a1d4e69bf088482bbc56809fbcec2cbb79b00316b2de99f40e639e9b54d1e0a1abf1a96017f24e3cd9d9904449955cd729898cb2e1475dd5205b5cd39fa5f2d02af8ab2924f0fdd6b2c3514a2bba920bfa387eabdbb6df676dedc38c8073ac74c25ac2f1e6f62e8495d57c99d064489b07e923e39613e0e42cb41218b8ba519801d80c94b165703d4d7fb7ebf76a9a8cc34e9bbc3e75fe4d57f7c2cb3b22be954a8cce760b0c925387f9a12c0d8b19a9347da7f363086b94277ffec1068865c856f955f6a37c1a12330347d7fa7e12326f704dca40436ee30a12719e89f12b221d0a50534ed7f0fd88b2a04f7a2d8dedd16877b6b35c0be4e915ffd543a3a4b5ae7ad12be20d5126f659bbd017fd5e8c30fee3bde373333c026ad19115566b2ed9a303b6a5a3adca2e2710cd87dbda3b2a945f16a6f03991da6e010b315dfd23bb8f79958d6688b61445cb307665ddc32cf0f71883327dadf9716dfbf15bcd1e85140efb8d33cde9b02edae4c459fe3914e933366513393e6037c5ff4e8ab788b245ea8a913ab0ed9625474a6ec46e979011fb16f6f7b3bf9ed7a72a97af1bb486d8333141c88cf6b9a7b9514c534c2e81c1ab874bb8d727e78c9c8547ddf1d7461c4d42efbdb5d4f4f72a74d57fe8fb389bf0fd8419f8082283fb867a562adf46407d61ace95f898ef7d4f81265fcef008a0f5d8b69009490f34d1d95e722c375fe62aa3beb1a368a130483cff7aec2fe1ffd64bdb5cd406c908423e74d84954dbb964d1e31034c2872c3485eecc0e78e4f376985af188391b7d9db230d3e654c29cc121869a480c3be182b326bd7adacd9c9fdae2143e3b565dca491f5c5a857ee2a820f7f77bb16b64221718c22c8798320fbbf42bc1114e55390820e148d22acf3f5c2e0cd1361bbe5320c6aa05e5755f07843eeaf1c4bbb218be9d545a90993d067567a7d1dcbff481b9fd03000a6936eb63fc2fbe58b466e1586612ca10e898d5f96fb7b6c1c539b7188e455d266ff22ae719d50c116596e6233855208334f1d7d3194bd8aee2b8439053f93524218a23debd5bfe452894d4308038e43d1336df82943b507a2581b118061815b0060f464eedcd641ca260d69c56f777fd0caae2a524bc7a7931518c4b17727020c0abc28a800699075017fbb5c18ee93faa514b26cce48b878161b5674fe7b6afd752a087c4892fd032c9d96e23b12e2f0e6d34ca6298bb49ece11eb6214c4ceb2b87c88c20c98f13a05c3500512585e63ac97892d7523b262d96339e879d12e776d50d8b0ab8233d444381bb77cfcbcb04f25e7185e53f58dde072c9ecd5d9ea3b0ca0d3376bacd13cb8adf9685c0588568279f5e0fc8feb00c2afb2a11917704e7894e9bf49fd79f0047897b173dd1253dd3faeffd74542700b576aa723d28b546188fb55d24add93163ec86ee68653e9b754cbffcce7630077171cc525c841cd19ae6c8dbe2ce191cccf906930a9d5c78f21b5f48e37ca00050e93dbbacbfb830bb9bd19279eb1341b9eab4bff0dd8c75f890f5ee8ddf4336899578f6647cb2b6cf6542aa5a99b684b6fbb63b777c68d2d504a47b629621e534b0c029562958b1c88dc954b200721cb17f8bb21e0ec6a0815d6c547432bc20f51038365c85fd1b4c3c81ca3666568e09285041922264e236e88c8c678b8fae1bd8afecdc3463d6b771867fd6cf70e784951b0ed95c867af7652935585db228f088cdfa9ecce2d846b1d61ca333742a1c67e0061221d58489dc2a620937c32387f18322a350208974477e1b7bb9dd46c9dfbfbcda04882a78baf95f7d308df94702958f7110e033bdd48cf837f70c89520b04d04d0a732976d2439a9694bae2df35b680b0d7fadf0417d330eb4fbe6b5fc470cbf2fa975a495a43a52a6f612a54b38627bb98de434acdceebc530ec66a3933a907349bcbbcc9f56481b2faff6722fe066eba3f3b54a90f7d0b0f0dead8ab0f35c27015dff66126c2f1999ef4e388ed6ad4c187145e6779827d92838267c80018018288ed8eb3a1becaf9a6def5eb9d329d5416bd1633a3c42ecf3d8ae0fb3720bf8078c87d86e4ea3d40be87ec19dc07bd42eaf6d650f85ee3d9b4f36af0c9a4e5459560e8a4c6809acf5059fddbee0de036d780e273861c1ec1892fa8ed9ab9668838c3a0fe9fa9cd4251e29b947bd068f07b45fa3be630445e2dd55544cd92c4716c7d89d898aa7f7769430e5d44987d7e784201e448a0766d324fdbc4ace14818142dd8382164df0a7e1d75c50d494ccd8cf71833b4e272d0e94879a1d6fe76e5747af5660f05389b3c2ddc95b04d30e675064cbc245f95043205a71c72516cc5569802123d1a9a0bdcd330aedf31598bed103a7f02a91f886561761cafa6f28a507b55375c1b680fa1320b38df031f2f570525e0cddf53a390e34edb09f789031f1ad3728aee6f9d057eef8872caece4e46d3e89169d827c0b951f0307f2383c9493f773f1f5691e9a6f1b5a07685069b0c5ec9c42bccc82a7a55a9234de0593a9f48429a6ee5a4677e7a6d2a55074c4c6032cb853c37c220c599ceb7a8de540d7e00ac3c83d77d7a52d2215b0c47566a81a6ca3ad16ff4e362cf6dd8015c35144b4c874cb34fd572f5207d8f09be189236fdbb8aed5db0ac8e861acd41a3f2af02e3257653b4e4bd95bd2fddeb473caedbcb42ff9c32d708c7110d40ab388bc3252b8389380143f55cc1ffd08a9237f09f2a9909fda50c07d8ecb47b619b1bb253a8c6366ed9d44480248fc0d3f8023371e874ed2a8725cd345219c11f3dca09532be8ae89346ba135a1f58a780e1b2e1d30f05821ae11743c52bd65798953a79c646f572157fb8684184ccaf8e07a923c9717d83da1854916fbde8a75a5d6b63f7be7f475c5066b17ecbcbcbdaefbd1404a09dbbee5d4addc9002b0581b7922a37b84c1304cd663747421786f96aba03e04f900ea0bfbf78d7c85bcc1b1d2543abdeb15deb3002018a7b1a37855804f02da2b7027c9e3556fe22e468942f85f5a0dbd32018278ad0dcf2931c911e5ca0d8b945b29dd88bd3a0167f6891422c87e4f7f85d69f85c3c3a3a7ca81765034ec35c10287fe1cb7cbe226a4b589d87a672651ffca0b07b86433c771b5e894645a72918ab36aca58e42308df705024eccf8dcdf7fc325d28a504f91ef63414aaf04f79aeba51b711c8b66cb6ca20845d9988e605a183787c69ed63c5d0ad9baf0317015f4f89f4910b1a1e6f146ed25f8306fbe1087022ff8bdc3787d38ca8aa6389a3dd29eb7d51e590fd4d59c7c6ee3d0f08a82706618c540a9bc4f5ee2ec6fbe4599fb521dbc373a687d7194055d6bdc53d5aea64e6e94e337eb68200c4d7be3f53900c58c8f3416e875dd75f7ae092bf7ec54950e2a0d8d50bf8e16df8450cb593924301f32a9d1ee7ca304afbdc0e335e98c1735cb1fb5e8489f8f55275cec05dde2b1690546c7e09f02c6aea0dd66c49033d59fd25c226ed0b435498e0d6729c9f155cf6b8b3ae7f2d8b6b6319bbef9a35ae9d89f64950a8e41f62bfcf20522d5329bcd0d48f809b345010b8e108adcec61707da029ab88ce509043e82ad067c3267a9fd176c4e3cda367fe88e2050c1fb37d097ab6f9f60e7b0d831d2bbe4faebe19e8d8021830791f4a22a182776c00ef31be3748736c024c18290c062df76303c0eaa0d5c2aa73bff1d81e9f0bc906e81f52e35bc3d9e674eb3fbfec0db85f4d794b12cc004759bdaa190226653c1d6464a4d4bb1b9e1914214355c7228ddeec34d2b4f358278bef7735003db004475372933e59dac3454c9842627948a555e5e332dedbf80f5c7b7b85282b4bd08c5ae8d19706359423b524ca8765387f5ffd2a9f5339a4326ba37fe9255e3ace202a99027656acd2a45667cff7b07e148f468a36f109ae22b1c01859cfbb7333f9e76a633507c739648d71abbf552679996ee78c225162e4794645617","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
