<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca623ed07e0cc2332106286be2e421d80a8c0421148b26fedf70021850139a421e670133bc8ba7089297035b86a802c79553f6439d0417554148d4fccc19b180aa31fb6539272c27b8d84202dfb065e4336d26b4c278f3cbb85ce80534e99d955f4245a6e8a25e3035b67b7458da4c0c550835132fc91caf1fc8281e70ea8160e18e0916a4a2a058eeb1a4ed7544d8648875bf7c25b31321cb6d5e714bf13c6c848de2b686bcd314cdc58f0293371d9d18502cb145e24d373f8ea0197b57571ad8fc14ac910feb57109b019b9fbf78a99bfa064a4ddd826b040a32cd614e23ded28dd5bf71d366db1ca0f5e071d09f4ca04c717965c24e363ab2d13599c5ffa8ba8d529e1f44e3676fd6973d122d533c3a2e18ee0ba52a9aa3da9812312df9c663621e89bfa1ff6b35b8c4da614d8686b492fbf4d2bd17844197803801b71787e684254376b27e07a1166411155f4d32575a223f7e01e50bb4b83a2ee487a11a1e55cd02c08a15e445113e3931d41467457829fdf6541a48684ed958065cc48af275b65213949076c7be3a9ede7d600b0c3e5e696c00737162f0d43faa363991d8e097382d242263a588311e7ce2ce1a7896263d492b6742cad9cf8eb6d64678a1ff94952b207f18123ba408fd080e15645a7efb7980465ed975d008c46536e85eba6f28559ffcde0a215167831f0b1b2253f67348351924b9eeecb3e0c70d25d1a349dbd78c41c3b49dfc7080000095d951d2eccbc64c2e6ce6e2e36f9a6491a0ec9348bd4001df31ba3850520e768ea1bca67a7cee08fffababd6b44d22b8c01c3fbe39e373198819155b6e855c771f4ad04451e7cac240676859f88ffb1bb6d342d3ada4ace0a2d996803227dfaaf2fb14ddba45aff84b3557068395ea028740688108d029b69524203f282d6440237f30711c5df936b05caefdba5630c9a3b2da07cb0fe81fb9aaab18982af55611dd226fc851b3ed4b982433fe77a45e3c97dcd9c02f68fd527b7451fa5472b0cb8476214376adc4c39750d3ee78eba7bba39f0694136cf61ccdebf810ee965ada542381bc836e1acdf78e45c71e8d62978fb305d9fa336a6ef91de39390f1ef7d65c665e097055c6475c273a1910bdd31b4464d09988fff118ff30635d1556d3cfc2e2a9caeac0d9a348fb58e36a5ee53382abe7f0dd47d728c42f9561526fbafe10a2e2ad143de6612c1f718f2549e5e8a793f8f3e793959480fb06161dfa8a20bfff1654f4bd941b7ca518e5ae5d372a7253d9cbc645af72344f99d61a9449ae11a20a71f9b1f5a4df4af976c4928fd2454b8e064679d7e50c223f78b106989ba3c44032801f2150242dce65202c57042bcbc1dc851a720ec334b3dcf07aff5f7b37789272593a267744f3a40a8e43eb4b24fc609998c6c1228e4d57c149ce70bc37b2ed8718e651e94892390f02336c0b3c9b0ceed6331a3672eec7b12866081d2ba9b50b098883f9460faf3bd7d0f78a9fa7fbf63481ba470d552c3f05a785c5addb424b2842cb527381306a5aab336a72124488043ca09491a8acded7cf90832decf6c5fd1960c99c9bd40ab91312ab096c2e82086cc50cab34e9aae1ed475c9ed903beeb47187e34747305a6ffc153c9398677af6816a21b504da9711031224ca4b16800b12ea7b92d12a28c7e9e1e91a37948a661915d01204d14cc827d6b0817e3683b5a9a5a428e9c5be6257a468f9c4acebf96d0d9603c5b06c828296432048142cb879de76e1105edd2dde2b8e1f9d5e02e1902a1ca0b156aa68e92b4a18b5d5962dcf38dd2dee5799cae06544f60776c0e71fcc8f1398998575cab1b1330b4dd7562d189b8d3a380e5d280fe1e65e65f40f8aba06f1e9afcc9c966bb31c141316e97d3c6412be9d4f5d2d5d726eedfe508b2d5c5b34e63a8d1c995a41ca17c3f201f4f0cf974d74518721ea14b5651f6f6ee3cf3bc8138cd60c5a65c29bb55c4a77c1a78b398b78b5c8fb21f28c0c9a42a86503652a3021ed8ccbb085da39ab43c35791d40d48534432dc3dc10671da02db48a80e88fb4ebed61e5d687521b5eb5d9f0786e2614de6e126ea519814622b7e2f62eb9918199d78ba89683da5c1a01088e870e4916b4c7540a512ec04c8a280193bec2760ec3f7bad051189dd1307dd3155177714a7b59bbf4d015c9e5f90cb86b7694246f67e9f7a951df4e637b4eeb888ba2e3ee6a9ac1d1ddbb8b7c7459a5337f8142d123e26b1bfb050658753476dd6e19475410440c8cf0c48c27d34bf33652e256988ccc761a34f7d328436c8186a65e11814ff95e7ea9b040b8de11a48afe0d36b4f4a81aeb68454cc8b567d8782d8f81d13c54ac242ec806ea4ae5f0e2ab7244780200ad95d794679464671ebff9f6a3556a410e8c5e110aa6e6f9761ea14e932912d5269580d36129df16fa41f470c71b8017fb6c3daae7192cdc161df11402852a1a2599ba1e68424a53fec0c251c6e5bb416debf25ea41478a8e51dec897704cdc3722380e2bc58b88ae8397bdfa7e0e856ef0d505c9fa5168c3319d37ee37fea975682c1d3e308a597610e2113d4ce606fde1aa69ec9f18fde5943605efe6e37f5fe62c5134c253f2205ca83bf4844693f3459c6dc598f82723fc1cd15d10d88f71db4c0b81fd0048523c3abfa7529a531076b1b8a895ba45db30328b1a6edb5739912eac9c7efb0ec2659029266ee1a26353b48f77eb9b474ca1496d26822afe529036d2d89fa25976d4c792e3a25889e3667976e27a457d3fb4b0265346eefc7003681a4f3518cc6c028a67abca6e33696666ef03b488a1d50f37d3e59dbdd59d91e6ae40035c1d3d39ae0fd0f1a83c6458a3f00637c9a7a2abb0986fee6c27d3fe19028f5f8bbc96c50c0d9740af064ea8841274afec95a9c1072e39af17fc76ca5fc6655d0d46f6c1eeab29a3f7f2a25d270828f8ac0184b85b986587f257cdd7911e81c3bc8b9714bb5b02aa00d9199a6d894956afa2994b415756436e34bf6eb92787624e7d7d9bfa774f0feb07a4a145587e808fe25365cc846e2fcf3e0888126aab754f6349817326281fbea0737397d67f9cbf652a541c77edc474360b959e3a4df07c4efaecfca5aadb269b3bf4f58276119b720b671d678c49013fdc056141c736c095afc3b7d8872c28dd9af2ea50f2f38259776dd6c335c3b653ba85c1c5b650be0bd60ffeb43f24c575795f9bf6d09077132c858877bd2101e5c6d2a2614db442781327dbddbbca5eff61258565a32fd2c7d87d1c01dba505a4a3ae9d2e3b362ede08bfecd9f75eddf1275383b1264196a85e5517aece952e57db40dec532b4b7aaea86039793634672a0456371b406e4c703132c110b25aab74e12c1817a98b0cb25dccdc27b1d3fb70c407366340f04dae6f16f00e561df4ba7fe403795a8c1c1d02f2235b98cc33b7104d73653c71762926cb9c688336216f5f6eb2cc1ac782c1757d93932a54348ac27ddc35ad2ffd9968448bc0407e854250252aeaad0223140e294ff68a359d2f31cee0e536908cf713dd90cee896cc8d2d7d7fa9618acc3230a29177ba51c90557340639a5f6fe6633cff28915bd7ba247ff392a2648a4e7c2e1bc17eaa48c9c69767bb50b5099ad518380a0bebc343f4bbeb50743afa665c66d9d74e28da2cf87421895334bf89b9ccf53b19eed9f591c67550ca37d52b2dee342f2d8f5218714c15b4d3b47b5ed030da45f0e479c9f49a531499121e9fe1c36fa79eb7318d4d008120af6b9a8a9de3e482a13155ac02996d9e2d6db3f792d418494caaba6913645fe168c99cb598542902e20989f69f421293c759a89c8816d721c68a1b1fb2f843965247422d1c8c4cad84857405c8e885cd9956d77b8fc54d55ca05a38a790c18d1675b5d448413a77ffb5811b1f35220f8fc666503d596820bd1c749aba2d05e7a0679bfd826295500f236cf56472479dee1630c9fb68336f5c0c1202f3122f92ff634e5315fb8c991fb6e29f45260639344a2ff9b7353ada57dfa8bf317cca4741a191fac9d3a73b5ed330bf7cd2c3f3b2aaf07a65b95550a8f4e136ec01c5dea2a45526af17e53c3c83cb9999bc6deb95420c216fdae50c88a9aaab416cee9e2d147de5e5501f5546a52e19c004aa3dc7a69041e09a68ee9cdd71a20faf2c372ee033903cd5a4b1026fc5ed4603b3a41c3fc5ed6b9aadbce89c8377624f7a31d8776a5f0c8e57b32ef93efd8738d34f997067166802d3b5136023987e22db5a41c6fe2b5c1396f1d34aa573228917878ffcb6c9224d0920ee5ae2bc0801716109131cb48a31710ea3ad362bd6c92a12eb0b6ea062e0e981852608a363df765ce4482502d9a233c5134c9f41babfb42dc988da0870afda8d4866ec90117a70acf50a41f018f86fc3f3c5db86725f23041dc739d5dba5a0a4ea62199a3bf1d7352073860a23d4902453c60213b30704c395028d4e97bb7ff777fdd0b43e7edfbe6dc5c12932af3488144bf55f48de59d3c6e1d7d80bcd7cbff0dcacf55f1a1df5ff0a4df7e860898dc519627934d1b1bd650f86f18a90071afa1e56589448686bcc5498f27a728ec5ea5f22bf69ffa46d719185eb34cf7d02f6783b279abb0eeafc8531eaa58de5f3f87fbc1dc574cfe6fffc226f0795a4bdb59c0d4999ec2777899b48a8572a92c4edd3903e4587587c16648bd30526a6b6c1c15edbd7b2509faf3a40876f683e1b40bf6cddaf5c34966420b30fdf2021bafd14e01b6b5dc1358bf4e7a7e812360f6583817751dee1d3163c8179290b310dc57f1968408fd38301eced88599efd4d47007ff7bec6d35ee5838e700c073cca43923ee09b23f2641c1009263b958fb647eb20bb9389007a0703307142dbd39d28285f6a115ca7ebab3bb221317d2d914171e69ed13c6ed5db8f62e87d4495332309b1f9d6efe3e3a52e43bf0f7788f531cbc20c9948b89491c4ad1de5f37ca42dfc0745be558526b5021443505053ffa370a1310b41e631acff2f387d881ebb5b17f6d98dff728c479045f7733e67fa64ce38ae0081d280df6fc0cd69f041b2aa9c982b9e3e53ecf85182e5e2469ebc0108792be1771de1fcddc2a3e4be0ec3fdcbd9f7689fc95e8639e6e394dd417af2f3558e57a554a1fa670f3e3d1c3baf004b279f97f271956b520f264a860b43c797dd02cf86866e720e05400e9b7ab533b401f577a517ec74826db278a34834e692bd1a15f7ddba1a1dc7a2b6e011bed20d949133f506b1b2957a3210b7f2b2f9832927c0e8adee0e60f56c093581f5ef7936895cf8b0230fe59c83d313e59dcd89b9aa10723fb7bd5cdd88d118c83273719727df297c372b5f4f4d99d39099133f583d06912bb4852f3102dab8fa8a2f25a77c140b89c8e92ece304ce1061510ef239879b771c8df9df0a92ca442a07a1e0b516eb499f74d14899d4a418416c383a8383897a8fbc961e30bd71a1b75604e6585528a9cd971dac420dbe0be962be5a081f6b4bea4c0fd3e4ee82aca046c2640096c6fa385df146d2eab2cd1b140e57bae4d85ea343b55f695c27e9217f8c3f345f7871cd5ac1c92080d4ec41baaafd438da5a34212cb7b0571334233eddb8ba0debdca579030dfd7b8dff0fd81c96cd459cc9521b08a45c95b20b9d36e33e574930b63f28abde95b1f8b84ef74971d74d1e48f271d535743cf0a188124a98723bc4c54b24d3f0e763f32ac819fa2e3a7f1ef6b606bb787a4e43a41ef2440c48daa674729769eca7a2840321f209bf7be5be3650247ee4ab6a147f66b982b864004b362fbce155d69058df9ad78e7e0ce0d6e344c56ba4158ebadf6ac8dbab20b36fc6b4f9696329bf2fa8141af75c4cac537fde0fdaed80daf32ff6ef03cad62b54484e915d397f982693c65e47981e214e0811d9272ed2e4a4ad958ac01634551088e72054070d513148339f8a0186067acc852fe213532b980eef3b60324fc4c63ddb4bbf3cce42c10f3a1b336c01de4bff7a8a5b18139f149504795889b8f506fc7d5bdbf67c7cbdc52e8b6a6cdcf4138585d34a4573a858d8d1149fab27f6f7cd01500bc359f980bfbadd1aa0445d48665839e670498bc69b4afd8a3112845de617f44edeadbd378fd4d4091a4c52b5c68026193b124d576b1b307d3e1d5f89ac82f709829f505ecb7ca708dd12eb97e793186a782b61ab99099f8096433a353147206207be4c33a3915eac65812aa2a7acae96cf4db95a4427e3ca83476c24a3d87843248db21e1abbac40167321309e23b369fa89494661106cc7da186e5a8f5e8f45fa778048789660614d8115031ba4fff190986bfd74c5a4aef628fde040b484e74e62b3122009d867107b1f3273ee2898028aa577274f82fe1ec2d6a1ff138658123217fb2bb71f5736957734e5932390f5ca27401638b2c12e108d4a02f89e22cad1d4bfdf0de747957cb00bc53d4e6c3e3f2d79933397288bf4ed3cd9d3839a3f135a8acd229111034b1cd635a9361fd169e8f6a2ca8efc5a3b44eae36f18c8e05ee559f0850f9eb2cff2d40645ddceaf0db0c6ad18e6401533f807899c88dcb3aa21019af5016be68d1750f2681596a908854c2cb8b503a544df262956766ca017be6d30d487016d299e2309a9a3fcd681ffcbad1a4425e603b960f534eeaa1c86e5b393fd1446e8f4dda6afc4f7843d9a4651d88992819a1f6e5294ecfb8553c24ecb0c5e404f138eaa548ef2f87bf99df7f5b5700ebf97642e8771ab028dfcbcb93bf4569117734013dd0d82b00c6818d5cc614f18532f8d9998f026f6b408ea65c28af5351e027122bd6cbdbacd2d16ad8b6f1b69b6fb1d076102084963dd70847412cb083123499321a13b4d62ed68b15f9dad37f5c377238a2defab51ef7bf841aa389432688985d9581297463293a7555919b65455b114a924f6ba11236b8d3a5bf31a3a4f6312d2a7d0e2af4e9936a87866ebfe7e585182a2b1796157de0b20e86f2c98d57810e715a0ca592d09381327580b7aeabae4da0c6b717a1ece048be62f2142fd2cfb88e1bd0a23463278a305108f8530c50cb25abea900e87c75068d4e0263be22dc9e275f089b7fe298c7974a698cfac1cd6b27a916440670cdd25687973cc947d9cb1c8d01a011029c6d2c17bf97a603ac726a8f458d48fbb50b8fe4a6193122c2a944c71cc11934f1384751c677133e6192742f0d42c25ef1c8733e3af13ba862d29c628f46cda7c89a97b9f3818fc788f22e4d279eb33af600f8332d41cf18a443a99121b229c9b971b21c8fc51ef3fad160244ab7aebc496e1dd816f39d9d95cf5535288cb443168ba640db95a3e6712eaf7a0a99a746b64e4e050f056bab080c6fbf53638ded52c7d3d46239f59c98149c622d989393176afd480e366217147fda80f7277069b4d6d7107fc4008f624c07efcbc26fac59a3d19e2ae3eb6dc2f7fce0cde22ee1342c2e31ef7445a6b1b76e75aeb85f94de5eb4ce845e6b29047b67a76b4a5bdcd4175ab9cc1b8c60f0c4ea317ec78403cb6543e5bb00ded1140dcff8538ff8121a54c26fe65b15e1b5f9707d35dc77e2dd80afc1ee3bd1bb50a324e69d3de3530b6b80587c1c3bd52573ad176f3fd7d5068e06ee51b9299ddcab9c594bb779e332d825bc2567c2c4df7c8420c516cb8e56f0d3761a7106b73b6510d5f5b1bdacbd44527cc8907569f2084162fc74fc757aec5f14eba09ef4bddcfdf5068172d141a58e286dd0e9b15c2055fb265af86afae3e83d9e932e3d187e09f2f26038a878b117d607b4d71ada8a0378df5c7cdb1b297c01fbaf79665dc96e669bafefd57e9251a35640ac17ecb72f501ee2b3f688de19e4383410b5ae1bf54815d6e6389107af6be04f7047ca89c25dbe57ac3b5f2379e6f51d207d7b63608e694c1b863b21a8d6fa3b34335275801e60c116c49e40917ec139f0879c79ae061b7b452ff8212ef9d0b7e695b0e9611097ae9be267ee7c27311e332ac59b6acf225b8d027a92d3b2a1546609c6398f27a760b4c6e0dfde80795f308e4c19df86337a3a068bfa78e8849ed5d85a9b03c792a385c58b1ecae173869d6fc8a35b89d9b7cb26449fdf0ab8bfdcc8d07c149000ad45edb35e9beb5b29aff3872a5c9d7ebef0bd6b6f317b3f4d6853484168a534f4acba99b3515df6a5b7907c6c49eedaf6182e363b8e1dd5193640ec5490acfeb1675dda81d6cd7f62b781a911cd58fe2a76c40e8570d3790d3026971e852227fa9bfc4a588c5146d078f6c095301a7c8950645d72ffb3c1979aef6ab8447d79e3a494790b63145b9bd505ba52cafa28b543279e96ffa3680dcf578d7e19bf8e398be1f95c1ec1810b0e88d31da79409586edc79168f9d54250dec7cece2ee9c84f4623ee6458211e5f9724610d8bd68f6ac58b318f56844ebb13030dc9b710a1b068e48998f4a950ca19631cbd5e44afd2b3602074fddb3d867f13621663f10585cba056c0ce3c78460daea54177688aba0c7ad18f6db44a8fe1879ed6b07e37ec6db7c8e648c8389766ab391da415e985f8a42e5785b7b6dbd4db01ce8f2d62f355bdeb4fea43741fb32a53258f8dce77fad0d1412672d21b75eb05b759e498e180df4c75e41e5a662b7b727043b98322db9c038f8783f5c794684c686a2b8d2b546e0a60194a9a883aeb450187b9db43d2ba8c5ed8c825b01c04254bb7b597eb977facc238273b1225c4183d34b1b2ef42a75e72486ba6f524923516373835cd35f99c1b0aa244c8c5f71f5d89ab928a4a1abf4bd8ec33777c111e176bee517e75f4d6c6a55a437a6aa78170a132f33859dbd7f97062e82c2b0407ebc8a69e37cbc3be56c1f46d56cfe0f358abf29bced39a26d24e3c6d1af6a929865052e47e871781e73dfc24ac1d5c3370f529e3406bed962ae99f507eeda1b351275a500393f933f111885cfac9021ffb6301386b34f1bb7260659bd22620de37323be8409783d1a48b92f782c826a3133c74de69d2aed9b1112a68e1857b11201b10312f64dc9c4be972651258f90373a2b4100602d906f47a6d8054c518887c82c442c2ac8ee52ea6f7a5abd9eafe42af991861e19705c17c6ff14a1241f4e8d1b76c8353f2e51f0644cf9d6818533acf79179368335d1a5fec8a7020468b6ae9e860800c1c21a2a458d64b44ba42ce9e4c46b5e36b811a85df05bea063dbed70afd5907a36e2a9361ea3d1f8e046a05ca2e21dd18eb4ec10e3e4e3e43252dfb1e9f4f175aeb18b0042358e0e3e2b58defb8757524086c5b9a80d6db0385c681eadd3154cf7c9f43fd1010d6d148e430a111d896093bf35c3cec55c0a56854787c3aee636ab3794708031cebe457e2f0e5cbd7bcf228fd145b84755dd2e426bc29082bab069f60daebded7eb70e258963267077f7c34e2f5c97bfd4cfba88dee71f0bc135ffab5edad3acb94b1506c5f297c22f2ca72279103921181af6f1a84156cf895492109d731f5b405aa77e489d05f0e23587e953e309fbb55d0dc2e90251724ba82928d345c78601722d6640c6eaa2ebe84053a178267e21059a3b182c1e66d814b94c951b7d38deaa1a4c2c50c4b1decebcf48093532206fd56613ce96bbe70b09e21f27548bc83fcf8c0bdab83888f57a2ad99cc5935672486c779ea2bd4cde10ea1b38122f4638d91a8b2d79bb1e4267fb17a142b0b8311cdf559fc5622b6bdc43de1077a1ee9f168769337a28dbdfc78a3f43342149870c8181686bb6b45ee13c6a44d8d70399408ac75f5ca6d2b9392b4018ffa2701acd7c5d3a980a61dd83a391587194c2dc532d2f7909a6030cbf7ef8d6066f6d87ebea67c59375415a5175fd71be874ddd90bf5808d272b106f9f2f4e22c7aba70af845b2fb6bb87a8f5f1254cd3bab2165917f33a26f48daf4a3cac433f6fb2636f98b8e84c3e628ba997ea6ab408b6c45a77efca4e9f93e360cbf6b58ec2824b19f669f41faaece4ddbe3d4649a81ce14cb704a57ebf415839a3e987a12699ac4c04ec3584a5218c46a83112bbe2408e08315045c1bf4e9ab0b77684a18abf3ab0d3ce0aaa93cc7a574795ef41c9ee400701db58e87fed047ba02c017c09c27ba0fb8b5b35c0eef1bdb3023fbaba86b9fdce80bdcdc9e7757189498afe0f42547dab13074276f1963ac55adbd86796d482a3de99a648313d8e7544e8abb0191212b030b7a576287f36fa71f50a89b3822754c47286e83e832b98f4a08ad2624773c6d003803e3cf914af15f7ef392af7efcb6bb71ec03b96226ab20c0a0a54e2312b0e327f8f527513d30d5e0e755ceeb2743bd09ed66a105e0290b9b38a305af550f3912ea0d3378cb28538aa16d9637a28e199d84542c5c22aa1b56cdfce52f24aac61c765d2e7a4ac66260b520d564d55df7d852e78e2f66a167c7d08185133e193a9a2a229747fd9b48eb2e791de821d071b6a7ac0868bed71bbe51f384a64614de0f47a23d26141e963f59f5d3a5c4ac3eed831951c196f0cf76796f46f69776cfffd55245950aa27fcc66906372fc23653a88c7191d80feee345937e8273842aa4c126ed1bb7b5288b77339d85d14ad978e964b0d84256688f202c463532b7d30a82d2bb186507fb78c904a1a764b120185504edd8cb2e15e8fde378c15272f757754438de7a34d670a428f4a1f8d229a2f94adf107604fae5c2830286cac351cccc3171234f9542aa05a6ed9a433cd9ddb754f57eaee1bf1d5117b6ed78b502360da4f3abceb74848dcb129d2f5bb161d080f2c686eaed6c8594de4d773e522481ad9eedfa1db16f0d63b7069cd65deed4a6d20aa3a09d2be5731bb35390a6788582a7478b8527272612feab9d72396a4c8bdd72fda8d8019df4bacf35e0f5c5e61fbb359593040c55bb9d713703c51ec7eea095e2c2e40446595494ca5f2a16e5aaf645b51b1352f4b65f42e4428f1b0454855c256ccee7241af0183fe0f0e851cb27ea464575134d65d4370fa8e01d123ba6cdb875818aa633d03a106931aa24a8a41e702fc181bd043b28423045fc8ed5fec5da46d799bb64c588eb156c52ab84fb477e061d35c2a66886ceb7045f43b44e0a812e611418d8bffbb74c9af9c9d60b160fd2cec631df4d84e162d16fc59f4fe790e2ed40fd27b390516a61dada31099bba43179af8391f51fc6eecf02b1db438cbbac485efa9619414e161c2aa9db4bca3ce0058392bb28ffbfe95e705791e8c137593a93e58571a53e69bc8d0fc45a2da02e53fe24d90cbe2dbfba4568f2cb3e29ac334e787200bc67e63451d485c50a801aaa6fe6d4531b18cd17aed60cdc5c5b80b4bc83090d379c711010c7bdde397ea33a8663ef0082079ca00ad644d0d6972eebbf00b6500d94befb17f3d134ebddf0b1594a8f454e3f8593ed9a7caccc21d0833f0fa20fa93dd4f006daaeb4dfd8145cbf2f4b47b04059a6f4aa2e0b68acdfd07eb41479720f3b3760468725268b93f72757c853e9845a8a87fd995f7c50dcbeea73238700b26ba541bd97330843e255491209434f4f76767403f118bfbab617632d63df2be1b7ae6aed5da3255ab2efb8822bba04fbee835fefd39f917b9f63315728440ee57bf911b7381924427d23d1632aab0242dd2a080bc6f2ed19967ff135acff5eeb980fd5f738562e4efd0df5888521aec595578317a6c5ed31930be2870161962cc433d8ae8d7f186f5e00add2d1b451b592f80f5518c6a79f5f5643abb5a55c849587a93d9551ad16692f78872438983899597f53c449895fd1d980f43f52bcacec6d15224eaa42ecb848fd15e5030056c4e1f8c86cacebe73e90acc2e2cff6474277c3baf135657976e450a7d66ca24ef3656191cf4af964a2d1560de814b932b60cc531e18bc8c8b2628746c461a01840ce51bc3f0c5c70ae0299b8b4568c0021ba3a98b7cf7798b2235943b18454b21c38ea202a8946033147e7d7e23d42d35e62efa75e475a37858afa0dffc3442b4cc41b375a76030c222dbeb9607f635f0fb630b5bc51299083f21012d2c678c708dd8f172147b618423db818a5bc298b14e4deeec3714895802b311db30ecbf2d0a209ba9e22b81df650bc0902a10c930b34d28169a7f7b1f87d3157948ebab3465e469d98d11c543467f2c42e7eccb5f3465ccdb02c8d160cd7132e638fc7f3f286a86026c84246782a81dd9c51ba5f67b52300d7097110613bc26b05d5b9da9dfcbe9251fb9f107f8517b0bbce370838b27226ce170fc7ca4db2817718da86c9ed5f2886464996432aa812ecf40533745917159fae9f770ebd7540ebcf88ca74f90c3b67bb3fdae51dce870c400d4973b718548e88d0f2fae8f758ed1c7721c69ff6b0aadbef3dc777a24ee1a94de80722bfcac788d289734892314dd1851a4cf84bf8f59837e5a48fdd9200857f3c568ffa833b886863353e1702de35dd7d7e18705ea6f2be27d5bcde3c3146cbadd68ec05a8496115dc8b955a25ed55b6facecd3dcb500a003a211b3712cb9fa57a746f47fea4f5b5e1c42852a14d26e35f5d25eb0fb5ab3ae90bbbb90dbc2f506afc0e9c4c894f8bdbc849d6d146f6c2f79058c3eaec0e644173f81525eb1cec4eb4c67797e1f752a01a797949781d006670905b260ff27ca9495432c984110418efcf2173e30e16239c080b8262d7ea9e34fce8fc83dfc6610fac71adcf66c943ece8089112bb856b76831002466729abe8e5816de0f2b25aac013d9dfdbfb7669f514775d3e6ce671ec03a199930b19435146246fe2f3c1204807df4fc74d6fa66148d7aaadcf30cc9c50b647435fbab90157e222cda160a79edfb68dbe542874d24af10cdcb71d4cd46429d308ff37be1c7b1fc4720ac1dedb964b73d007d22cf7b6ef6069f1dfa58250363be37c7dc81669066f82612d7e3babb1bcda47345c513fb39f04de7becbcc90a9a0613e54b7283f147041d4fe9e0163a6df60ca4036380d0e6c17ec098019b7363a5fedaa4ca6ae74ccd7679043626ef3f2eee4511e6b873b32fb5cae3af7d67befa0815784b1b2e98207c69a2cf2f16910817314788fd98ae1365bc7f89dc292f0495908a686e67d710361b924b8180be147876cef316aa817894564c85612be4dc3ee22563809c4daac76b3747f72bc0a55491fb15c140b7580025aa4a5fefb935d73bde18c3565754fad20790e68290d8ed2bc97c1d33d05e9e13ab1c6ea5cdeee025968d983552694859aef178fdd234e92a13640e9d4daabec0f0089ac682637f829d8e0d221ab45f981e36251a4b882a35ef7bb11083fa8355284a1d33950ee8d23e45b885a28c1a45ac2435d1f9bb33910b352638f4c8ccf6e39b1b9cecc201f0343cad06b3f427eb8738293874bbb724044f96d8a8b6f157af5aabb21a9d03727d370ecd317308e4f4f906e69c65c7cf6c177a350c56c91ed7a4f67c70d44b971ba6180e5516487d387714ed74bfdf266fd4e17ec91b54d401c473ce86ef277551fd9f1df82ccee8a7dfd4620870304c8e02a5a6ea8fbb0c77ae6d975c7ba8ebc10f258af6abcf7ab62edc61a9450175fd59b286a721493fd2aceab59129b7facb856c6ecd081c6d4ff00c7513ab94adc9a9eb52a37170758c90c04d268c9864a34a7c360fb5afd2d140e0b21d8f78390fc07e7bf64e689390d707158f82e606c835afee8870ef4fc1a0025211512113b9001e0679d69adc95f981bc370bfe05963e100239337ae7e582653f4b468ea3b3db24c0ab84aadadf605ee3af0fac55b7c80513e1b7897f9f909d0e2c30c3562341d60fa46a2d62af54a136b9fefbcc84aeba0705a81c6123956040fbf4e242cb78003e4126cfd222937100990e50525b350b4c4dc84ad6fb4bd740b49e0047239ebf28f715b60fea2394ba2b92607e647d6535a93e5391da4c31bdfc698311fa1272e553f2a2cbd4697164d4126f9cfdffcae5a4ff5b3c1cc088e134e8631bd5d71131e0a8d172ebe38331b42fcca70066c877d9ca11afc0312bb2162b1cecd54ab9ba5e6be5d8d0f83171be43ee7b41160f7caec326cef4518ca908a14ccba8b986e7c74f76429fd75bd0bcbe4dcf2a56be33ed135c36678970ca66d1f075c0d7fd4a03cb88664bbf1fe4cc25ec89f01848209080dbfe5e57f6a05c2efaf2cfd682da33e595300a18ed667c26b7ce56f4efd00fb902e5c17c3c709fdc71af8240583b3cadee78753a1a5a7b56eef680c6bd7e6daf42c2cc178f22830042769d621c5487498ce52f119162db069f42f48f9f2ddc1f82c41cc3192be459875335acc9cf33f714169db05b4bf08202ba9263c1ffdf39656586b6bc67a72acbbf0cd4468eaa5b05bce8503042f186eb235246639259a09bee23cadf601d707dc456abf2476707c75a61f0fe84d3161483814f876036da4d37cb856ecaf467dc704851a0fbd093b49da98c6c30cfc02ec70bd7d31995c6f360f4398f80e4e4654aea5ecd57cd2168817146747e01d2d8aefa4465f756c0d470a3cd37236b5d4089d9956cbcbe78de81ec279c61270f0c099209cca37eef48b21a2137345d825397dc85d3d0a4f283ee4170a2b8f2c12fbc0f1d7e47ea9b954fb7993d3ad372c74aa7f203c696a289afa82a688175f761fc6b8dc5d2e19e3a4b24bf67ea166f151d3673505de0b59082deb9e308829da1cab383249cf5c07db9d41544413ec94254af290a12a6f9e204a7184c4c02fbe4c0bbbc59b531dbdd00bdbad35a3dfdf52ee909f1e4e23525185e726c24faf390a591ffc2681ca674cca7f01becc6233356dbee3ab51a3cea40dde6659001d04b3ae1c498db8777b75bda1a2522b63586543e3fdf46c885071ea4582c784908ef2fdc683d87b084b071cb0cd0e16fac04d44cddbf80972a2e067746c6f92d09e6194ef5d83a9637584e93d2d4b6cd39bac150c18eb7e9a1073484ea47b24d3bb63b99c825f4668796888df0a3bfb9675457709c375432baa03c1c4e0868c2b8113f9af33d98e9ec3032744b6909c44cacf3850197d7e382b88b55ad5630e5af660c0c1fa0e955db7db5f3244a6efd7c3c61a146d83d35f330f77cf63fc3f7658c8ff5bf285ed2191cc1fc24b29b8d4951f8ed90fb8769c2e16e087819e24a6cf4a75b8f984c5defce54c9cd6b7bc098e6033a1ec6820999debcfd70e472a44c7287c7fcb2efa6850220b695b09f72c4983ce4793ea22da8c215559b96a2579ad5b0cd8ecc3825f54b0881d4322117c633f42d2f9508ad23415d9ee2603e0a662d9d18754060b4b183614a8a33d7d7a5644011eac29bf5f41ec03f3a869f2b93383c6417507f48e9c03f6aa227f6103100b68c5772544a22f51dc6feb02665e8f88649d2aef827f0ca2f0fb9c399bdc758651c944c6384f0958415984485807a0ffc32118bdf068a5b73c059a0261d2447e1a2b3d5803036454d46c9b3a65d86e04b7ff175c4d8b0b8d0d2e551e652fe2ff40fb11bdd439b2582caee6b2039decd56baefcd7ff6f3b2760310cfb06386c4c1353d125f3413c2db67be39ff373a54a5a85a9448b1cf9675984496d3a4358f6e5b287c337b7ff453e17076420fa1094ff0e7a455826a6a7db94c612ca3f7f5b06e42f0a2748bd115c9ca7c24041d51d7a14205aaffd5fa2879f6f0a3c150062f8bbb38fa5e203c1bfffa16daa0e74d5651e3c58bf9ef03ff6492ceeef8cc93247384cb812deec25d879bcd90d1571b06802277c912e32c77df6e9125ef23a50a7dad897af2d6ccab49e0b4163408f3bac858c3afb5fd860dfba016e737bfc0c2fcee73ffb8dc7b4393c136da8d556b7ee9a56fc387a0c637e36dd2341ea9a080695e1928729ebb4406c87a0bcef2432b49b3fee7d5a78f5739e92b78aa751e8d0559870335a4401a5a7eab8fee8e349ac241802dc76472f5f2a477264b5b8fc1bb28b7af75c7a9939e58ec9573f1eb3e9fe938f9c46360d8e1bd93e676670559fdc28cede8690a66c8001fd0acd5dff61db29e0efbd5fd9721832687e425a4ce8a0198112743fbcd9f3229e56462297db65378be17edb8eb93e7d2ab8795777717813b6f3b6ba001ad95d7e1b660a84d1acc021b1a793b7ac7538e0d5bde627588783284e97fe8437b55e5f0b8fcf2bcfc6d51d8e61b2fac96340d2380f16b70c0e6261d899c4c05452512db5b54159a32df6c6343be70a17d810103ca12f04eab64d608ac29c2a7496eb0c5419151f9d6fdc2b4f10a0e7ec8882789a5d959061d3e685715337a48d27771c24b5342387d1a54e07596f8f7f372df20b007deb129cc7e3183d301170c57dc72b1ebcd215d133589e29f9ce27fb00dfa036ebce01814a7c87324e0d234d63a932e1d44c6d21885338cdd328bc60b7ffe4c6ed811334abec9885ebdcccf9cef0daeefd557b1e763b7de331498f6ec810a4b2aabd709972b374284e5c5fc6a2bc12c44e7ecabf0ca954c9525a40eb1dcc495f006bfeb733ac28cb0d4f093f8cf7f1b3fa1f28458cd72bda9d540ef029c432808d173688810b5f545330890dda92b9370c6eaf6571a796007a7293f6e50fd6c71c227c05518bd18736ac390295b8f5ab6b882cf4b3bb9d48323c97d99ecd42eb02504bb25af5d319de051b31523f079e088763a3300a55585bed4828fca6d2a85898354f388f072b9d01b0d6b1f6e98642c8722255a02e3774d8e444e769cc9e98debaaccc0f852204147b465e0cac8ca310d87016fd5cbe37a6c69c10f6ea94efec4b6cd55a1e8364d85bc9d9231e1f4f49f0309f787eec7a23181b1bb8bd1576c46dadb8dd6fdfca3b5201c403a6d5177d934a04db5337e9cdae829560eb6c40f1e38a9a6b8fdb4cc2e8ac0743304c080294c11a8b9b7b275f731a66355480425427853039f97706e722b8e4bef5b4cc0cfce46d19f360016f1e4c6cb16e8ff6a41559666236a869ed7300e476acf18ba85af2733ac382f5c410372d97def4f9e6a1cfe648c2629cca0a270ef66afe41b073caca8818a8d43bf6188b226d17d199f8afacfd8a3f872c78fa47849fa4fcd3dfcc8b44b96a28fab07d36c97b7aea6cddc1435fb69fd8192c0dcbb87470033270b2ecd029ced307b2a104cf8097180002275ce1963959c40a53dbec4a71e0f46600433fc15484c64cb66c77a61248f12f358d56eed64e5704f2b24389c0f0079a4e13caf8ac4a89a055f21e7977a196621ad33756156b8e9d1e1e65c2ff491557d1684e8773021b6633fb66dedececfa5888e329843cd86aa55c86abea4e44363e5a017de0ab960fb70d7a0a5945bf1fd3175341f26f99f0799330db49fa3147e147e86e5b059d8c9a8ff29ba79572334e6d056af721ee44fbd868de4d07ba798725483dd3b49faeb808c3bb7442d61e4fa8c8b2dfae59c5cc9e44c870cddff53ede344782eba5eccde4542b230bb7f69cc7bad56313bd4145ff77dae6f586273e0fb2ffde79456e40fb5cd874356a7bd6fcbaec6dc0efab6ad6508b8c5e434b861bdfea01c23f1e79259e0332b466d37f212e083a2970984cbcc5600644cf245fc3bd8224bde548e8c8d03cd385e2fe962a61c7a28914a6ffd33985ee93d5e9646597198af7b17cc3bb3dde307e12b2b02fcd1735fcbcd8ca4ec8ed5ba6ae575dc309da851fb0a11c20ef0b726523da74e498052543b4028be53b31effadab21a51ddbbba8bcf3b122bf50a6356fd38dd782275d6c83d3d26355da9b38497c6cd7d7d8eaa35e5077628206c7742b60d887e0e6453f687c08bdb014b8bbbad0e1001effa5d7d4d58db85503504d23ae4397d04ca2a6c1dfc2866be94c6391499b545e18117e815dc026d38900ff52d93a57aa5c6945f1f0198a1fc7adf25bc94a3af6a81661020bac376a3d0384c502483cea6a66d9dc25ae5cab4acd39d963d516eb49b3e1f779c52236fd5e42afb0e01c05c6158ab144706dcc9e2c7bbae6000b4e568e08c18416d5339d845282d1c294d99241e2da9f62caa8047e24cbb75bd2e7bebc5d1ad18500d3fd56542109ee3be545436fd33f23a5d3ba2bc0954356c8400fb2a2d7027cb6548414638e0536136c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
