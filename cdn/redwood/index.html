<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f0953e520ce6605db28e49d8b5e5916f79a576e900735dad35c53fc73b10ca4ab1fb5b208ba49d87a6ad413fe64fe06e8a4c4250673f48e22223a007c8aa5acee8f822203490772c7e8afb2fa0aafe1c78d6c97e8b957a6b3d7236999b0fe15ce0b4b26591084a6b2d1bb73d0ba6ae1cdbde09a9587a57095a06cbe050b92a9a718108a9034dd3eb304380f215be19991448e6b4877e645968b5d10a2cca2a24c781564019825e6c36f559ea589c6b72e22c38a895f5ce4c971911aaf9c8fa2d5bfa16bf89c6a28ddbd4ad20f0944d113623c4fd6adf0a039bf326ec332547f4fe87972af9ed70255609c66cf320e8472dea23f63d08161e07134f9c24cca06cc2cd937a7022c55e394ff7d43e684dbd9e9af42ad44bc82ac7aff3aed860906f07d1add08f33bf7f6eb17adbed5d2d19d9da13cd7959f018d3d419e0bdfc08df637aa2334ee97a0d1f26b01b0ad3ff775c3a4c6cbf0a2062999cdcf7be3a84b24b545094668bb982cd681583b7ca9286318f409da3bf0d381bc9fefc764b965705a4ade164b9acaccf0e6da9f145dc69aa4f00b90d540c286fed03f9dd317ac4e33d1a6b00fdc70ebc38b056f4b635019e224d902ac5ad5fb5ec4ad9f289cf1a050b57cf2bba8f91f48b78d07cf3cc8e014225c420d81230849380f6b5c48f97461f029d18fb121d7fb33bfdfc5088d180965b293d489fd02856b77282d5fed846007d12fa2af34cceaf9d12fe178f4f9fa5071e130a5e38c5cdae6b5ee61bddae3471ac89e470777867abdddccc1f09a7905ccf5080f3fa149af894dc83f59e7beb5e208967f42ed4c3a259cdcf6666e7383cf38de2eea8391e69fada79c78ba4b3bb377edddbd89ebe7f176025216600390de520742de688f130b252f0229543fa77dbdb6aaf43baaf303287fc82a4c1cfcf14ac3904186e2a3b79fe5ae2a69f297840dc133e1169deb5cac832546dfa5f92234ac57d1e2aed6a93dd4c872e12178d2f8cf3a70aaac7b2b986607504b301c05719502e121a360dbfd2a6e9a59e9353b79cbdfe57dc0cd631c65dafa8b6d8e20d6b73c7f0541f00b66bf05e4aa169a92587fd963326b89529b689b2b5df3844b9a28ba93a140662cd70a0c3fd8dac7bca4132faef968bc7d8fe6f65a51be6b82659e94d13552a95e8e8dc62da06bc2ef05984ca5fc94aab133686d6ce7e63ec5f2093591b6963df34927e8e5454e01f63fde4220a415e694b0728ee1b905289dac224a50fb00ee7ebd679cde968016b8daad8bf35e06f6f06dc3a10cf3faff066a79781308c4c30f84c2125fa93b768852c4123a6c2fd653d1f6ad2e0e4aa8139d37b2a303c10cf2a6ad846440706d11b4234385e741b113f31294b9ba15e5a9e11cc05aa0538f6a627a4c3e9d3024c27a4dab8ba0f43a874c197ff27189b2bb910acbbbcf24611a93e4c3859169e7033d841b1ca09621c87f3270e88c1acaffc86cc881b448630cfc5aecfa76155d5fa9b7fc9176511b8804d9f0e1cc141549770184eda8ed202bbacfbe4dd5dbfd0a4f0feb76e8b24c3aab5f2ff795631da16d98e7a614dabc6f3bea80d39c41a870d8cb43284a0cd8e06b47f361c2018752aa323d8d53a72d6fad78d36c5cc1abf9d1492f71a9afabc8c74266b065f39c046a44705a6877bbc0f3ff635c737c921983b4349b84c2ce35dbce217e1ff8f00a308f3360d04a022e6e3f4caa106459994792dc3b82a419c47b7dd398d90f2a0a2b5aec888b344e304978121a40e305520a0488e638a240209b196499532bdbc96c99e9dfacf45709966d66a7cd5509b57b9e90e385500b56fc55d90ee53452b1076944c124d780b1aa28c89ddfcc6d2089cc51fde719669d97c6127abcb7b14f73a5e47a4754db922601ddf60a46a35bc7104087d1d0ce3e607c3f421ba717e179611963efdebd086e5611cd48b3479d61fa074346c0058366ee667e4cbd5328feaee83d2af33e4f71bd02101fe67b1d3d382e4faa5d9cbf9ee22da3317a2ff71175d70621fc591b0bd3e6523215e69a5f1306fdac6bac4304b35c0a355c6abc46a665aeb1d5119957eb77cafe07af8a59811ec53e136b8e303a7a8b891b16c409b53a776561211b4f5266a3929ea6b547dcfd2117a534e896ac6120008b4d027933c3c5e591c1e126603f68900f395bfad3862c8ec301104f8b1a5f98dbf8d4bfd693fe7e1132a7f2408253a25a453f272617d5696184b3a48219f95b81b6d9d44afa92fa0a1936e59280883668c253d9b4c5a9bdd6186f50bdd0a91042b7f11684f8b5e0c553dea9b06e758259a18fbef984d208ac3f5488c9fc93c08d4c751866a36e7c4e72966d74b15af502e3518b0417c169b2a959e5aec9a94c6093cd0ed0d535bcba32771b61911e53bc2d735422f8e5df89df104dcbd74612c9293e863ed3968d8aa23a20f8bcd0554ea0e25d8b648708fdf46c67a84c9651cd0580e0ae262340844def37d89b025826a7064d599f6425cf06693e8cfef37244e87faea38d7a60196631048ea9c356f5b0e2c70208e609809d475710d2b311866ee658f5f84fdf327f975f3cfc4fd9d7db8d09794fefe3055da574f419a9d98658e78325922124e2ea26d4fca0ebff4cffd64bb3c76040f6f6d5433c2dd970f7978d8856863874adee1161a90b255e6d7a3850e18cfac9b74c3a8bb767fdd1e4edef86d223741c61ebc0381fca35f06f0c2024fe1deb63655fca5fa4ae20543e55d2dad45ba6e9a81678375cfd2ac877e738366f8e34ab20581beb94f670d6f60859006e7cb3d68a774aea8c5d960c0586efc113aea3d1ed02c4472034e72d89360e62e8215cd2982b09d6c03c7f173869c4b3a6e3e718aa902d6a5cc8c965f2d5fd3a2ee8e6bb887c1915f0bd0a17e41cee1eeb55d5329798087e7e94079a728389f9c495531c1b891063a111b4ba0c68c5d99071df73b13e9507d5d114aac943f82e43d7e88ffb3cd52083febcc1cf6a65c0e9a519ce256ef30c138e99d12d64b31ccd6729738b4805bd4e335b49aa72fef7f7cb1d264f7f303fd4666e16d133b00ef467f0619388dd27fdb435fe9188cf7e2dd8f9601f06ed49778fc5b6626297b9be7c9d8ebbe481589e04d6fe6e895a6c69a7d66fae457a75ba1244055d5ba4ff0435126e605b132fc0433328290280fac5a02d1ce18807e2d0bffaf3ee05ef953fadbf7992005d54478ac287d15cd52f89261f3efa347c4ac3230e702ffe83a49d164ac3a19c0e17cee6ba730e2340c08c2f7a2c0854a66d91d02d360e7dcc5e8c412ad55e10bf3b308fd3e7d563ab3e415e9780aa37b06b9ab7dabb829b916da55399bd63638fa44a91be243cb218460e848df42c251b1ef78912624a97c20039eb673b6517fda560684936c5182b06182e9f1190f8d8d8cac1dfefd54c0a6e14437023a97271060cbef7d7112ad1285a249b377b56adaca16e21858e0be72a7a99ae4c5a7dbb643931ae651c605baa55b5c6782b66dfa29b635091dedf1c00e4247cae8e1a6a98877d0e1868379dfe552aa33dbd72089343be61ac9b5554aa16d861956981ff8ab4e39ad3c49d83fb656e5d535e840b0e33608f619eb850e2c87a99f6730040888635066b5270c64dbb8add4d8adfb752ec190eff0f3551410cc1ca8407aa09180ffa37ebc53431a7480687779d5b911f8d5997b0f2feb138574830d3253b8251647075dc28cb69dac403cced1e06e8530a79d02b7dd6cb0fb3914a0096b37d98dfb8221f3be2a90e025fec9bcc1fef42a09f6d538a8efe6dd716c6f10c6c153a16f401aaa78c1360f7ac4f918b6024a29bff5d48a806cfc76b3a6ed5eae986ccae06155e9b5f5a583a678eaab4f827b60824f7186a831ac068488815c72d76c8928c7b00342a2a3d86393f2edf2bf0da6f6471a8216241b122c75a77bb5684c55910001d366c815b73d999b1b816c645128cd097df89f7c9159b025c09e2acafb24c1fbde4b790c55c41f49b3037811603b505016633ca9f176a56d3c46b40e4fa0a7b3ff9022ac7d30ed8f2a87b45608d1d9854fb8ed5e50d32a37ac835eeea924bce2b1999b41b2c7cc29b273a5a8960245b0ab925deeb6a4cb615342c7e8c80e82692ecaa78f92f327a1ea9e56644f4425d70ba9dd71fd3eb26c365273992b1a7c857c2e392f4b06d5f27b3a7135786d8b5156c606db652587f0ff485bf721be66fad9bd40c404f87e631223a28a940bf76f461596e661c6d762f5f8e93dc2799a0a30310ee71735649df859922c9bda56313ca97927da2177dd72bdee7d5e401449a6c1328258cfd7b4081a1d60ee5313630a9259a372f714379c04c337c3d3f25ca931dd846567d3ae82b149d86f1fd3b734e1b1a901d920f46909a3dc035607512abd53085e9c10403b0d1ce6e91112e20847d73d74806e2b85d6e54a32afa877efad82197d08e9b83c5f64e3a2acbfd814da3ca35e340be6c8bc064f1a95968e2822d3275aa423bce1f4cd3efc80259e88a874684e26e1a8b2868b320abf898a60b8801e378b3acdd5d07412cc3d8bfa31270710476302a4b39656795738a15f283ff7144298b285697c1492e7d63b098506b1b62ac76c4c4fa626792157f8c3be6a2c4146eb435d62cc0eddc2577a95d3e51db100fbfaea692174c22851470f3f865f054083d979cbaa4eea15fb7d794cee71dca637a32ab60afb147c2f27d4cf43d703ec070be025a0e52d2fcf5601fc203b36ef7e0e6451f67576c37e8f6a400ecce6362bb56303c4fc0753639976400a1e2e5ad58dcbb3b7ccec4e55baaae006f246f78f5c309e1c73698ed714cccef1098d69df4a3147961590e8e0f6d3380ad7f0ef92bbd56203606d494a0b9cdd331f2d0015823ec0567cc52ffdf1d8da2f6c07f74e528e4f55d6cd7f3d3ae77cd87f910077210235604d10c4eef09c5aa99ca8ad9000632678aa90cdba89d95df10dfdaff069a8b059cfe966e2c6e0ea90ae32c7d0042e058f14e0cde62c9c78d2be3fbff8c8f17714c79e7edd726f234b069841772eadf0e6982b14e1ae5dde663fb884db5a5b51c7d79bacdf5bf1d66c38b7b64922ad640b77993933ed45648b8aaccadc67f8eeb9f98d933178c0106a828e3415bbe69b8dbfe9ac46229306e5c4ce12a16cb6cbef2779263b3ef5d0266d8027ce6db72ea4e853e61b4819f0e52d2aa4f6e65912e6e91405d72e0ddb4eb8f7c4fa7e581b045737de4ca968cc1fb62e1215b5bbd823c54bbddac20d8c8fcc06135184c0782e3131ac6ce99849806925f3d6d6da76ef8b60af24de98bc62bb6749304ce7cb23669655c86adf1919c0d4f1f4269e22433032d25275f1cbcfd2dff4a7c469a818c1b09d05e7d9da2bb5370ed85122421f5b4e9fbdedd3d319da7054603b2a2497121ebb405c956df0ad095f78b2395b58dada3d8ceade85973dea53b716148853d4620606213fa96a49187efeafe212bffb16adc343d643d1017346c7d35c4ab24f88f23b19307238fe4eb00b0349baf871d074d25f86b74582e565c260ecb5ca5269ab706340928f2a10e464592a94595a4b088aa8bcb60c3ccd4994383210cd29ef7ca8b344551811634cf60803db429272510fd2a4550ae02ec246cd3520761791be1e10d77bbba87dbf739d265648324866cd2b15bd26eee67c261bb436926cee5f05c7c39d65e42f776ad66c3b5ad0d5ff42a27765dec16f3bb6ace88b9a00697d0bc895d81861e31dc8a1debb5055edfcadfd427ca09fae0125baac15682038d4d58bf1a7145e18afa1d266c8e6c8765fb06b16d24e44029e0e287b8aa448901a18985b67afa78cf05402c2cecbdb6a829b32ed7dda6a457b383464117c07e105096e057ffc9a5d4c44580e00503ffdcc2c6ec69c2ed9688418c0a4f16237de4c31f637960144ef3acf9d1dea9df951999729b3b1efcb295ae09b8b9e91e015fb1533b939465b3abf6f034734ca947a666458d550b694915a1ee92dff2088cd1d4deeeb1d52808efe304a733c7b112d202eb3ad31879b81edf18a21ae3f57ee7d0b1e498cdc56de92be085f8c4b5f370eff7b04c05bd5b73e389f3f070570da74ae4ebf324dac8ecc4ecbbd4e60db5b8a7214186f0a1ef5d3c9f4a7198a5425a7178c5a66f18f8a7db9dd0a304dffde19856df9e2e810b9945c72f61adddbe9923b517395056597b5f1a6e65d6ec0e7c624db9564415a2cd75cb1e88c9a3d26314c8e1a55ec9e7c483c06639769da000a0307f1010d4777d02175b951cb3a3ad649bba034b247b347dfa1bb93816e8bc4508fcea427bcf9f8cd92d93c9c46232963344c6e3bccadcf92976c7caefbc42a96836c8dd0e3ac69519396ac95511f7284699bcd787d1d3106587e480d85c76b3895cc833b68783b570b74cb6342a08de4827f1d4a66ea02e9424cc00653d5313bd6719f17264fc58d8252470ae47ea3f2016d8f30c54c5d72bf8e16605eb0b0adbc71f8bdc012793909fcabf6d37580b66b723ee1df1d99c92d043464d2b0cf52f57a8aa4db015617680afa34d99c4e50c0173543eb1a954d8cea1338d6ea12e7605481ccd2e075d9a6991e9b130908b5dcc503f545dd138aa0efbb916dea61c2865d7fa2ed8f32bd13ca903c5c89651f6a356cfeea18c6f71e904359b0a68a9c67d31babce800ac84350e30dc5e472a6501188c4c08f366e8b9bd4b0ddf2592b00a0d531e42394bbea377332a02d5788cdebc2acd83edbf5a9442c0fa0ff508fa804169db20c1670b113624a07426029517056313069cc2cfcabefcac19dad218b5c5cd5724e2cf410797bf90eb1ae69c4adc0e6e7e1ad828f27f980a7a7c765c7a6a3dfa43eb6aa2317532e2ee30351e850aa6e5aab07dab717c881c39c7ff34ebfcb395fde504c5eb005f1cde84d6285ce612e47055f4528238465d734f6fb1dce105847f3183a4d2e533d5baff0efc69260052f66c53f20fba9336650fc1378ce5af910abe912beedf1ccbd1fd11d55218088d9dbfd0cb26e764a1f3b47aa3c21f32732966950b9b3607c92b5e0669389d6286e5bca5f6c7fa1f4aafd097c9e6d54c49f698bf2430233384307f367208f94fed1b77de0fd9bfd4f0a41bd6e26be377af9d501cbc1eba3314cdaab9cc6ac79e1a42de93ad29990ef60123995663c53ef51bd28bfb5d849d8015a2d2c6a3992ebafbb08396efcbf3d89f5348b7e8416607e0384d09ce35500dc7a6e1f722e457c609e83ce53c4f71a43aa7e12a3cb9fd8efe1d03fd86293c3481edd4df11ac827cd6190857485e555b5f795a46dbf47c5b35b016450083fb259e7f0c7b2af89ac47ca6339855391cdc788529f563e31db4ea261047014831ac6c4843c6a3f5cf4ba9930984be1b8c09e6c0202f0d8593bbe8b0de1ce6ee0771360e2593ef774a79b2ed2d3aeefcfddfdc9cf738017a2a4326a42197b200d63cdf480e3eb772a42095179ebf05d5982e3e59e63fd8d4868363754255de46f3a65aa8b6c8c117135396e19ffc1c705beaa9736f6e8d0dc83aeac6641447412340bd3ef1fc6732522bb5f4971254acc3d1e23dc3d9b0fa6cc685532b3c1b8605c0adfa6004f7e12f79ac8ca74247fd342409c414255b98a55d1a2b58597c1e5e8cbd37ca5805a20e5a7108d640d4f97287e2f7514d35f799f5f89ed5c90a248142fe34673ee9b2e48164cdd68bd5081489f2ddd99d44c44f413e9e6f34f96194fbb7bbe556a0a9289a0c146934f71d7c37cb33c4fae0d7266d6b19421073fd6ba3c08b262b9558d5bf7bfdc933e352d5228d822891dad14e27d5642484253b86b7d33361ccc6964757c903fdd491648f8da78d8ae366e9f0e472fc20efe3cb308f2ac79ba7004b0dee5a48a523ee1e69839cb3137e79ad88579661d62f16b71b06d5644a096b68e676ab4f4a59c31f645907680ffd7787ebd9e05a0c2a486426aaa6ac990b780851fac69d5af916c5015f186da00abfa89cf65c28b5206d0a633f7ff1f914ea540a3f6b04e6a0b3bf38737d2d7258786f5c4e7b10e499e392dd1c1cb2173baf358c737f72cdd6cb6927cb14831836ecf3d9accefa6d545782e45e7f9202b62214abab7a7763127d3b5d1db98df40f043fad0b8c3c731b56a7d1f47c2fe7eb7f7ac270a0a0262bbeeefb1242b1212e753dab2e37ccc36110066d44c3464320f8f2c45c325daa4530bea0314ec678b51fdc5f346ec99600afb0da224d4d20732788406f1583ed6e46662c67bc22b21c295e1a3aa6310f5f6c035550552504df04376fdb02ace90484d723b709dad93bc9cb16974bfd30f228bebb44d6f3f0ba854fb27823ca260683e4e50cab1ea72ce4f14c3003cc20d81544d193bf710ceecd3d1014753256af0cb5253d786cd140ee21915384f157ed21690ed1c4d3998aca20fc93609529bf464cb9c2e936ac8da9d9c68db1c901473137d75d856418f0cc9be4ee4c980b5da24fd90ddc8365b90acb5fd578d2bc933c8d96fdc68690419c570336c1290d5c81eaa4478879ecff3ca5da9bcb4784185c437c47c4acef54e4c82463a9a61cf2eb6c4f61e08e9bfa33bae5bbca30e644e0e49bc4bb34aca77e47d6b04d00f26ded07f89fe55b474c1c58ba841279f55d916ce5581b91ed1a467c3561637cacc1f0ac1931be1f90cab35a351a5162dbc5be504aeaaea62f321f6f14a8ddb94e53ac75afacc9635833c7706bcb72055d4887a931f8fb20e69e7e54058504512522898a2a40428efabe1f5e8dad0283a41fe9178c765797d5a3a120493059d88a8c8d549014d623bb844404f5d5bbb62c07d1b3bb3e4dc32ee6026252cd99d92ed75b5d74e959deceae5c1bef8f0f01b4c724d1409d8ea6a77e4ef894c2755040ba3f9124488f5b7f15bc5cfb480fa894db6bdb538ae1d5a1c9804ff697c98ab77bab3c47be3a5ed63c18aeea85882a8cb262d9234c68448f6703e6404fa9788b2d440f6b8b936c35c72e781444b499cda4fab213fc1f6bc7b15a3c4943273416660537531f223a053ce78960fa9aec550a1a6b29988aca4a07444b0330d24bef6ade3896728d339371652eb1ef4f01f2ebec384f53844279f550426a65235af040c842aacbcb6f380701f179783de786185cb1132fc1f6555a45161391c8f30d1988acd95961edf20b60eb06e89b441efcdc018f2450209bc56f4cdb5b4a06dc209af25cc36d5934761c10221ed8ae645737816017b66628028dbf7711b9ea2ef94757b23664e2658a70d812da98c214b084fc7291352a35edf442b52385ec48ba25a18edb4f2b22693ae4902b2f809c7428d12025d51a16b973c0ce009fd25bad52be8dbe60d7c3f2143a11db0c9295abf7c5aad210160f501af6a80c7f7aca4a00f1e1f25cd2b7da30518a3635a9051e92679573077b435aa54523d367959bb51f19ba4c46b36789872d8013693cf18dade020a3ef1478b0e85d06ce612fe7ea3bd8ba3980cf8f151733f18b580697e7f014a1a71538d80cc7b552bab3762ae2fae3a10087027b05d0cfc4ffe7a4566b3bbf2d3f0c222d1b3f89783427e2bb21cf4cf6bfb42e06d8d675bd4547faef4df8aeed56d74019dbc09ff3c4201e7e84c4795cb53fdcc16e0f62994cb7ffae00b0bc3142559cd70314c949415217241f5d7d8d98e8350d42b0d75d4550e7431f9225dcb065ae5b3b6ff2b0906540c3aad602a1b4234265cbeb7f89bb0a1ae17be320c115f5a79e1cbf215ee6d3258510b540e1eb8feb04c63677bbf00dd70fbd0c07a306c25d7de67ef5fa1c2311478152d6e36bed9f56a5312e17cdd552605e9f6dad3ce1b05cce330cbbe78185337b7c32d441a0c8f1bf3b3894d2803b42da8567b6185953a4bb07b3b86fea52f7b9ba42a8b60dc8789d51005f52879250d5841939dadeb79ae593a40d4a00340277315a4f120b15c434bd257b09f5e44a4a59bb6ff15f752825e39b60be5d53c8efd96ce8a69637996a8068a9513d22d0e72b4b9fa9880096dbaab86abdb4789f2701b2dce18c005904325f6a73bb87a95d83246032637ebf05379814058d786f9d402be0ea46803d385f17ae55777f7e69615139620a2f1b17ba6655413dbc4e7e619cb3894678c7b3f0cd1f3a86e8a810224cb56504170322179835440fa80f13bdf12a3c62f0a3624f4203356377e7f21c167f03a795b3170863b7f02c70276178742c3925d0be2b47a6a3fed6f86f95c9bf2069eca12683684f756ba836cf5935844bcfaef8ad6b6ec6fd5ff7c46db05608d289e4c48adb73ede36986af91caae27507725479973306edf1fa27e3c5a8f593f71dbd012adeef1049fa9be033aae9f53e3c28a7609b59d46376d8276718608ae41f7c453f64e4cfcbaba13677d9b6d8937823b821300bde0c9d6ccdec4b831e1f2515dfb297da3d6466e36097675613fc497f5bdf06b5272971b1759d8bea02a184c96e54b3a55aafd7539a023d750def550ac10cd6228391afa7c365774dd77e706bf338a5b8e48741a7f2ef46991c9dadb8641419f61e864e3d31187c6073c9e4c1d9f0654b2e3d410afa632938a8778d0e31ea49372598629c96585e8d8985b5dea6c2b1741f342a84a37adb6515ef5c7290866e561c73cb5c6e3e172b3b85dc1edee23808c7ea99aaa79dc45163fa9a76a8ec0c84aaeea3fe443a53abeaef9b088e31aed6117533c6cd9b6ee3e5f4bc18b0ed0e8662d7bca9bb89a2970147b7c942aa0baae92de7519ab4d6bb4df9246c1a3f9d13f6e40de5920a308570388dd08d9e97928978b81eb52ba21360804a120587f985e084952bc3c574eb4c7121ced630cf6ee892bcc4fe80bd39a0a2933591f30fbd42128a5cd66d607d1b06f42a901a485046867fdad1a181f7d07cf0b1f858645ddf0519db1fb832ae83f2e16d67751254e1a1f34bdbf8afac830d6e4668c573ab91ea4fdcfa14d332605d769fc605f1e4df47ed0a4476bd6b45c456264b04927eb796540353cb3c7c4c092a0bf86af0f1d6d28fe375a4d6ade8dab3e46e71226eb95d6c83de94fdb6ee360e3bdb3084410ff5f1d967406d67b66801d0a6221f7dba1a8f4622a9fc65e41f310367f137a26653f435228cb89d36e47333ca13fe19e69b1ffec8fa895c7486a5fa7678ee154cf493f7fabebd2c56826f119b5e685aaf17d323a484dd79a262e3355ad1723af6846416abb4fd3cc59772e381378ff4bb360de21d66b7f2578314a09e628bee33f2b094da74ca43fdfa031ced189c52453c0ddb3870fbbb00a15ccddc8254712782feebc67cbb633a45be49e73f051d231c6227cca20b2cad4b588340aba08576d7002a2792095f618b57101bbf5b34dc73a3f7ed6565962d31ebab171c36bd214b24f7ee169dd01fc916aa0f6fcb10998bbcb5be9725d6c5d466437f34857ace07c1a37471b92c5d26ad0b5aa5d6aa9dc763ccda4a00fe54b1806b2d2db007213724b9eb9465344a96a608c5784e9bbae833368b28f2f7f2093d6eade2edc1697f2e53bd2c3c9787488eb446632d2988fcd65994a85c19656ad3d57c14a9dc3468bd4ec94585580f81bdd93fea35be8f688cc83beb41ff2af61324d6cd8a2a41a1f00e9d9b0a3a9ffaecdc9e4122cac7a67d91090507e16e7090ea687ed98646961ddf88b11f07532e77d7e8cde09f7932075b5da9dab429e1d2bb33e06c1ebb8d0ea859ce022c5e9c1c9f2974b33054f1c5e6e17e6decdf09f6670a3422603caeaa37ddad15b81d44955b3672ce982a89a31e35873d8bf9494605be518d3188cf69d35793bcb28bbcecceab63aaa40e44701cc48c3963889a0b64cfd96da7dafd6e951267afb87ed93dfbb094ee5345f39646415db0f714bce4b77295606ec6862d2d19fa191294e2b75bc69a540fdfcd5b5fe371ec1b28db2d0ac3533509b1c1e7ff8491049be02535e4d352fbf4c250ac9662e6f1359503bf219bb7191ce1ce229beb03cb1f34ca24943e68a537ceff198b55d449dc0f69f3a1aac620febbcbe443e758a67545c154063b547a69621ca41653951819c0e778b2a5ee6e654648121f3a066d0a1509dd3b36f569d302acf219ab54af102d886e043771d0709ae12453fd6245b2eb5adff5a103a7e2840db3e132d89e0e0c3e22836e06fa6ac11b79390796498d59a5d4d67a1029898bb816519b1f9f2360ec1a8c7ca8a7ca9368332c5aae7820ab9f5f32f4306410d29c21e79886c539acc007d4e13dc82e9abc02f00e6fc547531e977fb5d3e5c0694a4fc0de281342e1c6a90c0b48ff675d2df4c83cc77d1865c8fc71d380e47cc0e64ab76f528c843e08ce391627e17cf285f025026fbfba087cab2a4ad80b5bb79e85709fcbd6836420efd2b43b14046c97ac5fed84a35927080d0214378c37033535a901594e75cba4be1a5a436215b71042707ebbf8d5ecbfabe8a3fcdf7ea72548b627dc4835028bdd854bfef02edfb1ece145f21ff306e28da331c64865b69adfc08956b0bae7597ea8adcd944c525bc8c049cbfb5114a7c1dd31470f384a7eebdd47e192fb24b0dbbf2b28396d22145efcaa1e8e237604234850305f1fde5ca24a16c23cb75b49503a8155987eae726dace81d28bd67df67c83de04bd23a8be926e8bd3d61fa3005960629b6e858c7c2d01206785260df932a43042c5f9fd6a003053aa5c7a4198c3948a55cb91f0a689b6c13b2896354729b106c45f758b2121d89f34c80d7bb668aa4b1b9e25b1e9b7d4d4fc979bf1120d870c3ccea412d4869c8f52f3c45f17e6d75a277164ae0c8363041c4179c214d79902b68951db2b7263e0e3ec7949db89351bde286de7ba930e034a6b9a8e45129846c2b94acae04c5b28dee98c0e438767f8ab37ce302f18065a82d0e0df893ac9bf6f811ae2f0c5c07bb613fee4e74f79338f71b43db4eb1d5dd27e7abeb73bfb8556004f3762dbe837936cc41eabaf22aaecd5267e3acc59d0e176030d11deba7b97fcd46a2685bd2db47eb4431e60b04ae848dba4011dbb688bb1fc5675f5aeac837436b852e7eed7fac763d42bb083fcf1e00038c5d0041da5c0961955ef162830c0ac121b4744fb9966ef0834e7a563273f9f2e926b44c5629752b63d878e6a8bec65d65bfe7cdd2531cbc2344205d816a782dd3d364501c33e84b79cdcf72102faae03f02c543bc18e11f6bf8beaccfcf182d03a5a3739d950e5f715c6d7d32dfc965d178acf1c8255711322c0f6457f4cf017e76dc5533c7069163e836b51feda255ef114447bc9bf0835f86b0d65cc097e0f75b6f80daf78ceeb800bc4072d5823621e1a5e262a9dc7e112032b5b73d4176cc5f017d436866b49222d901e8d03ae23a2949ee482ed8cf9eb9591d934bef367e45c32572ec5b7b07d9c0f10a8eb1ad8978ca172419b9dc7b74a569bf443fcf5fd81555678d1ecbb69a2fdbafafe7eb2a4959497b22e6bfd2855ef27a35b541167e60e9961d2fd774b07ebcf272c1f42a1a7d3da258e76c8e515d77d5278de0f3e6bb235ef131fc114f2926b0e89954a74ca5d2e0f5178cf7c46baa7ecdc4777c1da9a6f8736ceaf5ba7f2af1bf226995a838587f5e747d1d9a0649dbda39c48de8df8d7af93eb57aa1b60994912b05aeee0bad388eba4658e4edd0e5bcf85d09397614aefd5941226f880a8bf4f441951bb317b072055d05a866a115ae1fe1061a18560b2bfb40f592f9943a45099d1c6f6c8cfc746ecd3d300586859d67450c915f934344c6827fc4b0b151e44b73e7e5755d596c0f5c4c9cbab37dae2967522d5940d69f2093fef594a799d8378cb3b5cdcbe4e910aae44ff09d9704ab014187856b2c887259f389fc7c254f55d9fc6fd04578824030e4ec2ea2d67d8493ce2cfa5a6c440369fe2d6747dcd517db280174e75e9e33dd331fd727c7fbb70bedb672cda9a05b2b1b9436711cc0d1d818c4a3b705b9f10d805c091a3d10d07951d0d042f2685e5433ac517bee39fef76c67f5c2fa2800a6fb460d5198f166e7a91613ef89c01820ab40dfc55375cd05beb8c5bb70512008100858819b8466dde1169120ca36d0c63ba03e3d11ce25ed8fc3dcdd121244b5d42d5d62a31b499a67f1463371685e4d849d7cbc9c034d2d336fc376b8e5f350484afff4080c6c80a1c50e7a99629b1c41e7b5505ac7bca3d3e27e18f6f0827ad31ae5dd9db4ddf069ea40759c47f77a68cccb0b070584417c89cc95931ba995e70b678967d34f769b37c3a10b615f72a67d6001af7a8ddda7afacd845cecaa08797399553a9ee1d074e0277eae6fb1f065d83a88e7ef22dbb72d851a4f6552c3ef4ca35c47a9a146bc4d9d41dd03a6c34472a5f75706c670a1f29af7801ba01753257feb99050c01933fd3dfb9240af07a376b465d2e4a1ebbb15b5b30acfa8790b0909afdf7a7870b75a1510686abc455508ecb273e1fd1097b755fb153b5e970b4c8950827e6f2919c3f1d34b7dceeddd602deab10b27f9be26cab51a6fd8f6bbe995709f070ac43ae319907f47dc18f4a300525fa158870581a90e5b21993da412a0b09c7138c96431a10867f14f515a9490983a89e69ccdb465ce1d063f00695abbea4055ab5d8f5783029493ab383b5bf0f9d83370102b4da48c02486da85c185efe6322c3d1cede0cce942a9690a6d78333971b966d7f9fb2e22abdcae141a36c5aa28b7b2dd39904e8fbff3c2d276958a4627a387be8cfce755ae676220dae07031cfc051b95490802deb0ee6f8a8af53a913abed1875e7ed3831fe208f7f01a41586a6a65cba2fd075897edd2fb3b5a0ae367bdb12f7e7754555bd46f73e07db421a39ffdfcaf702eaa42420dab4be1c3ac21c2fbd85891eef6f49a062c9eaa1c11db419ee54aaec99a2abd47067d011d2ec9a2cafc82d1c4362f629bd4728b21906e170c42230e248e749f1c5bec85806a2f3145fac62515a7de4340763e3fa99d3cae22b66afa5dd3a39f679df88636b0d8c9f387788f96726fc564c4d01952b9079e6e6cd0469dc05532fed8fa20904afa29c4ef62522ece5c394ee7ef692238003bc72b5b1303217cdd775ef7eb3ec33f157047a999c375e0c72c38c39cf1e25a7787851018ea4d4811c8e325a137dbc91b5a84b612df953141df70b7b3961cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
