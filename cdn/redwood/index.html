<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0feffb0206bcefbcb3da1d93985be25e5fec437972153899c4471f0ddc32e8074dbd404cb822f74a95718af005d031427aec43f0125b55c02d1030d8bed51542e4e34204ca33e35acfdbfaaa9d23bdd916fa4d58c0879270c75d5b1dfdc5ff604a0e72ec7b5d00be024f952e07ab802a6d4bb743497db10dcd8c75d0d6be65e8d5633c6a610689788acaeaeb358aeee4904b326ce19bbbce077513cce50ee6bfcf1cf808b77a07d591da4ae7346a3f52ba315aa33593b819f06a619f2ce4437210bb1a7332ba888a077bb1f67bcee2d56ffe517ec8d1b3308a24c85ad1ade32d796c9713bf5078fc06abd5b235b69777af2556fa518f7e13fa3c9503f32b497d31eb813cdc4df19873cfacf9ae2e8e7c097c5d8adae50fa277a3cf81cc1296f221702d0499f4b8b62c72aa86e2f1d7e9fb6d4e68608689a4d4892ed5d0173c9050486797f1e0168f8452aac5ca03fa8aac31646f6af11203284cd8d6e0fa8455093e3317e94d5bcbd6a2e8d07e54033a9eaa43634d3d9e7adbe79f2d9b2ee1ba56e6f11af898901c292dd7dbb79064c78bdd55028754024f8e9fcf32a2ab07444c7fbed9a9f091a7d445e061f1aedd4ec3afc5a1279f078d8cd14c8882fc17a0cf5478703ff53df2b4e34114b88967411af900f2ca10b31fb9334f6d18887ee9bd804b04328cd89c8c36d494957d482af71c413761e4ea1b4769c08d8c5fab6ecc9b4024d26be6a1f7c00573e1a52a3edd9652e8b0dbd1384f9896e84ebe9f0cf9ab23d02bdee935bc756b404054ecb8d80f4f9733d8942515fce8426e4db169e8bd513873586c7c555124dbe036148abda7d14d45caba533e0740ce37a085da46af7b0c6368881b3800f346a8cc9e84db918cfde591754ac28db21e994441615e351aed4038cc14a19eb9716ee1e1666b9059077a5132d58aedeebb37b0eb484378cdf26dd14aad5d71035358ec509d2c3af2c1b840e79d599da6bd2331842608b0230d49d72c415bae269cbaaf441caee3c00cb60b68a2c00fc423312dd68685b8b69bcc4242ddeb7de8cbacbc3a69a766b8f0afee9a80dd1e4d7af5ebaf428bac9b6e81d8a654e54924a00c2adabcf0ff18e1e8615e471dc3420e1229cbfefb6cd65904b40c3371bd9abc60acc111083e9cbd38bdd394da7ea914ed8a7fba33ecb608dd5d1ecb45c20fbdb33065e387e68dee01b6c19982ec71d4413e1c3b8514a8f79064a9fd84b3f867addb82165e30ef1aebc8a27f497f98e426b4cdb5dcd9594ff64deb2643f5d694348c525f1a651ccf4ddb89c04b7c41d510ddf372305f9cf0edca0e0455f28217314aa84c787fb21d598b5bb517c425a94c2b3667b48152851b1782c250898fbb427bd12d90d439f72ea66064e363d18d7e31154965dd9a453d1d029d025601d95007bcac49f8581ea6467a1a93386b6f119d4648d67bc31d0252deb072036a82c42167b986d5f533ee7d3e91eeb11a15faac567b028990740b341e3f418e5e85fa6641ed4b46d884e9b61a862278dd1755ffa38bf7f7048eaa40a5f38bcebdcc6ce53b5929c17230c35594cd4acd4f72d31eb5524d9acd783fe0470744bec90343390a206a6755435e5f7d2da2b5c975331677a72367761ddbcb35cb7b08d52527017f3a90155c319baa3120682572545400a720c217081a3bd174d425f01f996c1872d53deea19aaba50c57ebc6bb09e13d0f6c8f773b8942aff28a682deac1646ea9681d999ce0c12a79baae7c52b6ca2a995e53e6e7bb7925dd414af1f5ba4be41ce3dcdd78e9954b125488b970820625aeadf569374aa1092a5d59dcda4c8763cd7cd23ce4d2f0414bf04a9d4bac9b1956e4755a09264ca910f6cdc6ae9450c5b3095707625ea7ab073452bee1291b33ab335b24c1d8e6ee67372729a9538f960c915af7ea3f97a4ed2c06e6d7068a18c0f6a98874b13d3ae9fb527e817391eff85f5d3f36b5a27e982bd142a2cdab6f37579e729fc4d9d6d784087f4595cd7064da8b78caff6818be15e2a2b7bb7440c711a895437b9c4891110f79f97bba70d49d17d3e970718fbb625d71a46543c4f25af276a2e7eaa317ada8518113c83ed28b3cb2c846482bf2c38377b3e57345b18f568cde4501a3f9e5370e5754ea07fbec1c53995a14bee5e0aa6cdfabc27423e8b3a8157b1e685e87942e4413b4357b673c8ddfff6244bd788cb82dd01e4f4dce2aaf9f759f44c0dd7b4c8d6c8c1af65fb8919655e68c51bf4a9a57a4b070ae02745eebafa7a2a3f7690359d281216ea3c43b0587307ec5fed3f2cf2b955f19b8583d757a6599be7c08433c0e34e5997adfd80489e4022e35ca7962e0903ea02f6c6b035515f8c5ee494d95a651c203698962244ed76005bb4c225ad66cedbe859ae63a4afd9699e04a0fc72fdfd9d947939f4a552a673dfcd7860d5b124360ddb642fcd1feb22f36344ab613c6bb9be3cd0e8acd96da7bd051488cce4c553d855e72f99ba1cf6ff69cabf901cc7ace8cd215261145a14b3f6e8437d5e5e26f7cd63ea80b651d192b45e6a48e4adc388921d5e13b0bfb0b66b091ced2713ee3624de4f0c13c46b658ffacc728156f1b52b45e3300bbb67e4cb33aa0f3b135eb790e2f905f96baa62bbcb3ccf5e2890e4a6d1bb4043cf92ba3ab70b0281eae759ae50a7c3548dc5de8eb05cb681ed8f01cd7c1bcbb8dc0d5523a5a307c2c04ac9fa1faddf43c066c10945c5c60091bba1da10584e85eb03822b40a98f170d5456faefb39ab06f9c93acaf89e0a5a37d81aeec7e9e8f8727f7ef50b50032a7e7cddf2bca7af3c069d42ca0c1f5dc2cf1d2acacb36ef3a7bc08a84dd0e16733772b5985a728c389c895738a82a74668a28a9efe39aec8ed3b69e6b5b02d5ab949f04edd39554b7861abf59cfd8b29e32eeaaf46ba5d2417c28ab19791d74dda2b0bb4d4798264834e26a18d815ab216d41d97272b872729be9f009bdc24b7d0899f76192dead16d9db025cdd68172b61e4207ed5bef42337aef341976652b835173cea56dd92f9fc10fda6e478215ac988c400100c9165ebbb5137d7f45bce959eab2c2d082892445bf466ef3e94316a821bf30b2c72c67e023407e2813c178bb98a4111598a837c427a006ef7155b46492ba389ca333bfed233afc09a4c3b236517321e2be23087e9355450207b42dcc4e18e127d6fd0fc94e086c55a4dacc5dde36095555572bd7e05b4e26decefcdbe5c0132754552cb90a80139cec7cb0c876c06019b3b0c0070ab8bbf84774018589bc947414ab3868600addeddd37a37f2a89fcb5a1dd6c170731082dc7beb062355bc57b745906354cf21d39d305e4013655be5ef9688a8fe234c7bca367939632e1b7d64a395060a366cc145547e545052c612fcb642aacabd42be5d8db17f24df7010167770c26f273963a1ef61a32090c1cd8283122851eba4fd520ab5d983186c192937d7b21f49e47c72bef656c53187238298d0c02176f2153aaebc44f34eff547fc51d6e2ea45edd4717a6fdfec104c1274d8e9b28fdf677909969a47998165781567fd85bd5ff5b5f70fef40940bba71af585923850294d3bb16b77dec42c865a95e0610b0c2bdd0a4b3989c59604a01e999c9af5cf7a3e345891c89ff7bd3dbd7b0f27f09d8489359469c72267487e28a41e679456967d64ca854ac047f056bad6d2c57344dcd3c166a70b62f1f0e0669844d2599c1858ca66644128a7c99591bc184663c23369481518cf1418581dda6ad8939209833ba5c6d978c5d3dad2be9907da2af779dba95d37d65b37aecc997026d486169179604c51783d28e703da526d4f73a38da292f393dbbf0d0e08ba75c50fea21954dc06226bfbf77ddc22278fb12cf9553e94fa5124ffcda0fa0e6410f47d9a187d8fd9ce391d683bfd9b8397b4ef664d58e49f00c6e83750a61d70a9997551b1976a2a8b478b866d228dd22c1e827e3f46e5126a5d41c43454c5e8a44a294dee4285ccf6b29e6714381f5b0db403dfaace9a64c31b669807c00b711320cdb705394085ca7f29780dc798de399c5b54e0c4b81ecc4c5ca408e252016336dd7f08edb55231851e1efc30cfc9ea0ced31212018c447d2878ab619749860b2b25dc6859aee59f453ab97817716d245cf3dae3690ac46abb588f67b623d67b3f082926a5df91c12fed6f63f9c930b58a5d3da36fcf27eb0bb5a13579a42339cfb97f3c634719f8ad81e00949ff0c5865cf810fc1c7f6008af85accf75e2a240709875cf326b890605fc0b18395575396f3ddc5ebf91e3b8e714bca202b86b2bdcf7ee61be5d51dc6aa8e710667a07bb623d0ff6815a1b2c86c04279611b58a044e628faf2490379f9367e2e910260e003a6a2bc512f7da7bed306a47dc144640da6de9a5641fbdb2e8e85441ac168ba10b76db52acbca6e8278119a208b829e65d46fe3fd5e2b8041db5c7a6e5f29160ec6e4b9a2eac27169514dd942462760a6033d6b63e564b4396a44ed6fbfa716366ffa408aaae88aa2eda2951c7ecfbf7e8e4dad9ca4a08044bf2017a04928e5c93b9442db631da12cda1af4fa135ef6a233b4bc6fe6519b62cbab6f65a85be5b5f7d31afb1eaf4d09c0152570733239fa98b3b58fe0f398151be7b37980d5aa94e277ec5316ee02809dfb79adf689f71d1c25e5f270171522e8ff9dadf6fbe284da54a12c3b00b95da653e856c71fa8e2d9a71f58ebec1a5f90ef51bfb6c58b6aeab0278899d09a899ac48aa56447c2ad78f747dde9ad293daa279135b810cd44ca703566700d110ff6a990a60f25e327dd92180d11bbabc37f41847c5fdd755c8c7ddc1d9614e1ede97ddb9c827e761fe189048dd544ae540f65b94b587fb512a11679682d133c9c55b6a0daecef4db8b4adcb89d386bdc07d904a19a7b224521ef7b3d74708d508229cd4638bc33e7399b8d551f9f63a54844081cc38660db1c5a23927fabaabdd3741976c8ba28a99eccb5f3c21fd22003177f88eb7d4c686d32b3339e09ed72ff2d9cbf2e876639ba2a58e872bc237adc8775bcbee5c6040a2a01be6977404668b2273df3cece7f3e07c98543b50ccd54904274e74b08141d5a5f865f1e7c0c11bfc22e66b7eb854e527011e5242536ac653e5c426c67fe1536f4d68540b09df7b431e7b8f2d3082f35dc2b84f727c673c0814c943c3c3061fae74a39689ea12f4e42d00fbf1eaf9e52f68f95194d8c04df121f64c5f3616feb5fb39165b3f127072c6dad768c0b2718c4826a9b5d8c79b80299aa8251063816936783270858dd0b85b3795d77ed608d37be0205924d7a9448052de5f015cce03c581723aaea3f2e2e738f4791a35388fbd8cfa26bd1abe3f6abd19a9766bfe535336296b234ac3fb6ff96e703b79cbf1879633c0b72ee86c3c5eaa90e6b38c9a96da4e5867a5e90fad0cb39229639eb73e1dc4669b26187a546c46397fc3cedc299873970c203880cc8cde58c8f34bd6833f005a8eb9b47bd9cf0790772144b2f70b9249b9c8f801ad8591713f739b8ababff56a6d1494d2a7d8a232b9882cef8826a10b6bc69fa66b36184b8688149e5d144141e551d7517a2ea42ca1e2c39fcbbeb375c10bebbecf0f60a2d17cab84ce5b0ab54ac6563218e9ac42cd51d12e493cb86b570e60aa528fb9bf9b3489de0cd7a15db8ecaab28c64f597593a60f2b4fb1e1b13ffbcfb09a849a008529caab123363df45152d172ab29c96e78d935c5d7d58bc9ba3c88b9f05e2d8a1c10da59b7581ef1b0464c1b0ffd8c68a0de0b8c46a1fd6f2aa3626b9f8d4c8e38663b26e16b8de6c895ace3acf44298251f3d75acc845bebe2f611d07d86226b740c1e12c77762b7c3ce58d5b2be553e52450b15e5f07e598054069020e624588607e5fa1f75f54a545293f572824ae84ef3f5dc8cd77413ab7f2b2f2242b16b608005b629ed5e1c30cf236e6d1b0ce41787bb20b86ab85f099013f3042eba9982fe1d77300491b0164dc92a4e03e6adb60030fb2c1ba3c1605ad0be64fbc82a1416520d73282856d46cb0c5ceb562e5ee43105d4edf360d94b6d2f378d4e364fad1f2551e6550d2fb71f678892a272556e5efa4bf961e63cc7d102bc7e9698ce8e19e0de5c7edb86b2a1bd1a399d51501c099b4f27fad3b564ba0a23eb5465fd81ec76586732aac2f8c76cc816e7c95611b8e38b0ceea9569f92947aca6f7c00e79cfce310f082ede406372bb5d0af9e6a181fb344d38fc6f9fd4f6098bc78c6a63640c14fb3197d8c847f1b23d1effddae16878e9548ca3a70c1208171584eeb1a0c5be0de0cc6183b9dda27baebbb295107d22bc99d12edf0400e650e40121c03275045aef75e750249a2c2a4febd4612043bf8e85bbaa206fba51ad59baeb6e87889ae0c6e9f829228b531f624186ea31d9ac1a3c08cbf06dbfe81d754040fe8529d5fc562e13238ef8ee216130740177d2c877c501d56d054ffb6eb48c4b244fd4477fb507c43e386c0186cfab2c2f9d4228d649f5dda59bb1d255d96d8d0e90749d5bb1cc19619d5b08e5c322650e89cd932993f4e52088d2aedf1e2aa0be550c030c00d36ec263761883a2f34ed38697ceacb2ea38557d64a96375a6bbe02c9ec4237c6af0b9a58b08df57ba2697a3140ed8e3759e3a79e34c92cbdb664245fb3fd100fabcddea4452ebe9767de12a203034cd6f6da286f4f39c22c0e72bfca12b241b053e1ce7cd01940e618fd7b54ef9b050a148388eecac0f4bac17ff0b1d3f8523dcb09d623141d24e833ee159f68e1bd06f4d578a7b8f5a1417764b39b98b36a3caa45376129c3430fe11e93999ceab82b60bf5ab60cdd5ce5ad44c54e38f2f5a00718335ff72bcd7cc83f1b716f4daa070de4ec74e536ca17948175feed5fd0ef5ea6bdfbd5271a4b2b4fbf03f9a0e77266c4a6e1ca9bb42f1e7eb78064148365f2dde8e0e05c312ad3fdb131f9e4a59faa177f2d1b1e86a3fb3575cbbafb8c1d5bf6822a956cf1568f8b49e594e7fe4d6f45d270cee46da92f3025f42bb8a0dc3d9d52784b7383b028f3b87877b85469b3985d3a4c68086bc3d9a617b595fe09e1f5cbaaf3f988d2366b310cfa4acc8bc9bd0319bbc8c8602035c8a2da17237f380a5273481bd0415189684abe582e941292b6080f933c1d9a723f754eb05273c49d07bad0ad50f71f74381b78bb71640a52304bdba5febbe4ef6c3cf464706ccbba5a4f1d09b93ccf64a6ffe00df280af07d14ea1950c2e5cc015f2bdd0ae34131c91e27584d44853255b603efaace0fa804c9e4ba0e67d2ba5ebb6252f752756627efa9261189e95d760ecd422474307b653b2871cfe97dc2e5777ca18d6438b50b28c9eaa46e89427cf0c81b169ff14340ff352d42705cb8a4d144ea3a24d27150b9bfabd6bbb5061ac2d50375f1444dab40590cc309149044a1bada1ec2beb8dfb98a5db0216973ae60fe94016bb2bd46c73cf0b6377422c751425d60eb08aed4622c14fc9bd2293049c5f9ae6f63ef39455c055be598e1fec9c4b9a00573ca8e92a92578793727ece47e25f3a6c08521b2ddfbce272e1276f4d73db28a8f34e1abede3e6653df7a4ca84336c6da6574a8e9c291f99b53b27d591a588b709cfae71e1b8636c7b52dafb2806259a8fe2b9e0e24c8c1c9c4d3d6b450512dad8ed08c1523715acff3eccdb09b3de705b3fd66eaaddfbe9fce2e3039827b5a33a5c6ad8d278df4034bfd57abcdfbd1ceb12bacc7994ec153880eb70fdfe969bec3149a312c468096dc8926ecb200ccd79f32e234d34e0d9fc67ffd35f39fccbc6bd0399ad9c157e7b05e43cc7e9f09a78a23d79e593598aff7c03c4776eaebe945b974fda30e581613fdca2b57aad6912a0d20cac454f836ed20784830cfe00965f3fe3be4fbeff8a20634a4d631cdabc8a49fd6c14e19d36177b547e536cd3b2939f46ff2b1e78526054528cc15deb21fb4d65e0be6d38e82fd3327943e373f86c6615f5c0ee4dc73644675f0bf3b3c435aa1b64c2391ca5dc1df41e802c895fa5c665d67770e134cb89b7d839c5c04d59c49c4047c5599f99a8d06757afd1f0c3f85d1848a8a3d06b13243ec9b79cde7d699cfb9e4c3050d5fe56c76869db1d2f76fb12de07955757a3a406b238a32c8b93f233b60800ad14eeb4bea06a7c802a680c4794054d0747d2ab935bad2de43084db2a486488d27f10715e2bfa0fe9285500dd9ecab7437e32cca93642bcf7de70c78c09a9d5a8dd8e2236a7385727b25a8ba2dfac4223320d5670d9a045abb7cb36ac68a8fe99e28fb0216bcf4b71e090c87812db8b2b2f26fd8bf99484dee394aa2bde0350010e2e9d65ed2355905ac4ea5cc722a010a6a2c07ad29effb328b66cf43103a08d5553b25a9e19b7e0ed1d41142dcd4b4c33b6368efc0870f3afb3b6b8a50054d02a0955d8c2e83b753654173355be014269969a1cf7bbaa41a56a85e25a3df7457069fc0eaa1554c183ae548903c21c1246bd41b0a4668052246141587621f30622de44fe5b2ea956faaec02e66225f99bb5e427218a7edf4ec8afaa371670eae22fa987c9d37d38a2f0d9d79a8232fbd05152bf7761d789646d4a2a8663d0d4ac0ca031ff7129e495fbe441f3689b3898b7ffd341c49b5e9b106d2e5130aa8b5fbc11c590623755d6f7e07ae30440b75f2bc471086f7042aeae11f417ce26186c2b4cf7cc920e8ecc6c4415660b344bae2fb7c380f6c19687fc97b7f4a1bec2e44872b2e34c45932663c92b1350d04996570dbe5f1b87fc109d3ba490bc0c94bf1f399ff5eaec502c5793d62f13d4c3e16ea35fe8a3c90bf77842e62df69f842ec4a13cf13f63fa0d9c2cda6c34ee7ef6cca8caf1fbc56a1f96e74d4ec3d72ed94136c1a6ffc5951694d2a86daab708b7214992513a929ca04aa52bc2e37b08f6ee264cf2502830d6ab81243e416d4e913c53468c3b5faf63dfda5c18f9b8671240ef505c2da9abe9c24e3ebeb14260b684a7971cfc998912b232d9732ad6b6ab76a3631c21be49065b493df55c79e57a10368a26df2efbae2ad56a81d90aa9fba1e38b64f3c2ec121f6dbd8aae9c8c089062f60fbd381b7fc485d60323d15287666033f4369e10a9135dbdfdf4eab7996d34cf12ca7405e0b6b23657e7c636c852cecc2ba7a59d6f80ed8b5f4376da55dc6b6cae2f6579c00c49bd08ecc684e40bd91cbd2580724da3bdae9efe32d07d24bbbb55b6c959f1ff9ed24de24722cacde3d9d94a0243c4567bb47ab57c14c9e7b401243938bc7385faecbbf2b10a0e3b4f02a2663cbc7fcd9308e518479a82a48f84ced178a632086e160eae6a3cb706a3e49c28f19cc0033b7dc61c325933cc6b9dcb57465a8c99609964efcb6e48810a1232e23eab93231696ae8e7350a8321a257c36e203c762bbe750fc21e5ee0a3319a379d7296a74ab3e40bc2b8fbe21ab3b65922eb242c9a5af8e34b76bd61ea9dad65c63dfb8a026385ed1681c962382f9487bbbcbb04a584f337c1830a4435a8c4f78a977f57fff1080f9ae077a70339535e645b5fa7f9fdd959edb8f114a1747c15e6c948e624c3201cf184ab487ea3c2ecb4f146c6079e6e8f286446d5985022becc0b49c82c1ecf168c2c021d577e0791aff668bd91efe1d0d93f97393eff00672f417ccb0fa66afc52236f007b8a3a7277402a29ea86d8d770d737039fcf13a04a0af96636e46b9b40567f3cf9d642764f99164d29d26b9cd90a23b25cabc58d14ec3157076d277c21fd56bc31b91f4bce7dd7af1fb1fbe49ede91b6671ae52c6eb366b45a6c3d458b4dcbff8fb0b366bbb6890f5f12758c43ce932397bc4619c2a142ce739d7e43f5dccd84923fcfcdaf8d9ede03ffa9136c9ec2dda1db54318a06487ef3f78e3af309878c8bb39dc8fe4f71eb390cf1daab747e264afcf6bf242708d1e81af95a74a145829b04e30c0a899da8256eba23f55acd3f24ee1cc5cdf22e5dfb8d5c406b95c7cd8459012d1f328eddeba72a25a43815152b1dddd1bf431e6c87fb9e53f828c550281f46a84215a427dc300cfdee589b9a5af6f0140a2ec1745f57a6c5717cf3a5f5ecf57a597ab1dd732fe1780182f97b4812489e30746d03f46bf869fdf2ea3d3d13248bfdfe3ff8226c23de5aa633ae4b043c255a52410d7b84e52fecf8ce3df94602dc344069fb9ded4a1dbe1a85f016d8ecd5d6514646dc71bce03be72397798541b6282b4f414b193c241943d05b21f8d0bf20795c3ceed1a5b02af457c1608003f31839d6ad9518596229c9a2a6ff3f67a945282dcd010e28f586d4ea4b9dd2c31f9c4186af977b0f8e9c981a1167f189bbb7805e3c7ca15a60110048a7c9694607a09122253a4415f78e379a679cb8f17a7bf9bdf67970eede950ad22cfe565b58bdd7da688032c34c018b959f8e90937dd470bacd9b82ec66fa38ec5a3a44f26819fb6766d00a6550b8a5514c7926af94eabd01d285612bf06da1006a271eb70a8f07f5b7270fa25bed52c5a0a3c2f5e1e90369893f65cc85ac3d95d01ae989248b011816299c8b2e384af18ece0d65279765ff126911f9439e2c7e101eb888cbd1b328f6abf4ad3362bb9db9765676d72c16d8b711743b8858383e30c9f46e7ea873c99d4cb3c834cac4cd0781d78cd74195795391095b6b088434b7306a9d9b14479db9561b595bf9f8f32b15d724aac97a386eceb6db33512ba519e83d4d15e0dc43ad2f1e4011512f54a7c1568065b9498997db80c558528161618d76bfc4bc2c349527b0dbd809f4329d78f6fbdc98f0531c619f56fa86697305121fd4673a88bdad6c0a69f5afe21e6f9b80d23c5ec15b5ec7b20d92f1ea46c2960f9a923525f42d9f17aadda9bab6788db6e449fa285716429ff3031597285515f673d539887e18ab5d91e33a03d74a9d16bbb80915b4ea2aa1b33e75118e4d8b886e2d3961de2a6ce20524e99b71de2e3508c67a33655264be112c92b88520463e98db02e2c4bec87246d844c60968579453b72bac2ee485bbe09896286d4738d79dafbd1b545aa4f6492d32a8fba4d00805991cd08a00236b8e7606a4798861a033044bd2b3639a28d4d17f6704b95d5234bda4e07ec133ec53050669b5bac3f6664e8f371bc9acd9d3838264530e62ca07e4b4c1b103c39102f55024e35a39d5a21de32867aa2fbe820afeeda54a0a0ef6779a3db9a2a6fb09b746c74df7782307486a6dc884954ce2f46143f73d371429f7560ec1502da42afe1d7d31a32599becd4fef89737d34c65ea85c837181a7b23d9ed9ddce99561b3d79468aa2a408c49f0d3e1d9987abb5063508328a42746e2979c34540cc1aa841f77059fbc5f4a9155cd59eb01f64c7f1786a5df95c675eadc238021ffc12e783445fb2acb6d6da8d400efe177436dbc14ccb908217c804c77107a1369cb19eec840444161f403e2e33afe722fa260cf59ed76cf683004d0d2dd624f58f16989e35355cbf81742f9a6522ca71d63814d93a749e6fc88ee4369b58c8170d9ffcd73c3267967f9e6f20effff57a2755e492414d30e8c6b025f430fb76ace8fafef271e447be75379766b0e972f7cccb65f36477530d0482375fee89c95e053cf9e4c367dd89930dec5f882515fdc48a885a4a800ced89288d66cffcd3f733e16d4492e4443f1f5dcf510130f0c11638f4e581ecc77f4172dc2e03db994d7e95d66982c6a976c42ae6e12c9b806b8e8547617ce72ff7868aff86f7021eff9cc88907777650801792d7fbd13bccbe9ca407b908d16adb63fe109fe8e1656212e43ebbba8054b5dc1e20a6ed29d8f714a34dcb119ddb7be72c85cfc723d69f784ad30cc7a072f33c6e9bdde83736f36b8273c9d48400a100900c7d06cd5d5e15deb501469ae13e7b5b16908faa2b4a8380df2769c73e6c1b0ba17a739f0d2bac109b077633e8164a606eb5f09a97ba34529892ca36cb5b5c945fa613266cf38ef5507f484d25f6e5b46d16c2dec9d92b72d45539f3b956650dbcff3677a24cad0cae2812a4f6961a5772bd193cdf8ef8d7fb445d9381039f3b5ccd7f85048e0101fbcd415fd49a6a2f975bbeee71408fe3fe51fab0c0b6cb372a1ced837bbde2324d7357d04c6e721cc1f7dbbd1dbf552e895950bf9b4ad7a162b0dd6ad82c390492147a97b4b1a1e09054c93b366bcde51044d255f13c19758476d90787ed663bd0f53c04fbbb7376ce2d4919ce5686c6b603d62fbce09ed9c3c65e397041766efe33b913f28eca959f839a8de9175b7dc2af7b8acbca0bc6178067212478f76e6278d268a7a88137994234ab0db6bea6a427378520426e73f31dc10110e51e9e68bfb5ae216464c8cbdb32aafca269ece5ac0e199fed81526865fec0e52febba1ac0b9117830b9bdd61717a4bc84857263dfc98478a566b408ea8a35cd57d2a354f16ea25f8d540164813d49533f1c7c28348e1d0083b17c7ab8a25538c274f5b52e97b4b2df442c12f15a4373b8eb5851396fb0a19d368db0cb97c3048df5ab8b11b3fdc3cb61e07a1d373f7972a150f4a789530717f935f1e54284342d6d4ba74d9a1d0af3a5b90f5915cd830d9ae1aa64d7e678e41e40717b4567140863ee3c291edd7bef86f972ca89582fd4e6bbee796c3c69181e77b3a660f6fba929279946201b3b456182cd79681d906d42d29da16807f728ab68f18a876d6f413044370d8414f429e2f453f511d340e59ffc79d0391755273e9bdfede2702cb09c176f4fc34abaf7d6ec3bc5169b69b552897daf1ea4aa808b0596e8fe97e582097464e3f60b1d0e02a17482dc93068e2e46d91e0646134bcb33e7a3a23138eea1ffbc04bad6bb937d52a920c59b40ffd2ae200344e7a761e5bbe32c0b5089ad175592bd6f2248d49461fd0ac7ba8f7ca0729be778add29434fe04ba352775ed8d8c9b7b25d0e5f50ed4c2e7426454c97fcbb0b3374f75a1821e10a9768a75150303dde25a7dd83acc6871a86d64c165c120a0c77e977cabeeafc75620b4cdc2cf419bc9dc26df526603e328a12cb0aab9f26293cc11262a70db4dcbdf9d22a346f7877b093e5d665193d8e6d0c94c0d9456bbf7ae6ecc49bfbee8b9533d0d9beb2e95ec11a4e6cac5ae3dd11d87da47aad2c6ae12e241b509ffbcabe6e2f17ff73a20e08cf8868e240ce332a8812c5e4550410d7aed6fc4cebf59cbcd2da77a5ba488c54bb33c281a6e5ff94c7ff7ac1f39dcd3723951a443dc5bc0d8fac890834a62bc6f5d972466b53c79c21a2457e9a395be943c693064c30de4dbc2c4e5ca20e9ac4092a4d0d0773e5cdae193757a805da1de49b9cb657497e4e0300fe68bc98facd378cb8c301b2358a6e3dbad2620b77f0d8487691e69b30c6e28cfc89a3ee074d82ac8dfe3d97bcb70ca207031e70f569a3c5cdaa3f0c57e7ae72c22352c7377da60c50e255c13c20d38ed1a26136356cd7c8b58d11ca002e27ef6de6efa52faa87878f061b02f567847f770a53b9cca11c0798871a0954bd602677da273281140d502b37d753eb19f5e0934bff3cf0c1a44ad2959b970c92cc5ca8ed932af2e7b082ebbdcf25db86f4984e7b5b4712bd1ba8aa1cf9a8318433ac7c45a8c82fcd85bd51b4ad33c2e063e2508d5b07bd0dd95b05f1d2d6e64c704e33ecdf12486533e4332f4c859d777340e7817de0a6798892f5a20b25020b41857ed75639993c03c10681495073a5a49ae16a5f636145de7636a6afbc90e0885328ddcde4d7aa9277891c5fbebea7997ec65dc444778e008057791b9c7873e10ffc8f297fb7d1568524fac3ad313550de85d5b3e05d0f8df315aad5b55b9393dbcfa1d76f5ee7ff25a80ab617da09523c67e34e9a8768dc827e0807a25c8dc5d11922545e0824cb50fa049322f23559c18f808b4ffc220f53d01fba0600209f99ee462fc8e25f9b9242c847fbc0fbbe4e76d004383dacac70bede877a535a5fd63ae4ae90c255e1bc716b5a3da849908a30e6ea03afba0571803fb29bf517a3b567850e7cfbbffa0beea125d614a385ee8d3d4df70d765d00743ba7b7690819a46a4816914ee3ed47c2d76f9e6517306d0efdb673b51eca6a67b9ecd46f4e127705a3074e09e63f53932f82c33c99f64b986de3021fa6ebf206bae094c937740dd0a810e447a09b760744d8d8ecd76a347256432a648e8cf02b6aea95e2b3bbacb033fe844eae6bd5515ca1f327f814bf990405bd89619996381a797f4c7418d9758c3a6e303656c475767b0f1a5a6355ccc33a81eb32e4d3b764b4c75807b96113d919446533fb5d762e27bba29b680b80e33639f633d48d9b3902c4c21180e0c094c2072bd2cd37d5e35c996aa867eaf27828241f0b5eef968b029dc80c7763ca167f0c3e99d3fbd8fe16ece7ea99c8d7e15a9d106878221f4d774aabbd2a042380090f9330391069b031861c0d90f0c7df080b03e1a83839b792767d78b5b8f46e22474b99626c74eb5644ef5a8e71701cd6f99ecd390eca254d350e0c1ec9603ad27fdf0212615956d726a7063d712f7d9998f71e1a3cade55463d1b757ae8723b2636d81cbd6a2bace2690e3cb7e22953d0fa70faea1b5a38388fd13870290aa7d0f4a4570e3cc4ffbca872df06473d1fd597362c35caba6ee2e060c04c5a395c5f40343a28fdcc44db4a345d274852a2c77c4bf2ed0dfb400998468a43ceb4a179cffc71d5f28d9effe6f2af84cedb344ad0afceb8855a559c89cd85737b21af1720a0ce9bd509b1449aa510fea9ab004658e7625ba83c48342a352a870d3a1c41d390023e28e31186b08179daf3557585af520f0bb40f519ec7364945f50c25202863674a4e9d752edcb2f55a92060d7aa61768df615c99e4a62747deb12459fa41ca15d4ae06d1d7ac1a8a8c2ba5625542f1bf0fcb97c4aaf0de8a4d111f5839d522184ec577e142e4c20132b06e4040114f870c6adb2e4c73b8bc5c5c90c03e89c3b0af0aac609adac3106fd59b76a623c062fb03265a148e5e7e66216f6b60179f52febfa667a6fe484a26f0c87669409abe5189a67e19b1b0dbbf344ce118b5828912f9c9053aad53fb96522ce3d630f7486d4ab4dd516d08a3cde24d7b5172d958c08f23d63f568801c27868c237ff7c8a55f95063213fd084a9f9103ab1664ee70c6abf67a201a786456215534b325c89f09ccf2eface26c05d5a10bbe332469ac337b1a7ca39b6ea1fbc495675978cb317f7636cd5ad8265a820f908dd1a7035a20d475204f23ad944d336c57c77df6c914b9ce40133c5dab90a6e903043be2ee853667780f7ca9a233374cebdd0eea0e675e1905c514ae72289767144b1cade70b56341bb8f27757804d45f6f1fd03f1bac115b8e6f3ce09373813e73922482078bca21fc2f8cf5f1ff099a8334ffab768f6d0ea10f19f0eaded34ee6c0d32753b4d9ac486f59638a1d29e11d8a62ae52525adcb446505398f9235ed8ba54c562770fabe223db0ebfe6a436d817a1cd74b7d727c5e82cd4dbc7ec820f71aa7fac39f7c83da6d56a47cc13471f7e8e40df57ac697854ad7ce9347f4ca948d0f4ca941f0d2db8b5a9c2e6a4b327cf3b2aba8ae49531c896c14e03b8b5ee86f97752f0bab13a33d819e0522b3eb1094b1e7437c15dbbcf9f9e76bf1f91a7e34806e62aa19223a8873c7d36b5d57a4bf84b58f7f1eb3074787e039285ba87cc912c0ffb9ddb8e2ec66b6da2cc7c1bd3a8d61906c979912f28c0ee76b16299931152db57e9196180ad3ba6a458083d5bc95b5d09b2bdab3f059b589a3c56f27a3316949aec33efc1848083b7ef892ca038b952aeed153bc03dace62c201c73b099fcd9df9fd4c03ea81d42c695ea0bd1d5c9a0c8c61a6eeca7a72a418449b2a64e114bbb678d2d95cfd78e879cb6fdda064530468835a472ae9972170757f750faa32797c07dc96acfed076181f52fd3c1442a12b78c95b7de83683cef3ed59e02e246d43049ccf2cc8ac6b87e79391ae36aa7944ddf33540cf001e860db5417898bbb608eea563b33b609d7385d5722f3e4c9617a1adbd40172ae785a7eed0065a5e645fbd9cd1c2a8996ee31bd103cade4982f0240806d313226f30db1cb14d0e2912ec34462f878859cf6ea792f6cfcb609ced879655ec5866f4628197bd69516225525a04d4c198537e4debfabed2a9acd32c772c975b9554d73a545ef68b7a9648a27271d615547a7beda1ab3462ef223f0878bb900c12b74c321612ec608bb67ac60683da0c5736553ec7f8ff801a4bebcbd618a6760fddd91c9ed4a35819d1151087c7c2238cbdbc3c51333326bf5e4f6ea5b7591863377c5f314fc1c2a70848e012f6a01a1624b43f3b018cef2b63ba7ab1959a95400569c765e79d079cf57feaef5695290a826ad3ab8d59a66664f75eaa53c874a9ab773af4c72074a2d243644b9bdd9f34e84b44b2cbcecab7272f7dc7df07459d1e60fd5ecf110c3ffdfefa9a47221ed02b4c08dbf1e727457c9784c83644d928875b6c4674af1a15b8a5f706aa6f90cefc8bf863be9e8664e52fe623e4cb9ade4a477a0c45655a9ee10bf450f68f4e09cbdfbb73e42a01cb87016e9c604c85b5683ae6c70acbb41e246f3c25427457a78dbb8d368c6203d675e7dba5f92945f62a7024cb955fcc4ebf7c51258d8d685985527cd8b120102fad63bf1ddfde7bb0efc1d72407e90bf82c6e4cd3e300615cd85129fa7d34ee03b20cb40e75dfa893d1880102c688f8a3032212d091c52381777e53ed9d0cc6953e0377d0b0f800a48dd517f3d834227f29d4ce4f0ccd5c7c94b7e7d4b06ab384d20267833d9071b581583e4b12719cd4cb7f9bf448840218d97d2bf39715b0597be3d7bc014abfdd7ee73e05033ec899d82aba1d39b96d38ac74c666b00bdb571fb7f63ef4636d8b637b9a2fb0ffcb3355040807b3c75db51f4285d04f77ce35ee86bc041fa6da168061fee30d96ffe038aada5ec51f7ce616150d01fff72c69e6d63bf6f127ce593048f56e3adf6fa47941d8c6acfc7eae1138ad8a5e21a2589d6be2516d7c3f4a153a2b6d86405542eed95b5b95560c00d282798fb581126f1cf1419699b87894886e5aee22df567a672c9b82da818dbd5afb3c909a458a84bfa2deb5af30b111ad1e23b3a0774740350bd998a7beb28d533fe40526a22c2c56f8cdbb29720c5b4901aa34acbbe58caa55d6fae737d10d62897679d71d74b0a5a342b4ec731b5e8a3a3fd1ccce65dcfb066e3e87e5180d1a4bfedb9bbc8532fc7924e116e2079751bcdea458ceef7916fdcdedcd1403b882cfef8ee67817a3a7b4cae90fa905a04ab7ff5768cab61fed5422360e92f39c57251dea3ae57e060598c7e2f7c188a751100369de291f657f8b3f1db7ef1ad2665c420248f0f7ad8c7d601bb4524d6fea82412dbe014cf2fb7ad51bd75d1993eadab98b5b9846658f0ce363ba2db9224f513bcc571d632b88c2167bb5469148381ddd81cbf97d9cbf8733bc8484d8de3868077ea80aa40a96d7dc6544b57220716dd2337dcee12385b168eacb74d5ab427fa150771c875c76202b4c2d406f101840b7c55c74b333cdafd29e81c8430cfec958161af43a6598caf5ebbbfa09b95ed39187f7a81587a2ed3ae6f5fcde823ae4d680447ee2f9f876ce2e2d2af99dad154b20456ae42a950a2ae9a346db4e6bc92329e80a2b1fd5de54e6e14cd42fb574e3c272bec51d521216012d4d0367d8422f9a1634d35d0b9fe15902630f3c908d54986f57312d940c2e4cd2cdbaf562096af1bf101f532cab8eecbebb89c6522f461413d1fc3ee3ea9aefb263f4c2cc581bcd9d77d1d67789d646b70a0341b7f98cbcbabe20c288e10609b6e623db80262cc45587f72303fc6697458c27341889c7147a2b8857342ea68342503ef1d5b0f2cd1735dd5c6608d539c34bc9a9cc00c52ee78ea98337e682ff664f2525c24f3f355dc917f3f02cff15527a67783582acddf7063a040216c0a3c44d3c115af24be84858049379c028ee237d4333cd86754da","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
