<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41da04977ce1de8534f62b8a7e5a097f6756129d94472ab7b62e9988aaa6f27b8e546158d47da22363441faafc886bd891b845ab1d8be05846f83a8c52853670f1a1c0bcabcf1acd64e26214598a8d73763e588aaa9f6b6233aaedeb93aba8f7def89fba8a37957aeaea8c2ed24f8a4121940e45e5915a3acaa3f3bfecc91d05673988be093250da39f7d0c843c37fa20d78a615a55be09fb9e0b007504b3f993b60f830b24e2846e4761456cd9e094f325df1e6c57ab92262b34434fbae4c92203039381f6d746254fa2f0e955e80e73462e67f8d881c6594002ad31d84569eea0dd66b7f6eaee5e943d95927725741bb4722ce3f7127c97e0a5beb677285ce37b2d9b40f3f4263534afdf7cc8a1a8ef8437ecc79919e7bf576a35d2f6237db139771dc353e5cccc95ddab4fa655ed20de7137a980747e77168f497355d9b4670cbecae1fa25bc290686f0da92c12e7c0006f793ff700e0c8c31295556520596ce64ed239d7563c312565b615b9c393cdb6de6d981c41ae6faa6a1f17e80a4962ce59a9a66612f37d5e2baa411c67e3aa81dfe7e7253c4c995aef010f69a4947ec5d04c85fcb55aeebfba5bedd2ce080ce0400e42bd71c34c3802d75b87fd5f31f01fd3aaa3983dc38c3d7749f5e7afb2edb84e330c2140bfd4098e6625f080717bdca60e773ab31d41fa1454e1ddaba5355286f23a39ff6a3dae8abf5f5e0f14bb4a94340e7c68b4c900961b7649cc2497dbcfb6a64e933a21cd50bdff9d7188ab3c5f5576897849ced202653e910c7a947c9f0611cea668c9125ffe34d588690176c2324d561fd2e0afbd2dbc24513760120b51bd34e1a054bcda9c6f8c77e8204b5fc7f74608cf76025354f4488bfdd1f08bde8565a3e9271749d6cb812b8712efef5c4680e4d02b67ea5cdfc3cfc1f7e0d7cf2515070b3738f75a893e03544de391982306b7469c38835b7e4af2e544d64a5421a1239273c580c47fdd1f75256363f9533966d324936e886739a030caf5d64170c7e6059297b61f8dc9d05df393ce3e6134a20b66e53e36040cceab053a7d19197776d38d9c314e7c8c43d09d2db2ef6bf19d43b018ec7146c6013b9f04e5031a7c393f6a54904f3003fdbb8be0dc252b1366adf9c3c8525c85cbc3befbab8f2229835f697165872552a70414c101b34d4213028254c0f1b214a5df67b3ec40ccb43bef3a1287c3d45aa4dc9c3c6948136878881b7133af3037b0c9fe738f2fdd114558374785de812e479c1c7e8c51ee545687bb758f367490f57e8739f188b871126998fd2ce92cc40411abd7a4e41803a13266101ddac1f9205a35c7b32e3a689f10025f702fd57fc114ce183a8df7ec55224df6be68375671b89f568be77924aa2df25887360d4bc167706d68bf37cd19bdcf5653b611013f73c2c9a878b6667550c1e639bcd6c10872faa7fc9a3d5b31a1287a82f1891d8411e6fef04af93c8847c0decafe9faac8cc5973520bec611bf40bb9164e86b33da4bcc0afc26f9418084a2d94d24adf0e2bcc83e69d91382b2ec8a5167086c876b95210b6971f65a1986041d7174bb62922fb5f4c116e96b67d11b80c61a25336d4451eb7d4b314be0d133115e1fae13c1aadb8c479d915f4b3d5565804c63666ba4c871d38ba039e482828f4c36d69d53232af8481c8268eb95e18a68c7fe10e445f3f963562cfb4f8997e06c57f7ebfdf74b2778f452bde19dcb7b3314e6464b80f0ac84141bb9334d9b354a5440c54aa3d2f42ff5c3721a6290d88148e755f75abea1a94bbdbd7a45f1ca2937b35e760a1ea0e5b42afedd2a0b6f2211f16d72c591a64f3ddbbdb73d299619f4faca487c688488503b36c5eff31e3f6db0f9b0b8f56a8fb5d88e5223a9ada6e443d58faaf06d63a62330ba690985e106c28c4901f22fa22870cea15c84e9e959dbdfda3a700da4409dba9517581ed2376e852c8bf6d21226cfa6c2904b3ff0370a33afe2e94eeb2ed8df3df2f6fa1f708d1c143fd33c8026aad4955b92400d76281c71088d343225603685bfb468ff6b3f80cd6946bb17327d40d2f86b359a150f96170b55ab5399661395e9edc89d4ca6356703a938418c95ba904303242b80fa4d90f52a182c9312eb19dad338772d263a82aaefeb0539cbacb5e4ce72ba24219ef5bdcf839e42a05488b45f17e3a0b541edfc6f5fb74dbf0fb267e1ba8826808b54a786f1c8eef18586fb48a345ac0d26b5b8b1b3d218a9e69d1402c87f3944f502dd2dc64aa37c8e23b772c63fa1e61ccefb8ac5364193d8b01f9fae78c50bc5f6ff6da25e65755a0ad9d1b2c85a094960f8b98a950252228b240d712ef67f48c7a9bc71941a7988e6eac72ca76bb07089ebd14c020b600cb688bf54a0665eb6418511ad1037059ab5ae712a193c420cbdf074c38db942a235f5f72c89e0aa8e1a0665403ce985cdc2f605b1ec501f62282ec68602fd80d5cad8d9a1c5b4be2b4b48e3fb6494a72a4480998ee1a1b5ea1c22f53219e1e48e7b26ecd3c3a9421bea41bad9c34a67716ace7346a0be281481a04c9dbd862c6843686c6a4bf57a834823e605ac0d6631f9b9cc3dfda686211270802722e03250c6717ca3134938c5925e7697b18946e1ca5a87309d7f4a394605f7512dbcabcb2fb1595994f685c04514c8c855c199d5e1c158378d1085f934cdb7e9922891818f2f4aa1202eac05cabe69bd7118e10e80748fa6852468685ed903bde5537150fbb6cbab967e115d9e40dc420b4e11ddd0c1569456795eccda849f166375e68836adcfc13c99de71090b4c0b1b956b3a87794acc4a71f0fd22c4eb95aa165e7b889bd458502e4c8083d7ede6fe871691f4a022c039853418c90bb0cf341b29ad3fe6b9f15a310782880fc8b8fd0de02366c980019d5ac314a7fc843a27cde6ae2ba5a6cbfac1709332b0d76743b6adac6e134aaeffb620d5b7c9e349af3a0d317c0e5ec1c635249c85d0e5878291684b92979bd77c177da73a700328ad9b757f38aed5b7bfad0e741661220eee84e856016bedb73c34b3cb36a63daa7a4712764c1a0a8c1cb426479c2a885134a4330f905883d826dd16c2ca90b47e2a416fa7741f14db6610d5d355638ee32e21296f3713237e9dfcf169d6c7fb21c81b2366377c304686ee735a442530a65e1837a12c9a797d337e5588e7a8758d8552d62544cec746ea0ac16c8c23773d12180ce958b0540ef8e8bc39b86993652e257e70e54932804c285f743be9256548ddd75af8c308f98d1b15cd5a54dbc52e66f0f0bbc9383bd2bd02f3f358c1a317fb38eb4c97e50d58e4729bb43d9c8101b0a5d815ba081b3db1ff46cf23098b5bb404492c35b61f2892c47ed9619b4d0e4b84e1d036e6d4d8968c00eb0a413713bea37694501ae8674298cbfb52eaf9f8859f1d54cd4bcdb30e4ccd31c07461c4e1dcc2dab5f61d41324fd9db91b2ca93208194a376369b4a1336252b300a025d0923d159bc63f2594f67e5aa0508d6b47484400c3eaa49fd30ec6605625df6e27250ba44421fd90e03ef4aba1c081041ce1f106656bb6fb5953b2fcd4ee9fe04e8ea2577f44a706b1a2e78ca4dee10565ada4d88b38d336915fe475ce1390ef91ace38f993ce4e5b3549d518200f90d3d1733637b72fa424ff47f15301a00ceef470d668a70105bb05050e0971031beb5963387975cbc041724009ca83569208879be3051fdb3b414a04f1d6596509856c90b7df49de3cb6119c0587dff9a4520e177880634d0f3f8b65d44164d5cb048d2db790fc1713ec00e3d233001deebc4f40c5d7b851e168d29974ec953d0ee151beb6dabfc46fc35afd8e526052827c46f285b353df6a959dfe972ad67a5987fe9ed655c0724441029a3e9d6df64a6896c63f84a31bf335fec2cf289697fc7fd04e04931f5c6e2942c673964725eea66987dd6dd36bb3446fe2451aba2ad43db89bd5cc1b85ccfa90762c2a5f87c2c4f94dcf8ad649de9ac69c09039a8613c5e69a288412caefa2adfbfc6caa9830a57fff48de45cc338ee87934eccdf28524ebff7f120da5e8d729b6df1e9bab66495e1e0e80d705091f36cf176cc552eb8869b78a4c4df14e9ff21574b6c35e09915f1d3a62c8983ea0f0a330a34ad3c3c95f56fe5da7335b81c50b27b96c7acd1aa78fa188287246ccf1fdac461894dac437639681db10c1563963b74e82b4a856284f5135bdda99417857dfe246f074c161aa0b95b1cc8735b8f28cdfda1f33ee584d44fa8d503aef6f17af132528760bd5b75480b404cb9c37f40f8c9719ae75e941757e7d7bfbe8dbc844668b5130ea2c217d32701317f663bf1d6f591f02a7ecdd4635118e6ed9d3e9ad4e20a865e937224c35cb6963a08f883e30ab790282e4723cc0861bb3c5e909dfe0eb9eeafd85ae6bd8e34038b0d163e1d0b0bffb0325aeb2f0fb1bdd4fac2943bb01b2c805c88c6feecec049dc443de8a40461914b517941de9a489ed6943699f9562407de48a2eb2b1ba0cc1944f2d7d1f842defaecc6b20d52ce29c7e9330d21dc2c766f2d9f443d751b334c5f84eab59a2427ef1b65b57a981afbfcff139628133d6cafa302753e66e269a430c179ba9aee922ac26947997cddf5601010feb8c14abfe4984aeac88576846a59f7f7965e89a86437d86847cff07ee39ef6e0d7f8f2134f32dd47c90b86496ed2f06048008629851f1409b8a4f25792e5d39e7624f2ecb6e75603e732ecceff57a9d06d0756da79baf15429bc1dce610f3015d7b00bcb8bb24c042075f108cbd9fc3ded9673d89ce687f5ecf5e18ddae9daedf6483fa5320dc2a7a8da18bfadadfa895f9426411f174d12cfda1f71d1a48e4ee1e7d64803abe5ba2018053cc5b5c27635e136f5c96650b60ef7fc72e9fa68091854cb4014adaf7ac28c8310317e037591d4384a839e28cba35239b4069b5f4405f4f722ce50f974254201f2aac070a24319447215d775f9e4f974585f460f2be0a0bc46df889d698060127c272ae5bb4f79c9be28d3086d16795c1a3ab8eb7baa8396da36cf494c0c2dda983f04ff2a961130c06d9b0938ae6072ba41a10df16e1664e729a6517706e6328342d0e4f449d668c72c337d2250886aa0c79e5bcc7816c10bb4bc1b26fa2036a9fafdcc166c69f1461991096971922afa62aa006aab53e1543f2007a41aa1c6e0e27429c9bdaf9949fd83e39043a570b74941e1e0b6c9754fd7802506df9de1d4f8895ce8259523d0577fabe8ac7c47af0fcc69cd47eb105dd8b23ff19857431c367138fb807cf8c64cca4f369f73b4a1c8c073b2f023159882a0b6ebb57c9fa2af466063b8814de6d3f36b166e8d94a105eb741a699ef5131e855948018575974955019bd0c3b8a300f433f124bf658575355ef69f898856def753218d88370b90aace0a00a65116aa126f034c983bcccd07f8d5b0cb29a66a295eafead40b00c8046cc63b2ec24ab79a6ee8d3145ce3a0bfb1594a78bf1b5c4de18942690693e13f5f299696bf52aec3e905ace1091282e7a6daa618a1f3a3d0cef7e1d8d99af4b9ee0416ab45a81e776e56db46895d1711cb4b1654e95d8a7a917cdab8352265f136273623c0f70140f79185e85e337855f2170819c48fbbe601795b14adb0bb8f458fa90e3189da6e2615d5dc59857322494206d6efc6b81d0b9076e4ae73e478762c1657ba3a872f1368cbf0027b191794f84738f98fbc8d6a4c7911624e1763514726a5f954d1e4585cbfc0a0c05519b9de7de3fa02589806e2f1303509dd33716949daf5eac49ac953adf63e60a5bccffc2037adc68b60a1411ff6d81b38607b1f7d0c1fdc6545847ace6cab3a7c45377065e94a9433f00fc5740b4c6d8ea644ba41bbfafa8ad83c49a5a839a594e42dc1bf5dc7e99f58566e83833d8157f3b5339a1c074138b8de10aae9cfa05f7a2f6791ca667de6d35fe24542abafa3d77f3a389fb63dc7b43a047042296c7770094b556e53167baa1b90206930ab6b940df1865bd5e19a1aab8e25235794b1b6e16696f4322448c41c7023c170fb2764f2617f6527efb2fd93d4b552927a876837b0927e688bb52fb60ae5e3d81556489e24774e2935b3684edee032fd5195b4a8c74a940799719c543fbb33ec9ab4f8b75563e3f1a0d4550d5b525e6062426676113a024b69cdb4f1342d2ceb28d8f4cf4a1edcf4d0491dab47eba6eb9d6ca6c21ef1d7a86749de4469ed0ef318a7c5e747d821901e8800200a1cbe014bc452a657ac51f491df3c9c70dd68253f0f8179947bd66cd4cc07746b54224664c5a84ba0bb8c80c8838b6e63827e842da0882cc2fcf96237dacfd32d56037e95d33f6dcd1f4b1d481b0c3dbec73f08c8ee5ef966e4dd96dcb0fe1e5116e8f8f06032847c8a050a4832db50c69ffc7e937b1bf26f7deb38730591e120a220e1ca1dcb0a2facd91c329f1d3bdc9145c99be9d782dc836ccb06159fb802ec0c86b373ef78310fa576776f54810929f31ae082b332c7ae830591a11a922610393e0dbf42bbff11a9cfce4982251e3a6eabeec8865fbd05cc19306a3cbfa747ea6a9f5145cf13ae9643d86bde34cd64f39ea1d856b4587df401248fc2a3cffbe32586d40a2aca4ef517488d8a635a47f732272610ff8cc13a93d972d005c8c6c7a6a2a2febd93a38dc384d4acbb7d84b55889d61267b8c4256b6806f1a5afcb59de28cb0de86acc0ee64c8f88d2e962d03dc86e46fcd3e1a8a43cb17ed9f409c1ff3bbc2d908ee2301d06ef68161a5c56943f61c9dc90ed9d12138886a4dfabe404288ca4f7eb4d3b668e07f0209709ba18c2f19f8ba03ae69f0cec776a8d85a5d7933add054bdcc51fea81884e1248e7589dfbb5aed1f52adf9daa6f4dcd450f35385d89de859830562a9ffb7ef3a4a04d4dc9047a52425a565385913fc5723d0dd4ff9b3c74baeeca7748f8fa3ac9e6d0ee61660c451ddc93213dedc106ce192cfeec751fece26f03b8d52ccbd9da8e397d88c22bac5ccd1cdb6b007af5f889d098949e45c585cefac3f77ddd1851b5f5d8cef9f0603206f75573961c7e994d9a47fa4fd1ea6d3f4d96dd265442b8d11c22fedb0d7a2c5eda1181461dd6ba08b7cad7fd034829a9eaf9a5e426a91d3a83a7b68c5b50c5df0a1669cdd250bd676ce09ea79c2d21d230800525b5aa8a85ffe3a4976931468660fc73ca1df67615c887f3303dbc4dbb48626fca7c08e73698d020cd37ef541a939bdee8a96a8a43b5784270c546a525ce594c3633d6538d265590598ef57ccd2bcc2f18658f966c67feaa85fc06ded307ce1f1baa454bbb8ac4eb42e675d7976bad69463d4e287e7adeedd53e3193be8718a559dd8f4ab0346fcb2906fe32b32d042c1d8332deb5aa6965f9ced84501d5b34543ea7e0a522de1c06a39a5d33c35bda4dc773dce69b178689a7c5d68095d846b43848116b6868d80b17edf8a81f16adca17a37a44bb15e93d9d1aceb6485320dcd14e9a2b12a22449e20c25a8771c89cf3746588277cd76f43324461078ed33dd91afebfd5f2eca946b869e7114df34f12b88ce071a9af62c68d21f8a6c55bfe09a0e324d7e8824737d923df70ce87657a9300657ee54fc7de2e53a51f2dd9ffe4d9444efc9e70561348bca64c78345cc7f2ec38af27ab112bbb8d4bb67cf13adfd24f47db3f7fa01f66274079733e26d36e2260771391481db7787e4a604b6dcdc0e0d2ad30739a1f8c908e7872ceea0367a395436135b9b729e8491a379314613f8f87bca6ed54a706420d46536b0ac7c55704b74c727b92bb8f67e10cb3506789c809e860e71577aa140fa6e7843147ee3e5e63fabba19878932e4b9ab299b6b98060a51848d0cf94ebb65dfe0e9223b1b1b750d0ee8d23ab4efa88d8473db8466175bc01df0041aaf07e0986264a8ff704e445ad465580b31d409704ee586512ae292d30a1f76b3c1043a41699e71fd771e5083f38e8ee0aa803d93a5eede63990b016e9c426f49d85f4b008e0ea949d5cc665283ead76c45450c1add6674bb3d7f5800973cd3ef8b7e48da6ba65926da77512bf6b09db97fc662cee6be77b0530cd6a8cd0fff9622a755b2839f343a614013a0e9a6559bd4473604cf609782230ebb39ae506b81876fde1b4d7ce46ac9d1c97e889c58f2b62745ec1f9fc84a525a1b41390b5548bafd3cd531390d8532a903e50ecb81a7e112191340b9b087f0b8f31cbc50f95362c2a0502f8435ca8f5c731d9c1990f864f3a77a992adf75fc49e4aa7327f8b50629d1cd14295dd7dead0aafb8d6e2637d6ac4d4d3b7f108a2f40680e05d9d5cbd8b7748eb7d6aa6a0f7efd7499a19139a240c4daa02045ce173e2991922cf93f9109897ea9a3e8bac0663bdd7be9a17790024d069ae81a7fe8d45dcd09fe3b05c01226969192e76c012734033ae425bce9f5f20964abdf1e142956f540aa2faf1a2e7239f20cd40ea88f9c5ec67a06d96e0f7465e4239eca0e525f0608851725f9a9edfef9d97b459ff81f72c397f8cd2af3ae8fad746473fc84677c4c4265997b14cb2cdbad5b9e810dccecaa945b3bebb87e5b82094841a01eec00e2f3e48750d84757d1ffa1d7bfd92f23abfe9172b2b91a665cf5d8048ce2ac27ae3867684d60b46cd83c62145e276520877d8cdc7fc95d2b03fcfd0d2d4b290b60c0a3d6148a855c9ca03c7fc03079eb20de5ab60a29b62fec351a6ce0620401c0ff2cdc3041e52bdcbef0aa9672647e15d031c3801d02f5547cb8c8dac9030ce34c4d06cebf5c777166c073b9983abc61cedb5c8048ce403dd54722dc36e3769486245273b46d0a1dd5f8f38f0e0c82c5e7fd93738e5a73927722ab33ba7786e876bc0d8aeb1988f2cc649e89b6c188fa768878af441e99547a1350449f5a7f87bc9d7f90f98b81f4e1b31981e95a8ae627bfeb6d47aea708bd4dd638e28c11784de312860831b5166fe1a500ace4358e532e905b113dbe2921c812b4b4a55bc20630118ff6bc62668efa881aafbe27e12317aadc056583c25492dc9c9b5292a9e7521348236f4e7c782e41d3e8e44bfc4b34967b84c472eed4c9183ca1f27a4c157d445395fd935ae0c39593002857b4745218e09b6f721ce7ddf70f2b4e5d18e08bcdfa4455f9f0b8390ce76fa492abe0e425b190853fff8593136872f352c0d7d558650225b22139a4e21a9a6eaa43a0dfcebc63ee63b0314a71474c8bcef648bbe5da5ce11bfa07b3e0a2ca336b0d51e10a565e6950bff1ba8e2d90aeaa18598bf7c9c31214c21261002f5e53ec17930a1759905c626170df081ccbb323c739a49ec4d3eec9236af82427eddbc98665c64341f93b3384604a3897b0aa4c33bca59ca10b3739f51183ce7df87451d52b301c2a189a90a5f0a964fc95c4505137e8f54d5cbf57d1ecb42ecead7e585af93fae8c7cf78db890dd63d0874b56f12b3ed113c5c53bd5ef963702533469e95dbb19dbc3ac9916acfc3480ac65afedd1f4b4231ee2658b86dc8b8384b9bcb54a8f5880165888d1d61423f7e562ecac3015d8ce1f899e02995b7bd15b35e50e9d8dedc8118c8c277015fd18448f0a73e2fc24afca1ab6ec193253b57ee4bed544e79202f1456183682bfa08933c04f2603bc17280f62d0cf60b4a2a23107abdb9ffee57dd6dcdad991d45e990dd2cc6c0c8a2faf7f44a523d8edc34967b059af658efa130d2ef306b90f932b606a7c1af80b1fad78eead687c98631bd13a1d1d936ad06e6ec2b451aa5b808c01a61a59f6d6061a8fba66bd40a029171bff7e189863510ed9625bbe12a24514da02b68419e76f37902e3f3a72c85c732c52f8da8fd30dad6e295a172b3fa1124db8f4b003c42a51972f2b935ebc65392d273719275d1752f8808aa7fd99169a35e39efcfa0c6ed7559f614c05151bf7faca528af2aa172525a967a5bb1742f3a3a82d383a515688dd8d72da615ddaab15fe417de0b467178e26b6b090efbd3200b5c54db2855b3198a0255f6022e903617c3e877bff68c231bd6996e0b8e064aafec34b54cbb8b7bb6cc1e4d81b3136b8f1c7481ddeef66f1b346a2c5e11859bf681bc3832da41c982b85c683226fd9a6c72a1abbad6b9244a8512167bc02637b554ac79b16c913cfb1f40f3762e126aaf2ec7fc9e200c8aac4ff08c84db74cfd3716b57d2d8575d04b43de3ce626e831e57349aad55612808a4e26183d03d22398f5ee889347c7ccf47cb396951394ca0dc6d57c58adfaedaee404e6d36ea73e8cf0604e4eeac29d638fc4052422dffb3278997a0da1b2e3fe24091e1228b435944432b625b0eaccc9b1e3a06319bbc3b3b62a35f6534b4b4d22b3109c182d71cc14d1c8937cdb681a64713900dd52420d6ff6f87fcb7a4dc142d1de3a58cf6b5b9e2e66236c04b7cb042ac4c65ef3450da3e134951613aa73e92293db79eaf8faf550e9d47ef321093da87d307d5f8c7060eca56bf4dd7127e54d75bebf9ad44a1b453ae9bbc877bc0262ff5ea825516cd2732e3883c04b27fc54b9f93c5ac3575e534b5925775acc18e3b99e2aaa3d5ae94da80dbb9f4c1745c75170543708b75684c39bf68e691706435eb412b715f286db1f6975749eb0b7e4f99cfb81ec6fc93c34aa275ecd7c9afc1a7a8a8af9143d8eb0347e0e3b9b1093e5f8fdf7fb60cc131201534eec72cf492c16d91c9b99f50799dcb2865a25edcf36804d1be664aaafa4f6adb6d77c3e957a4bde7c5efa3032499a2bdc4e9d92f2e951744204d869429ecaee3e9949ba597eba9aa7cdc714665a314980adf44231df9323f8e3e25dd8afb1f2977caee4e77fd9461322c01c5c7145410ac7a1e9b352067d7de31f804b1e08b34bf33b67b5ad86a1cbe8c92290704767607f5e3ad52772bd01771622e5c495b6407a5a7bbc6be1a613d42320c8c41b938e527143f07ddfa1500457d70f8d0771587dbd2f31f7964f7268f0f3fed471a9970491f3b6ce51fb3789f6e3627170563574d43d9f9605524adc4ba5f4d84eec5282ecce5453050464be486228ab05234d81075c151e78e9ca66d6d2e0bb220be4e41e78955a1eca5f4bb407c9fcfe763667ce6a1adda128818b0bc69be3661a0a9a8e6c372ac3fb69e0156cc9b78b11680ad8d0ef7d4a25eafa801840eaa2518ec4d5eb09c1bede0a6aafb3aa7061b9b7b1dada155d0cebb2f08fc69dbbfc1b1a2622763b4ef63d47461045b71dcd71421ea35fdf8d9f112ff0655d1db886827d4c63aa14573742de9b03372ad044ab1995c7b4bbf8fdf4af20b374f001a0ef1adfa4484fde7304980b6f1efc74379781bab7000d61bf1737c456422ed2ad134283bd58a37d6f7d80f76e2e109417958349b183616404900dc1bfdfb0f6381639e0f54e703aa7c484ca71e16d9bbd2a915b5eedc30fb36454eaf39c8c2652a92ab915846ac9c7e351f47223eb5c574cc21737a6d8eda3a18d85211328010939aa04b26db9dd1b343a21e77d9f6c92b568b5af633247d01bbc4a44c4373c09a4e0cf7145047eebf7febb88f85509e5800ecf7d493cea5925dc9a1131d4d7e2308cd4a5497c2483b5e8edd50525482a92e3c9fd1a4c96eec5e7644ac62b3cb7afd1483c942a34f4ba243410c30e13eb1109cccd1fa55d098e2fccd5b7ba8ebbd1ba766d7bec4b336776480b14ef4d78973c2a4c65ae6f8d6ec9d278efaf3a768edfd0a25ddcea44f0b9ccfe79a7bcde24c87642d2a2426950461721825d23a68e0870b7533b044f3def38a995d865ea2a29ea226e098877c76041d5552c9787d42d645b13584fb6d7e41275f448ef1aaabc3721bd4b3a52f7fbc54c67e86386ead5420668b5a13c6ef185403fd857aa315e45a5fbfb4b5d05f5e2d86bb96b793e12c188b59084a06233e60fcbbcf042f163fddea8fb100ea89783dcd3d4b27b34a0abba1e207546c85e2bbdf80f85b5496935d2434f3dedb829600a50b3330d5c3d2d8c9e9359ebabd7381fa494511812634f851624291715e1fa97ce1cff16527b7d05b52ad289428cbd36fb8733bf4661c3928b9a8aedb3602c573524b155ac0fc4e2159543ae815d7d99f0bb6dd3df28aa75b26cbe1bce79f56e00d87005021107b4f4cf256199bccd5474f251d79ddc31a7f05425a775b7ef7f2a87fe166f1fa7ac0fab85531ae71a0b6c5762c1ea9ca39cb9bd1ad3f52d6bb965bfb0fdc453743c56dac82581b0806f0e0d6e4ecbef077b61b216a41e102abcf13f6e5885a0c29d5e5bbcbd0a6a0114220b47fb891a9d99f7f63c406bb0507834695ed3dc140d0a5713fc25cfd829fdd05667907bb58c457eecb883903de78d49e002571b2afc62f8e460f420b6b47e1c08becfac68162010169425b1691e78688a2202228e6bbc3e1d31b2b8b083574e95bcbf0135944450b718bc1ace1830d1af15303208e4efaccfb17b1c01319d2fbf0ebfe3a5b4d5c33464a8bccc8019796ce2909e9a687dc64307c48a1cf233790f827e41bb1a887ab49b21622980dc3c77bad4915eb7eeee254ed7af27c0472c6a1026629594ba53ef15a055b929ed8cf0d19a5b17d41c7985cd7e7efac72126307f391ba02ae39157a9ec8c05d0989f1087855df3e4b6ff19e0df6d18afcd13ff55f3fb4bb244bb58e285197f690a0f41f7215c181d470e57d0e66144d43377da74ad89578c0c8062b48c750eff860aadd5e46f36ed3aee7af6e395eb8328fdb0da266aaeccf269ad8c3fa10e9b51268fca904f45d0bb22c5836b9e1bb1d264a6635f7d479aff0deb730a2847e44e821d15421b8235c93565bfec7b38f22c4bc49d9f76acb07cde715450055ba913684c54874163ae5e17756f6a38317b245c2dae984b05df426916c7a82cdc112e3ff19209732a793ff75e7b61ff05b28b77311a0a1f312e00336fe20de307b6b5d2b5f2d8cf441ab0355059806e9ac216635f88b41a48f15b6621e2676b7a6703a1361e903171136f4daa296e398313b2abf339922d078f8c856ba5cd573c561013af970128224f461c43caa149d46408f65618350d5b77ec3adef7a4cab74e2c4a4eaacc18816aee353a0e16e03773934b46b7de6a7066cbfa91afc9d98c7e72e1d3a3d134bde846c19a56422c4afd0ef6767ecbce6c165b5934e204ef2dc5626e4b14ab43afde58411ef376f08b147bbdfffbcb9f8003f707eb9642b690d65f91b4f709771fab9a4df3bf30ab7d5457aeba3878435f1d0559db3b0083b0fb9e9c1c9f91c8ef8b10ef3cfb92e8d15f6749012cf51cc39eb1188264eff72c75b92110252deb4dd856cea16c0d373f2bdc348ab86d332f00033500b366e20597ca397832e04ceceaf965c47662e89097e7d53c24087d125731a8052555c236679d498ae162842ad12bac48d25abbed48df3087574c6f172bca45fd6479a7b36795bf64bb9e7efa588d4721629b74b7c23ff478f13a5151580908f3b2729803e554d5eca5337b9c2a45977a8fdb3bde4dd2b77e538410abecd18f18479d9f4d0d1cc43ecda8252f221f2db75656ce51f005ff1096f37e548b667aa5fbb9d50c11a2d26c3783b6f3a9a1ba2c6540f9e25e60affe1e9af52f748260ae0059d5505613e64ab0c9b4660886e82408b3be0dd1db163c5ad1f906374d1b754b852e0b457c4289c1dd16ae04e6e1da9fb95332e51a870fbb351dfc4b33afe9decbe03f303b5378d117680cee2ebf41daaad57b68164032ee1c1f6c60ba6b493eb39924f943178b5dd829a40d1af0209f864c59a7a50beb67c07e1c9d69db5afc1ee50d55d9da36413afbd448861960214c773e985397612a714583482a4cc76270d7dd964e9800288fef011a946057ce0699717eb179f1226d9453c36a6dd718d8a93c6df44a015b4e3a38ea81cbf5b112882ca95220a9ccac676c6c7e15911ddfab9c13b6e579bd0f41d5f73d3f0d1744c3a1780162f31ea2e5c63e7990220ed81f697f7db5d74905090aaabbcdb5c7cb57100160a72f526d146d2813895bb2cc1cc4b79ad998a4e6b991bf3b062c6b0df712274c548fa8cd216d42c8b245cc9a17dcfc2393aca208d9f8fe31603221708545a677fddb8bc134f8262325198e7f421e80d98bddd0dcee1338583e2013cdff5689b8d55b82886b814b7861eeb9e814fd720fb7d59a84559fbf97346fcbf166c72713c12dc67fcfafc80e702e3cdf80fe1e69d983c6332d4c4e8711312452577e9197148259a2ba2777948e3ea7ebbbc5af53627341fe92a435b8cedd30f8a3d300a8b49c21778c6d255beac4e14d40543e53d3a54004741822118aeba08f7f26469bb7f0930d6699043f12bae88f539638371f1764036e3ced5ddf5f52d30971e584780d89071a456e6396c5fac311f14e78b170fbb4b07865ce9cc5511195215745618ed1f34b27a5927efacf8a6fc79c6cfd654fa959f637d144bf75266babacd19d555af939d61800c8530ffe55d57e297eaee0c9e30794e300357318a11fb7f43f22d152b730751ae89668e8ea4a2b2000ca5a72086afac132d66498a730fcb4b0af5388360af3476e29a41bd3863da5c4b026d650b41a7902490a997643c4003429aceb3a80cfc5adcab819e89eba40d401ee1dabcb6139771d091478304034b77fec19fadfc0c914c7ce9ef88c28b9c5e84dc5704af0aaac036a1c35e54b9a64eafa7c8309985adb23138ec9ba45e78602e750f9f5ec4cca9e75e94bed01a8ea4d4137a5320513dea8a9f1f3650392352ea6daf89d74e4e3783c80eedd7edabf39ef320f6af505359aec2d401ea9310e1f76fb9ce4981a75ad6821698d83b6aafc83cd1ddcd89f733ab9c82c7a868b23575eb42f1b1314e951b0b40afb484a306259be686571c7798cbf718aaaa0fc215c98f72fa8e2074e3158ec184c5241f3af5c135b40ea84eacb83db24e7341346ad9f3a2ce5b0534e18f6c3ed652f946fc018a12424d5c966d4bae8a7012674e4881c5f76f04cfa554a76001b24d6dd8e882dc7e98f91e3d7de0b7337e21ae6ac1bf1da9f28348a1cf1f00589a70050fe35e9765e48ae7c1dcaa59b0b8e18cc9481ba6162d097f457fc82765493012c249a3db0313b6bc5713d8e5f3f72fdee804cb261968be0cf926855c3946c60052b3ed5d93850","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
