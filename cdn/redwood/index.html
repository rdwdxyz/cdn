<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c39821d9d81a4776c44d9b313578b9ef0d0871b59f44a46c1a6313141767ecbb47dfef6f49acf56a99ba286781e73a6918d30cc07834289f3e68003911ff9f928bff966ba2c731a5507ee9dd47eaa171309cf1c60980e6501e5fafbc6d5c9f6a7d88c5b8bb1ac75ca9d02bcfa79d4d5f22f45ee89cbb47969b386d97866765227a023071ba2ad24f71d05fe7c1092d014f86cf76b31b6341c3d491b8c9f8d76bb7da0f0f742801b43d0700dfefbac4c25e1f38680312d0af4f4c1d5c219296dab32f18c92745a2ddcc009bb2dec72cc59ede8951aa11477a83060d501a318f746cc6ecb9e2a8a70e0723daea8a5abbca755a5c7f363cbcf6ba42e779b4ca11b55d2b4758d872e12c4dae65cc1c078839e4fd7cdccf3c7c28819a5954be24c34dcd85c8f9e0dae63d3498ff1391973ae31ed4ed51d3c53d9b45fd15c0ccae9b1041bb5848ac694f23bdb8b71d79c951e53e3d3bd94aa56007950d1bf66f788633371a71d7b66a7b140e8f890dab29c31dcd80a021e7030b26f5822a4c3c8845a146150bc8a44dd7675abdadec9aaa325f3d77884638a7cd4b76b32e26749deaa4efb630feeffd5b4abb6f736957abf330995e424744abb8187690f32756c37cc51fec96d41cf79654a4f8c9197fb220c8d24f50e5e79403d64a01efdc0d7888a59440b47485e4d4b04086cf86917d347b3ba919b7f4704586c3400861b443db4a79854a904935816a8581094e19daa2cc8de017cd2d3cc98ae93d7c6b828dead3e4c69dd8918b51cbbe9187716810bb98009774cc677f225471ea77e009898116f894a379ebe9f40f2895bd5f1769cf0875d7c5f9132aa9ddd5763a5bc9cb3398a9a160cebf458333a2b5ce5a9da723c1573b79533caaa4d8dc5850f96bc0100901ff0841f399472952105a678b862c7d73c84c440eafabe914fcde3787383a93a8e6702afa0c9b5887d0319bf8d360b602eddf002722b227e7aac1e7d99937e40c6f3c80dcd906c23840d4db7e1cb81ecc1f78dbafae3262ab0c8d458626b2a9d79d3b7be8fa62a1ecaf14af4646710f3cd8f28e18cab610ce32632707bb5a9f41a24e323a69b4fc1c34c25d3ea53a78c4afccce639ece9c5409dc996c3ded4f3ebc66123c2de1d7bbfd3996c46f3b3c995359395e7f9ff942f01f537f6d33bf436361ddee5ccc52d6789012f00cfc2eaae15587a6d359edd34f6dc2c86be85f5b9983114f720c55495c270d24e135da56e5c986be6651a019c13eb55ed8b0e7ecaef122167e81efacf38e52491eec2c424237e7890f703f2e39911b2a11fe6f55d3741c12a29ed47f7be2743c3a9fa39938e148f681dc5e35c0206b5d34f7d5368d50e1c7992ebe4b81aec50a30c423cdf577fe9d5ee817299661f68d106abcaf53d28bdd59bdc77741de0100f2b66656334a690c3e085ef33d223021a6a71fc4fb69fe9b6c6d907021917aa5d11d51ac5b6677494e93fb8b7f640b94343389238bc1a761474d6b527b7c1e16328027098fecb1043f276a1af978bbef0c6b5ab0667ce31898db353fa03c04836b6d40a3b95cdb8bc0e2cd50bc88b1ed3976da303bc7a182d5919d033946aa4f324373497fc88e1cbe0f79a61b2823263b1da1b380f655aa8b6944052382bad3fccb37f4e8e6e6352165cd3bf5a692384d4f60cebfbc21b651e4e1caab8abcef2cecff12980ef14f037c79ad3bd2fec458b600de06349d63932abe1ba2bb15e2b8bbd6a48d01b4bfb134522438937736303ac59dd0e47b087d034564c1b985e85261f1caaac3aca25bb8a9438bfc3e287671002e117b40454e0c8acc5a91e1de6da405996b4142498504837145598d55dd8a4d67769859c3569b8e826884a264e5143177a3c2c004103183785915232744cb7690d28c35fc667a33162e3e88a3448631f73370b60d2f8c448923cefef0c6cd48070c34633c2a34a854bb4b628133df3a02db2079f11eccce60b46118204a649739fe9e9224fa01b0c8c39d2e8cb00e0ba70a479a8eed7e42f97b03fb648f3516bdb9055b8e74c1e21c1ed1a9018303959b620e894219ef52ad44a9c5fa5ac21b2dce8b763b393395a205c70709da87dd846860db159f73d235e6d966fae453b00c19837e905712b6795fa53f1151ce4a59d37bece20c1b5e8f122ed8078c887982becd0b2e60f602dfe122bf3db7274cef18847baaeded3a9487bbabeaff80f59e4bb92440860c35f6586eb95bb2187264e2cff866dbd304c7383ce8a884b9ed854d7c3cdce7bfb7f55d4157f9cbfabc72d24ce1224960d2c863da8eeab80073724d4f0eccd2290132f26ca43b321217a5251a598991648d48c31cd4ab4dd19d1d22eb54d7f3adcaecd664229acd50dd4e3d25d258f2394d10d927d75a4679d9992bdc18883a9d4e75e8b8642eded684354290c922789a242cc222ca6b6a137388fd1c0ca885984de9df6c6daa604e3d42cb1f66d0f89b335de19e8e28e4c427df41f10bd8c6b55bb940a0d14a266d3c7f4fe42bbf164b0f72bb689ee9e400804ac4d9290d80952f78a5b03d6e5b4abeb21d6d2f0481eea8ab1572ab2fc01db08798a9148e2b617636446426661b03de38ffdcc7f7ca5b75a33aba2a995a38c69638fc7c5a1aedbcc4d7738565c5f3d1bd40b9ae067c3a500c535e11dd1db39aba4af57ae281541a9e2b05c8c80d009d4deeeab86e6212834a62ce45ff52ad33635ef2adc19c4ad23ebe3eabfec792ed3730938512f6116773eebd9867e26a34a45fee7bd8fa695c2d784e3a64457c8a13b617ec2908c6d8f13a02ca2666e1926e0f8a5602b33829b92912b8f9eed46c86e05caae5711ede4bb3e613cc8f762bec212a9fe63388267aa768426e9f71a5bda94adcee799f1ebbd0409d18b76d36757beb33cab59935828c9ff1c3ff98273c8039fc13c52733acff890667db443b367bdda6ee6e023b731366f0ca8b19e7236a00a4b98059ebf239cd6385e3894aca10604d47d689424904601261ccc52b911d47aa396925ac3d099c14926a83eabb3841b346956acd203f3ecbb5951c9a9aa84d47b4fad3a93f5ca15bd5a514ced1c897fe65540a0490fa6975883a1258ec97d2fe62c9ca4d44609fdd3cea48208baa1e792eeaf29ccd2dc8ea681cf63fd56686c1461e7f1dbe0a142fefc4984f3ec51e89803764de9f8b3010ef8462f8366fbdf4a2932b0ec2f75349ee49af1ba44082e0e26aae53a52a1aa7122e22ba9999729f6475f796c0003d253b57c4775c83767ccbdf141cb3f4059e9e88cd63e1256ff4ca7203bc0fe281a80342b16a902562b3a2438352a330120a6e43ddd346d3b0c8407726ff761938139495489c65b7d77f7381e0f6d5a46ca6c90239edd65aa0f63024a5f7c420494f5981863d377ac284513148e139675cd18931ea210d2ed5c7ed987b29002b7f2990ad067621fb38e1cbf8c15317066bd68fcf04cf9f19f15b2df5c33d2780b27ac5025dc4c9d40294554b00f2519f1ef6bc6ab3c8b4ae5900f44ff978bf8a8327ff4832ef6562d9edc7c406989d6dad10816db4e74e2c4ab5b0b610f76e20efab5c995457559ff8609482afdf3040477d5a6c8eb7a27d5c487fabb033c600d18c7cd212fdc060e21957918caeadb4c37ab9e1103bbaaa0e078b29a2e7b3c5653898722381401f20f7a33096868b2226414055fd2236d7256ba991b4d8367e09b773fc7f5e1360d3b0933d265baf320c1ac02b060a3f66ab52d88891f5e28e2e1dc4d3bfb7c3f2fde0e1d58e0f12ef3c62fe77e46c71134e26e908134f24256893e9334f58d14d55306ac6349109962026f3b9859858904f3b8b3ac4ca04d67aebf87ad452dc08c7a8c2985cb2c1a4c95f379faa4cd1a7089b4c2699386421256535604242fb51740e95bfa624aa6a1a109f2e819862f22c97a9431c119d7b158469d5e5f6a93bc09a4ee8c7e9647d4beaacb0c44e02f331ec2ab8261016404016e53f6beed6012c4096d9b3ec141cfa0945390a8735240198d6d3dc37d13ef009f3d04555c7108fcc7d22435939ab286fa5646cdddafbbd63f15a01642f3dbcd12a35ea4f1004b9662a99ccccea544a6c051dc5327df960c46138da930a497be0c3074fa4fc2375f898cee26c0a5982f08d5a9864e93df65279c98eccbd791a6eed980aaa017ee39dc446a7da3ed30f25209ba578ebbaa65ff1f30bf9b8e6131d249efd10d9a7a782111a7baccf87ebc0ed3f720e113a14d2d31797c02aef4ee06b3f350240253258182b6d627dcd392bfdf11898b97e4fbb6ca008b972fe3490dce06cc253d2d0e5690aec5544fd56297dda9efdbba45ad542434db239c82dfbe6a069ae8f35a137ba382ed5b8d54be597d17a2c8b2b607ea21c1bbe673d1ab5f21b957156f1b586f98a05b67d80147bad69b96feb6edbbe5d05def243fb6ba83ee9c5116fbc54ec89cfa1cae492259176f651029e70a579bf4acc8f5a3973ddc4b744f1821cfdf52a7d54fc8ca596b9bd230c4ad21dfed106aab2e19a4b700d3531eaa97e19fdbb2b47ea0493836f460cf510cb7407f0906d23552459c13da76e61a279c09d1446f39ff316756a1b607844d9279d6f95eaa38ea43e88cc22613b9ec454259e0ab8a992428ecc67e7fb622745b02c634db370aa23614351b23078be74b23a010f3aded24178f18369b6c255fe4b898249cc864067eff819095b918792c1283c884b67585615f08381c0c41bf1e6ed47d7f06394a5b50449b40ee09ee9450c97e4d3a343839bf9ef06a5e63b305f4cf1241c75ace1626a3e15cca532b73bceda3772c11afa831d48b58119b44019b0c1dc7764a13f8092a427c19f6d6970e74dedeb65c5b96977eb35b96db2397644befaf84d43dcf34cdc10965827c09eafca008850f02a2e350ddb08e9594ff1c9372a5062bf3e54dda52aba7db8bc623308e7ea09083542c3a9361f85cec4c83278cbffbc362dd46ad38a39418b9bae396b55973b05f9c5f3ab43fcf484afb304c7aae03afe38262f107d8345497d6faf1207fa6930dd93acfd02a50663ed5b3146a23600862bf396f56ab08140881659ab73070c185c80bf03b2d8610ebc67ae9cf770a1748e6c09b5bb89866d7f702e3000f9796d54be8f1a5f1860cbc00b13df977aa9386bbaaa559bf12c40041252bb3107c8956b1480ec6f78a9bff0376d2ca7482607ac865bd2d60fab3ecfba2a96b1782bd6c918b112f69fe2d03407e579ed1b5473e223029ebd692969c700db4615c3f133eecd7e8819f4adba0594660178603707420fb7863b97e6801db3603e3558154d5dc49e2c11745a918373ea1ffc49b4046705b2040170bb1332f4e6e9d9eb8ec2620d53d77fb1a9caa32734dca98e51affd9296971e6913f470f0427c8c66a314d339a5f3e39b4d05b021e120c4831b7a0f2f818350fb2faf07bb5b2388e4c9980b6986d6a86d8efac12d9ec4a1fe1fac2c18ef9a05370ab3beab21ec40d73d2e269ece44db6fa8c01d078628ab89d0535a056f7b4f2a0f7bc373ec0584fc1ec3a4c2d74f2f88ae366ea3cfeabf1d0129d67a9d732f04b277c7b38e4e45171b0eb8348f9e9d9982cc5f4cf3213b6812f5446b66168e90440017db4b8d1509fe35c2aae2cd5d4c474bf039d9a267dc344a7f20aac21cfa66761fedde6fea75f329b0a1ff050ff69e00e4a3cd61ed96ac32d45d24a78f2b8e9652c2a411af280a6cb0fe24ce2f00efc7362384f5f9337f770ef41e39aff9c2816baf3817bdb6e62ca2e7725bfc0481bc767bda9d8bc8894e01fd26d676cc5e2c294e277f36282d2ed962e956541fecfe7b115c6a40beaffe73a49373b4c22145317bccaa8ac3570885f6ccc9aa76d97cf9ae8ac7a9fa15423c80d87c0f6739ef4dca56ba02e4e543fcb59226611417b36359c85986915feaf97b625e37f0ddda5a2d6956a789e5f5012f63c51700afd88350062711164e3974228411b431eba08f6ed9b9e0e010b0bab792fd7d666e2ab1596653a1b2d1f7915f2275f3c60894ac5ec5d3ecf811423223e134eee81fd1298468193a6872f1ffd5a32009ac1a7a64098bb2afac57132520ebb27838228e45978f2a7fe2e3c992d4f45cdd62005960a35bc9325fd77555eb6d0f8ebb59cf87882d794534848b14a8b5df9a0ceedbc654e71d1ff198cdb56f2bfa17557c75ef3567d0bff691d81350c1f1bed305bef417eb64b9f0a1080eb98faab4af38c35d9b6056e2c9ec704f6ed6b7ec54f563db15380bae999b7a8c0796c108c34dafac9d98ed464203dd4211230f7fc10387e872dca6bf09d2402b5656c42e3cb847f22d2b6e6a057d559092eab8e9b7041556c522e0bed217d7641f36a428d0edee5cdb3479df6a88353ca1b2e1b943a9378783bf4e17729caa806beee1939e8c506c2f77becdc56e42772e26da710a7c4ad13e54d4bbd2016c2c6eab0332f1dc538e810ba1d4fee1b02907ee50d41800940c8a81ea08b3a51c368fe05a89c587ec95b8e584cc91d2914c123a222c083b6f6d7b873ab9103933f354883d42f0b5689c32a15289cd0932ba7ec5ae252746de3a3b43f554a5660144b61dcc654e94f548e6fc2fc3a0246bce34b6713f87a9721fd2bd3569458add7477cb2361d290428692114b5a3ec3afeba1f6c93e144291d4c618e26c4bc92da84458ed985ffb11297a9d1824131ae0af946be4cd3b7e96e7474cf2594ec26d146f274c22a830766f53aba05740e0c243919a603da78ad6ed52d04e0ce881e94731082e2f3b8f2416923fe20c9904b7b74bb670f69261bc21e706c480ceebf0a598b60b3f5a3442e3415d14c95ec1898152747047d75c0db68de0457541eb15a586aa9e417deb8d8771749e46c9bc85d32b588e2238045318d785b668501682bd81521c651206de9dd89eda9b210ea539b47ac8c56cdda417a17679ce9389caebabe54251432aec1ed9b96446347d37630122a019d7b416533ff026a9564c96cbe24a01cafd17640c1e841657f250463d4aa2c05add5b61ae975c9d2b963b074eb80a86d83348dda3c2df9e8b6ce384a417326af572ce95daa0f869fbfd3893358691ed6e6d55fdaf849e2a0d038824f6794650cfd66aca787fdcb02ec81c7e8fb5e5064c0ce1178bd0bacd17fa3b646b035bdbd1ff5099b990172c5c1286fd95c60ade3210f4e2e97b6fa1458bba76f6f6d3ce1ca45fe290ed831a4bf49acd13a9369d8d4984789353aba163bf37659b681c2ce82fa884062d2d6122b8c3b7f9e6156747a3e8f189b9218fe7110a23f589f63c843bf03e8b36b1f049626196e1de6cd129ee56f8cf46f19c1a42ecfc30bf91746dbff11dbb4f717e1e8d509029ef450feb4ec398f986c2a76bf2b87cb2899f1cc5730695f26bec5fd2b3cbb19c6cd3264363adca0bd5164aa533371864b6af741b7bdeaa6036371fd3022760c1cb48834158195afa1bc642e8dbf60b3492c544a8526b748bd351e7127e690908c224e7409391622070f05826e7235d4e3433d42b578925b2b14c922d8bc066f4f42e9adfccef705cf777cba8fc237555e69ce43f32fd216fe99489571ba7255b2fad0ca7d93a5cf5f9979074f35c3efedd8272732d602fb0f3b8df9c838c12f4791da8e4208f76faf1b7fdfce869982a1c11c41d4504b372955933e7b4e8be4c74b03610bacb37e4c0c2b325314e78db2f06c75e2534d5a5dd272452baf6472693e376b9fe088656d58e0932b1a46cebff1656bd92e4a73b10727a6a24efd0ea1dbe318a4f54a2b49b2f2f6537b4cb9f385ab6dd21959e650290ac80bde60a40eaad545df3b3fc00cdbbedf153f4aeec61247b2bcf7128030a509aae8815f319fd21c602792153b5ab61798ec6147c838fc85c9eaed6b7941a65a5564a84c69eb6b59f0952f57543a2f35f1293e66958411a75438bc607cc7d67c5ddce831e45a52fad7b6b740d66493a95edf29a5a563fb62e0a97c27538817e91ce2889b4af78ebf05d0e3ec3b6c9125baade74bd556ef70833ab48e67ee6ba7e672ce59eb3e69807331ed1deaeaf9e7dcb98ae4c183259f720eff14435057f196c5fa6146254d6ab15977de88d72687995a91f866476bfddd48b6a5f3630b34d0c708574a5980ac7a1cf50d692fcf64cba1e3a270012678e737eb509c1e33b8a984c9821e610ba20ae0dd47fa87a33076c3d4aff3b6c7bbb10cbe97467b2d59fdf2904b88fc3d2aa9b4d1364f79f841e308e6f9805fe6039f17682e4a8924e933cfbd3ed77571df1f30d0eab6ca6274b4542d55851623cd963cb123868d1bf1f198328147baea3b2335b1e09b2d4939718329ab3d884ffa6efa0f2f0b09d49c8cfe23f4047222a2856fee8f778db78b50fe782d9acb2e21671c3b6dcc0b95c367979985e5990b9ade80bc459e22e12d3dda8b014ca239a5d8026cf6e82441aa2e8b1e93feb2a0892eceef9d0a19864df123db6c327c1be5f1042a1ee5c15d348fe417fded6493071f3fd28f7855b731624c98eb244b71f7badf8fcccfb92b3f9dc672dbe171d6579a3527ca00c2ce70910807e81013dd0186c439dbd9cc2c5ab8ee1e2f98fd4313b8aa31b969c3bd7042fddd7fecacf2c907419dffe41ecdba5e73ff88a656a113757ef00ab167ce9c88ec8a882df1d804f66913df2e69d8c80e7291c7774cdea0255d4a1bc6517a2bdfdef576371733c0ae14684a3c0660ee2224130ab390e2180cc50b7d904705491b81f463eff9f726df6639edeaf63dafb0ece29ca232a0a4d97a013df35f9037c0173759c8dfa867a844396909af583e9f4c5d6801aca689ebab59697bc606af343712dd49e4e054dca76dc6e50f76d8363658394e96d7663e8459a6b3593a613ccf847c572744b31b9a3a31a0742258aeb10b820f4edb0fd249a6861634a4d79a0bc58671b3aad4ba9a9c25a380a90908c7b4dff412bc0065e4e72c1cd2d232a52196a16ed9d7816dab05bd15ceba07bf1deb860ca3e78af03fbdaf267006118cc8afae4ac648ff7f7b3995b2c8f2e7f25a7a8712093a805d52eea82ae86bdb644b1d01d8345e6e824fc7a5b570a624992a0f9b58c746e23be6f11f99575ea3e1a30e64b28e297c352af8f3a26b667996f201a4b63cb3f2b5835357d8f2dc5ed45539049cf4850bbcf0267e2ffc941111d5d6608aee92c3524f0bd57b834daf18afea51f5fbf737669f2f4ee27e448c7db177677c74c0c6792268eebf3f20d9404844cd5ba50505d0f769ca725d57c8e926205c7ff7495aa0664c7c494ce1dda1bc0b4e0d49c6864ae2b17886d70afc08a49ce0aed5f2b3021672e00481127266a7970112b188b5d76ba21c7275ea5903df15c45ba2a3f8758a16923e0e2e998ae44e75de2ef3179f96a9ab6ba75c12f8f798dedf5b0ab4c144e84f11181122bfde4ceea569d4cac174a7083979e61992ae0e0c3b58e903d29ee6b8def0f1d415d4d996cd13939f82102b52ab22ab727f754ecdf1d15a72a66a0de79de18e558893a51acdad9f6bbbe315dd376553a53975c679ee7b1c6552e991a6adb9000e9f665a2580ff5bdb7e98fa6c4c2ad69dbe6bc8974bb4a0951c39906498101dd00e43c72d97810e10ec5149c7ab2af0b7edf7888f3eb1f000bd6056a2607d429ee06849c6a798dd20ce11b3fdcf5bfbe95ef4de5927fa35f5e004cf6cb7fb42333a7884f357403e36531ff8e3df920e67e94a3251459adff9f3a08ed182de55bd80957674fdc95a5ceca5f510c65c24bad4a3016d3fd5ac476cbc49198206cfc1c2a7e63da8abff116987733050811be0e7dcb804cce061cbd2f2314b6697918af5599768a91a51446ba8585ad679627a1ffe8c86ac606f2e41fd9bb77aac54d6d4b7483f55a5af7893ccc3109120d99017c611128b6880c3adb1fa105dfaeff32c3b4ef97259c9f8c923e905adb9efd26251f6af52b5e4e2136ae5cf0dc61c0fc6ae3f3130d276781acca90f329ee1f17e8c1f4b15b237f8a510d84aab761195af82ffb86723ec13ff03b84b0f3ab9970b732e3643eaf833726edca9180e3a2f7a7491269b74a5a80a919ad5a0907114ea94d3822ebba34d93fadaaba52b0d712fff57c87ff2f9a708378f1ed91cdc2691ba3d0bbb1ae56e97d5b09731de80af8d6b5334eb4e8b4fe37aa704359d840307b86ab6be7d319758bb4e80da0eea21aedff303f270604f8de4198ccdf99a1f58eb4b7ea062418ad1f61bf0bb93a54f34ecf61a84d872bec54e5e069525711e6d29ae1a151dd9479c5fef9bbebffa29cfec08b780f3605d548067f676327dd6a2997b6b0a90488d15c03dacf1aa6bf240721f2780e282bbe1f1e8759095016cb0a9718c048a8450d7443acb3794875d36c173ba07beec8612a5e140d0016a52eaa2f234024588fb7703f29b327365761089fe155d478350c9ba86a8c79665227c2e002ddb78b12143d908643c27dd762912799c644a711698f2e150cb87182383b5e3c80cda379694bdfb40c74332e8854295d0ad71d49cfd19ad248e9988305242503d9eb2bb62bddeed953a3c4c52b735a5b8e9fd1fe5ea7d5dc11520a95010a0ee0fe17de93286aa5aba96905ee77bb038a27f6fc0ff10b7bf8fde047ddc2ac8891a9c0a0294864417d2597572f77596aaac83bc6efcc6cc0ccd704221b1b050192bb084ddd24fd802eb155b7683bb562b7482fcf964b06d856c69a8e25bcb387a6a1a98e847e59d9fd2cea71a1d2967cf1dae292d330f076f336e77abd52b6c1d3d3113e6e090417639d621de9944c9f9798893483192850ecbeab0d26a86b5b80b556fcb431cb21e049416c25047672925aa89cf34806ba10621dfebf76d2a8917c4370e5fae71a1ca884122f81bc891e54771e2e4eb54582d0b4d1a22ebfd734020672e7a2d170c23a185a7bcad0bd37b060e0da9a6300d0820d769ed14aadb926d06417a7cc4e46c5d573e54e179f4ea78256e3bed2bef1dea0e58489e63ca544fb52e4867dbf956d19aca3c9b6640107dd2655a999fb1daf33681cf7d3bb8db65e516c822feddf8786d9384df7a5b797d8d871d6afe582e27eeb649ce8bb6f6239c2f70a35a9f3894fc2d8dc00a6dc07c3fdc8cedb966da751ad1baf70b0b3e89189d8c683433dbaf305bd2e9c35b0951dd7c5cbb67e8b2c74531383ae8da92c54aa215f73852d3b47ce1db40fa5a15b0f1ea00c18c14b1757b4cd5f57eeaefea6ee866305e44b0d38c3b211d2e7ffabb72ba2f4e95f8977121b5d4f76ff412f8f9013016e407f3541c90adef3a8cc5563300acfe865931772dc2083f9032383ef0713233076e0ff51342b45364671f8f12f448ef81d2bc142cab5a7b859d66ca7724cb1882c6e483f2fef5349ca34e232f453f66e8332dcb12fc837bdd39db84c159ba70d69337a95bed9143f8fc3c7e9b703dd408b3177448d4394d2317dbcf5b881e6a88bd22efc87fafb21553be6b50702ac8f5d5ee0bc6edae0dec8bc582d47670ec04cfd355807891ba88adf44a6c40db44f477ed554ff3eaa7b11d23d4496ed78fdff97914b713d02a6b3c9bc1e8c9319208a689191e57cc29fb728fd719e6101ab787f06738da47765ba6ec4c7b05269306f160af40845220a17ba9747851fefdaed449752b6976e2818296debf1752d32818afb76a365ee17e3b391885542a039fa133c84e5ca688cef2e51c9767b9d9b26118a4d500c2fa463a7de02a35933eabf4861778c52488890c8da485ce6dff3959b71f92dc3d3ea1f7710086a935edd4c78953756e08c064667bbdcf2108d30e3ff31f656ea2edad3a2ff1b9ba980b0d26887ef0b9ccd0aa7f8c543d366fa5158033831be97741d4a1615e10d8583c928438b91ab524840fb32dac7470133010992995b649e1a392d934a182720364c27c17e4641e066d3b0978f3c5595f4ab54ce06aed049182496bbabd85705a97e6473874757e4ca2f798454e825017b0a5d3e3a39697cde23b3b921a9d6a87c90fa078291be12e74f2795598741307ce6dd42241e17c79119ebcb79b1d31a25f34944b957f2c1aee9d7085728112fdf014eda9058064d43b5555f2caaf6abc1ea0554fd1f15bb5517b8d3cbcf3987fbeb12e2c5b08fc0890b246327af93d77cce1fa2983510149e47d63fbb1cfc52006a6a9dea3804e964d9f68c4b230e800bc67464ee4a4796585706aa4badd0fff28dc51ff021958379fd23d56835672556e1a1c905dc4cf962b374bd9774d7982927674c47bd41554d9cf33c32c52e7817b6d7ecddcdf3b120ef1211596aad792c4e09e75d6eaed8f762a835fc37740ce80c51e3cb30ddb9bb256e75253eac962946d2b06f41799ba871c1009d1ddcf74e54e91d750c98b665dce5ed5d9537ef9514efc99ea88dfe8cb507a7a0bbf8e84d154cc14d5d4b6bfb9d6e6b291b327aefdd97c840f2c4c49816362244fe5c9e075457f9c2ef76fb1fde975937e01d1f5890bd31d49e491022161165e0b40409ae4fa3c28d1b4e59c851fc8912aaf2491b7184c6d35e05f8d8b46d31431e6adcb218a77bcc0e14d2de7693f6375ef6e149b7e4c3f853f133a8dd25bde23aca8a2ef1c4c466ca5732a73026a06865a41ded9ba1724cf1b021d8d038e7e0d639f60f20da3db73feb92295e904817027b322b52fb2cb6b51f2e50be0f532bdaf6d8d1c0056bba0d4e495c63d8fc8621cc081187bc444b357c33e224bb412934b5fec724688861f66cc42ba7d8b01dfc339023b2c047da3aee8684f6678d8f7f6cf3972f4344c6486ff909f665df30926f9010592db7e0ba84a6249902957773c44ef2d4aa5f1c9e7d5fd391ed7ee91d4bb3434eb9def49ec48a99be7ada77cb8086c9c2e9c14fe9eb2d7f605de4fa4b3e90b75dd6f32edbbe4a0300b888cd03a989c3a866a06631bc5c507b17a159d436c341a5a3c167edc970733397c067741806a567e7764d335145c2a97f7aad432675773b8955e4d5eee5e7e11b53b80c3da26f8550b7566e15bb9d40d737518e065f3dac34dddebf17070049ed11418583c02845875d090d2d5d8b3a47c874f05e78659706ef69c298f83ee0944f70ea8c2baa5aeee3694bb305aef7755ff0dc22133f3bac8478007aea8dfe1fac14d90375501ad6ee20f948d00907582e7a43536fd22b2acfa8a86e344986171199c688e9362f840fcfeccdff379aee25b2986104d26ac489ce290a95d1da12706667f9bd94208dbf106bae568a5fe3e5424c439b148b4ec702f4c7479d789d279fb7a7b3dae2837e1b81042a25d02b1e63e89d69d781ee486e1383cea772afa77e7b0d5621c5ce815e3e85c3d24591b5db1d2bc98180d9f6afbddcfb011ae2686f4167ac65ec76047a3d1732c5a208bb5876a0c2a484d3b5b167262b89acad14145ee84eba5983f303740ae9bba1599de5cbddf9e78120e5643cfd898c9a8a6341399b557158c3f32328f141aa886ff3b4d0c573c8a28111720c2bec72fa62d52b6bdff866baccabcea6d027f644a0eb01d694b64f1a0ba1d4afb466a7661c01e51b7ad18cde59532cdcf1882ceab251cf7e0f8251bec48d8b0b8c9b639df51c0e83354c213120029481ddd31c554ed5b01447c15fa986ed5becd672d583e10d90fc8cbb015335335ddf3c9a10b37621c27e4a3cb949eb65d25633934ae9588245b27c40eb41f5db5f2f6ef5cf47623ed74d628610aedfe554675c74ef6ce72b8a6b7ea5828e5cd514a483e44beae42ac8c53208dbbc6a05cf8a953341c67222e4d1dc9120752a50f0bcc0304816dc7f39a86dfac946329a0004620d0cca757e8a34222f4731a21359c44f788c35f73722c6cf959682dcbd07b2bb5529a60533179e49ead78cb1fb94d0197fc689ccdd76e2d677d315836b1ff698d579591a522fbb88f813a30896ca6c04feb50ae3fc494f9ca804d551889ee50507c59027bf2ee4664a437fd7236b9b36a4d58b9bd28f96bd2f99dba95ebcac2c664fdd89de97ad16ce8c92cca8e12c42ce64897d09ffdad5e4150524acd13fa531dd13745fbe60c982b3d8ea35d82e54591697b27b2e89d776b352fc70b6089efd47a531527f911d0071bad32c4650a1c1399f6d4335bc0f88d0ff01167f56a64c13420e16957a1abf0abf3899d046933151720335d148e15940f9e4ef384c5d5d1309a09a95c7ff9e66731be37cde508d16d7f4408c76c88421c80f0a02027018097dbf0061a26c418fa76e311ef1c7f0eef0697552e0ec355ae61173b65ae2c13bf179542f78d1f9967c6a85e9eee9e003dc1c3d3fd02681caad3e758a98bd57557552f366619524f860271722e304130bdacec9472a94f3fb08cb437361f6e775a9393565449a00e8894588311fed5469cbde1065ffb8bf2b73a7dff5d7bcde6018d64f25fa806e1d1050b2b60249980e4fb0efde51a5319df5fb5f2f458846d2908510271b6c23c368d2d31ccad1d55a10a2ac6d0e40b95abdaa389ba57d950318c8f274920d26686bd080a1e198a52fa239fa55ab36ae5c1dd6d6ef7203834f45c47bd778b6f9a950df569e090bf9bff77e09a65716b2dfb42190b922b9442ae0b33968296a688dbe12292eca81461387b2a6b9d0272cb85de4b50eb4aa3de1f33d171e536d37dd182cac7b72ddbf57de3dc630c0e16037be7afe37f673b1ddeb592ac49cd325ce1fc4ba5205e469650bda500bc9897c178c52315df7cced1fd311ba873aae39b45d42c7cff6d2e300f72628a428808f475311c5adb08f64f6bf3209f8d578e9329b030632f63f6aa5449561c737e7c9395200763d76e395302531d8a67bced96b512acf24f86596c04bd96d97732616feefdfe55bd2afe38fd4da613c701a6d93c6d69bd2f0d5be45af0fbab45bc3efa3026a9ac9120637c6dd6d89114b8b43d69a1e58eb6636887ff829062238454284e6541b2f60c9de99ceac8f660336e3b92de3449bab6c055aeec76a83fb7b7c339adcc490ecd7f3bf458a1e123fc56e074d33fa88b8f817782dd23b223895c4c0d040094455bdd2230bec2294fee8392aa53fec4e4119cdefadd918e2a2a8419f074fe5d70fed097aa01c7907de3d33111ae37528d0e1cb4ab1d6639fd3c16fded3dc61547bd47f9f609aacd32754966f9cce8057b5c9ccd9ad8381bc08c88bae4b7632fe9b35ffb2c3e74525c7f92e1b8133da3a6f1774bfca5af5ad18e3580125ee00e3694cd37ebef3aa87424cb5a77265fa62432d992221349d009e0453c37dfe803a8d2ed620feb477825c5e33960422302d679016d996aac790177bbcccbc8204df4a2e34a40060c3f0aeb6536c73c1669c55c61b5aba5a6922307883fb7cd5a18a09ecbc96f03f9df2581c87ae604da3f0cccbbd6bd0cce55ab89f74cb98ab8437f21e050520d60b7ae7243bccdd35713bfebf53983aa09b852eda376a479927657dd9dc4cfc17ae265c6fe972d18436fb40d78632e40d3e99612b7e280794c68379ba532abdc8129aa3dccbeec24ea4e57890d84e323323b462ae2d71d69d6e8aa1f8680746a089eca80486934e68ab602fde1217a228d990d233626f4e9b6659cfb925d9e1f4c2a172946d187ec23385f6c21a26954d792fe4266570961371bf1db90a17c1f64affebe95e2766cc477866daabe7cdd491e67c3eb6f6607b0849207010e311957d8f681619c4b806f33cc82d09899bd9d0d0f1aa62e4eebe1250c921765af6a55cc18f59b8cdb0abb2b76ba3d9a7eed52a8c8bfe0b5b30c149121d03c63ecfceb9e6dd917a0a8d1654bb609aad32a257c285c686d8bf07e59e89111b93ce6f40b873b02aa633138ea5392c6e0be018ca185541acb2cda8fa8a5e3924df5818d0f6f1e45277db86471454bcc1bf6025c7980e81fec7dc476d14a278670d0df68a8d26f798015ea860a6d4c8c1c28a36e99986c963bc0a6525ff73d442dc6bdfbb0bbe003fca4c4582649fde12dca35704eac0725957689175285e0122aca2a73eaa63867f249fe87e1e7f5588bb4622ea2b4d3fe86bc30728358f8291512785c8abd0c38265b23cd4e12083f5114e13faac4a17b9c3d9e2efcaa5dce96263a1bc1fe7c1e1c592684278705dae76695c7764aa0a18567ce16f4fb6be2be72e173be7105ec250ae8ffc96d9eb85196d4ffbeb5c686a91c400b389037d7aba310a9bd3e35cb9329c666f8eb7c5629357954b584f1d6a75f1b55beca336d1fba0b5fd8d226915f766d58bdc01da2cf80d4bcf93df43d26a5067f0b9b8a14440fb193984f368e556fc15b928d7f8617d087e67a25ec9c90bcb0b9a8f30a75f0727dc87831da2f0286be98505391dbbda214f8b4551b78eaaac3064d9978daca574cf7fe66fef0cea5857635c593e72e2b31180113d5856b462ea564d0d2ff1ad5b5fe90c9ffcf7ef53a81585c4d0b3ceeb45615b97d5461fb3f5a73081a10dfd0ee1c753a906e27476aac96b16038df729077539ba7c08014a082001cec1c4ee0dc409904ea6982f287a79822ede537a3e9130a0f2b5a7da2606fb3ecb32ebd408c6c3a134fceda044f5ff03f7f4eb75a637a2b3f234a30b07ffee2f72a48eb9270371b05047fb8a2400741b55547076c1b876c081451ddc92600621610431d26672b7ee43b9790078123d1b6e65f1bf6c6686d000bdf74a163f1aa281501d05910a396cefd37e265ea86aea58091580eb9649f477102733a64db910da41046db96f66b9e8b878240b09a148e3ace3954497db2f22cf94995e36c7cf7c0d5408ac7001cda0df23ad47b1c95b2018922c0624e13fcd4bcfe9a9545a00de76087cd1d6546f213c28369ff3bd74a58baa41b7f76ebd870d2c4da25f579694bd48dc16fbce2912344712300a27ffd352dc440e3824ebae3a8f58233a00fd365933145413300b7f64aa76ad534674646a5a3589df1a80e6ba106f98495eca770b4d056a5f3df8f0803c50d7c4f59142305ffbe81d603205e0da167f0d6ef30094534d739dcb3e365caf3a0e4fde6753c1a4934ec0796ec5bdef674d9dfdae878cedd434b818d7d781b69732f82973e6600bcbf20cc7871ac9a5aa041af7de900178998d429ff6fccc7557daa2eb0391f24e32b0f46747ffbc4019d51f281be3368b6f33c9d2a58e8afb22e66053774c42ff308f2bf7e6abaa303706314e4c90c0e7dcb5755183c559c8c118c03234025b3cac5c9d5c7aa836bffece82e6fc396a21802975b3da01650ff33944cd229acd84693ca01969c2c2371311f0af3088088ef328c414d3ac767ad4757eb0e60b6d0565ad942d3f5d2a3c28973098ad1ba0cc00663c935f8538b1c918ad6c69dd662b91a132185960d850c44036eb35c6bfe8fc1ce103bc410ac3bd888c6d675bb0646240c24befa01234f3864953070dd77522a8128c897bc881c466184d8a6406f4127cc84dd89c469b10f5f0f9d5a9c1a4be851bcfe99802e3899397f43b4abe3b50a213e7f96fe309335b02e6438104519557f3443f5cbfbe1c04c28ca4d42e38ea75a608e18e44a27cf339229618b36eb397f7ad9c528a21eca9576325c9cbb3b56b5394570a3571ba02852fb4936a89f6330ee0f6660c8a29051a6cc0b630d5f94274f9b503bc51d6ada400bf0d2826f825157de4f6fcd55eb380625022d1cde503fd781c285cc036de20cd09cb5aee972bc39ec8b5ee1669c60275d1e0e7a18af960894a240b8670495a0d935e4fe8a456d2c25ecfdf9b34d972bc2b3b3a97e672c0ef158324033392cddcea79e07a8bdf53f75e792d6f640c157c0e6629f0b5bd7b3cb534d02085abc59d9a6c6e3f8005d61f382eb86121d839c8ed3801049d32a435ac89eb372f7c037163bfc6277873e7aabe9e7d57280e17e0cbf7010bae02737ba5782d79a22bc5f5259fad96d3a7313b1bb70151a3de13892258dea5960daba5feddbe9b434d631a283891597ea9aa0786ee7bc5f2dc45f691c384952301477a29f4deba7a3daf20d203f5358f6a49799385fad6ff0f2400fe1e2922d44442e235f201ee9aee96e131b59653187542c2ae1afed14bc67e5b30ed8aa47cfc6312431461bb7e296c026a1a41f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
