<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50ef25224b50deab46e5d6b34e6bb65094f4322c56f1cee6952761bf390e3bf2fa37b6a23401db7700cee6c095863826e328feac5aa942fd4c180d23eedcff689687c40002b4fa3c2850f1d5107c9040642305783b648d106584020415bdd8722d11a6028cddbc4b65624a1667ab962ae4ba352bb4c736260c0f50b8360183d59375b9bf72ece14b9d7bad1be8f267e1f9014eed89335d00436286821b062df01c5017ef4c8c7d83c994edb75e11a316021e5651410d3f7616de2e659445e8555bbba6d667d9a2211300b3703f00c20dbd853bcabd5abe38720e4194bd01525f0082fefa689c469c8fd6c9e41c8bb79b2a02836386af8177cdb056b6ec678328f04f9bb48f12d7ad541a532e73ca2345e465f8fb8c9c78b392ca019c243bc19281981342ea252091c4920051a950e69c86eb8b4c2eac1492fde69d81feb86c7c9ef4d4ce993f537893a5210935a24767fc456413f5b0303e0c7961bb3e5fce1ed4aabee8145b5d21dd2be7a154af942335f650d33405732f248e9db3582dadf1fef4c1d137915b2cd91e061ab663fc2429c16a0e456e1e247b3bf0d9b7ae5483c0c5c7eb3c796f769b3a3ef1b509c1f8b45eefded0b400de29618b381d87a9989d6d0167885c31f5588b2111959af45492ef4c2b3043638093d895df2af587552e1d38aeff1e0e1ce6327d24cdaa2b00fbd886d6bc803b6e894fbb1b9ac8344b0074ac187370813b95422c558e318eed4706e454340bebfdf300495b01fb07121ecad876dbd5392a84a582aeba9d7ec16f38bec75f9c4bb0c912707636ddd5b3ddd43369b704843a8e6f316874a15fa7125cac379358603e477b38cfeeff3e9d363a513014cda4259e10b586675754f48a38a2f75483a96f5d3140eeba2a4f4356dd54b9b8d99cf0a74d4a051571eaf927bbb61cd01e8b4038bce604932f45ab601b7b2110d996ae0b138f29682290ef2bab061c93b13d4fb4fc5c25615d1590d5448206f5f330ab588dd7e1894d330999948ea1f55b9c6ece8f418515e735c27fb7c8a4048045c6c6ae9a615c68951e752f21ac0de5dc60899985def7698b5d72158210cecfebacb0b8233729ef5c26f611518462054e08ca75fd8a6c144151fbbfb3453c5c65848e58f2bc78de4ebe8ad35a9d8756c6c48507ca4080bfe9201d70c9e35becac87bfbd0e2bce2cddddd8fca510d6550729c6749a6c203ef9f837b936d3a809cbebad67544addaa493bba360ad0941066e7d2d6a836fa840c8dbc7013ab70147646d5a37792e2a773fa0bc9272eab89827a98befba9cd7c96f947c467c040631e46dde55f06a1897f84fa108f49f38aa495ceaef5d41425d714a081266cc342d71b5a0a4944f4ea749712b6cf2e80f0990378b6c431ac4040a796e0211c67ee365095cc95ec9cdc89dca1a9bf61fdfb91ef07109296e85337efa0e863a672408a151c2f5f242bfebfee9291b07d80f5c60e42b8e9180aeac06e9704e6ae91b9c6fb08cf713f926c43d15bb75b86a7354355d696ca026812b172260231cc19b90d6e85c03cb70333b280836ac9eed1e6ce0ebb15ea19f7f1a149ab5b0f657b84faed7d3669bdf1aa275e9c6760674d4b933677e4f4ee087c28daaa36e9cae63c80f9ee729f2669d13088ae71e43e1c60731b007dc9ef6d139e76c7cc69b13be133999c8cc26472c5c32734e5f720e1bcd3ef26f523dae63d760b827e363692789d0e26576ccaa409eb5986bb16fe16ea0a14c84057b8a85ce1351de9b5855b9b4f2f3addedaa6d169c85346ff420ed3eb883d7e0c0d364912f53355fe3127a209364d5e3470674c72246dc222165dbd45b7e7c579d3285f1a3ee6437c394ccf4096c820435d05338faf6f65bf0fcc1e7582f20601ad5fe6acc7ff86ed6d200ed75e8fd0a61b7fcd6dcad88e94cb5542aca7a4de12d2195dfd042871c1238c0db536f21106f6cf864a855dbd9f644fa95296fa0c1565165a8c08be7a29ee6e64f0717974dd7e69f94e6232492501c636e741c9a9f2740e5bbc6fbbd2f7170c41cf90316cf8fd07f0a1a48644a07284a76e92b4a93574be6940bd1ff4b6997d343df86f2c0b3f04557af03afdd5b5189ddf7b3ad3a24035e6cb0b992fced4c849a1768aeb0ae81b60d4417e9e4e22debfbfb1e466c85a69cb71f25a8e07f95d3e406b6c6129927ec438b6bc1fccaf20f06bcc4a74bfb3c9fd4a5d9bc41c9a8c6354a22a79efb0c106e318fe01965c0df8c407ed130e9e8b502c1de2acb27cd9b5e471c3425aed39c5b2fd023485f250600aa94564f7ba95fcf643a7a5f032be236791cd833aa5ec4d1e50e57b9eee1f11b1adba723da886ff31aa221a691fae17740eaddacf8c8538b118575686fc94cc509adc41f8ecab984fb7cebaa0737a45c340f3c1c56955fcb62e3353b27c90f9b2c5bb11a21cd035b6d72c13418d2968adbb8721ebcff1a5c4f2feab37ef27a8466acb6ea7d54287d8a4cfdbfd7cbd79b3f12731667afa0ae24075e9e60506ed0f0691d9edf1482f14f84fa6c31c18b7ad44be4aa974118c713a0a22ae368ebcd6b0749d14400f0d73cab4f2572040946b1d48e714d5289bf50ca1cf57de60bbaf90604ac3a1344295ba6bce08052b6a5b16868ae2da3988af0be4440751cf1e0a19b098483288f67353b0cc96c678006470552f07e1fb25e891836bf776fc96841b862b8c0626dec4d96a5bb5c293b6e49b23ac459603309759b4a53da42d4c58632ba89c14d6d2e1c6e676d303526630afadd8cae0723fff8f85bfd5a65e14b185684685baaa4b4d7a274192c7044159b84611460a424c758817ee5ec07ffd8de46f467b2a7605a06ae869236d7f2661eaf45a0485266df4529fa1317ec9e089316d7bdd4a2ff3bb3e3ca1faa732de3305aa38e0ea2f7784e990b5ef8f4129344a550ebad2db67bf4138bdd7f685132176d1eb8e50fcdbd6f72b163f372de0a0ede9c1a969dcf1100bbf10e9ab7eeb028bd0c7dbb122a93185d276726eb15b654de2a656a94034bf5fcefa034e21f07a224372790473d6bbb1ddcf964c79a5fb3757516ffcfabed7ad361dbd297f9005659cd01277aa27d11ec329ff45763f2c8b8602308120cccb918d1101891fa1fb59fa53658f01c9868a4126cda642239fa39c9a9b4e472f1faf7636442970158da2920261bb523ac91d6caa474a8fe2731f5aa3b9f70fe2f5b2e66f6db2d438e0a30358b95c53602a28fd40f86e7f2fc38998cdd0901e153e42e752e8ca975c20b09e399e1b342c9923f05de36a11ee93217866b438a9f3dffedebae51339cbb67acc7e80a7c3d3542da8edc5157cf78e648a808f85b9e34c51640ccbf06633864cef3897d265bea3908c901247b3585b493dd56a2912e526aa3777053a7bb811290308e19688c4995d9ed6e43c668c0ec4311c79e48dae5bc8feb103b12537f8fc522b8e85aa687471d364c3fa90b316c04edcc8c7be8c702c938a733b3a777d69827da2a344799c92be457255b899655d5568b46e357a4b85dbc86d67a5a1dfc21dc049c92186ee17d56082923ef0942f9dc773dafd7a2c2e612749c52623fe288b3a5df210ea75c69e3ad3ca0806fed7960619209ca4d47d14839cacadcdca5ccb8cabd5ff9be537c70b1026c2f9ea0c9154f4c5479157ce756b1e6098527ebd6ce2296fba030f30898bdf1e0e6682d333930a39a2f00e898ae40b75334dbf3a4e7fe848e8284154b4bd4a739529ca1712efde59236757913844cdd593e6cba4fb6dd081635a059d26cb9193f1877486d7dc1ab2d85fa3a1fd3f63e51d9aa5cfb7eaa2c9c506dbbafc280f1fe0c7a53f31c377e803408fa7cdf36c684babae19568464445f90c6428bbc0458f5c752c4f153e4bf406a895a1b0ceb70beb1208658003ee8ca4eb3ef0b1ee68425e589a0e6e935b0ba02f184c70b36fa00e1876a44ae4d99f0e962bfa3058641e4284cd92e49de3286214929782297248d5b30cf774c8c3cfdeb1a45f0e684a5e23227f8189370137c58c5636e5b92192e174099bd4e41563fa8603b1c8e53f31c80b667447acbc4418af7bef67c812f691b5e3d9d82416c86ba33637b4fe1bc7126ffac0af8234ec4e258aca6ceec9c419aacdbcb07a49356242bd0bee65c056bf38e5efc97298f2bb0c4a5eff1996f1136734a326557e8340ef613f5c484e17090e9b80f99456ea6deedfdda03172909f4e5388b2e6e3e29ae9f7a2a8c9073850235f97559f93034912490f719a92deec21c7450a070551d677783568e4e74d2aab163c9ec111aafed71bec87119c25d81282664bc2b72740bf67ca607f9dd2e46b3819217e6f282a19dc88c3ac0cf05b4d3fe6c3ee487e0d89ed07320ede3b012e3e60b94c9ca5bab316dad6bb7c33e142913f7b1b3b66e0164ed15aa7e201cd695a7c3efed08dacca2f44615809b3239cec74c82864afd399dac9774ff2d56edbc9da84ca1721d4f17cafdd85bbf3d2e5a694a12066b90ef2d87984157d1c8200296a0d50617c23b9e101a51fbecc79b3952745f2829cefd01d13ffc26e5deea58b4bfc023653ecc1f90d6a86b96eee35014cf6b10167472782fb24ec8df28fd0cbec101f57e9258e57cc64db79bbed45b5f1ecdafe79c8f08f77bf9a6e00d1a8e7f0569aef751df620aa75dcf0b1955b55c818884cd5129f1cb8a3ee04b5e5d7a30f1df4e1197d60c2c9515ee3e4461e134d2c1c644dccdb03ae45e7d99d2295f0efeecc3febb244af3e8d2a8ecf88c857e49a2f97092bab25c04c1cfea4aedfa55a5957bc2b77a3d3e471f12b8020cd3d4c5c8572bfb240914d99cca7796bd8356d7645d50ed1a00f892c2eb55da5b94163b1efab41801a0cd90dbd01878abba8ad84215b8524043f3cfc37812fd9a688bb628c12e6358da9bdf08e9844a2bdfdfe9ea1ffb90f91ec4e7e96e5b16dc233bac00f3c16624029f013bd3fe233e6a4fb6845efdf02db993a5a1bd49f6c94a5f5c4f2275276aafa386d4b153430950fa707f6daba032f2b7c801a25966df9725f53760ccc0236fdf485e03d2b9d4225508d26ebb6dc46f51786c74606ae3b040c89252e8887cfcb45ce3106fab32c4b00313071baad2a4946e532dd4acb0edd34ed915b35d69e6e94b2828075b2cd92f5071882408d64512e0c6bc25b515d4611e63dd74f132d953143aeadaa492b32f446ab13e556818b7d56fe69457e8e0a80a27729c7e923e8f06e58d19c854c84bba9d7cfe64d3a4c9c96c0149a586cf77fec1721053ca89e1cca68416cac66cf7cfdcf8b174b49ec5077550c0099bd06cccf297a9acc524a05ae2a6771e44bc72ffc303c2faef52c3aebcd548150c26debf5c3a7ca6337b2e3edf15ab1baef7f9c49e553eb24e72a56784fde907b8815d30489ad5225ba1ffd4227684c21eb6c5c4a9ba08f998883a3f746cd87e479327a316cd8de17ddec00d3e9850404a5e41e4078c70fc0f52f020e28ca6348eb2957ce40f5ec4b54997a32ec1e0331469457e56a483afce156826336bd80ecb9f81016f7de16d7da2b5bf3ce87309aef31d607376140c6f2d40bea118ec58794e870072bf63cb988b0424b493a2cba64b4bd600000538c7c65ba1a208cf2b36bd436cfb0433136aeb7fd8a6c1b012530a12b0d529bea323b2ca1c714ea745a10923195f0e9394ee560c3fc9b9a2d0c4b121776319fd21409f0bed0374e12270b1ae6af204449600d12b01c7eaf28292fda1ec93acbf4523ed95f78adfc71f08fc07edeb03d2613665f1486efb1e4dcc50b55a9eebdc18913f8ce957d11f00b1ccfd0ceb7eb5c1ea561ab18bbe94e149c04c92b844083ac9f0d163ea3c4417678b68046e5ca19a3d82abd23099f9bb5cf7fa1d13284f62876247e88b63a16f0c99536d52598a88e5771f82bb4f780ea50d7251705e4898a33474a0398c51a93b50e02b4c4d703309a3347ac11cbb2b74b582d56169db586997529cf42f9b03b989d6188195aafc8529cfa7d5581672b4ab400114397a2abe20bbc9f1e892e86388bc326485052db7d5ef27cabe36d8eac1240e4cc4728eafd9e56e8dbf74bda92b99cc4b081000c431e39078cf0f781ec7b33fe4f1f6ff0beb7b57c3aabbdecd9b0ab807db2a62ea2596f348d0b0b22baa5c22afbc069792b2ce420f5825fa2c9a5ae2478e856583e7a4322b7bc2aba62b2d193819b09d97e06bfddcf531eeebd87966f8cdf26dbe8f48da0c838765240aea62c55ba442927537499df045c0df9006de85d5da7bb52921cc67b009f2cfaad3ac4021090eec5f7ab5d3f3738d1623b237b4f03b9267d0d1b04eb314deb58663b17380e09c02dea170fe2809104115e036a9ba6612f27e4683c5e3c5361a33fc27c669e51df5690360127e7fcf7659b2fe5c106bd6025a04bc914127d0f0a377d0b32e6982d2f857ef79db9c0f147f92221b35b119f68768d18ec538d5dd3997ec54cf7046ad7c46007c6d1bdaa809f4bdebb42d1c426a81b43384311683e17fa3374811b87ad16ed678b0549c095c6d3a48b58b9a791aa9f2bf5cf3a83baac26860cb3c1cff5852e5a39d46efcb8f912f6da42a709dc98a1d9dac7daf5c4c6ce25f047737c4bf923cfb9fc9fd99909af2d300c8225605b261012b0d19db3b4c22b8e23c5c353d5320e5e2a7e6dd26cdbed951f3fd3b7dcb0978d4d509f9aed8a5c3ddfd3e663564acee367482cd2cdf6268f127e6fa68c4bc6850576485df281c693bef3661e8e0b1ebf0ef9f96124fbc48920fd886f9d0aeceebfcb8c7a4e57e23c002c229182ead7f74fb20f543bfa7ff5d316f79643fc22c6d8d33e6efc669939582b8ab48d1a69a34e87e327d12cd768cb16b5f2fb9dc6fda15517f94dac725a1361ae534bfbc2634196c111375fbad5318b5fb43d9490df72bbaa5899ce7cf5e77c62c280da25797dad0e0746283b508dd949406414c96fb346c577d7e064d47317650e5a5eb3ee8f198cef687d2114e274d7f1a5661ab51697b33e4f3013639e27035aa76dd5beea35f4e49fbea53abcb185dc039ab3068143d4017d65ea15f2327e5984a161a7c695f05724c7ca9722d4fff8f58888ae05565bfc615b4d9f4774925ae3f364f9b63679ebc7a0fc738fb45c57458cb6ccb898d8119a4b4654a8796f3ab9c31863f6617e59d64d6845243bf79dbc44754da222365cf21c43f0ce5905b1da97ec695def30c7d11021ca128de0bd3a122e02ed09941e60a71e7264ca461fa8ed8ef900e3eaa305c5a957aa056bda8028116cbe093048f7269febbcd14a19d3ee4a2de3b803a429d59236df103d7745f1bd8a13bab9b48f47bec1bfb096840c6ae424d74cd9a8fe312cefb76015972aa4c84b6a993a31b31a62d6456fa1fcc4faaf8010c5e3e973bb35605352a1946da037d5033b477769ef2bfbd2f36a3b3bab164122ed6d52c8b3afc80e01e624042f89b0de9b8f35919e4d6107bd2b8807c3fd101e609c2491ae3dc593bbcb9c69f4f6ae554c26f4d2e424a7a80cb6c1b1974fc329c8fdeb6a19da19f18320d6df749a6868341b202734cb8a213fd0df4806a489884835afa17c238d177e726e9732b2a2bbd4bbf5e025057aa71c7f59fe5fdabea4900c0288997f9ebd03918bb663acca7fc2bba8bd13a8126da8c09fbea2e17c355ac7afac253b4beca98c7788873e317a45d2374e52f353187c5cbd872ea5ef06aac451fa7b4f4aa218ae199fbafed88cce96bf0a095671beb39b92a748b8476eca80a88d615c787ba3d6c69232bcea2de4e55e54db1b92db3734a194125c13a1754b850a1d559b80464c0dd04496d279ada45cfc3e3178ef13401033e693a2a648738a812afcee109f588fa668060d58500676021332bcc97bf50e3ed6761b109ed634e3aa840ca3d623a1bfacfc341d30496d0bb92e80df911e5e285c862a8c2b95764b7e24a4beb8876ffc509b389de7bd2b6eb74070e976272c7d4ef1b69880c52cdb39f89abebb0b2a13fd4d5950b86e17376b23717b30ce39dae877f0638ff31db5554a0ef1000f2e1132efaac5860511c0d1e15a90a56347df8eab9aa1cbc09581b1948e16f2c41631f86e305e7ce535fdb999810b800b53d367dfc15dc376a01cf877dd7e3d79632632376e55717d518e818a6d4f092789dcab1b2ec8ed5884c067bc8b36417e24e2bb28ea10f4ced0a4c6e78d2f5f13615e2bd895072c36125479da825265cb83983f97c0e638d8e58d6b1323a7c671fa708ccb1418fae0595548125f696cca1f7dad71f2b769095e3e2c32562716217df1d3b30d736a700773ed2c0124111b77db1903590627cb7292c7973f396af30c813fb6d31a88bed14262bacbc52e67a1b41bc4ed30f21e991d9f2e1d5cabdd3e6f9a2593c359e3e2d2b74fedce369cab4b5ac8f42287344a36d12e2fe7fd50ae98219197f39d59f769d5842a1bbb66d0b471e6b83a142b6cf45a810bea1aef42b9da3d80eb1004ef932a9ec29366b93ed645803b57846c0c35def7d72fcdd33832fa01c9ed69190bebfe2363cbcf1f795d5bfbd163d768e8939fe5968d628cfb42276161878695f4f23828924aa2ee89f98e366d10cad52153e3b38d2abd5f6ca63cb6788a1d3f043244a3e5611b0750a560ce048e0df17cd8042e9a0d4e9e5b266d9861429b87ce6c14f40450b4c2448ce523270ce66d6d98a027b75bb6bc17e64811fee24cf7a7c3a0ebd4517a97f40fe74c5a538838b034b95060a8ec91357df7e787381a0d4041f9ac44b2a96f7dd9b5988c5155b1330833c77ee7c27a5afba95cb44f3f289d5245598ffd15317d92786654da283084270d6018b7b0dc40bde1e86e4fb3fcf87f3c8511fdb3094a9319ec11ea28e59b73c914d85eb2c8e0ac2ad604a152491ce400f88388cf25cd81bbd4157ebedd98e893520a67fe20987a807c3147e640bc0ed24997fd3cd3eb7ddef094b74918364a993322926f18862603dd3b1553a321c1f9ae2aeaf17d8d259e4ee2082c86b203fd5998562e2b49f0aaf46855ae10d196fab39f0c6d595e07ba81246615684b2e16fd9b701a1d00375c2063b9162ddf8a77ce719f918566f11c4cded383327955387b16732e889cac5651d1ec16bf26ffbd26881502d2e39b5e3410becc9a1494df6fca3e8b117edc33d3bc5b9e6b6ea25e244120617ccf53c4b818a5d7c203fd22edf543501a843941dfe1ecfd78857ad0b783f1b00b5087d28b27403f421e06ef4478ac35cf206046afdb4cf3401d78dfc2e04c1bc2f2440554a2f03c36d45008fede901c47a564dbc7b467a310109fd5d21e77f6e05f310bc1f317fe643a43451a5ab8629647af07063355545e42bba04540295e7c6bb28459c82b1dd4b45277ec26b8d10e3df86c1728e48f52e295479b785ca8649112ab70858bbab004083294ef788cf924fce91e389fca9a304df6cb0fe2de4c6e3d4d9eb290b8d0ba485dbaa24a97dd9758888a48326f10487bfa49e4a9b1a53806f4889c58db4ddc97f2a7e8a453818da8419be9ef42945754005313f750de3d2508ba8f4a22be54724ab37ab658b5053875670062fea04c9fde7afd4d0fb6a4e64501c61c2b2723246441534bf94aa64ccda1bebf66f7ed7f8456a28b2ca4a749ad1cdd97cdd2bc8da24c4eb57d93da50ca48c56c90aba91f12ce1302460ff909a9dc1c70daef1c7652788bc4f58a7a6427a9a73b69549ee3eda8087344f196335ad2a4f1a625466aff20729c7f051008666eef2569bbed3d7af0a0b2fa5d2d1ced94800448b5a5b16be9d0fabdf997d6fef7a9322f2c8e947d5524e1d7cc184fef2ed2e78540194fb44cb2c150c087e0ea60f05b3ba1e3d61279002328e9aeef795995c6cf62dcd51badd2dba4aaca5feb76062a45679291fe18edca18524f4dcbd5adab1c9ebf46dc63ca78c9de3612c7f0cead3523354f7ce84cf5aa2729d5f6eadef2814ba295b70e7eaa161bcdb39357561c9fd7692892960eacc62285dc6f54419fe4ed7774f344639bcfefed2271f7e76e797c8a6f13203f4c42bb3e7e31e490464a65accbb4956f384cf71487a0e8b0759582d9f15d8edd1db98441045d97bbd5cfc6b6ad455ff8915d119006f764b6d42f50900736819bfb35d82d35f5581857aa46237b646f38f535977ba5b1e18a15bb7dac39a6be5b1969218763659586623261044ace8db5f2cb3e186441aa5330785eeeda87a7dd663f81fff983c5a87ba964926a1ead534f55eaba8394674d04cb1095d473e2f29f2b36fa75e8388d4a80c01d82fdf0981534da1dc6763aa870394abde0e01ae816e43fd79d7c794e38b4c70d8892f82cf624265df9ad15990cec9d2cc06021aab766a19f6cdfac1e1555f31f8754e5eadbe54b8fa63d31d905fcf605280f0f73d322aa66738572acf0c7bfa9d02ba7cc65b9456b444113af843ba00963e25eea498b7aa8e02ce4d64b8ca6e54fb5892c4a7bd02abf42b3a3b1d1cbeecda69f690b49a41b40edc4cb8a71f938bec4efb9d874fd648d8c5246d13006a82331cc7ac8004f6838ae5c488d4ed1d58d631af83ecaed43971b3b345480bf67a3f0b4c154545a89a7e99387766c04841f15e5555ddacdea5fc59a213658118f62aca8f61d2fdcff077a79c8edf625c632066f9424192dc30ad4b4c30289b36dcf53b1be0cff0b89a526d152acab423d4f5c1243bc53ddd13db9ec79ab243e9fa131d849f16e39379dcb98314242ff8e0a782fd2e23ea4749cd72490d39d994a5686b774ab47ead54cbfc91b4af83c8f6af3be93e9cdc78c02896a26182ef30804dcee2c037af833aa02816f220c9a856b1bfaf297f145354019f4d48c55201ad404c3652eb8db84d13109578b52eba29255971b44aebef39109f7dae76d6be4c36248e341f07ecb343fb5261c1a08ac72223f0330840b6790a1828b8ca6ce00e48cba2251b66565c8f21a2e848f4d91a39f8afe59a971794aa08e837ed69c00160ef52a812bf24157a08dd43e52c4021591b375d43fc5b2a5551e29be6379a5e55e56aefbbedc95b1a2e6246250467e24f7cca5a54e4af53f5ec5b052ca86605c4f5827f3da9b0a23c194b2aa51c5f0a7cea99bf4deff6ea1ce5d07c3d1c10a6e30a5fc71f046a3eea6ac7de0b4d8da25d79b956a11cc8502e223a6c4b3dbce6e7b4d17d5abaec1513d308bb6ea5cc3af901cdb20f83f18df9541a196e74c03766ecf39b7356bee1a8b516840d00b51bd22459ebe97e9d63e1993b3f1f5f853e5ccaa3ece3898543964b4834d25ea0950ad9281d5db2512c781215c54aca2982679b9f4f121ea9a443879de1bcb8c89d5600f2f778dfa7f83657022f743d39d73010ba1b1ae10a6c63632e0133f662d2657ea22bafeeb06d7e9eb357a75778d2567d50ffa77d516d624cbed1a3e254665e60f3f8a68828eb6c80fe65d4de75f4b3bce9e60d2664688d5fdd350399105e7031d3f37ccf067a62d997afd8311b961e523f5361179c49ed13b61f50fe84071504a64c597cdac54a5880eaf2bfd236940072c33f7dce85a9c0ddc31bc8f7222e0a1df57eb27ffa332dc8467610a0d14d3347896e5c6238c33251264664e7077298c0de61d3dcf30007b9bdf9c9edd34eed0240811ddb7314417c5fb530fc644470ca7a9e5dbca307bfbe2d5cc1a2b46391ec1b7d43dba0a91c13a64954ec760a6ab8c68551f26dec92ca996adaf711bbac044250564992d5acd9b209a34941a5646b7b71ba7b94981a457919caee5acff2a39c0f86d8741b63564db086326f4d69b0c67b39444259835c3366f8073ffd014c77988a774348dd601553648d3152427662afb2f89352dc89b24415b5202251294f0f8396fc37c3765c70532b018cc00dd254bad8cc404838d2d9b607f6dcdf03569d4a566d2d1f139f99f7a149b16fae05805e81f337cc0bfe9fcd33892f78c3d35b5fe882cd2199668d10bd76709cf7f8ea12a8cbcaeb28edd747cceeacbea3ec25171332699c02bb6092f00c042bdd27ee8550891c263c2c2f845310f91dea9d59e514c2b4c5896fc9cf57a0ecf3fcb3a7efe885484a43d634e89d101b18513ff9d36479347c2d1a2a37e9bef05adb9f2cc2e4cf40f9ec230665a32f6ff0f065d7527a0b549793f90466d99c3e3dfdaea8613df05dd8f113830a5524e9d97b7e15038c84ad243808966ceb7154c5ec9eec77b3b1115281cedab4d5bb15fc7453360d8f810995049e7f893ca40a2d902d1fa836b2faabcd44208d6a1e3ffe12b2e9f5e426df12a305e6e21eff3a28ae6c29f1c77087b99a738652cdb05650cea7c8c3da46f9826a14f12245edd976a2745bdca104e433ec365de45287d30acd870d7fd73e2089c68209c416f1ce33ed05554b44fbf5df3f788b09410ed3c42ad1449900bbd4ab24029813be293574214376f2bc0b8360d5ae025775fd9585cc9a05e9bc6f64297b8065103dc0505ac6902edd4be1d2f5f247f3267880f8c0e2338a1de8d9aca58739ef6e9514839b720071716a7094233aa4850aba4276eb06ee63b6388290b712f14882232abc50b284be134460fa4e9e67ac724f273965680b6a9d2424c588ec3444e399702d5e745c60b5d6aa99c99fd6fc94727e6745c8db9c673edbe8c0cdd135446966cfad0c8064ce1d520c3c748f2a218589e0ea0d4d30697db26ea66349de8393cd4853bad248c39bc928a3c9026830e7c29d224ea0c796a787eab02e770e791d28e83e0167a0c701cce159fe508b095bcaf8526d0d433a5c3797f7a6cc42dde86a4ccce25b18fb94116b6d1e7aaecaf3b0afd64d8d5d937d71356d54878c951fdd1733e470fb678ecdc8bd1f58d839367b23259bf4188c5cd2727497e77ccd2b95524cbc5f229573b9df3eec954449a57f67b2a7177a49412332559faa2ebd08b7bdcfd95d64eaae79e0853f86f577116b0e7601fbacaa83be1b4aa070c8dc84099572ef73708b43f5baf525ff1f94ae0c31f3ecb6779a4ad071698d43d86a9bfc22fa35458c09ce413d66c786dec9680bcd1f63d42270466024425d00668a97d28115a5c5e67636d46cff3ad40f63811abbccc9b0ba9369c51fddb362103bc588d6a9f5aa0da129b595cfe22b3d9a5d0e5f7bf3a2252d720e6eb8669836292d6af4dabb50b7e6ef950a3b2223b6e05c509b6b4f893395370b58ba2af7dc00e06eb54dcc02cb9f94b3739c99bfb336a2dea7904fc3bca24dda57a0f8ed69f62711a9bb6b90be7f7bb192f738552d808449c0ad6fb57f9d1dce08042c204337b4bbf97b40390c3291f7af248d1180e33e44d29a2d4e015d5b196f5333c5b6f273ac1cce6a4256108fd0198d844b61538c5d2a5cd27be8854d57bcdff3fa6fc3e4da8f1f8def5a124e3b071144810b60262cb49eda890763ddc924c491b31b2f7b4a2df0b49fed190027fb41122406e3177baffedf6d7a5610ff958ba52e029a990ad7b67f2acffc1f0b32ce4002f8907a565ced4a52e37c212e60457bde5e162df8d93559a34173fb69d43e4899bc9a0e9d4bcd56255b3a302faf5252e09d0298374b72f49ab11ef223cde84ccad4e623d82900e01b1e67cd01b087925d338b20de911299ce683810a784eb689beb9a1c32818bb21760a5a485cc63ebd401f1248cdb3cfc6b973d825f7d8887bc8db489152c2c78c46e92821fa51ca25a3dc542703aea8f7f37f5923e57a4c5d1e0cb614b086b944b4ef8bbba128913ba1301251a8b6fc82a67ccf6208a7e8073eb79e1c87d749c232b60a406a231a11385b5afcb19811f402105e18575fad5bc913401324b759dd3b458a27f0c8609d790d21bf9b04394db4d4365a64c719dcd1cb162060c867b5bf65b35120f6dd4dc6321a374c991be1fe91370e69ec34c52eb4e2adb53b45d031ebae67ac5fa9c406cd5f7a96bf354ce69a7c1f1ea4a25c3f2a77534cf3108b8c8f2369bb69e27e05c4b97460dd8215674cab82734ed80a4d71d787e3486994b4f636a3a4ed119043aa3b11098287aed83948cf47abe441e4d8df72bd44356d8dd577407afe4f53f4ddf748655413094887919d7ef411f70d172964eafe6d2bcfd48c2250d162dd973a8ee270cf788e7a0920e97e6c4c89527cc6e995478938ca9474707ef5d44c23eb90fa590daf233b0371a15ae1eaf2adc5f3b8eca569ca4ab6185c68ba59b1b8e8cf3c581c207a3ca8f19acd9d7a91ecf8fdb15234723b347834f104edbb6c925965f94f1bdb9a07355f42edb8ac8a316b6d1d3f3ea3bcdad53ca40a9bd571b24e4029ef278c872bb63362116415252233a05e104c4e6cd1ea0fb858bb2fa41708683e241c421f787d4086371a8ce18fedad9453ccf66dee87d668711c7030d4ae011f797bd64d821dcfb41540b913a8752f010dffc0488a3975a03f4957b29aa3ba33e23005ccb61a2c8e762c70c6983fed4c19b49740bf8fd3d67c0b2e7b6ecbae3c9911adc83320162476a38b26f6952c844ef113a625188a07be996514da44761e059170f44d6c273a3128b92d4da87285d0ca62b28c54cc7da68986d5cd79bb897bad79ae29d886a844c199af4eb12dd3c72c5822088d4b37760caf80d4d2c9b994d1922e7aef804a68af97d231aae59736992879f2a3175efabe58a4e2d69519ba8442bbda4902ef673e1840aceb9a563b4ee02b4bb67b69a3026df3ceae46ae950b1f19615c4e247a3132dab18f5c923b265d7879ba6037cd80429a9922a86229c71bf4718d97972085acde1631115b25704f790d4daf23a38641c85dc46bdc11571d6f291ad5e32b727f28654cf6a326e674e284fb3171adc46f52f1ea501d5a9a34de3d290eade65271ee4aea0db8f8813104a0b118583d920fa0570c901cce5128c1d6d4549d475feb251c06b046f3e523bfb41062a012ad1a7a415d93acec4c790af34cb9b22e08c840eca0d6eb84b82c12e8c109d9ad480f96c624f73968a246b0720879015a5bcb9b649f6de40f62f36156ccdee4dcea3819c0aae97a7bc825463c914585bb0bed35c9308952f6dbe1288d9f857b1ff98a07b0ccf97f8a523ea9b995e08ed55127bfa2a446e5e1413c6f980425accf2e1ff55d90355a3b0dd6e5e6e42983ba7663b77a36c02f49189498fcb8b245d54f1e184f742d3f7e65234ffc4914d7e76e86b9c4d7505c423edf30dc5f4eb6840b9ce51bf38cb3d676a121fad71993a8b843f31126e97a59a4e1b3686775fb6b5667fe16f719b1f9249f3d70a502c10aac6c282d4f870d497de2eb7048ebcc432af47738d0eca193d1c9cc0d5cd4324cf9fa01f73fc7e7c36fe4fb490d5081f408b529bc88bb6d1980a6f709292bc8d2347b84b160f75824554eb70a36c0dad0302279ceec593f0f39cad52337851009f203d912088792ce8e86b5f19bd839aa32e5fe0587ddb3a6e8bf473551715f8457036b903ed1da95c35468d124fb0a38213a3d6b41d30a3c9c8760c11bd9ba7d33752c1042359a70061330b7ef5ecef23b2bf32373666f575dba061606421553c2aaaf093242e52bbb3ba34857bd3de5e2a5e93b927a68c388c78ed77e8a7bca02b92d2134abdff3134dc3f09797af6678f5ea450f9eb7705b9256b0b28225d493b413e4ae407f4513d4e35696fd5c1236ee5ebcec0332b11b8325571d1d660c894e2f34b4b6233c2ff0f24d7cb82d36d8b810db6f0e52e25525fd1edda265a2d8e0a9c936f0011e9c5757ab7c045bbb8e65005df5c92792e93759384fb0924757af8e5a2b6d7b922b7d09c17636c271b3af56c7929f7f89197c1a28b8a3985e3ba8af5fa89d2e5a89382904239a7ea2d64ae784af3e90094cb4122bf48f9fcdf34c5fdbdfe0b4306be8926d9e9f3d9c17332921ca7f62bdfc5d34e707c543a6e7faac8191800eec12d15e075ca92a6cf8b7cbf6243445c9bf28d64e810d113ec829cf2a81ab0b47c4737dbfa4483f1cef4f618f3c9f203d89099f731b3a7ae04792034a26b78526229c22a65904109e6a818b43e9c022c57f5a112c176eb1ddaeb990f3c7690c4e7446baa95b132f4c3fe1b1b8b014576efd2e7c828f72a209bc51ef4d87f65788d16f62e5f17e1945ec96d6f235140a1cc4cabd2f234c4099fc60dd950d9897f4eb2aeef032f3f86753d0c67fb7ebaeb3fc7718e8abd848f8615954d937c50db1834b7e7fee8241ac0c26f84b6aa59639e75af5a91e1d71b56816808b3b43b6c384716c28ab33cc365e872ac6001034124d58a02bd660f54b3f923052afad103a1df18dd1889b6dde490b564d74236d758be7d8c40f018de52348a6be6a151ab3b737b7bd234cbb229b95853ea35bcfc95cfac19619dca6ce059d1d6847711aa93f04d08f6a64413a98a9badefd7effb1f63e1780202596d124991a44c7a4d0d7c5f8e29411a5ebb3217aff0ef17f43db98c60de689cfa00a8ffd116efd9e1a8b2864a758cfc2b85f9c4bd734ae99a6c597915fc2674c9419d5d210eb9f07f3b5112f8cf425e1d42cd7381555b18287d8c053fe560087f0df7708be8e3fbe0a5780a2802ecccb53d3a6e037470cb9ed4bb201d830fd4effd86b67c2d940c8af6084e68664ba286ea3a5ef58ae95880c6cf01a92ad5c9e5cdbf531458b5e93769476c8b90ab72df54d6425c561e662b344aab1847e7e5b278679e638ee68ee632f91977fd5aa369142dc32b423ab87a789e5cf35377368d6094244095f556fcf80ea792b1ad64813b465979203e33a996a1f5b72a8e6fd1010e88e1b40ec61d6bb714c401fd7c82d972e5b061bdc10f5f8d06b87d274040d41c1663226b89a13eb7b6659707478088b10ebb2f23ec91e290fa779fe2dc7de872f044967ecc6564441bfd969ab35cba841fa1dab62b48860e7c5a998973ec4bd07ee7032410236d31114c557728ba19ce56d7e85fd67e479284b566596b376b70e65c0827267b4320af4c51fbf92dfbee8cb87089bff863742a875b89afc26a979f1bf0783ef5f82e1d0ff831aa919d159fa4d04534a7b2523c5f1ef0bf7972e9a142eb3d5dda2a72f8315dd3877cb0798b08766ee3c8e160a04cb47fd24b7652d6fad37f64f1cfe79b8bdb28c2d6e9d7e2852a179a3a25451812f795488d735ca834f19106c4bf4e79c5f5ad7a94a8e6d9f511f5d19f84982ab9b64c1bdd9e64fd16d9b9aaeb29c273559163a31587c34f88bbbd2b431df74e5334f18a8bd8ec99779c218bee0fac3fd9a0cd542470fc5eba334257eff1679fb4e2f994013066d648a8f0dd9d96b2c9457c3d80bdc131315ebc894fd9df2a1e3ac351d411337d76936b6fffb47472c985976871f3030459ea01065f671f981ce8fdf2d75b6000274dc077b8b117e248db17aadab52c153c40dbc3fc79d5fc0a06b8249d2c7a931b9d1119ecb1dd1d7215c66e171e1c3fec8b1e34b5e64f6f2fc1efd41caddde89e5598e2a606b8d7cdaf3dc51741581c78c6607d62133cf2035a0f81cfedfb044d70a4a672971c26eedac2abd66f73249fc6c9be7d10cb5f17776099b97fafc93b17ee1ce45df3d0f0f63030b88d52f7e1012e5cbec10252b0182b960e48423bacfbb0f045c13b789fb17f739c1c1f2167aae1fd05ff3291910676821489ea8b84bfd06a603cfd460a460bb3f51c0c0bc146e665f8c3dc8159521ea443d8503430cf983b59a9fdde01f6e8a8fe4b09615a04f38efad2f2a63af126c4dbdc217e409d152e7c61a938b35f66afd3b77e6beb26d068e20607519fb5c25e90f4be89d37b6b73b314e63017f386c0ba8ae9d293babc98eb04edb2dcc93500872dd85eb4fbefdd35116897d530422928afc186c5623e07d5fa936517d9e791bcfe5ffcab4064fe190cb882777b837d9f25362069c780e923a6c5a993a38d7ff41ead4ec3a8c4d320d8bd8b2111e7a0651cefb30469ccea16f5caa95aa95600182d44bb44f2dd82a58ed8d0d46ab05a3f22bb8a354e1761c9974f93184c79be1e646d862ad7737745f66694d7717ced0d6cbcf148e3dc8f5dc49f1b88d6856c79821682425d505a1e4a44afd63691ff41e545a5b8d9c13a90694fd64c90025db9de12f66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
