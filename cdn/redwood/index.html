<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6977fcb411944a4f62e6d68b41e480807fa65bdd7fb55d3134df6e9e08c26b964d9bc35d2c74410083e7817eee2125be671d8589a6cb42c3deb339ec593e529bcf3e997107155a3ee14c7b08b52043c26e3fc668dbc485f6b08fb360dd9d3bfe7da08ba593761491161bc516f124c88303c23c037b4b162c729e3dbf002dcb8fda501b3d8446aa56964cccb5af432d92be07e947124dccb958c925cb06a3e22436e0235162ffc57ba80134d893aa3853115ec4f2e3af6c2be8467036aea98f2ae8ed7c3eae17ce7d0ab07f7834c55a4686994cb7f696d096dfae1bdefba4132674dad22425470057f82492908e46ae647a83b881046604aaec151251fccd77ef053c986cfef907f697ac5c80420859c69261cc9d49565128579a13f44f0123093c5690b5d7dda3a3ebaf5c909e765c67e46e83e620b27239d675351b938d709c3ae1f63423f32e73b5d13beb74e2d031f0ddb069697d614cee0963d856661f38bb734c535560a2b2a67f2c1d1785e8113a3eb6bfb88f12495b7c5c11d36da935333f72782acd3149092f620f3a72d242a3aa54338e7707357da05461cb6d82dba335f6b8e027b32eb5d6f205ea212607d0c5b159d2fcfac016f757e93d7df59757a32e31c1c044037dd6f21954c824d551dcac83b29e16560d69d28420a10a702c3685baf1b436fb56d2235774d873bf8a4457b446815ec427400aac91639c176d866e68f6564cf1a0968419d62ddf3fc0e9a2a4a7354fb3d727a0fdffa3944ea44f1b34ac67abaa15f20ac3923183befda4134d1858f1e3f103476a6b101d3695056456964a75af9cb4eb8960c3c2110c369312cdba32803b1c1ab0463f8a5f145ab6a4f060dad2486e5d42dd880d362551d915108bdc7d446a87ae086cd928f2d0d5411682c3917d500733bafbf08ec85eb40abff3316261fbc2d528dd9f2f33e2aa7097668774f35e69c1ee718b5c4a35be702830170a841368d3cab6aef8c8bc8610e98b10224758afd86dc494ed4c85e94449fdb50a56889e01bed24eef1e3366e8a1a16c40ef7b38c09a87a5df5f68ac609eca2c61ddb22e0aeca6ff28f035a296f6b01016fd10d9b2b23acbe679f6580003fc2a08dcbebe9fa82dd62ce8a15feaf7735236b88f7a6c77c6203f541764c18ab6ba6272c4d021858c49b02659f772dbf5ffb43b29b94846d3fe61b8a4759781f7a57423a40177f6db8c0f25c849067b3a9832b1e14c4d61f84991ccfa11c2920a627474cfc5fe98388d74ce590719e422c59895d3e6b3a33d8e4189b06fee81f2b2b9792bd274e8a479de1920c0c4b6a728574f59885a01f2e9faff2b72f677f3853f71c7c7591b3431bd923799fe2ddf0beebe519ed478aff659664c82562881876fb3837c5a37aab97d5d3bc58afdb1f3d4bd046bd0bd7c03c64a1ee0d43e01135ee90d87dab546ff651ac657070e816a6b317f55c1b3282718cdcd2a304252b3678d736caaee52340a1c5d3956f7b3e70530cc57622e8682b03fa2e067744a91f61b1f66efc2897aea3f6ec64623666f12ef34421503c7581e027447fe8170aab1dfddb806a3e0bc2845e3f900c8b33eee0691fadbd6b7761b792144e1e4f8d9a9728798251981c5e65c86c2109d8d74bda05ad1dd7cec0476d25a8b360cbd17529abba634921d56d5d20d57e09a872e1441e6876b1f580937bd3191833fe4a9a21c3b012bca82184aba33143f8fd6596a052bbe4c3a1754cf2dd6070493c8c4a84cf3a12d1178540fb9adb9b74d102a1dc95078a0e9105a5d3960090abafd83801f54e83112af33c4fa1719bf7ed1406e49f7051823bbc6715031aea4b4ee2b8f6c909540628b88252a9cada451833223fe97f1cd6cea00587c04bdf3cfacf7a35be11dc66070b546768aeda95b274665199bf764f99e8e68c125efe89c96990100e9031962a862de9791fce002452ab506c3a930cce1604f4e4cca62eef37683b8dfceae06b98a7a26c69fd9dc028a2b7ee9cea4976f0ccc2f8efc0379c0030751820851693b87164fc71904d1650f6c10c25c692c1136644375ee8ad0eb35f53f4f4d454b94fe50d90ad5a7eb9ef2744dc9fc41378a6837464bf7a63403c9a8346f5fa73291c95847884a176ee1d967b646cd071c2556303df29ed617839c276d84bea45f2314bb8ded5f83c234ad083f54bc647db2ff2ae74e4bb8ee15590c2d79b12fe3c77a2f6943e63108e96c265dd4bf610f996f1368cbded614891aa782316c7d3819ca6fb71154ef0491a9133f1acdf81f798600e0db19afa648235d628b707309c71e24d6e596bd6cf49a2854700df8b19c0cab418978ef316926448b2e70e683e290c513c73907b28c7cbeef7c548c5020b413be369e42612aad3f44e43a7134da13fe60f410ea478833c923b0563e2ac4a00144efa55998a76943a4044f4ec934d354ae8ff0156561892a539f5e7d74ac08878ca0954088881f00980d577ede45cb227b60cebe02b51b48db94285937d1a1dbefa84d2dc8b1bacad4749e690822cf1101ace16c6825a13540b40058be3dcd36e6cecc2191b267d5ab5d4af2511d0d6d655de62c7cdfcb69618577da85b16553f507e01396024b7303f44541c22389fd70932e2122d8fd3a120b8338ddbc0b5e2a88d6d4931cb040dca433789458c977ab2ee0c4c41782ed2974716464e431866dde206eda4164f843f9237efa657bd681dcdcc55fdfc6b51fad5766ab5e0dfbf6d9cf2a8255c8d06d3ac7ee050211a337caa2ec8dcf9b295f6002182ca52c225efebee09b01651a5baae385f3047f5e86de2bc1750534df971f52291d1e8c25320b3cc6c69c2b01a19eed272775a0319efbf6fbd5d39b77fbda21c622fbd7f87a5d99a6ddac88df5ebc868fc02e211cdcfa8a058ab37e14ca84be859c6c5f2ddaedadb299a9ac0c366d13777f8982c2a846a25244e8e163410d5d1e49d86ad5261b839f83bacd6ada8d1ba34ca8cbab3c950d48abd5eb9e06c4753bfda837cfdd17ed489f3ec475d02b51d3bfd197ae4a6d3c2640d9d7d6ac872f8050a269d1dc1929a1e9a5511abbc9c109fdd26dfc88ef25dae6a96806653c948df9582f2902404a3a9f7c7949950077b1f68988b0b8601c384548dcfa79d83910edbd983a8d5a70e9c19f0d1993c8af441d7a792f2f84f353820210704ccb7cc44d8d3288f75239cca11fb03189dfa356941d2447f0a22ec00ad9bef211e10da785eb84c55dabc89964148373e57b5a1e26c0ea225031f0f1898c03c37e660b443426e38c347e197f73793c0f4adc20a4d2f2d49e8803b673dab7325d0b46d4ef024ac9e9385f253998e3dcc7a7d82a4a7a85ade726bd4f5dd75f34df7129d28068d23610a6ff3577efb6cb0a69c7c0bcaed4fcf8f35ed615c6206eef518d2a180653c2e06e4fe530b84959e20e202e4fd76619509807d16453aa0865784c2996eacc61fd3082de30b8dde6b646b12451541c88ed7a6477d7735d9da1828207c3f251b89df28e7ffd0e13173fc4631801a44a640a73cbe6947815e8861a83770a8d99133ceca2becf052cffeb3b1c0594cceabc9fa951c4a183a6bc1764e5bb918845f5442dc69777f01fca2babe70162aff970746393790975d383aee9d348194a132060d043d10035aa6c1a0af8a35f9539b57d4e32614e581d913fc661d5d6eb96c941ceca8ee011040a31e84ca4d860aa843be3097963b1412ff4b39bee67758dfe9a1e7935597046dd038ac9841b78faa5521743170cf832bfdeb0450519c379326e3b1b9a154391762ac63061c297821af3bbcec4614551a364c61ed9bbe19b5d6c56f73de3b6e18f258ffc7f0babb9be67b854885c527a8e5d4d057afb2dbaa74852435820482de3c289a4c5ba67369ad7d1a9b95fd2b91f38d637ea86ecb98bdd440f2eaea4c05a6531aea60c785d609f1908f7f5b96bb9bfc9859aff033d316ac6a0f236aadb1679f5a2ad032512edd86ba58d160c80b634f1d704b340c8c9a69a1c5b3a173d0916d3efdbd4c14211254141bb02187910646fccda427b958bb047b29597b09409dd836616531116a491a0dfec6abd9b5ab8736928193b9436e076e6f321086ac28e25b2e5f36ef72a95acbc77524e406363eef2fabde87da9c0539287440ba8fee1a4afb235a3ce1089aea945450aafd320ac2af9bdeb502c5ac2a2967a860c4fd166abd75a10f67edacb246a26e64774389ae44f99f7bef77eb2bb667f464404b5c7a6f02894d56ce3754fc0ede31df93e78a60b2fc3dc707f0cbc2acb0f42a4a136dcf738aa5aefb6650408dfd426a72bf73974d27c4123a1ef7fbc31dfd851cd84c6f00377af833f2f0f12fcd9b9730f2ab5a24e9b7fb0a66b50589ab06ac6a821126db145626b201de125334f98317136abf08649b8b2441388232495e27d36c324f731fff037576ca6fbe28b6e906e1e04d66e43e3fe127c2d12f364d25c646b2dc1b7027f33f0b563845fe5dd4392c0983800946abb7ed8381830f985556af280c98ca2069560f1f6d355df1384b1a26fe8ed0086cb98035d3af78d45a83638e8d83724967ea25d7eeffe462eb6ea169abb25d23e3150b0c68645a580ecaf5762c8b5f578443f383768936a2c2d5474879c3cd3218195d5806d9c315578b52920983e8fa041d22fc1359e9326e7739ece867b1fd8fb46bd9fab038caaa92d3deb94a06a291e92b32c7c0b05d834991c18a97e40cefbf80c2405facb85a618177bb4def35494e834e2be0a276c91b17b3ae2ba46f760be2a965ee74b2597336b9694efe1d714f86091282ceddd6f1ecdf30e42954d1bfa94f4128ca9fc64e61cbbdac9ebd353dd38c0a8b347d1c5567aac840bcc9cc0f99d8848bdbb2cc73f65c3195d27cdfe7a57f850e82a0d21e224eeaf11264c1b1ce470bfb83a44b8d681589469efd5e94a866cc7f2515caf5fd0e8f1b8bf87a14a0e1b6edd01c77c903093770c43764f02c288d8f65e11612792d3e6fc136de26589c80961cb613b3adf3617c7842cd778eb90de27368ab0b7ac493064d1aea613adbb326acc08643cf789383179d2d58627bd315858ab4eac8aec97c72be5be0ffaf4e49a3e1dea239441228552e8c401ec05e1836571a9f807c087aeb4da7f8a8a1f515b5e3b6a8b0d19a63e4242d6bbce4bf61f86d0543b5e623e3b0a8ef1c5721eee407b0cb4cda75a0b780d2aacd7aa8716c878a9c9d68d38f437c32115b7184022f58d8be7f38e177b6f8aa0f56d103b2d8f6a2db06bbb50779c622fa931a7fa2d67aac6e4d74ff1b597dec1fd6c091005257784035fd4a521e257997d225dc8a7f09b3cf345ca0f45bfa6ff616513828120e37c56e0c4f06ff4a8149b80a7de45c539d075505ad58d2e88c16f4201ded9b72d1bed227b305e8f5712eca457505e6bf0abcea081298f382fde83d8a1f3c19fa7b7886520ee77e7a059a1f97790a1d8ccefd6d14b0009f8f141933a1abda75fca09f612795759a107b60556fdb0bceb8351772074c41da3aa76c60beb79c473d60d29791ad63576c2523a434811902235d85e3c20b6f0c85259371c580b567a132f06e98a82886b1161ef66afc5ff2a572bc9a147a117ce4453ac1837e37eb6e9979de1dfd3ec88dddc929c7333844e9e796bf8ee6a4393d8ce5f324b7bf2e95037736e5a93d2974c1ed2dcf45aed86d560e656fe38e2559ab88b61f42af686b5e5b3b0e89b7fb7c21c4f9231b53b7d0b4770ba6b45b42e83ae5e2c4ff6d0cc3dd96cfc888e291b5e8f9cfe1454c1ebcc1ea1f167b7f933345cb197d22a1b8c592ddba0a5a8fa17df074b869ae045aa852611c7f54b44eeb5900c985d6154b3016b574bc58dd74c3f6d88b76a067bc42998854a08ffdff369748043cfddfcfffb1c3007bba6b9469d7ca180ea9a53322338f3c9db81b2b07f602c1573a824a391e3c255f86aa92f39323aa989a844e3e7281bee6b38d35764402011d2970ba90a2ecab72eed843ff0fccbae35dda558ccb30aa9a44b1ec5ef09e339724bfc0b451ca7f37861205e3f1805e217d093cb52e3543775ca0aafd35226ec1b7b6db3584a91595cafbe6c0554c6bdf0ac3d890fea555a1c93060497a53ca826d892a7bdf2873fc40790fd88bf1abf112a0600f711a11fb5b45adfeb54e5067c09d560374d7f04f64525169c726e3cd5141c8b96c324cd4b3356028f1f691f0988158f66418530a82c0d356e8d21508a0c124a07bbcfbf3ad6fbf5f1cfaba68eb92a6c908d4389ed5fe4775832a7a98dc021c551f2e44547c16e3793b90a3815ff02fec343385ba6d7137ac2b87fa67492f2c17aca6a08daa027e60d5ef412fd7376666ed724f66faac8885b27f854029b7c4ab6b228fa56ac1a3b7bd9c235b74595d91188a238c8fe048a1bd657fd1b63986ace599b2ac58279c6e92f4e5d492147e2554f1d53ca490f1ea4c43721e1f9580890570fb6eef9f24810ed26c54f70de289343feece11937cf3d722920c173b894090df84e2d8d3280ba18949b8d63e3f0ab233da0b7e9bd3a40859a5ad32c7c4100ec55225ad1d351a35a0a597a0d1c91c284d1971ba9f2c9372f86a0c3fd027ab9a1ab682165e310944eb81452421ab61e5ffd74bd80fd2314ea6dba3f9636d4d6796b01b9cc4b9e0cf423e50f65aebb7894379a22a95f32ef002a6f0750b799fdefa891296370a84d303b8f15c3591a05dab3cd05f000aecd715d98ec6032b9e204455d27139859578209b2995d28038c3434a7e6759d5bb865ab36a85e520fd988d44a93d25a3791ffe5582ba41fc10c90d6c5197029c8da46f2a1f1df029f323ca1e1559a7b89fb9a0f88a0765a0d4746ec11a2fb92e9659cea99e23c8442e4bbf5b1c2df4db7435981ca41510d13a87fe0915364c621e750fcc817cc6d7e1afffd04debad67c0c57412af48de6734def0625e22c68e03064724807ad15d35ff01941c563eee9848884ba0733dcc654f679004fae31cc442455a3335b6dc3f5fd58249255fec69f6badda992d8783a8f2deee061f191a7f8bfe096b7ab1383fab86a151a30b2aff13f5bf1c33d8489a5d348f57843f2d16206ebeab7f44c0ce47991985a5f217e035bb0313828b48e16ffe85892103bfaed494e8bb1f1b0082b4e7a30de35fbec5c34d4b570fca750c37831e2df95e3757dfc48708fc8b4a4be66253849acd6b34af5f3b340ec3142b0a99ba407219e2d82849a68b8481e745c51ef433b37bd97eebcec3098fd91f48af0c645f1ffd0120f39763d9151d76d813b482302d164301a68afe12fae7dbffbe193eccb08dda931e38259b5ef80c62ea5c00d1f49f6e4273dfb72f6ecc8d622668370a18d194a6f614f35e388cc52f510eeb89db0914f123aebad47ac6ce46acc523da4a20b93ac20da7760d985a63e7149cdcbd1093207518b458e0308f8eb1ecd834f941bda45df77461f70666bece409fae2a11faf7997a84e2e3155c0c786773d3a10a7c2a4cb4a762ae88da55c8e31f495e0d538be21a5d1e326280694c2ed566849be98997d42d20e696b21805357421822dd96b31088b987b0ea81d2dee755f127ea17a88c0e91a55c93ac83cc07a6a88d9c26b3b893785339bc74228336742ba8f3b3731270245bfa81f70769fb9f3fb0b41a93785c68920ee0e2f7f76528fd355ffd155be12771ff4a0afea9ca29d70168e079d3c685dff4749267cb9dd12e0398b680981bb4e51e3dd30193289fa44bede233018928854a705be58d9dd79fa028c23d571bfba1d54d1f31a6a18a23deeb9936b86eaf2a584f39e6faf35864b78df61c6330e46e840a94c65fefd95a295fc2ed4d24afde0b0e04cc381041c37060b9637bbec237eef27d796024357748b703452495b8bdeedf689f0d9c61f63caa8831851deb55df950e703ae0e176ec126f8dfbe143d18b2e2e7eeaf2be4401ad9c33d187e78d8c0bee96d14bdc911babe10f2801537e7de857ec18a4b7f54bf1bf0cf1ecec8b832fd9ec0c8c74ea1d035e9ca051b3dc671cc811c4079c597daefc9043e89be81d35ccb965915c55b6936058723a6700fe664a93cc5d347dfc570969109b65afa6179ef77bac7b0b44e13d286b9d7f1981af4f25c520fd2beea6e275f60f1b7ae138a80a9e30d0be2e60f0edcaf0e2765833697ecbebad75fc7b81c04a972fe60af1090a9338452312ae929a962560d8bb543b23b1fa3a025b319c31571b38cf72a4f3a4f0a7b257108e7febcb7ad658c1cced16bfb373596f370682d79a27275105a4458b31b151e828b4a108c29f75664fbfb9371037ef05eb1c2bc35af74c332cc9b099401b52f8d75f6bb1ffa466333fef6f1e82aec3a769f4e5268948ca1e54c3449944ca4f2b0158858936c829eb338c2e221ac4eb910a54f2a9ffa74f6a593bce5bf99f2630b5b6b62ead839e788b444c35ebfca111ee06877828e5c6e16512029b9949aaa6c12df62fb014160f53adf02d3a0e1af3f72efa672da727745a8ad121f1b53aa0e727f0e794670fcbbc753df522abfdf302f77a3382800e3c433427027053322c55fa6ee28712ac21f36475cbdffcb71106204273b42d1598b31c09fb79d893d3f772243e259d295e850549f3f1e52e2fcd881108ac5009e6be4863115ba7d0afc81ca7a21eace41b40546767608bfb88f50ffcd1fb39907a0d5d7b86d50f4960bf0d3f0a42098caa524fdb8f347341bc4ec5c9a007b8a84ee90d842ee904149b63865ef088cd87d60f04bd994c904c0499f0799d7c36ee12c47aec4fa67c01106beb2fda47012e21c5e2ab999308d35f82c8cf4f9785701cba1eb6d98a06c0883be6dcc6c7ba0a9da54766d774451208885186bc989bc23ff89a4c2da4e451e44ef3861998b55cf2feb608aa7e85a0d2ebeffe2425bc1c158a98f2bab3c10cb217b957d908713415b595f6412e0cc2e999c042cf898067685bb147546d4903ce76991d15a95880c40e4ca3fef0c40d49c6a161d98af80ab9c23bdacfdaf52481d544cb77ae889069339d544fce871a05bebd3b07da83ed49cae0154b35609c102efb2f68bea2f8a536390d40e19e5ee7c2d985a587b37295c66d2051d5c916744886477814206f1cded7d687e29f7df10d2d176e3c50f1daae82529933924abe06688840c9999501b0cb5a36885454f02af421bb12a137f55024486ab0fea3b20c0e6a4e58f47d894e31c79ccf5947c7ca71e5e0e8e753b31c27d2b2d9decd8294dccd7e43ca97159bf95004917e9a0250757f6229adb22e737d3bb9f999adecdd46cedf930cb31157ccef244b6855bcba0eecb443a3a7a26bdd5e0525e760ceb1a9be7d8f89b081b5da2ec0d25bb3118effc39e018cd94a9c866b82803910df99bf21f4e7f27dadd36879a450b7bfca22aa37b89963adbc4cc8bac88a4ee987208fd612ed42c6932664292e5121a7bfb981ba43dcee8cb46fa61b4b8d132418c1ff013e7ca06b4cc4adafff4280978d40c5755c2df2fb150a1990f7bcdfc934d4537224ddf175f5df1cc2081045dac8e92e7ce6f0790a4a835c10480ba085ad4f76cc738bd24d855d1a9c8d3798b1294f55560ef48d9189b07a3780fbb25473ee0fcf7927e30e45009f14f7899851287d49c9ea4d90531c9da461cb2196ddb0c9533b1dbd2498075de79ab1a684919b68578a463d2f5b6267bcc2893ecdae8424137213f5e6a33d7ddeb53aaae2af3c627f2f712ef790430149c18fd718ad572680a02fb2fb12d0e7d72faf34d1d3ffc4e280afedbc5ada3da146413fa9b618ff29b373404a7f3f7bbe10abba3073b2bec6e40c46d51bc507de0c354af37627cfaacfb21f36cc2f37bd49508063f23f8bd97c2a261c9682c0e6e58f19ce8df8b8a437a2c455c8d1f10ef6ef058b0d0e9ec48c091d5b09458ac2b12b426269e197388f0619424c354bc8eab24d6e8575eb590c25b0e9665a76644887d79795eeeac719750fb3e09bfea652cb60477c5378261b7a91ef06e566ef3e5ccd2d45ac51a2b9ce482f8daab944853401eb38c77cd562a9591367ba5456a259cb746902340dd63e15c663a19b943778ab38acc9b3cc611b593174bdd50a05f808567ac1fcf3b8b9cdfe3b64fa7c98d52e4bbc6d13b15128b56b07b3311223a841cb637f54db6b6ac34dbd93edc0e7428c468ee2329a2435489eee7f81c224a20f55dd7c93a83405a936fe708537b6fdbb4022f45afd1ef2f30007be65a30d7f27b82e76e95687dc2471268a074487e39c7aa9bf0127a9bb58d12733102497163f6025a073df8955947999c33ba4ab6f686fe505b5eb1a64869bfd75b4369d4708ee929425fb35e9b1309453951cf8590726d4e6aa732c393e2d0976630dbc341eb41a043f4a9c5efad0d8bd7e2309c99adf92a68255eeb8f60b684d1c982db56c440a94ae7fec92e40e1c2e481531abe3b1cf213cdbd0f5c11ce2130c443d8e4756806ea0c899db39c93eb3857559f498b62718e7c0335f14736564646b477a567923bcba8b97f1706d48b3392c764d2614a1c3f843195905dc6daef0de0abbed3168d330f1f9a98fe1f91950106d5a107e32b7ec4138aa8bc2cbd7aed56c89aaeba0ad95afb769d4decb2b5b3012391654955cc8efa5e24d6b559fa309e148a1b6981e925d4b2d729bdc63ce9f29dbdb2e95e0679678e1fb2f31a41f99f6d98cea9fd4a94739f38871a4d5dd70f8975514be911d50aae08e56aed5e885b9830c91d818ce102f32d799185d5d9c7a2bcdd42892fc31c1502cab17c54405c5da5b7e7e571bd1da1a1088550a8024fbb9f3b51125b30c476e91be6bf3dc4abcb67c77ca2e6526ca0c44c74858cce289e3d09cec6bd24d4ff643ab0647ce12dceecdbd7e3e0416e4fd82e277052029518020d0c4aca72dbf57d229568ab80fc893c8692ef3acf848469575639cfba10ae3f75ab770852663586e2bbc8794929581595a535ff350362fb1540e0ce08b5bc1bc64139afcc22190b6f9f31b89931067c9692e15c226e0e2a63041718f01617db51e88a2b2df92bd1cb706680ca4dae938f11a01638f0f60118c06c3021688156e1a0a4cd0bb44c66e0198afc57bc3c83cb7c36e72e4f865b5ec71f17fc1794bcde4bea8a95347550af1a07db2a51e4167b54ab25198575094ed8d8b350869c8a33bedd341426b2c58eb15d0912b007b85e093a33cdefc744be9cca42a0b52c175a4a5ba33a3318fe5c79701084d3f568da4856133ed2c4df200882a67e3a72a8ba0de41ff577619f2dfbb241d09771cf6577e09fdc46c57609f971928d2e8df63365493b7bbefbe963c75c9a10155c9397b51dea0159a3cf3657b1624ad05d20bd253c78099a73289a610a8198860dea34db568acd20986135b45e60ae5eab74927115c784c4c0ff135a5a0fa4d9ac56616499ed58a8986364632b08428676a2eaf333102433fa8096b6c72c7dff7386f9725d01eb9f290b2a98407f09f5d451720525241357ff5ee43f42935e75592598ae68d3d3bc0ae8cb19e8d9f21eced9c4b20dfd25996f272110be7aa867b586e12d277c8bd4c6a39d987423d4ae7e7e5d363f4980db7a6c95b66fb26c9a03f23a1bbbf69334f57a3b7b145aadb447bc8358d8b6b6ba4949ce80e0d54ed131ab65c647db93c41ad0304a61b1f24b490634ea78290340631a87f0852b3d22ef0f0f5d46d0d1ff2513077b90ed53b1d10ae3b237fa376a6c348d85d3fb743b174c1052a1d070d695946899601f81eaf06c6129844ec2371e2b5bd3c12ae784952431ff5ff5178017570595aa7f8d898386ccd8c3dfd47edf61ee65a678c6467304d8830c24ae1c0da9434337b073a0607c1025c8b96ad476cfcf93fffeb102e029726aff01e7dc1c830c8e4404c19cc9fd17473dc1483decc5bdd06dd02f0db22b82e74fc8599fc7cc3d92bbf8adfd47112381b40b5b697c43d5b6bdbcbafbe884a243fc6bc5b9b288131c5b72696c7241219a1cdbb44a39d34c0cde5eefc1aee691dd5fcb17780b40fb06192bcac4b6d873f0dbea364edee50a9cdd9f2d5d94971b38915bbd4c3c14851fdbca5496df89857316a66a4d3ca40fe615b44e224a793810b00a255e22ba80439a9b045755650c8563670244efd680d7279cfedf41007b9a79eb6484b47f5634ac45cef948b5615e8faeb413d2cc8fa4c53169b83f8b7e3f80624e0ec11ae1a588cbaa91fe5358716699c3c4c927dbf2f93faecc6b9cf6d1d06f087c7eb4cc54be3d53b22eb8cf1e32297a82a32283c1d6e77e15e52c1350910b2ef110abaededd88ab54bc79c68897d53e1b02cfe3d4bc5df5fef00a0d26d49fc0b312bfc38f70c45659ec656dd4122a5890506b797f619fc1e7fda46b5592ccc4bd65e7c2c17ef3a959ff87eebafcddeffe2ef1de90b0b6519fe4d09f1177ffe0638304692b6aee39e5d4ba769f36b547c2563ec936dbc80e119b6f9d5b0829ad40c431f92b930c7198f4d3d1df58742ccf614a71542bc5451d0a6df8023fe6f463ea90a6d3b1d859cf1b05959c358920b0bdfe2a41cf11714f647852710c1f1ee410f280373fea355ff526769b883608b0156f259d2d1343e866939e72b674f8937399cdc52bc5500d7192d3d6636fb3d837f1cb46a85ccec0927ef86d0e5f634702afaf65b8590636f1aabb612c0059145926d5e4755091c8769b712032b406e105b7d5ae1da521e6266210f0c32c2509c595ff69442bd32776e8f1abe2ab8d1431f394839c3ff654375f93080a95a097338d8e38bf62aecbf2bf936b3e41c291ee7b4e350a444a3a377c35f84744db2605582a9c5d5d4381f262796444a1b277ae82f22ecd81ae30250270710cf2eecbac6c2cb8103847986f9f429e9be2e20ebb664e1d4011831542d4e8ab8c326b2ac52d7d910df0810579e212464fd3c31e9f7e23447ef9144315752d74f0e8287f2c1558a56af5a5e80c738149032d1df36c4ea3f488f38683508d3200c824cb24cb910794df7dd6fd7bde6cbed76bfb560c7bf79f02d5fc58c7ef64df1b2a67a5d638efa1dd7d30ec0cb865d752eff50ad7e4a49dd6367e01ce675e9c02ca764f395084acd2b097c9acb9673fc0d0013fbfd1f55ed5c1550b6ff78b7935dad076bd4a0676ed1fe241e0fe8541ce6609c6699ca8309573ad4527ea94c26b2c312e98d59bee11a0adddd39d54401d99b508a7b90b77507c8379d2e9fda013b009127daf961828b7788f307ac053471e295995c5673e16fe50e96412f122bf00124bf76e2b88734fba7d7685c99cca7499ca5dd3a6f4883b274bad1b7929f03e46f26de54c055b5ffa68a11f8c6e9b5139607add12c0850989c531de3b4e463aa2e371ecd10982def1071897890def67d51d97659f4fd45154f2c365267beda5b99026580fb5d9c5362c2962e72839ad8c12c94a1924265a801c97a52ee3dc7466ce8f764a437f9b016e9ecafa89ebe72224d14986c933021dac4c91ccd2e196c4aa492685a10040c8b893e4b9b31e055b1f45e5c9a2af39105abad1b95d8f7239546195b93ef85c1d79a06947cfc99ca1284c5a2795387a41b11f0d39e8a58e3ebb9ff59a648f7da1473c3e9a4183d4a360736cbcb5df5fb37e077039cd772fc6ebe953d0791e975ae646cad8d6f441107e616a162cf44bb34d19b5b0541e6020ae6ef7c8c372e63203bcbacd4bb83459ebdc6b59e440a07b9da52e01a8e802eb82dace5f9a74dbaabd2814950acaa50664e817c36f71b0870590ce49cf0f924ec301ec5a6e565f69e966e31842852bba35414031881c547d745856684d7b20ae2a251c4b2d1a1ba4833b5835a055d3dae1cbbd2b7cc1afd0fc9b878f14c83c91db224c5cc4caf1819e769a3ca14fb90be707035137f12a40054cc220bcf8c3ca9257ad30df8be6505434a34145f76ec7d9fdc80c13153ff3004642da8ed7b3932475560ca9dea1af28906f2b42c9eda6538bd608bc567cfc6a3fededcb58fe5d8ec762255662a24f43d14ea18010a8b1b20d221d5851eef613582d77a23a0c98da89e97d9083629d410a661413d67055259a443321428093bcb1ca29eedf61719fddfc4e814f090b0bf32b38cdc6856fb2ecdeef2f0fc9d8a2d4d744861979a36b235848bc2e961dfd698b853585249946cfe462633c5d8e932b34524bdee0929e4900fabeff95f5cd04ee9f14c5b643b1594f393551d260d4dce7175cc8e5176c85ae448df9eecbfef7fc8b41d8ca2757fba1f2adb67eab8ba0e10f485d851ca46daf7ea39e1680115629011644cca598773c76e15af86800cc58323e37da76ff0c6d0b5905a71b342a490b1f823e331cf1ef8bccaefcd7442547c4e069a6fca6d3efd5288af782e9aa8af34a52d9c4c297cbb0e6b9d79abebc007f34f1559d83bf520ebeb16c314eda96712e95887c26615488284ccad0dccb3545e9bb614e742e5b8a57245ad3ae20150e6d3f55468f7d698a168d40f681f4cc0830ce459b9a77b1e0a42992a2672d8bcceead68ec38676199c1112edb8ff2759166c9e86ebc2b8bca25593dde5657a1932eeeca645b5e2225db0a6f03e6d37140229b81eca00831d3b59dfa6d6d21669b68ca7f920e6856dadd2039442d2f54816c1590159b0f8d3ffe643f9db443604debd377a25c956f7139ef44ab6b1f25d6d87257bebb7a91d108f8cdafcf016d00c9874ac316e146dad36d5a06864499e43cc2e6b201b52c853ec35a3d96c9abe0823f06000644cb9a2202141cfc121501cf8ffebe3df4e72dbb35b45931f73f9e89134ca5ea62cf7c9308bebd58665d0153631aaa78a3bb5b2e41e7e8b8ad93470113aad50a6ef80b318951285c43d63bb7a7e889e2b624078e2ee15b559240706003f742c47acd9d65fc5ba427433179180f49a5195c6cc7ab608c33e27322e1af69370e97dde1b76bcb8f920ba13de16bc73f1f43c7b6ed2b303ba86218773cf0359a49e08c40e1ea8769d4a7ec9986cd0a5823da33b8be546bcc46a19198adad38d53296944bec01034233219dee5d3330e603a5eccb584692b870c25f40a1d22de7072c23de2b7e36feab64f8bb6c1b1a8319296d6aa7b22357a90c1c63bc47af301dcb857f17742094f78b993b228e7c367057c8363b271a674e0098594eb6a1544698719cab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
