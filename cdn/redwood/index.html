<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"707bddbb347b7dab6218034887a1fd265a4a3dfb1ca5dca94b1f7953f4f365431fd30a043b160ddf81b737cfef22c1369ca944b6f606f4a3dce11a5189e33cbfce85900cef72ba4770a9c09c5d9233ed151df9a51bddb2a19bf6269174392aad79eedda54f09aee557217ac311a2147b619b36372a747df3552ce8a2f5dd49a7208538cf23cb898ff2afd9ee01b289a1bf72844042a1ce65ba7466227d2096eb892182896356bcfda8dbfea286d850c5ed1b79df16b320a27e024aff71a998954e2807d02d142f3c10602ce509f135395c1c749abe59d90790aac3ca8a0ba17e68dbd4b0cab2178bfdf9932805d942f196e50f02d0ce73c55b23ca169d8e9ee9619cdd6939ca262febf9edd8e1f25602766ccb53eb66d95e44b5e5c4e1a0f3be3c139ac6fe584c0ba11a2513a8f00fe219306ee1f2b87cb516e2742cf65bd74d4604c0c1de205241f69813aadaa3c5383b53289003040d548812658473781a85c1a9ffad33a3c9ef8e4758296582d497ab0cd96463523cfe151766f0ace356e06bcdedd6e7e78db971fe2446e3027229992ccaa8f004be1c2aa1f8713c7c762ad524ef7ca4ee54f70831b2b1709392306a04c83d6c23f648b94147fb7a308938dd21e323c36c02f09704efaf13622822c4804ead4ecc203c46606c0d8c55b22f3444e4a217cfa1acf9c5c7aeb9eda23ea9eee070efdb2814f3e51a6c3575530592500277ce0d80dfe024201724b9153d04d6bc13a5925193dcbe7a8aaf51c00feeac72bf77a2b50115355e465271531436d605e5e3e038ebd57095d1d35a2135fc2e1b61f2994bbbb9b83e368fe79d2e533537fd71332b132fc485054073760aea4641fb19c18db937ba602841b05d9fc2633575f947c2919f5bf8ab63b77f5c704d76173d2245f1c340c654827ffcfff9d58ad601cbe4c6043d74e017fe2dbaa234b3bd8853ea6f85a6685c9a2882b8caeb6db11aa48432e6dd579e9e5d6163635f06f8023d3b7e9d110feaba740330adec5b0090b041ee03efb9a6a709b2f0b46051f81fe8966054f45f3643b597e96f46083c9822d75b2e24863696b4066f7a0bdb04bd380a9964bec8a6aecc22c4ad992739120ebe9a62b2c8365fff87758a19d0a15f0e81116947be7c5f9b9d5e680211dd5c4d45394e1991c825189abaf1a33865ce2ede6d307658c9f9bc35184c535d48127c116fe3b27789b2d6b3da64080c3fa1f02f541ca368efeb87826bcb077dba6e7d6954c14f06f49e23d9d11feb423dd564bc083c7ffcd2146aaf1c24d7c2441405c882f1033c6db8d8a34b87ab5d0d06d9ee07f7ce44b253e5f9d0f513d993caf721842d71d7328b88544717e072fda2ae5b76897ca30d7e5150d56ac81d4a5e903aa68df919240d4ae34aeb4a867417cf86fa44744f17bed875f4a2d9c2c9cf4544b2822cfe1ff3ec1c40ffb27aa613b3768271570eca10b2ebffaaf7f2da89752881c036bc73d9281bdac00d9a614795524e986475d76952943fe935c44c6c6a85918a7825570976131df8a79ad7fde4aba2f717667b486463165fbabed6674938c961dc03f502fb22e1fa1edcea1e15c1eb1e16d5f1c2d00af4cc4921442097ab30dc0d2c75b8409a61b3bf47bac44bd3c9a2cf9f7c2ac513955641525dec77daa2239849f72030d3654b56ba7bf94c764ed2db56154035b4ed4fcdc6f98bd27ba6ad8137fb0d7cc126f02bf0fb5bb99a163079133f48d44634dcf4bae35c4ce9c79d75788b2fdd7b80f3eb78344cf3ccc27b3ed7dfb0d46ddb230421e079bd8ceff0a8a59e3580e93f82669327331757b9fa905378393501800d6f85e1946a1f5cabc5c0a499c4e6afc192b451462e51fffe383131945d5f2e7027df959d155198e1ffa83d80bb96172128ada5d3da5b1d7a36a88102307bedd22b35aa62bec5b7d25dc56e525401bcb4fa79c591636a1ebbed06d99062a08763c82f3e74f5f1347966256c4c8f7b8e0f60ae5b58c63c7f387fdbd7959a86175866f1097faf2b712d45d816b4ab134d0d36a109e71f762b76f9cab8ca45bccf4d39c59ead72255dd7e5734da665398b68f0f38e3796533846d7a3d0352064beae289a0794a91ba902381432c908b1456f2d0c7ea78056761dc5313fb83b7b9bcf9a74cce2d481a78089018cf90963308560d7e16bc6f2d4bb9424044a2696d39d892468d665b0cae3e7cac375a4b5f99b3c8006aaf8867e6da613cd45d57d54ce14a0f1d15636394d56ff9b760f337685efdd130b60cd3f4c0f7aa09bcd187ab8687ae161988dcfcdd677c6f21737178a4b72fd53e209e989be62e8f53c6e8dc0145f02ba12aa39f06b2c804c768442a7a075d11b86b8dc087c1502fcf81e2236262c6a0887d4d25050ee384e9e65fbbc0e49d769ef0eb179b4bcef5683f9dd572c04d3b651ef216ed81346bbaed73b2a80e842bafdaac858803f99d33fbcf33d828c36ae8fb5b1fcddd0919f53aba8cf51ad9d69a9e677a28cd560144b2cc325a19c82dca25d3065682e2a0328511aca8e34e3e961d7fa2ed7fa910fc6a9ce21fb4b33315bebcdb369208a085f46cb91b3bcaa3838ba9e75a3ea22d773f4a0f7a88c8eb99290db3d44a20d419876791294ffce5431677f039c205c4ae35cd31cfe2f08d490dd0d888f99f9aefe18ca79959890f15b72c1e4b4a01186c638c643a5171fdac7a1f7ae56e1dd3688e4d4c4340ed2916a9867b7062ecb61a5fbbcddd99419f255ebfc94be7cbb7db44911673374be9d2f8b593350ea3c8778761c1d8c11d98355accfd70e986a13ce5f93fe018a751759dfa077f743ecaeb5df7731560c3e3586459a17d7b1b8b886acf4c4cd5d9fbe54729297e8d19ae50d8d663433f8c0d7d07aba6c12fe5c8795f5da8373e78c13b209bb19aed9ad9aace1b8e12df36ad7e45222fe6876f4954b7cc770973bf1de459d9f2c981c8f12a52ca04cc4226b3a4a749c1eaf1829f9f9c154352d638ab6c8ade9350bc9fe302158d48dff0723f03ec2c7cce972ce29fb4ec13d165ffe39d4be5de60512fb8280d9d917ee85efef7fb5b7bb2828ca291c8bf33e0ffeb94f759e5f8a659f27d3ad41ea9ef378009ddba2aaa43edf2f2a4e55b972b111be69cad8d08b70752d7a1e6b67ae6b16327e14f2f68ac846ed20d86e9fd04641051e76045682981d3f367d5f59b88c2b69ea5126ccdc13067c6d009a0670af464907f5471c1e747689d8d3b1a8233a4cbdfdfd943f8b3da026e8092b78da1875ea96f64a792569477313454bdb9c2dea67ac9f07548ad36c0556343467236fae049d6ebcedc97605c09cc858868c7d9a8d381d4fe20b02ae2480d3ff418a06cd71abd5fae3b1cee57b8c3d6ca46b6ac258445cd354a24cce21b693979ba1266e3445e7f65b669c095867f591174ea86d9cca637ed1636e75486eabf693f1be212735ec88b535a14bcf00d477c1a9c2828ee04f782edc56422283bae3b4a3371894cb210fc3fc4cad66921e60ebdd324d2a73f1fb823976a23389bcd0e17fe3f0eabe62bf3415a804918a93a4a496d94517261c08e52e01b439b444e3bad11cdaefd2b2a5bd8c3c2181b5672d1aa256e48712cefdf5caa74dc843d4c6ecdc0f792c1b3e00d55f33950a3389507edc1ebc12b4e1ba66a21149e90ad4bc26dd158f2c487d1078eda5a814ef2efa6f29d6dcc98403276d35a6a13f5e734f1d6a03814bbc79af844444d4723e5d25ad825958bec0948dfc74678056fde7fb7a776c080cfe5cd4e407a93d8f15c0a85940d9e676527ed404788f83df31682aa0086d7a4796caf6ad41dd2628963e11b5a7ebe9961ddb96c7e515f4164c3e707b4a9c8d82735cb519674e027093e88ad3e1e1b317ec62f269565cd4974666e2c1981fef0f107a974bbea0346bece886f642aced7fb46010d44aadb5575b42d6685eab3ecafd5ac484dd715be5386258a9145bdcb1774ae2bdabfce4deb100ba1d99cecf66aba3c5c73dfce20fd2f547d8af1e5f66ff6ce72b89ea10776b1236da64378d8b660d84a511fa1a8b9b04207c7fc45b38cf1331e9e495d32a96215f255f52001d366c19268310efad1ce1ce1edf3ee5cb6c709b8fd3f4034e4f3aa70832e0a2be38efcc5d0d2efef3cd1237607297d55be4542a00572dc48e44b50128ddc98e18df7d2049d5be8e121003d1a4d0dda6b9d22b1a884e426d4b28a0a58c593463d3c71c565977be93887348f25a36abe7829abfe49100cd077bc52c7379298ce14eb2e28d2832ca8f2af3527c6d1b7901c65913fb74833ca40d699764232b2b5fd79c51c6bcee0dcc73a07199c999a5c72bbbd8c5021336c7dc7345d2cb3a05997e66abcfc9d2701b5a4ecd69d15a9a63917a6318d8d217866cdd517b1b1b652a87ae08265f820d66f87ca828819170a47f07050f673958f8b3b998a5ddaf4bf087d02d3edfd998279131ad4a87c3ccaf6cf74ac70c25cd25ac0b807f4b7f4f487282d89a71369b4b67c5871e5526f20be0a137c8d909ef017187021530f6c546fcf0415eb42cc6acff0e38f89155de3d67c6a631537fa9177033f31e24969414196d7502b4b90453a756e36f2015142dc76a9fa5502598d1f473ab3c3872ad503c800826a32bcd802520856e305f0ab1acb184970bd377aa6565df163918303235a434273ba5fee24265206d92414b13f7fb70ef4c98d84179e605152cc7e367939d77c3947f72635a245b0cfc6ac28db4d3634a4dbaae8f89dc40d32a9390f44557577da9d766aed1994abc16098ecf94ff48f73408ef73e80b29eada4edc31164fd8507bc675f18b75587b8a2d3a0069e45609c6f5231d9897066c952f54dd852af984c40935ad8430d31d337a164e7f871cd692a4796e0dfed538665bd592462fc6b4c05180c7abcea893208f011dbce7e12ceb32cf3ac676a8ef599bbae6177c505af20ffba97eceaa10ccdd7082eef7350ed383d51997132fe9f1995aa9032a83bd2ae21c1479168368e03f4c6e5c3a85e58a73fd117b0b12a88b2a239638bbe31ab619882e5b1bbe74f3e7e6a167990bf2c19c098aeaad517ce7beb8b3d8c656d8fc7fc0b111fbac68cd7e80e77d801846edbb157aabfb622d18015cc5df89707513c331ec2e7dbb23d754e932a1496bb1d93b14c896781f22641e307c9272d168dcc51ada9e52dcd14b334439ab588690986ea80442d5e9434e47893dbc5548ed0b3324566a9b5b9dcfc98c931aea372ff7d1799f6a0be012c043436e82c88055c9fb30054dd9733c2e00fa3f9fb128d7c586b1c5d00080e54f2638097c9973e8218ece51875f3e72af65066a33642240565f68bc7ceeb000ae52b61b631ba3c0fc493e2e36aa25a3bafc9f033f47ace33000c916e5eff3a7a87762bdd73d3c5d44100e4a3ed17c2edb72f73764981e09f81be3696eb9ed7b88c748bc8d92f83677356c8d1af1eace6b51b657e9056a7f98ef43bff545181ffdd11f3fb59d289ced28c6923d0b49e2dfc84f6448bd88a569d66c38c63009b837fbed2738c73a2007c9aa0d3c5d4ba9ac21d941a9544bb98e9a6d29dcbe7f6969d9bd04978805ae3280ab4d805d62df98347d2b7d58cdebce63659e94357aabd6961c8675e397a67563573281869dfe4d4c5fa2c6ebbdd9e8540d520d949d769d5b7c21cf8770875bdd6889998b36b7a2b729bee517a23a6d92deb05b311730d2f857ea040049a3f56e27878c5163a3367ff540434b2126ea4c2b71bd8043c88ce2c689b3e49cdd9472b382d9f5d4c63552c1a3d5fb607746e28c0137471af06655295ad7856cf60b5abdecc7cde4fe397cd6e22706a3202a14175f75ff0ed52d46cee9f9ae543ddc2b0f0d5e7a222243833dd1fab76ad6167192cd250093e8eff3265cfd69457c523d3395683fbf86141c0473c0356005d9a4ed16bcc773bfe23c25d01794108b2e7fbb8f3b8fa9bc548d1fa9f9d1199bb83512a6963b966d626409ab8dd2494dcdc503fd90b7965cb291a5c44ee4f3c8f1400ce27f1032607175c84bcd524552f684bd03e251d8ea22ff4c7b345e55ce75e1c92e7582419dc23cb282d2013e63764efaaf229cfd79a2b5f08e9fc2f73d863fcdc56a7742f066164a0a58ef81dd068d46adb0c1986976d8ffe79d264ea2bf085b665b1df65a64d26595ac10fe13869953a7f241c7a7193322225d965772b57f04ab6ad5f291646bb886af0f35a0569c3fcd342b752b18be5d1412d7c15235f164ef6ef69efb20877aec23101cbc1267096d4e44186604eb47629215adfa82b849a39c87e2862da9c6dba23064926f042ad21c0349cc80804f76331c5ccc880ca9b6782c3da17fe7519fe174c57e7a81d516bbca4fdc4f5146212af7a346221dc395be9cd60dc071e00c4e308453b5d407341a8eb2ddd3623f675b717e0986b31d204a6a79021a4d41c3dad96362082082d83ae6fc8bac3491f840cfcf1253463ab33596fb6a353436ca876d13460efc96be8ed9e5cca008b79f4f669833cf4225bb4a6af3c2180f28f7f55a2e6ab692a4e74acba5872d8f78345db32fa299acef028813d5a005f74755260d396255ba622b30361a06d107f26fb28396902f948207fb2d77fe146546c1b9cc05fa2bdd9f4602057e89e5e88f6231f12c72b44f06f4e172004d0020e3433b6a397a87bdd6dfe3df68864826251f0a91808d78cc51156b3bb5fd9d19e2f2a7e58e38a7906df423b8b102f5ea802a9a5f5a9e61f5c4d2dca0c6ffe6546451665c0f83f2f8fc369e637244304fdb73bb7611ee7dde5c7c08b074a4c528a5434cfe98d5f456b98960351a5915e15ebeb68337f0477f9ea5a3345e3be0a0debdfa68a2849763e6ca7aa5153ba570160f430bfd2c6183643cd0f0e7629e201217dafea7cb7936d6c2b497ae2bc5d94b6e4f2fd59d7b7b5f435e3c51b390657e1cc434b8bbbcfea0537762f0a42457ffc7268e4f298a43991298a14b382156a325d3a9c5562931996bdb4c5d6f37a9ee1a92fead500f315bf0ba34c2b66aefb5f82dd8cfa63fba739ffff5b619686e546dbfa4d4b81c22bb7003ab8a7e6dfbae73108e76b408172a2d2c91790015060538bb3d8fbbbf56c2e1bbf109f2dbcd9eedd3a253f82129a5c29cd8679475c337a063399846ad620436b37b2668740875cdc885e70c1692d67a8d4d1772fcdec7eabc2955c4770c643f5b4bc75afbdc4eee7eeec04a9ada5bb3fb0378e25e3e468c733742ea2f4a8b93b30109361e39eaf917c629c18d86b4bacc4d2cc082d9a69d5a4871e4b098d8ca5d74bfd7c32d36c8c34f5094b3f370361468cafb33d735fc0a13609a735d35a7d713029984dc761656558f82d966a6487c74ae941fd270e36659a6763012bf288978a48086a35f8c75ef353ef748aeb07195aa224471e9f12d1383e65cfa46189f4c5a02234da887c8f623355a2915bfcb8b98c97fea96a743e24eacf06c5742376516964e426eb04aee119fe4d73a71d3d7810437df3814d41b6cc0f0c64b0aaa88360df254d9567bf0018e73b5d6c66230936989eaf2e423c335c96bc7bd1b05c17a7846d8eee170564e0f1b42670acd89e61dab3b380fcefa20961867f8ab8fb97bdcdad1263f800bd9af3e9524646f960f9a2598a4da1957a8ae997bc082aa97a8017c884ddbfb8f538fcc7a1b25f77fd97382853075c77e553b2bf9743d701e3226a58b354a82e1dd9bd6cd41a0e13d170799a507fbced7a61007095a8783578f5fd40df81c63cb18c6f0cb06019595275e34ea68b928466d774c594afba275625b15b74b48e6cde1b4db70dba76f71833e2ce61ca5f3d26a719517c61ff32c24f2bf57283d97e5a639ea49a225a541dfc02887155403f0bf624904493a5fe71afc612560cd37da2ed484cfa637a05138a12a401c36253b7613962d35ccd7bd382be97c08e87682c8be315d33e0fe809b970d2cf32c63b8b08f5b40b04ca271242e21f543dc33fc71680c4d10064d49e92909d71e808218bac349997b1764ad7e594c76d7982ffdcd96b1a4f037987ae016e0e1167ec3a3ab9f876a5c19688e5de33b8e9c4e127bd27be3ff96ef57f2aefc76a8625c18374d974116427dac63b216d5fb25dd4b7dc7695b13990a4f9b019f073df763cacf93afff3a76ed6840d348e512f4839f6bcce5afb1b37ebdf1768a4f5c07af04e9c31aa74130fe306f635375dbf173d4129fae9e6e9ec17c2dbf89d575a9054e20776367816c332d16c1276932595ed0b7d76197831a939503cce9dcdff6ebe932b919943abe09038c38dfccf5f95565ca45455414ee137f89209cdcc6a7512a5f9f3377a41fb6fd1ec6988d4a32f5b7f126545c78b68bf9766713d7c485b8788ff8aec0e010b7c792bef310337015b6ded51210ca92bfb973e83c1fae51416bab46ee12d805c043b5206a46f36dcb66d47d44fd233293ebfe1b1c6b9f26f71d3d7aee69ff58dc42fa068e17d82a4f10ba21478e13497aa7a9c34d001e7bd0b12687d71d52b76b1d53495f02cef1e29d6ffcf30056931fbd2000b2924f878bbbd5289f1aafa43eb7f37f55a2be14a8d232dde92608e6cdf428cafd091f355185b166f2f88e462c41ad98a9d1838be3d252398c60f5d8d8c7135fa63b67cdd5cb960e51e7e79b122cc620c9ee88057b3117938ced78335aab4f6feb42a810ba221a03616be41d4071bebed387a3f92954354d8dfe954543cac3c84768c90a6d24b044e3f938517afb2136ba67234f6099f2dc13b898f2a49f9ecd9334342897d0547ea2eb185c35b17f5dee9c1a2ad75b33c5ce4b5157e97e13f947f87465f6b154da2eb98a9328fa2d90492f6343182fc7a69817ad3cd5d82f943a71461ebe151e4c04470143c5ad136516c34abc24af07429a43de87da5e53c96eaf1548fbe0f54a4b56a3691f3c1cc3c14b28df2c515b89a9cc3cf00470cbe8e4873c266f794cde96fe300b5e2a406c6712d2c211d043e538d68d8793e702b840d6f2de2fd2e860e2126a1747a1ffcaab0ba3c2a6bafa7be425ba66dc51056c56e765142168314afeb6d8107691fd5835638a568accee1f473e5d1b9c8cf7dc423aa60ebf107027f586b6eb33d3d27e212c7c1010ca6644c275d998485917fc58a5974c6b0ce02e390cd4ec4217e55427953829d478cfc1d585d79b705173272972f2e51cba27949c66baf787ad6ca4f70f5245579212b881c68dfb49c4ae42f46dc49c56d0d67554d02ac195660c373b58ea1d663f8b5ac1761a476f497adc5279c82dab7b01480980a52e18087f9ed306604436fa3db1d68a1a206b4a7ce6193c3005df069ba353ec52632e66557195f95ea1bc6876ff5bff6a7df6e3f7b33d5f5b5b763421e82ac9bd7d77269c0a2bafbf683ba026b3bab91299058428dfe31f12246a6854febf9b00a7a50f46457a0bc57e4d0271df169febc3ebad3303ec57a33c6a4b63a11ee6096f453fc59244e18c22099c595fd1e5c3b37ab240f1ced681e0c3483d45b33d0cfb3c252a98d6d5366d53c54c7b7f1fc5c1822c31a8a8fa2734d622b8ed1bbb6b4b2ff46ab18ff203db0776605d5b7d80b37e0cf43e0074ef85d0cd7e49a5b17f509508b4ac859126c7ec5d2c74aee602ddd41e4ac8bf43f00c4c09672d9bbf55ec8e65b6295503f205cf0222cb705cf2dd76e357e9752277cda29557338dacd12b91e67163a4af5bd2857312629ec4047bc5e5bd84ed7b110bb0a8f4ca5aa6b38af806e411bd99dc4f79db4d5aacc8bcb8562f7674dd4a83867dc664007018867733e78c39adfa99ae279e7568a89ff235f85c8f194b967673454b7cb716acd8dde51b73bb5df87200736feb213b09e3ee3adc66bd60c9e2a43a0b6650f38bc0aced21a6484bba479d29e4e1b1a574dfd2217b4388b1a660ce51f1b8c1a3a980559752362a26573f0fbfbdb656034991d1ad46b482ccfe885783e175a85e8024a2ea50c9f6a2bec3e292b654ce1243f6670d796e8a1251d64cf6267b4f705ee773533b982f20849e11fa72bf580de4a5b322f857f68392ecb956501c734d446f7b91c46f463a8cd73126129de4380bc14ae7678be8c465c64b33bf38802435f17c9537f9173672dec6fa5acb9e6b86eed918bd66cda05e61bc237b1a3a444c090e7086f6e4c11d155ea70d7a185a8a81b177465633bb634415a107d339397a8042b65aa03fbf3d0e30d42910c155f4fe8e6028d0e0c6eefc124d1a481300dfeda931a7a9c7f47499bed22680c45b7e07c3e4396af3b04484c28b9f25acfb651b23dace43147898fa9da8f3db60cf93ff1df0f5f0a04bd65bd0fa0ab466e336c887deddba6ded80098d6b651d2e006c636419529b5a1e91db56a6f7c8da2643ca51aaec2f34a83b830b48dbff1bb0fe32620fa1f9b2d0081683dee631a59f56e22bc92a87e326e11a605dbfc29ac8ea582526fd61fdf57bca5cb6bca2dccc153f13c49a3c3cc15dbf7ab79dcdd8628aa2426818c15da0ceddeddb048e784cc327c61fd3da02e2684d20b4ff44b8801979f4f5625b575d2fbd9e47bdb5eb567bd3b27fd6e3626b35eec2b7899782ccdf02a6616ba396125ccfc4b79e49786ae98198c57a0d3e88ee3ba5766c60ff26887d8e807e462acb76ff6d748a2ef812a10de78c86ddc7e2f6f0e32c3373d7b73f624c116764015a3fdc76eb35d029ff3bb0e4bfde38ad26abf671cbaffc7265adfe095bc20012ec821b61d568437988a84a8894763ce3e53ca7a6f62eca1988c11555993830d13313901247daf9266aaff34abbe7400871a5642c0a7ec86bda0e71272b8542a53657c963267816db46cbf4dd4d66648abd9ac008e639e0b91ec9c1e94a2e4b95f651d2b99d2d4f0f843d0463c6e4748d4a14db9ed5e6981ffe6dc219cc7026f74f6a3888037b79edfaf92371eee5a92270900bb7aecd0be2007856a829dadafe503953f0b53afdca0fb5f6001d697599ca5571c737077da6857df042a64e9fd68cbdac9e0909f825335b29d5dfb2878ae21582e243124a31e9a21f8d3b56c39e87384c984d1b1293699991ad13d1aa3e5d84bbf94fd9dc7c1fffe97643266118119f25a1facc16271aa16c1df0be003aa2a6001b12985a91f2891bfaed761f6b639c8477739239b1d7c8f6b0ba9487c55a62b16bf67407baf028fa9bbc346fb3cd4be966244e0edb33e35c23bcbc01c7dd19e3210b8c1ee4b4a26c74d48a2a4dc2f337985311a8398ef02f77d29e777dcdd12342f1549d06ef54aee1cff8e4ef77554c625174fbcd74c099fec3f85a247cacdb5d2b8f2daa749a754085b48bfc8a707ab5d31cb4fc934602da3ddcd2c832d6b2ad3195eb320ccb5140b8bc6e1a68df4afb93588b5bcbc6cef4a33db2cd062c27c2cb78873e256f29a45e3b90583fcbcfc7b498a2507efb1ed7840a24fd069988baefaba3984d7dff3fd9c7437984fcc199d4c4a9cc74f33232861a82edf67ecf16f5c81320439800dc89119b83ff1110fd49ef4da1877892c823b3d057a045c4ffeae6d6f537e8ea6efcdfe4d54e3e62a1235c8e72ea66a6cad22aa49df5181ecd4e9e9c0aef50d48c1a0e259350ed537169961d5af8c53abba71cd6840f2e39dc83544ae8348f3f46cb8db68c3701177ba55e8d9d5f796cf19c1c0f947c61f61120534c5705325671f354174ec9ae492af44b6fc3406ffc87f3a7a24079f331e5898e4229c29d48590eb8474521f1c0939fc7480d0340c4ed128cce5a951189cf72aa5dfbc6d4e7b2f2cec6b0d025ba1bf6336dd6e84692ffd054bec4412439edfba527b97ddb8b355d548ed67dc06fd94cbe193b80da1f6c75982624e06e076557b90ead34159befe104d12ec972b24565cd8ddcc54baada2f782815210a2553400a45fcc817ac5d25d04034fc843b6c09072acbc37dd7a5665944a02a56f7704d163c0ad6f43e8235950c21ca5f5e3907cb8282d087cf79eea3d8fcb85870d92ca97478542bc9d540e01180dae2c8e337fb6609a561dad65b7eec9a8fdfbca7696a388274c116247feedbff1299678d40ef0fde49914dc0dd514c424d02e7fb04e532bb3331f35a9a72f9004b53c5de126e6dc2e2cb304ad265939850a22d06d9fd7e81341299dddfb46709b8a32d2065ce42dc42eea6e5b7da5ad20f368a92a4e374862b9ec8dfd20a4cda564097d7f1e53452f1373b9287719e2b7a97b25e82eda527a1c15449a1ed629863174e6576f79675594b455bc684e448e0c14c55e3734128f9f985b1f80e2f736a7ae1e957a37f2aa7c16cdf2248bf820842ffd463640e05812633e2587a5f4c46fb79ba2ee82be3eb6f58c572cbe06ae7e16967832f06d3704a5b7a445cb5e8652f2802a776be7319027537c7f43ca2b6bc4349ccb840301b27a337b1d0452f7135772da69937a27e18bbdd9694762d88392ff92062b9a2bbea6476f50ae4118a6d204b9b9d1dc1824cdc7b594eeda88c5d529afe727d1b0a0ffc054a8885a4f95c52638952aec39723140dbebb098a6468d2694daf006fd2087cbb4e3565957a8dd66f832413ce79ccf01a53ed5b92e8e3c58c570561024478c6c3ea90081ee715120c3ecd391d670447dbf959af2ebc8ca494d738d9db167589406eace6ea3306ca4dedc48548ceb4de2771c00bdd1e84926a9e3554b7f388c0dd0381402fac1bcf992cf0603e89016d68a5207561b1ef08f9078fa6d31a972a18d1512918f974c74a7f58c9cdf8d6340d420a3e34d85e827ca8317035ca3f0b7fee1522154f3e35e3673a0ae703099b5ec248f3ffb656c32f11b50424e5f48ebb07336bd9485ffaa2fd6fb832475b008259cd564c93e0effc64d90a6f380f53115feb186f18ad6dacc4e94d623a5d7bc4c2604a859ecb18ef720562cef9e126d67b6449b591ce15383a8408a49b7ed7a816f64c4fda99d9951a45726286390e71bfb3eaacd443d2e02fa6752134de74980dd0c150fc841496a0478718caecd799a7181f9f52c84c07d84ec373561f273a964b6b5bb3769cc17ed9451bdd1cf736842538a3da57b1bccc533ae56147f2720c1e130ee4510e0f4cb1406f2c6ee096e1765a44bc27c45372c0895a875b1125d718fc4aeb6489ea3018f1903c052202d2391852caa08661af034f843650c72106ca7bddd36e0c05105e556016a89c70c7a11d81718399a21001e7b92cf750099e9140ac8b6d519aea9ac640ae1d2f6f26815f274423a741083164f7303022e6027bb2265ef05ec3d36dff02cff3bab2d6c90d547bdd911e23f1bc539d606180aaad04ca276209b07b43aff0e80d414e19638ca3c0890751d9935f3e63ff795ec4158049e227cd82ab76dee88111a2c89c0dfa3aab99a932d97445fc981b9235fbca660909e283834e632c39c71a6c38d13a05a8b654b34ee295eff9b3346968160cc0931e2e84486e1eddc5c40bace7b67c91812c57e96666d511f3a282bfd88c922c57e73f8b8b4f7aedb702907e8772ceb6e2341c6d738d1d50150fd43f321ed9b6b9802f4f399517413b0daad73b5fc06bff451a65fa577518f493f45fdb3094fa5d80b947ede5807c94a198124904b4127b480463eb19401b845e992a53a3009f02bb7572caba7a6cd48db84d4f210272d70d15b3f17873731da50cb33a0935f2f432b2c3b2d91174f019dd22f67fe89ceaa4f789c9d31f92dfd376d9a7aace3092d4951efba080b7ccf389d53e97df763e6c34bff09f04f5ebbb01f5162ae9bb9f08b0cd66c5d46428b7ec70e3a34c11e9b0b2624b1c47d558f074f7cb921cf92e47454487558a1810fd2506dd6e73acde4558221aa5d004b5e0cbb9307fe0a788d791f375988be30ae548d65611a3b611af278e74f94b3a853042f56d3d4f63646dc8c683bb70949ccfad3a2d274c66be71b4b9deb2b49ffc5e559959aaf6e244d7cdae092268ed7cab2a2ad6bfa4b9ff15027d2c47bd311c24ef8b34e9594659c32cc67084f810479942f681020ad1916ff39bd83e8d41de07205f7fba0ced7f2d4114d2f05edf459fdc3c6ac56804888957046a4ee1daa6d42e2201d383898940757a7538d37dd75955e330d0b7f2e33ce04fc7d1ce31a55f0a41fc665b93a0054d42e6968247e75f81b7cf7bae4868905a51477f97ec3dc83be88539d8ff8e922b95285334f66384562e985650001e4fd63818aefe85916292a812454c015a5d72bc3dd69d61c07723d50d51e288990f7492941ed2dac73e53076607062ae147ce9e610ba2e25d8c555f5fc3edf8e300f62f629d7d5caab7e59c6fe370da3b5a57ce7f92eea2b89b60b8b0b987a83b4c62867157070dc5343a76ec2a7bc1b2b7ed06b2b6d1e4f59166baeda8fbd0d33b7304895bcf7c8f54a495cccfc3f6700bffe5d90cacf3f14604f1cb776d2caaa08a4f36fb182beed202070611d027a2b789496c273b81c9cbe900d691b7c1cc1df6c8adb5710928b316a2fde8edf177b1ae96de4f1fd5639eb5528ab5455f018d7edf26226f6ae8fc510adfadc38986f3a5197bf193c754d7318e560c7e66d1bd2e053940836d99e8eb9a4e7f8555da09d74dec859d05e337cbe6cbc59219d9b5f5715aff8dffb771aad9ccbab706257fffe1b46d302febf2d97aedcb072c8467680c2d4a7a948171ded66d66d59fea51b154622c41c4a631d4bd9b47ac229bd70c9f883c5b33a1c98126e40cb1bb2e2fbd029dad84ce39d0d453a9a2c8bdfa347331a1f85179150379189a520dc3e0581bcb9edf665c952de18efe96f0c8da12354ace4fe1537caa82f2149808f24db4b4ba7df646cc732f02d2d211cb98fb39882978bb7968745bf260cfff7692d74cc012f30bc620ade7f93c920405b8fac4862100c1e3321cb4bbdc0167481b0fe3a08cb7429a842eefb829eebf5fc592218dd3dc7a92bc72c87719afd1bf6ead07b8bfd62210ae5df22a3b940cc38a814386059831b38400774f280500a379ab3d39586d575526f6b15b1be9de24cb6160b0af435a819f400b44689a36d010becfc53041ac9d75de690b9fe9eb18c5fa628480d40966f4813f56195bc8da3f7961b4a1f554152552db636ddebb38baaf166f6dbe913600fd0828a5af8956014601eb8e454c6bc65f3194f649e5be7c7ec4a872a408b09a82eb0cb4a446b3825c7d28f692e1e2e7a88fe7e6a50d02abbea5f214e3d9922981772eeb64b44a8fc3d2ae36a4cb637c33ec81ce00b2e1cd47f7c0b33ecd406b8d52a2bcb8a8c4f73ccad8de4a7900d2aa19a6f805886dc54919b0e38e294063280bb3b8c86eef095c45c6b68facb2620b1e07530084ddeb60535e2b52834fee9715e197d6c3cafbb470b84170d31c9272f4b5fb085ecdeb172289fa152bbdcf168d5dda2b44d4ba0c6d1de3565ff04d747d3ab2df25384049e35ed511eb82752062ec13288e67dea979486f3b1440dd0d0e03ec74dba576dd7e9d9096ef0a5bca6baa4a9a23bd4c3c4674e7d039521807106e86f72e5bc551e14b3f496fab0255d2f7df324aa600192b0549afc991fff6ab081df7230af61188cbcd24c72a74b57773eb764a92e175a6615c850dec8dba3898828f6eaf5251cd5a692a79a561e9322e623e28aeda91e10e63ce4def44448b07df45331d705ac50952ba31c973abccbef0115e17f7de1e3e25aca2ff41eb197a5bac9f8f117a0d17b4017a76aaff9ad2074021ac1606a884fd4543d1d599b0cc3373bedc2fcfaf5bc8c9dcccc0ed8fb8f993e41999fdff96de0740feb8bd585391e6ad78c1b7c02aeb58bd8a654aaaed666b1bf1abcf3f074c74acb8f5f061a4e792b2a17efaffdb3c23a35618984855b7e5f81fa3712c3cad9574da67ce1868e0ac70b53b11c656d5f4b538ee7aaade0bf98eb091b60e6014a5ec252238c953c3c3bef6ca20bb7337a4f0e9b5c5c55b07c3f1468a65389e1aa3eb01096310514808686a7d3eb74ad8040707475b7666b95f8caca99dab9a2f872548c9b5fabecbe2d0a39f4c2def3847cceccf80fba309226c7b9cc9a7499284bd3e95e30f84a712162728725356daf9a78ba4d57e0781472db20bff81b070b256e98f1d4b6fefdca3a3e2c40207b5fecdcc6f22b39d6c11c85939cae07a13dfc0d13e3886ec1110f5b4a5e3ad16e1eec66456d31e2493dde5f3c26b7896bc839c98c156e15e6dd13015df9fc86b1967e77125c7a535291fa3a8014f7dde3f2fc9eeee771c20dfc7cd70e3eb3bce6f09efc436128763f201a1ec5b2c607af3d5f103412f4727efb2c339a616ffc8d1e7797144d778c301615364b8dd60aaf2e2837e01c84863ef149ac33b6e5fce3922e86fb12b4b736d525bfa931a4ae424ced6b3cfbe10038c030ef3411b89e9d38921d98051970a748e43046ca304dec5c9603267dfbe1cdcbf53d3dc87f9d3af4ceee29a4a5090bf16e320888777318daf0b92df77345e17d25767472f9833c3d0d7905df4d29b1991028a48879c18272dd455c59d6653d2e9d7f375bc684018c16075d6bafadfd3c94addb6253fd538b32c1beaa95a51695a5e2edd2c3a738d40f369d212e244a70c7cba86f985fef5013f0c42062fb953f16aaec5f0154943da909ad21154eabfdf014c9a4e3e430802af7514468e092b9a162bf5fba634232c699f5cf5258f8e59374827f15d9b3d0e099f6fd2957b0e42d1d46dee882f55a681da848c4209c1fc82b07e585ce704091ed382587430cf62acd742045b31c0ba029a0879150b4e8327d511ab35978d99856d6617b52759afe77fc0724e47c01bbb8041b6664c9a78f3b9dd832270b15304fda9eb60be406a0d31043c3cbbe356ad1c6c486ba8cad4568bbd9ad75cadabfd99c005f087c58bae46c934ea704b503d4933e0015da3a9622ff0a6fad91c73b169f1d94af931c1348bcba155c39cc0e58987ed23544fbd8c3f501c82bc1f048b166a5d652597af513e26b043541a26c04cc25de1c9a72e76e761026fccb77e622a1c3d9c76add6097b14c572f1657e3a341a1189e2a661721d917c7a9f70c92b6f735e3f2310c84d71c2c9996c3d36eebf9c13a906380efb7c4f4e3fa8cef907ce159e5054ca6e011ae1ee8a5c7c587c4cec2aac1e6e588ee66ddf7dab798019a0c9d07e896d19da1e42bdb6caedd18e26700c8479db3c13cd5c58ca79b0300e2913652b3a092d931ca5db532467c149c87f5d9ae10e4e063875b5e0abce5e5872dc230c2e430d2b72c4fd8f2b929210dc76573c16d597dc198f01038db1c8c80a8cc86047b51173e819443d483c491cef1d7720930769b57819f3ad057035ad0ddb919b840613e92e3e7e837512a830af19a83d8df0c2d9fbea0f47d0b2dcc05c74deb02c1fe48032bf487235eb26c9e1c1f6ece2a31860609928072616774dfbeadab3e92505adc917b938370f4c0d1f2e445694e994328e25d2de5be9de7a17f51d12328cdfe48d371b02373e6486d0ba2d229d9a78340a2b0f0e701b503020eb5581a38f46be014b601b79b6a22272f418eaebfc5d8b6ffab4336ca49f5cfa2cc27de5fdbe7030ec566675ff18f7bff7dc9552e0af540b4c1a2851844f65b188116fc2b5dcb9b68f5a231f8e8d6b8934665f3e4908f7759351efe850998d60dbcc5bec61e755fe7ecfd185846af0f522b165b8792f2a266062706022320ccd599d64ee291b743180a65b6b1f893801f1b0f95fc1e3a2be5a69341a1bc26143eadeac7a7c2f13f4a4cb280be9b0f00ce5da31c5029fd50bcc82f1b8ee195f6f7155630c64ba3d3cac48fb29ee88238d7bcd376f945418013280e5cbafd250350c5e9d0692389d2b39884c1d850915326affc05b82529480ea88d17a0a086929b808f80f0108e0e971f5404b60615c51c4ac2e13617516e20b9b1c62e821f8dd3d8db70a61a337b843b687d744a905b208f77013a4fc47c80b0fddd942ff26fb3d5cfef9210a7e09e40f77dbbc24c398011ff431a4aa43eacd1482f74be3b1eb82fc686325f1aa078e020029238256456ddc6d19225538b865adabe3ae492aad5aa6ae4f6bb6d2633eb6ebfd10afb3c069d30aaa272cdd60a042e9e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
