<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"916c5baccdc842b6d577d16a4ab044b043047230b9382a1c6b600f188ab035791e89bcef4f6e94f0447fff3a1a54ed7b144ced8c30a89fc2bd1fc2441ec6232e56d162d321ac3967f5e3c7a9fcabc0eabf37d962022996a6fbaa81e8620d3d3a5d1a83964ce44088a9c2fa07f0733d8a676677a663a0f6954e33431ae9484856b35314c42c0414878d9266ac81c0e3d1ba77a5c1b78988f22e5911a7b578f5091703ea8dbd2bee264106f9a7cf1d48eb7ef3407613e97eff13dfab75cc0a8325ed9af10b29981ecf60c1e64c400361e76f329c17fe29323ea8bfd5a32ad144a79391eda425456203eb3cce633d6dd2f818ae82999f975bbc222657b910571b9c3b37c0d4e9a5153ce00426008c779ee361277a224dc57e02c0c64a7af9a3adfced2912ded065f37cc858c27fd4f96ce2583d94ea73848d9ffc9e8e84e3065c592a1c7cc1629c549ab9ac5eba90822955dc703f42acd98b93be8aba883ed8e1a4976ad5b359b79dd86e52c93180692a9f24a748437c9c43ee817d7476ea39466a981c6964aad954b3172351dda8a8199d40d999104d49e1942b92522ac10c9473424113f95150036ca003de4b4cdd962039d4b8fe27089a706145d410c36c7f67a67ec4e876e833004d8b1de4b6026338b9aaf4f612e0e83c2464ac2fac5b8f256701937e5a365f4e51b19fbd563cd16357116012e0d2a004cccdc20851364ccb7338d424b20ddfb6b77f6145a0fc831fda006d2e08b259e5f53cdb9049c38b7102f730e58167563b0bede049cc5f3913e9c4d43d645e887f1018025f8bd7938eba0423b6549fa594c2be3571e7a320b2e2f3dc16675c7acc03fb7ee307d05c895e79d61e8b72f2479b97e1c16e4a4cda2def7d83b4f7ca9908d4f045d6d38b27475e3aa2e667de391fb69a8727bdf170eb7249166b1aed143e713bfe9cbce538d5eaa1d7502ce599f2734cdab391348901774de3e756c7d20112b5330a2be5fdde820ba4337d33c2afbdabcb90a5fd61dc127434e45170e60fc7a9ef84215421ed7b7cae29ab3a4e23b5892d1bc0b863d5b9af5128e7a476cd501d6008fda4b534af07fdb024d954d15046531f31f7fec950c32189f376b3a3c606761461673cb47afed6dfc476a22d1abcba00f3a584b0e8873e4c7f9204a4222219ae45f787030aa4666db44de0426f14dae35383125d61209f7f2a5ef3517e7f40155ab70a6f33a63a63b870b5c3ada8d793a5261c7e38688325c5acb02f898cf436ca3fe2b49593eb8e09bbf30998e0871019cfe25ff0559b044ecc7f5a5f6694cc6618bece69e25ec13655cb1f9a4f912b5427d8e6038175cf13ec5d1afb6baf1ab170f1df8aa7fb9bea836b4b6a6526330ec37c27844a83be9cbd86e2b90f62b327af0f18475afb53fdc3393b0a5103b16650dc1f5040e850afc30c22c31dc1402354ca7f7713c2d832c111a139853bb251a2d49a8677f8c8db484bd3acc2d436d41f2b6b3979168fee3d9f268db8c214f20a6c64edb9057a3b126c822d13d47ae75117fac3863ef5dce7964cbe490dd50cf3f7611cd03b01f15d127cbca7226d96328c6e3b087951b5bc4fe23aea30f37bf09ce5273a8fd67e5f85cfb9667e95e5a3b8ea37daf7f9b4368c088cb62e4691ea58d9c7e12eb5a499953c84c1723256c77272eaed4fa6b2937c75cc4e423ee8630f747eece5bf8590b1cddfc340c2f7d68e3dddbcbc258f7689175d52e7688b366740c6e16eca211c10142d959172b6ee6ba9b41185b8c88a824c4a42d513a7fa64f5831b1032b9ba8007c7b54faed1b5dc5c3ec3668a4a3ca337899d19118c12e389d5e01769aa03170b343119ea5d6f1a906bec8ade34445977b2c728e939cfbc1e5070ab1e32c4059730f15dcdd812600b6592a39cf92d9e3fb1f13c043c42ffd35e446bb0f3f4de7231f4ceaa93972f89254c0217a9021dff6e8e3c6ceb27c100ff2dd92b3834cd8d3d45116adbc92a5baf6a92edc0e7ace4a5faabd413c01f469e5e05d781d971f842ad44608aab82859156b11343a51eb046418b6f5f469c9bed03291e0764d3f7c527305962c9f98bceae581b11481d4d501e43144785ab80c9c1c515484e2cb3b3cc133e5e34dd3a6f31327eb75b40ccd93fac980cf6dfcf0dcafd9c182a333f9e19007e8ac82bf853d2ca43b6c3e6467ffd851a75b7ac9b516d8923287c24a292619f75535bd62ca711a767837fd677b3e6c3bf2cb8ad5e54992ae6bb26e17254ca1ba63b837e74822940ee8536e1df1c4f37d9d71264a1c6d32cb27a6d0b27f7f9d9b6f3f85f9413250c8b600fac641cfc4a5cb73e7d6c30f9d908ef7863e169e4194df46e81d1718826dbcb0fc77b20e4ca77617bee2cabd067e0dba807cfd491d463b0707d58bfb6d7aa107024ab1a2ca3e1fbbb251ef8ddda50666f0b526e61438a4ff697c8cee4a0e9761e14678a6a0679a4f15bd835a1e9d18ceaa73b5a7ba9a0133aaeec26089266d31d3d7e0c9c3c54279081f2d9b0f9244e1ecafb80302baeacb687aec1c0dc316a26e5c52575091c2cbaf40ad204c115b672addee9219d3ae19970859382aab878087e2f618474ee1d4a0b4dd3a2b967980ee5893ffd5c9ccee3c5d519b3aba3d5ca1bd824952f66fcae36a95b9bbdd7500fb8e61b3dfbadcac4c7337f0619505f8ccd912b83b5dfc5829cb6fe386b3c38f9754d322fe83cae0dcf18cf324408698325b78ea5ee6dd99de99a1c2c43db70e43739f5f3d947407319bf3df5816e0f7c20f3eb1393a54d7c6f52d9cda48edc254e55a2ddc4c13f7a3e9327b6bd62d79cfa078c1a03a7d00b7bacc2e8edb932053919d2f58058607c836b62aaa63c5c6868048c447323bb969d7284b814c2d4ed73b7b395e819ded7dfa61baf508d536d241954cd96f8cfa3c1197aee388ebb79afea66513d5e812f8ebda1c80e2c233180c3e5601d4e939c38e6e11d0585f378a9350d5d95d05a8b5056e58e8adfd6763932960dbcf07311424306ce7a5a2cd8a2c81e2008fafe077c54054f80d6d46673593efeeb045d001dc8ec94d39b6ef9f165d1ae943a157c58295db2cb0123ea8ce0d360375ac9cf944a9ce651e434435d85011509972a1c9eb562e4604e6090b4f99bdfbb72eb445b06faaabc616fd0199da284fe5bddc2af80987bae67349ea9c46af5f37bfe1bf6ec5415661a66f7f387a581def9ef3768e5bac60f7e0dadd06ee901640b7f8b9a49ed269c55d7ce151102629a9a8b21d5db06c34e4eb69726a5e3e16b7228e25cc9efb2c2d187b5eff442629ed9806b6bfe5a57dafae2ee8c27f3147f65d2c4e255afadc47636a91783447f96e533e90010e75a15af81582efb7cfd5d15de9328d0cbcef2e6282e1d7a89f7dca07a2a60598e2ca4d5bacfacaddb15f721ca4913a032cae8d6ebd3f90590f124e799d840f7b41c9888f8656b9104dd7eafbf1436e6a7c7c0c59f387cf0b8d39a0d06b7695d63c1c91a88ea7a0fcbe8c2fc23852c50a5f0a490098cdbb74624373fdc1575052ee4440e0192cf39b862e71fb5531d752bf4a0d02033d41e39c750908d071bcd27cb5ec4b961c8fd194ed86261b723a133dc07df14215985da5772d7d42a6d35ab938267dd2044f278979f136c9049fdcaf9ad49cc27f61f8a064614503d8d0d677a198c2eccd224fa99a25cd660f1205b395fb748d454e050a08a6bf91bb72b74fbb076cf21cf2b058e2355a66dc63a7cd5fe6a527b6ba08395eb467920345159fb21174e506a311a067bda328f16a6a2e140fc87afc81dbce7764e37b7b83c904864f71cdf5a6e1364476ee6deee1a32f169e8f2d4ca4257527d9233ee4ac5325707f977fef136b72dbe5d8c60aaeae662e97b97f9a7a333810d0007c92aa75539cfb78704bff6c8124f776b2a4732210f2a9e7ecdeb52fa6d970cfbebe936869dec159b17f75ccf07f3b1726fdfda3554ef2bd5ecc46efb3b019d818fa6245ebf847a2ec0869b96ad236757fbc9186d5e4501a721cc72967381df44a2e608e70016c7371b7f58c5b58d816835d1f971e1a35813f0e310769ce636effd57c5831164152ef97374eabe786d6c0f54268150e0dbd094fc656a1b7f92938b30af76a02c6e0677e38424c883f70834262f9f5ef00b787d2efdd0df85829047185cef2a96c2409507d1becf0535454ab597e955b0a00da47cf9eca1232ede777700955ec507fc17b3dda604145b82ebd3716ab33d0b4e452bc810b692d330ba7fc8813ce71601c08bc5156da0cd039e105d8fda6ba6e2c09a381a71eea9707c35aa96f461455e440b5edce95071d6fc80582a2650d6f5822a2e3e796cf80f19ef5bf5b880197634e748e9c4b73a32cddeffc5ab53fae4856a69a9508c92d5d8318f26495a359a49f0d0e160fc2a2df65479164979a54bb175891ab696adcc71d84f1b7e5a778e4ebab253ca8162af01b29b006fb38c453d4499d36c925c588a7d6ecd334edc4f8f5075c2773f69c086dd6201a4922d5bbae334586cf3450327d7d7ca8eb188a15f23842ebe73a22280e18fd3545d5b041a14ad3c843281291b5af3c425479bcc40f8663898dba55a8fa0780b27928aa181621364c531bd6e1bcd525519fba15a0a2850cb73264294a0436b66c602951e8d4e7eb1ee9bb0633661cb7fa7e979f08091dfb467f37d88294165409107dbb00c51613fe33f48db2f1168c186133d278bc841556aa6a58d407db2a68a5dd693cb3224e3b01417d1f1bd1b8f200e7e316b7a5d9fe59618c7ed846dbc1e3fe69762b9666302a19a5ef19095e642a7a77b09e1fe33f9556fe4d8b62d9e4fd647d68ff1a783a7f1af3e1f2b154639c511b0a4b3aa667c1c9f878ddeed23aea9d69ce53f5ffdc644f22bac34c5482f2bc3ef2cc792e6c2666059e583a7a57ef9988bad54aa2ed3b821e05b49073d7fd04b1bb6351ba45128beadb55b1761ad6e65b67abcae7f66abe45a844c0ab81c389187ebcf63ede559281a3ac46b11ad6a4a92f7280cd67fccf24637bd0b8c8a183f9266a3b27efe7d6ce0748e24f21fbb93e572158d83b5ca7d7731c196a32e100fe14e1dc914d7837e838d3df12593fd08655cd38494002c7d35f6569cb886edb4316c9a34975ff593e898fc57c3556d32d89748ecc8a1505cfd52920fad5f1a91f3f74124e617ae246b33c930afaac89e0e4d663cc487893b85041ac952fad004ee09b37d9593f13ce8db0ec797e3224012234305b1ce6971bc85852904c3c86c7e71467113de7be81c41452db1171f621bce91350a23728c8be975030c6f75f46e028c1d2f92c022e84e95abf8d522cf787b8894ccd605bfa83685220fc7adaa86b769c40bec4229b308ab4948582fd19aca8a566d8dadf6e59d73b28756a3fcde3ae860ff137e31979553a08b3b973974ed38c27d0d52fc670ebf5bc418ea39ad44a16e17fe5bd916c8e9ef4de404a345f3d8f93907f3089e2cf82cc9c101e72f0b326170c0fd58d050c703d885e8bac2c5f4ce35485fcd779e437a285746463df3a691e273f0a924648b7b0071bd96fcd9bfbfb32ff6ed8d9504cef708e6c81902126e07ac152485e72c9bb46cd2d56df564bddd2ad2b51b61d823cef59bfa16ba8d6dcb1f1bdcdcaa13ad62d491d4c00887ad1ee7a98a44f947ada4c76d24835f4dc0c32d233dbe1a4d0bb7daf192f1a2a45acffe994f84020c83309871d8c65791df9b88bfe8460a2d081d8d8391c1ca8ff4387994a78a861d14336d2b69a57284f999d29d90ce3e07bfe5098b188bee506256cc8e4bb62f90c67c116b9700a1629090780d21c3a942a1dab2722f282bc33f9d9171cad0392e6b3333b9fff09bb5fb5a682f3ea2364639a47d126f31fd5ad2feadf1c2aafbfaf033612eee327e19cce7a2c8cbe7de79afd631943ec6e764328397343488a22f40bf610c2e283bb3898b508f73a7c667337f29d24e8bcc66f38a2b78f0cc7a411f20a49e0867e09153880aa613134bf58463dd8610ea30a7c651614fc8411248793be26bb0b439402b5bb45cdb4e999ae0f0f9a3dc12a8d5b6a58a286419e63971ee89648e482d8c5d0f13ef1ab3b006b2e4370fd64fbb877a72cbff3d9763e1159018e8d731e2766d22709aaeea690c8d1317504368abf3adc82534e2217fbba0f5d0ba307d3a26b8ae9e5646875daea4ba756721351819d71665cb4310348fe7aa933fafdeeeb34634c1ba4687df3aa198706e2ebef09dd08017ef1903dcd610fcb35e4f94501cb365b816c777759802d791d81ca42479e81abd08d86c01593ad15575374db8ef842538c7914a0c59971a21cf73b62d98ee3f0125a10d4c0b24b8ddcda6d55b2dade3bc7b7e011800ddfc975f2b890bc795e06936de451947b1797f67b98195a2717fc7d34caed9eb9ab9d283cda69111611656d4556f65fd61dd3843c0fb085e97516d77aa0fa17e529802af2dcb755f01b3ecd62c590510a4aa6603e7d35bf174a8cc1781459f81b32a4a524019dce7a3348bdfa9dce4608c7fe41749add3646b77b52c1e49ebfe36d4ccf86b5f69d2450d0897f510cb87bfa3acf3d1216b8c9f4735417ed1ef96a412ce9ec4dd7a705e4e05e61b186b43bbc19a18ac1680d54b5c1ca13226c48a197d408ade01d868f514155948feb8e4247b70d3341af506d17f3d9a77ae93041cea4d44ab586d0ac264c0b51a700942fe34e9110ed692099d44476659faf8f726a210b7ec099572d27fbe6e525f994cde49d9e83bff5bdbefad8df9918509624cdccbceb2778fa1df1c277e0f8f903b4154c77e8928256ca9beceac64affd069295f6f78fda3686917b059fd930e61d277f1d282f99522e5d79c76c628e8980d759e55e67333638a338d5f9ecabcf6b3fc2ab1122efe4492526b53d49703d56edefea4cb423d2503b3d99d61a9594048d93d50af839939d6463a0416fbd3c933395a49d067deca7406434b9f33f2b45c2accfabef398e86354c5a65ad320b13d16788cac84ba207c1845d6c936672615afbab427d78a369fec5eaa1b365b89a01aad3db809e78947d377e112c0f49b0f737ac07ad35dc418ed76d23f39e07a3dffa9ce8d64a2b2552e69b1ec2a2853f5a8503d55d5b384ba8df730d5b57014bde14e0d840e362df7ccb55c92c20981ec32cb89726af7690cecb87732e4446b63cbb54aaa7b37cccd8afa9cd91928c1e9c1f6396438123884c925ea0ed70ac6080d294308fd249f109f6f3e995875b505159e05a7841eb8b14fc0c8d69453fe8091c731e4381d34fe7ab2e38cbe36953747fc67d87a17f52c7a74efb4a668d24250aaf61968af2565bac0727f505409ada425346991fbf9a88ebb513d83213d2a36946cdf0cdb7367e2bcb76e776bd6f9eb4eff81f7c6b6c04948146b64d5f2dc225b7fce086dfa3d0b8599ba2d67b062dfc9f670dce8b5e93b520db1695e0641d101d5fd211d795de94c1b24fc7d29d94bef752c6119e336eb4e092ddbd26e913687ccfe15399c6544372845e2dcdb830dcb6986c9e4dbe45bbee9d49bcb2fd5a8cb94cd54fccd1f45f664e4a5449666a0cdd83e76a3d450264a35c5058855ca625e1f2c773309d798cc88fc0b022a46f54edf6a8dd391a4a140b27074a7e35c64bb2a794ae4074c7b9a1a8edfb684be6d5bb02282ed73d14c81445f359c36636964d3cd8d5679443d004a71a3a8bb0a9b556b791678ff754c569319bfcca9ed583014239258952ac68ff069ee1d66715b5664234e8d8fcdc6329195c42661e28cc128341462129ab7860839feb97677efd93c9501f65800334606570cc926d8f17bf943d356d9988eea64c4a548f42006c045384e0c7aa4ac74c85d9689e864e24f3a32b5e560881fbb90fdc2a1e7647cb38bca197fc718a9482cb96d3d9b696509594fc0b4a40d2f03b970f7022aac1f938a079ac86545f0526a010a23cb9509dd7c831a6d05b4a429ca36c1dc84c52fdb5df8c074417771ad68f3ffd5b076b5a6c4a931a9db715abc6dbd7d1a7cd786a9b9e98ae006b838096db12b0b508de05d580427d27726e295a779a6340c24a4f6eb7281d15cc11018201301553abcbec53d6d504b52e882094973576d2b172f349a56976eadb48cceeb6bfc84fa89259ff3ad316933617721d2d030237b693ce4f542b4f87b38ed22351738ffa4cafad05aa004919ac076f727ca09b849073d832997e1f5c6925006be479da0dea4d292a9da0112f82c62567c2ecf172fd1b6c67ec8be87b317a2755c80adde65ff17e83e0792d10cee8bdeafc6ee3f70dd101c7ff4c37d62370110ffbc6e9d5aad011363fa2b0621b7f65264a6f1dd7ae21708a3f1a12f8492a4d43b136d9a1ed065c46924742f8627aa8c690f8fc23257fad80ffdca24fcfffe80f92ef6d0b27dca432a235610b7c6a028099470ff0420fa6055067c585f395efeb6905fa729daf9de553d7b9ca2b20942043e2d208257d064da8479cdb18719530a60a5136048fffd37edf373cba8f02ea90fb2d064602aa6a1540dbd2b2200dd14527e2f3cd5b7dc5a9a4fe88285b7f7092d095429353dc7ef9b03b3d3670274814fd8ed34088274d73413a80bbea2891017de433428013c907c89fe5d105bca0bf9f90350dfc688624c25d4ec7e124df67ff50ab60226c4c25e09a232bff98cc1e44f353198c268666a92af992cc0d5f91a10fd8563abe0a01a41d808f6956e3dd2f5dc430c6c0855b3f00aa0f1412a7137bac338c604bcca3712e7c1a0560e903b89ca858286d1da0c894f2ee1433cdf43a8e9cbb90e6bda454c862ac70d4d59926c92c75dab978f8ce0252f96f05d1425568b1639a38fca05c6a722dea8215451a4ef8d592b5c8393fc73375634465e29f9e3c52dfc529080fc78ee4d09847b7d5c85a8868ae3c8405f4dc21db8bd0419379fbad9c7d5b158ecd4c1e29d473149cd81191a05083f1178526cf298f610367e239c5fe80418218247d4939ec30a26f799bacbad2955186c81145f506c8d638b0746888e18d5a86d661fb9e2e22d59a4eddeab688128800e1924bc5cf9675dd3cf5142613670aff8ef4e54fa8710787de1a3442bdf22dc6779c19dfd91923c3219f9164e8b60cb538311979b895ebcb40e90ba7705f35baeb67277ff94baad3d527074f000c26c34d8ab21c3e0976345bbc6da4ad9c421afad939f636a017a49882ace1750db2b63b368a216b04a146dca6f5a42b526465354a37acd1f814da1a7bd1c58ee6bdf3516885c7d3288eb352a58e2996b3fc62f2675ca88a3f307a2f98a7d76afdb50d94025b6e991d682b742e20071f509a07eeaf360815b797cebc87caa6df57fdcaba4fc4e16b8bec2990dc734d699a43119a95663f05f975d121a31a3b1019e04c281c89f249166feeebeec955c1e691b2fd6e1e1aa26de70927f8cf48facc268be5b138d30cd33ed77e235df60b4e061a5384efda0de0c3e1399f65a0b831ef0e25d126fdf941fbe909f7d170290b8cd90b1e72bd6338b2b5e2de40af1932c8b1f10d703894f6c46c0a1f4374cfa4e048d20d997417ea8a99f0b534b63805b24ff0e064c94131326bc33a9b8b1da0f4946d1a8bc40404c620a0eb4a9aca54484aa06b9fa5175196cb56b69ec447e157b865e2cf7c099121d439689d22ef004b9dbd8e61459d90e981317111049e8b6044d0475fe71524b5d91fcfd616a6974424b9e8511e9dd2fa88c62507daf79e6e891f18c1f71efa9e2c414481b74fe648b2b9356ee0b77c936a62a9ecf0488a1bcbc6189339964e3c49a63c919acba60f7306b60c26fad23c39dfac55c5fa287189352cbbd5f9a58ca24216ca16d5b3a13ae5b26dea617cd3cbe8b04996d4de97e851e0ef151e1a2210beaeb9a5cd205ae57b1875fb785666b0900129bce476ef0cd20ea427c9b3b28515175859c46a7cded103290225472e96d9f7f647efd31bbafe6686a0ba5bbf649734ef2fc28b11c1ae9c1fa4b6963a18b5236684a49e65ed3144d9a33b475435cecf292eaa8607ea50cb1d6de2e47864e4b20cdd49d22a553468b9128dc9533ddb91a5188d3988f305958df0f7a66d009601c5d01fb98641bd43b42d4937c3fc5b79589605b01b7b2f74051e09567f6fe23789dccddc7c72178e69525447edd6982aaff90b4cd350215ec8d43a9552c019be4839042ed44246afabe9305911a1be854f0942b2137e91bf9dae14d15f996339401f98be7ca53c07e627d620525a726f079cff128cf945a8558e5e0e79e4721d4826f618f1d0c258f5d425c5a55f937fc1a6f68c582f2e2db4565de068a7853c8372fbc64a25eaa63ad168b28737d23cf0b7d3c5ab6fbd31d2aec6d569892f45a023895a13dded43d718254f5da2fdf160b035392031e17c553a789075f63789260a6abd87dd27714af180ec558aa0aac2ffbfef0290f1b5d1e339ae1895b8f1d1e0c7508cf3c22559345910c2687e1d1f29d29729b851dba0d2fd18beb2d5dac57508b58f23d4a00dbcb82c06af7c60f0faf9013930a60e2ad766c171682c30a835632a008a4d184c45384eceb42484a62ddfefab22d31e93f6ed38a0bbdbca5d96cb80857a0095f6189254d0ea8eefaaa8395d338db6bb60af65d55488a51b744447af3282082b71f00b92227b27e43635a036195b3a1ccfbdeeee8e7cd5407f45ddd3d54794d009961823d81a647b5f1d5d83f297405448df32cf2e7046662939624de687375a129b9bc0ed9713c994c1dd9c9e8daa1b38b772218cca16c7827159884730c722e4d75152337871d1cb73b7194c863377f3f4edb6316d597ec32c76953e9060a3da4ee737398767a2ae0209d665780b356959b7f425a9d722659759ab6925f6f7295ba3a66a75850669ee1fbcb4756a457c587589b5820f96e2bcc685b675057e7f15564351e1c1deb2dec055a54d21c06da6d414885a8341100d2cdf32add35b99cfd352bc3f3bbea4b0fb7525d37b8d03d7ffe36c1f907853d9c13e0fb5d3e8c34e5e08d4343e79aa946b07a28232d678b87aefa93b6f10f982c4b43558d06493d19f286b9d431b97fa6e8f641d54bc081efefd29a030bf10a0d42312070c192bf2fd0b459b616d30b97fe4df18f2e905cb21a3bd50bc44814c727db25f7c22610498ca7c0544830d00a5107c235db834dd22b51595aa73a5141596813d90765341ab82a6f886833572633cdce007655342b252828b140f393af59d9d1634c7a5f2650f2d44755c863bf87f2dbe3206c03c67880db80d9b1412e875c08fd5f4a75f1e267b7cf850968fe09973718fa86ddffc1a2fc712edc93d7546b50f08a9d90b6fa9da584071ffa96d66684d2dd9afb86faf31209feb2bf6f852e2b8fb5d606816787024a8b227bab4c36f2c985f659c98bed911932981bdc2e1b7a8b31ded491d703b9b1b2138aa01fe4bbce549fc33b6d025e760dc796eb961d620ed6d5f2b4d5f1052f411d0fe5d72ae4ff01b71716b7b0388cb7ffeb0633d1260bfd584bd3e5100621952b29de5478b7f89fd32f44cb55e4f940a21f3c631e1ecb63c415bc3affdb23659aa0f1c28adf3a7457fd88025799b9d746f86297875819dc1f1b97b7fe0223e99209348159c432ed2d93a43d98021d7f4636f0af1682023880849cf1766c7e1d5d172e5bf5c6553902b2c7888e4e3fc30697a09b87eac876d4f1e82904a132bab355b2b05e3a1b9d05432ebb512f6eec0ba053d09807cb19d6a29b562438a12e4bed58f4a29f3a4cea5ba8858591f6c193b0dbbb0c8c4bcbcf719fd8318a6d174c807e11cd25ef1c1a3f6a6104f82154e36193de39f67051f01c06acdffcf4c6d4a10116f395aecec64b788e6fe063edded7c32a58c7eed539686a651f3014c7b82c3df8d75c7596f2eb30b6adff7d90e5eb03892c60ba302a754ec286923165c1fe09ecb63a4fa20e52d3c638960497416e7a5c74a0ba1049286999d9f232357f6dbe3e441a96320ccf12fc6fccd71e572f4b02ff6b65f6a3f27098808b1302e63da5edde6f271dd8399a469303fd1f3851ddcfead9643c16695a3e61224f1ce40d74b1232ce550316bda3de81241f4f56a7ebc12f790c177c603f0d10ede8cbb81c0fc6db2f9f01983aa7aae496431f1c8a1d47eb4df40a7967dfabbc0a14f8ce7503565285ab050e15640b8e307e69f27a994df5aae5e43f1024df7f485e4011b987b6386d5f44de56498266f90bc4d121d768f475306850a7a99d7fe149b5e465eee63dbc94d130f2b9b753ddd87e6fb3524115c9d6c3cb676cdf4d187f79abee3c06e67a049e1bcf188aa7f57a46cf5f2795356082d002dbf671e4af70870823f08c22ec3ff9b5be9bb80e9c7f889a5c8daf9573c2b1906a978fcc23f1d40fa7a2cbbaef5f3c80b319fc59085a06e550668d064ae92f6c9bff47935420a7630c1eb3eabec2ee715c440700916a5a57e051c7ba07ebf3a0d4e3dfb90ff4243097bc407ab4416e9e693a82adec6193505c915b6cbb35121c38bfb39603058d4730cdcd7eb6664f4b94270604b53c4d5235c5554888f027460cab3609af08e125dabcd98a0d2ea3cc57750eec917d2d655fe4df9d99ae3dcf21b7186224b37f5633d1c3bfb86b27f04ed8b6dea5695e6d93a9f52479682e1dcb5e84b17822250f6f5e79504419ae0b60f53eb922b7b1f461e6c9cbd5a6be6709a4f563558ec229b3afdf03c5dd30019b2b9d5128735a93b91b6df0dfac8d1d6c30044694c1558e60a0b0c9a809a3986c1b5d1a984cc07844753e58fe69935c24b454d97f52ca452dff37d4f8cd6027ece7010e96651bc65cc155bccdccdaafbc4c4f22cccaf3149f9eb829a3c97608621c9bea35670c51a9940132459889a3f8260f627ff7a79e479703626f1eddb07ceda50c0a7a66e6c63bb488e603ffdfc7b1b8de51c13666d456733b3da43f8db9c6cab1ad0ca796c29f97a5b42abd1135273756099699ce980a5532e15fb3c4ace34a263de04ecad17c2ebf55771eb9b95779d82a4e395177f1ee061a5936e1e9ca957b3c42d7b9d722ff0a89de26dafbc8319a561d1503ddcc689de32978165d3b1bf790347369edc091129a8d17abf35d68595ec0566c38c32a7ef75b3f5b318029e0384289c004a7e0c0ff3174bacd2c42818435cc8aef398ff38d98a7b3c5c27591b9ac4fd527eb5f0ea8e00b4ddc72e4f879c7145b7cc5a8e636df294217245b19a6bbd13456dd70bfc10335fa2589d0d5aa0188729b330c23f9e0b1e2c6a80a4b42fe1693e5a1a37987dd8322e86239b435ba31dff184fe4e80d83721ae559f8699b0f2bcf0566be4377a0f81e03a6d88b09217d3cac8cb6b40d6c7e7abcdfb6ec0888f5e0dcab5c39d3744dab0080579dbfbd0b34f5b8c95308f271caa971e2c357eaa3e632aed88733d4f7fcd93d9caecdc29b3a6faec07b38b6b0115d7f74cfc08c0c217ac58b98ce1bd06e5073f1c36f5db1f1a61f852ee4c263f14556439a47f279e3ed35e4011f76d5a3caaa80e669160a90984825d4604e0f38be110e2c652a19e7882cf582997e6e288691cbea7283940d651849c1c937d02d7a8562a67804d0b4f3dbd588fc6f9450f1a726e132fa8d07f4b42eff28c4cc3d13b7daba38a053d687d6f4651d9506eec43e1eb5a9852fed4b1276920ea50385b32714b0abb1800cb6b868b212a26b5332fdbc589334f9c9f521641aeec65b5ccb321ff2510cbffc1b18f74f96344f3b8e4325849eabaa25799d7c51c7bb3b35d58074b2a07a56b648b747eef8554ed958f03badd649a4a4cccf7df9c58c0567ea32694f90a45f108d1f027804a13cee3184c138280a057eb41813f46e55b5be097790c1a12f7fd5acb7800098425f2090edeacbdbca7776f2d33281fe355e6131d03e3367063b5a3cf10987b110b7e805b1cf76fafa7d3eff49d682f367f11bc21711262dc8836724680428b2724563877ce449d88d257bfb8b98799d1ac94d47d8341e2e3e6dd744fd533f7c8bb5772f2002c8d693228775d87d981ec354dd0c8dd3ff2f8b663010e98de6fae125b9fe4c1aecba619c3b0ffe904e4c45c9c246c8ac029dc2821257780a6b34f6ce8a7ef7e31df286ade5569d70a2aaedd2874799066a636b6bdd5885ac6045f9d8dc4d3cef3b3691a08c58f062f4c22ac4df76926770332b6bc33d566a7872c1925b20b66c656ce429e039c20fb374f03f8d8ac521adb00fe1d1df8d5ea18cf8de023cdf747896c92656573b629c50f1a6e741fa9b51351c7bdb4f3339a60cefbeebca945bac25aa10652a9b5cd848b497db412eab4a99ba972bb78226e4d005ec1256c7475b303760e6f3b6d73cd4b08bb30967959c619b2b512c33ab3da80a13c85f67f082e0cb25407e279ed125abc8d176a479f3ad99a35fb90285256a11d1662abdfe5800b2c5b943f0515d70b5120dcb7fdbbe9c38adeb07ea81a766dfe2d7032f3bdc223c60969ecc8870073c6b49fc110d8245c0327003a7a174b96f9bee3dd98fa4aa91e90c85cccb561ed83054181f8a24f5fc05c3d5e62e2c68763b5cbab3a5b38bc21a8cef0122534a1aeeaf528d0eb9238943215055607452c59830337e594ddb460f6e8e38f0a66f28efcfd9eabddee283ffb16b695e36b83217039038bb84403aa55a471ad98fd28dee972209a3c348b50c217167a20ee98da290f1afd73156b59566119cae5d10241d6efbf73295b2a4861f5d030400987b9e34bcdb96d9ad9d3adbf1f401c7d18e720ce5f84cdd51a19e95799dfb63eca8ccd3c1100e67753854655442f2086a5d8a0c06f78bbb13e04a94d38fca6baa1e309f1598ad1b04b469127ed95c19bb4e4511649d5e471a1663980feff5920dfaf6bb354540c42df909eee4bcedcfedbbf1d91a8f6792ac742ddbda16ac0ffb1a9b75d4e90fd7fd30ffd55105981204c69f984a699a5dcd630b712002997a9064fecc4978d0a1f425926b6fb8f905bcc9c736ed92c1cc11d64daa2e14b7404c42612a81f05320085deee92ec7ff33c96a08fdc4f3645b6086353d4abb4d57c974197e3786d4675204e70367039f9e55ae145986db6b742c44a8b67845e2dbe946cbdcb5875bd6d20465c04883d85c599bfc932a9807caaf49e24c73db5fff061e5afcf65b0b4596e45e54d6ec94112c06a4c155c49eddd4a7eeecc7fd17061161b5cd5c2996fd9a0479529850866de46e8a488450eca463f3b8e40d29d6334df49394ee053643d390dba3e29645a658ae858e4c8f942325e8a3fa9f8e413b16e6428cad3a2051f68adfae6ca3788187f6410d5bf61ea7362428ff38d4a53a03dd083683de5c2695586d0f5e990af4630abdcf893e96fa26f311930ad87ef7dc88214720871e169a4b7f4b55d1740dd93556e2b7b4a2d5673a149d4a34e8dc68a84b0bc2a1877ab884219add4d5a157b0f4478945d922044926644d07717f789f263ef2d52fa51d9fa0bb2990cc77cfdb310164ecc2d4708dd5c733b82e0ac6805957b8d704d238a007e8cbaa6b8561762ba9baa40613abd0fd110a4401019fbf4aa689125217d4b59b75cad86c88c231102bc84fdb819cd0a22ac6eb1a949ade3f0f3f984cf400fcdbb8e5d2e8ed16138cef4e722561216f3be9f4572fc90704595584fd29a8d9380fd2f896cb94804440b03b700257e8e8c540a9df96d83ffcd4cbb8b640c9fafe74ed8b8f992adc46298dd127f9bcc7ff8dc3ecf27a87750a6a9d003c3b9809691b9edfb022e58eefbb11693a309446fb0714fffa65e7a9b29405af091e9e9bb0c58538723a9cf74adb46e3d3bce64d4ca9c286e06bd1d764bb9707131d7d12b1e326a7b8db7de138c8ff403352ccfdf53ed89856e5ed9fb5bf1e982ea39750e6e0ec441898766c0e51c5c341e4035a5242f09d35656488c7fd0bde818b405c1ed68f25b0ea4da7903dba1bff98ef8e95d0619cb0d495c6c1da62c6d9a6f923c7cbd5859f5b808c16cdfea5f1733235fdf9f7283d6af3156192fa8128d7d0034a6e651c428bb3a31006afd66116a72eed64c58dd634d96c4c335949a3bbe1036ed5711c18e8d1fed5b92fa33e1287cdb73036da82fb209f5223976c55eaadeb24cf42b629054453fc06c4bba85e885af6308e56f5ea37c9ee127eb4020090b4e63f2fd65982e6d819d1fd67f22255e3cf3d67bc8b1226e6b5ac980f8ad247bb8bf7316a9c985774fea707188318dd9ad4bad8018c1549a05caf2b60ea266a00a0c276ac30bef59325e9ce77f898a5e6e52e4b654e4e3c9d7a6445bdbf9be162609d98ccfc6ed4ad03293c22b71f77f89f956fa7621066b35161c413c0e29375b4974a3f7c282448f47b53eb37995d3baf776e24671504554ffacabf1b242d3fa59f300cf2eb0a1fe4e04ea947fe27b9b4f0a4fc7277408dce9db16ad94f348d06506fad90938fd377f5a2d57dd0d79f168c74c948f92f074a2072758e4745d93efe21eeb6ca087ec17c52e743651a19775a6ce444eb53460c2859502652cbb3052fd93e071f3050bd09b75d7f562f95226c6f5ab505a3678683a56e055d7ac8f1ac3808fa35c046e2e6bc23ce6734c1e41aedff3de256c42877fad613e720bce5d19ed2e5177af7529332ed883cf3efc202ca7f6541d26c5c0d51f6ad6954e7fca2729e6edac2d445de13e5aa5031c8470a0671b5999c48f280f54f1817e95c95b59d3b595f30619f8ad768ecfe8d47d7b251991f0d2d06223a8ad553c150f47438b47eabdbbdb2fcd5122ed6c19656009c6b24c78542c8e47469436ba0d655a21ee0a42127897c5a1fcee430e40f709c37b5d0a44782b224cc1eedc5ab22e6f481f41d2ea43c00a60b571bf3bb348605d5ed29a9f7db0a9ad5846c9af2ef1d8875d127ed472f4ae591c72351201ac20658fbb9a44d5df642061c985147a6a09ef989997f9b1357bcdf31ce8b96c598fa371507932ba3c1c9f323966e68667b3d41945779356043399e04e5fb54cfe4fb27f4e98745bd6acf6ac91f8c528a67bae6af4e5215ab5317c9a1a8d4aa2e133062f5117bee6293543073924decff1f6b66b2647f3cf9284a3faad4ccb93eee8cc9208f4c1197f64edf23af79d6a1d1d5a3d7a6110c22d1b6724aeeda23279caa3b61667844a268ea5454d1f7086d77060346fcb8ee3d1a6242663b368f10403f8dc463cbdf79cb041fbac39b2b1505846413e1962519fe8665d37ef4db5ae95d7b933c1fc59d15543ca5209ad0b7ceba22f33699f69131080018cda1f0804ca57117835d85b65cabdba324a1b15a7c7dc0ede2b5ab39e544e687ecd7a03a976e87e85e51591e621cbbd7d0f2ed90446cbfccc16c53692d5d96bcdec402d53fe12db5904d9f6e2bfb9cec4a4f956b29d369480f669a3cac4b0e317ef5585a58394ba9d20671b48f77b38f66eeb940e5693638b3325aefe4e22fcd53b58f8d4d932eced85b02ad1f5a32717f3ec1e5ded59ff894a6c4adf982aaef8e1b6346dcd6d133a8df713c71f57d9f73c5f446cdede9c9b8071576aa89df636e122a6537ffcfda826b8dabb31f537ca3e46b2977fe3a921b63ac3cf9a28b09d1a89a5290fb920a32d759491476f6119b6d9d4dbf8886678461bda817b730ce2dac78cbb1ad0c9b468e3ce61fe638145cd022cfe0542cb4817c0d211b83f123378a0fe9aa6ff23af6d418d08a686a8b4a131ca98f43cd4f6644b9f6aa935b7cba69d4e30add543e84c6a6265e9ff52090fd46904b74ac95fd6d48d783a2186808f9ae6e13ab14e80b79792a4f4a6a48eb41041fc24b04e91e740fdaaa2893baaaea91d128c4698c4617fbc208870fce49081a98ccc0f032f2ce0964d8d3a3ecc7392e552658b1d5b6af8f916c831c4bfe7243ee72f076b85dfefc0b297ca658ae18a8b43473cb99bed5000fd97b699000ef7b868a044f09b667003f6cd3c28bffe16a4cb9e476730281f4d426f68fdeb1029b940f240288388d7b9eccec9bed9c57bd8d637bc781f3cdd987b93ea019f217f5062624f87bf41845e45f5f90443235095b5b3e4a3450f30011508aa135f3ffa74658290c55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
