<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c58c255bda7e3e0f9e8ed8d493fad4ac61e08cc852eb63c535e2524d6bc9b8dbe05f016f45712e9f2d7d2cb61edaed1c61b1704473e85dcb500e7da9235fd834113cf2fa2a472709a67baa955e28dd6384f6bb8d05d6f9001e6ddbc40ce11395a65861c9f0b4c23c325537953bf83192d7045f13117eebf7d1981c9d31f3e0c9657078fccda8b1fda7c6e050755c17ead015d1b2afab209a6d4cf6a1ea6e6533f665e152292161dfba0b900885f21ccb806bd251db6d646bef32635667bc8ddcc638363f4cf625c02ac2252ecdafe4f6e615129981e6d5d2843f70425702b936f71e0f606a2904f3eb1525505c7b96f8497b20054da07afad06d1b3797ae6037286a0e8768f263ad4c61081bd2b1e6725f81efea1d697411c641477bafb2368bb852cf2da901f7f32d0d5910b1b46bf3d5084bbb3329195c989dea6ac0acf9bb9ce343ee18a94cf4144102032d06e3aefdd034039817331a005df3947bcd1c91c420990692aa210d14b2f2a2ba460488fbdaba531ffca8ae1630c22a93d38b8480460af2838a34216e5b504ec500b9a8ab61a51bcb1f719aca8f726589bc281462a29d4d92539690a3e524025de2486c288128e54a63fe4c06de63f78a49d085a6cf6435e2f3d91cc5da5f6899a501ef175ceaea3b3d7f78d7ea02321932235f1167e499f264c1c2cdba37c1d73970640bb6aef383ee9d44c59f9d636fefd40e508a79eebebb9c301898043969328922f8096b50485b3a640b4954cc6cec377113ea778f696ec49db81b9863817518e2982d51abe147f8b427d526863b7b2aeb8f003188e1c800c1190fa809dcab3cad04039f8946b107e1bff8a997b8e6bc0b550b74d6d5687d618e55c561bc51840b1739db4df695ed5a06327daab0190f090a5f6457a9742362de4d0c4af64a2af45f8d92bb2ac7a3bb5eca092d22148e8d7d8122dbcaa8bc3a5a54810aa8ceea635e298a7306640ce2e0c4fbceccb42edb6f6a9cce1cbb3750a9088130698187eb2f850991b6b4ad7d642fcd8c2ebda9b5489a6f90566484cbb8dcb295f5561107374cd85549d68ff47d80ab93aaa7cf276e8041be485a540cec1cdb1b971554d07a761f5fc33e6e73abadc6e479eb54afaf0916e11729d1286670ea2a924deb00b25627891f994af7567f0044f05b99b4c2a61ce4953c34412e8406e613dab659dee6a752ed361a79126d7d042d50778755f65c53ac6bc6a863c3f0792da862ca19f15d5de853200c44bc800d7604c16403b4d2c354f686f0d30760f6447c8684767e5104bfb0deb22718ff69de2cd5735d45a98e112582c6cf34d8301be1e50056dc62ba7381f3779c884634ceb76cd3c5f19cca5c4112a47914fe488dba666007e245b05a160e32d394876ba2feca2db84384e926577962420c9f920953b22e2c52bab06dc7b5ba33f91c897b06b246487be9db876835639a969c1d5928f2fa93907dc317969aa15e5d7a569531e5411e63a5c5734b45722c6bf441eb423c4436cc6e6f97b143faf7a38645f8144f4ddd15c09922bd11fe032c204cb83c93b1ddaf8013c961dc47d9c420f65a0c2ccf9c3a0ee2b3957075cbbe8f588a8c8adf0e8e6032a355cb7393390e6246bf45bb53796c97b3265353098685228678810455971cf3e82c6d80b01dacce87baf4053276bcc9f5c33242bcb8a4fc0a485d395ba801390188fdf33adbbaf146fbbf41ad83f342bd189c0a316362b9f81034372b09a6d5a5fb3481808670b88702fef18adbee92033130d60d32748f4b3efc78d68b9dda43eafa354f88141b91e2bc303dd73d7c35759edf4021a886d7d283d0bcd4a67c4fe5ef404c466cf1d317785f6b4e797dfa49a6f165556f60579f876f63ea07eac5c064624be6c6b80879b5714a7824126f4f677de70155cf21e1f2e37e639b743bd14412a80a3b2bd742f12d3c6df4099590dcd1d426ecac67cf991eafd4a406027e28a7b2df33469d1dfa3d6a833a9b9452b6ab1c7896d4a995c58d85b50fa9fe1571b60574de3617f2181389fb67d066de3f1bd03d3e24fbc04eb03329f907d65ce2b65851fbf3d69e2d77149c156246ebb215e22e7dd9f73db6417c7dd9808a8347bd9e0388fffbff3bab7932f3f6f78dad418ab6883b2503de28ca871fb4772eb1019b47dee72bf082673f70070d8a5775ab70c409a473e4772df8cc6d1208534488e3a81309e5f8300d4bafcf6599479a5d6f4c2b48b263a466dc33ac30061565b8f4d1b9aff8a83cb24171325cfb6f41034aaa0846034f7dd7573e32b5eafd29c876849efad0f983cb945f7ffe3a9d3b09cf41b0bb946580413b35e1cc82b3857093b23ca74e84d85229f0b4935573926921cce89c28ff81330b40a1b4b069cedcd18018e3baeb96db34e231c153c8b27a83f616d9a43600f6e353f7bbd4868fb998df93c16c16d61b8f223e5c4431954d6a16be8dbf8e16ab30d33c42877ae8e298f2a7ec7d012502b1b71f6bc0799f42f33762658e334811c3b82cd82663bfb8e4d9463088c94444e132927bfb6b0bfbbac557fce3fe696d1f75558e12749c288db739182d36ae3e20c79ccee96fd294d859e76a458d3dccd05749f08dc8c0e44e880b015a010ec9001dcd45effde93dd18452366661c40f0cd90ab46ecacd5c73b23e013850eff28fab7cc26e180a4fa1ed5850e056b32658f6f1f47b7ef1cbf5e17c409112a7a3e9313d1867d9bd70b6efe9408ae8425d11c342368162f26fc28e7f7e6ec1d3f7944a33846641710c53de3e058bcd3e84fb1364c1585d76591174140007c2eae121fa0282c832dba82b84c3b22ac2ae0df4b73504325ac40d371d40af964eef63c22ec6810eb83befcb729ffba13693cf9c3bab1f7d4f54c65d7dfc376f1cff65dd3c5ae1fa96ca752bfe07dc1c2984635c1e618482ee5df7182e424ee573354243de828b2a9d6ba804e3681c72900a9832da072aa3143e2a0893c3ef0344039581ef026d0b9a68bf3b3b0d276533ef18a2691298214745e829ee4d7633b4670f986c91da5e29f87b40cd7d35d76962c29e49ac0e5845a8f3e4ff5adc567ed42ac00709074b9ebe21e14ec5105a3a56308d0503136d1a8b28a24b2e159365e7456feb74fbc063a9b88bfebba78e784248887cc428bdfd186412a55a385f22b4b324007b735774d6b42d6d8981417063fc76e7d7b9ad7b08aab15730cc824f25f2f3f702a11e6045842607f305799a652ba99f1c9d4337ff574e32dc0a65cb3cb08cd85f4858ba3b5c07433a71cae4c392e6239e37234b8580d93f6f15ada1b5c30f63cb4b0cf5dc60243315d06158414959f31375c714ba1c57ea25e1f62b31b37f437a87bc2e973a9dacf52c14c325835fdde2aec2e3170b4b21d0772e4190e8d8957a228defaa400a7250b9019b336ae6ec1f1da27c3eaedbc432a67a05fdcc199712c65b3a3390748c829bd463ea1e5909e52114bad593a748daefeddace1fca33f4cbae397afc34e84ffd98952b7ee194511387566635820d70884f0f83deacf1a9d66f0b454ad79c1b1bc094c3d94bf59048aee401738c873d569def12da3c3bc3c4f2c4fe9bec89e62b4e4c5c9b3e3157011ee30a2e6bd124e8ec5a88683a22b5d0b91e58b6e39aa0c7aa1ee10bcef228bc517e4d20d3f8a6bf7bb407e7af184fce3f7fb08974553b137d92580bb2329d431f2a9664100d287feb99d8fff8413a3467ae4f06ff358e0da40e2ce4fe02bd35f9d0296b8bc9cce23af1338dc2f147e257693c791ea584b48bb310e3bf44d48c52d9238d6c29a3d6cfec81cbdc9b244bf91bfc333b0c078f4df7a96d53ac69c31fc5c04aa25c91e33fb2e7a25440c5561cf4814dc1501e1cb22279423b3a833221fcb91f221849d4e61c50bdd2d962895d49e8638d232d154e3c67f4eb2d808f32e909f3e6c241933ca2aa8d1f193d413acb4032d41056f4a4582e622eaa7c061549f55c1a758a1857e3f96fa9b54f0c85e129f76bb2a33e062a611ff5f88ed279d91412b0426afa32a5012d06747f4724254775fc0a3e77a19d8ebaa67525e7653cc910693c61cabfa36b48a0ecfffc42d6c6b83a18287c38407ee051e1d99f8d5b206b6bf3acf24c164fca3318afad292ebd8b60a6c5bb8682ef71a2df169c64215411a1c19cb76f496c1ab7b63f690f3ef9df29011726974a79e3d284193a51aa52db551eb99cc591eb67dd916fd0ef142ab1cf3c6413c567edef3a02a8d0d650b85432446c11a16b21ec869436952803bcf308a9bed7a0a7a0730a9d3924b68785c6bb4f19f594eee06c1c2b984a9604a4793b9380cfbee91c002e72a4a27d907d6c735692eca2abee7847713e929e1c124ca0828ffe4ea8dacd8abe55eca7a49bbd9934afc4dda217c75089bffe41042453d63a2cf871e1c06228acd3ca71837e787dec8bb52a2e915a7ac13368ffa6f4775b96a8eaa56e9a9d1bd0bcadf80320c19685ac55eb5bfdc0a0f1e5fc4df86022a8852ebb32d558f47a5d8aed507623e25887cefebc87f0e8b4875e3bba4d7d8b64760a3cc71449a74b7c858f8a6013b51f6b46ccdb3a6342fdefe9bc217b7b12c55c2ae203311873e727342c25b59e28b2f1585927d315acf777b98c10cf959851e91e37107388d05c3237b18f3142dea5c382ef190012c94a006705464826b3c29ec6efee05ab1247d1a6bf63278caa3988583864482fe0678664869ac9e7d98e7007580eaa63d8b5250594df16b1e5171bb1be10124a6c47c3ec5707bea49c8ebd041f4352310729facfa66d801feefcf986e280e8766e68fc68520ea3240508d5bc33dba4f7add7becdd7dd542e2f4df6b99061b848497664e6782b4c39e72e6c690cc12d6d356ff0f04f7ac57a1f81dfe6cde424a606d5c60cc7cf549187d51f5cb44b52a595d2bdb779207a0b03b791f2ec0c2c71d19799860a71dc0e6d8377e739af42af420f59f931fab474e350088aabcd22383d9268ae208c72fc84d299eb8b10816be965394985362519219b2c9f04afa09af217dbc79d6874f50bbde9468b7f08daa2550b83ea8aadbb856f779e362490a8ea0d7f1b14393604119edf6150cffeee70b093ad12ac165faba26d97ff007b955051d750a8806b5076f8e98d4999c72ddbc7217e3b2f62a48d5ccccb37e20892a14aa678aa51696182ef7f91ff947127f53f9035de851081cd96fa8112a9b592ad228db473a0fd71648205dd944c89e14221e42729f865e6f2d2bb96e21287298263c3a01f40f620f508dce2f397fbd2fe5d21fb98b215373e431e370608d2aa13a4ed71cdb0a1bdd6f3f622fe9b9eb362bf14fd398dc777c25a911adbbcac65091d403ce18dbe09a18f5a228f5613f3442a9d7fa64703161062b1352e468e042fb3a61b11bae8930c2c51c06a164269533f0684a00c28050deb70fec7e35c04b183bf25d6c7ff19a569a79e5be393d2cb3ddbf572007c70964341b2eafd1c8d9f184ed55592b942dcec7d22093dd887828cce7c2ed05cace1790bf48d19cb5920b3b8d0ce2d4a71a52068e929aa5acc43ea3d45ca9f334a0f2623098eb38606b222da86f5be4cfe5cae38fefeca387fa690d92ea2fbf58eda8ec349013a3dc50db2cddaf25774a1d31d10be1d7dff8aaff7a9167e2dbf713df3bd19b49bab01bf2c92693eefed77068ead70af0736870792a420fb3d33b1c003b342c89fa704ec1398de8197578ac872aab87b4f1ca4e7be795af0775baa82fe5f9c44fcc47ff4d3b7b63bc52a5a588f882ed423214c77234b7f6f32ddae9cbd2599cba74673c191d636e033a2ba7abd1a24dbdda1e79d4126ee2af09675c572d2a17d44d2aea66f44f78f86ad7d50f9d1a9dd20db4857b4c4445c1ed3e616f923b71eaecbe9e9a261875cced82ac0945d59c26ce5055b416fc5757f217c9bb34532faa041515197a32c3362fac81c45e260cf6977cd1ddde03e11300c36b6b7141735f32b7881b4c94469704a86b4491014551c00fa3543b2c1a3dc5be47b87af8f3fcdad5d678ad5aac80cb752a13b46f2cd0fce9bbc400d9f7af13e69fb086d26fcf4cf88388896c2c55871eb9423777a4ad96c8915fd95520a9140164512531c4a43a987bbf862b9e3dd9aea5431eb970c43e431c0391651ccd9d349765cd515aea184d993026d077817bfedd2a71087f7e7cffc167b956aadbc18ddbbcda147ed49718d91c7108c367a00a6d7abab484b589da476af0ac9e0b8a090d219991abcf2fce48d21b398aa123091a90e28f62fb789e03cde188bd8a238ae313c86163efe10ce3b04d9ca4432295f8715450cf8e3ac4eff9b480f2c536cf40c4e6ec3d08100b00835d8c1f8db3cac0ea31a522d1fe869af305bf8f4c9df37586a8bdf51558a93e009a85bb0e8f986c30984447594d3571236f8daba9fb30d5a7ba9327e43afd30b03f922fdb2ac2f07b15469c07cf24f8ac96a722637891911c2d62a2a067348fc01bfdffc69ef5afb3f0aec01598309abdba11ac39be8458382ed8cb3a48685369627ba345e81214bf01671fff93c629dcc7763368515d3c75d750eb3de42aad8077470fa19a8716bdfb9d26dcaef037274660fc620efbc52ae3b7fc107f0c52fbb55a6260ac54b81cba064b85144edf1611737c8333ccbcaec031a29b206b0614f1fb9491c6cf0e1432452872c9f0e328447fea04aee98776e1fab2372c2e0340fd4c025e7c52b8fb690beffc3446d3c709e741c8c1ffdaf9e60d0c21801bafb3d80bc22c3ec814166a24e9a57342a08b91d12b744f856bbfa3cb48f1ef1dcfc2a852959876d860d198659227726ce01c0d6c2ab2164794a38e6bb454321580f9e33f17877db724598ec7108d19d635d09bb19dd2c706de0784700b9578acf31d7e6dda8e6b3b857328ad3ba51e0c04ea2e2d7b6a68e0ad52465c40144b50cb308df607f977f6764c4b6baa2afe417f49c2a26bb731ca5ffe2b8585902d3671d4262430a3b419194433c0128da6efaa5f2f5c4a6cac457b33bf191d4bd86e1c27e4a88fabfdd1fcd3263b5d3a6a30e38f00e6130a5e81f014b7eb894b5c2538416684d0b4009788ccbaf56c1654d068b7708201f00f647f141ef89efa5fbfa7a6ada5faf8dcea9d81cdf7fa6805641988712ab8143a41def995090dc001a0fb4026f7a71d51725cc5348d3c7148dbf154349e45a674dcd04380bd904dc2b22f516b2253422dcc1c9733c0800ab2c7039ba98b8017c603faa5b883fb9aa8e03432d4226dcb0b9a76c3b945d967024c20d0d42925cdaf478282e3f369fba6b628c1795fcdb56340aa7eb7bd903bf742d99906670a9cc86dbc80fa9293b6141db6770f89c8cfe860b9720178fdfcad9190c5174da0b6163a3aabdaa65bdd4e84dd0664c6d6c46266fd026b26b4e0d24134812a74b6caf583d7a7edfe4b44a9240422538ddffb2f0fb90abab6596a3be1e7e9c00707720ae0204e7625374ec605b67086b731d451f67f965262988f5e5242685e703225b9b307b68672dbe7f85bf3191c3b84d3a861661c72c50e75532afaeb73de7c66a2559d2e923beafdf258c16f38ec9d466e7a06a2d716205643ba684994896dc81ac9b380099fb7542ce968fd8daf7d889672e40ae10fe387ebaacf6506856f26deabf532a48e4e4915494d35c8ff54f484d23fd6e13c35de190ce04c23091e26baf7fc6313a47deb4e5de24a890a978b47b576d33dc89d1382598fce785e91c2ec72f6ceb023bb7dc8a85c80f56fa7c28d0fb20cbaa689f422e1b149c4f243159c705eec354c9bf0bcf7b8351d8e95e52b0faedbbc2d9f7828496252b5279391eb63b108da5667b00ef71f795909c0f2de902c8e00af376593d8ef1d273c209e3b71e7a30c59fc78927fbdd606cb852dbeef15d3e689ee9d666be770284e02775ce8d7e92b954bbec63f8b5382bfe8935d987e4c00a4c3e7bc38624861263a434e09c38dd4aa3045260caaedf6ea5576992eef54cc9f3c45563b6bcf59c0fc9fc6428b57e33e39155e50fa3e67fb8d8cfc98baaae41f7b36104ab11f9f953a9b8eaaa1b9cbb8a9df920b9231ecee639a7714ad4aaddcc4a84a337f28910b85f2124ba953334a70130b81f46cf448aff01d34f01ccba4afa741b6fff036749205e01d47d636b5054e095352500ad3c6e4e99f2670dfeb75b18c4e79eed0b423db7d39396816c8630c8ea3aa05ce630fcd2e16a65e597323691b29fb95f1ae7428e282e96d3323971ac16ebc5c76057221d6eac520135b62e3d3e50cac080f2836bc551a0795051e80912f8ba55341237ab0778d2562eebc8ecea00d0f87b68c1f68ba153388218de7b9ba76aa975f4880a855bd64ec3743e702fca012106c761f9729c99e4308287266d845c6d8d0131a5ac54c47dfc3bd51a367658fafa4cfec1a8d1fb962640b757064e121ef68595969ed4579b1ebce1441e71db195fb5b82bf5658359244ff2c06b21fa735c446fda7ae48390518dcc29dbba7cd0f6a8503d272d766a10d8e6aaf2851affdaff967a15493ca32963c51a47a3ce3cece49725a760e990c190aa2be050ed926dd5e72599c65af38b4339e7b7ecca810316376cb52fab2e1cbfe461df29ed09c611ccac81c7470c488d9789ff6345773191ca0952418123a86473445ce4de6d89e36184bc0d73a1cb260eb657356a55d96b4e11af797ad43d707a510aa5a5ed07806f2abbfa778cdf819ef39da085d6364cfffba516c603c70a4f90fc73f3a93a0172effab6187bd10add7bc26b4d1c02cf09dd380e5248938d7dc858d5efd25bbfc3b176e3322525c284ac8aae034e6d2969778e01c79dbf089002abd143f90015c7e05730ef1841536e3f66c4a982f746eb2b897a3b4e8a9632d20523fc30ae65ffad605eb4eb5ed17d487b1b340eae641db959dfe15a8d2a94b609437c436060597af7eed187b7420a352bb635c64cecea724f1614e6fe6d2c149603a49055ba7703dcbaac2ba4a4bbf16d22da8ecdb8d5b1014579f775654297ca3ff151ae036a8dd06889cefacc6dadbdf4f54521e58bae13d60686e42c82492b970eaa336000c7a2f4f389430226b10020b802031d42cac92f8fe6477db122bcb67d253ebcd5a7c7b35fecc9f798bcb5bfb87b5b7a55059075320473a7993d5d592e892186091cece1b4f5491c1e056bde49d94e04c251b38e01503d5af5b6f59e380f848b154d0f4a4546272550fd530b41173e2223ae30271c1c65aefff390fe1d5f5e649c82bad3fc0966e55f2d49de33c6a10c6f310e4bd43bdb396cf2d169b3786e87cc525629c6a95672823bafb5cb383c91464e1e9579f495e6af013c3513b1555b3db85ad3ed25678f022d2d3b00b382e835ae0e3abfb56d9c25d6806ba33661c139b4b7fa8882623a8d86ef58d89582d337e1a34c40e01f966cc8e4808f3acff634bc41b5a6acddd0f5a8326c8c19d2a810cb45dae07f9c74ffb671ee8c44fd15283b628ea15db1a6f01cc316bc6a3d67ab1166a488272c2e1f0a386540c11be760eb21f0edda0be289f6281b14f2cb9245b40fb0a0cabfbadd7549debf3e8839675b2d74aba4c4be2064257fc5f28d2562902723640ade94cf9b8688b7c30f791bd0854b711be9851053b87dcbd496217dab7bbd73c1e0b5b8a4eff1272b3bfae568ce7db95d18996f7a3d0fbff867dac3f2bd4d506b77983f93f9933ddc291377d3d2a188b9a1ac960be8d1d2725943b024f048e6ba48fb1a254aa752128e1f43431a849a7185c645d19da4ff1a393b6da63449ef5f317f56f59918545ac88c015cdd3cc2a797f9f3c788512117ee11c8f4b9aecc1ea5f9f631b2119f18f34c5cb5df8ecd8307bd911cd13257c53b20d028a233fe796be3bcbdbfbdcff013857fbc8f8f859cad351f3133db74e18f84dfba5e7d05831437b8cc0755dd630d2254ba2ace1a2308a8c6b5bd6fabd4651456cd5821674cf7d9e009c2d7a2652d7631cf59865ad3a5b3166ac080ff41930a091f3686373d0709460bed3690261b9729d62f154d458b280d9b6b33c74e04c95e24b92a9e16d134699ac5fdec09ac157c228c165c56509e8919b6eac6a4daddea02802c902393f4af4fb598083a7d440b6aa7ed878cc31050d7c5258599c22e8bde2b47d7d822f549a0466ef5a34e19913af9b9e03570e6f031b9926c679c2f53317e04ec69c9fa899c96ae316016a0387273c1b7893d0e97ee2f8b3d5b7e798711dc7a00de57dcaaed46dc958c1952aea3e4c460c1d71b9b7f4768249ff8cbc5b77abdc8ec6bf21e02dec2fbf7ef342ee14eef5c658d4e241d5a4bd2dd3cff52e1ea3b321287716eca4858f081fd346b976641ddcf3ba46b2eedf2a728f0820ed3b28967f7e3f4874a220c62add6e9e5294003199eb03dd3ea3ed4a974209766a0786b1809a5fec09027d66e64adc3b5129751458d6a2997ce2e375ec70fe8d8c51dbe2a69e9ecd0b846e5be5373dcd533b435caef5485d74c3eff14886ef78d4edb19b91ada3d8f007e77814d906ccd1c1e200c82e87a21d667fbca74f86160468546634af9e5804135403d604b3c3e76678bcea68d2e230c3168d8c3803abd620a96d2f1c0a27f26ca8e5296f017af57920b4db9ae455cd84b044bdeeee6c9fc8b4d23247c0213d82076d2bc515ded476b1cea0a9f81d96c34e58090346b9e6d8871408d5a2c233122d9fddab90867f2d33e67c690282aee6f3986be48271b3911ffe514d4fab6f4b7356f518f0727d4d7f6aa2ea3fc6c56e75ce485bb43f63ff2db12bcf7204b123e4fc80c02fa7e8d32a235f288b19a6d619c1ac3d7774fb1b55928d940298cfb43aeb5a01b22ab1a68c97382caabb8c949efa865514b37a97e04fa40ff42ae6996e7dba73025b72d012469cf76b43549eb394ad2d20110e22d800512038ebfb6781b7830ece459e796c589cf4a8e4602e9dd76033cc3fb12cdf2fbde655ec669b50f0831faac1993b31e42c2cf2dbe0d2e4166c172525928386ffe0e88089ae21960823a26fd66afb031c30351971c8c9dadb4e497e39ad17a5c965729ea304266fecce37260aab7c2e2fab56fa9e3587bdbca737c5c5c24b42def0e55ef47a5edbc52508cc060e177c1ea4603ab9665e34f90e4137686db599e938248c88b6e30b07995f3f55804d8d0a68ef7661c94c3e60e77a955cec909d675d25899299611f60e0c37e145babf4f91dea62115c1bf5cf77a32562c265e36997fa87d462f15b9fc0b07a0a6df8ca722debfa01f8f72903acfbfe4183a9c1dc438bc09a665f95eec655afafc5b3e5f4ad342d3e20b0a16f635aedcc199572a8a8a170e4ba1691f406f2c315925fa44569b2a9beabdf12fdcb9f351fb763f0ba3ee0a586de6ab1c5768c3e68ade77b4998b99bf93ea13b10809e36b54e51915a9eebc9937a886a8eb6c0041885381c7e993b8bd262554573d1b36e063c6864d4a357e3bb58d062008c81e9cd7f64849b769ede590d218fc316f3b62f279cc0511e28104a5e38322e547fc779e76f41afc81aa60a2870a9d72585c75e2a94a658964e44a2e4688c0dfea08b8ae3c5d24ce7079ce842cf540b8635ad0c5c69bfb5ddbbf11fcc17a0b7d0f116bbebe6801860eec733be3b14ada9a3fc2dc8575675c76b83b2ab5f97d2c857d8505a2d042ccfdc8d2255ec1c3e9f9b620406215068c7a0a49d06b6dc3a36f42732698c772c2449b7e68aa8bb6b7cb4278be8be41ab1cd47b2b95b6ac43f6914e73abde4ef4ef13a563bcb17234348c77dc4cb75439e1ade34fdbe65d235d9a98d09c1f6d381ffb77066cfe1ee57b076703c669539a3afac2add22f96a3bccf70521868d07342b4b0b56ac547afb6cef5a3107a0690e0bedcd533da3b671666781c604672a78c83668d2f7651348ff10bf57fbe834485ebc305a812a11894c66c8b6f7732726da28089d434e30a6327ae4baba4452940bcc078a38ee903c28b03113efa4e1e326d02400ceb1703caf9d57a6e10d5b783ddff48d515c492787626876378008d837614553c22280bcf44ab1968320ebb5cb12c735f6faf043f78d27c2d7763c115b0cc3722410945b89c184ec899fe45044f808de2ea3f9ae56482589385e5311070cd2db81318b88a9df990d90928633e6e2a380c95fb4dd85486df64e45363f452851387386497a16636a6f522b36c4987492252b49d29d97be4d8a35c16cc3120d8b21692cf995ba5e94fd371e03ee2059f45113026688d179ac56a07208f66dd882235062948a227ada0f149e9f4ed896920afb1e3d53504b56311f47b81cdb7003a79dd949292b734d8ab280a123508ab550314ac80d6e14f1dfe3a7e324c11d5a8ac3638a79052920d17616a75a2e734bdb16475d30319226ef7d84c6045f19d786560e51f018a305a3d53df105b403fc3a4b01172572c400526dcdf12c63eaf2441f618c81a56c28776d8da6a0475da5b585d263ffbd265b2db84bf6db875e07590959d9f44ff15f056fb7421d1b5e460b7349d0beb91cf484f532f98b46500cb00f997c1eb21518584a456cf3c2655103d564643fd1cad1c57f9483d3f2e09c2b0026da0ba0df5c170cbe0c81b3831b83e1d40b51ae254af370cc5597bcf2c0fee8e2e4d202c591e1ad89752367fb710068ad724be46eca205f5990f1e30762d084535f8c71e5531a4ca2bb901af1c1d9a337d4d1fea4b414067e443cb71d62a87408f5c6be4eecaaec5c9f5aea4f9e9571ae2d81cec040829859f18c3581b65b56d8dadc164cef8f41b8bd633d4bc439d887b35386b369443450be733875da229fe0cf005389ccd86e486b5985ed9070ee51d92b3c1072675cfb451b7157aba460fde01856821fa87c059c18d513ac9d2e78c4023d5d65f44ca6526fc220eadcb475b25d1ddabfc03e302786c33c6745365ca90436651ab3684dc1cb530160a3662802dfa6bedeaba374eec994183ccf201644a92605f15736f71f5a925753038fa72f3fb4105daa9d66bb4996e2e73b6f6163504e6bac13bf1f735098b56ce37cc481d69afc0809b5acf1cf1782e4bc20da48a800e1f54196f232b0adb4ea0a1d43d77a0cc24b373cbf54254c70f107adecda475f7754e5cd5781f8c30c13fa05d82ff5f6a1a29f6f8b0cd285e28940b077a2fb39ed640c3a3da1bac0728f96250141f237599f9dad130c930cbff71bdc37b255e7bf80411dfc6907ab1e7373f532ea271394b3ed7906d6454a67194dd4827a2a5551f33658e0d6a823961985356af1600dfb128877e8928343ee00e0b66c5c9973be9d880f4f7b9430e3e01fc8fc9840c0f7f283f24207f925dc71b628e5fde4a34d13b31224d65770ac5d1145ac9c0205d4e86829dd88ce312d074051b97c803eb300da619a350fffd51f7862a6c840e00c5d9e54f0212b3b9e55c28a608649ef56abde388ed3f16c0e4604ce1cfa575a99216916a7bd2bccefc92b667438aa20ea38058f04e05710c8d126e641594e7dfb4cd36a0f3d7084aa8a3346a802e68637181c51b85f3ebee2e01726f117bff8d2b1090cbc2b6afea3927caf98d3d147337b2256215058f94c9195b8c546f25093ff1174fecacc6f2666c6704c59a4cd05299a965b1fa6361ee5c4e1ebf664b6696ede797082e36da832ff56110facc2f02dfa715274a0fd0ba133f5cfe99f48e220a40b1b091c51774c2931a3ffbc675526e17ff576f0df49f8dc2ce8920ab179f1ac0a0ae8ee04b8f61c1bc490e3cfe6ecba1aff89e89ca2cdebd0b60e39d641f0842d807468d2ca9cf79784c7181b9ccd53021c8f87ac327f52b36310261623a0d99216df2f49a3a47c5a23f5fbe8ff1b2ccab4eb1bc0c18281e0c1c7a3213f0253359fbcc344e481e0681015841fd40ded6698858a34bea5c7ba2fce84e4157657b6f189e205902da22891e0f3f8bff3b866f16fb1660c71c015a4c25437d52024426e08fe29261b295e1077e8adb95c30775191aefd583c3ee1122f4fdcfe1c1d94b491493f27df01f13d991449f271a5a1792f76acfec56dc18ee6eafb7a1590862bb22aa665c8dfdc8124d01cd4a37749a706e1b8ad0d3d2d71bc66b3f324d7261c642072efab46f115929aca7e796cbbb2a778aebbce3a04810b4baa22ce28458fd3727e6552ad853538aff2660f30503e943847f9d30827d70a48b7c700b817bc0737527390094da8a4bdb4ccf1fd9198df78cdfbb8c3e3a7655e0c962bb1d0000746eb0e56e9fc185c41b1486cf4fa97163900f3fc08644cdc5db2e2b6183eadf0b5a8012e748c1ae2e494e80d392a26c30ecafcbf1a9415d6bd391772cf19e096d40bda53c5949ffee9b5c4bd7df0b7b245286d4a0b2b3dc6ad2a8322506106e539728e28da2b9f44dbf62f4fdca36ed9baa64d40b50b4ae0ffdf1cb980d35c55d14e2895671299c14df48db0e74ee2de621fc0a7782b18dbe2531abf914e4c7294115a0cf578ff27ed196136d730613a7b15d1d2b9ab7cb73748c93f408ccd92c232c06f453abdaf5aca5aa631055dd65225c0e7a872789147b910fc29eb99b2b3690cab71885d975ccd782e98853c643746485858f152255fad833c323e2314d6d6359dbe441410273bb722860ce090ff907be45f8545eebcd540de54081c23310184cfa6fd2827866e1dc5a1c9e504f77ca2b1da41fe0c417fd7c622a437207b1dd8d2184b3aa3f600b71e2a6ffc892c974a493224505d1a7a08dd974f4edaa31ab28ad4a64881478fc38d20d96567e071496bd18f7c491ed17b215f04a08329c22ce150feadbcfb6b63d40562d297960c49969360c0714c36e4c545107e3f352bc08827429e4b67dfff8ae3d517e8ebe3347494a1a68e1e9e8063d7a301ffd67a08579146e2ed42155389b8ec4029251049c2c3f6adbf7671c518a8449b16a88198515e019f8073944c320f70239b45bb5b87c0c7afbd0169401498d05a78d1c3a8d82fdedfd992367b54fc810bfd7a487895aa8c071c3413b87c0f158c5078719babb5f5caa509c63bdc4426356d77610c61fe1602428f6dec67d3800c02c60c3a6bf62c3276fef2071faf40bf0662ffd3e2870aeb925d036f82fca77849ef57cc3d1e254ca7f338a2cdf23f943725d86be037f41a9422ce2405b09524dc7dfdd3b5378fa2c92d46caca2f6271604f9abe71aaad48df52cb9d9061f34f6b813907112ef51a0ff6717da82220991a99eff7fb8588c33e3af69adc2dbe582a51d72609f28121ab5abbfc0b1b8f8961df1486ba93ab678e9868469bf264288e9a697d4d7d2d8d53d6ceb2e976ce4923d47becd56f52585186e028fa7d5ece0486df8c0839be248878998b2abab28a4951175837247ffa7630856d50d9c6bd4c295fbb43a62ccd59c7895ee1313d143ce471135684e7f0f4b4910c8ecb5dde6c35008c9509bd7d42c88df6e493afe7d9314a5ce241e08168604b7ff397329f7b7cae6106dab3526a66602e448ffac5bbb49b8e491bbef73e2458788faed3d80bc66610ecdfb20fcaccb60311b2e80c0adabb414cb7d297315bba72138749a31a21302f1caee5b93fab5fcc94ac5bcb27906178cc7e482183869d57c68d0fbd225c4603caffeaa17cf5890c51d2559bc876d25a36cede0b0bbbdc28c5782abb7b5f5eada5e052ee893ed80a936c29a1af192adab2ccaed8e1e145618cf5343a9191c3205661986c6c7b8483e472b9963af0fddb8b632208977deef466a8cc8cb51b611c9f7d4d3c6338d2812c99c957b565673226df3deb7f6dc60bfb7cd03ebb261a3b332a51819bda86aaeb6d02a75007485de037b3f49d8c6304753ebf69deb9e26cdbf628129ded81add9f172664de4b0e8eaf074e77bc236c5fd58c2020ab81e21c02cd4e797b2941604a7531a0529ca0690b6e7f5e1391c7579670d73b300566cf1e9f9f8f63aa47ee22da19a4df56575e27dfa7fc51162df351213b145ba5315ae1a177ebe0adf9dc83eca4059b6698a74c34f16fd2d10ac545e9102bcba93f9d26c3f63a3341517fb0510bfe1645525e8f5326f9d909fd669ef9b13fb38ce737caaf124954556d98fb07d12b9b5d88a269596208580b46b42b1d83d0b5a8b9ab4a6dc6b287135c4e1634dbb17da1f4296a81aed0efc4d412d58c320d6392fa7df82119d5ceea7c9eff23946f9d4a91ef5a7d3df7768bd372158bd87b7d366eb1caedd78348283d0d7c1b76fbb4a8d445d2f2bbee6d8e28ac81e2a287bf465a8321317df16aa10115b8d0079fe4253ec6a55319714514fe31794c4b0de466d52c5c3da7c74446741253552262d8232a3872ad4d05644753a8bc92de743abe4c4c64091dbe87e5a35f34c17f6006215ee9d062f5f88869593242b9a93ee5ce164c3f6f0277744cee0df6be08358cf87af91d32d2240d3a41365ad46db315d294d42876b2ec204776d6163eec8284153b3e28b00c64d1ef2813f888dc43063df9e7775f0d42ab6974c4f87ba15bf72c73255498ec2781b643439e8d344d4ab2f6963aac6d06b1b5eafea4419072e0f5357b7ad70c438d66e4c4c331f7e95ee52263c97f2a6de2b539f85770231cdde103fc43562fa596e82317f7535eaee46dce6e009aa188df517680d41d69555ff711f11219e330642a7143a77f908141923c5ca15c863c113ee8701035ef70281437ddb35e2b6d4b1a073d8263e50059783417977fc79ab629645944fcac17a5e94f2ee14ef046d6bb8e70926d49c9decf4036fc71c1bf3e6d83970e4d1811cfad82860313d7c49f4aa006ed0e0f307f3153f77ecb70280e9f15baadd34b5ee68fa9b71999f7459b7b169cf1e9602881d8c14111b1b5776620312898dd4e149dc9770f79670d5c3e243d4eb454c39050ce0bbf4e4d1a1a37e36f74b903ae376c4f6085bc06b451b0012f6cd934b39ef2dedad9aabbfd32ef26d51d95020c11adaa1669f08cf543b5261f26e6ae9cd34aa37eb8e9670d45f3715c9fc7b2720cf2b964b0172e603fbc4e0283b35f3c0074a12f826c570fc534368faed046ccb688196c3d93c6110b098c67027245f5f2c375af99fec9b4495676c338afd380375b799b73197cf3879b44cd0f179781b9f227fc583ea57d6dd3ad0798081ea0ceb5cc7a760ceb78ca6cf2909f2be753e711a76dea86c2b2fdaa345e4289ac7bae501012bd97326e1f074f48f0394ccaaa4dc5392f99f8d47a41ae9c8d1428c9d8ba640fcb4d95afbca2689fd199d3c3f70a1273c2d24250b0fad8bf542d71a5189b837a07872e51eced7904f4591fc02adec27a5f9df1d9da16ba829e07c908c25e6b5186e35451b414fe71f3941534ca26f8bd1de2d5fa4bbf09b2e7e9bdaae09a4fe8dde31e1c1509632d57e709963e0a957cb8dbbf3408e8aea8ad89769f00db20f1f5004084f9b15a3ab3d862b13c92c04a603a1727f1695e85a31a1520f5601d418693cf0c3662e27d6467be03f90baa29d4f4ec703453ee09bd05f0f0558fe51f34e8d80d09d37048c24c29bbdd532e67377ddfed22773cba7b14cdff5bb6de3e0bea19a6849e63ce9d90ba66196be7ea65f79de408c26e09faa34cbd853af86e7b70c3c716580801fe908ed54ccea21506babb8c1b93aa9c17e4177049db6afbb79316db8f9dd42dd9d63cb9d908ce46577c066d33575574c3f68b8547e91362d97e82be90299dfae9aca1d89b597f70b11f92ba8cff8e525a97c4db39ee8af366e9ab8498fc279355282d9270b32e21929fe25411719dc7da03914b27e2c77e13ae6af123c4b71780ef1cdd88f8c3786932b2106e2806d96f16ba1e18d1b121b1415c8f6b1250096143c3ada3432b300a6c9195d4f3577b8ee53891290cab1a11ac237ebe5dfbe0580436436d9654609e701a1ba1bf4d2790c4de7a7686543f6fc255e9b815c0ff7309c4c9d7f70df63c461c3a0e2c8d7e63166925bb774bfd7bb9c145bbfc430f5dea8d571d073f03ebff9c519166ca13eb8356606338313116d83029f2a61f15de3357cc39243a97aaf9b98c736f5440c512766c3527efe95e812a5cd23654e2767cbefe9e56b714a56d6fc6b4283","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
