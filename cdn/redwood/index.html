<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"043dcefc50324f5fce0c00afa7600b7aa7f0f056f5083da88d3728679232001c190a67970e48af523982f8e0c9198409f40f2fd239f29f2c422f30eb926d3d1f17400ba484cc9ca6ff7946e6b925d68f4673b6a64479e2ba9f68e652b444ea5350f54d70790eb957b6a26a78c3852414886bc3b426bf20aa24d4c0c13c531a52044935ec6f712959bf5afaf766718e018f315800e7a7cfde6ff15799ad7a9bba1ed3a0411cd36db35d8546e62016925d172bd1643014760e38f8d3ea5dad72925c835a9f0a123b7a6f349fdde37d21b5bb8ca794e21466a419c26e97501cbf6dcc1994109b48394979ba17324460e7629cee532bf308cc590a06a04e56cb62556fb80af304dfb048a7b8f4716842364066bbfb191f6b7c4112411d21c6e711149f200e3740dd450e9823db636f43a268c976b82a7a498c6b8476e71ea742d2d5789f70f88bf62d340739f0fafbaed2cbda3c7febecf7d61ed582fcd722f4a1ed037df4136877b534efd435f7adc663d083fbe9d54cec03018650fd3ae365fa69b593ba85ff730fb9476f1b1ba4e874d943c594609f7853491bf791603dbfb8e4084a6000c7f1e3a8567f610fe266faad38feb84eba4eb3825a7aaaec5227f61773080cf0fd4967b929dbfd563066ab0b0a88441aa7e05a494eec5e70217851816d07604b3a451a6bfe3058b027e206caa0da6bd1d5bcfff8dada51333f03952a85de6d2bd61394d359262cbd07a821cc059c605f4564716fb203a5a59378992ee1193cbb98d42c6eaa9997895e6d574b7082d11c79fbc9532ba7fcb37348f4c0218e38d4416e48c473753e096e7528f6977256c3d2dcfe99c9dd479871f00158550340c6fa704a7dbd9ff00431eaee91527831d9c44fa7eee356e0de561de1320e21a0da1dbdea1e73fff87b97060c1ceca12a40e427da92b9a7af89740a081bbf1fbf79ce0f70f2fd27edb45867907a6c25731d56ad6cbc29c067040da1cd912803dd954da937f72bb9e3478a9886aa4969e8e248d6f051d9f1653f5f5cebb41406b678dc5a3426373e09e67cbb710a061e8336f89d25b0f1ab00d779a44cd8bcdd67d5ed5072e94279627f9a4b5e3ac1230ea28105854ea31d2258c5899cec9832a8340c6c2179710427a71114e73a3e6087380b364ff6e5b92f82bdb6a1ebeb60957fdc7e0b828e8b8fa7f904d13df1b5751bc3ec118351f01a91844cce58e062017443e5fbe76f72bcda3040c776ee67956683c1075a8470c9a96c7ed18b0c602ca53704d94e57f476b623c7c7c080fb7aefd2559f52d2a58b14604bd280078d975025d87ff0bcae8e3bd796806058e5567eac9c8aeaaca5de23d6b24967892783fe693720ca44cae5cfe4bdcb01751c58c87a1aca164d87c190f40ec3ae83eb49b17042d2400bd1593f7025d014191115937e2420731461aaaa11f80908f4185a8f7e89c20e529b0e04d046ccb7c64d00f1ddf003fed105b55d4331b121b1cb636aa9d5dd8db4c22a8be4fdf2a054e9622aa0d9f63da9a97b44eff46863065e9362dc15fc975206f96d37646aefbe13033eab3cd5ea487cd1f97c24bf15256cafbe3ed7450ea9efe01a57e9ad650398f28b3e9346f259d4936e28413cb62cc34e18ba6cd2f7110a15440b91ffb427d02560c6e179c434fca6c2c8b86b41df3013a1e6c96f9ac11a3d58ca15bd6e117cd42a11bd7349e5a725143094a24c9f9348c51bbfdcfe1e30aae53d43e1afc0443ac2235db5a956ad6da886a73340b1a6e95329f62a07debe2cca39e1d7dfd5e1807cd349464d5906cde07db254fa8c76b1af9c3da2a9f347bb77162c9dc4c29d693e01f7b0c4d6df050f91d4334a08ea3ffd99766c3b665188ee6410d70dbf442f98c7e82cbda227ac31d7f4b4cfd7a488879fe5b4e1a26e689472524af36b942d6529d8e106b9614f43fda78310057f3a054fb87ceb73e479b10b9f1e445d5330d4dc6d7955f5a48613326352091a43f3009a375047d0c49a4c3212c1181843d9fd381658fedced6df95ddb476afb37dfcc188369c6b174376dcf80692b4d34d53f4fd99d61f32a663dbee92d3cf8cf68c8c8fa0de0d4254816b0a065163d91df5963fd40ff0c32b37d4beb50e825efedeb0c59fb2ac88ce4c23a3f004a1dbc9b45b18b2cb86a8e31bc8ec0b053f645d7d8e274ebc48318184e377816876edb3e87c1cb2b54f407981cd75d25c2cd6694adc3a0be472588d999a7642fc864cc80de4fccb88647cc915c048a5589127aa372b170bf823bcd1135c1061153ec30ade04df931b04653b8b35ad133c08a77b72ffffe6041a05e667566bcbf95cbddcf54ba2001f2ec49653a195c45679ff0b15a21551705b04f53681b0c37d14401944bc4cb566183782fd6bea4d5908f27fda6dc26e97a74c488e631482f94a61769e4dc34f773c6e34522c689c5c517f581f2d66e29d144b191a2ddaa625cd132f20ab8a29899b9f4103dc5e70555ac9840abeb75a36f7368de86f15c93ed4d8b3c74af1df2d6532d94d746417df421ef84d484f925f7db27d479001126846be6dba8da4a04237a8d24a1f77a24124a4f1392d14d3f43f157bbcee88d3ff6e7ac39667f212e5aea72224c0aabd6b60e95b47135a4e140438fddebe24d6a63822e9de9197c822d1b452cca4ea187c49e5970ab1b4080fbaccce1a6d07dc672150f01928261075ce0010305d1ee0d5128f05b19ca761b22b52deb057bbd98b8c4a4f0eb61b8764daad6c164171aa39e070b6728f47c4d63f798901238e1f78c9660b43fa0553e4b37eede5fa36ea1ea0c9233c46c9e2bd5d3e058ecc7c734f750974770bbb30315719db455a946fdc5e4917a2b4a9e5889c10c7506d16bd7e68ff60026e3cacb82758d631393d127bed974d6e97ed17451cb82228b0316f0bef595d69307bc94d6c38f1f4a120b761ce340c94e6554bb9820be89c12acdf887ade6a48aae50c6bc412138baa45f5be0d3fd9a5f04c83d0149ffe115a84bd2e538171f87320fb7ba07c49c0cb5be760875bc7c41917a5fa27e797090f8e24bb9e00cf7d6d9f62a8145f23f78f6905645c9bf9421646b4b118ac9a8b4f50a5367e0b7456a6873d0385a3bcb79b3ca2c06698cb5d603f8a4eda3ccdf0503fdb820382477e99992dbc21a94e3fbb77a0c6668d603899edc96056ba66ce5efa29e9d88e7282507d4e29397db06532f09a51c7841e960c0a626b1f1677563312f355c4e201a9fb1ec3fd3e09b014ae96f4cba44f1711ff2539699978766dce30b6341a984b24977d56b4977b90e931ab0990347f77b6706d3c1575d6d192e2f21b67448f5c9792052a23253625f7939b459bc36617e1516a6527505c9e3526493cbb736f48805da199ab496c17e810ee21ddb2221278dfebf1266ae30b67da0fee9aae432cdb38f9b5165319c72599aa34c9e1c3b3465488832b33eb3b63a277134648fc3b40867cb39311e4ffdb2378baacd7eef4ef4494143c08d1d167459081334d11d325c35fd44e5fc28c4a1346d5d8b5ba8cb13da6e7a94b60bd4f57399c4dea5cdf54cfa677fd74578bab20ad6a46c400db0ecf6ad78d7971b7cb8fb4282895107fd9b5a88549c529206ce4d93e936c0329b4efe0ee41a1732fbdef7755133ec35ff32364f2af7b1c291cf0476686190fb35168ea027b5d4fca3bdb7970895ca67bca7ce8b603a64c38006611dfa20b69bbd3dd72a8b6c6fc1268f8b6e2cba4de72c3591d4adb0cd05b43ac213eb3675fa59c3c5efe81cd005ecffe9aab2aadf519ea3fe9cb17f0dc78a521814ea08a06303ceb7225169b3a539267744b5a6d61b4fd4960354771cd0fa5bd04974d36a2b92c835671c61a8865a10081a99a54b43e3c23820a92d7b03b6ce76236755e3f44e069f1a7851e13328acff81c0ae4de19f89c910f6433355bc5580a76979079c90da82701388dcc0a7a878e3bd01f63c6101d2d93ab3baed68f9c47dfa9ea0134cb156593dc5e7edf37933a58c364fa6dedb233831f219dfdf2a647a868ebbe918e0cfc5881f99379569015d6ea614abc51754ca872c4aefa8dd12e1acb7464df7780ff58a731a3f6b6db14bf43f95657058b079fbb8e1e223618b4a3596acd9f6b829cad35bf62100f2ae300560fde86c55db221993e7d51004369b5bb5af215568af023e8c014fd0a0dc0b0e01ecec8094964270664b78c201e13b47dedb12bf1d3b8495914358a2b92cbce825cb9ec2521418cee0e214747e29fa95048796e07e313fc103ad073a4e3f37ebacdcb8741816059e56397836602bf3724c8572ceaddbc51e812e5150b61434fa2331d39474db559eeee788354923a27e6480d7af8bab615b4f95bc48105c3e0df7086d09114c74e0c5fad7bb9c371e8211d5f926ef18efe702ed4f064b44a38eb173d9dbda6f67bd07d8a2fa86c2c2bebec80dc6335422414e704ada620933c13831a6dd68d8488b2796dd372ed610afb4719666bcd5230bebcf13e0669bebea69a32f0ecd2739d932fb8f4b5bee5d2129e4b6ee5bc68f5e547cbe70a21139eddf10db3c6f612de5c10f01864a14d023c8367c8254e3b925155a688876bc35c5d6ddc9522d76738c14756578785e57519f2787c04a6ba5730b9a2d82e84a347551ddba47fe6ea96ed19ac69621b61dcd2d79b3738a34ddc8e8d0d9898386c3960ca18204a6d0fc4d7c7bac1ba5a737d573fa6fcd44d8149f0f89137284ea607e3d58d4f1b0b670e9f723e623b37be60f3779fc37f18679d061bb5158672423c9db001c5f7cb03bc0db919babf96deba62b347a6cdb35c3de58a6fe0a59915e74c2dd40737aff7606e712bfbaa05e4cad85980239af0eff444c161fe993992264d5fa76d16b66d0d46a0c04ea16cb826237edb8290fe77a72ca49b09b575303527114de4dcfdca2ecfb73cce793225a70e030627136d2285ef486a10b74c3c0cfaa70d1424654de6d7892c9ae94bbc52fdb7c9286375f89e39bf2374b083b111ca8a2da232e95cf24ffcb3b7c40236964d78233a389c935495aa453a61db222af2f2ec22cc483824e664eb011d533605765516d12071ee7bc3ba3d5116df329ca4f2d1e32e753505f4ed32b51cd0ef12bda5365e1d59045250335a582f10aff3230b67a26d4ce3e5f69de93f1b442ded33f6e4d1922fb9bb126c5cedab7153cc6e2c5c593456fdcc63a92e741963c8c66d5c6bdf71e468d5f80a630454ecd8fd95fc46261c3fb608330815471ddacb27e5bdabfa17294eeaf1964ad6f8eb3d45a5e4cd5353564a247b4bcedb8360377cb3eec4b692c6334dba85256fe2167b2b746c5ebb2935af0fc98fd884e0a2f87467e7be270fb479137d911a763f6dd0a936a54f52916ff76143b5e987d0a06435312b6b520470b63a5a66ca77599e1f08e9c932903aaa5d9ae49514c8c560e317109a2c2614ca7bdc11d3c42235778c3a292ac853eab200d8e06339fe3eb6546182ae214be6b6b6f446b8e4708bf786a0b8a41c9300e46f8bc6e933c8f484ac9e1c099826e3dc993b632ab8df6ec17cb5c069935ba6c17ed60eb057241d895d2bd3b093849ee5a7fb3a798ed6225c5e0c33533315ff9fdaf228a03c43b1a72fd5cd3444409367ee029de931fbd42d97a864296a77f6976b775c47371ceed3d70fac1e5a9a8d67c441e59f74badaf24c79b68ae2457befd81fc21213e02fe3b75268d1bc757c8ff4c9c5f5ea0a381d31db266648ce61ccba6ec160e1d4d24b54f9eafd0c1a7f13a754331559d3930be5fb49f680d459ba478a5be0041081475a9c32a38bd9463731f31ec70ec7024a450251df58176435033943e45a1f1ff2cf632b6071d81afe64d4c34a65b8e34b33d2d9936e8c1718d0cabc2b7693b54b15e235dc59b188f7bff06b539dee1e34fa75a73f03c7dc11b92067f8d15f9480c80e87cada28d710d0c32d54d713a1457d623d8378880d43c88572a4b12ea1ce8a8c98231bed1d84a858b320670e286fa7f500bf7c8095db1fea3677897e21574027faf911016496970a52382f5ab78ac86a04f920673b6d766f5b3d49c2636f74c8390af671d7ac787fed5a577bb842d5adef02d773ac72a83b0bb2169b6bdaba1744da3397bc0e9277dd2a09da7f1f9a2fae7b3ea1144cba7965994491cdc63996885fc3e5ef0f1d3ea1aac47ad71c136edcba197e7a59600fa69853e7b052ea7cbb9fee1130e8f6977735f51936f282408bdd397eab0b23a62821b3cfa7c1e6e179b455a93beb80c02bee8d1b2e4854df6f5f6c8818df7c2e4fa9e2615f1c0862143fb24b3ded93ee3ce76bece124be05884f151099b79aaf87d67865524331cca8ff741fd058cc3521bbf9c5399a42ac16bbdb6fa026b8c9915037cfdea6a5fe49786714e882caf316182651d287ee46af96815b7e3055c93ad126ee37e5287592043417d206eedbf87f1f19774c9b49a61b2a22eab65cb35601f7e24edf628ff5d2dd06754575b33e1e00d8b1aa290702df4e226447c5b0fa821155e2d7ac779174e24393aa976429d67035016cd5231ef118329c0b4fd7cf4427d06e85f584a6d593db0e7fc197cbf30125766e96e01155ec3373520935c5e6e15fac6158006117cdb4b989869bf0cd8058cb5679e5a2bdbacd0ab18bf44675c88ce3857abecdddd4f975ed2159053411451d785d7188796ab059b83a72c86ad1556f45e3cafcbb7c8732339e4da71403c6c530dd652059b7c7dd72c9b4caff0ace7302ceee7533544f51cea109a2c1fe6039d87e1238ecfce4a20704c527e9e88f2134e645ad3879ca69164ffda5f82eb0763a54ed24f1a0e03c4360ffb08d8e2019291feb599b3489b7e138f6b387424d5d79500447251ff4fbd02310bc11ed1c07a226e09744c2438cf400f5f85fff3ac4e567c36cd3bd48815bb1d4aebbf9e8ab302c49d6a2b547271268ce79f681406602d65519716bd50993212476290b16310bdddc5a4ed4b4d07b24ac861391f95e6e8f13bcd8e543e7cb5f55f17cd3fd4d42b4a98c5b00cd442dee59f53663be2356f183689a60d4846c45a255d1487699c73dcc7f1fe73d5ce206e57503cf5e6a23414d903e0b4346aced01f8b93d8bd63142bfdf46937f24d785ebff846070a1475721c5aa4392e41e731374693aa75861b2cd8f95f876abebcca3bdc05136ac4a243f65b0bb45de1267cc706c9d7ac3f0e74233f0c7699ce7a14364eeb123e3020231337d6765d805e82addf7d0f3b989e1a3233336dbfb8c71d7ed617361da66823faf6a08f4f3ee214f26ff9bc760d45cab4ce2c0647e22625d98509dd9cdb839e1788de581fb3e4126a5bec6805a64ed78470e30022dcbb443d9c7cbe0d08464a640fbfc2d65ba7ca93c89c2c9a2257daaf023e95a19b5e61ca3a8f529b8aa19958e7632e1771fb0c479b54a188c281c0cd8e848494175e215d1b14ee4bd75fd63ed1b405cc41b6691847eeb57640e9186cf08ab6c10f58742d9bf7926317fc726f814c9a2d3591b4d93dc8acc2cc815013a778c9522ec97b255c993d291de714c16a58cebc7fad8052c35fda775b3d8538bf2d45c080f9e0691600c84859e95bafdc37263f82e9ddff6afac0c0cf2bc9aaf87dea775c733b6031ecb7d876d1a90e11221bf28f4a04cca56f9e85c43cdb114d70d8ba69ac72a4a8c25fff52f2e92f472356fdb49caff4d7d101c598059fb1b12f6ac79f9f8bf7e4f6c63d720a000f6d895bc7cb12724203fa5400dd3be5a82f287cf8bd52be0b17cc42387d6265d68ed71e0171c39cf5cf3d448deea6528c24d74abe9173cfa3ff1fd00cd1872785e2003fb5c20a90fc707e41bebd15c9db6f223d4a3f1471fbb010de32be343538ce04d8d059b6e7e20881471175ecc948cc8f4c0b0832ce5aa8f1604fa6b7fafc42e764baf6147a872b362596af62298941ec80867f5551566960995ee6fed9ee75cfeeada8bbaabffafdc906e9e242a1e8c4319558f01d4178e7ab7d8894461808da98a57fa48d4033f0dc961b8e1c449a1af65a118f1a4d1acd663da1f0874fec4a93e8dd978a5eaaec49332af60ab5749b0145f1c1b784dcfa0ba68d19f855a4ece5bfd9cf025fc7bbd2d8aa20930e6c26f02e790096f435477e0ddf51d65faa6e0da625928a5b2958e01271cd90bb03680b5f107c29a64b74a4d5e9aba9275c857953dbaf6bc445a60e0421b73841ca14004c919199ce7e4d9ed007c507182ffe2a6d32bff65b23ba97ff382b5758f885fd48892451962e59da5ae498cace275eb011a0a6b2904ba6583fd5ba24dfc17226e2e247487e25bb503c1f2f705976c8f477110076feec2bee2f09fe98afc5a0a8acd733e818a6e311a1863de95939368b0c2810dfca0efaf06fb467dadba77a4c3668701975fe8cf6fcbceadf3687dca10655678d4b7f0f7ba7a336b9c00b115412e97689a462cca9de8d275c2fac46f5b4bb8a2f37f465b09579aa198ce97c2ff319e32828c6e2dd591064ee8bbf88fdeefcf5bd9c21de1a85ff2ac3f9ba0e33556e6865ada6b608a76091fef2c74c60b141e50ac23879270ea8d09d68321a70bb7ce61ade933fb7a417cc2a428fdb23660486333959175c41bb9396ce8530741ea7c30614bd85aec2491067e8ccd3f2ca048bff0b2b232b6f57fe0f74b3fafcf30235c55e5fd118a592c6aba1943b4114462358e321a4fcd3a1207f270500bcbf2d32f66db79208eabe383685a13a9b4a2326366136e3614376bed441cec9d9dac61330d870bcc86d3614186b1036fc279e6debe152154a8cb9d1ab7fcf630764bc1e7d649b7c1af6acff8d9a89cac28201e5769df637d49105aab1643cd23febb46ea0a9f31cef2516d0070481dc98e7ccfcc1a6b81d39d67bbe768b16141c9ada5c8b9814acf141805c3a9d2386a2a6e9b8c88673878140849bd406d2f01103eef33ce903ad14da78b7d41e11a8139e47ebfc566d9c7e7726a4fc6d792cbb2045b30bca7ea6513e865f14f6e51785e6736c51e927fb95ac6f7c107d2557fb62922e4c782976b8357428a51687feda419cf9376569796f35d801200182b87fe965d3bcceacd63dde59d99fba2f62aa0702043719acbc15e5cd422699f57dd45eb3d55324d9e8ce8fe0fc6cb1e3328546889a6bfe404c6a89a078da47aab41fab837a8c53e8c26870dc273dc0e26e92795d5257eabc46d15ab6e241b1c6fa9ce3a582540338a0dd827a968974317bbbaccc2a742680b072bde4161592fc674c688b56950930096c4438e9b644015309da76ce326116280b95a3be03fa8aa3c4e4157ccef72ad639df6a2a6efc97c9fb187904eccc01a2ae300c741c9e6cf5b2881d258cf59c895be36445dd3e0332f272b08fdb60887bcacd816907ba0ea5bfe98a9ebd0c1c03b60be04beddb939d2c099a42b01aa5814a1c4e2209119ffefcd94d70951faa4410ce5bf72f67dd08487cf4fd927b7debd1667edf1f4343c2a1c4eb548735198e0a627e7aa6c2e32a9865fe76283a6a74763b7dc0649621c02c1aa187cbe2c6be4abc02805dd53a9fb29d51fc1e94ce466fd4284874af6ce126714c6d36c65b21ff1f9a8d9441af6f2b6891531607a419c0c19a47fae3bfb38475eef8ca132266debde1c01bfe39d796f4e1ed4d57dacd013c2cc0861daf2750faf0b096d6e36bba93cecea533ed72ce93bbdf64f842a5b4bbe59d371b79ba5dcf970336ae1ade6232555b657a4d642336fcd8241f703c1ff4c3571e199f2cce777650de73d20cff036028c19f9f5a5fd3dc980685aaa45d1e8ad5213a528110aabdc08997ba567d27c6033ac04b018e1fea488ef24dd6fbbec47c6334d92d29a4b5be2b1205bcd7051b063a2ecf3a1a2645c4bad101ceaa7a38b605ea094721b427767952174a42ba91d3deb3705d7542d1b850bec20a80a5b075b82c12902189f878b8385991e21ad79824f323f273489b7317c7607304de1947d4021f8d81a7396f09e783c8a418cdae24bd2bf4ca0d16f15a5ffef7aec8cb40d59d4b69fc153a1afabcc8bbb21296732f797f2b35ee758aca7157acc6ddc313103fc3df701af024bef73cb130852cb71c7af004adb522bbc1cd2c9667f9a1e6649ed6bc675bae0fd271c72eb83639e0c58e24d74fbbac1852e4f6e0b5d56ad8053c91697c52733f172a78e563ebd6a1b06ccad13a84d2bb61e30b051b144b9f07d81dbb53af1fe4373b429f2246e5d12415edd26c469bbb6a4b814de323e190bd905d32304cc4174636c43cdb5a41dc960e7ce48525db69038fd4ad5b0373feb4d2bf73dc5c0539c9ca190a62def2528ea3cf0ae5eb2f12728c22b3e52f8144e14a8b23ee68d3196773ff4cce981b9969abfa1cd7714611fbbcae80f332fde9d4c5ee509b396851e3817ec29abc57a48596d66f27daed8fdd95120ec5b1e33969e9109c19b40eb3c838231f2af8656f5505058097fafe05b56101324969d96c78d01282dfd4aa58a1480e6f9623b243e1389ffc6533a0f17af4a71b7052c9c3a1824913f20f07c4c2d99dbb601ba9b21845b815cb14f4e20526a62a5938c83e11dd91053d9383c0fcb959e7a571a25b242f22b15033faec6f1b3b43187991ffea62e511d108036c5cb0eb230306a47eac7456175353f0cea27d6d887e33b9c4007ec0558bd101eff679fe77975d19fec3e45d75f7adc18153ad3429e0029705faf7b107beb471f89842ffc13cc799a439ae3bbff2e7b89decd2578514aeb9b6fa54c4125856f5efcedb9a68146d3f9162c886dc2a3605cd730a5df37af5f1bdfb4242c0710a42c90e93f88bb4e92f6d44d10c8922f13d222898727f02c95121e4ce9b7a5fca4b7fcc25b0741d672e939c687ddc6526a700ebb7cd1f2921661c566cfd003a020c0eabe9eadd43e460de9fe713bd96648879180ee51f206109f87755882403d75449fa520be97637cf274c9413599a500ede551becfb2e9e16d5dbda7217e7ea17bf4d098106c78b4bdf7f1192dfad5fb31ad73639b07423221b5b1b86aa849217b215aa7d088ba556a44c9c4b3ed91ea9738587c127570d8d6bda8cc750fc6fff1168ec53cde5c2f74f719cf11986719420386b63b3ae723375b29d5d672c4af49f9ac3072f2d7f141bb4f1dd87fcd030367be7d449f60cae17a674d0f5d715c0b2f88df58c31f22e4b7ea94997ee84060d0edcad383b595ed20f0e3b27a164ff6e6e17dac924306f139300d00790720017cbbb3331c9d7d914769f8330bedb52b7a0cb306fb8b988d8d41dd7a10dbb2efac6923e7853b21c0cae3e9ee0943ed3bfafdcd7b557e914dd66014fbcc09ae903bf7a4856eaac055b7e823de4b6b46788cdb9cde110cea630b4315d45df979fb13de4b51853aa623750cabe39ff61e98245a8e2d00bb92b35f8773cb8ee16f03629e00b22147d8ec2e07015027b54138965dc9dbe07d4e31645826363640118a5c9d57cba5b6a06fee914b65b297495fc1b2efcc179a896ba5330c006ed3c4afd53b2e37afaa7e48fc482385e43dc634caeb2ddd24bf4ae9e48a9240a91a7fbc5e213fb3c4461250770bbeb10e96a779a72cd10f3c7921c022f2203f68482296744ea028f7c2346f334e58667333b062c7cc6a30c863d6a527b23edffbae2d59a2d5151671732ecd639d1160f5f536260ba5a11b6da8456747f4ed76aaa294f21501d5d3a6fe9801c2e6a75215a56a2fe00d5d311725ae5d9a5a494c46e1ba446cab658108a9947215469fa1ed53579680d552c3316808cadccbc66aa578fc8532d6b9586aba542fad5f2573003044d81bdad296acc89d0694c33b899a29025ac25a0986979ca93b43c0703ba64c1eee954b5b8391cf16a5ffb73dfabe58ab44469ae5b56cacde973563f088a5d27a82e2f84c66395c3b71edfb80a859e5e0b64fcb91523b4f5e4ee498a060c60d447cee0ade2b24f24e8317d9f2a8805a5f140f63cac866afa41871f47a3aa1c5fc49c24bbfa83ee50b878c3e4ab6edd191bdaa17aebe80f9c0083e2f07746967dd0f9cd018a730f58187976c4d28635bc82789be75ed08c604b9e52a3d6a0cd1adb22696df9c4c9c1dda964adac350df23be83fb62a5f169a964d7f65d22c822bc34a2d2f2af2b45fa755e409d5554a1180a59685342ed66f818ef63c6c267b15d07d5a8c7db75ff9712a90c28ae33bddbb374b7b7a3476ebfab151ed8e628df553ea74401e78b31d3def0229e383833ac4ea0a43a18f3446a53296135c61a6f3f428f1cbabe3431d2d350711ad3023dee5bc85ed81f97c5dc6670507a3ea77352361df34d7258377851bfd3372af42151481d6f20676fbccc886496beee242149b572d46eca06ff2ade9cee34b9d2afa189d20f954aa12e6b6369aee64e0a26f7579f382910098a7cf44c9eac6b61a24f217e51b9d1e4f79dffa179e55ecd37205d6e1b5fac15c6e6c0f445f6095c36aa4c9249878bbdba4e88c0298967269df2b874f23d8c14bb8cbe6fdb45e03a31ce3ad4329f08acf096e8d1eb8e94b530605a2531f462ba2cfbdc6feac92e6f1dc990bbe369796b820bab2fbdb4bed85404d3d876cdd477505c8a6b476865045372b3017fe26a1a4f4344d2633996c8157768d9050f8e16a33227505de68b4c2e7dae7068fbef87fb3a168c22f49866fa03212f2c6a1ee85f701808e4b33cdf9570c9167d8ed064032c2922da1fd65b04a592fc2de674ca0cc9199887c7c4f55f3e43f2c1cf6488d51fb4f8fbe4abd3ed4c60850ff456b80b54d9989042c5cdfb4e04d2dcd1ece350af23649721ec347f0dff783bc2081ee9458d1ca8ab2a054970fe2fd0b97f917b4cfabdee92325869678f89ea5faf3ae9a46a7b049030224082560eb00c2fdd7dc15447cc34f4f1299167f85e96b180934943445cf6b6d299e2ea44d40afd32ad21a402818f4d0b7f867dc3ca49c980fdbad01ad78b67cc41758cbc415c0f33ec7843daab093b1fdff4f0f4ece311560634a406a6e2dd624a4aa2185a02cd6b707275be000130ae0f09134b5eeb1552d48385ebdc4b9e5adacfe55f3caa8e8b06f70d69fcb351c8ea322c3ee2a7b9427bd96eb136c934cb9e944c6c95a083ba83e74b0a36bf06e8701dc6e007e349ea84951efaaafdf7333e7ffc1fb072838db21655118a3b3d460a71c744e90d7e1e9024fbcf9e29ca947e4aa23ac4215cf782e30b08cf884fdbc2a25ac37e3e2fc7a315ad9c09f06e2cb07dcd29cb339b220d41d9569e0dbff209a360ca42ef1234ca385c0d5b3fc1e3ec4f09936e888ed5b5d4b69c319cb9215679b89ad3dc1fe616e63660a924fd142437f694f2fd74e640d9a6d72f6cefe72cb827bb6a041e24507fecc66cae9b698b1089f879b2a23a969b7bc0983820ef1e04f0d59a1821a7f82e283c074a623ded1ee20773b6dd7ccfe4aa2e5f1691c4775b0e96de910ca75fce520d56a1f9f3622a9910cbe685830ffe34689089761dedac5154aab47f6c2f23eeefbc4575edea0d9b3fa4a20b944ae621ef06e87920b480b703779200914fcb7dacc3e91defe4749249f9be6149669f53e28283f17787bdfe28a83d511c7868c795d7314739e2122761b2d64924c3cd3d03ca73de636247a1eedcb048bd5f9c1ff6ddac431f4e0e5965c48ffd8e1fb99e564c792e80a8feb6fefe23470c3ebca7820f324a450c9c483436a266a75ecd2990962e73bcbc91b21226004dff62c1349feb3ed63da6627917cfa0301dcdaa937fcf8b56be00289fdbc3443d6fd10ede911b37f4c970d48d49807b392d89747d3534d1cecbb3abfec164736077d3c5d7c8fa0ef96cc0fd6a3924dd8539ff2d168d505eb17a13d4163beadfc5a99892378fd4e54767d922f2ebe734706ab3ae46f4f2308eb652fb39b89d01015013df5121fa367a619ea1a451f33634e1546b10ade8cec23b968793634e74ce6056af00a172d17ea33df1c27232d621502fb961e98bd05567d55261169d6e2a8ea03ada9c10ba88edc73ff4debcf1b1b183d934fe88cb7dc5942e0db6644eddc3a5631c530f21f2f445aba14338ee9d5591ef967262f49ac10809adc5376665296ebebfbc7f78a6558b27f8d2c8669b4a80c578cb627ee386e2a55fd6c05bd51ee58a9f768dce6a03f94aea01be8e1cc1cdf2bffc41483162cf8d7c35e4c13a046de6ab2665d525176cfa9235bda1f098e9186bab037f101d7710703e7bfdd42fecf716e4cf5fb7b865e8107e9412463aba383373b25ab2b0e1fadbf6a12a638c7b35202648c3a7764f787f405a782f30b3e45c17b306bb0d3d417de89e3d5e8dbfd1d8317f8cc5b4ea9be76399848df80ec2d78a435d5c9c920db329c7d0c5b6faf1d507796bf1089282bdf944ee5f9e3e0a91514cfcc183858c705b74b7a36ee212dfa19fcd1ff6fc8e04f74a7e3a3715eb8e050a2662605ac8992744a49db01ceaf405847abbb93220b8dbc72998d75e0cef7a90491c12555440cbe4a0c7f5fb3516b36a2a8281fe53111c52d6482953e7a0e76ca26fc09b87c99e70dcde35868d8d3b4f8d986098e8e732ccbb3202a7dce14058216287cdc0ff5eb25aef8ce9099b183bb8d7c04a2e1e760d67094fce385c5465933a86368f6a944e387a082f2a7be0836fc046dd01685ab56be67447bbb9ae70daeca9833da59a0e39e867e93fa61eff28a5f320c5bc2bbbbb1233f3306251963217d013fd92ce3b029bbbb17808d71e8c8c01fc60686b41b10760b9b4a0597f43545d6c8c8d08750e6ddd433823ff194dba3ef9577a0408b498c290f02aa784884e6b2cd51bdb0f38b613c1cc8e1a55f59d7a4912c2d233df8cde536a10029d7a724a790632c443841f1872c93be0109311fe6d7225cf3d4325ea98fee8d9cdf9fdec3a3cb5dab6a4246c47741166909d77eee5e20f790d3efeb5ffa454d20a588bd2f5f3d95c4ecb7d19175e04d30310954ab40d36e176a0ccd5dbdb74fd4a4e7a08e0c56e791d882f3e96f672c78fe86a5574c2cbd3769cc0e5a9f4947b078c884bc1915e1c9dbab178ecebac9eed786cfe979f7957351338e72fe0e6f76380020b486605028e34a898c71585e8c9bdea7d3330181c0fb7d6b9d30a40b0e2520459a2cf393a7356070f3aa1e59fa55b51d4f05013bcb42af16349460c29880f3ae377d73b923183e159e3273cf7d3baa74af722c12976eeb5682a7889ea3e022a84a00b0bf5a438d661a661eb2088886eef84a7f10444b6af7b14c24b761baf8ce754791997285be15802af1659d096b62cc7a05dac57bc4e76c9844164331c63b449f5b3a09b6fe0cf10b4279c381c9495b7755c62f7a201d5bcc8b47f244d52e1bd59530bc198f9fef3c3d83cddca9f6d73e1daa5e5d0772647edd39a2a0d0137984bb59bddc4205cafcc8821d4420be1895d360874a21738d8e5d6850f8d6cac2b5b7c0f0303fb559047a92bc750606cedc439ecf716c6fc60957b933d8d606c32d3d8064ec45783151e7daf001a3f6e9e29e477ae259b3e1306cd5c61e5b838fd7d7df281aaaa64a4b3f28a103f4fda374fd4b6012acc233231d2c40816c9fe6eeab19f1715ab54a6b81ede6124c665fa865548957c4a2cc6dd3e198b41152bcc3ad9c718887c95fdbcaa642ae4b2a1aa936ccd2b05514ea482b9f7bb010aa7900956ab3b49eb09932ef9d0e92d6de9677e7e4a3ef56fca3f5e484cb2d172272b5668eddc7f8f8912fbf84c82303634f21857d684550d89933575f4fc1d879f07a6ba71702f1b8dfceb7888e6d90632dab14925a68a896415c70e623e50058c72bd5ac0bc3bf7be80f81e907cf7cc35928dbd33198e813d16fb51da6ca8f38406ed0f0b5bb0f49a2b2ca8913d05fe634689417e0284e2ff49ed7657c0eb621742af7ec999717e85991328da515b9cc4752d37e4bc363d307131140148bd4dc2f75fdd3aa36f913b4f3c570bd7aa5bb24761de581acf9e39db54a45e97fc39dd798937ae43886b1c68464396ac7a26d96c1ab7148f0d7618e937f23faff1add8ed3806300e9ab5b80c9f8214b1378ba1337a2a38ca006c6e2d7ebe556324df233063cb1b6510441dc218cc5c36745f42e67b0e0726b4eceee14cd0c86d67273089b7cb34acd1f701f6e54a1864760325030b6baa71b26da2814ba7d6be803d0cc05f63f4adbec003056babadec2bee6cf871fd48e1f5e8555cd7def9a56b18357b1acce43cb2e22a0149c1d176312df03ab81d1fd2847c6de37d0c0cc33055d6cd65a2c0f585e85e713a4f2ef5cdc6374fb69bb96289ae939347813b2e84e74d60576f3e2fdce866fec5f83657a9d8455820b73b5136083557292965f7dd95ad0d5714d56e1586a7505ab8bfd0f6535857e1919b9c8597a16853586f97cfb54297cb47a77a1c62761b0ec930cd759246dbb2916318184482a56cde3a93c1d9694246f173024f9f8849c105d749e6eed25b55288e5794e0742a644793baf63b55e5f022a9418fb811ec75e0971b2c8837896b7a85faeddde0b995b31ad21a8a0e2fd001fec48d407492d676d7e33cf0e11b5608eba19b13928a214bbf03157077f8050589b08b0ff5bce0219aadd10d73f7fa0f4f4e0daf4034fd63291c09d138ed25394ed786a037003af452f95d49f49806c90d35efafff778b571b60e1541e580bd371130798a08d267b5ecd2c94887b7bca54c8147df3dba68d735d607b57db5296f91a05cd2e877644b741f46a44bc3cde7cb6b4491ae9166c09ee33b7cd592e049df2cbb292d572dc74dc1e5bd5ec6d0e3b6d8a6d15c1080faea58a791de2f0cbd2c91558f2fa3e80294e457e7166d623aee8ca3b1b55412c301f2a69e2b28beeef58f78fbfc5c1ebd77df85c7645f44f77ef802a603f4f912883719e16caa32af058356878de4d689ff00e146cc9466669163b01fd974bf6e2c809dd386da311a7cb5f5b46e89ea1dff077b4a97c985667d897e7022b245308f5d57984b91e2b196aaf2dd60cb23b90a34f37b4532ecc244d2b4d019ae4c13760a9e0a85095c7fc6985bc0d35b12ff20af32a69563dce77f5a65f3b81e99d9549e662ab32b942973978ab74e4b3a273d5566ee8a2c0399f8569018bac36881ec6bf7b1e9a7f757e82ae5c7a0fa8fa83ada4a5bda1328101e4b53f40ecc0d8b0aa89f293314690a061b1e980a050c2e643620b90fe88f7a0755face06680bfc8774adba57c6c82c935ff0a8e7eba81f108272fcff0080448b343732250c293191bca43432d0a02b0fd71f3f4485a64def94a93e7d913e77647935e270fca4866c99d68f766c4d6d65e9337a825a60fc0fe31f2d35c5fa56641d9d7093d28e941a6153ff3027a9d97f067a1eb2148527fc16dcff863ae0d38a787148c8ac4b9f7ea4a63f5f1a07384d85b8652c4964ed522894bfaee873134f25f61263dc807ad4d05d437d0fa3ba3b35b10269dc5ff04b08deed40790956b6c699832f8b94311d878eb101d0623c385c69dc45c14ad58bbe75c567545407c27094e2691172e74473dc5f046a70ddc14c4e657a4ad01ae6e0c29344407ffeb8d390c9e0a6fc34a0b9b2bdf92d1d744bfd83a5363d31cfaf0531bdddba94268fdf8c79eb8ead145f71ceb61de6680a1befd83e683e80d4742cd12f1bc7b4314172210ce8eb44803da2c1402856926977bf8547c6852d558ec488eaa7e4d29c8a67cde7141cf3b7dabf8a7e04968dd63f286c6425eb083e5ff74750a15de122a42fe5952b082eaf4676a88648286e4bf1cccb9e788fbed542b5bf222e701797370d38642ebaa5e7966836c655c8c36c2d24cbef0340ab2df64e9de497ebac5edcf22712defac698c8caa47a6d12ccc67c35e7b2a270d456be020759f1e87264ab0e47a8e9b851767ffc62a7fbf10fb0d2fd01b2ae4dde037bcb54015cb033acad511d36b0d4f881b72e00a532bfb88604d31b599a54576cb10639ffa123db7758c244d75728866715bb0919358a7b3725d3ab5dd5ef0ce16cf25e8a0d9b3b483596603db3ebb8a79af477348594982ae80e1a736021f73da56022e6e581c200dd8a95ba9c69fb45959687","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
