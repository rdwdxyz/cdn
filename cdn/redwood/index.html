<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90ece3a3329db231e8c80a67eee9ce1ee0b7525b453460d695a07112a514355cfa3d5adaea8e24b1153bdc0c851c4a5806b4c5c9d3792c9e9608e9a716598510787933fb3d258d74f127a7de6785036adb4626d0e85eb0f23bf6afd542bc319af398bd521942972dad738fb4b14a5d1730a3ebcb822668068a42d83f3a032dd104d36c7d81b417428a5364464a8a3d003f5c1bafcd469ee02c88345fa075f00f299359bd5a8a5e85befaf7e112c4cbda2453fa319e21bd8d1848ddb55356263238f5960a68d18aee5d39742fe875f9fad5b89a0178b193557bcff7c9963bf0f08d53c10d2c4dc0ee78b123738c8dee5a2d3eaed80532ed42f84e9a234bbf83a588270d18913e7c3369c3b9802a7061c7f14e04ecd3916728ae1b0f6790abaa089a2154e1e37498741511add8ab6343a43b1af1c253b3075a976bd06474f9df14c06c26e955bb7218f99a15922957034b7356f5268277fcf477094c8553278d7d2ad8c3aeca223477932fac0e956240693f0c0062c3cc1234e782a3e13eff5e5a4dc6eb96aaa9395873378df7ce39e0d6ee96de85dc7e7dd38acd3d41fb137ec1bd0b85db2009211847c3dbfabffc34967f74d6ddff91df3f865de96e9590435aa8a3fffef4f6995dfaf0712db5a0f0b565d35b6432f4fcc3b3721c618bdb925fb94a23797263b86db0e1b198bcbbf3cf35a4bab0fffe9083fd2b5cd73dd87290be66ff288ec76fd72d66fa496472e3771b2d0daf11abf8634e5e98b5aa458338079a2efdea239ede18b74d6be3a900d177f80e42dc827d6e7644e23877f7f34345d7c19aaad98a8fdab8a5a4217837fdcbdb4b5cf543a64ce917066cb8a60d74c8e5e5e5caeb92ff1cb15eec45b1ff9cca8ab4dde6a95d44f6f48811c0e3545bf050f0a0ad357097d13454b46a93d994382dd7f851676dba0f21061b118fcf6bb911b782d8746cb2fe476d8bfdca79a2cfb236f66c6668950af6fcf77889ac52d876ec867b8d7579cdc318021182b9332d87a36d937ef1b5e44b5792bcfe059ea320e5d969d1227fd4ef6ce5374da44d9883627eff7518243bab32fa1156f6378924a3a0a3052509e3f80bdee7c4b25c559ee00e96a5bfed5370018a48d88fdaa9e84fb9dc4e2c86be75348ae602a076ec0266f39666b4b8154e15f6ea452140907cfec2ed2baf08b0d46c7fa51689a8f52197dcc9c37624fcb65a5b56a6a46ee831cc785effa8b79aa1dd41cebf0fbed84790948e35017b561f84de045383d19ccf19226d58c1bf6754554519d0249432b680e6a6549fde9688b412c502a2042040364f8bd19301054bb0e3fa649257c7ca743eb3842220137aaca1637eb77c80da0a5f4618cd9d6d1bc7615c451134cf67c194fde8f383f92123269aad99647c7d5f1c8c3c52c1d402fd7fc0e2d7d402ca08342c0be825743ba6318bdbc557014c22ffe603250882032e6cbf27676546e99a9c9804334a065d0272b7f3ba5ec357022d2e0985081f0ebe02656c2f29c69863e466f12d17a16b5a5140931eb5596cebf719dac64a66ddabc894b0dd8de7694a1f15f15f58022d42871dd5163a4a88bc40f9c35824879ab85cebc704b48fa429f19aae221fdf955b3cc7521ae9c9cf54021d5ca635b41fa78c8a2726f6750e55e48729bfd0f04b6eed68c14652634e8bce06897d18b3587341d51c10afe68feee15f7b4ccb2bdbe00ee3a567b2bb6a5208747a637f7022ac16ae7a32ef6d678b4443cb1a4d41650772ee153d269960b9d9aa723c89afb487a33ac5167beebaef622dae01f849382d523d9ed6dcb1ea4878a0d8034211f10308e8a7d7fa8f737559cfe7b90104e49383ba4c5dc1a07f0e94fda305b515ab8dde013c04faec13636b9e37440b787da8f52c369bc19aab2f7cddb610e3772000bd30eba3022dfe362636bf945b2095ab253382f3b94ad46d5bdf84f04b2724f5c37e5a73547fc9e658a9b2cb01ae6e09e78e5a38ddea20339ccfebd18eaa4306c9cd137d9cff1b216ce85cdb59943338d1b7d70565abc50e0af991126272fc7dda86bf133e36fcf200b84a97f780562ab2928d50f5560c514a10a22f3fd12852f67a5f72d5121ad6504c4eabd78ad93629707785f0c7ea14d309877580539a87037b7d8be87ca4842060269dbd1b79d12dff24f630b0f94a9d2f0adc2223714e3e008f3986557c1b5e3ed91274821761497a728b7d07a0e9210a7cb1e8aeb8d43c3362108327fac268b64ab4f822049c99252e126a830637aa33faf591ade9e403e939721fca61a9a8a2334d61b83c0c56cb53277313ca838c5a1739b3829c025a23eee1d2df0affb5f3a05c2a8e2fb2dd90b51555376c88506ce57d483fe34182fcf809362feaa72886805bd08dda2b22444520491564735e2f762811206bb6a211d0c3645a2c846240c8c9616c1c0095d2a309456e2e48131488ed4fc9f33147886b65e7d9fb28bcbb1092ee2848decc0dd522aa5d31783c3727d29f84e5537536c9c47d5c6b67302fb2d87984a7032bc5ca84c84b255dbd5b72162e67bee7787df68155c35235987a7e0a31ab2c7691e77e3240373499952fe11eea073ed7a47065a5bf9aa17ec95a1ea9b35940fd0e5e86fcea9353cfb443002952c2a4157c3f54da18e816b3f4eb6d7bd7be51aa806e964773b0f0a2e88d8818ce7438ccd652106d64e8403800a28f6ef858f8045d5a7fc4d85f5571f7c1f343a125cf39aeade55f10d261da91fba4cad1026c5019aa420fd849c8b0e48bb112dee953e05bfef149aed455c303173e509d54f9b1f3b058a0897c05f3eda06be1e10b64909ecdaef59605a25830183940e16ad0dbb3f6c7be2bffb0b35fee89475ac105a68a30d4ce806beb9203898c761d3a9c089ae368197f137b51d7d4116f2a3621f9d05af5a9f2edb611ebb944e0f0d1ee013399fec1278dd432a33bf67da8b5ddd56d79c9be49ae7160eb93fc62614b753b85978047242812913cc3cb33338511e02cf4ab7810ab7ac326448339837a9ca1782a3ee95957214d9819a3b3399b4302c14fc9fa70dd5ab0be8e11382ec8d07d1756d6c7ae77be2873eed05e36b0b14fa500cb7668510af05925ec726bdc59596b98796620f9b913bdb8d89aa6e78bd575ca837aaeb89cfea4d844890cec392b3df4d0e87789e94e0d95997cca5b8622d7cff8b27d7a6bc153f9597da7957b005a3d1bef5b4c9ad4253d57af89a8efdf6ce0a0dc5053542f4e0c526ef309a08cc040e4da48bc6f2352336daf415e9f197541711fcc244888b6038d428d7d07dfffd781f5a0e9ff127d6e0b37fac90c5eb529f6bdf26a3c0b830508f0e900da5d51ff75c9cb15022aeefcc98d14c83e49b628c2bd85ae881492de0cc0f9c8e31b9b7dbb52220a70d575f294e66b1ecc4b1fabb63a47b3baf9596182dac0e77e399e7a4bd9e4299f4ad358d023d804e9cb6520b8ddf7e3fee27d2bd63074f8ad17244ff1b2b9ec15fcf307300c0cf3601d92d8756c029f31df2675ff06a3f94510420f43bf12b950f54af3b339a4223254e0ea790eb8542b9a6f0d90ed4854b3964a1a31be73a10125ccefbe16bb3a643854b2a57ba33756c5505760068b794f42a9137eb0e8086a806e18cb386d89f326e8a760fc1cda2d79decc9b5c92264bcd875a7eaf5055c92f59bff3064a9a659b955203b7bced1eeaa31b6049cacfeb445d89ed64e787d6cf78c75d3ffda76b0c2ae6e995c1464d1310c457f1c2c86b94708006628d8fde6d73ffc5150519e65ac5308b31b05eed1a2469e361c3b04e95e7b17047e07c446416d32f5b9c4ed800cc400402c055e0619310360821835d010e9c119c09fa23eee9168180abb3fd0d867f97c67dbce3e4809971c96f97299dfc04c7478f22fe4357b13208c3368ea88c6496b658c00416d769f02a00138daccdcfa12a66d324146cf79cbbd5d2d88fbade59b271e18313157d2b16b4b9890a03b977ea58853460615b1130ed00ca25cc2022245e45e39276a9aceaffbf4db04c67b3a2eed468735fe5c0587af3c4ef6a5d554dcc861e7661f0ff64381a1ae1bb24b8fc5c1cb345b9ffefce1b201630bc684e940799e2909ed85f115e28decb74966658c9e7b7406db07a3ffe04f96ca1e3db485d06d57aaca3b887b03d52ef00c19dff28f68458a7a68b39adf0ef41bca28f640a4ac8ef5b1a186de7f5aceb1afdf386bd543c9d73f83cdc34220957f6b38a13a00e55bbba4dbf70a5f9a204ffce5cd7fdee38757154c8e93aa04394a930560a8b9df249c9f1d9e908b0df4c8fc971d9fe36ffa7695209836c625839c390b3f0193d1a1c2ee9142917daf3c3d490bfbe882cf68e12aaa34b549f8d0d45fb227e11ddf659ef10c5c35c578c318759e0a68a9f0876a7c92e13c8f81609f9a8f829168b0d0431dd8c86a147cb37d83dd0e0f43133dfbc22680ff14deaaf5db5696abc56b86b0086dae3c57ef489c3adbd48335162ba2c94b5f71ed7e7cfcd0a6e1a6100bdbfc0ff0e6db1d9a2292e79185d983531d4d95ecb03cc9d7adcb160c44bae923f3483d50ed226b1c6459915ad8a2c4015262fcff6bd9c96b05fdc14318519e33e985369d7c6c1d7e6c1028feeaadde031776b05adcc7c78db549e2caf0e6ded2534347d2405ca41d95b8d71b70ef4d739035fc2de37dea34c4683931eff205fcb25db9084046dda899215630498126759641a30896b4a5f5ff2c608bd5bdb8604c2b894d5478f04149062909e2516071b23464b66f4ace42dcfd0ef4405f4179256a47af6ec13b76482bbbf86c7a079736665dcb5efa57f25f3b2d47bc5f0a99499d0d265c7d4a689aec9819fe9fb825c1a2250680f9b8d350d9f154eab2a1cb89cbdf309527224beadfd1da24031c41470fa3e969d13496c91152835df7f73918a4afd74695fa6c168fb7a3ed2fa2c5ef622188542528abf7d1fe8b9875196027b400fb377b724042b7100548baf1d59a3faef2fed6224d9b6a9f573adaecdcc57fb278e5601b1875a3c717bc8c05232e00d39026ff038c767df9425cdec712fe2dcd4c0127dc2019e28f8e7294b4f027c744430381251cda16cea527498c91fe03eb3d923fbd85183abcf78657255b7688f9d3e7f4bf428c85a5735366292c172ab95f755e4632c0f0cf1a52c8a721aa456ec8213d4615e5f3a1f0fffc8a9fa8e11ae52818caaf6e82fdf2d2d58792351f2c5ae2d6fbf6e907028132b5100bb1f09b88fe57dc411fe697d877bbd6695cc2ffa68755bbaf0c39c1aa75d83a58f6711f862f446cb303dc961d39d6392311ad9efc141a7552771fd5f61c642127d033772f445573c93e1ac17d406ad9e4af97555a1c0b17ac00bd99114d97806a2a8b9d7ad20ae918f5adce6564b8292c77b71d1afa87008ac7384585d874d2e301293aca9c86867e28f5d397336535f22406742d8e1cbd41591a97ad6a6c7f1cf06654a638f2e0ce29ca51cd686e6ffc62fbd9308ff4be97b920ef324f630e632edd2aa493481f2446bd976e98375d552f0081a68dc8222b6fb7d85c557bf3108eb0f3207f68dc10e38663ed4c13efdcefe0f080386e7e90c424c63f7e5fca4bf5401c6275f8a14dc8bc453a4bf61cadcc9d250883300143dc4f0db3df08d8f3dc5244c5917413c66fc641f8182a82d251b5cb412495ec2ffca2096f5d42c30f56476a6800c4b07679cf707ea9c44f62d121c67c1a8ec446a01be0b1ea667e063bae53d7bbe2ab65e40a9b9b6d6b570b0f970d427ded52298cab85c388d66e424a052b5dd0807df51ce4f1a91a69ee44ad17e6d3cf4621a5a42b38d502feaeeef418118256d443bf6bd1318b6aa29a1d0f5d574f207b57a929cee3f5a1ccef12e0425e3aa5244af0d8b98155f706c1ec6b4398e0ff305fe2b4d6de5a07557c4e4c27d81dd048627775692b2c5a0a812072bc59db302305d52f76610841f0449c36955b9d3b98a028c2b615ba3fc72492bb750338da853f017cf8432b454b9965caa7c7e931ad1e7c56577e7bf1313dcceb8020926287dbd2576f05c2e426efc8b0152892324c39564e4120573b850ead7f03a55aff3535cbc8edfc18b6be02f6e9a90a244f99713d1626b77c716000d4e0ae8aab101c9c49da36dd6dcb6dec7fdb1c79a4c2078bc9cda9ba6095568c6905560d1d53f1bc369ed2dc8f0525782f7d5c34cadff9e1511a4f474b4838c0af4b7426b859a1ea981d264665ced2e9bbed977ae20127c59675783ca9065f2d10ed12ba2cec221811c33197fe419a1d8837311e759f81a7a8058c5234392a719cd6c989617ebe6dbdffb9b2a949819bd3f886b09ace1b3d3f05730ab9a3cb98c0b76bfd9839c4d5516c11aab4cf22a894216d4ec060ae1aba02930e0c8e62a3fc24b45def7d2c76ad243f16e0117f9393b524b0481d9de0a3818512264f6be40eef249bb6bcc0bde08c28a8b19953be70390a5fb66a230b25d337850ec528db0cf14f474f5fb963d68db0cae27d7ad83e3b34c320af3c3642139a8c6cf5ddbe0881b1e7f1c9a0cb600138bfc91f4e211de457286dc1b0c5017f30671586084afc8a8a6b326bd65bf9cd89263a75c3a1f939b559f651728d01e2c75ffa334cfe68eaf4608e32121515b151114ad0d785858af252da23da944dfb2bc0330597bcb22fd1962bd505827044c2c3e3bbf70c3098abc314a8f5f0107aafae5f515281285a739af9a6e49f797dd45275aa48bb5c6303de882f11f4c5106719abc271b67fa77e97835941d89a3bbce9b0113219c113b28de558ccdf00da05b648b1aa59400feb9211ad3dbaeb211d19aab37722d4d60229cd981fc283bea4ee82a4c22f48719ba6cfcc40059cba31311bd61bd2f13f97aa25e98d374d8eb22fb2cbf6e098c8cabb7050b8b81e5ac7ba0d4d0958c8c8a218017600c94ae7718d713a27f823ba32349a981a6bd1cff90700e7f96dd7f224fd95e79cbe066c073aa0fabac7506eeeff0e946abe921e20494e7679be66417e2f649602c6d522c1737f93a0ee584dc126f2c3cfd3ca5c328f929774bde414189fe6f37a1936b0a83fc45193a7121b542ba77f228915b58083f2f350f48aa351a4a009a58da5bc8f24773184c8cf3dad574182965f5f792bec9c02ee78af572e4e69ec243aa8e738f055f6a4caeb7dac4b9fc791c738cb30ae20a0a93595815fc3cb63ae5d9d7ae1801459c12b20d70126d1f2f78a6327071cf84e93788dcc160b18ce7249a5e5af33b1f85324d3b3cb20b0efd244e34cb8da67d01732ee5d158a8b9f71418f8fefc3e9bf36a2a7ad761340f7d5dfee133404da7a0ab2568d1873c583ae0fc3bfc010c8ec9a3ae6b6519a082931596d9838140a47d113869c868e3cc723d2376da989c3cd2d2f118a2993d6aef34e38ffecc3f06712d2513da1e098225fc2b19088deb37f5e2143ede630edc3cd7fb9f0c8e21f7653ab39db57c1e111ab185b2bd4790fab68771d047c7146a8558cdf131538a5be866da7146c5008117bf3e60df824c89a94fc2c5d6532800d1631c97d1ddbe17cee49a5babdd24be734dd14d4a48a1c321368ab08e753c0c7c3ac605ca3a39a518c3de5797c6662cfe9b23511ef9170541de5b9200208d680772c2fc5bc9e0c1bc0f37d89524b9ecb08f9ebf8765bc74599b0599e0f1340d1b2fec8db3ae3dea9496dc38f8d77defd3f6dca703ce5818e86ef014278af0d1e90b655c22690b09d67c008361ad5c2824698580836969c05544f4608926e9877dabd163f24ee79ea7253c31eff7475cef3b7b00ad0208fbc48e13e2b4da87d74319382995e630c6e0b2d65b73eb58cd3754274148e67dcd9653e05ece04077a3dabe8a82cecf952977dd52cb5ae98ff3d461f79a27ce088220fb11a99668cde30ccc8e70810ffa6f6123237ad7fdb677686baff468c6144d7210af2b00211f836c43e0ca3140f02684edb0aa08cf88bb56b45b05b993cf69a45e293fde603a5fcbd3cc67dd8c17a519d7e3707dc8d351e9a58c01beccbdbc8207dced45c20378b68f87587503fe46ac4f99d731ecc624d9443816818752ae0b3b61de416fd765ca2cfb8dfb4fc0b8748a76f2af6870c494095acba88ffdd46e4346a163c2b68dd51f23c2687e8429d6b9a5844ed1f2627aa6e3332cd868e4d838364f387b58651b3cfd8e52a3f41cd53e553b793e9dc87b8a22617f1cf477c5e684c19b0d1915753781145fbde52aa06d2dfe0afe3d0cd57c5046da46b8ee945feb81a79415c63fcd5ce95b82e8e686b919a9d4824bed50b31051560336d61ab74b379fb8460508044d5339364786a1efe3b13af569c3f44ff9b01b76e08098cf8ebbc3a50c3a311d1c1a2aec4283ce3de5c79c2b57f905100752b31936502703567ca9fc12d1c6348e3fe45389aab827ef9a2f3a14f275143d34cccab1f8ae89c77da18c4e49e449f04d22ccfda2cc88d48ec6211543d0f32670cdcdff700f868a0e4525f695771d1ce60da38490532e9cc447f1a186cbc3b6af5a38552781cd10aa8f2bf044732bd496b0d8a3f88deb7e3508b34df9d6eec588db935b8cfdea31ee8b505c62208e9c259c6a0ff7fa60a271203837ca45f30e7b8925ca88ba946200bd54f27b443a91e244e32a89f1124c77301ae9be8d3ddafc6ebb56323f4e1f5f1451a0a341207044fa58eef2c1a07959f8fd1226480e886ebdb0311f6d380893cc6b310555da879eb6901cd5371c3f1e98900877038198ce1f9c62456282be5be9e9138c0f27e7ba550c1b53f01f763280e19d0e27ae0a7dccd55325d09eba2afa3b645e0e797589fe8e8f0ef56ea597d27c95c59f76611c5a72fe7cc6cc719f12adeceb62776a57bf23651c47c35efec38820e400ec5f4335893b33ced9aa48e09aa04e15a5caea3a24d64f580166e32c1ff0c7aa95866a32845a270899f88bf3c3fd5ae2b924517e73fd6164ac39c2f4fc1eb90ea4c24535e9ec1fe576f2031d851edca4b7a954a281fa56518fafe88d98ef667a3d2f3978ac9f62a095b2862d30b0b2253fd285091f15ddfcb5b29ff321e6e33b34492881dc2f320b032dca6d8b3c6786c008d080a73cc4923db37d8ca227e7403514c299426ea1cad6da536ffe934bccd9972ccc931cfceccc5ebd41b4fd483aef5f962b09f4e83eae2ce0fea112dccc2f6d27348addfccdf95ff91e850bb2a25b6985bd895003748d405988dcd0306e212733d165ac8e5c0c64decfbe6ea57da9efd6ca5f3e5c9d0de6ec73ea3db773de4f46131fb511d0b6601e5b9176df5a8c9b6aee80b4bc9d213b5299609b686c1776487fbd4fbaa1678914b6d0ba431967df9c255655fa8d64601f4bbf83b5fc84af4ec2bbccbfbdcb0e027eb6fa2c5321580f0284f907eb298d4907175ac07dec8c1eabb1bc2e45d7c043a990663fb15e6448f8ca37bf87b9c2274839d5891ae4df66b2fb191a5aa98658f4eebb9a48f46c407bd77e9c10b3b45dedcab64123638e3a3098c915e23166ed9cfb12801bf8e6b1bfdbb9f3ffb4f216c668e6355299a98bbe6b84b61a90f35f7e3dabb970c997156162b54b9a7090086460bf227f83fa47257196710aaa43bf2b0f46bdae2c76025da1479e261cf0e258b71fcf54a0f805fdf4da61f522afb05efdd35b5cd9772359f0dc6342aef4ba992ae7774fd1e930e67a3e7410b47704ff5ca173a690dc510d7451634fa20807880aabb5d16995c28d3357341e2587f2c2f7e50dd3f1dd2530ba67f7b373116a7098a406cc3e3105797fc3c1d06ee2d94688b6b76d92c06fcc527844295d3a6f00cd45e718d53c78cfed1b9a2af5c39193eb2914b19b254400745c4918807c5fd58d58e81a62088aaf3f61411c10fbb0ec0db24bdff6fa2b38ab4c19d1cb44642b2190ca87645379252582ffc8eb08e6d269596706f4e3f2ea91bcfd6b4103a4a639c642d4e80a664f0373e4869e24a2a57bea14ea1089cf1c5d5f41117126105971dad3de430b04a8c203e3a7d269d31bb8d19d2633ef1f8448633bc3968b253ac2d9637176ee31434fb09e3336714a00dbbac89320872d9d3cb5798902d53c50a34ccf506edfc8f2eac325e59d362bcaa7db6f2146857fb21b6fc0af48306d8e7132a78d00ec41d428945b0c3a48cb473a9f8bbee6f01a478bb87c8e55693aaf07b45751a4797798df1be349245bd930eadab0cc43371bba15112ce4bf52528604a115fbca601e7b4b5eb41d82ba6fd770e10585d36267cb09a5c7b7594e313c8a1c2cb5380b3083ce5f72d56bce29df51cfa56537f02b61b822feb7b4ae5590792b1deac7ac492526e3608574fa67b3b750e4b6075258da506a91189d2c9a2352f2a0da0f44eecf16005362ee514da21bf8405973610bdf1c5e613224d8596b101b3982fe8b138639675ebcecb9625a2ebd7be6db7593678981a240db3b4404af87013aebad017876536419ffff314e52272b9765082708e6ea4d9b598d68f6f61d2014634f1389c817fb4dd6b57f4d805aa45823471cb735a5551057506ab26c96ae9851ac23b325f8efc33c2934e4ce75c2c6ee7f61935cfa4a0790bb65bf491f78b5023a25d71123fd9392c27c5e9b2d56bbedd7412d6f30b2b44a2d9a55ef30ae496b73706450dd288b07b6d340cc8142101932798aedfe588f6e0cf3eb0ae6df9561618f606f9934fa80d50526e92af6c91ab9f467eab526d5977008bc61c7abad3a5b7abf34c3890f2e1722db06e02d558005fb713f2acc41560c55a226c68030d5a29a0787b07e6501c38ed05c67f68aceec053b19382347a6e32b0d5b0fe71b05c3ad019a90975093c7e511c09907ed9730391ceb9899cfcc7269bb9931e136b023e8ccc1856345faea15ef77777a71f7a6cc7949e558ec4996e7b0c2868b6336af48d7c0813ba861ad098aee90f837e7ae4d44ea6e86753b1a0d7a2a2d85cc02e22e3805a22b92ac9d4fa9c478b157614cc8bca4d9ebb2c96ccf8bd686386caccb2827a52f257c6e1b7aad68bed53c6d27f924195ba53fa81405dc72d408841157e2a7c2e565752d8747e4f78725491d602c0b37012ff48339c5d0e9d5f5c3e64f737108bc544ce896eab21215fd9dfa4132add298ff45da176d65d7b11f3bedbd5aa06ad1721f60d821d448f68a9895ecf584a399d5cf574e3dad674961fb49f211953a1e9b0f6abdd13b0d78b276907f51feac6b093e8ee0485bfb12e9eba7ecd0aafe2f04a389e3399b911e11e774639543a3dee2486f2d0b7ca788cd59230b804a5aa505d3085d8f5cc07751b577f600abdb4ebf2057c7be1894493e491b9a67c88db16ed97dd71f8a78ac323f8e17aa12afe1dbbde43d28cfa8b1413c16484a5dfeab2c0a71616cd80af118dd2278fd9d0cc7ca8d15101344022fc3a7dc44898d81b4569a5c8b69ac1e59428b5edaed9606aa461bb2522657fabe11e8b3e0402d7e5d170c8b281dcfa371041d35957245bcf9d9e83670586b389d94f1686f4052b57424051244ba942f28f69456fb64ce493397eb7bff19933febff500e7876c5ccd40d0323b5dc6f3d8d7b23e2bae85bce6dc14be02299683d5ad8755ad78b1587ec8ff3866fa0ba2ff243af4af9115f25d68e390f641bb687b22e8b00847145c9f4edc713d2521630a738f9dfb40ee1577761f6e92dff293079ee9635a67b364b2082e0ba2330c62869744a3dc0bd6e83bce46b3c3fe2d46af443fc8bf23c21abe04a53a8e8ad16e79f5173d84dd831c594f7e1349578cb5df11aa81489824c470c2827cd8db1a12671e5529ce614b5e6ae57019c8411bcb8fd27135c1c3a88e7aae2799e672539f671b42d07f226342f3f93115a25934d3b92294ee52791ffd7a800716c67aebb4c7485c4f370ac85815ec9516cff2e770d3b9dbe82404d04bde64498f7aec17d8b1059604f3d12ffe9bc47e8bbb14213258662605727ea10f86592ad313b6535e814e9b558a2160501d9725dc4b1a98567046e9941f9c27f778b8ff819a8004ddc7d8795799e353aaa81e2a10e329642ff4f0b9ad14be50ded9f484d910b9e46fd5f40883ba775d7f971371dbfc93a3ff6706e6d32c8f5806e36d3b012f22e3a3569f7104b2f1ec06922e8e2c112fe87668c5b618c710b37b20b43f0afb5d3de9d12ea37aab203fe32bf620b1c841451cc7392f185d904fc09339bfe75a26bd0995614e37ba36773cc73975da74b603e3694a397d5d0d7a54b36dff52e7620b0f46a87eab1b2da8fbe6b053e5f852aabb7cc2146757221b1b4a3d69f3f4de22ed10c2658b0e587e3e9308c33d9cf4884fe1fd6271d565c9a0bf0c44634901735dda2e28010d4504f78f213cf4b2875c88f98098a760717c38fb0794bed0fe5941f92e49aa39c1aedfb2f14e7f6adbaa9077d9d4b40f17547d4f255ee3b742053d29e582ac1f7ee5c4c9812a541b3f2926c0fcb63e2a4069767fb0a621e3e5c8e768a6ce0b9bc7d1e6f3f6e43b36cbaaca3d524970581fa7886b814b5b311ad0c8d9f9619558d4170265d623105a920f6b7d0f75c4a59e1d6cdc0284707f1ebbde5b830d59a98cf6b392aedf3f0d43b653f6e4193ae4b1f5c1664611056c2d861d0a272cadca5cd5a9b3e213080c0f49333b9997af7d1509ddd189d23f93415d97212ec3f9eb1d3caf896c70f17ba4062832f9934068f16a6bf30be53861eb22fb230fcc3816af8ef037cadb691c8772c715d061478a307f18237fa7586af8e7e787df71d77e3f797a5f61f68be7c2cb30662cf1b87d6bb306e2808797c1a4a81f475852c95ffdf5f1704346490f4792fc3e56bae032dd9f3085956a6c9e82013c2cafaf8f83d1e42195c5af364f6dd3d98c753ecb86872a64a8cda8027dc4a3aa99f2cd374106649672655c4787dd42e5fc8f00cf47c6c548e6e36a043410b05be98757a62a01bfe069570b7a9d7d1c6eb5d7c085c291742a67c9aa6d40e5f6dd3e6a22a0cca904d14db0d7f84ac79d7be7c14fe8b786eecaacd0d242f4a59629f78d44de3ccce4ebfca41c3b2fc3ef9a14f33b1385c6a2fd969585c1b9031d38473b2af26bfa0476435d860693d908cfbccc773170ff0524eacd5a92d0d5bba08f42c72913b156413c7c52abe0e0680881e1455c28223279cc2dcb2b4bd9200bfec9a32081d8df92a80ffe3f16790f7ad4bf027f5ed3db2b219fd65160b4e09d0879c10aebee07f6059a2786914f2b59031c01a01d669732b327b9c23a12a1e6001be0f78fd51bb1b85b9ebf3db89a89fafd6a3549e24d400e879db275def1c89feeb0d2a6d10782f91ee803eae2c5f18414e26aeea9f6edae018f86b146eafc12708d0430ade36d5ee63c453efb89009c6b9fd7fc8e101d1a83118478fbcad0de915cfcafeb78aca188f45b30dae3494227fe787a26593f054cdfb9b02a0072ab2acd1d2a339206f16460d6eeac61ea6eecff503f99eebe18ca6a0c4ac92ed7cbec0d0239de29d9822511cc4feeacfe253e0c6565096224e2d3e05eb358740aa97a9665e12969ca77d1d8a13a14fbe039c7dc50c3961519dda6860ff79b5a0c7a56ccb94830634ef43781f0623c5a3c665182a934507d012e476ad065e98b1d9879e1a9d2ac832b2de6e27f6590400973c925ae21e0335fb56ec58b54ccc413ec7ed4114ae5fe1202475012d3febc4f88cad9833b04ceecd1df54f1625de3bd079e2a4f2d46b872ebfa65c0f4c40f64d8a898218e749b92186b961f5c4080f6ff4d35b62bd06d723fe8441f10cecfb04a49bcfc66412d3729f9d33ed0467e329c0e748bd40fbe6b518640fe330c00526e067ed0a3b1f1bafa2c91b742a8e7c7fe43fd4519cb471c42a43aecb48d1f2effb9b8086fa13f87ee74e34d7caed4aeab8646ac0f80d40794974e513835a37af95be753f779fe9541868544eeeeafcbc527a465b7309c2c5fdd5b763e46b1a6524f77838852f6ba1ff6eefd95ee0cb7b47c4c4e7b246939d98abd52b64873891b3b897ceb5eaf93e3f799fcb736d5d6fff1285d6c975e2f7c4ec102e36e8193b044bec0191c477dba1d9cff0518b59a5fe8156cae511711aba1056d4aff61ca5dbb30722372f653982d9229529e8efdc2cf8b1587d75f724aa8e4f862369eb77e2d530c6e99124ba3809b7fdfb1aa44fe13294a20d1ffb38b50a37b2a5bec4643597767903ac8166156db0459cc6ae049051ba5393e9f00ed4b4bbeb3b20719e8f95c513a5c241ed7c4d26eb8c59fde087fae28d8b6b47fe685e24bc7877dbaedbf7f38ec98d39497e73a26baf0323110d1c682b549a6190a00abc6d6602151ecffad37bba4f93ea29d6205967df669700935c3feab67d703fa8af3d81e447d7acb0478b7291ca17bac15e745813d47babca1f0d2766bbba0b7731feac73b3b3ff7521af513fac5fda27d686bc0e2401f9eef3d423534d588a5264ab521312e1117531fa2ea131083fa58705990db919a9b83b2cc74c97c42c62d711c09a9e05b0151346c77f7c6393038cc5602eb3cbf1ec2fb4fd57da51c97442a80125e1e88963a8c52ebe874f77da0b232cf11f1fd962acddc22cd0eca221c0f53615126a6132d0ddced1bdff2637154cee084ff9fea2aa20a5f41c7ea248018efc41b041271d37813a00d25dc165ea9253d420238492f5810719de9bc46681e04392036c405d9420f8f4825161ed77e1c939cf6450d530e1ea4d21a845bda46c2bc223644f8a3012b66bea9c231aeae3e81f342d7e9f4bf17c57f4a3b319519bc54835466d02b5473093e145dc2a64109159f27e2fa8b6f9e41aba2deaa5f3a71b8b2e4358a12cd06aecf755569bb17000746e3fbbbfb1bdccacde6f14ed4a9fa1ba442990d06ff9c4aea69bf6b39d73c8b994b7b872f28020bfe7dd2d768e468b1188c2778bfa4ed0db83f17bc89afc07fc1521dcb2ffad55ca9d6499ed5dd4d9dffbf3d73e225cce0c7f26c7f1743cb118e949ff7ecc81b6b6040774b0a5d7c4be2535b6399d4d120558d9f87db9aeab13f7d4142a459a3855523618dc44ea51b1ed0921b3a0eeb01b000299be5c846d194145679c7903eb666a8b267146d08cba23471f6af4fddd9b887c240c6dfb110945a780636f4d70613dfe3d27ebd3836dc0f4f131808ede196e62b28e2bc2260981a662dcc6082662ef5cc6942ac1e257f2b8859caf706ac99d986c84b1eb62e4ff992fa57ec87ac0bb04396958a6e22387ab1c526a15b33889a2fc73b00ee4bcb244a2ed6f63b171ae8ac13ef3cce07c4d7cbdcd9205a8023d291cd10f58be9bf23a17d54c39153d4c0b0c4086aa58889ab39d62e009b2f4556522c6dde432d33f188e98eeea264d14d376705e751b916496ea19b64d16e5587414e4117fd3e332ef33750c791468192b7e615ac856d8b282479246c9130239ed3bda747fd3956371abc11e8bf525328a6fbf9d8bb3c75ebdf004cff28a8e30b0d8706c7102d8f4e263b1a3b97266ae075b22aa346892b1faecdc8fd607bfb233898c5ed6e671e360ca9cfe1d21db3ae216fdbb9c0511d5fc95a57ef0ce532d1b9025701f8f463362ea6849a42a8646032580f3bd3d873f37809a016dba5455a5c75b0c171f91ae1eb0619557f032c403f5be0ee13402d54b410f08a2b1731a0bc802ec87fbd937b1595b402c23beb7436c4b7783087a7efae76b299fff99083cd639b07924f6d702220a6f0632b8ddd499da0fb1154bb7bfa6d9a9783e9d2743196a48331ff8791bf2979f645703bcb055a8447843c6a735878cbd6f08838cc328e3b817d337d5672b2f5e983a86547197049b73cb2137f079c8229b350ed2737df6f925f861a39b4d35865fe3bbad7a14052e0feeab80513c30602e0aa2839787db3fb9cf1a036ca898c708b3a5730f49e2dd1f61fdcbfdb0f374c259b9c1c7253b104d95d88d5f9da56cc5bb8e42ac6da124d63b88dd41d29cb34bc156b93de944a7f41a9d699866dd5b4c251b296b64cf2ff5336ab37b9e85686eac2d15a648ac4e111559e002cf85d7e9774ffdb6e34d50b9965aff2a44ef56d95f9406117348bbe03145ca644e434a9e05086da9aed92795fce3b87718f86e42dff3b0043194310f7c81d0d64a3dedf76fbf5b2a0ad6d2dc87f49b685472fe8dd3911edeba0e8c6ba3a1a623c7506e5b140b9526228ca9212a6fed22e9ac8e9365794b26ec65d071915d9a9c93c2f94c6860fb63808ceb53cdd0ef486b84cb6ac1ceaa9b2316dec7cbec4842527187d053de0acefb9412f41e693bc5b8f291720aba37d31cfde9a36c6248155c5367b0737b2168cf3ca328e07fa1d80f063a4e805118762254d7c4f601e4e0b7e625f5311712b881e883dd833b0972844d2eb952d8fd972b85f00e3ff555f86c345ba6edd9e0923c1cbb14b32b6bed306af71213a7623e885b849557e764d4f8955f729008474ce2fa85c68c5e9f3a18d19f437ea8aa4d9c1588fe6a55882a2ecb4ce5303bbc85cdc9d9ad5a4201ad97726a30a4af561bf208695631ce6dcded27ae59bc0efd520f7b4c213628dbb075db571ca526f2cad28682596d3f65d983b9973a8c6d16f241f70193de24008ed43090daebc55fa9da1fa6f4bdf71c723d6a2f21bd2afa8fb139c6ce0f08351057d7029e6a07c9f28656dc759d32fed4593fd12b0846344ef15044e800dcf0312038a01ffb6f54edb73cd684d3e392792a66fd16dc8afd77920f01ce3ad1c81bfc22ff4111b977de8cb627b05fc8d930ee8499085e43c09ae15f1c10dca85a06d88b50af6691e31187fef4e99ba8633b881b366e3e8a8332c415f7d15621a7c9e3b0cee7f87ef291ed943d0d50dce1c5f162596d2536d343ff99aa0825299e340a087a4d3c4ae5b598cf1b37f3855fa08c227b038428217514c8074fc467b8e0674244f5a768f0ecf0017c9d05886f4ab154c13cacb39a64fd3370d98ae7c1075659195107d040798823a4fbcda31e40338845a3211887f17b1dbce18d7c488aa9d2014db10234157c3271eeabe2f988cc5d968a56fcd25fd88e4ca8d9e5dfbc3c846c2d8a1c5581325735d89b90a8e37fc84b0c86d8ff15907ffb531bb745a7b10f5c0fb684817ac69556fe7469610cdbba7edd7f3d7d7d3969b6792b114f77f43f41f3cbbc9e4358fdff75bcd90f8bc99df2f412c8744bf1ef1e53ee0fe71d72b63e2a35625c52e57ded4f558fd795d2a2764bda8f1476dc71ca9c16a1ed4be459eb4f48dd803e38000cc8886568b284fbe921ac1307eedf9228d509f249217832ed407e950ed32619bfbf825d07d3e8ece79c8c41e8c3b3b41939cb5d37afb5f8faedf93260af62ec1486bfb50e31b61fa4ee356b45bfc642ed9fc8da8f24eafa3bfb782efe442fb39c9793bc0c4dc963e20e35370b1590a7c1919b1fe27e25688857b4511351b0a7c6aecb608c3c63eb74cc6c9bd17266288ddb55e5f7249f24554f7daa1069e6d9659d8ac8e2d08d7d93d1e2f1d70bae75bf1eb774b9f8fe9a97b0aeed476cc1baf690bb55d599690d8c6712c37a881d969ffb36098b022b89489cc96b09f7e6a8fa39d57fa90f56542736da74c0c435e97a80cd2ad0af8cf589ca0efd454befe47580fdcbcc5ea9a79b41ea0d46a290bbc2d96e8b787e678c5dc863f5417a7a7a509b9ca0a7cb7c4768aff91d917f810cf844354f7b02d359a4eee30e65512969e86325dd5c0ab3d5241831341219668ff17287f3a39b589ff979aaf1489b92136384e4a90825f2ace3bca2ceed4c7497b996c42fd973dc81e62fa8c73f76342e11ada67bbe90f5385d9cb29689ec81d61d1d1ccfcd715ab7451ea4e2d77180f2b5a1224800d994af95b5db421f36a7c4c2952750062b57d3855ee04ac860c1d39b76d631d997f586ee5bde57b450f07f7f045375fe35f1f7330f5ef6dd7d12903113386ecad256086bc29a5b791a6182910bc2b2ab21078c395e930a86d71385bc006723034b7537471773e626820e84fba85afd930e5a3f5fd0f51ba79c87108ecf74a4c6c41c5238942a8b244e1a47541316b6bf3557016c70af1a12d552de2004d137d24db8596a000ad30d143ce311f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
