<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4dcca4afbe7dad0670abe0177a0ab0682a448bd59f0acc8deb11539c229440f57cbd1382101f52ae7b2a62ae63038ceca2d263659eb6e9883e9eb208a28b81f42c7b9a4b269ebfaa164a9d254a7f46ab5545393d7a849b6ce92cb099a9d824fa2fbb586011d9ea2bd1b04c6ab73c630c69afc8ca487e803267b11c81f315e2ce7de81ef04f8fd0896cb19cf5ff96644516bbc97ab65f3c6a843543b57627252d23c6054a32808d941f120504cd410699ca7360a54d094744086f06ec1351db623c606bf3458cf3ccc9c8c45234575ee1ac035154cf97dd6462eaf71461ee913b277b3d1b31be0885df8b1aecde57a0d13120465db81f97cff4d239c3c4f7b136d6c5cd042503d5f7d5d6116e1a95f168e3cb93907b8a6c5925f19d6d1fc55c84cfca6a119fa7fbc14e4e3737f3e580cf9e2a2f18d099d9a1fab93c836ef2b1ea9df3e27d8afed750994993fddcde400297dd1eefd659dd64e79258e8c98dafaaec7edeb50b95bcc551114dd7998003731b80129bb5c60a06f209cdfa7bdc3f92a9c5e48b8b8caa674e72d934b6e5673d8c478e2daacb107c104fefa40e66a5012969889c4a92314a1e3b813a90208ad292f16142047dc7b682ff3b59ef3f59b3f1b1fb54c70d8314a0a8e1eeb3aee10eb375fb19f6336ef40e3acc2bd8b34d38bbd3ff23f799a20d3d7cd3de83f46243946fde6a3fb25a4b2004d9be737f50e0064ac462736ec639e1543822072e3fe0f3d1739901e204792c1bba1fd578fa728748ec1e6cae1f371013a08dde75f3902c2ab4a4753ec50c671ff2434b64008565b446f4101f1094db131b824e058264f06ce4eb3240ba0dd809ea0fabd06641446529de1a009c1529d6fead7e9e3316a4f12291965d88da9e27753fc5865c1b47fda9f27e5588899aceccda93b4501ac75d2c5a399d8f454240274f64fa2f3ba6970de65511fb261b84d834911d9adfd42bba10baa828aae9904a21ed8c1f2e0776b6b818ed5a3c86812b5d378d84d90127b055765f1fe3dbc2cf69db51be598b6d96169e3c520d1db1fa9776b343e7cec609fe8fba6c2e7ac959557a149276aa9592664242a4f5dd2aa69c88a1150ca55dbaf0ae5a00e0709cf6f0c9507fef9c9ab2d912e4c80d5b30e354edfc5367a55d7e8f9435cd2af7094fd8add7d14093d0fe284e7cd987732d11869320b55b150295a2903321ad6ec36d3feb7194c9e0b10d4c0d0f92fbe08b2e8380619044a17d7b2871cd1bdd79db7a95898b6876cd67ab1400c595ff4f4d06fb56dfc2aa2a6d3be84360314fe07857eaa51823a5931203f3e9e2679b7741f81de97d405ee6b54973d02ededdfe922db74873fc891cd281da323942f9228f485648a18779742be7282b6d95f7740d3610715509f8f151911593d2527f7773eb65478e34068f98a43eb43aad20b2a11d281588e8675a9f22e905dce98ec4d6a6ff62d811b2c013483696396d891b8bb5980c4564884bed63978bfed467bc37785ee6fb274ec75ab730beacc4e22d98afc6135b6b60d27937d12d73243a4fad5d1bdb7930f0e6f4cf853aefea96a77f16b4177d52855ea5ec19ac27c35756df09a8439b550d4c6133f91938f97a6f37884a95c6652677b90cdd3899f3727d0e113b100f23891d5212abf05fd61347182ff7742fff746c2700fbd3f2090c70e6e6c247171b1fe78f8f5e531c527fa377f23894fe0efc70d4df444a33cbbedd208ba7cfaeff2848652f14c36ee6fb560cb7ff0a4d0661405443889c34b0d40ff2b01c2341311b059ec62b553fac89e120aa2a7c8858f0dc220ca2927aa670b3607372b71a5d75127b73d48a229001d0895162f57fb3b33be72e5e84c99ee2464e780d2c5e183835a7b937d82fcee55a3abd52cd9f558ee65bd71a15e0d950849977ee8c04af46306d7cb890ac0b56044c324ee580f449a11e7eb888f27e2db83606dbc928a643b4c49498c336467edd468037e9ef7196946885654ddfbeb1b2876c9996de38303b957b6630a6facdfe32aa2f5cad328aa3510991bd28e6f560cd31da7f7bcb59064ad09694a718d981a675007c46275d50588d5890de51f0106a25548b11d7a939358efd1a123d42cdf7fa4c09ff6c4ab16293fb151d916634c46c337c2c0e11aec47c5260a7b39875ba01cf6103bce62c5c9d60307e51d29671145d04be79bb257a3fc869129e29eb24048e24378d542f068bb94636f5d2c068caa658899eb588b069a3bb3b92ff9a8d14469f1caca7bb0e77ffbffec77c5e1431db0a18cf7d68633f8c106bad4aab0b4b4094f317303b15c12bd3a3c42738c563f0d44208fb7be5300a1ffdc06f6b588509581d1f7d968bf5d8c721c7398cd11906124ec7b1f3b9dbaf163a93dd4656239f96478f9547c108ef1085fcd5f3c2d1e006d04382fdc25ed4c8fc97c63f1ecc3f392996baf61aa0e8abf4aa1f46f792dcf40afab8505cf00b7a0ec42535211bdf8993ec1d105a05279511b500eba78afda009df680bfba505e7b333933cc9cd0fcb7bcaeddd190e6c9c2bee44db322de9feca244c9b150cb13bbfdbb9c11b84ec832778586398fa93247cf7589dc1c52a6e8017a5bab5a4b2ec3852708ff4c3afd778f4a0afc1f9acafc2490a7d4e457ea9e20a1e2844311cbe857077fd9c74c861189301fad4c817eb7c6ac51d7eedac4b42a03610e59699ef3d9501f9162b967a6a3b0ac8bedcda830ef95e8be6648797e1f1172f46c66255f279bad596d15a432fdb7fda705948fed04c5fcf4a0c73f920a7ad3b8220a49542cbfac1639ee4d0085ebb7f2efcfeac263fb0a47bc5570f0fa92eb6c1fb336449137023dcad7d8238c6eb3ebf126cd8e7a396b84bd177f1cce895df18c44e4ed5edef76ced837a295a0eeff4482d4bf2c0742e1ae615bdec8ca68fe1d576a7d7e8bf939639d464a11f2703b8adcf82132f0cb42f095adccaf691ab195bf6da37c7370d44c540b77dd4f15da700392bcfc9b452221bc0aa772849bfa395670a31a3f150a4d7d10712a602be71ffbfaaef1dfef5bccfb113a3b42280befe99270f5c0d16a048b9cd04133bb4c24551b12f3ee233b23ae3120a99414554474c806e20ebe4bc25f168f8daefb1b9a92e1fce651b72735387346d6cccf0a7508a9bd29638d27fe0945eeca4bedb5348fb257f8f0587cd4898608dbc50335708deeab8863fcb1acbce339114cbc623c69cd52dcc3cbc51347fa14a4367ee86edceb47d72bb4ab196cf3ca0f772e3d7ee2ee67d2bbbae9064d7f1e232e0319205f5e516e03e9a8fdd948acfe57f053383c68c74f64c55cbd401883614fb88fca25a3824e1d67aebffa4c4003be5585d04af7cea94e6fb0a3e4e8a1162fc941100ebd20ded76d483ae11f51e8888b2dfcf365905a5c31a53bc1e237183afa2347e0a92b6b8cee95129de52cfce1c21b518281f07870d621af3b584336825f3329d7a661011a5c8f126b3c8e9389fab032ce6f6c98465952f0e44979a4a838423c07dc0ea0d53e3f6b452007142252e6fa938698519163de0c607b805551496ff7b7c5390e2e478b8ce2078b8655ab59e5de65e948921a1366e6577eba763ec4d792ea92e877ee7f2eab7f33c64b74b891bc9285592813f872aefb676abc92731207c6019bd26c520e12106f855b78d55ab0810244f99f7cee5bd10039a26b3c9edd75ebb521a3a62f7c5044ebf9b86953b5ebde31b831a2a9f9db629af20d38ed7da87c544586cd990a403d4526345dffde9d70900fe14f7f3ab97bbe733398a4e810eba7babcc7feffd6f089728d45654b7a6dddc1bec1075ae3f33dfd226268050c2aabb0efb904e00fb1cc61e2f06cb1d1c90b877a5dfc3cc4d873fcfc7f823faeb4c5d4646db32424d855ea5902ea1e577055af5e917d7aa884ca342d68a0f9f4dcc60e05d200af8c51d6dd1830400507e2bd7986db84b88529d5941aa07298001cf7575f913329774575d63404d7e20ef7e19d7849ab889bd4a787c499c8ea648063e04cefc4873b8539bc9117dfe3da6e15e7e5f237bc4d56931679cefbbda791cbc579fe489be28aa1612f22657581bfb196f98c02ac2f6515d6ba99e70993ad3d6afacadcd7a782f2868cf38b3325eca40a8cc4a8739068c0babdb0a529925cf8f3592a5d032f174aaf599cb9dcc64825fa644aefafff8564fe6c1c9349fb8e2943d2c0f5a650e52798eb996bfbe8960d415964c127c89d0bfa0c40339c49bddb8b74883800337dedad05e2ea60bd8f5734e2892e37e35815e31a5c7bc37b9674f11cc10117844edd692997b00947d56307b2875a4e64471fa160461199d8269d9495643db99a929a7bf2f65bf917ea79cef05d0eea406618a1f4f55e40768f9869afd6737b97efa969a1643de409f9c7f456b78c50196161cf07cee421da79bdb8588b2b993555eb1500178c44c1b79da2aa552e91972b5383ba91693c3c72b643dd13d0c65eda42164c866c5e16e2db99cc2313b8844604108aa2fc89ede9f42d2e9a25113400c8eeadd8d270052c17a7bbc011661c083e03ea97c0856c214486f860d748b7cda448a878713a54bc104c0479c8988d0772fb8696b34dc075490abd9d163a545b29d187b5de958a8c2177c21b81c6f675a9125c17100b8ffe880e085f6592eb7d5587d6100c5019268968813ef572f667cfce2efa5ac83eabc9c850e7c297f082bf0c991ff8f3c0830368007246703eb139bccd5094da5fd567866a586145ee0c8dd667b0cf2a02a86e38f1dffd5f742b2b87d210e2382b6a4e7272abcd687b2543220cafb190bd6f3121843f0cd820c268d38267ace1cb3a471958c17aa15b3592a77f75137bfd7150ac3af8cc02f47e254be2de3f8646b1340ea31500b3a565ed9aadda21c1a066e90e8a58b171f639d5513f4484d6a2e14718fd538b3aed55940f06d497ab9a547dfc721d2db05adbd27912d4a44510dc971536f43cdd0ecb932f61c32dd9c494a9357d01e1bfa1e254ba453cb8a51e327bb5f5174ea078d654c4e24e23f1c8e2760dfc8927331cc34691e82c74f421806ac91b6a45a81b077e60dee52fc7167b1d7e7798708f7e598b9f3107504758ee69c9d59467a2b3b9cee9f5391cb22aad180c22789f72b3ab84d5e82fc9031252c0c3d85c1ca3818ff4bd22dc2fe574c03607f5725d916ee8cb92b6ac16ec0989dece5e973cd6fb8b97e3be1a1dafc8a05cf7cabe544beb46d2d7bb3bbba0a61e6e423c2e2d67a64c4521c4d2deb749e6216e3c6d1d5273c641a21f608eeee985e0180b496d4e8740663ab02d98b54ce1598934bfc7c32a6379e60553a99dcb42ce2db0c22f5a00bf8fc6ce61f2b7014e779bc02d77805d4af7e6901376f316eef620cddae4ad4871e5d5d15c5912de4e92a39b4a25004195990b59bad619c0a2d3104106f7ffe73910b178686e5332fa9260f76ac2e7fea5f0386d54684c7be60093790d3ceeab34ab35b3a42f40422cb2d6d6378d30a1387d8c256761eb4e9d7b0f8e6f5a1a2ae9c89e207be538171e3cc5f5ee15aa7a58c7b6ad1de96eafa6a7a20850e33e40da98da8c38ea2d72b509cbdb0e2503f0fced5b37a1886c1abfd6d3ccbee26b3e000b87f8d01ff2ae4cb75d50e3384d6b3bdbd93f5d3b372013bdda7e69e9701a34cc045de9769e4f9ff9a18276ddc950433ed31d825a60129643ae524ca184ccfb950bcd84de98dfd3d46d45db4a8d962ac91fa38039c8bc81bc8f0318425875f7a1d459c9e91cb4e11c423c9ed913fe964a0a919f9e75349a9c2d97a5c8f963f261d94ebeaf8b5f1ccef1172188908e337a08630b8f34cc165477a295e93338abf56513e9a5e7ea73423f4a24132718591dede524a629a2ee1ddaa218e50913851bdd69babec71f440a4d7c0ef9c04b0e9817b9935a39b581f9e02e6e9d74a1854e3b66d5503431a3f2e291bafeb7bc9c4d00ee869abf94000a48c7a0eddce20ded1899c898a2b6587fdee9ce4e83f9b30f072835f7b731e4077f9fb3c6b899c9eee6d311c2cc8a2cc73528b6557e7a4291b32313d9adfd34a464e20b7bcecc1f37ba2be9982f06e34b71a269a49fdff11a425d1fea00a3372f24ab95daac41851fd65a28153b6e046869ab3b365a58b3c2d4dc5b6e9b1d8cbf94be392512f6946a4cc705909bad5e30321e382f75d2d515392ece1cb9bc246892025b10001ee3a6d6685436c877858bba4ba0a1aefbb7f4831369d58e0c59c510929539650b185e747410e0ab5676180ed1e2dabe24d9b3be1d22be58d982534c70e1591c0741bda8c1177a952bb5a1c93383be57144d0906778ec863a8e763ca0f83612351ce3e07e4e3e944403797f5abb601743e2649cac2053ff4412d2a0ef9d21c7e169d065ec1094a2549a52b5fac6a582e7d9ad1db312fb501d5db0db2f4d88d393b05a340f19683242abb57c3c44d3e9633ecca9a1a3fde428ad1a1e6197a83a84ccb6ff6958e0e75d3121327fbd306ac3419e9432b787836eeda53b46f33ed00d73e3fba260227f542748d33b39185aa7c04276edb7cd218ba2e667dee781a17f6ab41dd8c4544ae019fb94af7a623d8ad93d0768a3de2fdab79f37549110d553e2a40d72907cae1f97b1b85035cb26c226270d026713bd56a7dd8b9d34a96e4cf9286b40781687f2b75a49fe76481e516b7d03b81620391fb857b39439d9ba417bb8dfb23d9acff41978b8ba65a72d1c759403064e151b1c337ae19d866cf9e016f398560fad7908db8c0113151a5ad4030d4253b8fb52175c3e9eefde9b12dc0605ae96bdb085b7b193aecae856da012cff8b3533fe4183f9bdbbda4ed97485aecb2c7753f6d9f155282baad62b8a71c4e9c65cc7318444a1b44b1e6fbdfeee749841ad44737c599f839c95b754657a0e9cac945db08946ab2624fb5be97a47541d7c5b002089e6fc272dd2d94a8b602e95aa2fe97b094b585afed56c2bfe58f8c52cdf7d4a2abecfe11133ce8a54e4c58add74997e4a804621841ef68c28e7cb82901cbd97142d664e0a45c3fbb2e6eac4ac45fc60fb57e7a4d70055c28b4011a073961e4ff1013ea0115cd49472d23f6bd657827b0bd6feb10b5be7832001daa8df8ff5bdfff529028bed0c2a3c1d11dae3edba0d7cc9920cfac5ea3127007752d548793616946fb161fdfbbe1fc684a48361d66f46d63c68a3e7485f720245caaaa4c58f0457dcb6323b4cd2a274ed5ea0cc1db6fbe74280517a9f25be62a80fa40ad84ff94de0be6d7247656fafba0be3a9811596ed21d07bf82512492db200d83f94101af72d60642b758c6374a33dc6a0da227dedc17c918c55f48dd2b08756a85cd4c0cf816b0088228e8ec6f8748cbcefad71028da86a25c60aec4fe47ec4c9b1ef1506729019d7c84584cf026f886e5aa5c9b34d3706821a55711d7a8e4f7273e95c181afa71763da322abdbd57b15b82b911ba422c3ee19ef2d71fb4fc7e09b96e05c0d6a872c05f2e6b9f5c13f5e1c94e530c96cf80062cb24734565d3c6dfaf3328e01d364d72a8467da48dd72d00c74d27c530b9dff9758ee8f249caeef596cc998cd6ee2ed66d56031cdcb21f6e9731c75d3bb4b0a716ab5bedfc991619e975e4c8a83660d16b2289eb0a5dc96776d4c5be5f80477beace65c70a888eaba81de8c3687ff2aca9a28b9800dff29ff770a8bc1983d99ee9203c6cf726bb554795c16ffe6791cc43de657f7b2d271a5d5aa7a5fe7eec297d4fcbed3157082adb08fe442b0d81a85f7c7fd6986c8ff2f5c6622bb2aeeb9d66b329db57297dfd717b8b4972c01c273f88afb6eb3d68a1a1bbf43c092c498f555932edf8a045ad4236a8ffe6339b2642050868f95eab89c7a9a2a3a92f7dbbf85190b9335eed4e7e21cf216de059672d9575b76502636fa28f6601623e5779c56f9a7459c3dbffc6f4947cec589640a8970f1e0bccba2e821234f3b80ea99cf8513a8aea01be08fffe9b69b6c26f9a8fbcb396651657785f24f6d1d70fe9dd85d27fe6e29884737dbc5ef6374cd561a7ba238050ede4d05c585b7bf273eb3c598c48dfc8dd875a8d454c8a451b35e8e734d8ff1e6f11cb8880291704531dbac0fcf1c722575ab17a0113e893522be551dee24f7da51554608e236e87b4ef04af1b15a6e9ea4d2640faa7d4efbc978dece085f490665308e9a23f066351ec6944c1ec3425cce1cccf5b3832ee45c5aab4627704c4f05715282719c99f06131783ea7d78c4488abca2cfa994aad11d02f779c1c11fa90c093a3dcbaea0f01b19ef83793ff2bc1b34d878218b551bda84ef35af4ff034eb433b5856bae394f935cd526e730ea43f94842ed1dc12f4c66c56dc96c5d60658ab81a852006121f5b3e822cafe14279839ecd4cde11b5faeea18b993dea9d782832dbfd4aace604cf13f607c5ee6c09349137becbbabd78d6febb08b0b464ea0a94e2fbc84659a1090a5f94476730f269f7c8f07d79147c390363e61451872cb0d1a712761aa030807c1f5a22908f97b6855a9dbb440f7f707fbb7c66780dbc5e002df251de908ad59032f334bc19c81e0c8723ef917e668ceabb98d9e18136296105a69f688370ab0c5b9cc79365c5a57e1148d2ea7b3b79a972f9986f22b8606f0c59b6764407968732fbf68553a0545aa93cb0486ca59c6d9d60d023c3c8bdce3ada64401b62d9190ea0a7f42622e4c9e7b466d5ac069d636d9ab25aa342d6e44c2bbdc955d9d2796c0377c57ccd391972fe0c44237cffb560b6d2746d2d29f360a87e7bdae1f4e707a68cc88ee1653f3efecd615d0167cb0cf724a9cb4874ee6d420be32c6334c23efa54d20d3edc5b1b308b2d4bb4ea6e177d217900cfe94d73608691de0a3ac158859b0b16ed582db79222b165aae8fd4ea9b261d22ecfcae436891cdd2dd07cc4f0795818d1ab0134da0c9f3b22e868eb335ef05a24cc4a927749138441164867e85407e898f666be738d520c6145ae3599e494377e1b918424cbea6a0bd884882cb92ea9fb7889cbe9c64e6a35048c0f658b5e4aab77641368542a45999cb0eb6c341d27da97582c1ca4903f923486429d19fdc29fde6318151577842491628235d57651c51152b7c646743229d1d05d34659103c82fcb66558ec7c987cd63f047bf3b20421cd28cfa2613473c629c02e6de135fce08b720fbd54cb9982fdae3604881001468fbd20c8a14fba551f2da93d8e83ea365f0d13acde5202efc2969adef82c9472f1f4e82d4df9285fb4546996fcce6ce9f1a6616e288b3a702fd1e6e8c9057d1a2bab2b84cb2ef51016f733987694d2655eac7a690da4a59a03e535c41a6f96e025012644c4820296c346878e5d755693e958c4c88d878c2838840d5842011b18c9c47fd6c5929a07649d99b67fd523336292f760c3e753908e16510418f3320496d87014d76192519b2b6cea59dc7e2faddf9d44d74a85056d6b7a814adab37ad6249f7f3364bee7651ee068aaf8a3322c28172b761d613f3c280dd1db4f239ef764d6781e439f9e9a747c78417f93f3daa721253f1af80d6c418b8abb4da956d92c611d8e90aac54d838eb0bc08fffb12d781cd73f209e5988508be1f44980c401c065ca3d23fce4f2f7fd4520d6889593e7a23da5e385a946aff8abcf1b73707cd0407185ddb0c1425e9bb9b1d5f566fe82b321d506bb5ca9bbadf066157dc36c428a9f3974f8d34ad050ea8c24f71e68a7d14a81487d048d4770ccc3b6caf26e4a470c8b862ad5f53a8c375756effbb27371c6afbb9ae01270739bdffa66513cef63e074443329a64ec9dce8862bd3ea3e44de8c458808f8053162b6a7e774f9ed9cce1d5635acaa065d8e37959ff9b095cd8b8d0e2cc9e2ba9ab0d3fa91bbfa07b657afc852593cc68be454f98926ee6b3dbf92d8df508f7f8295c225290be9ebf75cb9fd648191e5deb9dc3dc5c7ae1b8bc5c65c9a444712b3f5b3a7962a113a73475629cfd1686a4badef2dcf33fc8f98caa002defb0302cd492dc7b422cf7b020a1666a7e9446c5fd20b8576c62e26cd8bebbe62175a7fec988634ac71469b60f4647f12e038625a15388ee66a03747560ececa273458f08b70446c242f8f6e7ff55f4b63a9ff6b03f2c4fdc44a3f0249d7e08fbb70c3bed2eb3f28e51d49604f44f15758f6061e560486f838b70afdd822012d6f805119a0ecd4ec36058bd249532c6f1470b8318155ac71d66d551d7da978437be53b75ba429525dc9917c904948615f467ff5efac90a2c32fb765571e626a2e93a00278e066fd29ae12ba514cdcdbaa6e3995e850e8d97dbbe05855b3bb49d0215ac7e5e2e7e6c64d2ea4c023304566547201ed414aedc550de0cb0207d817e5ded76c201620b1c15a051968af858c52c662bfb7ddc80057aa2db41614fe56d41dcc83fdd78e244c8ba31c2193775a3f132252ad8c296c9546e0c08f5e96ba89b45498e28bd041cc03bd938a8cf6a379e85c47a0869a14dfdb0f61267da3a5b9f5fdc9a7542de53e0f93fb4dfa2cb9596a4dbb97cc5c1e061a63a2cce9c4575c629e07237dd474d974e71bd93eb042977c802dc6729ba7a5297b1d49ad6fdfb1f3dc09cc1c3a35293d577fd8fa5cef35a98f49c83024f8c15971072eb244d7de4ac8d14b8390464b43c99c69be751e3ecbc8325783a20bb54b6b3f8bcc4f66374e9f9fcb278a8f43f8af45e13a112419d459e37f9ef179af62e5f9de88ac740934c99af57564d01992b1e6ab5da9d89f48ba4c08647e84f9145bbba5e2edaf73d591c16984214c428d4440a4a6a35fb2e712110431a750718ffd535b1cbb46eae45e41e066bc6265bc32b335c957fb1839e5c6de4111d30c050ba6aa69f6298c9db11623acf53952f8fc6992f96fd4f1361fd63111139f329a226db0b73ba6f047bd54dad91714bbc5261bd9942671966dd92cdb6cba0e69d30e25f6af28517aab580495cda0ce5c52a9ca745507b0e05eef10be5ce01b09ef3a72f26b601bac1170f5f6bf0baa8b2b64fcf35a3cd15e5d37aacb17727214d0a815b7b7aaa61e4fd3843897049aca728749ab336066f7876b4780290170e8aedbf38cf4159b32058b37091c390b51dddec7efc11e48df41dd354887fb66af5c95b2edde31fb3ee6b82bbcd8a7e1b42e306811a1ca2a60f99f2adb02a52e8575036358f2aa01eedde24b7255603ad7256576e48eeee801eed149b2cf5d3b09d225dbbc968ab2ade28cbfccfb52636d89a82f9178c80e41204f7f0e78fe1d4d084797289184177289badd61c4a905bc629d8931305edb5565764bd949704963bab0432d9b893ff75e26ddefa6280c4bd96d98ae2309858c3fd1d76672cd3c354153e4726816052dfb1d888b8ddb91fb694c02d7f28b216337a6eb4bb5cae9e3b3a8b4e1455da03ef2810976ec0c1e1df84889683720986101170ded2e56b6505f12450b3c2d1a60d24a8276bec56959f871d5700e62c0ce7967d773d743ad38a7e439e932dcf310645dd7b48e94a524f9b7687b4a07f648be6fdc27bdf02feba867e4b609a64fb5959da2e22f9cccc725dc99554f159e6dc2b55779565361691cdb9138aaecfd260a02dd0ec793cf4f5e4fd3da3d07469eef1e1a1be314617ee0952cfe11b7814c8ae798c46c21f4b117c7f409fcaada9c9704cff08e7b39efbda4d92483af4d47dbbfcff550af14f9293cfad48232eca83da3b99149ffeed01a06aabbb7f9331cbe2f8af02a405422e636e09832c5d023d92881f4ce4844ed953bbe15df6fff62f330d7d24a69b27b9beaad45e46fc746805d5dcc1013af96e15d57ebd28ca3268a70abafa9d7a1258511f39d0e6cbe311dc22ff777ae173b82c278c0731e19eb77069b97710642452ca6a9d55b9836cb421b1ed05713c774359cadb4a1f7411b6b6d30ff57952eeb04e293bbd05738862e846d6c14f30f0adc17b4cdcf5d5d51bd4001d6b42d828d7a5559b0ef55c84c1b6e385d43a73e4ceecc862a1074e04f6568c80df49e7afe959dc5c77fc0f0d50cc2b7ee766d3885c185a2f9abf676dfcff2a97ace0869081d3d123dbe10d4f8fc9a8cd341c04daf69176ffd6e120d40929db8e4bd5146f091ae65c5319929d25450470cb5019fcda4dbd5706e218ed649b24bd539af759d619a8aec8901ca9b9537ffec4996bc49b0b6dba0cd4fbbfa11dbf284070d7d4c425233d9fa5f52980d57d0bdab86dbdef56c2dbcade31af5c1fcb3d5b9533a02c52366f21c66bda7a76005d9b143e9a2eaa8bd213025d68d3b8abe4b86bdda42ab6e0d21809f5dfcd37b4827609388dfcbeea6337725e91cc7d286a605009148d2a57c6ba005e36a88b944ac858c4a3f267d691bcc9aa4157c71ad580e57c96de22245b5ff21ec2faf98103c9317c1b3c575e44ecbccf60901f860fbf207076ce174ba5c7754242518d1f000b1daaa8d319a9b70e9119a86b88f2c66e7cd2eca66a14be3be815044aaa31224625bf924c3929ac9f01a8a37b1397e116bfd4de5ec4f1ab288b51315ce5acfb548a3f6add5f5edaa02ff25666805b4deaaa12ecfe27314de65e44735d1e94ff8af419bcbc1ba02b5a9268dcb10a8cc2cc1e3ae1d72a31bdcdaf4890ea5d4cf993661398139a9511cc7ee7e475f4641702ec8b2cf34587331231573c2add38374562777aef270ca6df722d4fc099e33cf8f4a2791b669a9ee0dbdf5e50f1138d5619830bf41c751aae49af9d0bac1a808489e04063b6a72da0119a7ea4229f6a18fa19c532f700ebfa69521840f7067563af2538f63d3d26a26b64147611ba037515b3bddfa0036a753f6bac4fcea1dede12f9104d9ebc7d1f8b9dd82402e1ca019b61332bf31fbbb65ee51c0a562fb20fea85cc574425e38e6e897de55ae095da813020eba740e5465271703f3400aa930303360dbd7589492fc3491bc010f66e9a262715548b1ca8f717779010ba82026ef3ac4f4c9f379304788a43186d6e1fbdc93b4e5f818481aba8259057c0736fa74428787633b351314fd6301e29d9cffc98e3f315b09626c5ae5aa1e925283ca85f8aef11ee9a35679fbe75aef80f644d325966db58c310f46bc8ba15cb9beb8dddc5c1af5655867e65c39ffc335ac9e0a667d6682298cb579bcb9a12185f245cc5a252f8f9c044106a3bac1427ddc9a13993886926b23b706adc2186211bec2c0eea777df8d822dfc7037d7a79e8af3df0e06b542b68fba099bcdc6b6cb1e8207c1f085794031e6e749fc02d2435f04f45d644fea863587ea54e8c55875dc3971e38cf7b75b6772c05e36ebfae73fe99014963334fb4abe8ec77bbced9233152a34b02c7bb21118ddc25377fbc1ffd9fbc9440d9160370cbb95e6b2e656617d948501cd7b4b0182effdac95458f408fcc8b408e56f9e6741a53dd938d319d99790c37fdab72f6e4df2b795c649e3df96f262719dd0fc99f7be81bec7a17a1be903e7931e38736a964bd9ee9b679c392eeac9df5a6b70587a556b4e98cd1ffb3434b7b78e7ad4fe64b6c4b53e827fc763dfff1af8a11eacfcf6562e2cff623ea728569cda1587af0c8e4e5baa8975c61eb41d28cdd8cd0423ef1fe21f2ff8450c216445256a528b0e7eb8e0b4910753d237c10412558e8d1eb67182cafc024533b9a0b1510e994d30ad622693563e861e9e35c6d1d2d54c9c62b16715299de6468904676ac429b618c6262d5bde3a1b9c804d65e456c480bc6363f62add0076217c2e205ced240eec30ca944df08a01ad50fd3cf3440e8f3b0b737f4fd41aaefc7470ba9782a86a8a23554725575fe0b583782f49013b0bf390c5e99aa9969be4f0b83c382f2c1e282aa04225427e301c69fdb1db05f3eec6b71df891cde2e7737676f08c5239a74335c0b48c4f32a184fe9004fd7ef0528bee1aadd5c04cba002093dd7c48e5f6da6e618ce8cabd919cf7953158ed2b400d4bf5637f467f3ca4b77756314e4343c33a6878c63799bb87906abb6306bdd3a9dda222917b6a8772717f482002c17b6cc7bb73a47c3a387899accefd67f9ea0acd893483490cb07be7cf0cc3a2451ad526dcff463764af7a63e3d46ac47c0a0fb39bfbf68278c2cfca0575a28d75f5f64647908d620b7c3c50db639c2818c67bff498e40327c629906753b3948a18d2defa89987a0dd55b6dc0ed1e785f7b6c1b355771a71e2722da0dfa728bd614397bfcea5be9cca196224ecfc3af15cd56bde9ffd1cd3e8e7157756ddf9dd20539c656c5ff90e9438e8c921e458e8c8da5f6bea16f6fe0620d67e617a50f04a2f2bd681ed34fec665584757186bca29fe65ec1c58bf35e59461554c52f567ae6308d14463dfcfd9b3a1ec8f50953da4d330012d556aecbb1e3d98f9d587d3410f57387b7a20aa162eec462b605f1b46c220998c3ff8c1e131ea0cb43d013c69c3e09d78e9a90e7fd3f916a8a87a272bd79b218922795152323b97848fb641512abbf7e50e304c3631f8d3f6a9f5a5afcb0b18230f265e7795b255b9c5f30a10adf51a8b7949dacb692728038a003b933b19af34d03f3660af257833ead7319819b8757973a087d98f2c09a96035dc609d9445e17293d60b3bc9bdebeab15efa4530c333d6c8a1ea2ee385a9db2a5454064a8ebcb4ee002f08846b25e56873587ad699a9d1b06dae3a3bbd0f8ae6ebdafff92f5f6d74c0dc4a3241cecfcdac2c8703d397622cc1c465658806314bfa7971b7c7d2645c364fd7aeb1e30213a4f1dd6c7df1522444bb5215b77a7d4fec9af57e00ad1badf981e744cf62b580c13bdc26ff807ad6bc74c26f9dd374ed0c21a289bd125f68cc5b7490d2d4ce2fa00a805796a1efa499c0fef4bd22ac7072fae97bb18269ed46f0060e800bd00d9980aacec808df1e5d426f0b20a850f3000da22b6b164bb350b5b08670e6c765758670215525e3a56b62532639d6ceab88f2f8f55dee48c60e15acdca49e69966cb6ba72c9f19e0e17ec1d04dfb890498f8e2933980cd13554f014095bc99e5f2ac48c79c3c0bac3dca4e00ce504cdcfe6eb99a45c7b9b891871f943dd99f44899c7bbab877cf09b987a64df49df39f897cfbfe1c33ba3f1199a9d6f26cdcfd217800c17da97641a3a1e598b24d0dac1c1af1268f881ac4251b777d6bf037","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
