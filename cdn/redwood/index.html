<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73054ae4d5e171f37ccecbd2bebb057e7b5b64b77994c1e75809ebb6f098df5c2abdfcb9a4a403958a2ec2be98ae24bd6b9db4bb0e5118e7d5b4956ae1f44e46d3eea6b05733ebed8ea127f3c4513bb758767f2d0d7211e3db13192173ea3b8706214196eb0bc983d5a6929066fe3207efbcfd717c828bf8b9c57a0fa74eb9ba7b17361b8a436b762f670400d9fb6983a629213ab737ae0252dc62345add3194f0bc4cbc2ca31b10a1ca7aa481d3fd2f0189af87908822bb01da51fd9fb4ac718be4cc19a30e4e1f00dfef4c6a6514883b7abd41c25303283a01d0a147a832c0fa2553a99afd30d448a5823891d93ecf7e57226a3f6ba920211e4f3503dcf55a2f1a37f5c450d37221956b25a4b8b4f81bc63ff8fbab6d81f3b40effd90a491a3230e6b748d1d3611b77b81a89c96f43272c1d6d88298846fd5740711240ccc6e6d296ed86b804e160681918f7ced4551331b88599a5041ba6cac23a506d65c07215d881095461c8d1dd8b8afea2dea5b1c068f69916891b980f6b0299e8ff0cd236285cca9cb63dadafa1f11ac11c2fb1a37265419d79756226706db0775996f9557180ee9cef93ba1f8da66be16ed291cf81f85ae13872a863f2bbdb29dee83e39e6aa69fdc57cc251f823e9b3b9bbb55ebec4ea94d9b85c24f6c064511e1e14757971441e9046409560e353d545ff27d12eca7ce5661d8085159c0f88ce6a5a3581803a7b346ce34d0bbde49f8df5a431cbd813eb668a98fe4dc97ca60dcb47e677c4d4b710096ed5c5c29ac55a165403fa603c2bef7b6210912a09dc63b6c03b4a652c2800583dbaa6953173af960d148112aa6464c29400652af6cc27fcb0600646f6b6074261cae478cc007028a32f7f0cfc8331696394314d844550d558eb20edcc2e2de3445b3c187a520d7a8534c90a8acffd5d931316645541552326eb50b45ca61d42e41d0e9f381f9d79967704a73648c8efc84ab39b5c34ad5ceeeb276b541bf81ecc3603745a93c82d4b5aeb6842d00e5bca4be8cccf38eed3ce7b69eee4b2c2d4209633e19cd2adcb385bc17f3bbb4f5aecfe43e012f433d176d0cc99a39ac5fcde9c982b113113bcd244e5fd98881905d1315029be8aad09bd463ca34c52dc57e4e7d8d3c5f30590dd680d5ed2f5c76fd344df771d105c9e5c67cd25f84c22458adea61817f589daea683d198e269d20933f00629cc049365bc7190c5e3432559d8d76fe00c6fdfec05bddf2d0f51b8ae362be8c612cefc85f1c70530645e6e5f771ebcab15abc2796edbb94d520d76a33951425396f8e78f3fc22303860959a47ffeb941db190c62661ee1932be6bb57486d0744c4e046ca23b9bdafbb160458ad49984168416dd1a65b941d9eca680a631f2f5001db8e5a1c12ca062a8af94099cd428e81968828c4dfa54f9e0c91ab37b27568b24c4d99212e7b25ddd68ed36fb80f9ef052ab81780b5cae8562f0f296798aa5dd03e0fd013cd0191c842d87ba5180d139942d25e52218dea55a0913bfcf04ab62394037f37aa442b4018a00711654c9cf445160d08bf5eff77ab42d25def0cbf4676baae1816b4732f54ec9eda972854dc83cc134975f913ded0440abdd4d8d526496bd685480866c1e0f7c79f535b6c4de964e636616a0185f29595c32976d1ebf2cdc26e9a820a48ef07bc92e43d3cffe540afde6ea29914605b8a685c16ab5746f9d5b1aa353ef926440d631168af4203e197614136b525fcb1ed5b9f768ae494dddfe6b079b3e78d3863419015d2de932d84f09ee416d3f121a9a9d0ec4de4223393dbac8c6d0a9afd28db31d16ba14c502818377d3e7481cd81d1fd5e12d043e05c3a5b67eae53ddd3bd4ea674787ff77328d00861faa91453c5a4cfbd79400755a6b9f9f6433da5c47655ce72e13c9d3f4e468798fea6dfa3e12365073a53423b32d9b2cc480c17d02aa09622e8ddac3871db7445746d14edb5116ba3a7f6a29e48c3f0e59104d311b4978d4ee99d136f9da156b2047fe4d81d64bac208bbf0ccad1ea6a1e4247c61a7aee0f94e1b0f0c2ac3a34f0c0a2db1a003899fb6a0c60955446453f4c90bfdf6b25eac44459926e97b1e1e60616ad09b6c5c464944a65045478772a7712f9a1ac23a5c18a8f4918242d2e6e8f32a0c76d984cacfd3caee7a34edc4bb3efb8c44f2498314420b9e169b3d05dd37e72893f92ddf0c073d24afaeb1e6c6b798b06fccfb425231d4baccccdb9f22fdc7d3cdf0a8d7f14983295f799c75a60adb6cc82de09676c2ac2e88fbc3d3faac4583b141b15ec659d941de3158fbede29c5b230d4fc7846ad3944f1b0dcac06360266e18da4ec5b186a2db8a57753b2eb2426d2a4fbfa6b2d071c99eb29fc6e3ae73fb870258e5d980eec63a4bb72fe5a9e29fb7eb2a5fc6687221b857f4801d68427dc2d2a153b999a6968461fdd7c4b7269287e340cbfe145c7d0b82950018edcc341cc13cf6f2f0d1a1b987a7661e54ac0fc037e5f0db085001490f66cebb3b7754b7f2f56156bd895c802bf4a7a849007d5b75d204ac733d0cf546e9963a2f25940cb67e077cb52260d690d82d0f4db2d699cf75eb36c3e778c30d26f5fe8687461018b4ab11077e66187d2a379fc31586ca3e62c0bd2938d3a3b56897ad6fa8c8e69a947d236ba9b9c517235032721c0c5955c77923be4d5c9f2d843bffe2ec8e3067f74d5197d4508ba09b664bbcdc2bc7da117abaa91a08a27e7b34a7e489b053b0ee6be88037f9ee66dced8ca4e6766780a066c32c1ba5ba586f8ed67605035cc3782dbdccbf153af3bb75dc45f37903bf362b875ebc0a24e9fdd532545521b977eb87b0d5ae1a0969020299ac7f15d494025fa8238231d22e8d3980a7f7c4d0d827c42d8a01f96bfd9708e01199c0f6d1d34e4e249bd0685625f278b2c88f8ba25b6163e0b52ebcd0cd40980d4fb07ecfc536f64afa612d7b99a10dcc9dff2d52e756bdcda40bde69dff9427cf63be24978bfa0024296a776b89f0e7b00d611eda55be12bf263b6d9f1eed244b824ec9eabdfcb0dc4d7767588b8d9151a91f2b576e224e9ae3abd716072497add402be8dafcdf1b846970791df98513f6c9eb80671707f924254c798fb537b3d2cf001925cf8689f180a2d773b7df7c618de6e279e60ad6e6bec51e811eb83d486e3ea080ac34739b2925ee7f700061a296f4a5c03c2d25475d9fafb56ec738af628a62c00b5b1c6399693ae3a4aa796ee6a33427ba2876ebcd924ae0005f48f844f5d85ca2295dec657ccdef3c06937c78f79c7769d6d66ba1dee1110dc5079a915a1f859298e22b2da7560ad470f52ffe25e0d8484ec7ba351007c039f42accaabf1ad23a3fe76bd9639544e6541c532f4bb1b385a23bac73dfcb326a3d9ae9652fc9e86a8f5642a1c8f40983141cdab2b2ed9313dd150958e20450db8588407105ab47c440810b005399a8b7b8c902d4fef6d55336e6d0a022574b8060ec5aa083f3798646698e034e805dcf9bd8726dbd136c05af5941a70254388d3ea3ec9f8cb46329603e9f03ae325089d9fb40d6fbcb42b6c747b8854e0f28eae7dea84583e2492a2c3d6ede272178fd049c0e49d314e19e31adf4b100904dcaa246eebf3c1dc3aa1f7b69b1a55c535d064c358082be1b930770f66642383a7921a3e7b9254a6e66bd953df5b2f01598150b95ecc535df39316130e3a876a519cafdf60c3d9bba07357e799291dfcc774840b1699b914feee29d08b27585b7476820911fb3b22b36191fb781c02a24836dd7f9581436b9194a96e85ec4ce1324cf4ec5d1e4e211f819f12ae2e3254214325c1efa0369b3056ad4a6520e6784ee21bf2b357aa5c6c85b224bf05a0dc12c7da656f0645592c2249f407a01abeab28eeea18b2ad77828ba332e30cbbb0261a3b0a463075158c92f5096dfee377628f3ce8999d7719ddccbacf8df43561683ecf0f97b2f9d780915fbf59b6b28ddb8d15e072c6b2e8cb0399ccc777739596c2334cd8eb1b20295890eb36b33cfdeff2efcd6ecb088829ccc0222b7b1eceaeacc2d78dd45228913b7ae6562785c45c370adc32555bb6093c80bc21ab463efcd7e97e6e18a69539f34f57eafba00bcd4204a9c070aa1a177a807ea0326b77c07c01b52c69237aead825758466757a22cf387b41bb54675a7669771beb7d14a25be20b4c3547d921b30c552e0df4a9eed6d466cc5c67ef7f48be3afa57376dc7ef0b7a0223c13e2c2019f237905f5045f322bba559368754ef68791e74792e311f8dde97fb1e033cc047186e36e952a3d2620ac6af0e06a02cbbbf1e0dd34756ebc12d09ec49186c1fdb3244ca97d0dbe44515490e77c15dd381c6858e0b9d34712315d2314cf499844e3af029d049056b4302b10cf0c73d4b79b8136edfe590f248cc7bd59bebad6ef3dd497c31b99f1309eaf89c78906f37692a099c2c9eaf230ba9dbdb62620056fba2d9e9b05ce6d09f472fb964cc4b165f57009383e9e7327d1ab22163d63bb26d0fe5e835fe05c32457a052b743cd531d2bf8173a6ef2d2c554ee79b6812013b2141d061d44b92e9881610768bb33d02295618085baad0071cd23fafb0694db790de434a3b673a68e91935c9210ce3067611325a1a8c00af56eb79b2e62c9c236b6695a66d68ee105287dedd6e41d99b1d35a9fa094598e951a9f01d449ac0789b4465d6cd7f08e47424293ab4a3bdd2a0487239be2b3dd53e09024fd50a4f1d6eda8d0b190dff8453eba48d932e301bfc3360889e4ede35b060c269b99fe83419eda64bfa0aa040d6557b2466bc36db7c5438ead68239c9566d70f27760c844f2d22c3fd22931dfb213d506d613055ecaef48c7b23fd3e0cc5ca4329357eedf561c72a923fb87c80441d4fe18e6b9eb2060e5cbe4a9046ef0f6a4ce12caaac406be887e2b7aecf14eb7231129d0e0b0316a9725052d8d5f84a9cbe2043fd2364d1e4280389f27137b024e52b1b4ddbf25d68cb7baa765e38a4ab2e15301ce07264c5e9080fd7d83c3b72af2f49cc06fb4ce5eae17e139d4e5b959f3df1a1ebce60899f467827bcc6ff2814705b3e9b987d601065e0681e64d24cabe05df377a5eeb2bd28ec65c836daefefd6219071004459eedd53d79033d978b74f9f61ac65875473a071c92610815fe06858b5c723186fb9f7ffb1f49ab457f3ab436b33b692b4e4e4f96d176b0aa925cd2377a2b2b77316df54ae941081f8b5f7299ae11583c3f61422dc41af6f98e79b2ce93cecae6186d7cc46509eaae085dea21c95976541bb74b53acd637c0d9ede0a94e5f7e388bf3a88946488a3e6143e3e9cc9aada1ab1528aeb5d2f7d491a8353a12314181fe1948ec84f3031880d33f68662c95ce4b4836268d024b9ae97fe6c7f9b395f4d8c2efd986ab6eb521777f671e6d949d81289f7d2c8cc4392cfdaad64bae4963e049c77dd284092d94a36866007b9e0d6301a214ccc6fdfad8b491ef6129c08a6429782888b72198e23301afdb330adb12d7c70be0fc88e34233f962a98df0a8ee17ee089900c70007dde9e2c7e84b6cf0e0268cc8a3c940a0566c2625cd4c20cdb2a4e50749a9485ec623bea7bc043e3f099d4f400a5fe0e8f9881ce875c70574ed3393468eb5800e87e857105d3cebb84a6e847a2de61ee1d7b688775ded5cc33f8cc63e4752b995cb63c81f456d918fe159c8ff3223df447aadf67cce209750631abaa03f3af5fb8316720bede4a4e190aeffa93bf7df919d25da4c2d49d6badf5f53883ed522daea4d279a90cbace055658ff1f51035fb0730ba284ae902c0a4e00919d6600c1fd867a1381f52b4b62422c1457fdddd462576382c67a5ac256702f4437f78d94a08036a1e6f0e360e4b309e45eea381f19d01814f1c700d7842ba03d3407ed6076dd5c5392f0ce677e5cd07d98809bee67e2600b774375618d99593f50d172482e7e87f140a78f394afdeeef1d3b02cac5187721e962cc065bea668cd107b1a2f0d99a838ca4f854d9c8aabe81fc27275fdc0a22349afd6d7c4266e1ec918518ce70ce04a9b4e92ada337ade514d8d5b9e694286b89804916424031776dda8dd861d54bccd0ccbdf40aad9850de5bd49d84a920af9f67d675ab8e875112994413aa8784ad96cd7ed3b00a23fa1744cface766cc995dcf4f3e541552cb372b888b7ec8c4e91aa495130f1d944a07131f56aec6b99180a373759c4f9959df0eace8188bee28c0c31fd5c3b2a5f31f9ee03132029b4fe52a7947c2ea16f543b27f7350418999af7d6043259d1ddeafd701ca3e4e003bcd7426461b1ac518eba1750ae1826f043a49d8825fffc08b7eeb2ccfb754ab018840d0d40cf376dae23fd4dddd64c12f160d6fe672245d38ad84f98568b10db0f910b4316435beb420b80e1d9ae62acfb9ca0d05413e2b33746ad3d2b99539244f339d2344dd7858077b2ee59463ee17d1c12a27992343cc56b238da5418d2ae27f4221537fdb4a280459d9a64d8d4c07cf1f8d9be07a1900676004996f6da33483b77e636d6bf11a9b289b3bf1e2f671fc7650443cd71bfdc86090f52a9224fffb40a70cbd939a11f6776efc4ae3307dd4b813b3d7367f10357f76d08bde33acee0ad3f523e041c43c3800cc6bb794f1e15ce88db8a5d255d1b3118136b2fe23043e83cb45e5e5c87362963aecc721dd2c475e94f850054c2d0735973bae4b1c380ff9cbc2e89709058351ce6b42755c9b6940171871d753a318165510310ea35fd39816acb9b4f6421ee0a825a7e9ef5135952ab29fced651bcd205f61055b7db6ae91e72d5e5acffd85c291eb82fb837e4e79ab5841d3b2e769acd3234c2613e2e06810e20a819110d204ef6c3398e72ea20dab7ec156ef885c511ffd9c2920575f118386748b37d93a0ea9d11a21ad186172c2dcbb4bd5d6fdc267a8b2a31c1bb64b1fbffacd4996c6772f23f72db1ad3e94e458b825a1ff9f627e7ff58415bcf2efe0a07e8eb05fc5bb98197434ba6008461fe36dac164d6bdcfa894925414128a5768b5df69337056a011c479002fc9a592f96af6c516c24863641109a245c004cabbeab54fa2b1764b9587b8787158462c7e649da52c5a60c5294e6560ab14266b5e620f8f994344499c2078a17d43d14cc2939ee45fe8021e458ed0789fe7aa74cff4e966961dd21e3024d7cff01235fe7d8b075025dcb8f781ff95a22f1cd96c87f68c6dca030a94c1539a8c4e019debfb773bdf12d1a80fdc93f09b5746cd5bff73fac066331b3fc2858d4d26f284676cc1b88c36d4e6cf1f9783962ca8bcc8fd12d861afedd840024edae9ad02d127db3b226ce4acde0e30ef5ae871708375d294b123866d9f3bc3e24fb0aec7624943f292bcfe985da3938719dd2d8716556f5204599a62256502356f3278ff09ca304cffdce1276a05da072fa4989ce2f2510d25b73291c29df64288a526747aeef68d9fa21605cb38f5fd21aa43f167d9ef81387ca35702afaa96c3c8c15ec9f1e5a4aba8d05ad306b6879a754699e8ba648187931c39a8623f5da0b6fdfff25f300df2dfca6fa4bad355d4836eb7528902c2910a1a8c5df329fe54a93f1ee1f94f0da6262f7068e0b5768f7d5319520b3086de6f8c6db1f660b5339175c35be0e2562995986a3aa8f9d00cac9478c2861d38064c6184638c302c47d500c8af4bf50f182d74386db88f1d0beef50744ac401fe98dc3666a97fd5ab340ed971b930393c09c6031c3b168b35dcb60b4516104c22342b1a67b0c9e181ad9a53a0fae667ccb659e7998149a9e5277e78b59b2cad8107f4304fa9880db0c642ed1c527de05c96f42b73a126ce3d1c463fc66dca65c14e2b67d721f52bd7a3affbd859d7aeb9d6f7e98d37140626e56b1f8db3457a4d09df4ae1a07103f5105a83e1625b99eb929d2b41105e4d68ab7930fb4870e58568a16329e5dca2325e45213cda270956908072bdf36626d2d903ebe25b9061d0a492eeba8134b3cb035caa406290ad9352326553c0c0203d3e094abfe70e7bf92434c4ca5ce46f8cf3e579087a1d44feaf35825aa2253dd0b6070b618821202209a444a5c7f6d9cac5817627036bf19322ba2c63a5b4526afbc0a511d5cd0e0892fd21500c981a984d58f3e462520b99366f5278628eba249c266a3b561abb8e84672b03811b5d58591af485906d3e71555dd0f54fcedc74ce96b4d225ea11b45c2742e376d717861dee314c4b7f8cb3a93abd8169c2391c9ca2a8e3e2e0b636486041e5e9449229470268304fec0e966b427beb64f51f67784925dc4a832be91b2123cb9e8453e4db77542dcfacf3cc4873378334d55de4e6efc194268d262fd9c465d30f250c45e8fb5c5f2e3746649321ccb6c9516004e662f2c3bb09826a2613fb5437b95adb169c9e09ae9ea6a8a620dd4025bd31b7da385cce6bb9ca4fae4142fad591336fc8a9073b0543342182d4a3ee1d3ca2a432e8e65f19a36e001341293fbfc70ac9d471aaa7c74ee5ab11b6c62ed9b0d6b516b68f68c0f8dcd517ac4b02171e2d2b64e0d8633d746fa75f1cbcc7f399312868f9ccb35695c6805e4615abe792aabc25e471f1f7f10ba2eef945c9736e21dde98b8a296beee855b612a3a32523bae9538f95cfe1e46104890f2eb6fba49bc8886fcbef2a7c8ec6e244cd398039d21bfc9e1c8bf66419686f39ea634a123c3049e4e47316ca106d499351c99fb6d1106b6155671908753ca2512b7c77159d7ec900ebe19c011ae9cadd88ef1eed44f43e948078b03a966f360475bb655a73a69b1af6dfe523e375190e11eaa8b950d30c3373fae53472a706339e37375f7e2265d532954d50123542bdb68f4a7b33e91876c4a1bf8e9ac177f613313508d1b25e1d1fc534cf0f212b05330c32025a08f8c0fbde49f9f72f1148e713764032725bbda8b3de62b485194f855f830d94d586e823d2a40fe4f4aa014c5339f2331b1f8361701e1aac04aebe35d173b9920b9952ca423400299fc714933d8a0e12d9d8c62e8797d2b1505da8af8ddfd2d86c47ec443891b2edffedd2851f2761edcdb6a4aaf88afa055f3a02360cdea8919f3bfc3943bd3187df99be615dd2bb1828475d183a6eb9a412188c4ef63af13be8fd2c943b0adcdcad75a316cbcaab4efeb7ae1cd13771532e2c44079d0c9fde93671e68852020f94d35256b5ead6bcf59b4da2b0c05a8f0356abcd5b0f3d1146130c5bff88c7b46b43a2cd68eabfb4cf792c91afad67b5aefd3b41b8f95a6ce4ffa09fafaf2d3636641be6e418e049e3c9d8d6b801de5d26d70b2a8dacb882def87b34410547444a465edd9ef2ccc594f22c33951f54e7efbb6cae2ed38414a1b883a367f8232ca282c2a4d08e3a16cddfc7bb0059ad3157be3e53dc440be2664d17a4aa841aee768c00cb024476bb12243ea75d50dd16f2bea881cc3fe2fa6add1eafd51aa0f6d098ae625a9a2ee43bd0020dc42a7043a54d33ad8ea4507a2c646ba5ca5a5ffab3d3ec012e2b7c16cce55acff7f28eb5af4efc3b3b3993f8841f8f06462ca7da19478225e9a83145abba6486c5e8a6171abddecf3a3cf4fc126a9b62f653b6801e0882268da17dc80ff3186c216528959203b62ae6aba0f299963b57ff95df4fc0314891ad1aae6009613381d50c89114b9a59bcbf31fbe2ad32f294e502495a5f09220ab66feac680e0fdc9296e51fb8a430e774632f812ccd60cafcbff8a2192ca3879239c57cb718fe890a4a6ddd8b9d1bf012a04dec270b3c185537cc712d77e37574f39db60cce1532d016db02fdd7fb7884877d55d27e1d9d15deaa1864ea28ce971d0f2658f15aba022d245d2b57a68c82f581642c5934189af710ced303f1db1cd41f40b3f14a45a38d4a5eed36d5cecfa7658449ea3bd40986c4a93de113f5fbeefb10afdb0bd5c35db25b5ad80a0bf1455614c83cf2cad5117b8c1c3e298b418189e9b29668847170d5f76b2e1be5da3e8dc52123b2a95b7631f77de78ee0f4a49784cc00ef466141fba23d1826fd31efefff9a45a8d579ca6b0a0a0a3bacc6ee0a5c56ddad61c8f94ae00916a795c0bb891defd54ed89e1a52a16887cf6cb60f0ba01f5086e4d82394f5956ae9c778dec55b2bbf5bb54236da279e45c0ae08c2cb5b1fe78d1d6886f9bc1e91bebadd025530c76b7fbf7c05daffd0e49577e90180cc820c7d490a786dd4c599b40a822e9fe155f62b412d8900f929ec040a7c29035f5b588059da0c1d31564015c1fdd94f6b65f18f502e8caba480743d146b9824f395fd8bc7505d0f69a141e47e36212d37baa4c7a95927978ae27b1046cc2092456b8d9058ca12935af839026faaa5d54c98ae745f94f4445f4a6e72d583489f618d26735fb2ce6ff1173b71cca5206ed3ca9ff4d239bffa9377ca022db78704b9bb823e55ff3dbad5740ee320def5b3155f8f6722fcfa578f8de42af3c2708664316901220fd2b88a5f82ba448b849865426793edec0f684408c4bd8c780ce062fc7851020390c88c7ab52e8a30f3f8f8bd036a2a42060d58007082ea288eafdfda7cdc6205419f65c01d307695e681a88994a0b462d989aa1fb5870d91377d984056fffad5ec65e72c6181979e22258f16c7ea7470fb112978a1430a6dcb99361edae17866551ac4e84ea04cd7085404220ee214d253dd09f9321878d757f4f22e54d581d6ad1772035ab1d7387a6c1e7d46e76931eed7d8c24a5c4be479ea0c27dfd0a07610cb6c349e2075bfeceb16c4415ba367d656abef68494c0091c1b09b73a720ba15b854fde73d0836ff51dd815d437ff6c8e5aaf3e5add74d2e75badd89d7d768e46cfb883de3cb4c8d6d1a332a8ee3bad22c09451d32ea2337c33645611c017c2a3a026e743b72c1d6576ae16182ae7c294e79bb5d68c7c685f3a32ee969cd79a015e78a73bbf44f1233b45690eeef795ab0c1c76de5f4817c49667a45ce239642c331ee4487f0f4e1aef05e5454f6df4e1e237d08bcda950cf71e5fa3d702fb2450413e3e669550c4bd1a2ae584d0e02184b935db686226692b84d8129c7f4e9ea620d35fa37c89766ef5e10ee60f807e6a0e0b6e3a6f35ff41f7424f3817a80b123f0f2288a05333b923bbc9533aaa92edd627ce4143081db27893adb771d004ba0e8509ab775adb9e8e294af93d3f9467215dd7b2b5802a997e16b610780953547ac3a02c90242a6cd47d428db5efa5d0fc898e1fbd325e9818109ec7559f464d69893d58a15ed68db4c8d3696312c5d9cca93d253c9b4a7ceb3a81d09069c536f29d32afbb9828f78e21345c63dba2b9d0cf34650865ae53736346bf97b48fb1dae9d3feafa4e2e86cbecf77dccff0501ae390550e0ffbbfc22d96c166d4db849e64715af92a10c897e20ed62e18f364e185e486b63fcaf713d363c6e0ffc3effbe2d28a3823d0283edd5eb220983beeb84f46f4eb2d475a13c118ba4d23a6e2d214c91b09e94b103fe283f915fcffbe9c15090ae19498c1fcaacaeea7c0b33555bd9072ef0ee67a42314bc57b8497a3df554af78c4c886f809a37183877e566a79d145b9b3082ba7f3855d02ed824f6c7d2561f11b92a2627bee0c20d4c7f848bf5e231a9453b8b49615427694f6f870095f803fc72488942c36a3b5017fc318921aacc55b83eefba4a7288f5455b76523931e3e7165f7efcb623c87d0482dde362ad8cebb2df9cf0b7304866d2ed97dde0c51e12b45a27d68fde722cae8d53984be3c441523bb7b685cef021cada2a25e903d7399f059f6a951b80b6939994f9d2088997bb7301c3672d2c77593e007090aac2b3636b1ca54b445f828412bd5d51a0242f15730ec55911fa067303397cbed70092313d332176d38f2baedf9dbf681d88ec0a99da4bd73845ef2648a608166f2c951980f6f00949ef6524c9902a39430c8d0b2f1a610e4ff52f2a680e8b88375411814320ee3d88ae5cacf29f4c46c448bef08e3ac6423443fc699bd72d500d0439c2624c13f7e160ab3150b88d9e660a63813f871216ef224197407c155f05b709d6fd3ab0c99f474e2c75d7ba957eebb275e0f4cbd246a9dabd5d2ed176bcafae8c7f43f184040752ce288a0907513acea746f32785fe093f1797b71e3707b02fc6ba6ffd9fcd83868671310104f6e532c5f450fadebf1796e16c546d09bffbcdc4444592ac37b71ab499214c4722e6e9df14bd9667aa753effe35a919db573fcba4c8f6b7ed57f1b90f8711d303556dcc6f97f9c6e2fcc3d83d3f09739bb425e31a586f86a15b664c35edcf0a454e6d6e7f95743fdd17cdda2eb3839bd207eb935ea9bad7da7001d190ea5b6484d958aaf557e78a0126fd27dd02a1275a63a2217266e17cc84b73c4f42c173415799153f3439f4e66a3c509d5f5d5ca1a1f615f396ece4810e82dd12200fa5c45f8669206b0b6fc3907bf8bc9c67d14aa7cd8ead030f9b5b2d596c354eb1183ac95123d458de9fcdff778d6f9c1c04257a08d6ee6d834057cfb85b9be70d81256c8854abf30c4a17d099ad1eaff3f1599c9fe27f2e8d618ade4e15f984c227ba720ee5d53a381a5b86bdf7a7d08a3b97f0d499d8718a395d0c8398792c4e07fab4e9fe40fe4fbd95bfbee9e34203f8229ef52aeb16e3c2a8ca273818e82597efa218133171b7c4196662d92ec73eb4f5ebf2f026a1420a16802284cf6f68de3a8ca09418ac6cf1694d6664f3dc06ce4beaacc987cc424c0ab7032d193a05703cc2456b65cde77caf4c292e981e32817f8d09dae2dd534f4000f065abe20403dcdc11ca53f31d25bdeac83b9e5be0dee07b8ca973beec5498195468bf3558bf8fce66fbde5dcba6cc9b6883af490dd65c83947f442fa4aa7effe820b01fbbb2faf341f182d35b6db22957ddcd91a8e85fae2162bd0206e3d29dd27c39e2693f79216fd337cb275f82a8faac16d9c85a744f9db4f34a1ce6ce061f3a98182ba89f640fd2d0b03f1e5464248f3c7285666c7a1f256a7edfc80d27ef302a5dfdda4aaf3cfe7d41ccf331a0849a95511f870a20df5d9097fac4f1b78b2ccd50a2320a6d839cc239d9b5466870993f22ee387b4a5d36dbc487c2b07b2d5d1f752c04237a1b3296c8c2086ba66d31034dc01091fea5085d3dd8d35085094cf731ea4e2d6a81796e097436c8e2ba2cad669aeb1af71ca886ede00595b281e07fd1256c67e2380ae8c20ad8d6a20413cf120ee00e9ad768ee3ec6971bbc7b1646b035560888245da50c569c73b2875001e494b852e9c2c9245ca5d91aef068e6634419bc441d8661ef90c4f718e599d944c6df80a78d2543c9795d8a931e67d89641e079f7a182db4794939f8662fc5b8ce4f15252e3e9d53985e1304574726c22d0ec787094bba8fe93bd2a97d30222f828385625a7c6edbf8693d672ba7b51b2ed4ba83ea56f391325e118afbe49875453189f59a976d52d24f2af0e654ff5da02ec480e702672fbce6444b351dcbe5e709e303138d99a5c146f922e0ec20b1c2df70a7c2ff24ebf411a3edf14e44f907eccb41490a4fe53e969fdf85ca507d5c86c93cbbbb5d81829f825e393d2d7051cbc946a02fd4c981a450d826b99ae50cef63565fbd9730ff8d61b72e57f3eb09dd26aed6f87476ae019854462a410fabb67f502c10fadfe0247713f5a17693df89356ca8b9bffc31c22629ecdbb0e451ecf8efc04bfd2181c56983393e815484cf3b7b00e94caecfff4261dd6e41aa2dea83ca5d20fc6de10c448f4473bfb21480679ec7b10ff34bdb98c7eacd563fd301684ab32f8e305d20b3aa3f9b97b30217d3c9f222069664d75153908f02afbdeba21279d47eb2620ebf619098854c85dc5ac01bdfc0a1c02d7359130ef1f723df1e0aefce429a0c403fc83187f8a22c758fdf38838fe5b9696c970ae252acf51ed42a0c771b802a5ab08b0e85c8c1dd68391e73145a041fb9bba3159b6401b4d7303c07d0cb0475d8b2fe58e8a354e4375a92f06456d1e2fdc930d127557c37c0576a81b43eb99fa3bb55f0a0c9489d826e6294aa008477f10c9b46d1ddb9993fe3b3119694952754e9f0081da298395cf40d994b1f57f21555d4973fc517e7be7b5a5bf2da61793e1084ec98ba0951424eea1464299bfa8ec66c445f3e639ab0d801564c202c9dd37092f0cb50abd3b777f64df99581713fe55a017de77be1b19b244b8980ec2df07cd1ca2d5747fe43b52d06c82e46c545052cfce1cf8dd21826f601bff6b96838e8f7f377519a1d1e2698a9e919621736308e1c3dbc03dabd843f598b2c274d64585a729e489b42d11c41e174bd837ae8b8c1ab8c5365365c3e2ce4aabfc74677e1c8057f197998bc1ae215dcc3f97ce5b612bfdb5d275f8ab7e1972f607cb61bc00ec1a0e46a93b2717682f7be00f7661ba85d26c066d114e6ee89a3250da98dbc18b6ec72f0a504588ca1b566018e482d951cab244b7b68a1aea9ee353fea2ec1de9b046642d9e135b0c5ea36dcd02045eeef2e50b255391662d07f856bbd8b2a29ed3e099182c845467c3e4ac67c7406dbb0545e74490a24d9a32c10c10262aea648291ba99ad4c8210c3fe307ba5ee0e11259e124deb733247a5ed30be39f5d1d62976930bd36ea84b01fddb036a2ffb4e656245b5b4507adacf70eaaa73b0feb356437b3eb09d3f6c952d507cea80eaacd262e6d87a863441b479d7e6cbeec95694057d8c0d42c858443b11a1c65db88fcb7609cb2e79c10ef75fd1899eb8e092e1bad1577cd01133820c0d412cc464fe935bc398e86f6c4d60071e850046f5471ef610821064fc167956f66ac123e794836aed0a51408c4e4cf6cab8ca5d7e4770430fe2a5f04f55cc686c5f8a064abfe3f237d244c119085dac13dfe2b52dadc89d508a80c25fafe747587d22d1c310abb02095a474663bca35038ba996fba45211629356ae35095f787f8ab88c977721b1d7df32fcfdc6028d9cff480a12424395ae86dc8b2268767e531ef8ec889b5c8febc8fe78d163355bf11d623754d06a9a7db3d446081aa7962b0746cf398c3f9d711f44df81c9dd83543c74c3417f1400e32776db633d631f6e87673e71ef9901d9e6525825fc4ced82463e6a2936ae2d689c4f786be4e59cdbce5120bf200580bb595d5b7d797131339ef8036b130d013c9b6fbc4e5d0819330beb40873dc707feb2bdb302cd4ff7fb8bd6d8a22dd0b21afee6e5c7506eabd955cb27baef845c0b43f1c087403347316395dbb3cd92c361c7253f0b3a7d7d5d1e0ac935ad625d94d31f4089daa072a7ecc7f366b9dc28de24cc1afe6380f280a9d13658170333d410b172dcb2c3bb4f69f9bda70e17319e4b80c63443577b7c6ab6a46243481142252de8a7d15ebb89fe0453cbc5cf8ce973d27d4d26fd0bc45b6d57f1bff51a614c5799d2a91a0b8c41dc26547cbd5f8d66e36eaf910927efdd9b36178e37bb373dc4595826eafe59f30bce68b5e531f3cbe2cdff0b7e7e7e071c5ff398475e9beb87b58780fbcc1001cce1728b7865ecce5942d70f073ddc5451556fa937e66654aeb3ef5284ffb853cf666d2330ffec5b1c5bdbf70a36a878fd2c9237f20cea61ab7d386698527d4e14fdb3e20c25eb2ff8f09465d3d93542b34ab8233c91deb2af9f9fef70cc4c6adba39f611b3c32927e9a8d28672cab9803f522305b213bd22fd95a42638bac98249efb86e0c6e639b7e3d3459578a88278484cbb2b93db60e6a51d613df93b91b6c08e75605faf041ec4e0708f3e6f4ba83df99ff297cdf77a4ecd8bccd5f17ed48618e69acc4558c46ea8cab3fd8779645e6aab1c95ea94d6c7639d7153f8bc56f3f8d7337719b5ad0ecab370816cc1605bd6a5a6f3ec647c0dd66f266dcd9ad44786ae923af2eed9166a28421bce7bd952aab87602c250f8dfbb4e7b9e78cfcf40751b156e1942671f7e7502311db6c77cf25a81a8d883e8b31564de723288696884d34ce29a9d0e66bc9a0dc6eec1dd57afec63a17d51e60460eae391fe47a8f0106c199533191f7362c73a607bf6301ad4044d023b05173af10ad11317b587bb1ec22e83cae2cbde6fb3563cad5c32e927a92bd81f9d10537e6321718c599c91cd766ce33cd7af603436dc3586957b9512aa9f477257b740a529832a8abc57159056ec8a00cc098fd5dcecc40434a2487e887144a2a11e495a4fa698d27f1bb26317d98c4eaa4af4a191623ee515e1cc6f29b2aa6c21f5451322c05b7788c79afa3931af774d22c2a1d11a0f3c4f35871c2047216860c3e0628fd443ae7bf39f0170cf990d46504ba6f96b53b51ad14451626f1a615cd0776a390f7b84e3076fb927bf96bbcbfe985fd475a0ea66cfd4c59420fe17b863a66cda143fb16c020649fc9cc13815effdc6e9f7e2fd0692cc9dcfa89c920c6deb8e458db08707c1cd8853364133357f33eeb612287e51e38e3aa0c5623dd028f2ce9cb28dddd6c7d3349dc0267a21248f226202619314cca320c040ab0ffd99427acfdd768bb3593c7dd3555ad3b1a3f0d5a45a0ffcf6590550ad639177c7d3ecdf1af17009eee9221b495fa13fd4eed908edbcc3aa8e85da760bdf5c53f11f81b4da63777cd795e7bf69ac6156f94fac24d25c16421a3237dbf4f552cc867627cffd5dd6f01d3f7e47988e486d4eda71631269a8720609f1c51bfcd4e405b206330e510972b518ffe690892c03eb62f3629aea7f28a4d2daef57804b8419a1b8eeadd6ee592d64943e2d04bf7a67b06c73bb0bc88fe4f1d2c8cf80a5df60db4674ce0b8851b4e54c7ca1cf31a186c444a5a32ebb88db047d8800cb1aa096b4d8bea71d7fed6b542aec3be87064ba32b2a0bebfe312a3f1a3f51fd8d28b42a1bc5e7f7846736285da4598f8dafc469a71c32a4d8363458e533b29b0ad4f7b56b06aef650cd69560f38bbc4e482d5e84393ff74935cff10200c89a172b1e0969e51fc65a0ca9f3edb6a12cd68b48bbeff6901c3efcc381427d62dcf68de55c3bfb5bff5f641d5535e2a8dc626e696ce165de43a7d874390f392de95235331d2a55c3d0848ba55b1a8c080688cfe03b8a3c5734e0636888532c66f6a343e84dff7b8e91d4b367782ac87dc6c65a2cda24888c2dbc083ebe52707eedc706bcd42e5049c4aaf9e8b86c6891c02f72534c4e455f6b08119f36fcf3a20bf93c078da5429e467bed4f10e0817dbcaec2f32cac7492a3adc93c0d3e015bd0db45f5dcb87d90fdfb5fb7359080bc89564372ceb1a75f277a725615b130fd75b8c87509e853edd68962ca3b24e69eb3fce2cb9eb11eded147e03fd0949869a61c94b60bdd9f26b9e49a94453b4bfad1f5a77f38e4e7c823e6549e11cb400f2a9dc8b2219feeb588c76a9d1b7636d2722bd4fbc19bfa30da26ca61d4be08e5a2018053147f428a1b928d5d2f5bc9fec14ce192ecd9880629ae78844c5d1ccfdf20484ab20813f049ae8caecd87249448f7629bdecdf4c285212ed11565eb5d8009bd9a934a99928dce498fb380767d2ea461e6effc88eff2b5ee9aff163dc106113341210edfde057a842609576700897220d0e7f780123b92ac94999bf0d4cca51afd47b4608fb74cb6ffeb56c8d6e2a5d5c6eb897fe4dc055dc1c2b39972c08a01d905fbf271993ce68dac34bd569d1e1ce1130a716f7d130d0247aab0eb038a95388101f084e61ec7121631c1a59a61bb881b5402ff65db16552207d5ee0322b78c2e8eeb2b5cceba20fa3de71f806531f1b1bd997ca67c57d74bfef2b0dc4c82a2a6fda224d8b98dc8da33049c12b34306d39a62892a4ad5ae886d73006d2bd53de59097e1ddaa18ec462ecdadacd440c4df7230dd8794523af1c81ecfaa7a77e48a56f22808f8c71735c09daf6f335138ebf34e6bb8d225d9950fdc174ca9783f41e2c2ba9f24e4bf91e94841e1f96f32089ef250363f674750a37130e91eb7a4bfe495bdb8116ebecd08b947e87c8dc8704b12d7c8e4f80bd8d2c285f0de71108de0084a7cf2edc9cac05bf7c1a7010a43","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
