<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"785f3327a01de9ed052df38521ba805d1c2a0d0c80919309f1ee807421fd3365b328f69f5d9e9123b846f09d1c1e2d8ee9c1c6345113d7ac781bb6285253ed6bb9d881a77ddb8a8ff6522fa356e4317d6d8c54f723ed28e9b7502af61bd79d83d0ed156b7d99d175637efe14d121361dbe5abc2bf07f4cdcf0c7ada47ab23323b0d58f1559ed9defe89c959b3761134806237fac88f8d2ba881a9c262dfc3a9d5fa760b09e0b159cd46afc301fbe25ba9367c528ba26cfddadd78e46922e9216d2afa316f3e12248f82b9acd9c6aa913c20c12a53cd7de06c91d3d472cc6e699b5c32c90319726e7420efcec53975fbd67ece438967dfe976a35960e909fdfaf72686f9f330f0f0d51183b0020968b36211528d4c06010c92181329b719755506411761ef04047e2531cde13be4d2b29f4e0ad88a52a1b2db4fb00506509d6ac58fc16145d658aff9c4f0de61275ae17b35d8f40b3ec7596a5dd4c9c9b70ca9df42da7a162ada6f55299ddd0124455d4b5784bd7ac67cab5292cef585eb64bf17945ec0ec0b8f961aed9ce093122409a87361b60963fa2e6dac0b4fd6684882001f185723b17a897919bc491d68e3b448632733925b533e3fe5e046fd79e69890b011a46a4d2129d2389e116f459470723c103a9d9b8509ef02bb92185334c640228d851c361ad72ef913c16920bbaeaec656c76b4207675084b643f7270c53165e874f500629444b5b5e342e284ae3db9dd26e03b9328333608e99a3f8f972b9c30ef34f3f1b6d56f9ed5d835fb4621a786d74d714a675c56cba3e30435ffebe46560fa05b506b77dfd967efd797d01a64458fceca27fc0e205be0a71257c728c2600fe952a5e5c77a64fbf75de143173e1eb82e18909b47e49cf54cbc5b3b728d323dd8f28636c02290a9458e64d1a14d94ffa60a7540a6e14c3cc873484b0f5250ba78f60bf28a224d38b1b478eb6ee8d69cc61bad6c95257d5007a320fd1238fa8d7ffef195675828e3bfefdff08b673d33759d85201b38c74e76ebd23b934f487b2aa3f655d7e6e3f2800c73f8ff1927e5b672a94fc8973c13d41a6d384b7c5a04cd21cc33c582264a91a4050df0026259936c56ce5129295545fa54f89d83356c80fd3bdfd3b9cd5260412e1290641ed69fc72c987d5b95e07a05f9031dea27c4366ce795a8619465ee16c521075699f800c235577f9ffc06ab6213f51cdeefd02690a4c14006598d97503ced8b1572445a119a441c04ee10cd19f9b01b9b0bd01501f3abd0e1c08b7ba5bd8b6863f79bb1d4a65fd86fda1cee7f2a51a7c09b27b741847c0b6444fb3ce1ed68147b599edf658cb30e46cbdc585a87257a0b99d4d1feedb3a2980b3d1ca5f3877854f4f70bf38cdce428505cdac9a351e357b4574f8babd30a8ed256011a7e516033db78718a2a613b9ff6a3bcd6d6c6f7383219f9e96491e7b66f0970db8233703fb2931fab31defc51cf2f45c2382797f9866f237074392f02f96ded62072eaf1a3e6ae11313ecfca2a55d46b329c3ce74068f5789de921589efcb5fd7132134f544f8c7892e4bc3bf65c115eeeb05079af176353f89b4d5fe6c867e764d402ceae409d82ffcaded6f54ea1904a03f8c364a03ad7ad6cfe0380401c5dd7c1c79fe96364a59b97c8ebfc4512212fe69e5dcac39496f5546612a4aa7a6991fc7d5b29a899bfb7f9966ff1b7faed8bc8d1ab42c8d0551f7128eaeedf64dbead6c6de8b4501f43307874b381bd7d68da11375549349d78b5f3b0e97bfcaf20446789e4516ab8d0c64570f035590b3ecd90a3955580ceb53614ff35da39618362a422179630b726dc00d8c13b4ef0c55d3238f0ec384baadb718de97babe2a39c3f50ced5f6c7031e8e77258b762b947244968510b7ddfb99120954920ffa7089d845a800d92d4afc1c338e34eb735aa99c34e0fc193dfcdcbb067b6f744958f89fd1a44e7b68b926f5517b5cbd84e1f8270336ccca07819f3475c7fe523efb0bdaad2c60a9efa11ada9ea6d952eb22b055097c49b89df4acedf2c98fd791c6141761d32d5affc4819bdc72e5a73df6312542d2b614f488c2b9b85ec8acfb8e982bec4408fca70dfa14bb0ae97cb36ffbe26c0c85ee633e0db672e477e8e2c9c8273897696f46d58c405d985f8dc38b7b8b57f35a9a7b2adfc0b18af1890cde8711900232405f45e5287dc3b1867ae021109494eb64b801ea3dc00f38810339788662b6c069367150cf3eb779e7c31cdfd9140e117e9f6f5b1a57c785d1c12ac904c083f862b482f0dd04cac00fcd008814c615b50e8494d1ea79e2828406958c927c62a39c096a825d6e02a3b0780a3315384dd6600869bcf0cc7f4f57445485efba9cbd42a1aedc77f240c9b29d510073f57fe29363f1cd2b4fd0d0ac458bd9212411c9573345d8aab9e187953326df673bd1282a9843c59f0c248f4af75f86846ba74ce872db036b5828ece9b1d9708cabcec38554e566c117a558775710b00eb8d35490225ab291e6e8e71e7caf41789fe956a739338c68212b9c65784aa51e0291aee034e4318ad9e26b20fba81a035b871a2812a081e6e9de905c06aee340d21f1c6657066cc418d260b1ed2237eebab622f4d5a8528e24380bf935eb21f3c4d62c841a546cb8d1e73bb9834bb7858eb8ae596a41a7e6721ef0dbe75cc46cd22aec6974267b33c17b7930df1b9fcc56846b0e20513e92531c345e6a77d6800c82c6886b3957ebf7ab57b898b386a5d8cfc0163c2d1f50000d177d0285c52e1c2d4d55273d290c33e57adf15120c9582d24bbd2f1cb74bfe5a879e0fdfb2d9671c9c8f8faa8c8c56c22f806b071608178b40801e5fbf1a0cc331a896315716a0ed14684b11398771a312c1b5c22254d89a807b0606c2c4a590b66d1a94ec97db982627e04cf2003ea5a244982d94ab3f3f1d80e74ca69c845434f797cad6e783a9763f63a70e31c99659e6384e5a8813bd8a22df67df4adea6eaea7fa5d38698920bd9238735139dc7b3c310d3ae1821ee15bc9f1d38fe2e99ab23000653b553c6a80950b2f0f1c7b4d7a09f813594ab9cfba0bccc2b76ce7d0202c7057d84656c14deb872198a779a2877ee1daf6fda43ef0a253c5bd8d91df37e1b6339342151ebca74c453e24610857565581b0da16a89b13b23e6c8d5e77630e251dffbb9a9cf83fbb6fbd423390256d0301b6251511d81e6d3aaed177d13319b686ee90bcf652be9ad38c92d5d88bc6d89253683991a221e0951702d695285bb74a025673abb304b0447e82a15a6540d461315662455b7f6d0fac69dfe10f2230f8ce930ab8f1ff6a346e85aa6964f7cc189f39d3bf22ac45cf4c5f62d22a11adefb36d1d54e6c6560a8b9061c76022fb4b22ef3e22c1694e29271510147b2ee49f6b9ccdd1b1004a5ed5cd95cad3e81091ffad7bb341a163c790b9e5d109fe72c888d113f5979199c80102ea9db128ec09db57c555a9c11b38095051063b13bc774fefb8da9363eb14be6dce9ed91380538426563393035ebf287a1bbb913f79437c04cfd8283c14cd37dc308ba5b459c34f444de06aa366629e53d2d806d39060f06fe5b1f1922144285a99dfeaa26c2f211e6518923dfc55a0625d7f2cf1a4fca5ac88305cf7a9283a450df130323f6d28794dc46899ca15bfe33adcd7c8680dd6218f6096b71a2db7f4738415a367024f1c8c260254c2a0c9402db63c03c4556a19e41f2e228d40c9397d29e8326170a02429fccd65cb1f395da681eae517c0003324f1e209dcdc965d3555280850a3a9a76d6717de5b2fe1edfae9da78840a79bf65be7244c5e606b6009b92409c6c7ec3aa0349c48ba56f46f3cd1eb4e8cb1fd7a12f2278e6f6abbb257d72087ee5bbe921d3c949b0c17113c6afdd890fc3bc1c373ac811e85f9317e9fa8d1a60be13fa51552cb9631fd5c480437774efe6ac8faee9371a7e1f2a73e03434f3fc21e71a86caca52213e1dc74fab83a6846fd22a2f640b8712b9c18372038949976108c98f51a9452a72a4ec6bee3e8d33012caa303e35d86de50c9d59571b8ebf5adde97745bf5d56977c115ffeda3f43ab1136c7450b7a701f14e6af15723c768e1fc68f3476ba71c9f867de38bbb7e55dbc901022c07e54c1d8d612632928dd60b19dbecdb3549e924b20f43d3a453976dc539ef0d2883977df84e578651cc7de5d0ac09c562d072f2b625bc3e775494d64b2cddfc6633ea884dff29cada1dc13c48a984c2d47b5a39aceb46ca36c6ca0fe429e3e1383c48585482e730b07946a247818752fd4ed7d566566379e119a91252e7db748ade21ce539d707ec347b80cd996245642fd5b10f58ab9c0d039ee720e1bfd7cf4f7c9348482566151f95baa4633b15377a2ba06889519a62e3fcb8c3219bde156b54f3da2dfa5a6136c20e651f3387a9f8056f58dc544a16fa2e57d86c92c0d0c382b17e77d4777dd74dd04cfc4ea181ba6ad84c5e72282e7686447b4d44c92574ee5f2ba33436bf5c5b17383acd0382f4ac9d7ae7ed035684d1b028eb09d9e8b16141fdb73cc7eec572c3e85aab6deb15b0540fb5a8266869eb78979c89255551689fdaeacdebdbe36e30abe938877940150b3db32749454b6dda822737dbe362d5de9b53aefdebc3d56005b5a05cc01e56ccf532053944afcac00d1ca90efe2e1ce62832fe9a134cc907bc04fd3e0a007ad76764c00fe5d67e09ce88c77342f87e280cb398340c2d5f3f22fc0687a5ab73e27e4d16521ed6999bf0de4a851e09b33bc433c0d5b371af376e85f9597f3b7ac19d4011007b1a953640ea0850115e28572924da96a1cae985103033d674aa5d61e3ac22618b56a55c5959bca5ac2d535cf03f6a4b78cb4fd2635d8d2c7d273ef8e4bca05666c77d962c68e7fd740addbaad17933929908662e284a490b1bc04f4de31c5b6110b9eed06bd5565d01248ab5de4f6e5b90536c06510c0ed3f858f0d88762c1f0d70393a51136fc645618c300c8ce3f284192158f34f21b8958f58fac44a56fc430a8254412afac3d3f6ee737b60ae9bb66a0162095ef2345dbb95ba415af2d64d7fec3c8be56f2c6b6c9b5b5cc999841bc085a1a9fb147f17d9ac84126791cd77fb43eb2f047bfccdb2541ca147daf4b328d70f7b835a9944549368e3f07ae06d1e726c27cb2ec5432eb0049100b84a4e3528fc704aaaca5feeabd86e100b2ed95f5df6e5e3d66d05153310c6b3237ba44dc0b7b3aa04fec4df3515750c446782e71f344f3b2a83e009a889969e3242aa411a4ea859767dab43f347bab659f836df3d92a44053aded3f7afe942cf5e7194545a456a513fcc9e128fec1e79645deffb96b6cf560161ec1f35e6f1888f201e048251f72faa22614766df0b5f074b387d30f2591196890a03532fdefcef165d1d723a0f0ab0a2e6f0eaadf8ac8517ae1667913daff86ec0bf7a7b76ba3dd311c2e1e96e154cca85ddd63e5f8e9159b6cca2cac6b966787d4d1f9e7494d61b9a2ec49afe6704e40d4411d63597c2fb1090b4adcbd2e2975dc0d9f09cc14e84beabd9a8670822a5a383618c25b342a4987aea78b9ab38054407fe4e94853fefe7819df60ad10df219ae376dc3a019c58c65b3c974117032d9f6ebd0ddab8ee311910dde16575cd6c9ddf9398ab40cd48b3c3dfc2a8ae3aaea233167b183b5098860eb0d9033ceef95cf585cc189e214571c6831fb873672a423201263859b3e0a754282b12a05fee62e453102206b4bc3db21e94a9160e70307d25d622b053e1e064058e6583831c8514535f64dec05033d7b30960ea857381fb1183d2fc74d6af9da28c8d6162e33a7a62cc13b2b295fd5effeea945774604084895936a3655b9c382283107a8e344f8326a346e1eb2a992e62d372c2995bad2c037405ad41a5e0757c110b02db07c5d1ed7f62d509c45ec5da9f164eeab7334da65c8ca0d394d26540a3297e3fc07642c1d7fdff4c404fef8a46f0767a982a2eb8543ca67af920a252050b894faffaaf121f52a1ba762f9691c7bffbae2c9480fa29df61ab816af31435c9f5fbc83fdbf355df4f48763f93ac4fc595732efa8b34372a0036097c155301b1bd27a045fde78e70033e4251af54ab1af3a31162b59d0abaaca6b17245d8a3de3fc2ffe0816b852c93fb21857a36e74b12bf4ebaac7f47ee3da099862c05a160e6afb2772a664c37428c1293e433d83c2d73337e0cc2674d3acfc20f8a995d09e2659be1f318972bfa12fcbd299a8ac24f3c45fcd90dc64162bf10b10bd33b3929771bb426dfae09d187bd200adafca5fe14c50978077448fc2e1a257e88538349d7bbc3c398c248761f12999cc4130ae07c17821d25a0bfdf9391a94273513d8ee7b1888a08020262458fc4f0edbc32f9b6d960b6e30c1db0104926c4d7c1f04aa752086f3385e1bf6b01bf2e46b0771e2c433c923648cd96a583ea594e82f3e65ed847836968c937e3dcb524d996278441f06f8841178efb135470ff623a878b9eae92acbdbcf6d67f97daa72ce56c22b2ad42eb35f61ee0b4182fd49075b7781c69946a900963de94bf15143a9a3f99ac34bb9f3826b9bb89ccf6b734c0a570edb6b0f01c0b09c5fbce52ca7d3d9173ba974752fd45856d3e31f60bd17b2cb144ad7a281eef484413fea117cbf22ec1c3eff3051cf0f92687a937addaabd92a972cc4e786ff389de0c1d73827685407c1e94790d8f59094ced4e901ffa94634a483622680b71015069ffb8cc6721585aedbd5e1257e9f401946d78ede2fc0a6b05f4b964f1da5c34c4a7f6e4d0a01b2d351df2ac8c3cb3e2f245cf48a1f1e5c5925fd69c70c0ea49b8e66e569935f2267af9b17f2e8d5f7b05f384254baf06e136dc5cf48fa1b461cf2e8035a754d6c3bd26434aea2d4b38f07e8eb86584a718d97d1af1c70c857fbd90ae00fdd9833e62cdfc79b3103f35e73eb0c55482180f228a2f794044fb95706f6578951a08a0905963446a8b2110aa9dfc9353c0d108459155b41c42046e66986d3bf421110830f46b83e6f24ce9b6b9bc6223d877a24cad1770fab89a6ff7bd13efdc4282ef36dabe3f4401541036abcc0e63cb5cbdd0dd5c9ab3dfc3eb18b50d8e68ebecb9ac6cdfa58dc1d2068bbfc007562a245a0f8f5a8e4edfa5c645126b74a2b99a6d71f71861a01240e01ca69fadaca2aebd40aa2406d42a08fb5b97a7aac5f03cc2847444793aa5ff035bf68b6459825b3905d15efcf90f2f03059d6ce2451d17ab15b74cdceb66c470d3a3944c704fed979fbbf0b5a8833663843fad3a730d3bb29ceb21167fdddfdacef7e5f646eef810e51a091647a2dbe6edc222bc79575a7f7f852bad137263eb77cf9c9e6f65bd97fff4699d6754d871232db0a247de2dc89779ace41162cafda46074dd7d6c0d30226e4be3a4f1935a2416ea25a6fa0bec25e4538815f6131042e10d1ea8c1c0751682686968a2415bc71d831e48263dc61c1e7eebf826a7784cd0f41249951238f7fd0b4869f003e004ad32fe39553e8ea8512027508df75d4b7abd877b0c1880aa9921cdb341fbd1568bbe6a9c6efc64c379862257778a09bb7f2080c67333d9dabf12d9f3783f9e6b843a9049f5ff937e3320ebe74d19fa23b3c98ce1e8c89490f6df2f04cc32d1cfdf9490336590b4858868ec1d0b023abfd1b5194d8af4170dce84b9d3ef69ec8407b3ef649d9d9118356eb118f70750e2e3c90f9fd60cc6dddf4cc9ccc3445f0cda671814cd35efdd3eb8dbb62f15ddcd31c35e15d7c31b47e0fff4223d80efae465fbca04ebe6510bd8e1b46024d4cdd8ae697d941e7c8d4bd5a8e1524ad936436e652957b3b0ffdbf754c376d02075b44ffc5a99468d962c24bafa763dacb30530472ec83d075cbf80b2f7fdc18585afc4ecebeb36b9dcf8b3f93e752a221afc1672c3dff3d43e02daf4550cbc731331702b0bb9386e0ab36fdc8f3b91252bd6b15dd300fceac23f6e299203999a42ce0dffad633e5aa7b4bcc8283b0520afa14287ab03ee259571e1e43b9f16acc4d80485fd721704ec164f0345fcaaa0e4b1104f122106a74f54a649e1727e442d2570fee8135b910203b10d7d26283ad578b12960a2234970fb731846100bb251b6eb89f014da955fbe972c41fd0fcd0da73e292517ec5f645b1fa333f473c8152f473c04af29f665798ddf3088215abe626c2b8841dc446ca2f0a3106a8db92f81efc41e062a4350c7e09998293c32fe551187aa5b581c931d863fa2cc35feeab8bbad98fd1da0728ad55aece7c5da61b9f63e8b53a5a2f9db271e5e6c0f2b172841352a220a6b0f37ad2adc34179e1dd4f7a2ebf6ec9de59a5ac16aab9d762a4eb9cd04f75d7ab32f9ad174fea8783a466ffbc373a1d94b4401c8f9157f8fba5f49783000ce5abb08f15bf45ec56a44f513109ed0748266f0bbc9b0a65bb5b4966bf61145b9c73cbb872b2cd5b605b921cd942aceddc3d8cfd6253fbced0c29221f7ef854999e6422f74b82b26510fe6411ad82dfdd4b18be27f7cf4b704083616c97e0181be4f2f0f6067c55dc0ede476f0c2a721716c650efedc0c01657c989746ccac09227c6b66e95566eb37d1a382459bf9cc80c9badaad1fcb7850f70cd9f68c28e5051a7d3770e92ab67f80cee6735d90cb22570f8332b48717f0ec1306815b4511843cf3c5689d8a4688ecd0c958255cee064a8829c5ea61d2408299bdc4b3d2722190e35efc2485f0bc0ab02e3217650c78a43346d21c5404662cc026d5ae67c0611be83c638f0ddeafe527d9301ae50f2a8ad899a6a1fceebf91349bd37bd87908a50d924151eb04ea603292e575cb7099570b3e3598b794ed2a2b5221c0904e6ff203eafe2d9855e5e7d3dd50e6a25966faf093a338521d15af238cde6a55d3eaea88400b3b93319cd0f363815d63a79e41e183ea4d402e00d9365bc4e00d8e336231b3b6ea302739503f5b61152078bd703463d23a4efe06127e18add3fc9982e25a11979362c715de3c2d691164b28ea5fdb255e737d316a64abc3e338605d16cb694d3812b5efe01355acbb2b50b3e5e8396cce1284ede5d0b468c30316e9fd8683d2c99db6a0fda95a60a41b2dcc988f87be8646e729443f30454d5dd2d721e86e674c1d584dfc271f1781200c30f44f4e830618fbf42ceb042e4c3f3f2cb097596c4f59261dab3f2e59288923e96fd35411b0fa362dffad73f99107d111004a056b9fda021c6ca17d6191ada37e650af9acfa3e22f179317b3bd984c94a6644f168e14d2dcd7bbd35a890e39f440b9623a65c4ae14514df66e5f4bb24d6852d869e0081981a8fff3fe3dcc1e12075273fef6195c03bdcdfbf02b03c1c569a8ad26f7ab7265c0f56b0d5378fb6d3851415e247e1dd39ae9be1f055b000a501af1efa24f3eb99e0191f5c8f4003ab17a0a3b3a94d4de035d06789c4e6354e959117c4a11bee78c782f77fc57e7fae885d1f3702dfceee6ecec57c35be48650661801ed9b4d647da7a00b6219e27dd1cae89510aae9cac770f4fdda1eaa7c6687d858589568a37927508d753f798c41049512044719558697cebe75f2d5bc06e700262c10b382e78b81ef957b369fef5f9397dc228247d101b7453c341a7916e9a438ec9f2c361cd6e378f684f07b54bf33e17e700070514f35aad660a9a956e665dcde509c4a9142cfbb82690fb1c9b9567263600f01d91c92040e7608755c7aaae047104d93dd6754d54a81c84f0e5b49e1108fc58988e40d914cc3033265eeaccdffa2eac30bbecfc5e57bdee2e8fe6c44ff94826262f9a8dffd193edc31edc4bf2e5ccd097d837b343747760f0dc6c09b95e5343530931882da6873a5cf5b6d746b3c1b448e8fec163b0e2dc78deacbd85e67382f5b0a333c6fe3d0d90e8c0eba373973bebd3a595726d39ea8a126a93af1bf5759a035108a80144cbd13d42d575df342a1c5b8347b573d284578522ee83d05f726884651c28aa6f23d0736e8b2735e2421b3be821117ae8d24baa2fa69833bb321d4f3675482daf6676892fcbc5a077c19b5955912377975388dc824aef0fb8b8a6c9999a11ba650071df35d12415843372e1cad31d6d7d02e48e93ab16877a6d7ae31b7c528c4281949b1615e6ed64f12fa7cbf61dccc63daf143721d02bd1bb51c4bf1d17a1d32e841096323c28f8d6bd6e53c6f51c98139f0162118d171df25ca0a00b6a57869fe84427a67e1be91e78f67ca9838c844247c4ae47b0a20ccc55ce1f3b2d1b21ae58ebcc09a9ba3fcf1758757eb76b4e13e3da33c6fdd06b8eceedfb975d7da952196c3a0e912be6cdc633c57d68d832891146a8eb0fdb4780a42f1cb159a624f61290ef1879d6af507d25a2929fbacf13fbe15a44cac110ce078e54fa2e30d5cc8b549ca6cbe31ef361757eba4fa2887c9d121e535679c6c22c5787f9b29dc8ba0e28787a6821697428d5781b92b0159df492a7665d073cd82a5fc668d5f866ee27d5b2ed9fb22e5948278ac0aa03b85c50fae24e1da965c29926a5ebde1ec6374bc2f1f73b0c06f92955fd7978496d4227d9c63933950b5a3a46b57bb9fdad1bb29b15c3847e00b2bf72dbf8672a1efd5cde54bf6dafa669f3b5f0f9962aa00e76ffb7dfd0e800d2acc16a60a1dfc380578630c4f0f53b54596f2909380291ce48dfb06962497f426231b77ddbda8625e6ea27d122e9d722fb886b97189e96639214bfcbb024e89edcd9abab99d4388fc2286b5edbc485d6dd6d79c176a6340defda924d5b958f883000cf71e103f6372e8d7beaac247728394e6facca9bf227a65ddf91ec5aba41cff169f71fd15e4145f56705815397f30a967585cc03939933efb52a46ce732a61edb63570d944c6d0f7d19df664d2fe963ca3778070153b2b8ef8d26e4bd93d698ecfe626a11c7e32d9b13fc08c7e6a907b027feed08150001297f1655bffbf54f27ab0ae59504b213cdeb0c913b4bace2317d6a4b38abd00ea47fd721a0d69d44d61ff1c52af07246179d21c2e6cf0793f4009699f048a25902f965f4525ab0bda75a80b1699b38f1fcaad99d1740757ee51de46680f86016d9d6ddc7fc7034457531c6d466e32d5a25f80e396e2fbc33fb31b76deecc68f20fff6ec88ffcf33d6b68608fdcd58d3e4cc5276c075256dc6028e38a5800823751d44c281f09ff55a5a26d4cccdb171488293249934dc6da31c1c6e4bbf63623e3d6a6c6d0105bd0e2031bc824ee6a9fd4531ca64b58ed909083115cc7044edf02d1b84b6ce6bc42060308a3384184a597728a743cfb58b687fbebe2adedeb37475cf4a0c50cd0abec0c06c7901be510caab2738f802825f5d47dd0230acd82310d554d1dc32f9f3d054acbad964cbf85ce537b5aca7a5395b41a7221e750565a50295011eedf38e87f950eaa0c09142c08fe4c9105e0cb2edc0bcc1486dedaa28c56303ffe8edcc1d9e1c7644c1bebb80b0b31a8eb4f726f9a4c70c30103bec1a77d4d1249dab43471926281b40999c8b94109c40d1caac3f0f364a2c3ba4ebb41312c8ddd2611b0704bf7d8689a46d45110d12f47ed0d18d15996dd3861321144ca14e1b1b90994a96d5d540277f81f99139550b6aabd785461706a112b1bdc91533df0004183fbf633b900dabd1c56c375c98dd46243694071b517746f9d33c8ef3e0a53a53e23dd19acef8ba2cdf43c42ac37d1bbc299c440b753f7ef0c9406787df4659e8c1a01dff5fdc9f79c9d1dcca97213ea145192e256d33fe09380739b08b6a1b5ded05b223778433cfa713ba8cf1ae952f5cc65eaf169072cc01855990bf966680dec30fa2c03113428b56ace168e67eb5ee74ef42d7ee938861d734f3d9724dbbd34dc259fba9b786564bab022dd5f0adbf9c87b2dbde78b8cf6a16c358702f59ce6180c50344a113ac2ab278af0ca8a5fd6b01af6f215f3ea51d2667e632cd00a291752ca144958c025aa215a443810fc8c637907d978622c13102bc4efc385739a7704f813eecd2c26005c8a1d772bed6365759130279b72fbf5b152bcb3ed7059fdfa3b6cfdbbf8ac3f9b2132e2155bf97e659061569a42a819752161d2dac22b7a3c9f6b63f14f3bcb442cfba0e75a6a165aecf7f6b9e6c9fe407656f9ed4deb982d285b6c3b8006ae660e52734168b2a6427c36d5b4c275f983ca18c98544f4ede49a5b8421c0a857adc6e5138c5ab8df5f7b3c9f93944761d9c22ad3585d51d2277b575f8d35a387c23fa4a2986e914f8fd810d322246e48169d256443c7f9eb66a2fa02624c4894705c9790782c7a1262057011200d288224c925df173837858bc9e8d4d7cebb19a035f76fc09533c4f6c3219795c16f600211b4a18e1a938870f394fabe4f34230583ca55049e69da15fe88044b9daba4dae2278710c7026ae90d04bd5d605198bf2a12c84a807301f339c0ac923111a0197c9edc18d441324ac5ea18e136b85a314f7512df8270d9d61b3d7a3a24788759423d62afbd4eb04119b83ffb1185aab55ce2be8d96f196e33728dcdafe84d2068d6ca847d4e05a13295822f0484d21d730ffad64cc0a6b9ac700a29a89b757211bb2fddef64a58141d97c4b25dfa9db86badbfc4069885fa0e46d7665d6b710b7c49d6467252405ad2e6c5615c783867dfbad240f54d95e80628064d189f9e5fb908737bfc784fab495f03e028d567c43af6ab481b6b1f5a950687abd20302fb1e06b4c77291c551b11b1a8e67738eaa05a01720a54ed6e344d0c78e5d76e23f899555c6fded40bd95cb304c9d5405f31521eb46a66214788e4a5deea7ca1622cc03d57d7e1a9ca234e6a7576a6900cd643dd4e5d0085f5bc3887ec7d103e90d07a72b696ce7bfc56554531a1a4f408cac196ad1837db4a4e0448d8c1b033c7a1b2a2f6e35820cd328778526b39b8561c7273151efcd4b1b75a282d72e320cbac887b532c771637127df5a50bb06768b6d14c75193d26639af728b584d069006124d8034efbac11ae75075ab49fa9ad651816d0ab0d91d6d6a630a7b64e54565f7885de051bfed00f184534faae39f3c6d51f86bacf93cfa80e42f168c648b3973410b8e327cee03224ad99b46c67394464fb39893f0639e337a1d48c013a1f0dc07fdc1f0e02434f7ee8966edbc93c89a0f8a552b97f6ba0671274b7e6e4b8ea0a260c6d761a9c2b4823d5c53de76a1958fa861f2c239548c2894093436244ef10f86d53f933c2afd87165946d269c858653976a900f22e9440484543d6d07674fb77624914305f335084c2255894a74ad6c15e4687d98210eb44df38bc95617cc38d18468433d5abdb749f03992be58d98793683416073521a679ad9048b7ac8b39113c288e27d4cb9d822e1663c6ec3cb8a470e10f3ba87e05b632ee932510c7224b5fa99e32c25a6134d14d489aa6c21827651c19c2b5fd42098980beee814af775bfaa1c1444e2d800b014b35f0299c0eac2170dc410211e7e2a0d0927add7db03f132abd30b8cb28955830d9eb9fcc5e84b5d1c9544c5a0632f85a5e634be0e13c5608b94ca4a6f7d59a7b67b2be3a1e724295f5839f899ef520a01ee18cab908d929af1c4f6d78fca13183c6fb41259b78b1f44b14ea8b2feab37eb2e39f0d2a8899452c7660370cad2a9062fea4c201ebabc7cb03578c99ca889388559cab31b623b0b553d893b85672fcff91d52f0f4abd592f1ce95a518b99462213f9b621fcfbde064836ba5969f63991b2a454dd47da9810d6a0ba97f08b0bf7fa216c1e62d3900c90a3fa878267ff8afefcbcb0def011c60b24985f1a970fa3066eaf89b6de6b1bf9c95f3100fbddde95bd5d5b15d1b589c3f9b1626290a45ed2747ac8e8b27f9fef93162137807283d4d81a5355f3cd0948c3fdf7c0fe82ba2abf88d6814486cca7af4a10332412922dcf5ff22da8a6235e2256e49903c68059560ad71d0adef1d065187fa22408e1fc5e5a5fe8b09c38f950c81abe6bec51e07ba7bb68d4975020cb1f774954bb19fffa9d9b2d1e5944d70f913497fa66ace2a085a845de6c2c6066f8d4bbca0e343e4e404403f2823bf3194e6b5a25114ce0ff767ba3aaf8970eb1ce084fd8b202826d00b035f58e53be90fae6cf470bbeef99ce1ceca43273b278e93e3651439b6699ccdfb82dc01768647c46f465a9a41d1d2770290eedf809add9baf2e0d17abad7b1bd3b88fec1a4a1f2eb4b61f30a9608b41417b0f3bf211d216e2269c6d4f3a111b4f732fa78bc33fbd178095a84032d4bf782d232951d9efbaf3af9f8b7221780294ba66608e971781ad34a4f2b2681d8a523ba61830c816157cbd925a83c1694c1bb5c8a4c7dd538d09642095cb8d4fa78d42eefda2d715891a8b23adcd8c26565f66d8e0a48493642b85824e9cec9f8820efc4e5e79043f6beb8b30c5f9c25b1daacdfc1f0c5cca074ce9a9979163ba9c40b330f4c2186e6ae12e58fb6622cd1048e3e407bfe4bc1da48f492b15acf33c11782e2d1de2ffadbb69f2d83d959248e4fa73d7c09d70a9e5f93b5dcc84730fca4101699ca8ac2cac08543c8fbe95dd17cfe3daec15fcb95d82f15141c1deca5f59746b1ecd4484ff74b33ce3b86dec5c5fee81f53ebf36bf429ba6dfe336eab952850226d4d88154261c5d720fd929165aa747ca2c0fbcacd1b6f084fcb8f2951a049354ec1844b77a6a3f8ab5fb0b3204652cc579ddfa39e7930b22d67266dbdb64db0c18529d11ae34810cdc6470ffe5afe619f8b6ad691cb66ed78b000f4acb25ad4d5c6aed209ce312f13322407e8f787e0c354ee275f3d61045a069932e1c9add3f05e1c9df66b7a8d74533dfac573ba5ad41c95ffcc4804da245fe6b3dd731c18669dcc4e06317b6903de5cc9fc41fb0ea8b951eaf5308b818600268999f28d85c4a8b7e697635ab5677e842e0b21e7f09ff742dd77436bc3ecd76af413a0110c5f87b572df2af804ccd53d2d0354293692724d0c0ef904afc530216469a44e4de8edaff8abcaa82bdecfdd6bf4e9cb2c807d12a1f9442c3c8c4813c2897bde404816cd684d46935ef5e315804b67042244a443c84ffdb970011c9ab4bc51b228c020fdd9bdeb65892727ddf3859b3ec7f27d7de727ea205b8157a096bc2c9ab858e7493da6947eb6adf0d8b421184cf5c639def98ca8b8c6a26db6eae723c0dfbcd531788f3df64640cf7d09357339934b1546d004ac0edbe1da2f373fb96ca3dc75dcb33d3d6f2327d8c328f51ca4faf13afe74f5175ec8a1b9ec201ab35af2166349de4e377915058ac2e513d47ed5bc5f46879e5176ec1b44837330bb5ba9c298166637e2f52d7caea97d79ca6bf94c074284338999efbd08d0b8e7387170936de1f3cb62bce226af0a9c49dd59fff068197e4653a332c882147c579b2e734a3961061413953584d6edda5967600a01bc417181758b01dcad1792f75abf63f126ae6d1bb821c58422bef350131d5defd3e52c22892da0e94bb2b1f4eb5a834279034c00076bca01012b9e3b8e162318b0bac9aec5211e092b0e9e61f1c09ba5a75beac256c48feb3d06643a03c292449b7b69702715dc2dae922054bcd2a75213dce25f5a05affc3aef411ed3a9b3ac2e793dbf7474434d103e98494ba51da09aaa8eb06ae746d9be84f611adcf9833fe64808140b9cfed0d402ac5a8a0435ee21cd392cac6cb73796b4e4b27f801028fb52db9c1b447966f20fb36f6c01aa5b7c54f23b18f0f6bfd316bc1edcfa54fce3c5f5c2c9e58249b457388d3f7a30f11f90da00474e026c5e09d68cdda75ad7920beb38d5d6c69427d60e408694d24185add3d51c2c935b150171bb667dfc354f5bc85e5cdea95e74f0922adec6a73ed3153f82c8176192b9a495bd3c5701d316b0514cc70144987a2a77f649f439c9e7d348de9dace23321ae5ce02cea1ea51414b77546d4adcc0da102135363da4bc29f8a3024c3a6535d6786a883ada25cfe34cba52daefd696adf044bbe27e4c8fc2c1a7c9aff5e96b40811c1ecf79c8221b7fda5d2a3d601167cc308a73b96770597c097930811b2a8a2ab0fd53856f1dd780990992c9e7a61cd0a6071b68fd88f55df3dae8b2289bd04252a06fc6959ecaf7fa83a9cc56a053e35fcb0f3b74d47eae82bcb08a031cfe72332ae713144b1e76551654d54d40ba361c4d7e2ab5c991eda69296fbd05cbe9853070a2ccea45dec4991780f50fb6f61b1ad8048b1e536c678cda70c30b86396fb4378d451711c60dce99d9e5d80d13530b565ebeb74b680734d6b96788da89779ed52b67029fcd472e91276bafd6e59f700aa40f3ef62eff998f938beb003a790bb761679e0419c8d480bfbe05d1bc210ced8cad9a3f6a1ae36b26a868eb820e1dd80159a7c6558b2a8557994dd5989f99eb8cf473783c3dc48e26078868a6d42b5a6e6dfbd1dcd4dc52e0f5f9e4012052b305dc789b020296304a58c41a43f0ae6bd10100e450e9ec96e7b88480fe7d7320bc39fccf1a4c31ef45856dbe63853ff4f270b3638c5e604d823d1612f99e8e697bfa7b05a0cca17e3de6f7ed216c8247794e9155752b47675ad31dd6375c5be1ca5a5a9d96f576c2862e60ba344d35aca7e49a1472ff0473fcdbf19eb340b7cad5dd6e51fb000f9fc56e0ce681d0ada2b7e1a9676590e866ac026dfcf010be18e052a403358adbf48165fa00e0a993a6704452ac6674228882e84db417c4fc0af2b69318e319be79c00804ed23c1f6a33c7811ec1dcc840361972089f750244e11a8c289046611b038f18e4b2bfd6960f81a3b739e6d85454fbbf9afc87586293214a760c8c3e68ea70c7c5504a8bb5dc6b41a69731241323a57298ac8267e8e349526be4cbf21d8f49c122823bc558a6af17bb9f1e549d9d484325a5656ff7563086aa48d03d3623be5bde37b7f71e35dec4b385665107ffb7ae9dd064015e258d2237c3e93435acc66368d78dc8def037870a144dd455a293a07ecb2bd8f9d01838d9306fe68ae73c84ad366493671b40f228c4bb4189f89555345d63c83809e79472ad5d45a61aa543aa7e2b13a2e7bb25106517134b60317b94d5e112ee2e4e6e6f415ef21e2fe7e119f3ab1cd5d44b1e908172757f141df1ca2c7b50e745625d823cef8abf1f00bc677feb5185b6cec93d85e718290599a0b40a6bae3949d3f17e0cddad84f39ab6cb7a6c879387b58830fb5aeb7a0caed1c9edb6b059d1a2d432028a8dce7c79c5a791cff50ab1750d9a17fb4f788e9052b86f70ebe362b2f42415a2db824499a69a90610630ee34618b9d62dae075816958633e0eda56da15c93a7bc6ecc38b143bad769f778f8e5cb0b3f8d142b0b7d6f9bcb62d033ef9f8628428add632b3e96b62ee44cbc5405e54ad22457fa80e409df345e54087bd1f8f3bea5bb984e57f2a5ee2752312484763431ea682bf6953cfaf07f463478d849ba152df4184f092702dc1b89d1fca42b83756cecdc6e38c332275d93b9e8f0b48654b5947109a4b52b7a27be041e5e02ea3fb9fea2e68e321f772ca1ecf5c4c39a0b4421197b877f7a32cf081cfa2897739337b61f14660fa6f072eafbacfe1a1978c132641261a97b16a2ab1f76c261d94a2244bfb79e5f3182b39a8b0fa7fa8c9fa6946fa740bf5489afdd3c01607a20a4a2d4b515c4727dcc3bdc3fdf7075100de813f7d301ab6fc886322e784094dde4e845e10693edaa4c0acdde607b0ee2772331406f547abaa614d104f4e06eb05d4da6b4fbe7d5f46bc84b425de2d0b9ead5376d46d3fbab96b23a3506adf75b4e2338c443f79d023403f9d39a71c95b1ea3f0ca68c015fac36d09d7ea495d64432c2c3cdb589254dfe8c328c98f40dfc9c424a922363ceb34e49d7473cec855859cc7070bee715ef425ff88db25a6554a5bb4b1434a8a95592b873fc14eaaf96b79c5c2c030a42509cc5cfa67db24f0104708e2c6f7dd96cb8e4fbde789ceaa1b5359b8f05d9aac9414f1558d86dfb763a571b2890b6eb277b5f285aa2e23cd5b87","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
