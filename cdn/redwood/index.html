<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"921d52b205ad0af6e004cc84fa957af8b1fc1dcec9cd02090d6b71ac0a91671c79445cea1abeec42789cd089dd77f88ce756e93ebaf2e4972ffaecf0b8b79345a518d56d4c88dda8405410ed06be46f087b96b182818dfda89e6f3ea3e59a27d2b71e6939bad2acbd0a7d55dd1b2c027245e7402819d2faf962960e7a1b67d3acee0a3754bcb1c6361c9d8c5fc8a4aa3ff173509e2554cb51a28ee011d6e3bce0d3679bfa20d3174aac6923cbc4f3a53909002316577a9a3620aec607b67b0978a65e22fbb1a36c1bbf08237dde6d0f7e199cf742b20ebaed3ffad15ee7370459f077fa5cbc9695f7d45c93cc573654f6aa554a46a03b3a9d10ea7309f5bd4936c24f9ebb5c3d899f76459eb48dd3180e7295ac009156c508a079e6fea18289c258e374e4d66905465aa4b091bb608ae45eb5bb53de6ed56218cc7924a42d7a8a0642d68716952279d1d0fd989c8cc687b4d86c2f65e5d0df2340257727b68d9e3e0f98d37f3c16f0a0ee1fd8270e311d9186355ebfac7950dbda43cc1f03f8edf0caaa77efe38d760f6efd2a9b38ddf82f66a1d2f6edda9de29c6265beac0f2adf6d95883ba9eb366581ff5a694287eafbffa5376ad30b00678408f41966ec169c539140b2cb6bfcdde975dcf96aa180647d7170d1addb9cbb561754e6940ba6165a00d03310a0bd3777f0501424f0dd2d404c23d8466cc31c85b93d0a8b02ce89b4d86d968ecd961abbecf09b235dad0ff8241b55246239669003564d71bfc039acf82e382a0fc31474812a7e5821ca7faf8549857e039becbeca09bf2ada360749aebe69e2bb27a6c36d8770b43b34db70790ff0a1f19e8289280b4d00777dcf4f892f689c64d19fc2ceaa2d0992feedd8224f66f998096563589c8c47fdc01c84142fd0802d0fa4e83373772d9e40f67fa45474b38b0282609ff62258df837abc2298aa025c6e1cf92fff65d75429d1aa1fadbf4086ce28fd32c112b7035d6da9096dc9dcd2b71f46ad1b515f802d2808c5ea0ed273c28104666387251b89815fe3cfa63f3d55e0a0546126d61f74c2d2471c8c58b16d21c7406a540568f2edeeb572001d3efdcfb8a353162fb8c1d7833e1095079f318933cfe249dada1ee0f10d624560e8edd58153d6eb5fac94744d8169cd2f5e008903692121e096b38a5776d54a6e3d2ea62f1466c00cb8af77483105f90bb8665046c9868c4a0a9c46098d51970dcedfabd3bfbac0bbc1cfb42d554d9d92c2ceae598d8567719cf035f71c9640977a899fd1cd328f096fa329b62ab5992afef1be3f2982b23faf1303ee64735ee6e81b618c8bb83029f8302e3edc92055729ba8c80815a9d703bf7167999dc81573da87d60779a42d5c0ae684bc43fb0b77997c61358e26f514fbd05a246770513828cd7126b6a0735601de0172f31f5b78b07648a8a876f1574960271fbbc66e867aaf7626e39d4cdcb968244e1203aee1dac2b3f18f0f047ebc9d0d247082bb346b0f3f4813e5ed160d1b49f0e52c442c5e86d086c4f3a0dfc597499c6769abab67a12ac6c39ad5fd9ba75358000dc18d106c3925c8419729579ab5cd37c70cd8988194a3f2ff4f9b78ad5dc85b7bdd2bd68e9422d0e13509588c14c7264aed234bd8e1deb54ab258c9c0fdc299fbed8146a246329c79aa16b0ab53430523aaaf93e42bae9bcbd58a5a1dbb86d9af5a75acb57cacfaa28de766f18f19b8059035a206491f3dcf277afe7d0e5f46b05fb1074c6bdbac24fc30908372540985ad4e42b34a36511d895b1a185b9acb4ca2e5d6acb859d1dff82ff486dc0525de74b7f59fe1c4cb88d438f1a9ebe650fc0dc6b0f137be5e6563678f1c5eca76fa208f8bbea88bc17b4b60cb7d9135adb31c0320c6b31f7c09f6ecbff60bbd587b7091855cccc183a4d328ace2da006ad7eb8c8df194cfcd15b4a4a493083b8f0fd6b8570aae81d8265ddfb732d2907a78e7853a19290ac227ded0844c27442043d2c7b74c31624f20e44ca8fb0c3040eeb05c96f669e02622b1609ec4a5b76c2282832817573ba0d2f18cdeea8e8e34ba9672c771966088dfc6d582aae65f696073ec354f6ef332f4d72a3166b3120d56db6ac63540293b1d9ae910b1a137d54c73301b3977274481fcb5a5f83391c755e9a6d61fc7666397af40d39369fbad5ebfffcf5d70cfd19f255c94a9ffe92cdb9ee632faee825a2cb00afc783785669a7d880afd7757194bae3e46bfc2a6b5451b05a4355567502b8c8bf1e8e96b96cf569a68ac29c54e2659bca750dc0d21ec382154a5b601d0d88c8ee688495190ce4dc8e56d90ba648ab78a944329277e7bd6429f7888edd15c406277f87a585380dfb00bea647e781dea7dba4bbbb4306334bd9e3a46b2e8704f3bdc1315241f33c895e4c8f6b81f61a417015439a0094d942b1a4cda13ae30b0e405a08468ec7cf8ca2ed5e4708cda35a7d8c3b6603cc6273f9db2feeaaf3fdce682b018dfbcb722079b2c268da14cfd3003af0ddfb284a0f371dd105d315e20597315fffc03a989134acfef615d43bcfe18a226be30a1169f6b9fce752e6a4b1403c4e81709e526342adec160d2908721498537a55ac984e18350f77959d9883b473ac15d62b9a8435796b138566bf4264a887e190f989377a139f7aef1bddead76248d57810a8106b5b3c6c63debd232009f77c2cf88ec671f1af7e052d2e799fa3a00542098048efac06b393d4b35db051cf49b0d19e9a0053a72732084f80cc2513c21c78e313477fe8fd987e73ca4eb2be78ea72e0255ff263228bb3b888d6b4fac207a1106f0cab26d26b35d3c81988cf0130729647214338924be484a113b8d6a6ee13e89d3e40b29257390d4ac741c21ed83dc60012187442e4ff8fd6dc2ce209fa9272bf289eb6deefcd441eb0c18fa2b842c8d41e5dff4fd0eb67f38582038496ee9b5c34ea0ce499b76d074156b9d14dce658375773baf69a6e25c722ac35faec6b9201a3c80ef56b3dfb96858117e43a4cf50b4eed66e889a834fbdd805ec598a4d9380051151cb7e2e7f6297f977260bd37edb887c53cd86c3cec67ee6b35635fd07eebf9ffc604c46c1da879cc1907177263e8ddd7d9ac0779ef5850470972949aeaa0c089015308494c145a18706577802f45158de4a83f93237c31d2af7f3ba4d8024e4692bc42447ded2c90a537a0864920ae4a39b68cb6204b3cc0aa1cf1bdeb60f2643577e99b85cc35e4d4bff8ea47c09f66ecfb2bfb2f6f45db7aaacdb068af028be2c725ea4c99faf56fb3b5ef5720473fae5806e9f8d50a8dd377a718ef90c055daf2ac92dad46436a914bd8d6167f2825414bc3b0dfe5423e2f50a3d511f1e9f5005186d53820203fb383fd9ffbaafc9e8a8fcd5f03447ada010b4e5ed1210b52d0ea92ce2ca8009c19db85d995d09291b857b1a88b5cdbcb6fb6178b1f7e51acec4f73c9e2c6855d5f348a0a22448587e2c9045d7a50811ed7c4f0687b54298296ab2b8f255f28f882b07884a99dffa044fdb013372294f81e28283e5ba1d52db270e3fdcc27b1b8e03564b196db547d77e89ad88278ec315f1ed5518bf3b983d01a0951816dd8cfba3ba38dd0fd02d24a62657d088bc36a64a6127734c5cd0c9051bff59f01de4fbbb31863ec11bc42b10bd504a21dec7e474dbe7a6f0d9e8b16c10a239b4d31bcba3f13d3336d1d1ca4a6f685567f208652e0b3de28f0b673a35aac2bff94e0672c866adb6e1ca9f8f5427b811da0c7d7a3a7d2dcb389482f0391f33ce61917e44f8d60d2e245554b5305e44fd73c4ad9e2596bc334ed5c47512fcb56fb64101a31e6779eed162156865dbeef857954e2347753642dcf2823088aae9d3cc751c96cb6ace194cbd7db4d7d931ea834ad120dabcdd01260bd428d1b097b37ba75c4b4ca6fb5bbb4691d37591158ecf5512238fbc198efd05797efb954bcf0b3501cd73cdda25e5c4925d1e5a81d60415d6b2fd3fef1e0071221cb08381fd4b1bd2963dfb5d9af6ca4d02087716a6a16288d76565137be55bf82dab1607448b1a7db4ef5c7e4795a3ae60cd90815cbec82bd7cc1b16335324c599cef07325f41b17d0da46c1090bf3055e1c3d2e2025dff1387cadea810abe8052512ac4a60d8d61bf850fb3a8b2576d49b13fd4a85156fba33276c2c2c83efde9069d4da9dbf6efa475609c54649473b9311ae8df59b7782e76bb57af10bcd08f0070a7ac1b8132af75f0cf3c5ed639d06671cbad9a69c3f3188f6cde144e92125d8c22d6e8c03ee25fde224b25ba361c8a9e1d47c0d7a5accece91131add8b249b4a896aedf3c21747ee3d9905eba5fbeecd57b0019a60ecb5d528bf8708555bf5c882a30ea2a736e475add4fba04ac83e4c54d9338a01c9e57bc44f788a640c7b62727fb3b96cde50f8b321c163aa3ed12f3cc108e685063595ef4f56832dab0cf63973efa12e2c61bf74cc99f3b81ab95aa455428897273f138f54354a9a04836d80bb0f877bbe0353c559b64f3736cb599fbd552bd40c99225b6a22965705bc5697396327094b40ea1315f116be0123d139eb0d469a82fc2b08f48954d881a70d7bbebc8e96afc8008de63d924d91608ef224a392c3cfc4703d4c5dd50a218f91b7afa8233f4b4f4026060a64b8d9a92c51d620308695299c2a84d251f25f4c8f4a3c68e57d5ab991da03b58bde98faa10fd1c395aa20f57f0c3828e4152f93ae2c6441e62c810d2fe824e89ed3b8a853838f6ec513b5ad28da36bff1c30184661edc824374e589957e278c01a960de75a407cb5eb9d5ab786ec2d7320e05d3a714e5457f5051a5b5bbee9c75bfe9461f46eb853a28921a827f3a2b90f136ab40af17d6f3caa56534a75c4bac167e9e6ee723ac3edb04137b14474304345c7c9d00b81201253d726dfd6a9fc8cb91fa103817f182d044515934c11f02e6bf1c0e7f635922c6668b59bf620ae438990f9f5b87ef9d833293d6137acfd0d037d9323e47b640f20559c69ad97b43dd796eb7bef1e58900223ac7e0f60ff3a460fc859fd2f2381a67047ef72ebdde330a6aea6b11f887cd716f5c418cd1ab432b2fd2e761878edec543cdc1e64f730eb9168f7aa7be637c8582db6e27819f5ab45f898b76c5bfb07be57e65eb858c47324c9263641f5bee49c484e0fb0a6eda90066c468dc07bb39a80335b2f883437fc0129e37b58a0b5ddb4d092342a3518f7370a50dddaaebd300e4ed997cb21e5c32e33eb43c6b97355508be9bcdff0dedc1dc09a849e12fced15f04461a50acd0de2ab73901a7d2bd0c4bad98c6abfc89749ff94a749d3a6b6c20c997934cb2ccb0301819af7948ba961837e628747d673410c0d4051038fbff311fb77951a3f690375ed7ca49a3a3c1ea65d1c3c3f69cebcec2015a64fdf1383325971211ad29202a1632525cb25b411f846b591cdd6b064b34976a1b7594d3aa993791e50d626b02f3b371b5ce62e485f88790e2f77e1b8e646b0289ef2e67754c3c8543a2582110e49e65f7db6c91dd29c3c8c62c0c3491e28916613287908126860275f08f5d1f7eb03688940d0b1e2393f1149675f02ff4edcfbf4dabdbb40b1849922ac2b417ddc11ca44a651e7ecf57e287f5712e213fb3a7127a46cb7f411240c5d221c592f61c4b33512928e8c8b9a1353b9ee8024bf1021a71d84cdc8b29eca7a0b8af06309aada26dcb06a236ce977fdee8e42a446e4cb92ecbdaa2f249375433c809d5fb4567e0ba8d1bca5db3a3b1b44e743fa5f1297780bf4ab547b898c7abf27e081de0f019056c9f2080cfc69a77d016d14d83e11a09e64a2bc9df3800f04f7e3f188b40eb67f477fe5adb32bdf340a334dc28c5365ca14b04493ef3f433b6d2e4098b4e960f60b0fb84fa006f88de459d67a88611c6d6ff2b3a6fb776fbd9a6105596876a1fe4585b5174037bb21061097870b66b0d9a1fc6cd476b645a014c81e98682e2b3325686e1592faabdf73733748ba04e75fd8d25c9ff6f7232b4990a728393683b5f7aa66c2252c8df89b5ab641dfd507bbb7edf90e8b1920c11c4ee82c14cc47cc8ad1845d1cd263f897e238d6b08a870bdf9c37874e39382ab7a54b1d07ef2eef7c79d17c320c38cb4d10158acc84f51073982971ea39ceac64f7a8d00786268c5ec08598cda42140dc6b947fe0149164c75f62e80cfa653bcff8d75e6e427bbd7fd24bd3066f7fc5d20041f5a2cb50be1f487b0cbf85514f1aa77de0b60e1ba167d39fe532a2447b7cdc949f9ca1d6abf9fc59c2cdea124f3bab1d97b8c96d91c23b5852cb6c91b906a9c487c2b8b80d2b527ae8f2144858d43c7c9e3ca42e2d51496692a61afa4eea2bd6e48d3e78eca32417664c77b97be3e31d6c9f4a26fc79182ae93affc9a5077cb78e4d10702ada76067dd5f8ec7c5de76e5ab434f6a68fd6bbafba7239c2bc4ca05ec980d3c5acc2a76cc60af22e559e5994f99eeac16827f8ac81e98d77fa6f453b70985116d0f4883e6328a8c57fd04648c47f7a3381c6b4fbe65757d9604224d80248d895d6e7f1fbc90c3c7fa14eb215d1b1326fe3ba29aa0a6874e08af8cae41412475d4d378afb42537e849181041e16c3b15fe969e11993569ebefe292e258270114030e0b8f63669cda7c1758a879dcb279b71a1d93a5b11e9640a47bb2c43170cc0ce8fd1ebc0e756c1cb15e0ce46530ded670cf0855cf11e9eba6e79c332fdb2eadf726398ee138ade434fcb9cef36f41adb3347fc40cc73f9fa2af9808f014e78a18e1a55892ec7f45593330bb117b28a9c3e6e8c70dd73972e8649fddf7e11d063ba3146872bf4ad49b91318d72a154d6b8e490c63da3fdae1088792be51ff596ea503e0ce0a6ce283f8b8795dc235448caefacad94d0326413280a43fe9a255a814dcd3bad8d962840e05157c1370c2032b7809a70c55063d00edd354c74c608c51a4148672ca13ef00ada2f545d308d626d4aa8760e674dc5a3676cac6cb1f79b659601447de49e4fd80f43e430eede2ed844084d928acfd6ebe16ae3493aef1c34e4036b0044da8e86d8f7c7bd601a711cc1a9203b43cb0db7539146b43ea3e27046726f68efc3f04613267f2648b0af74063949029798ab29a923774482f48314ccf9fa97c24e1606839b947db8d46e186846f20f6c4f9689ce97f6442a6b0fa7af6ff5001586563da19811c117671f9f49e5f4334992dc065ed9a44af91eecbd192ed56656791afaf60f2c2009d43f9070b7271116519c7c77c2d1bb5829822481facaf2450c432e424467558c3c0c5eb91b679f10ea83171893ea14485244c200ab917aa0c7ac59d3207486c2a9717545819052b7f8b8892dd1478506cb8e8af9dfb700c756937e49bfb942b16c92c26dc18f13558fe0899d4aed3afdcf94c3cfbed7561cbe88067a566f01013f127a3d3710fe0aaa37a5ba1829a6a85fbbd7e53dca80f9cd51cdeb1cf90d5d88c38061caed832cd4eac11bb9ec03436f783e5e75e774d1abd2ed2ed798b03ce55eeedf419683689d1083eade9874c91e69189cfa59c8a17ba9e200f58da554be80265892f6ea70678d25d60f6b555994ef476ad78a9bc002cf1995cc0d855cefd4cf7a789a66a8576a8fb9d754b344059e90dfe661763142609ef97cbf51a3a574f08b0705dddd2f72649e353b6899c27784b2844a81db2f31e237b9ca1df4a07550639ea09445674ee9891521ee24cf54efcfa48e268d0049bd515a87e0ea1807f9faedb42edf3275d99437d29697453cdcfce39198d5791c06def9a09ee48b4e7659cba3c24ed0ee5b6390bc8eb38cbcead35bb07defa40abbc7d4af4b5f857ac8be859650f067c6279bc7e0c44bd2f22cd09bd25dff39d3c5fbee5298f58e41b88ec173437552b26fcdd794b0492500cc503b782a665dde57d23ec767384939660364bc407bdb655ab3b22c52b3e893273d328acb3d0047398e03f04f04ec52370938d55117cba942ac02ad864ccfd30021d5faecf1158a03eb5c44aa09580db0e904751560260cd9ad5872ad6e00724833314802f1797d2db5e181258ee9335017357046f71b182a6d062a36dda49071a0b0dc485b98b44b9f16447cdc8de528fd53123411b3e955a1cc7636d53ba1b0f7852940b8b2ffad85bb9ca5f31e5e64338d9812a18ea6d613b97aee4ebd39b2ec5c13feb51cce0b0d1bc247a883bd40156586dbc1dedd046f84e4abf83f16cf6976aacec6d691755d2d6047d5be6b5ef5a5aa3663e8ce87ddd1cb56f02747fa68a7aee0f299a7eed8664b9de57144be2e4318930c39328bf9bebc62ab978579e8f9131774f410988c334dc5d8e1b51c37a1551cf833ee9e0606ba83356be907337d64982b4efdee4aded4e13cbd226138e5af3a42d1a398535786380a08a1040f635e5532813a6407af3d1aa4c6b6a943ed4066359421d5d283da5f14685a0b4aa43b849c282b023c364643943d1fc1b289ec2c430cbc06303cb4eb97cf11e07ae89c5de11ab0e8ab5da9c42de87d14e2bfed378fde23e8c3d200537b861a44d127e76e925256a411f6738848c19faa47e31efe1174f2af90534252a922052fa7db9150f92ab788a2e1f574c1a166d0718a3b9456ec20b7169220be9f24d5755d032a3b898e80eac8565bddba85bd1d66916b64872c2378d0d283d2e34f51011ce7c0150ca5690c84cc94a5f515b6444f9e7e5965f06be4180a1dff0aa283e4f83f0b02217b0c3466559c7075a9b3c7f7cf28f3dad23550abb96f1222c152d709944f02cc921c531c310aad3cb4cd95dea4b7dd0587491dd68229f84e0a501646fcc2d95a1a36ea31d501820d8707dcce542ad1a0358fdcb5be287c7f2f0fa2384843d896ef42974f622717e8d549e013a11ca059bb45f7ebdc3f6da2d04992499d880fcf31082956438d4f3b650730c107d05f0f488f74431fb51339c04cd5b8e2e6b318a5830d34902151ff2c322e05aa258099b524e697908ec5d8164af701fa06b153e38d815224d298811d622d403abd45795e045ee0a531fba48a3263d1ac58d7f0b3a9109a560552c74cd2520e98068109e1c724f321217028c38803178a7c8b6dece1410b4632faa646ffde96454aeddd155d78fed0cfc68991ae955a3bd73a2c7a82977ad156446e288a80929e941106449186a7df3fa40c2681e9bed9eeb355480bdb6e24b2eb8cb614a57174d947fd30275a43cf63f05ed32675b11ba9e49243b656dba792549f4d5ff75753a508422877063659fa0ea21eefd1c028538adb3809a919f42095c180a543f2748d45afa9c9ef74707202a83efb59f20a3a251bffc922563bc830497777085cb8f8104a8461ace08fad2548caec5a45c2966ee9884fb4ec6ccc254f083b04765547f4e302cfa5bb18a6772a905b6df98d279f33a832835db0892f3a5f7a691e278ac75471bf9eb9d2879c290dd07a8a1e3f22c91f0458859ae3149a7765297c4046740320e479ca3394ba2f20c556e678f9f26d1d1847095d14ac77e0b5838cf67e54ce3c7849a801b176d0284b44f3bf4e98e341f363be4754d4264e0bd2eee209c1eb48a63ad3d765a80d9230225e18a504d6510962b2b2cbc1e10fc89d4b8f16b2a80ef9711c0cc5d007581b6e8ab2847c4c73fe023d9331d4b159b0c18b46986878b590630f71ccb9dd2f3ff325a6aa4a845511e7b81e1b5e39059aa34e651ff83f3a985af38f66cb8299375ca6e0d8250d63986a7bd7824532fee6fd56b1eec00175c0b096edb869e985cdf3572ddd934e6658ed05ec188f51893801a591369e274d6bd33c7f96bb7eccafd8b14b57c5fdcfaa59f5a57d70a107d53bd4167167301162c767c1dce443a172009242e2fae2c3fe578ac0332f3d2e894c0d722bee3e56c90f7df245dff013821a6ae97c964ddbd1e0364bf9647ee9aea097de1fdd42ca9046268bdab38740b90c5d01cb4f5ca0ef621d09ab254ea1b0f4a99b7a1e7bcbc5d7fd1172376641e89943dcd065171fbb4e8bec0ed19cb03fbe55150fe60ee40e33df33e91609c150a5efb586c3f6ab37e52abb3530da3adadd057617544890bd04d35a84b6462ea6cbcc270682df45e92a3ebf3822c6ac079130f3b7417950fa67c08d3489c525cdbf11df8474746f42a1e67838329e457ad246e526fd7068dae732c972ee7632757292d991e312d5c5fb04f270e2397c86355e538ac78668c98471d5640a3a20494cc2aa9fe3ee040a808788bd66b31f19d906ab21c8311f86dbac6b1e0df397a6e62dc21d5e43787780475752809180b100b75b7a197d1d5b89f9a65100e776d5bcdfe81ad274c8eae69155612eeadcde65430b2920a807249fc1cbd045fd49bf472a673fc579710613501812610bcc6e56a18b915d1b625ff9b4bdebeba692755897ba5df7dc8b0f293488e833d1def013f159f01dee905d9086c1f949bfa89aee3c3289b4d6922db4484ac5b214a3cad5f9d3967fe15414e3fcff2a9ac70f4d8f453ce988b5684724ed54d0f26fd8e4653a62715fd13b4b054a4bb2a028861a237c155a65b060024d7e7afca1bd7f814925aa5119705e3a1bf03ad950695f8efe917d58a4463aa58a4053c94ad4effd4919ea7470ce6269475499501c829e26a9fe472a689b3b1119eace07099ea7acfa61a11464b6bac41dd543bb2a3ed3bead8995fa4c237a949aa22ba86c8639ac044d5a42db96a67ea9bffc14c91c3fe086f1f48c57bca402941e203ae2da441b70b46d202c9adf3cec554dc00b15075045f45ddec2cf6f152452cf14ad086a7f5e28c606391a3e852e0ff2740339fd5d9c57d8ce340fafd36b93c71bae2b51755dc0a005724798317316ea008fb3719dae8cf17b8bed7f0134db6f6fb8e471b5d44d38d55904ea9595139da081f920e08488d45fa88d5ef7847f7e86d56a95d64ccc4e625327f49c041481d18c1cf4492ac9d011c25fae81ecb2f8797839c124a393cd7ae87d5f9536e033028ead1dbf4f6b4bb5ec049b59f3c9cbc67c593f446f481a4930aa80390e63cdbac9759fc6f36a91d0df22aae4499256c1ffe3e0928c64350034b168c07012f01c3fc889819274ad65bff208452a51d09c426bef376d4d0bfe673fa9ef231478e516eaca1303681dfb9dff5a9d030633d0700b65943c0df7dc1e08d153932dff43eafc3e1b33157977c35003b6bacd8656da9f3b1d4b57c558f91d7c03d08fa6adce458d3f24f6f64487f3f072bc8caefe396e19388006709bfced14ae93a2f17f02488fa2696064a510dc3468dde4d0e9169355f8e9b4c76cdc41b61fb80f21b5c626bf828730039fd2bfe07c34230dd9f11648283e0074e8f4bab88f87724c646ad69154779a19434d5dc2f1178e68de0110850c7ce1c7db82d379dcbce90eb7816bcb6e46af274b023487d23671d190b35c56eb5ecedd0ca834b00e4f9a87d16d36fe6013fc47a1edcd7621a8ddb6b84f78297fb653fa978441a15a95c0d184213ca83480771c5f39bd638f6e16539a54b0deeacfce72b8d9a374de893fee2ce9121d99866949d7fb2a6d6750755a55b3bac1639a42f12411aa4653ec92b6673b7165d6be4c936e1144e4eb3a50af5c87534935380c5f1e0577b0301b815f316471b557fbe030b037a22c056e3bfc0564ac473a729a91288ed72f26981236cf089c0da454ab063c93774a01e9e6f378827111b1dd5f9dd0f2b0189c9fe70a7d01c929427836084fe6c47c307c283f26c6aeedf16f52e0d5d9367f6ed9b59356f5cbacaa2f73c01030d33cc82bb4c839741efad3b61540467aceafb96722f3b76aab35f66836c10714030faa66df88bb2f1814d579844fbd5979ac404bbf84ddae5c42e1fb6bf6ed89e8bb1b99145c1d1fea1c5ff1ad10bd73474de0517ab4a7b7074ee0b7b2d5353519306c8be32271aaef1670cfe9e70b0129544951837fd628233def2b2e492d3ce2df188d174b5cd5d71a60c983162763e8d9d2d014485e1e213a4a560a52f142def5c0cbdc8bc904b51958c8f409c05cd3dca2978361089063ae025949b7ea1cf781cce50442ea58f0b4014ae5eda6d52987b94881a30685af8ab421febe339059090ab187ae2ce8cb32fb95dd8085c649d198080cfa9c6000bea5956493a1c6a7cc4b4ef2f73ef46cc5ab25ea010c8109cf9464688c61de3a989e3a6d923bb182e7504f05a36444acd3328f51cd5c8b2ae9b6bb3e3d8a5da4533ea47aa76af2e9bbc9ffd14d126afeb994fb4f9619476109d2cedd1d4037a63478b2f21b0e0459fd1ca201b6d7c9d7dc7c2bb05fde4455f001ffe3654c169ac88105dbfd4ca1c1eee71026451fb8580c1cc9520719dffd007861308a01ce3b897da4217a56e2cd7df521e5b37ccc567e0077f2ea2af56be7f675de2e2a71af79a9ae22d4ac2c49ead28cd5de0d67457aff1f2506256a0a22f2e6a3190e25ae2b5bb62ac01572f85c66a324de231e2b6f92d49412ee0c567530ccf6ddee1575aa21d893fe6c478114e7bf04c36c0a8cca4bbcbeb7100fb67e85c21e693f8da32647383f77f1aecd51b3c9a71a84752de6dce2e31321f632658435e7c1133e8da4836229c65f8ef7fe42b9119f9a5afeeaf04cf687d64b0c116d9bf6efa64d3935b034050764af4f2fd7c06c82502c73921f330c47ffd3973940400c1e84dc97e5e43920add845306bf8dbbab4fcdc3e3b17d8544954245f51fe3cef36adf70be20ba803d78d350c2a7c8cd1074689c4036a2dcdf3cc0b3344a54f94ee84acaa657c0e3884c784a365f52943b6a4c0fc63e0d4358ad3781276fa2a5bbecd731c19b2d65d8c38907c3e82af5c23f7c6ad9f9504ae058e354abf15ce81fb7a74fe4cf1cc315cea6b40b4821fd5ae829a91a6aeebe86013e72befe91c4ffa3a476e0d8dbaabe82b4afdff1aa2ffbd04256380e6d01d37433034356f6e8d6652c09927761deddf5fb7b658acf2e8993916c9f64d140ffeb42350ea288686c4d320c5860162e700a0e0f1af7bf0df1e778f34f257a34f79075f85c6526a3833374f87f3f2a66b42ff22deb584599eacaa293d930db60a07a546cda3b6fa8cd577dd435a892c4515a26259a972d645aba6ad0a86391553b214fda5ae4bdb7a494ec587a48e095d8a5b357848677940256dd2775b834d80d555810483df958c54fba35a46556a3ba02f0e61c5bf3a36b815b5ef735b6e14149130d1f4e504f2b6f0676d75701daa073ef6cac28a0c237036d48e8bece56a6fc245b5e1eadff9915cb993b7ace7ba13f4fab6072c489547e6a53508d10b05eedc3c99621db29481788a60eac3876c28445da641a7e71bec6462c763436580ad555e4a9838e49da4c20d00c99aa7fa441335e7003824ba4e62dfe62f9434fa46e053c770e0bcdd6b5e9673ff7ffe2c7949930cb60219e5170e3b90d5895e960ebfb7ae95ea6fda15288abac3ba79462ad2c5d8c4e7c936d7a1483630672de6507251aa9ba1fd722d5fbb8e1efa2bca649edb924adb84ef14515f479216902337e126fa22ff4770ea0e6bf12016b2c3617e2aa5bc5353ff6e922c93fec7087aeeb6b44bd42e193caebf44335d35abb8e37fa22f02a2ef1a1844d04660c0c3c72884a82f65ae043828309e6e1c9adb70c874cc5b78e28f0b00e0d181418932a497b91537b6bc7e3506f12ba439aae77d869b34c20a42fca346d266d8a372c0c2e846fd26520358cc752593f530c7179859b4e3e417cdb1847cefca01d62da7b709be779dc07beefac6407e559f81f72009dce2e57071f0d05dcc530ba01b6894cdf3f4548568a3d9d1e46daa4b30a166deb31af2b8de5f39583caf83d433f602d7da72c67dfb56908eacd2ab852022b93b7255a1d5c9e91352a1de4e3aa2957a21e919be5856a29f8f141a3802c2ef221e9f9c3110c86b8b26f5a35dfd25ed01c70487f8bedaf68f80b78727c1e339b17ae76936b663837555c307aeb6b43253ab66e556870499119432518f3a2b61f1d9079dedd959c3f966b6f477f42fc9dd03f937b5143d75f4d1e4934c4a81c688f84394775333e628619ee402a9e0682fca5535c94d469a8431d9d245c1d142c2b5aa17bb000120db18e580014af0c324c2ec3f6a5d6d403deec8f4c946a0d6b1a0c814d178f3efc19179aaac11eb8973f357c2536a22202f2382bcc463f3b91fc85cfc8a062bb58f0e2e3d62c55be9d65889f4b277b396b9fa721b7c00f416fad023589d3d6ef0fbfd12d82b358b803a6e4e65ae4a395a3a8f939c8b319eca5c8bd677d04d07bb82a3f24e237ae0e1a089a33adbd646d9cf116c5625daca352c97ac9decc9024b855c069bba4c28e9a4de5fb53af2c7fa8014b70db735144e84d7e9ed727b3a6d6561078276802fba317d4a6aaf2d907d70d486a97d790f1066660b2dc39b5dc22841d65a7efd7b56cd488eb492d5e28a9b27b98da92e22792f38c686446ec5048aebc55630059379a2b43e249e6cc04cdeccbad9e7a3beb06de76bd12df14e0d6f2a5410271d34f1ec815bce0c306d95a4437378c6edf4e90af15355a772c5a73535b6fa8f58cbc731c01ddb8b279316bb68854deb3be93bf4648ad0fa5537f6a6f4009b728ec83e46581c1ba7d49214c79333fdd148757c85c764d1d93bc8fffc1c76409f17dbdc3d291e358b0ecf1ebe4a6f28b159ecdcdf1c38b7e4ab64d0ec84da9b53d645eacc9a048ba6fa2928b1223e612359d461e66543b1bbb45054f8b772ceb62139c884f7fc33b0836e62b6e34bf59602ae008a43edf35c0985277e606b15306233492503101a582c2ba908358c52874cd97176d4c204e85585d835fe4dfc5d31e0b1b4f9036f20c8fc1aab9fadafcbe1a80fbb31b6ab5480a5337e1b62f18cf13207d7d8d668d8fd460b34224c93aa59dc96fc5b0e417f12cd119e507e7fe555b22101d45c425ce0cc12671f38d1dddc8950651f3d78dec78efdd8580f6f00fc1399082d5b4dbdd1604ea87e60115f1a43b141b2e33f96163e30a35434cfeec281fde55cb885de680d1bcfc454d95cd15b4d65db8568de6af260b8220de08b347d9835fa08fa3ea267dc0fbd08b2d278c3eb59cbb1a599bf0685b9e998cf97dc2f99bac196f6d84fd071560e7061d333f7e26fa261b2affa765371ece499730805116a2e5fb60fe1b2e33d8cebcc6fecb4e7de3bff8f9f2d1becba3eb75fa447fbc32a626f74c3ca78937a9daa2ee048a04aae1a4afb675c379df318342d9e96aa19bc99d194de275d5bdd2c690245e72cdb6d12a3241a207544222c635de7ce08562846894f536eb96e6f9a473b9a176cf1cbd9879480618fee071ff72acfa15d690b070206be2d07a76138dec44786127b1349d999201ce0d0ee05aefc7de672a0b57c0c26a639ad173f1d77d2d9222897debef5296e0ea5577cae54f61afb9717aeb49699a91c4d0634975cd5e577bed97ccd1759587c0ff73b88e1a8799879824301ffd2623a373d09415774736179d7c6f3394773fd3a8abf7a6e639801a118e73d400be6bd1f2da5d5f11b8459bafddbaa7ad59dc88898c82adb2c3b6ce41125d4e898a3696d2cd1a0a97a26b9b66a594ec903b493c6b6351276cd8ab5b4e8625276a03e6da7deb92f89953a316cde86f878bc3ad61cd4a214659a5580dbbf95da4d09feeac36a04c0edf30c99c67eb40cd9425f224ffcb0ce4f939d26d8754d88ce29560b9e2984a68c3c624fd6139cc3dfd1ac7e31dd5c6d69695a9461797be411155d6f3ff9658f940c3aefff8b5246897cc5d43cc1881bcb0631dc315c8ed5b592a01970b5a2e4ed9e65b9677bda48d02ad4d4651a7f39fe92b5b54841cbf649e692672a77c211536296402371f2da6ef12af26011cf922032723f33687b6a979ed076cdf9a9e6adda7cfeb2e2a3117f56a9456856ee859baef5e224ccd7514ac01027bf815fe87be828284f87b676a828a1446f22c1d213bc98e934d2cb6c08847ec8ffc48061ce95f71c5c98c604e5d72e839b41d23a4e7fc12a21e87e7482fae84caae6953abdc5a7647ffff50f6d07c5acbd9c779529c85bd2b351cabbe7d41fba670eded62b69c3ee5ecc8f12684106a208cb20d6399d8d8965374b07a50c647e0b403cc5c03e0906f52e1708b0e46facee545bb5f445d509be1f3900d949c917f26e98c94774d8c1710c2bfb53331c7c7c17a5a3aacab71696579d7d6fc1cdce73e3bb08b2a34bd32277f647b9c5247f4ab7f8d912751ce91df977b6672124109b0756dad30e1d9e09db5baae9e5e2531c2dd6f4b82e83a149edec9c77cc3768d367b2cfe372a834a00f34a0fde07d0ddb204cefcc6b51b8f6db1de46f5ad2b5e99daf9cd7a5b75f7a254d9557b687fbf0b5d65b802080e08bfad53334f5490eef257b5fd3ec991310dfd3fec1c74c4d0fcae3e19f1795d83d7e245b204b445bd62c7a468f160f313c2d6a9c0859a7b23fb32d20c123acb6ba73c2e3a823e06a47307be4c734a80ca914141fd54d5abacbfea2115fac63d37a6c79c47be5ab34ca5ea7ce6ea8f84677ae8e7ebef06d720af813a0484b7f0ef09ec3c0b66fd139fe36a677ac3d2d476e23a776b4dc6fe1aee2b5f186e6d3fa7360b8c1de8d59d9c0ab63126c5a057df3e8d0c46f597fce326ea312f0158ad1223ea1315e4c28f77f30534af0b1dbfab0b4edf796d0b64958ae737b1492dfa7366dc8a0e712ea523cd2cec3a150836f31c5d6262e13d4e591684ce28377ac8536d4e1ca46aa77343cbb64fa55690fcbdaed9c4543d2018e9ea0c4adbc4edadef6782562a8dec4b6b9de6cd56960dacbd78dbf83ad412a5a4f0a4841b3513822ebd2a862b3801e2efa141d90f3649d84e8785962aec81f0b9fd16fd2c5c2a634c3ae9d8a51132e62fc5b018a86b86ef8d2a91dd31590611b47a7b3144eea0173c87396743fb71795886fc70b03d8d2fb2e9e7ca7d6de8150abc8c8e05c651ac7d1be21cea8fff63ff82779bb6580f8b5909028e7283315a8806dcb063e20e33f71ea8e0d314983c85b93a42efde1a5276761d53163bc1da73dd61cd097c0a0c5510f2d3def9e587399031eabdf4ff140ecb68f1332e829aaf0f9d21b5cc0bde7dbcc82c3f1f376e278c8f6798716556d80de81cd385d12d58adac3fe45d8061cb21edd297d03b70176cc122b8a073af1ed7e315b8c862a27594cc2974c5c17d46a5e43865b953141c5ce46793af37d6a99bc81cc6377d3e618cb470048bcae2f2e7ee477eb18fe42d7261730502b88806342e99faf8379d37b68febe6cb24e6453e5e1927bbc4d3000d376af6e6e560025e8825df05e88f9b9bcdabe1938c9e0898334ff99ea848a52069e8ed12bb8523e948c78bd51e32c9cc6a2f6988028f6dbd5dadae763d709e1b56d6fe602caa17d0f217bf65253a9e36299929b9cae54136823744b8c5aade7109199dc6cd233bb7d23af580e5ec63d18165e400acb1c0934c51d9ae26d9eaed2ea4039fc5be0dd30b5e99d1016df12b777107a772e59733047244ee9b957cf5b3df8db37c5b55d41c75eeabca0c860024bd4cdb174af14c256e39ee4656dd5b3fd4a5691ccdbc8ee25f3f9cf80b642e6ab831e7db6067256d8a89c6430ca9a5cc05b6865bf892a287e2a36aceb6f7a775921b09016d092077ef53f739de42c7e7d179837b2baf9b656a9e9d733097fec3cd235af6e875dd9b9e5ab2cd3e21ebd99bd9760f888f93c17baea78096dca97a4efa955e99a4998d8c505595b6e9a3945bbe559475dbc801a8fafd3a16bc040a0f1d815ad7ee47b58bc344f5dbb4c42f285321e8be0d9ae029eba6bb74fbcb692118482e89ba990f46eec9369d77cb56bea69d6ede23b424b4275ca37e4384f0940ad642165664e1cff3e11930142e5298c2792012c360d007604d3c3a3dc7c7f58a94dff59c7a93f51414b6404a92133461504e8ec998e3610f62f5ea10d4375aece8592b0fdec34594e9b26647e1b1474e5739d3406c40dbe5c692a6dddbe523c122d3ab589c8b32303bb0342ddd92b888290a3200ca02d0171a21da9452fbd9eeb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
