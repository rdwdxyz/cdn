<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0396a9b8c8940912771d9950aeab2a0d0d543903b4ff5f3c41ff7d4ebf7e42e07bcefb5ce43972523bb273b70eaa26ce0dcbddb127def0032a19bffd6d977b0271c55bf6bfecbc6987ed2f6ae4106fc95ab42ec0782677fdd174c7d99a78cb3f92803f480521def6121139e2e217f7e996840e7cc83e430043273c3af32d8e454663f7865afe708d09193a7ae90f4e16e8272f2ec433dbf8517f41e94799a4f12d3a8b3bd2d6851b683844a3213ba7f2bde6845bdc658918eb412772c9fd5c699b4446f182b8248799bae08edb62682566e68b881adc97b673c6ed050037ffce7d6490aff308f773bda0705f6b901652f4aaf1aa29808db09c4999b89698ef54cee301c5542b8ed43a1d0300bf4a4411b8041d7b3e44c248fb6de8c56b9135ffb33ed95e3158d10a19cbfe3385f12b2061197a53a1704549e807c58ebeefac066eb62dd0f4a3e2e210d7d1b266d6bb052e8ccaeee68df525d8664a9d5bddf03736d17309c226cc2a4aff3b484317831d51c76a365610b9ca730b1257364fac083a73aad619787ad0b24e495f5605ea68c3557b26157ea43ad4e4b39b7adba61844cf3169a42fe4df3c2cc67d664704771294e615735b2b41148380de11d44d91b092f2cf799bb7571efb0e0cd3a4f81fb7e12943d0a4686ffff349b78f999bf1b6a49e460d7f290a0dcf0bd9945547974b3784866415307ad16951090970e6661393fa1d20738c2f5c209c83cecfeaf303103d1fdb7af14b7936fe1fca7109861328ecb0d1f35a26391c1dbea1e15c5747588cf83a5574b46a212f897481b3e8fcf2214abd4ed281f9498953fe0b0098ae03063288f90206d3a03ef4df714b32a8def2d10c25f21daa48d6f81b91ec520e91f77e7b56ad2308acfa351260d76b9d0587b6c30f4d795daeaec849c0e0f1d45281f6276fc685cd2bb33e0139e95dc75a5d58e4093eb25473561cee9bce43c5bc7613932bb33f64c2b4c48faf8b25c42578e9fe861964e5ed7fd677c21828fd8b6cd2f97890bd39d3d7f69dbbf375b61789eec5dc527da3826fdca8f8ff044744186cf589668739a49b539a7d4514b0f2a0ec684ce0cd16eae52fa9f510bcf84c25ba14499ea096649875e84cee6ed1f58cfa24ecf50f4144f6bfd46b0a26f4769f0f7534599c76e28bcff8e9787cd4bbc7a54d957c5bdcea7221ea91946a6bd0834a19d28a4a349510b1d4a1c0812f16e696afa94b0a4d784499750518af6f39183243a219402c7286e36c9a1c9ba9492c3dfaad78f43a5768290b5d7011be51134294ee46064bb00ad43f02e61f5ddea85a15acbf6c7fd3f133b084e9a8a4159d1a2e2119c64a8fddb11ef49875cd957b2507d988fe8edabd6a122fce7feb9efe9a6b8fd6a0ddde5d7de30d9e91a249c26f3ca5d6a45e88d0ead42fb6ea19cebde2aefaf176e31ead563baad27503a7ae62b88c5001dfe54ea42c41d4af8927abdcffbefd54d1f0b6f428f675371c56ea4fb8ea154c519489c0eca8b1d4fd4969e9bba49d9538568044573f46af83daaee2b471729820aa3011a5f93e44a20b701ca3327b3d13fba4c9e0f4e203e80d52f52ebd232e7acfab6ca8bd270f1c95805619bffd6a37b6b9a6ebb7e2556c7b827dd01132d4f46f2528a74a024c20fb0d6b5cb1431bcdafdf3e541f9d29e95e349c5dbcef94dc68ba9b1a14f3847a9dcb4c50ee3cd4c18b736d8362702b1ea39d1d85a65ff46e1b6e8790bc78a00951abb64b8beb7e17f82c22038c2ce93a1ee6de6476d2567afaa41d2e53d56a42237bde6920bae4654a3ec341ce465123892220955f4452d68bbfd57af3151aae1dcb0f1e78ab75abc14e7ab387bfff057f8bb5bd1923281333ff7f8efa364c3b655c64026fcc03d9f334a226da18e61b16346bf7da430d63532b4fc7a2aa97083cb2af42ecb9578ed0b0f2eccf59e3af3efb0bc5d6ec328c3b30a8509ce852964813bdef06fbea1209fb47ae23efee069bc11d1ac47e7b67ecc611f91d55feb04d2d64e94c24a94c9b7acb0995408805e1c9566f8c69cfc1779f9515f6635862071a320b9db5cfa5a62d21b4cd6c567abe28890a11f9938569f2feebf958b481baca500f7d8ec629d739b8fdd837ad47e931a8676e45348f2cde3b41fc36e0d3ab44b0262e67ff3439e3936f618b4cca98812d61d5d6c29de9cbd576fab5979f2fa1368b0c4d0b01fa673613cd59457e8e463052c706bcd92228eef84c1fa6169b1ed00aeb1b792c0ad322097f9989e175c198f46bb40194b437b602f3777e7104307a231e0e88a6071b91fece60f3035ad7e3d161ad995d332f038014d0a2932a2e6a70ac34c7df66bc7aa0c1bbd6c1c3e6a92b2f65a0301581fc9833c044930063c04ce57ad8f08c22575f6246d505f2cef44f5bcec8490dd001b76bed2d624b6d347040e2d0fa0dd13745d55e3bc98dda55556eb82194e3acb3ef4c6b8632e3623044003174d5c14ad9913208b432e0186a3a3b89bc784182a467f644e6aabd2d5638d6be0cefba19045b84a711923fd92a980f8d2cf67247775e0163b1d43d93e74e54d4adc67c334492b030828cb87d7763b44a2d2e8c06446128e46fb9b1dcaacf93dcdb037b0427bb2ce2b35b057052f8cba5604478258ba051377c167f9cb851709e341c322a0b1b91125241bcf7f64b377ee9b28237b280f136237888eba4f20df83e6b630e0423816d24c9f130dce11c471f29e3334c5596a884255d4766ed7e0592f494ace94c170724ef4ceae9408386892001d25102bca179b3e77204cf35d8a7a1d0d0a0da39f25438253e741e957edc8d2853ec9e96aae8b30e8b4e8be667b907d4b2e0f62e7d4269b48be48eb1d760c784e9fc9d1acea9af187c987ce77b8128379658e12a288e6eeebf44c5326647111ab0531591df58298376fcb49531ba87539c947e52cc573778eaec86392f9db6b405594cfa57e309c517757412154c3ef75f8a748dcc91ec9cffb5a205f6138fe4e94e4b5a521fccbf7ec17f236b1d88e263409972d3e55fc92f69c7d6646a0b449860061275b763ea40ee1f4045aa87677f541eea98424a8b780e36a114b206736630e1d8dd40624dfeaef889c37e96400f1ae73645e26e7576c689d80defce71b922ea093ca731053294fe6ff3a30ba9fc7d152542bc2d236f443b4fa786a473ba167093a9bdb822ce78ae8aefea7b9f53164cca850607f98b90588a8720ff0154c9d161ba7fc61a32d3fa6c498e037604d53ee3609c742853b2ab9f70b80c906f4c732c04f751886aadaf92e9ca6f906e37c6bad96769f7132ac19ec167dfc92e3da694f89071c1bcdf5f90745958906a8f0837e4ba34d4fcbacfb2d385805b47c0a965d31eb0722ea562ffe77cbdae91d91528e303a1f80dd5817f1c1369a3720fd75e2b21fb3a7f8be8d126c4368d80595bd031a03a40c96f12aed287f42fbf2706896f11ff2fc500f4d1f6fc94610e7c02a18fe7eb8f5ce84680eb7374eb4b2a9a4be0b7595a041f61470fd16cece0127e35500f4c39d132cbd6182e8df6577909d5fa64e077b1268bc01ec2f7cb0d4e86988f67a009da669127862aff69387beb29268101df5c0fdfd5597b5314e1cc02ad2f68608403d98d731ba9fc9e2deb4a70d88a1bb469253b98dba7da3b9f06de35479cf3109e6d96489af43bd742db1bfffa7b76bc64b4861cb8ec82ab5202b77b0562cb7a490dbda1bc648653bc8cfe6bf9f35d3273540e4082997e5112a50e047aabc2efe369c03598975d70f20c909c566c31b36f2f7593bc4cfe27e4d5c80fcc585a4425632d2633ee5f515e7f187a5e01de26341d274514dfe40f88db0697b8585de8c5c4dfa2ff2a5399f94ea7c3ca3923e5aa9ba23570b26e22607a5802b640f8246d91765c68fa6207839f8988ba6a362b380c82d3137c05aec8a3028357fb4925a16aa7f8459b13f7d272c38abeb6ddbaa56fdc692aa57f6453645849055dde7674cf7ac4928f7018a35944aa867fc0bf453b153cc7e356bfc4e8e3bacedd113e7ad0891e1a1d502e5cadf109b93bf45564552b5ed5e99a7cc2043344ac50e8d70135a5e07dde6e0f99ab90432a689ec46d2136aa0088e8c4725f9c038afd8d0dc4e360bdba159be6db5082685a21a83e648ac3f07cea8ff0680408ffb8e7cbd0063b7990068d318f60982205bcc5a3ccf34cc665926cf15403e903dd0a3874959973efbf44354bc3ba38d0a1350a6b5e7b92b8cde69f8b03bab0210931f20779076e62a4764e3a973f391a31da85ec9619606df4bfa4ec6d107c144866948230480ead51d977b33fec7620989c79b3a23735ae63681c20f368d491e373e44dfd66fbb0b3480272300d822496a1b3fb224ab67be76dfab341e79a5fbad72b12f09ad1289c35badd07119df947501c0547543923f40b99ef02c2934407217a87bcae9f015dcdb14ee722bdc80432fc49c48550567869ffc800aed21217e50852e905f80c83f7fe2bc926d69346659c93e95f3c6c914fd551f956bb0313f6efe2038116ebf2bb2d85c860aec201f134d818ba3dcea622e105d9ca46ea32f941a4582c67c2580711f342ee8dea90523a16ef23c712e750f7c234faf9bb214d1047bf118b8d152c5d7613bda40997ac319835234947439f51046ae9885de2dbe7f3ddacc1792f87689fadfd01f76a37e9ff023fa2a07c837755e43e0d6237d6beaf707331770c6e2941ed1c0b373d7adea5bcc73eab924825481901e25efe997b32582913c99448545072dbce30173e3b042e1a0325875e0f9dccad580735f88279611d753446f0bb8e7874b8701a796c9814b55e4af1356fefc7c62496d58af1d6db2df2fe7f4633a9ff3fd718f1f38f9b2f504c79d3b095d494ff7174ac0a01b40067737f3cd412f1a6142fd23163f4c448f6c87782bf559d72ec6c19b7b9bb36b9f6370978454e87daee8e8e2acf3b671e0a041e60a14eec828f0d543c224e4f2ab42e5ab8e1c3e807b511851930933d3917d66ffb7bacffd1ca76cd66fe5c36d40cc20f7394691a3f29a6682c76705c601efbad60bb28ca98655635bcff9d47c2f4260b4af862d4c2d0d0b29d596c6f1e8081d0083b80fa46e0808042e751d2e8d06546bf96c5086cddab2c6b632f17709c0966d7409e161eeb8569f4968e157bbdee2d1875073ea9f8bb5d636181ab79922559fc0ae2cca63a3d33085dab81c48b00a0c2ede3d4304512a983adc0c6a10e4e50f9415f58e2439598c0decb42ea1e089ca44cf8d4a0f29c595980f0be6aa00dbdcb20ed49addae3cf44e75aeaf4937831cdc1a5c831c72f880b7e492e7e3b0c97ce57e25b605a3cbb735b544687f49ad2aa93f82406a1461cae21ca2077a572242cf0c6c2de7d40b06b0c2b8b4084236b3fa63de28aae057fc519ab0f95a606d482457ccdd81bf863433f3fe9ff0d5875b4feddb4471f6238e9ffa8132a90f34038cbb498fee3073ea990494b4fb42037a90a6e11bdd4e69a36f6788cbece80ccfe8fa5bbb6f6ccb932c434f53df7a439d1220a8eb79e9c87b24414bde97f50ad3641914870cdc896372cbf86eb7635e6ccd6d9eb4a6978662527067dc6e14c07acf0340516d30a5f0cb618d8263cf2c5b8f816ceee7265d40752f324b2feed036020e8256ac30b1a20e20a9be64aa5c2653bb50458d2619e07bafe16d93879d7f1c5e1149b2d533f46e5876c96f384f5615f8ba4e50c3634eb44fd16796e34f1cb4ec017077981667c69dec2166c05c1d3b9cf6da1fe1f566dd09c3a63924aa1070ad71813b23c86dc9aaf9f0b154e1e3a64a5aaae88853137aeac83a0c450b9a9bd439fec0d4d7da8f3d42468f6966253d3709d3b4487a7fb253b9fcaa9c152a0b3a687bd99320698734cc1ad7e311b6d43bb51f48bc9631a5bb61cf65c2130ff32863607c0f6beaff7779902fad96c20074c6fbc1b3a8628dfd094152dc7aae80b2cd452b721525c2ed4c9492d7cc265afda5b448ae884f17ce2bdddfd614b236813c6773bbf53e5ba823036fa3f57138b405d0485a474f166111cddd7ba360a030faca68a9ed0bdf37b9ab97c407ef2553131c6bdbd9a6c8cb7d86b13f3edce7f7832c537a02ce884767becd685bb290ac7f8ef2c4cee6588c0acc858406d19c0967d0b5972b2877d44e4ee8816dff85cef7b040fd1fb9d802cdc0b68231b003054317eeca010c20493dab648cf989ca5f52cac384eb18257d23476d004c37f3e15e37556f4f56acc7b7a73cb176403d5b306395893b44d506363cb14ac8d4fa4907276d0236716e461c5a035542317dcc83df88f8a6f077f6e4dcbb7a5487a8b80b3a5cc127130891e06f9165ddb531012e6be7b8a804a90722706052b60deaa8cfe105a8424453f59759d26d05d6d499f5c6f5b19f8b51f52592bdd03c8023f951140384452d5b4a91e6319092d9fd109e04641ad6345db1ddf0387d9da98824f377bfe291b33c3ee9fb22666c3969eafa60459ae105c5d546b5119ed9bb98266eaf69cd877d28c32a0dddbe56b7f6c8879dffd3caf79db8eb1afa056549a2ee9df1e63e63e96f968ef53b73bed5b7259f05b95ff925ac9b710235a29eb3a9e66678075a5d2d67c47d1190cadd31ab97ab5ccac9af727b1bef4f1ac93f4ffecd4a9b26fac929465ad862386565b4f33aae04a13efcf71ccd8d7001156d6f812ff3daf4b30785eaf14f97060edaa708b4677e85c120720008484c776005004238dd5d5d3cb0cf0514648f87e6bbf064b5f992485965e919647dcb299b536b8c451a986bc09efcb5872d03cb125c3b3165e6ff740bd5a76d38e72d471c7be7279f80c78caaf366f1d4f30a5421c1a5365476e115fd731002dde1cf3ea91a8a1a34ec8ef624736720e7b5edf0ee3061d5229cea5d67a9b6d946d5037290149c8a2a33c86d1c33b3c34e73c471cb7bf35f461fabeaf57d97a157398bf9feb1815615ebd52e109020a69fe8577cd386943f8af1435d9a69768b98b3e6c2e5e1faeb77d57626cec5b41efc5822e1d2f94d8838d2655b9b871e54778a63e5185709e9c58c54c5eb0cf48c9ff1d81ffbfad1562fa4f3286427e884cac678a9943962916438df712f914a5d6ab7666a941f16984ed8821ddde846bad31a9066ed12e5000405db527658f0cb00d6570e8be88903517665ca3e699ad9cfd8dc4dc88853210c8e76fa63e3a3a29d052557566050e5502ca7f692e6b52765d4cd2670eefbd38eb7d72af8afd0ec4b9b7c5313c96acfbe2b3c74cc7645de90cf17958ebb0e39235deb957d34eb9f719abb9593b993f123cef7cc53d09326856b183b103b228d13b3342b368c64be36fc800d6d334f8c860f267c4ffd5de40f90cb32789f5575ad3556d97d8dee1c017d937737ae90ea38a2962d437f81aa2c849e65737debf344249d061c7af42dd214ea6336e00239c4ab4fe9817348d1fb4a5532254912bee2f9d30cfefb3607ce6bb735635247037f998bbf3ab7cd6879b07d4563d769ca46bb281d407ef7dc13f622235000338fc1c1faa9fe09c1908772177a03fedf9581022489d084aeedbb04627f50580b4aa5eddf5944b8cf4f9ec8a49221ca7896f3f59da430a310e28e8326e555b3c3734dbb4281433b163ee559591deddb4e1044188f444ed45d6f3ee857ca84d49ff7c98482315dc8af63290bceb204fd6bbb18627f9371ca67fa09759308753b00f12bb3abc944a0a2334fdde16b381fc47c04c7fdf64a20827e070cebcc451b5e7b2f1f3573bed63cf3c32239a3afa32acb023d392a6780396a326dcace568d3e13d1d293a5140e78f98cf30d5e24233327f7dc55d3c36291849bca02f9f17ff1a13d732ca3636fad64a708334f79a8996901ec1d3981e92b81cf2b9ae01e39e846205d9c6a9bb5920416b63f749d9b2b69d1873dcecd8da65e5b3cf2636813f4b145806d16fb66f81157ae763f0c1a615dac14fc8e727215b7867bd16e72ff2ad8c3c774b69f0dac584c7cbdaa28013410819775a2d44e6489be6d897bd02237e848e45e0155683825b4b9c1ac1e2568d88318b7af2421b2449c7d8605d9af786480087f7a76a5f20e0c6d76f7fc459abc01fa556f0c8092f98347c0c9465c5f108afb2d77f2abe52233db8eaea9ec7cb202e60485aadd12a09f269a511ddd749b719f3b8bdd101e4be17195487224ecc61c5ecfe39b6d21d527fdc959a45d5fadc5160a51dd196fddfcf2150ca9bd5b534b734cfdb93e1584a49ba341e6f7a2a7f806bce964e0d9c35f54d957d8324186c1d18055b3ac706aa22f67f73f406bd097f7b17090b18f052856dd384b223c0600390f6779d891c794d2312cc24c8c0d729a5e4eef206dedf2d87d631064aa7acd7ccb584a12c0037843fb924f465495ad5599c3f133aa4ec29e06e9ed43b99f46bf37b73e3678e26d7effdea09b2d29d9f49a643bf815ccf74ae827afaba17df6973d8a580cabc96ea45ffb8af0376c215af612c66b556caec4c40af40c5cb90a4aff79a34b55d5ad2113704fff336341f3b200dab0205d9b593c78218dd0421297ce34b64cf341206c901faa4fb6ebeea457d86b426026f876b204b183cf6a77c89abb480ef5da86daa98b6810ec3a7e3b15c3b00f8d7d4ea4ae35383a01bf74d2b8725287cab1e795dd79a4c910da053e582c4cf79b4b08f7d71f197573f1eb4cf05d68c8d229625ad1473e41281255d361cf7dcd2c362fedbaa0349320a525c537328da7769b0d2862d989e21a80072cc83354c379596dba8d6ea70a6441a0bee609009900f831761183aeda2c5dc1e323056d3b461f125d117ff5db48c19b6a2ae80b136045fb140037158f59ce0a0d99a487fcae3146f578298e83373ce5166cde27d8d184e38ecef6ffd2f480e2c05cd5aa1b744595ee1ae1260344ab5024cbd1c183fd17a7cae644a71e15be299e5a97e9c78e1aa8ee21251f2fd6554e1bd62541a9c4c26318bb607874ce2844fc9a417de926ad4b85871092c36ffe296b44766c0444dc57873ae3e0783ed7aaba946e3ffd709b6e6d3a6a41ef55c972863fe9054d9c8a5fc4e6b3468435de9e8ac8a975b20972afd7879242cf397e36b21e1426810ef0d1434bb442bb3c7c36b48e8affa893ba6b2e13f6c785d58599042d235173f1cabc4c50622bc40498d8a4bc849c977cb8c178a16e67d3f9b7be3b3aa78774a091ab9fcd6df905922ccbfe16d4c8416b5b2a12879b56d0a47a19548e230f9cd09bcf6c4aab84403ca097ddb0bb5160b38f627e125e08e57bc0edeef08b779d81a32f1bfcd9a454c6ee73eef890268a35b51e50f4857d451066719efc3230b5882c32280eb5b2e92e151a2f551e9f5e9b2bf87146a19bcbc5081a1b156230b61c88241d60e40561d0dfd33668ec75e67c963d8a9ec9291385b1a211e91d5e802c7d8107bfd16f84b214a8ae98fd088b83e14245d0f7b33ee28ed1a1cbfde9be322e83e003ca87def5247bc48bd0abe48736344326e146ae13c1f6fcd576df788041bd7de26dec94ce855d17c6b1d702ad2368f61367e03f022743c5cdec0eb5a358016a6a3e3a269e3317be28857f93b9de249bc092d0d14a6f2ad2a71fac0020cd6574d7614c7e1cac36b0cb933e9801aeb01c39480ea0d09b31bdfccefbe0b9742ec1d23a0128fccc1bf3ff2b4ee1b2f0d1b0f9c96fcade9f4b92d2d56a6b0ca82204526eb8e070459b1abfb41e1f71bf0bad54140eab700c17b19cfd681b591df9e6471dccc7f4031c0b1bb73d8df52943703904cac98ac9dd1f00c75bb29c24eb4e50f6e1e820ba5c242d970802159de562329eb97114ff5b70740dcadf6670be2de0b6a8a6a5d3831ee3667a7dfc5402113d030dbdc75bd37ce8c81a799299aec861fcbaa267f2d91b9159a35104b82ccc255bac556f02fa265e171347f64d44cccd2e9e181ca11ed32cf2184bf5f3df97aac91e31644c03313e6d7c39b7afb5a76de205c6b786f9b3df40c2668777b166bcfa7c21a0562b6950a99114e077e008805dad75e5e2544e42c2c62bbe04c1cfe0d4eba073fd9a94aad9c8442b2b39b9dc2631401cec905ce392cc813655448534a063d1e8406758f2ac4f7bb1d81c85907ed44dab96823f7f1fc1f892f92c082e917be5ecff8ff806c28063585ad867dda5094f5d9d3c9e7f6d3ffc33971cc289f9d8cf4260c850f0caec48ee8d02fd2b8206b6de2d000917ad520ccf37a8b11536dd2bf464460faa2bea3cf1e2e83ba185d5ae7ab0a278051d2312db2e583637af07f9dd8025596ca095d5627fd44d5d0ee9cf85b6611b48d046906e272d73dfe30f8e47202572d46bd2effb7093876ee9e9319603cd62fbaa4b2eea92eb01dbb42576310a153d9d6891ccb6189f3576ca15ae6792545391bd035dfe1d6556a744ba322e0d14e5be98507eb855083e9d64e8e418c206e1379e0e9481e691778a361e56f153689a82f01730fb6add67ebeba8efac891a809c0c761f0df9b9aaf011ce0958f4bedbf80e8dd1f53259af8ab70388b1e43c43876a7ff63f6036fc79d191b82cbcab909a353b016aaff2806af9eda3e3fed24bd064209b8ffd55a897a26c5c795fab3ea25f1cefa92155680c926bede570be8da733791a12f343a6c91a0c63f51bd2f13a9552d66f2acd08eb6f110f7fa1fedc368e47315d68ec32325a8e01ee3ed51cd8ad4ce360cd17fd25752d7104890fc20c8c01f8d83680e696a9972dd4495bb13351a158217e5ef9aecdb1c0063b4c652cf219f1ec324105fb6a43ed1f1109f64b3cb2680982635ba767af6c92b5a30acd6b0fe8a8ee3e30892096b2c9c4f771c001355adb435593deec618b02b5252001ecdbf4681ddfdb85512762b943b0aa42bfc513977a3cd223833427546eada80c1d364c52a7caf4fcfcdf7895851caed8b34233317a6e7175f18555dc45b00261220e3ca84cc38a19baed7a6ab46096353b034c976da5bd8c602877b442cd9ea04954861985f6c615481fedf7c85c1b7f902b93a0b9d51d2d7dad26f90d4be9a4edd467d535f78cde11514223a07ef96b85ac8d0b1258d44b188f4d2ee79a438e1dedafe2f26b16259956677fcc2eff5d1dc93a976b4683caf41af5e972559aaf0cb64d11f578657b52b51b4c6e96280bd7456c57b25578b385c694af356ac4918dec335e422ca0ce24a506b45e88b0855ad1059abaed5ebd4ce221459e33ee59f746d7d46c8fcce57743468f3a9d4edb6581a704753995a3d6d7fa2b9bdeb5f7c732616e2e681f1fbef375de5af0dc9a222dc40550f1d2b51e3f96af93a2360ebe40f3ee2382aea3c3f2eaef404fd7ee6e75baee048cd5c396f66aaba4121912e620b66468bdad30480ede201c2c2f5d601561c30f2056e302ee41516d72fcfb4f1346921affab7d13f15f3a2831caa7ed4860ae9d082a37d00d0360d855c636dc7ac88ae20580bf409d10efb9ae31580b86b4665fd99d1493d7d6d475ed230cddafa6adb9ed49452bd27e6d05bcad99fed8091a4581c6650e92ed7ca2b1637414c20c62da5f6a5b0f7be8dfa885e3631b37608261ea99bd5e3e649757a1fb4da6f9f6fda8bcb7c1273d45d9e9fd6ca277260eac1768d3a93b957d9bb594a420a91908dd068d08de7d1cbb4b3d9be63879a7f118427225f84ff787d2ef022f57ffbd083c53857c8cbf2151e800eaa7ee9dc9fc235ab278a6a6419951f09d05c97f6a27847bab6d10a2ba9ddf02c6678432013d8780cec5cdeca57bb55e46359fd5482f280da18d4536e7dfbc982708a982c28ca3bd4941cb1ce539a2eb1b92baf29cde5042e9fadb1fef215f6af198c76d3a640fc6c9f5d647916cda7a07f371ed707555bb4a9ccbecaed74614a46c14ebf36e884f177ff205e0ebe45845f8b2fde789288783fb61e836c967afd6ec33264a2f5d530f28f328f68348c25c5d74cf8a6b17a8ca9ef28ff486adf50ac02af8c48cd998d2d448095608088f76dfc6dce887548feb056bce7d3d4d12f2c0733b04b04de21969e4e1cb0a08b1f6a5fc7ab457cd15c5cc5f060f6e5dc2d169e31d39910bc5e913aad27494bbbf30fd5ada691f8bf841993105b3636f1002123beefd6fad85963ad0842e8d2f4f347ad82841a7c93ecc9bf76f6592754f378ca8760345cdd58a17ad43da4fad05310522fb72ad230e77987cd9105d266b78e0863a3f97cef3b8eb68caa8ceaf37539007bebadf504da60683a42bebcf034efe0ad417e0061f403aa33ed3cd667c8fda8852400b4ea99eeb5162cf39904ff59a41a62e4001224cb3b523f8c7109f92e153c226fff485ac494bf8b629abce29e6199ebe5fe1622e7355c9f681496f6b74cf7a2ecfe152cb893411f6d20d30dcd592e77ea8d79dc6948bb75e0f49ef32881f40c070376730b5a22d37e7267f24773eb2ef78c70267b0527bd2c8302e8e20c1f49152656112bad3767aab22637b0f0bf30b97da4b52e0c0d6dd1c1aeeac6d63e8f7cdaf590d586264fe755e2ec4fff00a89f4b1848b83aa271d8d3ccdb387c31a056ed117b44614da0c92cd432c1d85b067eed99f6c995ab208febd9888ba0a1c2d40138c6dc709f075b5840cfeb4b5e0e465495b42a641356df74f8f34196d5e993561ac7f83c731731c37924110e55af8f8c561b36042291158a421d5fed5f9125758f58af7d44bb430b59413731fbda463af7202da0b33d38e4eeeb413c9d45e7528be2b20237800462d7435b49729e1bdc57884591330570d95f47072e42421c4ad67a63d77f619a6f9ade36c05029cf83af96b72157231f32d00a0f6fc1f6f4a2b9302a18d5bbb10ee223e80b747a4b516c9e1e96fd8440fd58295f62a960d9ff4c1b4e4c12183472befe4f07250f34b4d8d1fd5e2cf353cfcae79de3cc241be1bc384750fed339e7592e6de8513ee6ac73f292f36dbf53fbcdd8feb8aa9869e1bd21d8a45ccf9a86866e7b66054dde1f33b5921e7225b9ceef1f2347071aa1532df5480b88a7346d36df9ef2ccb85212cea80cc786882b1a88a27d2e413d888c6bb46aad667cdf59a95780a78ee493a544fdf17b06f890c611ac309b48b455f3b0c9e8d32d66a001b6b0c4c46367802190d9209a22a6fcadc0239629ec84b6c8afd143a1300994104aeef397e4ff0ef14eb75cbd406e2676322ba3c5afd6e2ec7a6709b6b9ece8a70a115d2741f4764cb3e19f1e126947e01fe239ad40cf05c53908726bbd658ce5283313aaa0e40bc87a96ffbdf75542cdd96b5a7c52d027b7d94e90ffd3456cc93e25d1cb207c4edce0d1dc5d16579ae8ad595dd49d4a174512e65c118417cc4b745bb67a9b5e1f893d30b75dc7d893dbe503e1eb896fdc41015e2a4ce38a9d17caaf9c236bfb65bc1e87899c9d19dd36386381bfe3f3fbec9d1175e9552dd837a62bdd41366333d6b7449dcffd8b24e0c0f5596e474df041484436bb7f6cab73f1f76321ba06ad9cb25c6f4ab792f99a1b1d6815c6b2cb5d9451aca465fc72767d7e4798d898784dd969deda3d81c057dce4928f14d5af3971848692f3f54d0fde683f8d6055fad88414000fe2c438626eb196f832d1c038aee11fb29ebac4bee6138e245a63a157a7bcd8a00561de9ff65b2031eb0cadc8d9256c96ff2efe5486064d4abefda7f94071a72cf0353b210cb2be8401812956e97dc39cbb1646be330600a0fab16ff31afe3e03c2a59c666813e23689bd2d1235f6dcfe66dc1375e28b39bd99eb22a2b43d07c6fc707ff61e8a163fa1f71123c8c86a576dd5c965a9f8af1959e7cd76e23c0b24f99f6f8d06709dac977af100c12a4b740c73e316b289ffdf06db30eb3d0a143122da115097ae28c8f32349e60593e516bb5e684530267953981a8da9aea4056cae330460d2127ab7ee91740d08234a92bd45ac75a530bf87b5417691dd1829477bb47af27c584cc56eacd34cc9cce4a8116aaa4b0a48279b3235083c524ff9867928383df2f88ca90bcffd5ba239f7d0ff77ae48b98732808c61fcba028db9665a9b814a8322ce29b515a97db92db0f305fa4b3b0c6e5b593d2679b85fe78aa4fb84694f8cb85b85e4d87eb73cf124edb3199272661c2ef52185c685b700984700ae855e2caaa52998d5e083bd1d60b53cb42b3d788f3197ac34621662daaf950c19636d3348eb6f7fe6fd4bd44c9d2d1403722b01e47e89efcdf1a2c5475d59a0fecc229f7c76dd0c8ccac69182591dabd4616f3a55525c59d3c902bf49f5bae8ee4a044d8f0dae1c97c6fe1db0dc9ba2b70e832360a07f91d869e15e21412668d5fd02b03d4ece1a32b5358ae53cb1450ae5b9cd0de900bca5acd0605d0aafdbee4cd7d22d2451d2646ea26d1f69fff707283370f2c189f92660ef91b024610cada1b1ab73a5c1fe35ce9e9fda1ba4309328af693737e0b8d16dbc26f6810d44f6f189b2b5b88a93737a90ff66330e779317b596fc62fd7b435e028b03608b747c37dc8e82da68e7c810fdde22c9d778029adfb696ac85242fd18ab87fba440e06e67aef91dcd50cabfaa1703a69dab9d6e96b93d02297f49c2811b5cdd10dcf5e93172453ae7d0aa3b796dab4d1b52ef32ba47276ec983d708a3d9006e3bc99b0c755485acaeed871bf39d0f824a14a1e2ac0cbf679965661eebf8cd9070a0d631a78f1504987a8b88b4f47c8424f2abf99a59967b4b3d187c823dcc2dcad11c15139f7788d225a77e4181b2158045aefed925bcbaca18ab988174d4c4e884d92bf99b29b751edadd9994ecf372a4c754a8e4419e06e56bd567daa4c3b02e7eda0e37082284337e0fed3272d4b3a30e5be1230f16d3e2140e77937eb1dbf018d82f72b640c1a9047903d8fda29458fcff5a964cc05c9771832095deafd8cbad5f92dc6962c3a780470733bcab2263af585a3621cdff34b9759e0ff73a5156c37dc8baa4b66e6f5265bc35ff6380e25defc3ec5ace7832a889f8349806bf180c506deb4356225e586c0b953d70927ecf298aa4a5bbb4ae923115afa8ac2a2c7b8593cd7e9a5614e016399b72297de35d69e4a73f1108fef394e30f32021314df86c6e5e79ba6ff630287c87c7ad4d5485c4738dedea29fb7632a65985e63a03419910d0bf7ab9794f5e3e5a749529bc6937f0c91786625a78140d24648f83d023d376c7175aeeab25548023382759ebffdddcb8553ad18dc3f3f0538650c05f51727df66c7a7f4a4c307084a1b53f70a4edb5c72e162290659133efec1db62abbc3c134980cd4055e43d0108048618973c71243ce5ecc86c93216981ea3a494a48d42f7a1a94545e768d490c32b27dd2e58ee8a06e25fdb395d3b4303e145a8e3aba95427bfa493bce5ec01a8855fed574a988ba822316ad6e3ccb86ae4bc77b3d7f600990b17da96df845b5267fe751b3a94ee1dbf2eb0bf21f3cc8376fb2a4994e037a31afe97ef8ce827710334d103de4582ac8a3493834fb52d9e9cfc0f0699e1d33a9ea452d6358737b43756a051fb8959409ba939340ca42ecd87034ec557edc6ff2bbe16ba4da4d9991f74ea8d4e568bd23fadce91d63599cf88df7950bcd2ac59f52e6fec0ed1eee96ace5e13fa8f78c4ec61b28ac31437b23b33c2c5705f40a549a7f4c515ce814e799eddf5d83804238976a9081c62226eab1cf6c27a0c3238db14a300f3114892f6965b513b2a5d309c38f8e48a9e32633a55cbae81301c6f5e76fb31633d199f80bfab7982b3b8c1eec8f959944ea5f4e2c41d0f1d6e16feb582e019e90a8816efbfd771faeaae256c8a21dc4f2fb60b7d684affd70ddd837183bc6d1fec74c36c7f5080574cc64cbd39a806c38475234f2bd85ce3f40fd31f4746e8304642e924aee26bbb89549de08d7fc022bc252558296c405935510b09b4a9fcfe000db1f9679ce5b1889ddb1e314b0aea0111e9874e2fb4a4b17938125a2875f20fb302ea0803662932660dd0384d8bf1d8f29a2b81c33025c0b546e1c11279fe495b40900accdfe94691136bb761b7706a70b06d968db8f29f80ce37c834261b7a56a7a6283750cccbc60cbf99ea98d2f853c2f395d48433184e94a7cf44af781b0f85fc6e1b68b0df1a1539b88a2f6ae3439053ec83923470a526bcb4880b05140b27bd1aa1e2231fac9b2adf3f0a75a5f9765e6a8b15923c542ac0801d3a91443d85b70d505192fb235958871476ebd3a00eec9910a79296e8eb1a770450890e382ae762d3c33657c033ad8cc7bd78eb5cee2e30c6f4ff74225a192820ae845808ffd8b59857c1332fdda7fb16cf90047d51957ad33533d72aedba3c348aed1a855d795efd6ebb4c1719d438544652142858b9d0576e39e742a2895b16608ab12bf7f6473fcf51d02739b6bf372fa7190847a286bd6078b2a75404589685d29c020ff3b209e0ab9aea4353251cf1f4c917607c2755b082b00927e13d7143635c01ccca6f5820970a35831f6f28db48e85a4ea7dfa99428d5eda94c5e66e9ef18216eeee8cc9a297b9862e199c39404cd64cf7f475c2b54a72474af61d60a6669b14b46261a6d0c52d454044eb3a86d4b88d5afe7aee708c77d1c229ab6e3361dca62dfea6968d5bdbe0314f3506030e41514c452ded445ba2e6d663f03cca668df3e4de02a246b3a5b9f8db46b1f732fd8b8ebfb2dfd273dbfb15ece67ae24e1b1aa7140c91ce05f210c61004c37203883e07df85bb7a7b33b9b789c302d104d5f6048b7bf73ac49bddb1a2ec869de66f36aae6e3fe667dae950965152878c423bac3ebc6549443bfce67a3d28c59f10ca9d0c68c82cb041dcb08c4387bc9fa2c2d22f2f0d110cfe2ba62c365710af3cbf5a53b90f9f79974a15a67d6363cd0b1732bfba690241142706cfda1b56caf82bfaba01a2242ebbf8cc90d6c0cf56f9d30a796fb39bdb754cf6fd58617259eba32118470da86a760c0ccc4505c67277fabd0ff0f55818fb38a0ead98eaeb2152c5ad5f7b88875c792a503f04dc83a5e0de1eca945cda849cb1c384a61d35a0c1287f69c489f3d53b57ff15adb7dba3d1c887235aea3669065cc7445270dac20a2439ae05e4abb3be97e7bf486a6f784961722b04e4cf35e31cbbea7e7243df87d789285ab091ce51586f34861ca6f31610607424c67fc66aa619837c89405195abd3ca9c51f1e4bcf97a8561fcd142f56765e10e2b4d8547225331b2dc4b81b7eedad64aa833d3876a194bdd53829e9496824fc408d143ab3cf23f10a3946a9f154330e82c328386d4382cb897170fd03fba96e2ad826a689c2da5990eae48793a8e8cb729609211782b004d8775d42ee163e0f8f432eb930bcee6f5970be39da0bc82131b68ed2e2e5a8ca2e22b4cfa88935fd3c0d87aeac9f1995544aa8c4db4b068c68a71974c0beaa8022d27c9fd77b11c2f62f0de4233b1d9c177f6e5cf929194665eef8748857c3fd128b2c27a6e589def5a97a20a2441c1438369f8a678b2be33c03486b2b2344d2dba55ed690cead86e3d2533554d76b9ca5956b3a015362e6d20270b0fb85d3ce6de5481de407b5fe3a7df363a232419fb27abd099a8c63fa07b60a19804d53376865d4ac0483a03de3cd07c38e2a8872273a0231b0f60e8d2e1707368c206547b698b979dd4bad46a8667cd11edba66fd67abace678c64c8fc7b481033f67f7e715da6ff7ad86462aa63d431a8b97f698169a7d8c57951c186512168b6e99f3700862874cce36987ef3a0ecb4fc78c61bb623291628fbc95b8b490805cde690c27635400a8118413b81b975c7d0d73bf38506d1a29604136b4b8312ae2c48b777c2e1f0ad3bec492034d88ab3bd2ed70a6140e81017643f1ed75d54d16c6856e253160e6f03fe46618c11c4b2feeedda2fab58a9c80a68ba514e9515ba5826ba5ed5acece179ead01b5b5fb37d30d944f1235bc85fcf1a456431e6af224bf95ca792d4ff15cc6626104c08e2d803d1d392e76a6b22e5ea42b70f0f2af5bf99173f9bdc359fd98ec45a07e696f097504c3ed0f0b374d6bc01f087130decd5d32a1c12e0924aefd40a673af07afcbe9db393dedb18b7e470f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
