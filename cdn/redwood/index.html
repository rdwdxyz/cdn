<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"151f04a1b1c5f88fc7fd4e6a34233c6b5cf390bac9995e7c43803ff5857fa37114c3e22e89ec3167e7e53d034cfe5474e535184c986bb418736e3d24964f31b1bb9c495aa8d60c8c3f3ce95e3ba30d2cfd52988c2c14fb1ff485cbacd3b94db0465659b34e9db38f26f764f4b79dba809d234d49975e64c56d44dab11a4a0561f48867f44add785cbb4f105674b795569869a1b88ce9d59bf5eb1bcf51569226e7f1243efae8d6e2f0cf553c951e2c49da68b2bdc422f06d09ce40c52a6a18f93cff60ee7dc018df3183d8d2251abdcb9c461ff25d9b5226f032d8a8639c5f0c4acba5abc0c61114821c66222ca0d987b29e3af40998f0f5028335ae991a52f9c6911f66f92e597d22c42e1848ab6a8d89dcedb5be6bd1af869f5335d7034c896e85e90ea99226a6c32cd3115f66a66278ce5a0b2410c770c7b091547878c3099a4549f64025b1c3c9b329c40f40320f3a4f266b18cba11d1e5539f9effc55762eef95c7be468b45bc7b5e2f1af850f982dc8b22354026274be0cdbbea159ea5ae083f86f52a691acf262841f656e18fff25bfec273ac3ef9a8f73f1ecf13aeeef74b05a149a10ae211e87fa7dcf2357c8d91ebb48224f722a4315e9037fd902a1956ce3cb800fa3239273264ef704d355d32b14325ca435038ccc6f3ec3023b2e124cbd0b587e14d320eda277d595f15147e640982f42dd09c1e673abbc26fdaa1beab48ef12dd154fb672535c9aeaaea62e9085b55bea1c8b14d8893b47335621bd9fd9fb8db8cdb8964447b031db477a965fc62be2ad1f6d50213d9f84dc2b6d5bd1ba6e54e022b3337877cd88117567c9ab908af591a5312cdf94423cbb16b9680fa8c1d7caa2a85c8866d66f23733eddc66ea945a847abd2d1b5006a71ab547b930cdb110730b2ae4756a07faed4af362b9d7f3be307f88d3392242664209d4f0926e9667ee0704ddd3df22654b232276990888379f94dd860c6cee8844e698936566f6333f5ae9f461eab749e397e29bc4157bd1c9102dd9e94055e5f63bec7c2a502703e305f50a1019978f1a8523585df56dec305c137980c1db569ad23ae85d64ad002b7ceefc39f6b3615cd682b775696f1631d1e7aa5f89514000e40f8ba375466f2e8a930e305d667bcf6506289bb9e5913cdbb4a684f86d845df0e332742315b46370c8127fbb7c75c994a65dfbe03028b1af598b1231cada0c89327a348cea1a222189954dde837ec701379112760642306bcf8f5bcafd73c9bae5e2d1fe24860997b7b701bf29e7de101b15c1da4c98f397395d2d1e78ca00b8a87db7f8f3870efedbe8b8b77642c29d81588a728e0bc269842b3704a36fdfe4485fd86f38fc628574fbf546366895aae951d13a47aca0f886b824d4cafb11be80dacf09dfbe7dc549732594d10a0301301a25d8c59882a266bfd8a196c9b43b41c37e2ac7e49a07bf5ecd3bee59280093379d7dda33bfc6b6da37fc80ae68ea1ac505fbba2dedf3d90854eacbe4e073f667db5556a7d69e43bc9972c918d9165592b77e3ae3e5e24fb13f7432bc311ca4d5c250b7f4409fc5c842b12944fd5b7f57d2b3de8d370849a62abb8bbd9dd0fab783dbb42f967f3bba663569e236b8ac9d297eca5ccc1c629a9191292b3872494efa311e61be01d7c6dd294a8d25f992af31170f6ad5e2a96c86037fe1a46dd7c857b856f3264963d07fa98d8c5c3cf7cec5bd8221b5d893464c67c0a0be6bfa566d2e7993316c834b201febac7c017f0c5d02bc8bed9ff825881e0443883b8b7bb82ff03604dc62556fba92bc2cbdf6386c75f0b9f29dae7ca22dc4f2c21c11cc8d4b84f654dfbdc2a9df3e810ecbada88078ec4c79cf6f61ea01ab6563ac9b76bcc780c978eb095fece672760230833d0cf546bf4df00960fbd325c2219f784691c3565d482553470bc76d88eb382159a94f3e8375735822f4cc1021dc7d9ed6450cab45c6950ac0362bd9b28f7efac34f30e92c2c0386a85079757e454ee7df712cede86dbcd48bdc3ba871ef5d51396bff0fb780d7d33275626ba204e16076a140ab64ffc56b7589c9931743b4e774d3f6cb19bdc4b3ce327c9948f629247da3902f6aaa2c7194f91a1e31394555f66fad290e0a17d5bfb014c648402e887b511f1029659a506cf92f3623de26744194898b61deb00b9855e19a314731d84e1dbcd109af3511a8a8546823973f9bdf91a078cf856bc825890b2bde4820878b7c4e87679fa76bc67b3d8651272593a629f31a1357bdb1d78d4b0fcf1f40bd3252277668eb7a5d6070a859fe026881ec74b093cec6d1a5af070bd2064ede19493ed2b165467ac43cb0588944a4641f5f117ba34853cb7c7d49fb2a6804cba6fc6f3db172bbdbda1f219c2aaf6f07740ba5db10216f2631aa264499029ec7f7262ec318e016a1184a8882da705e815a996310b3936067a506002b6ff1c23ca698922ee787922b3784ded421f5f90b59b95280f5b3af2aa290328d101e79c828ee30eec5866d309c68b6ad19c078f30449a5f78e339a4daf0ced785ce120555df0145e068565b6caca454918b2308dfbe5767cbcf604ed3b320cb5ba8d8222e55b324c99f3e70a7d54eb4a89609497907b5fca01b8c2695f827ec4162bea51312191d5c4066db21be62fcb5180c78dd51e65cb0b61fb1dcf1d3abc29a4032440f6cd2b3492988806bac8183a512e970c9a80f3c699d2efcfe3389bcd7e699730a08c3978ae91da7a9af0817a8aa5b2c3302df86b2fb431cafddf4a2cc8c7d9b8c6989c9d37fd3c94161bd420c77e4e73f40ecb5c27a33b090e6f09e7d6053ba695c358205f71d2d5ba0addc69551980d69f3383ce2d1bd7af2798f550a0228f731c5ca1fd501955e24f784749f24de06835d3ec5326effc336124f252d4305935cb4533f33c8d6aa7fd6b2c9177932e9c219004a1992fd2f38f9b3296a39d20f37d9cf3850650526f89ec3a497d95a9b2b11a302e11037a4911fa047cf55384b6bb2a0c19ce6cb8a75ce2f272b6894b6d15af5dfbdc434a3c3fe2a5edab1410d41b21acc8051019293ca14922f9aef85e1c512c09fa4f17e20351f3a32600062519199b91d14b25318fb92ebdfa47ea33467cd2709654a789eb9738828d0035c2457eb9f883d8cd7a9ff408b550447f3fb37397ba5bbdbd13dc1c52bffed45527561343633978fe9d97cfc2b9cc9011d42b9bfd9e381fde7e30d8431e9453245b0765a76691fbd4da3f58ac1948a80e4754cd5e171e6af3faefc6e4b9eec2cbb2b5658e977903341d9180c152ed6ffbf075b3203ff28047169951583eebd24ffff92b6cf23e53decc1dc409d82e14ef9375e6cd41daecc3c18e5cd0973bb53c0f08dacf6128bae1835f609d77fd65871353d44e635da2c4c0e8e12c927eda883c7a806d2e20d98c996a8559f181bd239673829eef71770ff918fc8ccc8489cd2ebcc21f2ee669dc572088cf989ec773856eda82375532b1feebea449055ea16636cc4dce473c4d135ffff25e588b8c9d8a2c42f23517ce519d16961d56cdd70c298baf401b0c6fd3e6e81b8165196c7439b212ff6c22edadfad85a778fd208e911ced4cc6bd5f2869324e0ef5aff0714cf9dbfe83a7211f2a315157b4a1d27e0fa3eeebe5266f17f08798af5ac9f11bb1885a11d1ed5f5cd4089cf8b0610965963acfe9258a3471ead851e4b14f0f19bbf878ef71735ce3f47b1eaa74072509fac73faf3721801701a635484f8a163a43e6f79aeb59ccb4cef4b7bb5d7a40ec149f028de33ad469811b6702b9f6503b69b443e78d2432dcb9cfa4f8bc6f88002966bfa83fb419c93e548375d671dc0e05a53c78d8eae7515cc6b6265d8c8afc1ac5321149cddcbd01dcbd90d12fae7a536ab3081dd36ad0d88faccde717fa9aab827a186b0be19dd08eaa819ec166f5d6da7519b471a3f8e6ad16d6d09742bbf7f3dd6650f355184952630c127272e4ef1727aa93b6913c02dccaf0a2b051685d36cbba84cf86bc7db694f5865a0fb6c60e6a9634fd7cf32853282fedce977a525a9679b85883aace6d9f512f3cd6e3160aeca7c4028153aa093c000e3d6af862c081196ad8debaba3bbb221be60666f86f9f958748a000717e6094887538b56c4d5a119bc7246ce5c03b0503b0ba66712c8b8a9e82b68cf299ab6cdd1667d8d55b0feda9f95d8822b0bff88a0cd86c48c75570c4a6e402f27356fcc2fec57dd31573f967e4c25221d6ca0acf340412bc56c74b49c20786dc05cccbcbb5b4173a7e556caa115a13d66b6e2ed7960061a89ca5aef1a6b855769367d747597ff9dd4306eb036abfb68bbdb980c44114403c03067157448fb9d3aba6fde34bd10895bf7a1c61d56c7040f810d7a27686498e4752231798b9aec44bc83746fb8df5dd75e4ceaf952f5e0da55849584aa8573059371d0df15cf6218011d206b34a9537aae771078f7b4adfb41a9565c58e95863bb7f43acf29d5729bc3fca90e1331514ad0270026dd9037298c76a2cd2f9bcfd31dc43e306f801847d528385aea4c7d4e935d5e0aaaf208c8b5ca150f9db490581a4f32c5151899ed954db0c5273448e56f6315a5c863925b2e694ace4f43b3e9c54217af019a86999f899ae8c0d26c2af0a16772a7ce69d60ccc8b0889f5ea1ffdd8fbfa858abc27f25847a5322cdb6733a3de649fda4d4e0d9553d6f5892192a0b24442c55d12c87ab188f310bfd0e5c48fec1f49c28524d7ea96977338e9a97a2ac77907bbf285ce5ef901aee02ecc58d3b13282f3ee05a124e0d9531b84931c90c0833496ae3147b1b66698942b2e9a698d43ce2afe3f8c448e3d3b010ebc6b41c60ec077a6033debea95fc7c002e6b1a10304f7d5409cbadfd01a675956776d4f7fb9d7bb9c68c771bb5f20a9750e59343b0c6e5e1dc0419485e8802ed6a7162cd11d5b562044642b730129199a47fb779d8bf6ce547cde590fac43bf1cc5e68c2b820e0782fc012cee322a8ad97b151514ab685469f122b82c81d5217ffd8e1f0657feac9775e00d8aabacbd6ce01c011f063aa0e324621bfd5bfb77de9bc218125748859f149583bfef4de27070b63913c03e7a9f848d546b45fd9e39aea492bda79e17e0735f71f7788508112687dfda11e43d482109b69a1aeed19711e9982817dd1d5c73bf4b66906a1f04b1353030747eec8bd2fee7fa9dbfc0378bc33a4f42e2ddf550bae74614a4701ee3067b7bfa063028ee519b1b6835c4af1b91a3d6bdd0a74f74f15487a893e6638ddcafb1e1c48794584a3fafd32b495f0904e8351a52e04146bb339f72dbf2a062050fddcb784b249b298d663a01a6fe50ec03824386f398cbd3110fd83635c10e31878f89ca6def67cf4f07544a6256adcee74efb37e3d8bd0414201f470b6fb71a7b9cba0cbc99c07fe2841fb18e5af19738948f74fba7e2d1ce28d57338ab4346843ca432b8acb145c2d35b14c1d1b168658e82d0dc978753311e1ddc2c32e952dad48433a972d87b5f621eb3abd2bb65abc325664329fd44c805340cedde7f54c3d0dd5bcc2f25852d260a9821165ea27ebb4632664175f14b826959b217469d9a3f10557ea4a2410a558ef698f288f04cd245e4a2d245b3fcfa75f0d6a5d0c13aa0f2f3e7ca79a76ff97f55f811e71700dcb0c7e539d3ffd54c1e00e175015cc805c0a6891d2198013ba4f29bc81662cb0ee8458f215af4e21ced304eea866fc718dad24a2fbc7764b3959d7ffd666cdb384ae066476fd1e263ce180a627d72f48cb8fd0ee4cb08cbfc3cc5b78a0ee14d3e4ceecfd7d8b07323fdee5f83dc1cc8daebf4ee1f2e02c64330952ac001621ba6ecf970036ab05ef3f538b05b9ac125cba461bc385f056be3f2989fb02806ce4406b305a94ce8e21369a6bdd5bfa7adcf92200310d5e7dff74b1a48991e6c34e31e860479fa0c75d53082c8526ac7d44fbe3ac1671dc0a0e08ae54747d9e441180831bc6f17ef3a0b03a03073bdcbe6bd54028a279a58ee984549d6112929399cf7802d2a9a8825b23aff5fc6430ea9d02bb987d2b1690810fa390cebbeeb725cd5790c4a3b1d63a1eb197916b6acb92b53f061ad75f89827ab8b551d04afc0f03d0741d213cc3bd90cf990a649de3633bc55573ba4aec7b67f398a1a5cc321acdebef73f25b7cfb2e96ab95fe907ae8a1221ec231eaee2f0916031c2093d8896519269767cc15dc45860de5e23a6da418d404fbc66a6800a6e10d412e8ea8d667a526fa3e3e2f6b639c64cc01bd667b5772ef939cfdb6a520ca790422c691ede7aba02d2e51a3801f427337322db976c14f53eeda843115fd6d09a7bf3592346219439da29fb5a62f44782fcc8c448777e91b82257469ecf3f5bd47cfcc63698304dc92353dc88e045703a3cfb55e9219d38b660cd7bb5fc243fe0c0b79ff76874e9de20f255fc055b40e52cf7defb0252f62268e8be7c2474fb3f4873e25ab530ab010876b592db4410e8cfc1be805449199adcb15f48770f686c88430f3ed4168e6ecf67c4844e630912b991c96cc015464f9bf5c02f90faf8b7a7514f7c43523697b33727f2aeefc7b8e3c84dd31ff1efda96299c96775924bfd7eb9954559066ff3773935ed25fec33243051e51c40b64a9c981e642c890ebf6f6cca6a90ce9bc21e51fcbe00bdee87bf5feb2834e3097c3e33b03b48752763e230161af561eb32f95c336aed02b6b55e26b5854b39258aff32c22b0626afc606a7e3775dd8e156e9a6680f7fca0e78ad62544f10a74429394b75e095e54b6a5b2ef8b0049ef811e923b61867140f21e30b44f3410a4b2ca41f640e6713b7db553988c62f057e01282d00671511797c8d2d392d23ed7c5c18bc8c51c09bb300730f4bd6262e89472d1e16dfba1ffa9cecd7766401c4d1cc15e11d3b856f5ef906f02dcccd61d98a628b75611e0d901475e84ebfe5754ddaa4ee1c38c0bca023171dfa09ca1321e66aa022f54055b042636065355507958268cb4eb481adb7df1bd9b1c774494a2360d4679a8e2ea4ef24443bba276bd6887afe9712fa84abfd2ba29e66cfd4da6272e6479dd41bfafa21ead16fd9ae18a9879712c69d62ace6c00069fe782e3d42a9186ef32e336e2fcb5b960eb08cfbee63cbfe788002f32e080f73dff877e65f0394c16dd6ccc2415f298b9e23c775588b119a80ce5015f90bcc1db376339855dc728e3bcf1b81a45e886bfe9a5fb11e0afc7b5dc0a8946ad4abc48bf378673f197f965060b25d919927671154b6be46df3e17f8b66b53e83f837362bc4b647587dbb3750b469dbc3904531c00857c3c74a245dbaa4ea07060ade87383ee0e5c3b76d320e899f7f5a5e80648c02cbf46fa87ff5124348022e5130dbbd177c6d7f4837a9b489250954c6bdfb710b84066663829e126f9db8a048b9ba4ea77d67c45128adaf70885d8a3bf1fc9d581aba5f0cecd3fe6d393235d178c0bad06efe36a77a04f994c5efafb246ccbbe348e0ad3c5adf6d1ac859bdfaef7616e9c6b49c4e1c4be6d1efa5e0b8e1a57b030143aa32e589ee2f2ced8534672273dc3614ebe920da89c87b1054fd6ba41beb823e243e9d4a4493481ecc8da37e2f08a3299cbf36b6ea746895bed6510de5246196ec2163a7c3d200fb58c67b0a381799130e844086d1e864d4db28873d8f38759331b6fd4b1d1701210b3c09cd3bbcbffa3f9d78f5c872457483dbdaa64e5707d9e2cf807cf704b476eb93a1e22c8b9ee2feb158decbec51be0c395575219b4e8d83ef7a3d4c5cd5ec700fd14aff07befec4d7f1dc9ace7ee84574e46beb921d329b5725d9ff08d74aeaaf0a98b448f99d1c994656d9c985b6ad899faa12862e769e2cb791b0be093f0419a7d29619914ad2dc4fc1cc97070f28e34f197e35ffb8b1e4c5cc4ff6a63b23cc5b7609275015393a27a6eeb3ffedc4bcd3d6b19afc52c00b063fdb7f7f69a808e95b9b33bf9f95caad5d2a17f1a6571c9ec0cf8e76def8cac541992ab197f8bca24596dd13dc446225f60ebb9e226926ce83bae94dcc2f8e5e9d1aa76ae4c1e8c3bb2f6a47203cf28fede168c9354ea8e4f3c95c6dd14561212975ff57d3202544aee5f475afc43d155ad9c53cf901f2526610f21ce35f86c3c7d6784b9e9846310223d3c49275b670abee997196e71becde7e61d06d6cc92412449132e72edb98b0a679dcb3913e8306f8916a14b4d34fe15448543f6713c1e861a1d6d5bc8f7dd1c7c68a46723740f27cb987628d17f68bffe33694c034b993c287730572301b6fa63a4fb4e514f58ded227e2bb90de987cc0db7dc41e4688caa87d661e147dfa345ff331e80e3abdd9f5a098975b23963364e140fbaed528f76f9bee68cb2f1f2da3c7802dc5a2c95d76ccb67cd9ef18888a0e6d331e533320f072ff29a71a87fce1d3533f107c31fba041e08d635608f43f9b5f0be4b36bb4232d36369eacf9e4d9637925a4d82025591d02981041b69f0bf54512dfbaaa51d0cb8fd0cbf7300c7fb4a1dc393d361ebdfa8ab0ba4f6e16149310c2e5604308ce980ab6287bbafaca720a5022537925152de933a9c9b4b6699fd3904c57d7437cb671f2058b13b247b2cee35c585ce5e98934e275a799030ed366d940b319882e39e8a24e5943150cb9fad6d4bc66d9a30a0f881309a2a12a2d8cad0a9800fbfbc2a61d4cfe70d965bc3dbb765e30d18b4f7204c6b3e8dbecf612880f179ae3c60af0cfebb8334df957bfbef287f393a256e6a813e267b75e5bd1a4f980d3df9997b09324ccf1af5a59a1e33e3b66b24c8df4188cfa91a598a335c83ab299c353ea7419d607998d6e95247da390d1a8d957d4bc7905de0658b2cea98fe96c09da5dec0b37e1cfbc768e76b4d4bcd0fbe95cf6ca06cdc3e4509b74bf6e993a2c6898824c8457cd9b04e1720b3e71db362d568a89a23696eaa825d14e10156cecd0142d46aab7a06d76f2c466f7fa065c25577797ccb6524bed6f535c85e496444dcc0fb000caae790f8fab969d57177b2514531ea8a48db71ca6a51e32b6a801d153927487c4fbe47939631f0cd3fbe865caadf8a2950e192b23c34548ff8a4d1b08a0da554e9bc43362d30fad95bfaac416ea4f941af572a59813d8e47c1d345b1642b788118c87ca92df7d527bf2b81278e7e1821de21130075419ac3343f21645f97b439968b7b0efe81e3491c2f87cba7177fda48ffbb60ddeb92cf1e561caf1fc636f0f24afdad8511e25d576e4a2f004f8c66268a8409baba3200e100c61de14a98a59df33efcbc7caad39a319d9baa9b2bf5e3981035bfa6da0f064a54bd2f07ea96e6661f99ebe5acc0e8a2a6b2f52a7f926536cc019263c905bbd0f11f8e2ac502a447ad642e064da5cbf46423881bec30f311e73cea583d28bfa9ed6e90fec15efc1435ab82addec1cadd362971050160ca82200b1d61a684f55ccddf990303e71da859978791cea695f0facfc834a63dca64e8db3a5045f67787f28d5eebe8c8dff3c0e761f80e2a7c3d7980fae8c500c0887afb9ecfab470eb923a27924429a8b8d6707a5e63539692e1e510024d99b9d516d0b5003fcba6726b4b2697d7b58474e45f82725658ce949b4c00c7d0528bc681a96f48a8477aecce9c55fb7919b1ced43aec4992d389d3ac87be2c93a62c60b91a318fe5a280b6d3aa29c52d47e56ec93d1f0a6c3667338bb1be57426aedcf74a4d8ccb0685bc1f6c579af95fb0dd2eb8897c667a6d2b3dc9f67843633be015f8304340729d1d6c260a6055e9f0b660b6b5719e1677c5ec7da9b54a15c981741f8d289c1255576f89061852949c9d0c5b5955e44ba6440beca0b327dc22876a65a4f356c6fcbad9941190ad40e2fa7960f2772881f99eb64b87b99a25a0c9a5882fcc8640a6259853883d22ee1e640d1f851ae8ad621f208f800d1c90c4e2a29f45c23871b3da24cc041ef668cb12e785fb086d6acc1cc73503a938bcd78b32e20ddb68e199f06ae22757f50870a51af5d36ea29e7a5ba8864b837bf79675ded90829d7638e1ff431f68eb5d0210b37f9edd3a5e819e52aebb1b570011977abcc24a06bfea6e28af95bd0b2ff7af58ec0f55f56c58da404b2aca6fba0855d057ebd70e1229fdbe62da057a71ac1d944a6cc4203128ace0a3346b172ea0e1e7529030e45c043ff7f64a47a1072a49f824690c7ff04d8b0b60915a293e7ea6a8df63688017b19b5052baa6d17452b3708af4c772d0ee06e75c6c52b07a1522df7c11a7dcfc2ad27f0bc553ccdf51619a6d1076fd603f204f119b047a72adc2aa12f3cf17ca1c6afd788b4420f5887f7723ade39224ff8a46b2d782ce967d0137ec98bc5ab40cc2840a608bab87cf326700b2cdfb82b5713bfa11ed8a22858984fd1f6a57476f4ae311ff33af095a1a5762ed491c37a98c2cbb9599c7464f546eb65dfb5b0bcefb220b31fa484027d0af7a57c9eac70b441e027724495d4982302b4bdc54c0442683092c2bcad7376e0aec8aa27a87375115a3a867b6dd0ef15a5b8a7a97350645cb640f1f4add7653f09b393d693c57014ba4ec026794cdb83b7c573a6ba37372adc2045e1c06c59af5dfd527545a8ad379b8108884789923864e0c95c27e7c5476c7ff0ce9ab370557650693a9f5c6838cafb6cba4b165072d49ca9177db1b00b36e7530bd08fe69db815b02ae13c12fb9c0d351ad3343fbdb19978be17ba88eaf70a2b4e03c11b7237fd768276453603968dc74126be224b5a38f45a54767a1072cd85e66a52239fdf6441dacd421cf81c9a60da181aecdb02662407c759f8211043fe26bae836a41751b799bc43a7e635575d723106a1e3e0423fd18a39ba8e741ceb00c488d930693c198ebe256b45e3b2d7cd1d4fa0e6aa8fa9cd09b2bfaa7fa5cbcc1c52a5a634c69e49543c24b75f2feb4e8368cfa62e6286b1971fa968a0537d5e981fd0a0f0160d318bf2a26af13608fcd06c91b2ed59f7c19890e5da13d9b3d5ef61880a368a7dd93e3f38776b28ecdcea47237be05e0d2914625b3a7babe1f70a58f105b71674a3da7278ecf11f0b5d984bc228c0d680676e63e008d67949facd14b0c635d25787b1cbd6ec4466b256222dac10d04bfdbb754f25b00e3418bd13564e2cb8030af799add2725c7972da38932ccfc7d01d739037ceb5755e1aa1e4c3564c9361ef1c1807dbbeb78cdec4b79f30004e9237dea2628ed4cfb33b71565f49bddc3797a0b6bad17e3a0d177d91990098197259a9e3ca7fce19fe284f3a272b7c89c166992b5ec19ca90f054c5884f39895ea71d5cec1632200c35785ba34293ef6a73661740fd881b9e894768b9e8cd646b6a0e2581c439a7c0cb44c336f3637fd60598ca0e05104eb307187c0673d0c49e682cd4796e885254e20345f81eef8acab81f1d584182cec7b992e5fcf501c5d4905fb25e11a3928c4ca2e201cbfc8cc7f0e2dd3ab1ad9a8e80762e80bd19bc441afed4f96059ba38e3df66c19c1baa36659370e0ad59e21e454114235f20faceefdb3f2ebab805c1f2f3d766fd9329f0f763cfd8b74e4c027df79094e2405161dabb5735c1f8847d6949b50b162c4967c4e3ae200e03f2d93f4b6e2c935913cf8126bac697146664fccf9abd35bc9bb3702c62fe282bd6ebd412084d4fc393ddb6d478db13f38f7a3045913603cb3b4130d46534efe477b43a3e7509f732214f4f96906936dc5f8b3efc233a510809228ce7563518488a49bd17d3a217d41ffa84b531654858d6e71d10749ee440cf0bdc8ca68a98c10f9d6e33377b7be400eedf45dde189bb8ddf931882aa21be0c5e10f2df015b1116033c7eccd3c7e15599dfffb82f535494fa475d98d1455fb62dcfa42b9ed83f5a0039192daca9f97d73bc54af55881bd270d68c3a935b9b7185027b585c6f1c6581c05c894124d560d2124e37f3d81deae5b4506b50b6f9478cf2065ba2e419d64f2f7b3f3f96c2dd495318e553947ffb1a32e77fc55517ee9e25cf7ed5936c86564bfa463d485683a0595404cee1c3e498dc8911dbaef6cb669ecfbce3e95269d6023dc74b75784b77fb9033365752e8032d28918fe109e6f2398b92eb40b90017667ff5514fddd4005ec09d0c1996401f2ebeee65657255a49d20c342d039b0963f9be3f3f29908a99ae13293906aa49e226684c83e158cf1b8c43bdc19123b5b7dfdbbc8ff1e86e901483502e83d0ade7de78659bfd3b3f88bfecf77b6308385eafbd9fbbff6e88abd8814838b73ff5c555eba740f03ee423690e7ec806b2f1ecab4d9ec91d6f8618e840b262669fa502b2a9019e9aee127b2c57d8186a6df9f1b0498ff026fd08e0ab494bff2d1d01e1b82c101ddb101ed7c948c3eae08f8f5403f1baab679519e118bcbec282a3c06b611aa50c87ef74d22e58d165f4f568e0c65d81ee3d2572715f865405a18e9253c35a8d666839572a3f2c7646049b2a3fc088112cb50298d6441fac022dd510344241f24a5039c91a5e7332525a264770c956b1649ee1a3eb724df5889b77b2d0ca459e25946c9c7d0aa383af796fbe74abd8f0b648702aeae1cd900ac0e72905ba922267699efe19c0863d6509e7f10cc8a00259229eec376cbebfcc6527e68cc5b6d32c54c10770ba9d2ed9de18781c4e339a45496082182e0d8a24296976b24f78e6a8eded6f4b16b02ffbcc493a0964ed0f786e8605cddb0e7394f48902f3b486f298fb85b2eb996b552d2d95a31c59884beb6cf53d9b02fa85edf34ff838e5416485befd765829e6730a34077c8ebe536f392c37839870f29a8f9b7bd529e5815ed7e770ad4fb7dfd021a3892004cf8008326359983412a278d6af9c4f254418eb2224131524f066d2771818721e66f58e9df56cbf3cbf537c82bd6eabcd0b58f5ffbad3d9498cc65f79682cc01ab41e5676149fa706939b59a20b2b6ce8a0a56f58fc78eda64e999269ac06d91db52f215bfd5d023e85783286d2d4e75dd5c9f4b8aecacd38b30b09fdadf38c1bf1672bb079fe2a561e3604d66280e94143b09b112ada32e2b6e567e2b00416a5b05f7d55fde04dd552fa8f25ee4a93cdf29788c3781f7043605029f2673544977c6aba03fc6001d52c7f8e18cccef2470a36b12ea2d2abb2cf02bf4a7161dccb4378eb7855c2cd5682db1d3fc1ede0ec244f8c6c33867d8ae9a8ca94dabf01b0895d0b3fd462135aa702954ab74c87c795772a888443c78d04835e468e621ee44378a03810e3446171eb83e423761cd583d2b754a23ab6f139db96675ed725ded2f04bb4a3e49ccfbaea9534f0aa95d425abe11a0a5b351c7a6b3712904adbe19f9fecbf92216709e1824eecd719c53f932bde9ebd08f3d0a374992f6adebfe036faf9e918c8f784e818d579ef7e0a49da71f17e6e46e5965c424336da62f25a00ae474a1faff24d279fd831557ba1224bf73c56b322d5c89da873c26d2fb09f596a378b7d64f07a7459c5cd0e162c705d0fad924c8aa8c3e82ce6a007c84b92447b599b5ff1336d95d5978a3bc3c3c528dfce46a41b54179865308db8be3facab4983d21356292c3f446b0f95c3e728e8f51a3f6054d57ce4dea6eb0dc4955cc536d2d49b384ad7b15a029808c55eb90c7496444fab7967c811e392ade7c6b275a3936b7354b17c5c40be0f0e6859f214b4cf5444693513d93a9fea349290eae8ce1a9664ec5a6090a617c34883f2bd928d702889542474b94a490b539c22ea37434bbea85305bf7313943bbea8a35680275ec0da4d9a544ba89ec2e4389f3ac2d7e9bb66854d1337f394d5f035487960f3645e2e9f571a50f79afa2d22dd370af560167b3c6340077a817bbb940610c7a5351a1096fbdacd87e323af2c05482e4c5d7b95c60064a78c7e54d600f741e63ba14e37abea8fc10e1de5db96e4fa1a781303d59398cb3b59f48b1c402f328cb030e7f86cf9ee90cbb0cd5597075babf331ff231bd8b079a45a2444c61ac21f520e497b64e3243f08d32b46014ede988f8b0f00c71fa16775056c69d0396c3301021a8a0e1e9d9b9f8c9c0a2f0c78608ee9e9ad3139342d1b5d4e260b22d2c5caca891feb08e0ccb923a852897f67064515ff040910d64431990244bb313bd6fbc8b0f73de2e51712e49d5c7d44c827e3217cff9fb8a87bc4418b2016d1c0a80ed41ead85171792160176ad696f2e8a0848954f48f357e039745689a976f824a3c4e2ab65e681db08759d69a3fbda21ce8541fa52b39d827fb842292ee4d59c21ea8cd01e80523acb436ae2f4150de50204ac9ac4a7f46765e64f46c3ea8ca8a5b6354ec542aa6b680d63c337a8ecfa1dec84ac07097e85cb9e2eabf878c32d3504b0938ec2cde54d0d4b0fcaef4a6dd8cec473bb8bad60e20cbb17bd30bcb868899ef210df604d09e4191b998d7ff615a9ef446010071f0bb6a649d37837e2706765e4eb4112d1cf42e16802f2a67e66c459a9c918066262ada5c3473c5078f61ddb99bca404f1bfd013c6cdca2ffad95cea874689d40a94b4e4ab797f669240d6622314fd037d46af976f9d1cb6e833d85ca8248588289303db10c9526342ff4fb06fff1798db372303cba25a37136584bb86f23aaaac04ae107fb8d064aba43a1da2faf1e02004d10a1386b65db20d6689d54f69b00e133ffd9faa5ecc7da431a865f8147b2ccefabaa774d9444c5b4970427227b8cbfa986c0e22781a7072025635c047854aa47b71333749a052167f48110702a8bc972416ea466cf36642137918e4a7a14da3fdc514a694e9370e30e63220290347946a7ca54ad869d607b47a88d4b46969f7d9bea8696204ea47b368ed860807d484c26092a7e4c77aab095a0040a97757f5f3b5631d6f02047c9abf96287ad5fa65ae786e7ca0e72122628e835a788844b033ef1c34a09bcdbd73a4dc7dd367b38293e5a11d53be1e4aa78700918957e3e9f5fda1e7621e3302be5b906e9702e5c7ecd150ce5697f0c88d322b8c3896cd2152444904ebb97437b64f9bcffdb391a1caed081ba5e47b3451aa03a2af90363a0f49e9b84eedbd4bfdce9507afaf4d5ec223c14a80ce541df1f8d94f039e4843a56f9a4bd2c3515f4dc3a682eb5cac18e218e844348a7cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
