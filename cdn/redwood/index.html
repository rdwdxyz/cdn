<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14a4b1d1b3225c1354b8e913b7fa0edcd00922da16f94c3aa1da014f765ca5e579a6f59bff675292173d2041f2edf5f6cd2a453681111f6c8d4f6473e8116cc5c54c5e9289038b059c6fad9c68559ca205fe8b59e601a996b7a3b1b5b96558327685acab848dfcca67d20eb49cdf7755649a7b5531aea5679766d537aff4372f2e93d4995730f7160ecf324ac067a02f5cfedbf901961d4001969e64c59d84fcb3c21f858bf0e5edbb565d7f9cc2d0a0b88d4d24da95bd61d594b1e22b38ecb80fb2d591c3e66cda203bd74498d7a26bbe3fd31224b2c3041ccf984e96e3774d7a464e54e290f04da39b6765122da2c359c4444da0fcbee764f2a01b4be6eb159efcf62192123bbafca711afe1ccc7a583870c1ed5d37deb544c9bffb524593bf1e21f129b69d96577740be3592d61ed090a18812a14d32f7de7a5d579296a733f26633ecf8dae8c38f8fca5319a31937fe7f4f73120e87792b8a28531525ccb143a95587e686fd938bb463b7080574e45cf42ce1412d70c629f4bbb24957326cfbcd729d5a8c5a8fdb09a1a638f87adb7e432af023107834bdc805242099fea48ccfc7802758be49a994bbede1974d1597ad4f755798b49d1cb6f5bf0de0561fa51f47bc5966b68843ad20303079bc30de21b243366fd556d8b9d6a3ea3f38aa38d5aa1d050872c6f1cc6ba950de07870afb3843a74dea8afd7b0eec941be9498382bcb75fd630f22e14706b033cdac942254a9528223f51021cb3f5051d4d32d22278a76fab14757373fc1f14fb56d74c01a6d8fb6ecf66c38957ffd2053aebf8e5025bd950652efd53bc5909b3adc72c624e3391881a3dfd6becf40bdbc4f6855f079d327fafaf39d027bb14d6dabcbda73ecc9fe2ca4e98d7c83643ee9ae93abdd80e04f661fec631dc88b43366a3f43f42c38d543d88d3741e4b4432f304484559c9c0634fa0698dd6b0f704b7c0b744d655efeb8e4f7d98bb30ecaf06eb19f3bd5a1419481c7ed28a04a14393e2651f10e6c864a6b989b7d76b742488cace316ce5e831830795d4d464d06c73bcec5b1b98758828ae9ac1a42a0bc606febcfb1302644610ce8242d64959a391e901dc0c0bd0aea63adf845d7f76117ff1cc372a164eb4b253c26af3208d5a856bfc231197cf9cf505421bab7913dea552c7ee65d7a17c036e8a14134a0474752ea283d50d4e63d6b91126ecf93c378e884591206d6bc0bea3b0bdf9ec9fc222a555f55f2cf55e96d89c390a85b8f212d92b65c97a335725c9ca51d3acd5a5efc430bfd97c2658f7caa4393c32c7d7246e6deace2579b571d01d02ed1fd601442bfca1807f7e1a3cf06d9f470397e1357fdae6ae2117bd364ef9da64a99b9aa6ea4ecbd99331bbb4e93f1e171131426e2157ebb3c24490db0117f83b6b436ab062a7e16ea545ae9cf2ab70667101538ef6ec3313410fb56a2b44e71d1b0f3290e73591283889c4d3538764e6666c4200e46380dcd893b2e10e4b7fe9497950c6c5a38719a92d63be9d76abeb405f0b38d0145c7583f4938ed05ffd0be9bbcd4c74e62ec255f9920e3c2919f25017c6e78abe245caf087f7fe313ef36ae1f9042f156450972fda26c322cf7d53c5a6fde66dd4058637e7dc376a4e00a658add19fa3cc99535a348b580d3f9e82c6933422c5684a96c50a2d76d85d96cb0ce53cbc48e5dd7d7b164937a0332798d329f2ab842181efee102cdb074ca44f93daac9147d611def49e8e34fd189216feb3c65b7fbfb1dc6d0c6764ba9267b5d6fe13cab667b1dc57784afe6c0de253c919838ad86bc85749d3665dd939a3a9b2fdebb4de3adb295d3afd9fb54b2da35553498ec0c50356ec4288d30d4212c6625913a7f8d2fca56f1b5ffa2f35d5b2d204144dd1e10e0ea42c93e82b1845a024afe2ad58f6ba8ffb20a37409c1df0ecb247721e2081edade6614be25d80892d7830e5413d53fd91547de4be0a532e722ccc61806f572b87d6728eebde248486fba31a079ff64ea42a2547f9dcbbceba933fea33e3a3b065a704fd5f849e6ede225400abd695e08759d7b2227975a8c5852ea6650f8b6379843167150504ef794e6f7a633169b251d2de02e3d57c8f60e73d039ae9c0e77ae873c3e5b4706881c4f093784a15baa0ff5d8d693481913e0defa15e0587fd220890dfa4428f37bfdc1ae308848a8de4b5950652500015898ddc3394fa42d2f763752ec79d3ad9fe235352e83846ba05357549de1576b563a23ae316ecfc797612305c7eacf0fd49e0066b600d8afa9bd165472a1d6d24e32c12f5f11b715dcb038e1f77c7709b61268ecda1a2aadadc6337b8f06fb15b05840ae83c23573311eaa19623119892a5ab886a6d37c612021d998f4f13d419b5ef74e881aecdc776b290d447e62358f8a8d805392ad38f216b7e9a9a91c0b4cdc8a9982a63d864020b76c7df2bb5f2c638cc714d941ac03c1ae74005777f08a56e87bf1d87f8a4e9d83c62ccd1c9170a97f551a805f91c58870abfd7f6cf84de3750fbdffa3df8aa4bbb2a3eb1d82ef1028e3a32a94bf3a721ed1feb8373ced90a2caf4afc9926541e0b9b1c833040586aa581d68dc941abd3eeb777073dab9389b706b934a41b5151c9034f71cd52cf8798f3e44106994da73768323360e0014767cadeddb1d5f93f20fc365a8a0ac4b83acf53e49b5c800632b4104d9411a611b6a1e65f67a617d531a94dadfb8343cde8da0f7690d00584af5d9d147a0918c3a5605591e3137e0c9e11ce49aa7c6e00d68ae742761bf01e6f55431324b3d7c7e484edffd5f8ffe007f0df84dc2b736f12938a8fe1ebf22fcc9467f5e6c60032cb8ef432745bad61a5c6e1301c532febac16a5c4270b4136112ab29aed68a057caf9f7de81424b9658a962ca7f24e4f121c60ba7bcab221613c52cfb376ef131476643a5f18a196328f8a2975f58fa1741c1364e1be83adbaa08c7d5070efb6ee642b6c3cba8b822bbb59984d6301b87b9f8d00c4fa5c6837c47d89eab81279e959109a0a62b363e18d26615a65cb842fe0e873c1e4efee36bfd53a230f9da45832b765796285cdb2e885867e901544d0ca458a5fb09571eeafd694dfaea4641946a37f0327512f2a2b6e1957457668d839fdec45f2baa413a2cbdc699b5ebd6f40e1029ef09ba92308abc5c85b4464b564d395a9a38a64fba0615d9baf43fa187efcc119b29f795b5f125b617398d8eec8bcb72afe04bbe421636735f0da6d616c48f1891f275a65f98e079c440754cf385e6d635031d65781b75613dc81fe5bc0cf2f82f17a4e577afb6789c4209909852ee43b08c4caff045fbc9f28c29abee2b03dfc8be02d82bb890fdaec0a18fc17a639beebe5a04d6d9b64954a9526cb2ec64ee81793a8906d5283ca7eaf802e6234106764785a300b76d072a81b2ed40e0cd3e0e057c3bbc39290e1bf7cb36b8d076935f232b28c4001aab3235add980b8d772e04ef26300ba77480814ed195de5dbd223bf3443ac04f0311d67128cbee1974db3d77c9c2120c41de2575e13b57ed8145acee686c54a29acfde5a25a52544fa1c3500917988666f7888714e8df6c70afa13d91130e93069a0ff9aa63925650d0a57746eae3326c911af9b9373ce62b0ffa1326faf1d51dc1ede6e579beec9b57b1be6d93283cd667e111608961a5908bf4d0ca984a83570f76ba907ab2ad636f3e5aa54219d2ae0dc069b02801d38c9981989d4bcac2ee01472740ac1dc0510d540c5f40d3a1c02ac382c64d5feaeb21b8d69b771c29080ba12281b13bcd9d2b8986c79824a57e998384307612ff8c3f3b9ad898189022531f9ed6f87a7277576941b438223174e7f6d833a0d1a2fabcc6bf56ea4cd5ec936f215bcdaccd399fc7759f3d26fc751d0349be7ba0c80cdc19784cc066d6bd50577099db957e5b1df601b7a46fd2da443f9fbcd644a3aea830e73031a402cd625bbbd873acd1f60eb237d282f4287d8a44e9384bd67b0419dbfb111560b0b631f138c130033756b1d71975eb47f8be9fde57560b35ab932ec15b0246307e89a929b7d635872f4822495e84bf4ece0f8756a55a510bf50f93407b8dae6e2c45de3443bb6b855ddb3e113077fe0dee4e5c4e90e99e958945ff0d683c0e6db38456ab60a58279a028cbe235b2068c4d006ae49a022d82218b29059aae1078b9e8e6f098b74f0583b0ee481ea557eac05d178d40a4a149eca3e7b5b87df74cc366b49330d64ad418ea463f40739ea7fd21d8e6ce57be0537a58275771a164c89f7682b45745515cb690247f02d25de36cc968901d0627133b140a3da18b89aab35d2d5e94bd0755ce680fd94371c8cd78656176ad621133269d210e4e81d760e03ee010be740d1902ee0b6e20e93300ed9eb0c0c48136cb64c5034b35e39c360cdd161028557f2ab1c45052becb4ab53560f8e1f7f92100d4e853d1930e651aed04fc214c461d3066e780f57315d424acb69b12ab1229846662e2e6be1d0595a125117fd57a9428779d15bff179bb79e2fb8811c9be0c1dabad952b9fd1220629d7590a2ca4725fc6475dfb7a1755744a60018e1c5dc7f3705868ccaaced38a728df4f23bf046a51947bfe2347053abbf658a9262d396264b00bb290d1eac3ba6aa4f0ad2457d626f89d277e8b0949f617be074a0bc87d885bb70abf68388c24e5e31c01d1b002c81a3d254317640bf21bbae6b33070eec05cc1de85be3fe97bc3cd2b1c406ad7e243fc9c2177db585c6a5e7902b1e3cf6c245798411081ff27a994238a5fa91433c3a62c72ed6b1abac032be34cb764e5c0d42ee3f98ebed2b5f044d3c1265fadd224ca657b89f15eede30820e50b67ba44a3e007bc90c6885f145b69943e09c9ef3277b042b57b9a0676fd38f0946b166119d87bb0701084d4989a6427f4505723724d8115216ba9b5795e54e8e7e50be29741e875d3344651dd8f835a6c43a0e13eeb3fb87c464980d188992979d4cdcff29e17509e7b016edce2026d20a791109e5a30ae14a6911223910b1038315466e75ca0d8a4b2eac2a7ee36ce0ac3a79178688278f69c0cac7561829cfe4151efcab077f3b2ef224d1bcd948a3149a3f5a97ecb2ed57a78bddb83d90a27efc3434c0c7afa0e9f78aa85a11e6b27bf5ed83f74fdcaf3502742cd85fa7c554601e42bcaef9b21652beef9ddfb7acca3e6e1e660bccd13a84e7b5a14ca9b3fe65459c234a17cd1fe02e7faffe12d5e5331230fc77231c376c817d31c684463e4a327dacd52ab281068da3ccaff346e6f3cb5a7ef69a156eea5960cd0b4d2ccf8ee7a319c84f42d88aba50e96be98fd9c0c92a670723294e5fd9359ce92b70918161c6020c3c9813b27c7924933af8f88e563e0bb882424d053b2cf93b730d299909d44b9dc093fbcc4bab8518dadc60075e8832dfa75198de8d8e918b95f2822218fa1d08145795b0520581fdaa4ad41d9cce6d053e5add4ba13820c02826609f158306a6794a26764ed313b06c4f30bd1f8308fce8ec18b3349436111a46d2bd3f0ed12926ff38fd860508c9a3ce5ed21fb9a2281f39379ca477b91fad9ba928127ab57883ea66902de827110b6b00528871dd13473b85b51f03f4f948d36ad3f2f00c51e4b46c2f9bb2ed6457e042d0081c33eaab196dd957c428afaac33c309d3adb03e600d914cdbbf0c7305bafcabeb31c0b58610e982e594b11addd18002b01e3f3652227ad1b07cbab8ad7b288ff50fd9f29813eea82f896997c6520c1af1fab90b4206fa426fd5e4252c69f5e80d6fc59c776ac4858d33646052d9c93186f8622dff2713b3d916212d37ec24a1382b28374c9f3ebe1cbfaa563b65cb0efea0236325e8ce1d9a365f9a5d823753cc3193876d666e0bfc1e0b0ea3dc90a26d649a62f32d45fbea7cca81566a6f1e34a53fac5d45d5e514abfed017c45d079ed16a589c2059c5b150fa1f65fb5510868465948ddfc8d8d6e1b39a629cffe4946b7008f2d8906e2ba18667896cc99e7ad1a631240ee53cd7b542ed5b9cb884dad5c77648728ad3e3eaf427299100c6943d17925ad23c8208685453d12d81a20cf43adbe5dd18e76847019cde505395c5438e7a7566009e4c316f52d10d48740c41f56f2ef9431ef6b2bd102a175e85d364b1b99469ca99d1a497cb0e1f9d7394fe79d904fe31b7c8f8aa758c642911a3ae4774e4a90f1be7b2de90c956bf2ad0636aa879e0541d8577b633b10e6fa5a2702cc1732ac11bbe8d1f8bb82c526492475bdf0ab3e0c22c98d686ea589e7223f48fded550663097d8ceafecbf509e3842d321126d645d896d18a61258db3fc8eae05e6a71585bd902274fbedbaa48c1693ef8444413a482267d927c42e7b95d535603771a5009258f7a27099a38daed64f09d5681ee58ae1ac7cf26e630d1a29b6081963c731738a31f1b95448d0a50b743d3f05aa7a555027de4dfdac9bf3f230179df473d029466bb2533798828ea7547da5950878ad1383fa6a653fb3225dfaeacad647f0b4af5cb4aa013e7528bd6b92a706265efc916852a93dd3d4baad131c61deebd3193c4b10b5ef7585a30ad9c4344e9817f7525bf762c94e08e378fdb043daceeaeff0b9164404eeca3c63710f0ef38c08ffb50263be83cf27d8252ba800302162f54694735c8e2a08959293e23452e27f1b9a841c2082fbd6d1546274ed0d9349e9d9094852d3a1ff25d8fe982baf84049fd9d53066823fba088a2f4400df58025d7e68e8d27059fdc383e49b857bdc09bb87a97ef6d400d817c899b73c661ee5f0b2b1ebb3f8d71a672ee88d86c1d4cce5c3455eed60f95c1cbe2c1d9ee780404629738f99dfb5425265521ffd21097460746a2d41cd1301a47be7e30145da5612d40736ce2fc6da638fc9add344c86e21e01571a978c890946b352e92180c0e5d2a370c422a0c14fcacbf34c95a7dea23356568805b48c76c519eebba7c314c696f01315769cd02782ca17076a569e6f7e091f8f85c88a71d6e7ce33a3b6b412411186474c009e0e444b12bafaf94d499dd12938e697dfbec5d78005db0052010e3d2ae0d4f02121ad395e76d5275e70b0b0caa36761f109f935ac1d6b1b6fcd4c0f636b8609e2246d70f4187e3cd99b9d273c325fdb73a957e0d0884b59a999b9825e579518e41e39efb3fc13d40a3ab0586b078feb97ef71f78ec3b15f37deb88ea5858501c94426e3e60b90ff4ddb9c8ec8523ea8ad168406bcc861afb570e2a2820f44ed35ec8e7f14877496b5c438bb4517a6bd0237ffc4d245ff520398997f167ea9c966529a6f80ceeda1864296efb68a3166fa0fb90cb54a4e8ede945924206d02eb77390603ed1c464b896d2c17927721ff209eaee7bf687d53994c95d16317d1beef4510155c04deba544457fd22f7a0b1b9f93212ed0a4b6121f18528eb04909456fe6a32c4944ea9fdcf3ff681852087647a73aba05f76f22fe5d0ae7a52d475d35968a496a48536e8d9dfed213545e83e209786a8b16cfe51c4d894ea0aa76cf1e0bbdbb21bdd2ae65f786c941096dca01681d69413b3db9104585d773e67d02ca585245951e8c47067860e3344f1820849a77b73090cf9f796de9c48cf1c4f3f85e39138e7cfd3cf0ce939035bad56994593cb9168a2863863ded45eed688031490c37bb54a3aa2067d47821bbe80783f615d293fe932d695c9c746c6681b2cfb1c2a4ce991ea0b0e9242357bff4d2a41dedab7ca0544f43260d9aab56be591faa46e00cb01db157b5412defc2a7dede14c115e619d6e1ab1ee1cef131b7616e70e4f6b76c29995b7201b8c242528877fb078f646547148e1c1a7a8c3ee7c67c6994b0c2774dafe0619b161276fe3993356e3a4d63176c2001c14afac5511ca074879897776fa4b9a182c25776e7c1a44a2a08b081f38d9b039c7f9512845904db53da18e81c20eaf1893a224bf80c58d4d83cffdb68655a70c1475feb4fc5da43c92057835542c756b8f749fb80a197170a836b5b08e201332dcb2924ad51105c3e872318eaefcb4815f93278bc02627e800cf899f274c4f27be7d9d71db2976f18bf38d7d965f610b3de4e331cf4832c70a6120a996924bd980a7d2cbef57c020667e3a8eb3c23e3900e81e93e1b9f589b5c4ea5ca28ef457eb660785f948aeaf82c35070a980600b4c382878a9a4103d7e789ea95b0648206a30b17099b850a7c92e00d62f9319780a6d4609fce4ea7c209cf800dfe9d7a293bed702a69436d7b4272d00f52acb4529cf9f2752d28bc5d6403a09711b9cc6b449abdce3b046ec141fbfd33de81f4f4e9d4865962d483a0c32108451237c651473c71ac771f9c687987eaba7ad69e1ab69b8990f583b5a1ce412353fa7ddafd6e49fad144b9448a1c99f3f4b5b105a139bb3d3857e808c58abe5e0f681a2d45136829e4dfb4eec06f26fd7386b052a2fe2c4a23bb03a5a67fe0f06bf1589ae02ff75ba927de3fe7e5564f7c450fb4b0c0f07225d01ac49fb5cc2b75cc5c834e94b5edceef9458988114a25d09cd081b1ba442ca94319a8c68172e10125ab6b5e9441d837c04d8759c2da331e9775c075bf7eb1a8b89e48aadb6e3e752f9a38103c9465aa7839f03ce51bc9ade569b953b59a67c5b02f37eded1a74e95abc6920cc97d8d09c3fae3f095c510cb3321f6d21795cb8e8bd00171dd2a965359d8ad3dace43d123f2ac9ad668a663a76c3ed4ba28e12390ad399676e12b6ab81c99d73010502796102158b6a66591657fd2327ce416fae8328f40fd53b90b7c33a1b32b2724b90a603f005dc2e05482f004fb4a81628c0d1f06e98b2895011482a174fcaa840a7fc42af30e384e17ec1181f91caa5c74ef7ddafba6a3897e865ec7f8303d5daa259e9e4bb8f87467cfee78aeb7833a197e94f50a37ddbea3eb2acb7fa23ce81a1fe760eb4d79f500632a3a2e660b96d7c8c2b7e3a03838ddc5087dc0bbf2090d730582651f5166d6bc542a0cc5df5184a61b15cc08842f0ff15b60bee3b34697bdccaf51c1caf1a5845f0eded12c2d38be050307a8960177409e3c50c3b716c267237e4e8d0337bd73b74aff6bedabf1b44a3e0bbfbfef1e60c0921c5faa1176d913463cfad4e4ab12613a75991f87d05f3359903c5d75be7860ad4486298738ff841d39d0b6afbb47fa55064998bc658664eaac79caa132041b34772aacfb19451d94142b35f5ce0c7981cbdef31cb6da8ee76bcc76aa835defd739fb88206e865ad5f578bc06fd2dde97c26a039612a339368e95911d19f37825b4e3d3c2b65b703f072b35c773786bd812d061ef7e08c82190a1e15c73c22f5c5a33d2ac79c69b56b3e9b49b5b1de5ed15cd7d048506b2b91625ab975d7951943f35c57a7361aaf61dbb914bdc5bbca71f42f84198176c3a45dc96fd306c662fa0da14456bae9623f0005d51b8c8d18bdc9c93793db5d0ffb865ee3227ffd5fa830c470a44d9e870dad5f9e11906725b0cd7167a6bed078e6ddda6afef99ef18be8d5f4238829d5e8528b5f27edde89df6d016e167887b82c772e7bf73d5e39ff2376cfadb58b27f55f847300eb02ed860c9d114e9d88ed510c0d8ca347dfe28ef03d070fd306635c84c5e122b8dbb367aaa31d5862260cb6e7a907a340cab0ae7758031400a1ce98e1b597a6798bab209b15532cf251c9f4c45c4d5cb3169e35239d541179cd94d0c57ed7b7500b5bd2bb56c99e58b46e85cf482a754fbe522e9693beb0eb1e3970a42e2d77a57ddd535f1239ba75b88db1430a94272835fedbb72d557e7aa81100936c8a11d37c27da5b3e53e0dea2f97c6bc6427893376e8e8256ff69297ef265adb9f49c4a1274b633cd20cbf65d975b524720aa1489055daf785a2ecfee82ff800f492eac8ab9f1773ade8fbefce64e6edd175db41d551a1091387d2579c0cbaf0ab08073ee58083f4e70b11666236795345db53b01ab7573f481f3b3d4c1231e3e8c23e678725123c61f386d44522111951d4579165d38481564eeb3baf3aaa65517a9a82d42ccd69c6b3212115f709f9b1b2e0b8dd1464bb498544b00e433f99ad3b0085261bfa569ed87e9f10d25dc88f9238267746e7e75cb50687a7e4cfbca0cfc632208f51fea5cda31aa4defc5bc1d2903ffadbe20810dcd48ab3201993503ed1ca3fb7f969954af81ffd99c3efb7f44f319c386779046d4b9fe5404b87d6f881761f223cce8586953b5cb608c32671127648b0b3811ba27a16a5cdc437e3cc8baa7ba45a6642e902e2aeca15bd967608ae9f200842565079a1ba2a0d27817a7db4b1d13c75ae252bc8649aabe204af114c127587a5746604977ee051d09ffb8f1be603030bf6a0b9044e791fccb8eefd51c0855e8af3a4536d956f8dd28bbfcad725d8d28e8ab40fce7ccff87c14d0bca2ca2c9b25ecd89f33449429b290ed9f68a0ee640d88fba62ba9f0628bd567a63f61c8c96ba7903572ca52f4520bbb7c6dc5b2a6152de6d8063c10d1ebfbc9ab76ff2d514f0adc6a4402bfcdd29b8dc0096e4fc41c079f117e6af2537c31c79b7a014dd85334a8357b7dc76eff472c5bdda2ed3f84de31e70370914c232164c8aad99a7b33fbc45d6e5b4f57be2d0ab87f3a33f81d97497825796ccd6b0ac6d6580f2578b9b7f02d0c070b3d071545aebb325a2db8f9509a1196564da27034f27e14a75bc3a2a3479a29cf1a3d8dfb63b1c3d7373ed6e42f4e97fa971c84476770108675417d34861e4dbc90cb5fec74a933435ac59b864f8056dfca2bf22723bdc221a1c9d1bdadc265fa9025414c0e4ca7628547d053efea6a18fc051a900ec0227a0016bc42f345b19ec9d4efdeb6f9b54001663d2a0baee06fd2fde8d091a3ff0bf485df0a9247cdda216aa12fe6a5b7557dd7c57914291bc749bfb0fb1b2ce4c059407975e6cc9ef97b14d7f249a243fd06cf03894b9d3c2cf8ffc38697e6d6c5a675dd088844155cee76432685551c7eebcdf199a5b3852527abbf387220e29c37934a087de82224f6d5e41c5bb6f405eedea8f3f795eb6fc900422ac98c5df6510290b8e0ee8df579f9d17aa9169e34862f11ac0be8257f83064050af4f8857c87261e0054990635ef2813c71e394e8ef85e57d84dea50d607c993e1483d396e53fdb43b84a10d12b4fa2229d119cee5370e41059107b605529ac22d8c7590e8e208db6651887ad5ccb99b23f33b582cd7b0c7cc244c9f4f66f59f62d7c2ea230a0e2838660b11bf9e8a0b992a1ab3e6e3d07ec19a7a926a72f83e5f133003cfcce522e02dc6b9a9280a6924e02dbf8dc0a065a528e33d1fa28979b4f106df1346936ed331dc1b3a44e66bc83cee667cf45a32d8020b6868ce46c02c941767cb591f910033e457fbc5c8f9be0f34ac05c61402864f0b41f80f54c9082055f93974e3ad4c36acc09dd482d3ebcbbf38f6910ecea94cdd7b8cede1bf226cabe6cda3f92235f253e53847afe8a704487a914f9b0c5ed5fb8ab6a491c946faf7bacb80aa459c57cfa6838d607de7ec4b4961e4920852292b06bb52a526d02c26ebd3573c9d619863841d55a9ba04852ee50750f9a022cb61de350bdf5eedd1839d4a6e5a191b20bc8a7be8a7e59e648a49ac7c805f07ecc542ea952bef81823d6ed044181dbb58b35067767bd1f75375fe594a4cbb2e3ade56b31999b04099c8c4aaef0f57d6366d1845e4e59555fc05925a1cf632c21f088290243959554f957af474e59e218018385de524421aef99e6b789ae8e899c8faeed4739eec1d512ea10f60c47fb56f1a25d325040a283fa2a145faab13b87d621ec1cdb7439bfc8693c3b1d94b1f429dc3fe215b268b2ffe5aa5553baac27867203380dbed9c92c34003e039804872e6dc89ca6abcf58801622a35f3468f8d9ed397fec868ade9b606176b27ea0134f90e6f1bd1e882b0d447c1ae183b72fcdd98f9599133fbc54f56ff20c24fb0389ebd976285812081b2f3daa0149399b268cfef3b1f83ba37014831ca3aeae1a90e704071bd66fe4a9b16f5cf8acb4b0be763784b4d2bfdc247b69454c177886208434c3174bf273068d9d311edf7f2d5dc73b6110636b4772d06a3a70ba33ff3bf85b5c4d241977add857cdbfc34111d9d8f55bad021ccedc48529d8c1f9fe547d534527d5074c7b83e0f3a1789b69030dabab8e494d3c7c5e8985637268711dd1cf53235af4a8524ccbffd6e462814ba639688121e1fb608726426797af92a328467208fab224cf10f653bd7ba5a1b96df51190f521fd4ec951e8958028ed42d08922bf73d404aa121920d938d98af5213e0ffa43e74e897e334a2b809cce7dbcb848634aef93cb213826676069f9b422e3452792a4950b09db3bd592c6460c6a926dd3ac59c3c9733ef706de4bc553db656f73a0eebd4ae61c20ea077fc3ad3904c99ce792f56332b58d9246f7ecd47430f435154cdd7b96df29d9fe30844bd651b198d5b4ee4f638ba1a11e96f09975e0f915456f5a8f3be1173ce8426cb15baa00a2ba0c1a3f93b1c918dbb5aa86e070fcdee2156c834991fab50a42bc0e3e7fc59dc79a040ad0deec772da0cb344c3eb47b47396e83a71adec7be5e033923feaf32dcfde56a2e5f1f4e8a7278f83e182215fae90427d2ee01a50e2e1195ac9cd424a7b4eaaba4bf27de1c4e3ac9af924c69f2699793444532ddedb8143e37141fc3e6481819b720ec973af1b4625720d9ca70cbb49023c907e6f109a5471c78b39b35c63fba31be3b5b95be91c4e3550acb6fda90799b3d5723741ddc7a95e8c8961b8cdcec481335351e59a7153e20788186c7894f970a5ac5232d70ccaf2ee0579e97d43d671101b3861a205af3415d8b814a5c498293c7b525598ada9986fd938707b611f0d029b6926ce5bc70e66072def42fc448f269a5166cf1cbc5e7a8dabc4c8c3a23db8781ad07f18e1cf808890ea3f98cd9abdc0d4659d19331413d70cb6b1d21adaee947ae8062199c3bdb87f646b0aae082c564eaf18e722bf644842fe11656a0256bd1548e757cb31b06427f0de782f72e78c9a8e14c1c88b11c0cbcde91d089c74a0cbc03cf46c0592ae96fff3b053ffea4cf7177fbc568d23ee2c045647ae059d3600ed39bd6f940f85dec8af709303ce35f37e03c5f084ba6a336add26affdc9dc8f9251c57e2c184f880a52209431dcc8825ed322d35fabc2cd8e05eb48f3854fd4e28820af444a5a1559ef7df6168ab8ab415d220cf8cb6d81a88cae6440f6b500059331b57256ca6feb797dc6e7e49d997c34762f8328b60e81f5917ac50c99d7070445633be29b7461e9b053be09f71984591b0321fa114ab412134cbb8e061b672e36b55f42f260df409b4d3c12b4e503a877eb6812f8f06311c858de548aa63b45fb2bec629bad5630ec1f4b3c83f8a2444e920bb2fe24cf4a89631374914c226eadac61e831a23397a5d8b2abebeb1d6f492ce5a3d01ece2b8ea03e1c3e264bc110f360092c3b7e518d3e848eff1baad98ab534963c570461ac99bacf9d295a3a39a4886dac4842c8c5cf581222ab5e6925bc0fd514dfd08049db600d81f296c392a3bae0dea2cabfef648fb143d68b8416f6e5332475d97e70e7afbf8ebaa4efa0625b090dd07d7eb4d4adfcd445013011549a9ee782abb46542ef726f409583c19e45536a4a138de30f253d256962d22d4f9a282d6f66b6e29dc379d05ce4b752e3b3701aabdc060c20218cbe0ffb726c24637de0b8b1de61b91c4561db47c7fdd65f0c3a86490651af516757231c5d15c5bf29e84fc84f232698a63fd2149d26d0b3166e385fd0e4a1ebf79a6bd0a7510e9f0772302930822cc401cbe29e31596037f3f1ef14776c31455df5d8cf37c80dbffe74b50424505a66f6aa47fad49fc223b867e12f40fd149f7b2d13808041f8ced476ba9e2c3441c1a9c76cc5997600473cf5eaced17fb788f7f09c8cdc32c48d70c4017a26dd81497da58f28423311883ca65ebd5bafedb6d69d069523d49ff1791412e9263adf062dce80fb913359e95198082febb99627e74740ca5a24703698f29eaa1298a5d333e9c44ca92557c84820c4f82f0a84a73f94ce79e74c57210c3aeb5ce1a9206d4ec6a06e57a9e90e5a86128d4a453d161c710959686e9ffb991369b26b9e04ced62b45ad0ceb08516319dbfbe5c02d86e07a8beb269ca7cd686e73587112cc183c214c15396471bbc58d2209d7a29a9cb44ff016beb199c49ec1673cb31cd1e5036d75fc84a39a840a0e3fe39896c7ca345261595e69234ea217b16d0bf18b5dd52b90e03fe2775ca68cd6e7f1ee79b1d2c8fc45138969bf1b4d4c97a1c95be91e728613a84d2d478bb7004df09409bf94cb237a8f6f56e8dd615199b30ddd7f00814f2dc3d5622fc008de40fa508d7f503e3e89de32e860df5d0f198b069754f9f6237df117b931d4698508dd8824bad6ce905b3acfddf78b7db016fe8630c6cf90cfe92ebe87ac39825daa313e576faa8ba6e0feb6b1de8b074ad0bbc8d6c4de72b221e66e8bd48bed6d111ff88cb00a41d90ca0effa61fb57641582254a02e67baeca75e77ae2a2ae2c45eec5ffed0661ca8c7dc126b97815047be9d88bbde2e75faeeaac706948b8d1d643dc092ae7192ec1d6185e079803c916e9053e3e791676a202ac239033d21e306b36a99a49e3631acd25fa55804e194855e9d9d90becb8be633bf2ed51cbf06ef973275c6ec954a1f60777da08704f0a411c46292fa99917e16125ef6451296f465ad1dddfa1e3195d608c96b092d4120759d48c96694a42b1ce1be08221e6cf98b2fa0d36b00a8f0e23e11c27a07899559256bf29a562089b7b3e323e27b3cd265e60fac438947e49b22280798dd41773667d2719ed9c6f22e9c59acd12b10c69afbdc1f59964cc38332ec940d6eedb34aeba38077279aa4558c576ac1cd6f38eb5821488121db20f8ec42758a270209c7d45fb7780375b745765c342e9fb4d98fb4383e3368b9dd8319cd239858634211f99768df546eb6d16ba8c698d256d715b149d5193f0c487078c0a6c41b8f9f53d668914f0ec9a3eeb52b40525b08f40cd39bcb7a097d6cab8d82db9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
