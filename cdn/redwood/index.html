<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63050d48b365a287b821474c204a562c85a0c0ccd9bcc06d325ae78ad38e108a21b502df354f90b3e621d58851e81c5ad9e564d25731ab32c10461ec1e6dbcc1b3bb16c7482e351fab6496141279937d9eac323c3d1bb5cfd8fead365bbd4b2b211026a7b1e07400c38c477beb6ea062b51982449358c06fed2cafb7d954cda070e03925f539ffc1436492d58c93ec0f38c228e7af9df029493b39330aef07c39c6d4227c30ae6c17d7828ae15c1aaf5c48208e18ceb180918b94f3ec7a72b41fc23ef1895aff39115b31048451370276c2441ab45ffe1cfffeb1b4cbca99d583859ac61f08af5a3b1957e722c58c352ea8b5f0d9c3e29581ac8d0d316d6faf2616f8e2916050fe43679c0920adc6c3a8995b293e6d16af8e3037db49e7b09c63433a0eaccdeac350ca120b7d008cab50324ad8dae095edc6ceeb4283b8c173e731a76ea17fca8a9d1ff8b8915fa062c9d3a28a12bf943ad4613a0861824f39ddb8b6e7c431d6d66edd6273162c743d75817a48307206f0db7462f3eacdca14423967fac84d18c4d4e5c8094975167a840324ecd73d320e56bab12e86476fc3c767e955797bf2fe9030de937c654b8d0ff700d6cc4754d4ddeee7426d296afe139f1953076a2a97ece462f8bdbf153a3169fcaeec6674bcb68d5f582e1dbe662fae9be535830624bfbd3d4dc08db32967945a2f0c79fe8c2392da3389d5421c6eb1b86ffcad8e807412e6a6b90cf86d0809475ab4a27440fe665bb9493421384460ac9b02a9a7224da5685749da72af9b8b3bed70f9498f616e918e2deb2f3805efe6dbc3e159cb5273a00e55de27fdaa7b2508ee9cc49a66d65bb426118d2ff14d10e0ba853916885ba8dd4fb32941d6f7944929dddb66c63552381f95c2e8a793b1c2d1c5254dce9af658504db1571b6be93e222cb31e1fd8c43ab05b1d2291b69380544eb436a2ecf238bde8aa6f486c18240df66131d6c1fc13e5af3009b69bbb61713d163c226b77eef40ddeee37c660da0db3578e134ac0df0580fa87e11959f6458b20a834de54d38bee78922984851f58aa59bdf9022b20d0eb7ffc5c6ba39d18f82b96699ed5aaea876b7c95eb731fc3f71feef112f79d1f9d9931d9ba66bfa8f3b71f1ddcece453ec7f59f33a31f93ae68471b46a7119377b4197d7f4981c72f8956afcd472f9d914df25cfda5e11d38c9b9858e4c9b5d083215db1c5f1e7786a54b2381eab5e1e974d052483ebaa1aeaea8f7627f4b22f3b9bdec2a959fe1f5fea09637b5aa6eb36b0c5caf0187ebda5873d255dcec09b98c6d8f2b1ea28eb64cfe88325547e5550b0868548e7917d310fc4c472815fa15ba5937972b7d21b2ae864c0d2e059d2fc061f6af7b585e1e4d9115693c54f02b621da2d55740bd08297f6e3fec31d774039c5513d70de960ebf9d2a26bea9a22220ae22ee53d94f368ea7bf4afefcf25b36723d85794ee05b06accbb991a6d6bcc0ea5ad6e87b13644d26ca118112abfd0956b5134d322553d9fc6df1c0a1db490570a8962e6a1836a9a84eb2283c16d7ccd156902498c999f1c63ad270a9325d04e02d7dec1d4d88ae1ad094dffc0a72b550f983adb361ac015ec2a3a8e15af47d588cb6507264fa1675dd8b8b184e596ad66965b63eb30177b60b27aef7180173bca641a8f663c90b5494eece6766a020ed228fc242c9df3280a685a9e4c606408e180de5bab7432d81a422b1f7158a41e7a3ad2fa492c36edd1a03e06e573af78b0a2ed8c87a88712a2ed0f8d5f2b3f674fbe93755e438ebe6b631a16811e318e9f75643c35644f930d5bb6d10df397ec513f7d713c633069ae2253e9172b90b63dca9115f48fb6922e3fbe74ae6f60dc8f819ae9e7bc19b4a0614b2e2e86c025cf69f08b607cd5d102d429abbafadb057a60268a40e00ffbe575918f8f7e494c873c9b6f951f91c9a3725ad17b76b4223973c4d09f7286dd952c1969c5a5b780c57f702f792e35992757066014f7ef6f5065237ec47e4adac4b932d5b3e60b09351d8e0b8c621c080e3e3a8007b712d73ef851323337ecf0a3f4c003a2c0158929de6fb302721099b7e7774faa45d18a19a9501cee678453d1fe2ea35b6b52b11f42eb1527af1d6600ba9f4e19883406265acdf9440dd8206439c5225ae53f555f93e819cb521c15146e4a37c4e552201db83d907bf7c5d2bf48c5ceda21355bcadbf3d2070c114e9e6bd7f43625faabfb28b6760814ffd0005dbba43b65361ca6f4bb9919de827f8e561c236fd78a4dda31d1083346636f3b97752552525ddae016156307392e5c94949d823d180e17d681295bcf4b2db70f06c8c62c4fddf742e44233682b5dcfeec27eb6cf25c3a160b5e76b50f2cfa5f528569dfdbc2f8bf1d702b30d21bedeca305ec25c0972f74b65b031332bf7121fed220213a5b8e922af6911c3a9e74e3651c5befed5e045888c43624aa4da766240b93932a6de7097f1190fb9de567061f259b30fd4af13c23eae685e519999b4aec366f624d1db1aa0965c9ee7caf298305f988e2dc56f237157721b66663c0f8ea69686498306677500b56158741a3d1be8222856fa6d8c601bacea51df3ee03a186a7d319a4dda70cc774c0c152d870a84c787a49994c71792573184f0da50aa9c00a73aa26cd9b308fc99662b928c5bc6c43fbfc4076155a1c81dd6ddef0b28f4ab77bd69398251a1a33bf7e5a38e0e9e488b16c942221e1d65e642fd37cbd57a56334ad2143cf1db1a3a9df24589f554dd35bd693026dc15f1efb8dab9b6aa673c1f4601293ccc53f784be3633e5ad13f7b7a93c383bd833f1cc014ca031c285547f44170c53a372ee199acd12b6943608a03967fcf47173248e7115d75ed91684dc224ebd901a122993cb75ce6bf193f62d4f5f4046b6f898fad518dc15b8d1b94260b00a534f03790852bc7b954ff912c12df34113c27351fa1f027c38746e54f9da67668fe0e29b7ca0757e0e5417dd0e67812d244258c2680d5e6fe011f9aabf5cb6beaaf39f82b1f9eb625b837c45ad53fab9f5b6f5549a4131ce67ce0630d0f0d703cf778dfcd13add0b8610a420bacff20b8ec64ad491f570c51580a324572955fccab771459d60b7a9b753f1647aeb9bd74622a6fad79f1c2c8c536d82e72051f1057aeddaa1b8c640bce0d8fff7be2783074396a4dcf633ee8bc7a94ed41b2aece949da254262a6036f559bbcf275e967f293e4558a2202a7a90b8da79fddd166ce4f26fea08e7145cc28fc029d2ab4a912536fd44201c6479ef3487e9c3c8f5370e2b951a405d01014682977e8591f43b887a0a5da77fa1fb0d56a259ab859dea4c55a079505a7275636e50fe012539f3d3fa308a253bae736962f60cf916a0c71b93350b0ca9d82a9c5ef68bfa46c1657d15b529d6c22e60c74e4e616d5a37e99e388915c21cc800cb5d36036111000e1c56036078e2116b40e2283bc3953d8d24c46861e2e9dd875d1528a292261fdad83ba60883667e16bfcf398eb3bb41925367a88abc79eced4bec46c6e155ae59041cde7cb51fc1fd7474d0cc95a7d57b196d664329073a5beb9a5a12b7de0a9c853ca6baf74326898b3687277c6248dcd88e06d002b7a3df958e572a658bd3bde569a055596da269059c8419d58ac035de561743856242067be26fdb43a3251fb99ce21542e30b74d626f5a0510e3e79d288037d8944983bb6cd117a8093f33ce7aecc2ef64d8ed0247365c287431f917e60e7cde7afb8268090eafa202245512fce02ce616673979978096b5067a0b24414e86a83006ea74254f0449def54804239b61df1fb8d2e66c186dc612a805b6030d8a7a8ae8bc8c84ecb4e7692d15f3be2f58623fb362880dad8a3170289a7ca30cbb55b45f2f6445f0f2a5e55f1b1dfad4624df174ce7d9a67a4b32b3447d0bbaf622a957d9123299315fd92c884513f39cb7429a0b47178b0c2c52992a14be353f828e32feeb1529f1f7486ea413a6a9bb490499be3a263e011cfc9285016bef971d194cd5ec1abb84b36e0c49523e0d5799b89db8bb83eefc210808875fd19be9012b40b318b4985b6b2649a3aa1e6044e8ccfaa682b399a1385acab86422258a8bd5f788f3bfc7513de68b94b70010a4ebdd2f4676628293865b303e8cf159f7309d9c47abaded937e106ad1a278eebb992059cecac2588174d6c41281b1ab42cf21b1421fa4354431e66dfefc1bf6a7741d56d287f5e961d4310641dce929e4a1439ae1219d92a400edd3457fdc553e0c8aee7981f1b039dd7cd3e2729945bb15f422fc96a8d8e0ffccff7fdfc416ab9dbe626f559c31c5a74fd289583a8ce1e1fa658fee55e37b14d7ce5a5cd8a65b441aa7c4d2ce8f872f717149b64d2e9d28b4f4240def2b8cd3acd8e40b1efa5a9c4ad0ea777f0007c39d6cb43dc9b821582db2b3bb9cb858b9bdf3c9d6ad8dd1e095080795abfae080b8726340b80445e2617bb10456ad9a3d91852b427ddcc94321efd6a97ed2483caf52c34516c14dd9a304d4cd98ae82a9315d2acdda2e62a00175b38c9d240ed50ca440d5657100301622e49f8202eaa0250d64853bb7f848311258bc6b76984523581d62e150a7877cd4692541ef79c68d65575692d2bab7c00f35edddd473319e2ebeef02ea0aa823b4ebde700607e45269804af7ec306783c5bc2b0e474d2633b8fc07bdc2fdccae43cf1d7eeb35841de29f9cab2bd53e336f2c11a36576facfe7b7c43288b6fd6652fd295ef935403e77691cbeac7a01591ecc1fa9d8d39217a25e5617628f7fa9133ad5c6e923377ae7318c804977629bd7c8db5bdfaae99546da9b19888db9c8afdcd4ba5b27f2ca632ac9f9a0f603cf79e8d19015fd248996635bf29d804c03f5ae213f52b93a1c0bef3797f4bd75a2dd3dfdd95e4b7bdae6f086368b0aa6ebace7aac6838d95e1531822cf4ca70abc919025eefc83b46f2c5470012b2384715219d326a376ea3d1f35cc68922d4f8e6c4e230505c77ac2f49a975f269af7792a25724d01628faac4f47c0d003c0d6eca06855fcb599a6656744b7d07169386b10213e3111a20872787d5455d8b1b9949456d9556e244e4ba1e47d23d0863cf9c1d0bffde078033399de083794c6298ea29d7da2fbe118f6f75923d8e4509e11d3eb34d1676e46e9f11e0dded78175eb0f12cb2fc7940b06249ca089956f495670814e5525b47bc1a82fd4e9bf5f7dfc7d47edfa7863524614c97c12fc53c81b8a5b13033d64ffb8d7247452bc926d531e37debf3c33342ed6e2fdd835f3959aa769f66828a3ffbf896dd17542cbb4d5185103d07972bbc5992a35125409908a88dd2534f976133b4dd3074991824807796de19218d635d030b6969b827acc5fa62247df56481b680d6e284785a2dd0f2a74e92b91a4f023301de6d815843a6111f9cb962e771cf3a0f65408b861926cea56135ae5a85110eb586c1f5c69ae112f40bc349148c30b4bb60865e629136ae0231d2986fbf9974377f4fe17426a8479fee91790d6337f113d3a596f8a7a9ab4ef935e3f09a0e531ab76f7450103f2808d9c18143cd13f13ebbc60deaec6f8cad45bd6af7fe78ae89bef4cc27a95472502d842cf064548c52cc43f69f53f3f009272e1e4ac51a1fc6efd97c0f3bd87a6a1254ebfc93a123d041559c01eea50e8efa99a46e932705350624e356a8115e8ab4a84a84835d4b153dfef3f94a64ff683945b349df529c11372eaec0adf97c80578bec0075cb6bdaa4e94f91b3ef8e52882cd3abfa9000faf8b39d98105656880c04e1a2c4a61b86190ce5dc4d418f78df0f46ec5c2ab230bf51e4cbba7c08b997ae9fa8bcc4b9552350ebd5995fd1d8f169472ab17bfc4315980ea1b1391175d24085e1b6c8304bdb79825d001933957403e47c248e124be1d47080e1f2981edc69ed00d60010f2a2af06b436955c97961327a07d15e2dbbf61fbe82ef75af6fc502de6cb837694475f0c32d72b14688a421d29e734b40da36c837b716bed779f92afd0fc357818a832114afb5ea9f9c7f419cb5b57406fe91c107e2f6e1244d3ada5d83e01deed4bf743833b44b41e85fc9e158958158f6a80dbdbe924eebc762efc5e08f9c8f225cad141a5120fbbc6b2d59054fe09453643dbb12b1a82725e61bfb3843bdd7abbb5cfb46c667e79531a69e7cc12c04a18627fee7128fd716a535653964e18754cc816e49a80cee830f64801091dc60135e32f707bfd3d97435a2eefcbfb20a0823d9619c78d56a1ac60128b8e3312ff58d3ed6ebaea6778be170f03aeaf773387578ee58950c1ea89ab962bf4ab9b213fbeb99f0047560346d73fc1d6158e4d1fe4006c0a60dca17fb82f61d2816257597dd656d078644302f5cd4a91a44300edd02e842d22528cddbd34fc4a9447c0d84b49bb00881d49e0782241757b0c9fe09d73751ae985f64625e6912b2d4364d360cd30bb548580aba0cebfc27d3c7b7816c3d7d0cd98b3d3e0b1aa4d3cc79d1d62c3b8d66bdddb51513ddb29fbb03a7290016474ca690273aa24780fd4f60f35470bff04177cff4f88f22b27c032ad0294dec2a5092703b7701e7f4b9946145bf7feb4d67da68b6c267eec4b9eece968c0772b04e72eb2a430978703eb5d294e9092fed6feb085c8f412dc720e122ceda19799497c5730b698fb535353c272799d225d0542013cd19ae44c7a28a2da204981c2d2c4c0e9d21b45c95aeb2e1009cb22c4ad30437d2459dccfef54734cd054bd79fcb9699bde8afc080b6219e70abbb994665669b1f2b0757aa1cd8807193809d5987635e9632ec20381369799a09b3edb46c98701f85da90b044109be18cdc4dab6612f7590dff16f7235fc0905d10a862f16cbb9d8796db62734034ac6b381c5f60deaf8b41e5a5b07ce125bd107988be602fde4bdcd20c18eda3738037f3e5c1ec0fc52441ae2c3448bbfe38c72822fe8511305a10d729415931b164891e85253020d26493b8b516b8874c53e913db4daad65c3fa419ff6607477fad5816141650b4a582116b124d265d4774ee37017b452ea4586fb33d17d5e483c66c2699534d1af6ec723f7a034f7fee8563a839d036789f6254110444cf73996b9ef8d58d41b533ce5f2612cb47046f1df41c514775ae462a31d4be34eec925b588a063b5f6790be8646e18c7b804832c1b11671bf4f3987b179f87f817dc60a645a29b28f8bd829f2c8442ab1b291325e45c1aa11d151b2107677a89cefdb2775eb72ac5993bf77fcb8f57e9c5007d8396878e0e53922a6f2285b61334752a3606a317276efbce5aaaa1afb49f2746003544a1b3c5e296b4f741756ec760e98f84434a9a09f12e00fa4ee3c49efafa81820079b99383aeaa7dfc4f0d2fc5ce7a7a51599f4a21db8855979baf09b48d4b07ef6244785b63d802ba92221e5c9315959e6829d612d536d2e5eafb2ba767d716c97684d27159e8bf713cc5bd0ffc71d742a76ee3e2a80934ebacc87883d70baaafb19357767d8b870d37893670d0337330fbff2d743961d06887cb0e8cc9cbd931a2e1a67288f0dc626b566eb5553c4655e47cab394aeb35809c112b817896211406eccbc793bfa40c2de4818491cab0b775be4d0154a1634129fe5c1a6f1a4476ccd5a7489945432d1cc5748bb25707fb9fc4ffef08e6a41fad0749ec8d6d53bcae1d72746dee3e1f953405470c1fb98c4b8a5328f472f2bfc6f45f985bcfcd6ca35a93e4f761db798bc6c26e156630fde1e760c68018cd6a85869d184a30fc398b01146292c3ae3f0f7f71f7ea60e4eaf7bae9cf0d2117c92f0b4a28a4aab45c437a617a19cdbd126d65a84d4cddb058128cc9e8e5575c1761d4b9443db655ee23e62c189a4314682468b69070be548f3004aa54dd8cf3829419fd8ab252eec0cffab86b6b40fd6f403ccfaf0ea119c6548adb63efb74296ffa196a221499cc81ee8d12c49872e549ddd05015729b78a28817a8b8a3da505fa326df4333c2560c4d9f16f54a9b47dc3ed61157088f46e2ccec353363fdd5fbf692d4cdc34ef8b48b7a250cf4cd80cb42e48c267ed48cf42c06c48af60f0ed65edfc9cc82a150894530966aaa6146e570ff50c160e565332bacee17a6059de513276e90d5a517825752d12d31a59e8a4ce75577ee509a2204163135831fc52d2f6f946cd198cf6992d2d5c61e9999dcb77d394f12de99c3f5a4762fb4812a34b2196708ffe242301b4197c363a801921a0898950001a0a7e42a47af58d650fd9c308662c8d5e5b23d5fce491dbda61b7fbcd953a12f798c5f23eca14575c718e61a458fcf85989ae13f7f8d65313f9f9b0d8b813f69840b9821a59e984ed26bd70f1e31b09d7e922d2db583d7459016aa6dcdb838aad1e463388daaf5c5da6835f41913f01333f266c4b39627b81a1195b438ea3c891d6e9aeeb1889528b6392534a8a1a8039fc2b9164986eb91fee4bbba6eaa38e2b03a22491bc03817c275e57faa699999a02c2fe769f42e8667172fa6a562a5f7676a066e4ec44515fc369f71a4ede482f0fa7925caf51932a3bbfda2aa1ab8e6618cbff0efa50f04e6752e0a655442862bba50b51571e42dc164b2382137062b3a2bec16defd3eea92ddc4fbb4130c0d3abf945f39bd6037b700033930bb7349dfc9ba20d367bfbdfb2b74ec67ed76f0d02a417aacdac5f3d350d2bcc0f834aee6fd537bbad85be51a91dcc0f621220f4d9f108ec85b7a66452d5aaa3c75e5ec2256a8db1a6383ed3c162ed87af7eb0156b00ba9d13de40dc0d605dd853a23f7d899c9acc3b30e6e2de9f4c1b770635a08fc1e380570d19adf069bc4ec25cfd091533a6e7aa97a8216e3ff0a33c0315d3f63af84cf861939663a47af271e6f971a3c67d19dcafc9a171ced3a6d9c6b669689ad541d37f2461a760f4dbe0b916aa6b5fad333dc1e1e33e3c057fcf5070c2f46f7c32276d4cf59faa67b057dcacfdc65ce2b8572c0701253afa3a19da020a775d7ba2be3fcee11becdd43beb66830e4f1ccbab18f4a9ca789830754fa38e0eecd489293bc9284a53b54e7662bf24220652947780f528c618b33c7d2c08bf97c18bab8344e50151ff22e1fd96ce2e12b78df64dfe92fdedf63d146d0ebbe253d443926a29dd616272f6dc18ad7ca512f569bd1328d37dd4ba84281a31f5ac77bf8cca1719bef0f97053da589e195d7129d678b9062729033afc4bea9b1bd924afdc2edf567c5b102a0c8e086e018b59c6b13cb1289f2c58d3180c6351d094291fc706d8f117c9899d95e7896650ff159f7b14cc9e813da5c3427019d6b6301a4076947c631e31fa31ac24d5a4e86d1a24f05fb17642c2215466643923bb90c6f3ab6a9d310212a07bd801a9143d56597bc0d68bcbc60b4a746a43909ceee558528eba1f1414e0ba1e38f0396dee080fd2d44defb117dfc7a00eee26fb304bb1dcf2d53be593de2e9bd754c8d250b382f26d6d996f9a568a033463f9f9245068d30ac0a441dd4942cd9d7f7edfad56e423a6f50e55d541efe4f156271153de67f253f2169222dad6fac0465099f663fed2b3d8fd846433fe49d74fc3c98a63e5ad2bb912bf8a628c005f89779e659a32c99e7400f0c0be41715bcebce86e8c058feb27732b0a0c80c3e34aaeff8ea0859202325d75dd95b1fa8b2d15d6a51f7eac1d8616e079b17e37d07b459345b9dc178c98b95a590217fddbcdf6008159cdf53b8ef661f5601774c46d3263a35ccb746f9294dc667949d8de0a7f9b4178ec605b14413d011de70c9b0360f48a63c2c24baceb3b619c920a12e63a1c6e93df10c0dde9dce306d495d90833dff61a8b39333d4cf3e77f13c1d6e49494780de284a994b96af6a3987f54cb3f62baf24b745c994d49eb36f96c51210a59efa7b5a41b4e7752918f472a527f232be7e2d997ab0dfc34969851f9926ff969410a459ea83b5fc27cfc03e8b5dd8e017d0893f739169fdab8689af47ab0e2e198b73da339b74c3940cf9128ccb6a2352a59f9052d0353146c538beb40b8d19603a15a9b173c01965c385f8626b8071b0ef78ef5ee2a0ce62ac94c882ff487dd58ca670418072e4fbcb35b3e2f8a4d27448eba6f76f3536217598030e9823b616ae6dd6bcf722b010e777ac0dc91e82ba3ce71610ee2eff6961f4d5ea28239a1f9448c6655ef9bd541d66f44bdb770eac24f4b9dbae706060fb64bf6d98b11365c1475b7aee1114e918372671cfa4e496d8bfeb85cfdfefe2c159cf6f54e73863f9ee1ebc82dbf2791266fa4bee0d7014ff8421f65cf8f28ef5b734734e4752cfc665889cae327229088f06a4fd0e2633e63f7c425b057e7cd2bf90cec5355643fc4174aa2966ea0d129fd748b38e5e904bfee6890cc98da7f53ffedf58ea552e27adf0df244405e0219e5cd7685d0f299be9d8e523588c5e3cdd2478889841c5de1d1867081ed359dabc6cb5ff7f1a7deec521433599bafe01d1eb5d9184ae477a0096c5f13f9d6e13e9aa9670db6b812603fbb8ce7d7b6daa27f3183a339c032fa0508676b14323c667713cdb7e1741a42a8f7cadf682627943a91540f2bec1472c45f319d472cc827dd3db3b7db6a4ca665d8b11ffcde149ff90fbd4b5674a739aaf50bb3429cb123f107194ab9806fd164e5154f6e0de337dc27a37078ef50ab72824e06d68326f9f31f25f8ea110d68c80a4e69b6b98c0a3cf6da12fa35ea8f69a14ae55294461397fb67c95c2275ee5669bf2ebfa051c9d45854abb8ad8376818d6b9dc4ad39808a6ea4a37a063ddd295d7c41a50c82891702a6231742b293bf5ab5904431a74d3c564c4606de7d7c0cebe836e709f4febd6211fec5cc5b3809308656c7cfc356151e2d08164caf162981b80d78d41a6e77dba93a37d956ea49b5a7f2859fb7fcdf526b5eaf476bc78e12fbd01ba6bff9255488079f42c2835fdad2772808e7ea53d27accf8036342445ffbddb79d053bee20931c3858a0b4d0b6a1bdbc16ba3e92421e138d94030ac20eff4e538894f2ab460bcf798c9ebda7996ae0b2e339e7c4b253f96149d748ab96f0b3d2504b20e19afe5507dd4e421ae63813eba0287ac6782c20f36916917e8e29bdd11dd418c3963053c748d76e0b69b277b4ad61663326ff2543d36be7ba100b816befc7f0ef80f414361ecb1e60d3c64b8f61707525dbcecb586f93adfb7da239a6a92a4a7a3c996a596f0a577e07f79f8c46f2ab1a351d0bdf9574f1bb004bd6a371e3c4185e63019cc517ed508639225b972f397d8be173ea73fd704ee55068fbfd79c90034630fdbbfc42c68f3be70aa844def6aa2bf0ba7459df27515e45b1ef07275608a2c72f498aa7493c812f870184aafc1aca2017c0f77df5d9516d9bf5a60bf07f3baa485a8e02eea155e284e1952b3ff64df8e32a3e4fc2022ba098fb678a479b1aba7e355945ca58eeee5f1a9cc0fd81cb89c87fe30fac5bf2a6bcc0e547c272657c4ff17733c3ca59f11316e68b59f745582c3ae4d3b1839ac7746b8a41f42bce9da8bb791ea776012e1d43a9c4b51d6768b39df7d166ee454b3a9655ea50ab739cf112b1269400d92afe07c0d6d84a31715c3dad3cb31dc0e1c5ac46a895f44f302c29f2523fdcce245e0d66b5e6d90010b38911d304d7510403dc49213e5102bc83c645c53d0591298233ee10b90697292a112cb5deb3fe07b830bef369e5f745361a03ae8745950eb2c1ffa0d7a2def5535678857c4db9e58d1047b60c0e5178bef80ee13c205027a4cbaf2fe207e1ad5ce78af548621d8fe77dcf7f806a453bf0717b9e14b0cb6b0dd4438c7c958fa5424b7c74f52f07943773f3e6ee9547a473f738132a72d6c9e0e4ea49253d15e26f94ba6bd0238448059b0626749a85f8063bf2b477f7ee37d51f06f9eb2f6b1c3d3dd8a719ffbb2da4835e6ad8ddd81867816c69f40cfcd3f330df2dc139399ef554bc4cb0daff300576a637a7f2c07e359f985f195a7e471b99cbb3e35ec8c1160c64ad8781f9c6ce96842b02c90a9415249be16cf72c2fd53f4e3ebd775ca04407d338b9fc414e4e79e3ebce8f00dd40dc9969f1dd8a908a9a2597caab267be557a5616e646205c095465267387e9a87b44f3ccd223398632173be81bea4f544027519485bf942b7c27b09dafecba073c9dad88d9375db7b093951b614b872a113d9a4968f71c8a9fc556005508d51b1b0b6c57dd4c71c58a304990beb6324410670825b45bdf20fef78487449373f1856f0c6bf8ce4b773e60ae891a43e0e429469bd7918567db53abfad75b58ae44f68fd52f71cc63bda307c31807ab18bba9b63b3c8e52227c6dc7d8c584caf9ca745b342fdaa0cbc740bc1b3a2346fa747d7b8b340863ea8947e4937f7fb1bb8f6c04af437911bfed3f0f386d0538b8f8bcc2a5fd24ec1c1f65045a81479490c88150a2452ce8fa63252ebcbc1b5a904db7fd4d95fdaad17be1ba9ab22a72cbe06e8e1b1ece1c04e1441e6069b7d980c3a9d70e84e878219ac981ab252e46aebe632ef8237e1b7d2c30ec5680b2a3564834fe6faa22fc454395120889014102abc453f201a636e509b68eb493b0a04c43c5a2d1571a2f8b085fbeb4eef96cd6b5b16e7a452bb2f9dadb95e3f9e40c7f46bb5480beaf0a4940a0a8be40bcac227e3bf54930300a9c6786d86299966cd2440111f6cab50fa676ea4ef7d1f20828942d679e0b74aa962a99c20c7cc83f1b25d627538a1931c725f998620fb85debbdfda10b7dbc1b7f15143eeabc34a65c0cb47db2eb81e23408ee36856703fb92f05f1e469450f27add6af58ca3e77cbdd64c8365aabf7881026b0a6e278e46b2286b96ee0b8d4825c33902a8a9addf9efbcdfd99b1bbc36079a5900a0c9f612b6cd86eed06529518e8c54c542b2024de4024dd6e3f4e5c0097477cd20c84e8e835776f502abce2006b5c3825225beba9793a25440fdbb4875f8c6ac30f7fd7411a0fe95d89bf313a5e2389ec3a73d065e23431a0a9665df1114648a0663fc1620d6eab41b1b791e3096255e313690b3d95d0a63f766bbd69430a20330a94c20f683fde13c331e901b25d87b25d8d6dfeb17e3f42f32b5307516179c537c88c8d5ed3f58a9e9c4e208630fe77f241ae1f9dade4f0be00324c0863b18b301cbfaff81def4fff6dbd3c9c8eeab0354577207665096100844ee79b2e5b31deafc9ed62482953f7a85c34ad1855e7139dd683da9b58d23e8cb602e33944bf8c6807c80657d599069904b0397cc422325bc2dcc28882ec27f60066991dbad2f39be5b99f4c87041853a4997e52b5b26d793aceffab3d3655b60896aeed26389e72fcf328deb350dc0a6ca8ae6cd1402825930833c58c095f169863466a1e2940a03ad3d9c3c729715d363558df49fb03947c92b86c7141c652b9288e0567cdee37be1b6773e6dbb8ebe04b52074fd6d69ad7c9ed03c596c4f010c53b410026f13dd6a7e55b32383eba4c2dcf4dbd7dbacaea3feb7981280e3326ab6684206a148091b0835a7b4803be4992a80a21b5380eb13c76d1628795ca4de31a3900e88e5e8b817d471568a87df3f6d581a450a2b10dfb295a7aede868b1df3974313e59218940d48fc68394024517f0444746f1ccc7a9fc500522baa8ff63f4834a1a39a97f2c3646c8812c6ee97cd4d93732b246be32c2c7a694deb790f295b1d4bd3e967a50d93b7fa1fb74ab3b350c331a3c2d934196bb1e52f9ff3575975fe122cb0a7da6907a54aa59970275d5997028c6f17fb5018e9c45321d8b7733c73337ee3b6f04ae10786abcd40d931b9154fee737fba4dbcb8374d06543cd3c8f19ded06a00e46160bb6eb977457fd56364885885b4c104c672e712e5bb61d24d943748d9e6c94e5fc4a6b8b5881ec81596c7c5bed462a753ef0da5605e78115fec3ac2434fdf9ef35671e57abbe7e653d2f89e1a8b9d95b928db31c5b56a165e1e63da2c414c155cf3ec6d1d5f90dd462772a422a073926c068ceba92decf55ec0a92ab73a15cac56265b6248406fa96f9fe13e4510bfe8cb44c479258ba9845f6373a2608305366912405a2990f743b0b378201cbb224e2c9249613e9ffff645b7b2178cdc1e0a5d6d6d541eb613748091fac8b1a7a6a539b6334fad4500dca0de27750e168e3045a7c8984aff8d91060c9f31555843355d069aa90259604513290cb2b4aa01dabe5aaf2857f2d00c63ac06ab7bd4c9a790be023a9866951e36352282989ecb2f79661c8fb41bcb440aac864ce445d4e0cac2b27b29ec8c3738263858f70a287dd79a12361c8244605a6c64f854008ff40ea1866affa4aa88f1e29ab3618881857cbc9a931ca7079d29933297c361433c173946fd351617974a534b91cdfddc077634d6dc3d32bdbf65216f27192bf299acc401307327ddaf4312913f0511abd96a152d420b67c9c01433eb6dfeb2362441222fb452a8fd4980dae18c86612ee12f8ff70732c965106b678f76232f316bef352e406d081aeb3cf7d4331555126a969d3bdcfb5cd52fe3d9854363af853107d2943f1f52d7f2068a93119e6da15fe52083598bebb681071c69d1b3939d431402d9ebbba7849092c8da3ba0d0204f1dfc344f232bfe74aa41f2fcdef6e45206cf6edd6bfbc53af81659601400d454bfd204e41e52096a1f791cf984f2aaffc853389173c0cdb80538deed0090e3faf18541f5150a72db65afc819b8d807307f7e186003e9de63cab933398e836fdbdf88a2931c4336400fbf29504ef6c5cbea5ad5746b07c4e8e4f7ce396fb89de013ddd2f385861e5d88ca6616af1daf322bc3b4d90cec853056c0b09bfa495b704e74832afa3c8b4c0f00f79a72137019306bfba485ee689c44c3992f4d7e114c7a9661e5f4bedc865a4135f42db5d8042fd039863a50ca6c89869533289e5efed60ab1450e51a9c0f370beec242f9ecbf22e7fd5a96058f94e64662e26d061c297aea255dd7ba8e62801c99c3b72c8f8001866b0a1ba544bc92e10bd5fde45758d24cb6c305b0ecb45af87f561c3d80623b2434765f36c32c0d87a41624189d1071a4c0ceeaef734d60d4773e765d717a7df70830d86980477872e36a014ea13db1a61fdc65f278acd572a4e59f2f2eba0a6f91e86305167799de339855137a1b078a44ab97f31e67cbebda84bf4eb54f92180b4ced8ae68136851cb251e93e455803cf04b49585dbea8c2b35e2d9a16e127e92e8f8e66a61b318d9cf2136aac5411f7a5600057fa9fd7121c018198bc90592648374d8a1a94e0449ec7afa9c1941fe968a4fda890a98fef5c6badf103aed327fd7b1e904b9ae2fabf3ef9d300dafeca57a85f7a6c89881a739c242b577853aab25b1d6c87e4dd289d1d3751b86548b53004c9f329079e082fcb0fa73949df6bf7388c8bae2dca3081752e490680b20ce74824987a77fe6d68bcbc466cbc3eae7dd0cf78a9c39676c3ab6ec74124d847d4f713cdef69ab2054249343ea2008e266d680b42349c2b3de41986bfdb84b0bfb92cbfd8a7b74d3162062045ad1ef4fc253b1c37039740a782252697309ee3ccb51b71b7be800035f1757a95cde31c3385b55c0a029c066c63cac23a7d9743d64109de9b9d53298b3c866b22f98f39de8c2841c32a87f1b00654bc8c86836dd7434525de7acb1dc75233c8d295642a644844f9927973ad33c8f97c028c9db78d46b43c6035b832470e4ade3ad1e67285a3e06c0d44eeaf11e18250cafd3492b695e848b80d07307e3330737d9723823d06afb65707c0f68459c01be9d4ab771ac21002eb13af5b822163a2f6c1cfa63de14130431f452e72883a3155583436f174805875af2bbed3f6aa6a852cde3494408bcec8507127a164d3a2da5ddb9771e3d537ccd6ba10bf671c40c1129bbc7febf8052594ec1629d95bf8fadecfcee5f32b875daba12d486b6126bb174c51f751e8aca6a161a97cb23d70226db0b74ba8ef81b3d75c010ea62c68445936b0af4306a421cb4c085cf185d55461100f0fc1a3524343badb11e25ae20f8b3bbb99b4ea8a6820f7f9fa0dbfc11eb436e0e3dd8279fb17a5201d2809ce48fdd2446ae82efb5b56e0c7d935250998f1148cde7ecda8feebbd378e8169a655afe28ba221e9f0ef7ad7898fecb4b45cc5f544e1d8fb14e10e4855146b5a4f6e8cbbd71d9ea2a05bbbaa06e9bc38311700adda13e49497b400bfd431506812840d54f5168e91e3cd41245c568484ebc4e82ae601a7158fd88cd92e8944b2c2c19aaec52c4095301516166e2c7a07bd56fddd76d31ebfe42e3af4c27864835f077f48da866434a7d26134300470a49c5bd78812ca48e2e5b6fa76ff23a37cc45401a03330f62b93d6649da054da9c1f856de22c2838458cdd88738fcb12ee6089b7f82c9fd7555370f75f2c90b5997872c9be27f2644a8450399490499f3a4d0519c72bac066816e5bc7753a38402c6006ddfc8c515bfe5cd47b3b99b5ebb47fffbf54cbac9ea05c725253bbb37c956a2584ca116b4d74020d586232b41656ec634f0f3b101ad8af539d1733f787db01342834d606f83efce8594682fc86646afb0beb5ccb863b3cf8634f6fe0217e205de245b90388428734c363333cf5852470b97b66be7d8cdb8a31edab9207f5d60cfbaba192a332328e1032712c367f3673502e4136e052e8d8eb625a1da229de2b84995f86697afe23e21c659d8ae37ab926f549713a210899a33ee7f5524f5bbfc42d7466f6ec452c874737c49f24f1e7135df373f5bbd2dade0f65f3fe76b267f48634c281212990d0c4bccce1b5c22a7d60d964a250580b78705129323fd0b559e0bea241d7b0c923d51d802ad55ae746523f0121f29eaba7ed05a9f032e7417781284357632530f1d7e205a184e9774b739813392d0d5bddf44a20766795fa94edd85e6e926b08ff6409589674919c626745282bdf62e4491d9ca6330c684effa234e7ffb2e26e05787f80b0b54b7f30fb8101719c2d676d520ffa6f186d269a4989d08587f7f3d55f23f56ec2b5d89dbc48eba2cee84a9a776d635fa6df6b1956082a1450805b447fb6829b91c6d969ff7e7a395ca2e1ab7fdff22d5a072c4843068b8aaa893ba45ca5c7c921d975df3c6e8da71dc3740435749c9857d7d1d8fd50bb6f029b805d13727406b72dc87c2d0ec388044a7445dd6ef58000ef2a2a982843f2de42522a44548cc59f9f5764caadcf0ef272b3a94fc9cced3adae8cabc6d2bef3e5bd538f55aa5642185e6e072782ceefaee1b15f19f148dbfe69d1f075368c6576ca15e658e896567d9fd284eabd4addf9ce290ad35862ebd2bcf42899b627a0c62016e1c5fabe80d5c565939757344f9b5cbd02e07d6a75b5cbc94f2e590164da42bc4dd139ed7857c5d0a41bfc2961560c41e76b2a00a4668644fede98fbadd6aa8e33986a47271739e4c0864bb50c6ca8cdffee231eef18d65cf62671b1407eab388552c18f48da91b44fd975b68042c3e14c7b38c185b84f30e254d2727c7a2bcf43bead1315ae5e989a0afb7402024d55804334280d063aa0e64e385b4081d33ae5e3744c973ce0bb51a6ff49542abaaa313d7abd28aee347b156928b190c5c0145e18bb949556e90602ea60b18f987a6da8e2e78660f0aacebc8df01f4bb59b9c9ec31e335efeade7081f6393ab5bbe866c57a04a654f9bcd204a963eede5346c386a2410721b26cc2be7a7bcf982953f2c1209bf70d04125e6ebdca6fa266558f9c2332467ddc2d5a8b2e80b793ffe48f561ff7fd21670ae3f46b5c8d0c43393ba952a00e694449458a9f2e8eac1fb58ec0ab2f5f4a40f740430d313e8fadda51d0743ff1845722b0096467a09edfdca7db3e11220e85011c3e4b57cab6be24e3ac42c9252bec25980e680b17cbef13f793bea9951c33abc8f81e8b874477a4d58c64c20339650e5203ebe37166d0a55f334f6f2ff055d47e0dfd5ca7d4670dccc2e092c7e3a870766685caccfdda8697908291bda402a0c685323","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
