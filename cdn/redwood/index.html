<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2634dca500ea8209468296e79562e45cef8b7c82ef05ea26ffe2c2c3487becb437abab4eb10bac2bb5b28f2e02b1eaad6396e39e44479dbfbc1511a640008af7e025485118e9ef3bf0a4f7a6835b0925f112386c99747c76d68cdf21352bd780ce80834f87bf94b4a22de93bbe860fc1d00c3b00ebb3be12117d65d8ba45c850761e073897e1e4658f4aed0b68d44805008c0cc7f99729af09ba95207332b2ebe3b7ad4ace65074d9d409c6c2e913798ca34ecff54fefc932773c61b37e085f8ca809e9b9a3319981f16ed23c5ba33d9b94b4407f47d3e617faf88047b2801f8725b57eff68c440c2b3fc2cbdb7df94668531bd92539d3a557fcb74c0c28baef4b3a0f8089148fd61fd927e5085d216c34cc8eb358e12e41759c7014fac0e273eb441826222414f9e70743390e6b57987a2a05e723c31d7a70821298bb66627ad2a654da9d2f6b1124fcfed63a652db90900418ba60ce950d25261e19b568935b9944f457f5db69e6b96ce132f4baad8dbba9c9e6be8a0847e9a46471e009d079e68e4d76fca6031c60e92851771e7041250e34bf926deac93d712f5e1d124d847724c2f0db43749345bfa118955899701eb76b8ee05b74e5d115364c116454cba511fa0d05457436ed37ffec6f09fe194acd24a699709f4d66434bcb663e75a5e13a8b5146b3d61548a62f44792caed58c6551a218483db465f6e7608bd04957f84c5a905ae115f1e003b5f5205e626b22829b4ca9a7c7657f319a6304d387ebaf25a428999bbf564b56699105714123075c0f41839c0d177874cdf376a0c9714b46a7c6b87630e3351d3ea70cd26e40196b3eb810e2ea7f1a8acf4d1d7278a74b4ca3f28a56147ae1657c5122d7c55afcb5d9eab60f01b5ec1f92d4c7b671fd2c5c86d7d91dad3dfe10b7c19540cbb915fb37915dd11f169ca7b2715a1d2e5c2173ba26e770175088d28d9feb1b46c81491ed3cdb8d98fdfe2b50110ea63139f51805b0bdcd944deb01d081e47867715300e022c8f3466fe191486f3e874fc0ba7a83c758025ace8ba388c6321b3bb05accd503f6d9c63d81bac35fd2090e41f5b636a3faef5dfa5e9d818ff700b46ac665be6c081248f88641aa744291ba26d05fe3d2c017b038c309437b713bd2ef8094f0f9af28d5ace05d79d33c557cd29dbbb006b548d180225c6c86726c78259cbf78ff68a9b7b8085ad1111dc1d462ecd0b98a6c4c53208c0a94a2296b5f3dd6c446ad427d8c773d575bf215885cfb9313cc855cf8ed1ee70001c4ccee1b9a09a11a0c2bca44bfa1984dea5f3e466d4cce003a2472855bdc5a4197e78e207112e17a78e5c51e53a2fc3f4214247841966fd9392c55c35a2b62a0eab81d443e8cc0f240d7665ac2e3d7bdc9b46bc28c7a2996fda937d734a21bb97f54467c3eb97ad719a27b9340d8e07cf65bc0ec8328a45264aedf55b9448154f8a9cf149488381a88a77535c1c940031dba796d2e5e5b7696af6927e399c56c28fb4d98cc62487b654f0b539ea8d69dc1fe828b62c6ae14374622dba9f7eac108647019934fe487e7ad88e411ef5becfdf0a21efe0cd5781955db5330470283dc7a1812938548369a5a0edb58b6eff99b88709455cdf46975518f32eb3e12987d15fc87eb774b9b6c8430f0a56aad88c7bbf63056466af702c8a9bb95a0276a8af38a3b4dd14913b20487b49ad2083c25ef5ac61f9d0c8a4a4f69df64ec3f2e0fb2bee0fd3579291272181c2eac2a390451bc53452c3ecaf6c7c4b66198e2f9dfea565bdad36ded0dcb42930e29c78f3df8b56e2d49f9499a0e871401c1728a3f1c86981191d8e90487c5f0d5c5ca9bf1839bddb6d76885754264c82a0f3ec5b421054b381ba28e971f3ca8c007a7d8623bba7e49a722946e6dea88cebe924008ce2966505b71d66d23c9c33e25e3a4043e6a5b6fb0138b95c245085b01c70b2b84b5ec7050f47abe9ee6455a975eccf89a647f37ca9b9b7fb5842c609f825a66de2518b3b5f022c520d531d0809fad96619f86f8d54395b1438b85c737bad368dbfd1a8892b9e33f0efa45fe69c48c3a5de7b84f1e2d722443de4f9c80658028d6292a175e054906885d8da16e9d31c8b588e97a3f42573688ea83e58e9c006088d81321ddb8c00b70c4208385040ff09dd88fdb47c6843c14cb70620b45495a217e74717181792e63e8c468636ebddd8692915e818f9564368723bebc0dc57423bc655cbe9da5a45c51adfed934e9a4bdebb201f3ddcf7a8dd4428e34bd2a3dd01ab6e5c4da27fcee6bb1d6f8a403067113e84e369a92c0319b9b71486f616b8f35bf360663c17603609b132bda8843ba1513d24c2736cdaff86ab48220bec56770a1e875d5189a906e4d6b0ceaa635915eae92b9f28b9bf818184cf9f31cb2f662581676273ec5b4b190f289e20597bb36ade2b76025a4a0e2466acd0a356940af8f9d0532a598f0333ad146560665a6c020ed0e1cfe6625b9d85577900b5e277e4eda36888450e1118a8ecec6f6b48cb7f9401bdcaef2c99477fa94cf13d13eec9adb9e57d309b0d24b0578827e58de2a21f4eb6f2ae7f0b9f203accd048ee1c03bca8834f5dd910270c0461fd381b6f874f57b848f025e3e2bc74d9068a840b8e0f2d12d645f7caf5ab04de8deb8f5053df06ad023c1ce65c48f23662d6a6c80bb6af0bddc94fd7effb75adbe6904bad5c3f13806d9afe3b96ce4b6d9f92d34fc70cb984645a6dd4b9eb715200dfe6b55a25afb4e74b48c454407f0843ca483a8b0a3a030827926404e5ebda65a89d223a5636ff8d7f871bc8c437a0337a5df6a4625bc4fb9effe11a0b46cb5acb79792987dbd9a42e01abd6af6079c33cf4497d0e423075d4e20101269bb590a2adc3b85f644e069c54ac4e2ce498af6a5148dbe1d821cb9325089280f35d4101a8733fed94bfaf58ab1f21e3854b60916bd686f7d2109c94dab68b243625ba0f82d2b3eac2c4640ce979ef8808c7578203952cc457c7a55309c41684bd862d978e776e2614899e469250a14f057708d48746883949599a7a539e7cf70719c4bf920848dec59ec499e1b47755d435e894a838a827fdf08621647c17920965c6a7a4a3618ba1f01ced187fd6815655a80fc2f390465ec03d9a16664aab047e797401d1033b508adbef9093909c49f8661a0d3eea50c1c02a0e309cfd0529d05e855fbed5ba79dd1e70f3b0b5911088394d1f8d4c8cdce2d9e2cd7126ace08b6bc5f4237f17c49b19d2af17ea557474fc2888d96d65e1ecdc3093110849caee66300cf87440e2d94202bee29d8aeca4acbaa2ae2a68615f73d2498d67e619cb9c34924418d53778022f4a007077efc047bdcaeca697e6fc36c39b6ae94220cc188fac7a2aa234bbf008cc752e9170d655acfe17f9a24a23d50136875d7209ea553cebb9698489c592cb17eea0d0e4871c772a7df7453efab7caa0b9e3d912f45a2c31640eb91206b5bfff32dd942acb52108dceb2088a6134954915bf5bb2e4f7db118fd9d06899e838c37dd48f531bdfe554bafa311736ea05f4ef2d13a2f8efba29173be6c63a4796f2e3454371aa946ffdbe96062cf7cad8eb5a5d20797b1a1f837416059b42342f16d09091445ef8d832f837c751c2b88a1d3745b78f8401e12b26afdc5b41dce9cbdb935837ed89d4844ed2509783e47d0ea271cf5f4572725f78b2000dafae11e8b7ae28362e4224f17206782a56b38ac42cad2f7d2e726018f750ddbcb2efdb24393343381e034726bad0740ea2e1d0bd2191f87cae28d27ccba2c01fddc6de90578c9f0d042f1becf22735e5398df57c5a9bb47dcc4a26894f59e2a978190144f10a2bfd28433bfffb1580ee0d00f243660a6e3d5dbb49676f1b43a1b125f1112bb6d9e2b43f474e518084c6eb5cd568ea98904d3fb788595c82bed770e0dcea143859f68818f76a6eff020d045053150d46a58908269b9d3aab6bf147a42ed06f24751f111ab355f9459c06fb647ef107b6b1266f971e8fc0071a6744c41fdf91ab9a156c2d498c266cc1e7b098eebf89158686a83cd65ec2ce10bb438bcbed0f805150f6271be97281479f0ac71b5db57e09ecc66a83051097cc74f51c2de49d408a57571976c2a0aea88962558bf4e78cc3f8bfcc3a63c4d4eb5cca954aeda6fb27140c7211f47e696ae8576f0bef7da56225cb3633b40297d5d6d14ce3d702939632f4c2f89797d4e38e42c28f2e80232269af6c5d01f374f0bc240fa70edf5d73e6a61815933c4834b00b5f69ea973911dff8c5e7024026ef024395a914d059071e39155be71c8c6de8112fd1130c0b459c300cf5994a5e6b04a929ce12918c48f7031c7726bd859a5ab9c4786e828a304b1ca46048b8c1ade8eec906d335971b550a19cd48cf1cf132485bd28922647c216015b5e7d4338ab8adac0702cb75248550ff938f683b51e1f7fefd86d30e35b097225488b022aef6b49270b88cd1dff99381da81259272d6f3eea8a962ee64964a0b104dacbccb863c0adde6a9f1387fd459bec9cbcbb0366804d3ec022c650b686946c0e4877a72a5111dc2c5f903995f607cad5ee5839171ca79fc088f2debf3d5b14aad6ec6f76e4b406c9cd2ede76a0502261b82d020cc30fc510ab8731d0f4e0fbaefadb9b0a5ca0919e6c1ccb0a36efa04c6a85cce5a081d99a719fd6c88ded63e5cdce7aac8c3b29cd8e23ccbe853014449c1db07d4dc47ab003e751d339de972457ae139a1ff36e05886328905d857558056a67ba7e0284de52184dc732bc9e4dee07b810c344f6f5dac82d881921021e9784b77ed5dcc2de1c6453f8fe40a97896b0e2b08441760f108dd60d1dfc90d5cac25de3583c5d18ac66c4217ab1e7f478148f490efc67efff86d05bc26eec78a9b687de3037cbb32ada46b270ea846fec0affa9b1dcc01c29572fb5f8201ddcab9acb36dd2532be1148239db587a9c61d51ce608ade2bd32535d711c5562f81f9a31925a8f9b93447a315ac22d9fd7957a016336c13e3db30033431ea2e64c6cfce974b8294a774b7af989dbc838896a93197140afa20d960ac2d6a8fd2b0a7ce8df4f3ed628e03d44963917b578af0752f4839d17153c5f5b437c058196506ef4429ac112304e3cff132f4550d667e16b076116eb80eb47fb14d7182672dd1abc2b1a4a096a177c61f5c508d3931a3e88bafbc6d77bebd03210942c7a59a370d6398640e1ab9ce95b557a2d60a361ed4e2af79cae52a968ba4cfa408782d8325ae2dc3394037f6df8dcb8115eaef652a343b21d665cc78868bb8724250719d4543ef4af4398b0069fe8e29196d761ac0c08776f174bfc744c13678d25fe03c9612a57a42dfc2e0b9e3ffa0c45ca57e146d64dd14d9c775a4fd4560a574f4f2b36b1ac8da03f8c87839743401d3f62f28a2905e0e738d4d9d4363a6268d309726ec6cda52d1371b18eccb573b3f94f9b4c65a7bcede2b104c1dd23dad1981678906adb6345fa5634a70eb41d4150ca7c77d5421c04949eff79a916b4837a092f37a5dd3584722f4e5daa48e91e4c298359af139206a1a8de1683d1067fb5afd77c1d3b2fc12cd5e52b54e5f4693775318f107fd2ad55e7de70aff49dedf5ab057ddb04e95eb1578860f765e7ada56d338f97fa3bd353911ec5577593e7a209c0ad2a1553ceebcdcb414124299563bf3bd5b7a0685df5c0d7b316077d7eacef30892995f0e7185915f07c604193768911f9ecafef80048ac34f79a4a4008e6c6f8016e43e4277e19a99f8791de782c77745dfed96be78f20d1a25a43f2b7c042bb3aa3bf386ffefb36c0edb10624d004032baac0f129dfe190fe63d90f1bcea5816e46b54e4502b582e116d23ff3b7135d18f9de8b61b0218bb6d9ed9d912dcb1cf7b7710d7395f04bec18f46735fdf4067c9c59b0396e8c258cd1bb18ab5c39a5382f2e0311772fb8846aaec7b8b3eeed6eb6c7b46f5234143357872678bee4fa1a4115d0a9e062c510d13569d66dccb8b3b08ad83973ebb72a867270aafaa138dc0b5456b39828463dd3bb1b61ebdebee2df470f28f482f56989fa7f043b53c82abe74dc9c7a7ba98bde5bb937970199add87fcdb6a8586a38962a3020ca02c9ddcc3d5a25bd9e9ac0802d645f2249fec4c7f125133db889aefd8392963521341d669f6e3b034f68f1fda306be251aa26c4c0ad74c7bcb10f105fcb35fa9859ac407dfef3ff6cfdc119fe1adee12205b58b979d4253bdcc4fe867eb9b968e31d784e07b10c57e4ee460e430048345ca1b3fca066da747b7ef1809c75a1e3cc1617768a4c5cf4cddfaad7bf66c40322b2332c808c154b552b6e72486753c24d21f356e690dc4e7c57a95627aebf10343450ef585e0162f0b74ab008a0918f2cdd8895a8b2271208fcf1b3f7dc00290c3213fa5d6a95eeb261e47225a3657b951579eed4a716c19a389a4e689e7ff875ff2bb6dd430e5b2f2c0a0bd37313122f535c58565a15d57980b33276d84e87d5bf9e94916c67a9d7bff218647b0b6f4159021e9fe36054b833928cad56bd7296779a5fd7a1970a6f77769a5116178e236e5ae9c7c32b34f02de52928f4b89a43989e721fba0f6797a7d505424e488b6a773a528da449830693269b18bdce45d3d5c643d882cfcd87dc7ce8be762989b35bbbaa161a90773ae12d7454173d0cfe4e8e6e670e064728ca0983d9c0849160c63ebdeda89e514c3279067e637a975698299cd2fb50acfd0bcd1358cebcdfdeabec06f9e27df1507d638ffa6ddb9d0c15e7253abb884d2eca20bcac565800020b271e31c6eb1d6656fac8268df2ad8c8d72f78baac8821f7a9b6f61a6bf430c4a3578b0af4166c1693537da176d4a1f0d4d60e4e62ee3b98c1e83f64d58c5a62a3564c58d2a608871fe4932e98d61d03d08712933067d5d57171920d5984a9bb0c8a0e633c70cd75c04c40f4ac967dd8cc4d9f21e9f8256a626d995fc9952c6d8c5e3938d67ff2b650fad244a7af2e6e3e1752137d3f44bbc4c7f875f53d8bd3db2e36fbb15f30a3218b0160e5b0c6bc4d71e8bafd7c85b00a9dc735a60af3aca6c0f9b3237bea1ae63df066a1acb519732b2ba98aac37405b0d1f1d34aaec22da8836718023b7bb606b2175a335871c7d1ccb0fdc283dd8299f64821ab77accfca2b9b7d6d5a6e0cdffd0807758fa3fe341e5a62792c08c0f59d514549048cbc486aa2faea77ce7cd179bbad2baa79f445aa837cb6f699a7d3d84eb9d5393fb88e78802ce45b22c072e89239a3b17578970c3809e035244526f442d501f81182c21498b5175edb91f72180c0ebd0ccba5ac35105aed4eb10b884db4cdfa310ddbcf555a119f8d03d67f30910b9b4dd79b0791c90d3734d25e04523bf443381b5602bc1f7dc3abb97e2712e965d60d11447f9d4d9e9d6f0682277d72ad7c67122284e6110e7d51181589e92b12b63dbddd63ced9dbc22218dbffa81bb0794e2ec5e229cf4a558b42628c2bc0ce9e5171dc28196e47e09d7ae46dc1966edc197d40934bec65b52f1b5ad9e0fbd6ff080bde1886946056b39d0dfceace4ae4e21a75f3d2159f6097bceec568d4e8a7735616fb0f88744b711fc0044c2aeb30c01131d3db0b823d98fbd12ad739f06a7048bba3f1a45f94df3117ba7a202044ab4abc7c6202e9dcf51382ef013841b63845efd7aee4334f2d6b3dec448cb77eaa1338da491eae5ed655e995d4b679a112661544f608ebbc7c0ad37480fb649d65fd4b6f066e25105025bbefefe921e35981e0622c624f2a90a4aa9fd90a885bc9bfe010b9bdf037b9787ccf370d6457e3e9f9042f43c9a35e78ecf33ec921dbd520be0dd92a219e0e544e02321936f36a36173968abd38dc96299628b9d2e1520a101d8f8a07dffeec92d991d1217ff66a42e6ee6f5e84f6326bf67262269b6f952478d4f98c2563c59017fddfe054b2f7d048ad6e0d231efd3cc886c38cddb5a1ffae14d0df7a7d01cb6a8643c61b8fa064da19fdee77ed3f2f967516f5a7abd798e7ed54c57d600127475c8e455cec31bdb4cbf301097d0e3d2bdc8d4b17a8e7e1c1fa80174f746de14d9f8ed6c52c9886dd640bc27166ae6c18352ab1f2d6de9c59b9ad2ef84966ccd17dca43f50c9cd615ea18e7de243ac4aae880d09dff83bfc8d5c538cf2b28fef89dc5148e83ccc9d3122c1faf3213e473950b55ddf27c6c8358f05ca0bdc0bd43744ec03bf406a9831f39585ee1c074229fd1ee9155578e48c1108ddbfd5d251178c3ee0f9dfa59dab443289477707d3e490b064cb2714a68fdad041b94d3c13935234aa332bbef4aa9219b4a0b55a39c70aedc9c22452ba5c45a4bca2838cf6955693cd0df23c8e10b1b4b94d3a7f9f7253cd85c35bee496104d7a6f9501b39be17712a633791742b509d19e5df4b7d2bd527ce2e0ca5211c16feca0286a0d1b80bc90035c3495f80233a8b0041344c2cc65b09dcf62df8972e87f6272d712fe6cd69f021ef0a20502cb86641c824943b35972fd97fc58fcca9fe9d0d3fb36071d907554b04287be38e247550d0b3900415fa227a6a97ea0e1edf10723187a23e1d2c70806eee1f64bcba2dda2b2fdfc3fc3136aca3a945b29caf0dcfa9a87970b4f5f6fbf2bdd92d9362f33a920abb453fd537e1bb6ee2d7b6bb188bea38006eb3ce954e76c256db0d9ae0229e09fdefa112bed601e4aa034243efcbdca9af8448dc0ed9139d9ccfb0b5d04b7c9b64ff1f1233a8e6f16479d77e3c8a0352a418f0a627636717f7f7cdbe36a32984c005b776724610fa982056e9c9e91d09a65b10d2f18cea9a6a0e4beac8bc5417bdee749978912b1d71a09091ac7bd841af7fb8085b4323a238d9da8660cba48d943acad1a334cc69218c046b31bc995524183d077880ac951030d9477e59902e189974129fec0394b507a5c723fbe6801e883fdb9b8488fb28872eb7c4473cc683c4c7ce780bce39a62d5ea8bd772c19d666bfb484fd91f9a8d5ec4046784ad36d36293fcc84952e631c4c099766f48e3bccf3047b534f25b1725a0b4fc08663f46adceb875472d1d6996d72f0c3ad67268dd6bba2710c7d23ddf85912698f8b80acd17530e7b9391a028136bd792f0586eb89d331f8aa7863514b59fafacff08bb6fb772eb71aa1e42e3ccaba65e7b6dc7838e5578f380a277079b924f628d78f845fd10965e8a5bc198c0f71b9b035de7a296d568f5492a2ea0e29becd393f13ca6aeaf15b07dc30a84d0f10d327629c02a2097610cae2ab3af9e100bff509e15ea48944f85ad3aa09eb0a521dc01fbac2b2f61e60f07c4f7858e02b02fae371476d47b53bfb9b841076093731d3f13323ac1a4be4f5a05c45b9432aafaa3e9000402728797247893e2a2545e6a1bd3946197b20fa4d23e5955646c6474a754bfd9b49ae5bd0a3664d21320857070f0b51aa10d1605c26dec6c9d68eda80fef9e659457ebb551c3140e80a31f8db3af6e26aad4244923fc6c3e203fb110536cb4bcbd4d5474e2c7fb5d7ffa9cfc4eda11c88e6543087ebdc3fd226340de9233e1e5c0d0859a328b38d1d12c3ad2f8fecf7fdba3969c3df652460ad6fccbed742d5de948b3e32d98d8a4fdc27e1856f7e477c4221884017c5bf74c354c804b3c596cdd5a28af4dc38db2abf89b3e0b605d35473d02302d7e053dd6d4464173a5239bf568e7a7d7c5009c8c3059889ad50ead8eafe01cbc609011da41ccfd9fc8e4cee130ba040ab88467aeb7a9ccdf186041392254446cb713ab685589d5477cb1891449a621b558b52f4cd645f76d38e656588836d59b7283583996f4ccce1d064430d2f83d7e2c80b2c92e0ea3aedce0d0eb74e0e17f83f48770aba9352361a5e726a2ed44c4d11721d5098a29ebf29a5981aca1c8ec1a0629b8bf37ea2ec2e112e8c4000ee34131a089eca5947ea1f7cd8c62e843f14ce5f363407596d57557382254a5f19d26f357e0682a37ee8e6bf51523946e6494df624825f025ee5de956241201ec9a8e810fa42adee5a554a043a83c417370f6362fdce4c703edbe78a549582b0ae97c03185d3c819149088768ba47e438248e843e9e77a0bf061c91a485a19dbb969335eac905faccaa53bb38972a2e87f9922516df96df4e38eed86fcf42bfc17743a3c99e228ad71e47dd312e098d83d7a4abdd03f6d60a9d1952e7a550fd59ba6a18ed2ed0594b6937154d3b75c619e71a46402fdccaf239e71cedb2dad15b1ad567319bcab092ca1c43e2dcfb92d9f28426303d9d2a8feee7fbfe149670e7bddc6a5ebcd937a359cbe991621b1c91921ce755c5095e59c1e19fb9255eb6fb4ae18b2226e0cfb6454374a85941b3b69b8333","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
