<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f27a4775256683ec7691e739cd126e10ba529a0ed2f5acd6b8ccb519e93d9cba89e6f93858f1ef5a87c12d8f65cd596fbfe1c607ee66c8923dbee3a8d023a9aca93ba3abfd448c3bd8ac30e21cd552c95aa069168bcbb4c8adbad265bfc267c6db1a3310c1a9e9ff76e92461a85844a142c08ec046c4e1869774e4de517f5424719ceaf2849796a241e761329b033f32bac8ebee95b946e1d7f4dfd9084de23e47b9c5b18cab92cfa3f1a939abcfcc51096dffdf6ca36bdd0abb80b71c2476cf56285e89af3580975dc725e8dd2462133706640ed0fba1e19c15fa059481a2723725ab8166040d419df1f3564a49ba40a62ca14233af4fb35c23eccf1efaaf6c52952933028372d4dcbeadb36d2fca1c8cf32ae13bee59563c4fc3bd3e130b8c070021e5e05a3366b65fe2588be745a76341be6c3396c611df4dc4246f1073e6a9c2067786a209557aa0bac8dee13d496f788c0010a61985c0455f1cf2731d35cb58f58b9ccef6b152747d8138e87297bf807dd7c19daa7b58d603960a6567f81a36e8415905242685c0f06dae01061094f1ea546111daee0b3f023875938794c2eb66c48fb469c7dea5408944cecc05ae3a263d47d68de08ba614897a27857e300d6aaf85626f78c0a6c5e052b5d6a1a62726ee9cf3bb49bcf6111040bb59e890508b8dfc4c88773341cae6b8346c5271677b407abf8c951d685b302e911d66abe080a67ebf646f30cadacfdf88739ea80d5a98499d34c6b549c3330cde055e6f58ea6b45607fd3bcbcb5d284c3dbccbcd05db8567a0d0fe3b9c5e3d935d5dc5ed34c9f43d84e18bb88063f52905f6c1ca2a9612acbcc408a9046103c639c87bcee7b99306edc6a9bd7192e3f81b0dcc8d26cfa508fbc628fed41e946cd82447521156962c601618dc66dd4c8a37932c48594ae120e4b2f27044d1968c68985a5ce0a68aa57651e1de8d7b6be360945dca77d8417b515147d477a5858d9ea7ba0cf59c279d4b05f11675076ab1ce69d4011dd9742f4218e31e3eb9f7347035e6b1a3a5810a69957be7b490d2fe3c19640335be533972f75d9815f24257f1a186e3a80cb853a9be7db0b96fbf2b2c0e0d87d25354283703bba981cacdda404300fa464bebebe76f206b54b609e92ce3db0cf8d7df2a7e76749202edd010944cf95210905508e4ec10eac52ecb5086fe52f8171707048cf4a04f33c5f1254ece3dcfe99d64b119f334c9a344016819f4d3d8d356f853adcabcbb23b15dd0ed9a8aeea53b2c5d41790575866a9b8b12bd227c53110ca70b647bc5f4167652a24520438d884660637158fe5643ba4e9ca6523e5af14c6508cb4a0c6c6059f49ca42e129ec2319fc646b70cfcf25d3d942f8aedc81952eb4adbbab3d6a1b919d54d6d7e5cf70a644987f00626f2758c3cf9919f7756ff4e10255fe47015df97f72aa84856da0009135530a351725a5d70af0a08e3a2466446e7aaf65105c6c3fed846ddb8271bb7e40837dca766ee2a980b98f40a6f1903afba4c31851c51349adcb3c3e6484b3ffb66103ff0c35654113bfff51c5555ee8d8e7c3515b80f384a48e7b78acc65f59313aedd1f845f9389689526c1216f74fd14c87e5d4fd8a77ae8863e28068319ef96b868e139e54b2d0f8a4594dcd5f0803b90778fc2d1f2f88247a9f9ddc617da472aba24e98cf30dfd31b7960cf9b3d682323de6d5086616bf249f5f3443d434ce9fda37bf302a9988c009922efd4b87e54c5d50bfaf3d5ba9e5a3ee66885741e2407fd0c233ae11fbb4afb5c34d15707189e1ebf0f99925561d37643b9537e3f15ac4fe2e1d811545ed426a0419607ee2c361e52fd2d2944f3b3321a74eb4f70d44786363459fb75f5df15e440a671e16938e893e3cca7d012a64ab40944ac3eb8f96885ab43e9d977f1110de75d19961e390e3e132a495fed0ab142a0a94f85b219d9ef8118c9837f8db42ed888b92dce2eb9efc5952f514a64904a986ea74f082aaea7e92b79656fff0a0185ac31c9d4229b4d919216b859888b458e303baf8d8f3d0e7337cbb3f38a4d3c3beca23b2d0f8f9682de869c138b980ccfb3f3e811498cf7ec78c13b1d68232d54c978c1311869d9fc7effaf0ceb6ec33670f3635906c5d1aab182fd29f85f727d22a700cf9f192ea8a19d7f781bcaee0ac9df9593b6dab3476a9beb5f0f200ee66b7ab16c34a8f3c4211e10385bbb083686ad6a864b183cdb3923c69aca6f922f00d789bf5628c9e37824d689dca5a71e1dc9666b4efe606a6c67021177f3a615c5bff7b3bf267ccd6666f164a7ffc81a6133854df955679dc9dce696da916c953811ed695a6f0629ef2a2d3db4ba778945413a63e1013a50e97e2dcfca58ffabf0823239559bf5b4c01b73fc12f0703062039f872d9a25c6b225f4109f073d5a75b71f4654639bcfb04bb8e4f7a9b536973b2bdaa0af597d77251c601db1451b857828e7a7c7b58797d8a2a3643839a057c391ff216d31b5c63ea9078d3801e08e174c86c869721ac8daac9fd3e324dfa1869e2b1ca5babd75ee9d42f25b9711e81b058e4139ca398147fffab5e57c174ef25a33fb287aa36dd9cef10937c7e738eb512c46e356f023505b0b06597075f0b7b9af00cf2f97ed8a031579cccbc0ece5c8e196dcfb7064a6a2e6d3ab39ed3140a12b5ca224629870b80ab71d10d9862be6e2ee34a116c0e7dfbe908b4b844712ef2f28e0dd5263ff64c3f8bffd1a8667b61dc568e8a29d6e91e270b2638ea172e37ce005debbfbd3e2f521dda2224a55773068aa0e84c8209f698e8f8d9ce1ed9583cf6e4381294988d05dea1e0a11e103e46ba7f24a2384586e0471521581f6e11b45ed7bebef5b7700d995541c01dc0095edf351ea956356840d378aedf809e869dccf68f7af6eac12183256da1f336a1ae8275dcaaac8604e1bc4837f09da3bcdf7645ac2a9090cdbc5cda372ef0db19c5709860657af490f4e18d11158c5d72ca2e26c54ef17b9d5584eb08fd524d8d0329936946270b7d2728c4793205370e2a61ab71bd3d459ebe1f2da590f44b677c40eea7191350c54a6591a16101e1fe150868419d308737726a1611db270214c9ca2a383b14f8780c0a434b86d3289654dff0ce0dceed796e795619af1b737d9311833627e37cb0e1892c09a3b78fee9b316ccae34a1469bc73045a00c316ec7c6d69c5129aaa6bbf200b206b47858ecd496814bcff2bf0cba1c05a224c6112a7b26b4615b8b9b8e06eb3c6ae3a12a5826621c362e6959256cc35992e1e57a6fb15b028cffce722882b12c952536c1197e738372cfe6c008a51bb2aecaa80ab7c5ed820e27af85cf3f08d52662a0ec4260526db2f75e51878b718ba8a4c16222999f274b108b07bb66593755673ec6eb98fa97cadd0d35340a0eea576649ef00d45e9540bc8f6b362c20088f0673f4559e37ba5f16442940b26237917cfd0e2a55a249f1e2089e9fe559b229778f42473181f5cab49f32c47dbff72e41cb81df9a49e4567a2f01b02bee78daeb9c497ca2e6b0c58f5fc74c8138a8b7fad02e31429ff5040e3ea3d30dc4e1c3f3fc476473821cb71e068e5fbba1b90b8f4d42c2fd59f4e0e4d6412389d83f05aa5c33d6a144d35eafbd8f3d90bc431e307f8554937cc62dab4e361250c7b05c8491165af83e242080f947a038c5964514c666db700688d1880330d89946201edcc4fa27fcc7f96784a559d5788bc91592bf9e2f1a8a748f4bb179e5a2288607e08618216930a67830bfb3b3eb2b7f5c0e005a0d7e26735d38f83b5535ea766a84fd3b303dd3cc10f98943d9e9fe806f05ead442d1ac2fc3825c94eac8b61e55f4bfdf7cba202994aacd9595563cba5e2f6c2e88350dda591993a062f9f3c358e2e3cc0e4236053d58408cf943f26448efb031a8061acc0d5c6ed635a91c53441d46af383be47c960e2bfa9f74551379182c9a9c85f3de171607b90fbd719e16f0dbcde09e24d16ed0e6aee3070f42883fbb6cd33623d109d74ca7b6db19b3b6b6d1fd34e9ee4344c01f48fd484f832c932b28a3a7eb7770b6e0f287f18b2e4ef78352ae473812e9fdef612729c68114e7673a2f04e5dae11b4d421983fbc2e13bcca467283dc50ca480cb6ce51a61bbc39c89be9215841402671491fe1d3dc50454f0e5e3160d49c46e6b6b3122fe4f0631f67f7552d80e05f2fc285c8df66215a6f9604fd8b73e0015a29e9d0b3c57acd76640be17866526d25d7523f4afbd44c43c08e1d7a14f86087972963a8b0b67d04d49cf6d60989aca735f0a2680d32171e2cb8b13f2e36d99693b7c6fcb5b06c70719428433c3be3a8fb6761c2547373b0b6c4c0f5f2ac0becb628d80389816fe689b49204421d804d8e6c3e5ed1417cc5341bdb339859a71bb7bf8a6c8c27dd5561fa1a897983b095b21dfceabde3d40fa9d9489844d84a173d3a658eda8f7fd3bcee0efcb722235ca7f0b8d1f24e782ded04a2cab451088926af70e50ef6774c1075d6faed8413fa19b2936b852c493db734a0352cf74cadba43e7e59315b944bce9f563b8a972d68e71cc4045c570ba43d70f3f5297dffa27e1541a91277815dc7cbb07abe1b77e17293852a6fa38acddf752fd9de818077250c0d746c6c7da2ac9aef2d2fa254fe65953d13562706c06fa7fa99e03d79b9a7ed80a9d42cf6720a3723877a77ad556bd335663343d702f0ca1bb4b60ed13f48a8103f5be75827cddc2090db5cccc67d700d1d7beb8b2b6ba7abc038daa41d431e5731c3dc1de13a12de116afb12fee1125e3edaea400e7cc3ed06cef32b7871cf561bb4d493e07e21b16370a3a96df58557053b50fc2336c325441e31e6ee5bd8de70c4ceb992b7cbf138124de115795b59e514404be148ff12d916c4a9ef64b73dc41e478a1d3f7a4dc2f22effb2d9b7d265a33b86add6d4408610e4c6b002393a6984a2f33e51f4f57ab64844175c62963758f3a798d80da0b50900091dbe079cec2bec3c81b908acc3984758217e61c18892fdb81077eda7e9641060a9c90b49037f43e8c2f74e652db86e14c987be8b4085355f06c120d61dd6f57054b67679e596a5121a667e497edcca7bbb355480530aedd5bdedd2564f92a83f836a2fd155c02455a8ebb61ca5995202c1bb87fbc0194a6e6aa0b62ac346965d98566c60cd24877d118a12485ee0b5e3404d92918289823804a6807d0921ee6be012127a7beba78a7269069c9998e25384af5cf07ddd2482df934e72d4ab29587542e9f21cb5580df647db32272b47c84f24d2681f912f5d594033acc43d8f4e6fec5dc31160f3a813cf69be084186a2de2ae9aa1360f8b973d1b9205dbf3b32ac699023e3c528bc40c140cbe01de2289179746e21853ec62406d1e622d461d0f0c3a08dcdb91b25774b5499e9f124707d8d1f08fb34f5450d3539157d483b1c8ffaf37731e1c17daa6ac16c26eedb8ed1f4213bf758baeac9e0fe718ed8036156fcc20f6d7d22fca20c4f8af6c69ca63bb85bdec3f3af8e586a3cf61ab72bca2e2cb43b1df1f2cda0560be2ae61e9926fa31abb907369bf26f24e905c7d46ba3270b5e5174c098ab6d3317c39c77132dec8a607740b29fda9b1ad8e184a3bba5bb36b107ace15600b74a41c8eff6eaa3cca2b28730620e2f72184d307fffa357b0e3037679af3ade3d4b635ec379c2da1ff14ad27918e7a0debfb8eb444e74b9630d0f763b4f4ea154f9bdcce6bbb570f14ef0eaeb262fa228c2dac47c16f25bee8a220f2908969377f47a512964ebe17a0e5042ff17f4b519d047d8d363ccbf6bdd4f2145be2a1f30de2b311cce4e5890238d1bceef121d13839802f20af9b11294d6c3cea39a0ca2b97b2f4bd09594c7e9a5c133c8ca96c11ab784ec436da04f39b4e5847ece99decc111c2d4239effe83a31f243c9a0e83b33cf1717ad2154b6febcf95e044990034fdc4feb46483f0b4e61d44c0e939d7bd37472de0962e58b69d2a6c55019d16f6601df500049ba7c20fdbbab9a02b393e8c9a2204cfb5986ad54b57e4e991da9e9e46246b72ab0f466f5638fca6f88a106ffd9785603b5c3b39c81894d4fddb367cc32f904861ce241a4dfa24e8e627ef1088bd899ba2263b8989193a3c3728b34e02a2a1a27f426b9a7c4b42f9d4e585282146ea75452d598f5ae7c8318b234618230ebaa49098310bf2c4a38e0303719a7e29e411e679f6e14e924e3da5bf8fca3a91a2547681cea826eb1ac0f760e4b4067e9a508d8d462abd8c8f7189060aeb004fdf0370d9db2faa02ca4f51b2e762fbcdf1ff8e3316e21f97b67b05285886944f0863e735e1b7bdd283b0de3b098da0ee48531d0936b63001bcf109c4181606469997a235dfe54e925473a8e634d5267cc0c3818e2dfa378fba8e74e534b570a90ed3db2d14f30f659e633e79a51f709c1af3ee8cd7d72c329208533a31942376436c3feaa51898246bf9625e6841d57b46b0df8952ee94d5658c475e28170a52b9b24fb9adb65a93d90447ab4e1d028a94136c963191c0d2e224c92bdd342b39e5e6b73347e96f7442769cc1902e406ad66b6e9959d3db700c02287250b46693aabf974532b44f4ed8c5d0b53989784d4ad262b9fa54c4910527776704409ae733414359b0d61792245d8c4205a7aeb1e58beb81212badebc9ca69d6f909bd29baafdae814730b60318d060985f8cfa7988dc4fbaf75162fb1b72c177037d50ce925c44a236a7644d470c66e31c81ba09e9da2634f4b73ae55406860baffe264799d5de9369d946e445fd990eb104d6293117480cff451068967e0045f8ae4438b7279cbf65e033956b1c31159e343e2b1ec3955ea97ac295272cea0e509b77d5ab3b44d1e705a653e33fdea31d28b7cbea1b1dbf2e049f208933a6ad330a635a61c6fbbf16a8a6d22f11f8a04585038b0536df53fd20daf70ed4e8bff7a6f8716f89a90dcece662dc23540cd9214dfdb1d15147dbc18e1f3abcaf9b7e4ab958adc9992f5d364d02a4643f815ce6ae4e7bb5e85ac35655dd36f5129fd9de723daf64b317ba5b9b6f2e4293c6b90aaaba8ba85d830d920c14f94241d25311d4e0fd00066270542262c351a76b2786885bff55c0d547075790f8ef8b658e94f7711321258c95234f0ea9db490afd109baf7ea680aeb2381251ff6c01d04ca5e628908264763c187b360e53afdd40f48be957bebd2c2a2a7d872abc2d2081e3ed9bc43aa9cefe69efd93d889fd94c1309a4ed804c0e1028923c209b4fcb3371cbecf1d4641309c7bbfe0f0ec628756b4caae98d28c543d64359b0ebe71ba42753b9f0a3e266e3e55fac9cecc4a2a3189bf1989f105169700d512c63fe7cb4611940c52fb590aa3a15313d5c0dcd736068ede40e8d7c9b0c3ceb70273a4e9b56d56ac1a3e1e308f7e129e3348b290afaf3186ac6e622475736fa197669e726fa159279c9d886201dd02045122116ae3a477b10446b0db5bee6d9f1d3553b0b071bf20c92f6568a1bee010fea20f399bb7b00c338542fc6786ab619cea26d96a6abd432293624dc71ca5b9fd54f309762e2044689332b74e4d77f20fbfc166f0d2814ecca37dc9cf7fadd0344e9ddd417fce9931f846db2c91d970677e3664d5ebf012760360f9d4d589aa56f9b601d4ce3587c29deb77f4fea2406090088f1dd146bc2b690b86541b4aa241d8584b33a3a36fd61bdc995353d1874c10e384892cf86a67a9a50a6487026e8e592027ff6ac5bc9213825098eb29efe78f819786e6d929a94d39c54065306b55f837d4a463f104e3792e310e8bdcc112fb489e9aa9737c7c61fcfe8d63eb5aa9c961c4cd66a86ad3f5cb8568cb430f5be85dd0a0fcdf12ebd4add6d0a8832abb8fcb98b1baf283a4d54d6e2f9c12d446f9d16ba213b4b372fe6a4989608762bb55412ec3230ac084dd6090acf2fca2b0752858ede1fa1508b3049cadf628b82459a768b49a444d2afbff23cf2bd5bdb2c17aa39c50698784204320a4cb44ed80116cd71ac93f3e9af6f938eb3baaf2e84ee367fc0b69fc207322a52a0f5e50865b9f9e3c6070d275ffd61654a3b9d530f63f2c519eb807da675e1e1525e51d60087ae5ad61da26bc7c5a0db3fb78272523a1caa1eaa89534bb1115e7981e367b7c4faf76fc97c61bfe662c21ac68dab0ff9d40771d38e63199ca275205d929e112a27c03b23ce6c08dde992c2590eea44488d9195298ba58f19c3be4046c68fc33fab92cedf3bba052a28d7f87e27f165d7b48bce35e026fb9e6fe75d2428b0091dccb3c17106060b4d20acafd743de18773df6e5ffad92ecd22062029fe6c30e2d34ac710d4e7edcfa7ebdbfb039db70506ef71fe01e937fcada41f6854dda2ee2c67969194b3ea8b7138f46be1be9bc048f3fc62524941a13c5831f8cd8e5187b8af9f64d5649969eee885210e4d342a272966c971556f7b884e82c8443b0dd7bdf958279a36d45f80f579d0f89d0f21a700ba7123a50d178b0276dcccc1777c76af6111f0c5dbc28c43ec226878f41662eace71265d05e44c9eb401dcb1724be91c6cdba3d92a5cac1d11fa4d044b8bff3369c36649408b3e1f24736d786755e5d0be1083bd3caefd86b53bc21ef00af71b30516d481026d64a7cbf925371cdeeb9dd4e4a264d60cd15e7688966c513fabfbb9634f9755697c8fa2098d88d18b922ee250b95f163fd6903a781961c8a66ba4f7721db5dfb8cb618549e728dc2fdce6e0f4a479b52d4d7883fb3f49d44dedfe398ce17e8508f95cf91157cc053065531115b386ba1d615739ebd39b98918d9d9652353db06dffd9b689a8cb00c567713bfd76adae9ce9bc37fbf51fa1121bdd19ec3ef5b9f05712120c3d6413fa2bd5f0b2fd41fd55959251f338cc129a3f48f3ba30ffac9b68e125a9933d1249b6d266ef2152222b65dea66fee4df0566eef9859f25339754810c2a4bc3c0c67158d7488d1c7385ce18ea158861b08952d1358346591a0c906fbe1556e232de55f01e8214bea066e133fa7ffdd123562475b07599f6033b9cdfcd00e2fe8798b7385c384193e6ae2e288bf4dc602667e9b2e36a815ac5ce30d334b2c780ad284d320fc99137d4990e2fa05959440e278dc7ba50c6a612dcff07156904f733056453f80d9dbe4fea96345afba1d96a180b556d5527b7adc0efd1a35d36753b4e956f2d38a0f5afa1c5cb7e61f58074ba03df64c378f2a1dd6377817be437f8c84908eeddb19a94488f9110d6e96f1e96d64192651533d7140e94d3d12cb2aa822b7a0db17251a02e7fbd0782354d36c5ca8d2b984a2f44e5f8b2639de52caecc0d2af2f900fda2a1ef79cc1db15d095e5e13b1c5a8496ef77c5c05b9134b44fbcfc9bfdd4c9c60d9673300c1ad3d6fef8178afd12474b17c87ef4e502ecbcb414876317d247fabfc124fda03058e8a346e73988b23055fd8027c3805c7df8b3b78f0c940393e48cdb82575c992fa5828dbb9f58424b47b9d0f06eaccd470e0713573031afa0e7824c673c2ebdf52ffdd7165081562d24971d46f487a4df3d95e48e3966f8172cf89a4d7b70c10435f208a30ef9832d689645b4bb84d4a9cdc78df380f47070075120535e7d055997241c6d614180f720a60d1fb6477881c3fcd140ecc03e4008a52fccb67e85ec192fa97064d344cfc2640673b0bd76b6167629e8874b1374ceef799465c8e47decfb02a2c2d0b713865ef5e19920615477e69afe1ee293fde56d2ef1857acb64069b083ebf01ac2dcd589a668e34c4cad5260cc42ed9f4403ae24c81b065df16b388bd1dc53af50cd8a454a222beb67c20d1a74baa834b7bb62b4b06382eb512191192d83f2aa70502de2f968f1188be82662872e93245c08548e496eae95797b0af24618c8fbeea50e44bda0534af3ec8a30152a5fd9a8e9a9c9c3b5e9af8fd77ccfbec16c500056094a3568e170af8f808e7013964f737f6967713242bfe2dd7331d237f2f38bab303e71831c77dd05f9a5be817d677160dc5ea920139d0aba1e283b2db50605ecd82cfe451a605b59faf36360e1bd3d85f25d18bee9f6d4d836a5f5bc36b9cb45f84858bae207377c1a1542f25b5e94114fb179635ef2d2b9f5a6f05b00e3f3c306ae84c7a871e1e7aa49462af46fa38b58845d8c765628513f1b5f91d5a0d759784595408c35b8670e904675c42f735df300b6b2a3257d5d66355c935d8417ae7931654665191d55d03e8bfea3f2d62022616bfde9867470d0b584969d98085172f77ee0ab2e3fafacd7fcbfccc1dcea3bcfa41d7be6807457ad24fd29867e0c1ded23ab99261fd74f401efa533f51105c885a2e59e5812588b92464ae561d41592ce22698e78f1b9fcbb22a7c3a6b12f215de816e895fc95ded08be95faf43f748b77bc67bbc87647dcdf72b87e4d16acdf8f3a020fee0d35ff9249df60074c78071db3723b7143cfd4eb73c94539bdfa880211561722aad4561da9d0c16c8af4991b1d4770325706785d9eb7915db5d6eb85e7f314ba2c49e58bd05cb887c35f5feb71945c5be620b579506bed4f7fc86a4eaea6e36f79cbb9644ac561fcb99c8e250f9b72700aea6b5a8e07bdb5ab24520653ad7d91f84a2d9dfca3c8873608e7a977b06713ee00b9243d2b65702c31440b350eb0409b4b8389fca1418a79362e7565171da95574064927228b7124d3738b9f9233090cef3b8dbbd8db39daf136ec66ab967d981c316bafa4f8f83c3c1e589290715a3ed4376df7f54bc2f5b4eb57c64e909efda9c5dd0f2e3e988aff99d4de3a2515f14d7e193983171244098e39306066cababc297c18b4fc35698bb9a25ffd2516c5e3ad7335d695f558d2fec5436886ed56ace6e2a8f0b46320e808e51b1b06dd86041b48da19068ddb2aec77017f4096f48bc6f7c149692e1a1ac855a47d7aa3dd6f5e635388edb1a978d4efa0c90639271d705abee210d7de88d937f698f5da6cc9fa0e9a6c1902be849a1d1d2738215dab07ad9fa2bf057ffdb11d9297a6536e4c840640356fc252f58aea5d5f2e8b3eb35c4f10f5542e8440d56aeb5086b2dfa4b7bd221a8f7992d40a2116e5f35bda4e1ba26f61e2fd33a024da198aa7609682659f268ef61fcdf05a59cba8138ac25d0abdeb26f49d265ff24eacd237f0eac3a549cbd727a2bdf56eade3587895292c60462534ac3d141bc76a4715e88102cd98551203602d3f3838b788fd3b88c9a1a5830da56813f21fd160b1c15a143354d125b1e928648586d6ac3499b57b76e396a12e10b3bbf875b225ade837b00d878ed35ec3fde7ca8b0d3d1626376fd21ff0b1ac54f5640d37aef3b97a6033827115aba86163097697525cb55d5a0cd370791312fd8cbc49ddbb16b3c0512cc070eaf2fe743cd394e0ad43e2d79e0aaf4607b76cd8724b3dcf8cf194f4d7b1f61a10df199278d9c439cb2faf6ad6a259f4ce8098a19ce907dad8383272b612e9c3510a600c4f6ec82b8bc00cfb7d2e30d38c9e220fea9d513c515b9d6f47a338dd0437d4640dc614ede438627fdad7954b688eba13d7dedf8e1f113a5ba783e8112d85fd5bea693d780ef5ff3d9c0df6295f222774d01b50c37bea0cae779f0f86e2e3f0a1fe7ce542bf2a29358f8247bee53d158007536c5c8f707e11d8e0a94e844b4f2f7ba8a8cef9944aec86c6017e7cc2456bc58bbc35a9d945e2477823eade5d2ed860f78fedc007d0246aa861e269584dbf20bc624ac06b95653d8c492ee796cbe523fca05de6c1d4a752e3576431f241a8597b397a3805c01e705f88ca28a3afee308b9b782d9e5dc603d23fc584ad8b0036bba870ce3413cb7532e6a53fd94e545e4ea23bb1ddbc9988fd1f9444795e5538287ae76a1706f89132d455aa14d2d192ef059286acaf0650c056e429e09cee47a2c33eef339e17bf95b27e1e564168c6dde3f0e863ec8e9ff9a958af3099ae5d7b6bf91b0c2cf7b8c27abd3ff3167ecf3012edef3c099b48a6a29e40459ef90cdc01e458372730ff8d2dd4bbe54d98a09376da176dfe9aaa20e2624a6813562bc8ad2fe58960f20b510aac0a52735545d51d5888b9ab565fb4ae96f579b4b7981bd4463e99b8697f265b925f0959c992494dd86e8bf5bcf0cb9bbcd8130d519f1305a4e1c94d47b5f6ac4c82f02d71eb606b15aa4389abef97f68f5c199d1d84f71483a6ec5cb8b7a7c8ea1b85b7ac7ca6c71ae3286565da94adf8d07b6c6cd89698fe93bbccb5607e83bdf6999e11a206b4b3e6374a5c3770189d37a4a4d32d83c148959bbf216cb6458ca9670cb31df4a57bd690a36a08961aff133f19d0a2b2c923b31a5a6eaacdfd8d2e53f2b057ce6bd0e18df089891440afc06f161c83144370ee790b0840a9db1863e9042e0984ed1b3e8953b9f606b15cc280681789d4b9418dffdc935397e150fed7e7bf9ab3c4065adace203ec8cd3f402292243c9895ffb99fd6735b71ffa6e225c1bca5ebd135e5bdc8bc66faa5c0281d18fb3de9ab9aed8b1dc0e170e160068f6bec080085544f7e9bb2d02aca934e64e2004562220186a9e55f063e659999d5fd8693a6cffc3771c025d81da70699b2848a04c1f1a9f192b459408fff1b188f6fd3deee7769ef1f3ba30d2db1db4db36bd7ca3ed06b6c67c7fd7d4df5b7f8d22e373f182ec9bae897ba5b093f54e9214952cbcdde333a3aa52e653bc793acb953513cfb7b43d01292373ce59a34ffef8edcaf04627e2ec1c3f461bcb07b9ebb81ad4335e2c935cc67db84986fde34d5549667f577cc12930e5457bf6f1a4f75e212b6142ccdbc78feffa2a06411d090a80529b3aa7a903b5863b7be3c00407d1dc102dcf60037246cb653b907f5fc4493190514653c4dadc6bd303d70eef4822df42e0782926dfdf5f98409e3e53b56d1cddc5271d35502e13c2642268768c5734d090a7d35889eee1eed565201b77b679a59bb36a7b5df463a5b2de860fdff341b6c1473444d1b31dfc9aa086005aa776d62507eaedc1b6761d80b2ad23272cf78cf5a82b007e57a6656ac2e449651276857317ec5cd8e28aac98128f98843f52abda52089f5d67c86b748d2950dd347604d438b2d80ac4dca4724ed9bb76eb7e838f78ab52ed9d3ef1394c428c7d58abeee8332ca1dec87a06b5354553b428f75c740c07e5702d2dbf15dec22e3e3fa79836593b25b29695e14652dbccab93cdff130f65d0cdf001732639bf12fb84c5a9c005d52f8f9ec3f08e4f4b8247a79723cf88ce39a96838f5b69db1e1cf7a4705377859b6c43ddaa1fab3c87697b34c845d1c0c1fb23ca51c02316cda615ff669af5a79aadd47f1654db97a81ec7e36597fa2f2180e1ff5f28f20ceefd327697d5b7bb45974d439a109218c9ff41a4efd21af8ceae13d8631949893d760f67a0dc54012b0abd43d88979b14ccbab8016ee6a61bdea9bce72f0a134c663b383c5f67766785d9f2e070ae142722d8e146895e453db9373f66b177635884d970d4746f9d6c2e80b6430a73afbf2440a58a84b1286aaad76bda09f03353246f407099bf213c91fe1428afd911582495206269c2216c5e743ce8b980413e367feb01ed30f366a21f244723312aa60a7c58957e191301989fa2e1c357d95a0451d6b53004f15f7467b73eb7fd6e33e6f46f3b5465354eabfde8a26d237249e51901125288ff84d57db8350475931d6ea4b331a3c6edc9afc5c28c1094a9858f90796d463c59af0bf885c8f4ce991dfba33d3315dbec26df6cc1172a9bfe55119a8d41a1adf80826d69c90d2026abdf02b61a891ec75c7d9621baf3d98366ba81f5968cc0388c2174a569c176db57dde8e665d92dd4d486a286bb7337d7e618a3b41b4682fdfece956adf333a136971e0b10d9aef7ef469ac7d1431213338f9f6446a376156957ddf31345cf215fb0e00eef685215dc30f5cf7c957d7d708397faef12f03e7a996c73b54483d46f3f5192bef9477dfa0245114dab1d02614998fb733847abc74b59c1417401c61efaa802772904676d070819b32b4596a1c35ca6910635bc09c302570df09761a633136a3902259e53c4c44f3d2eefdcb7eafa81acf907b9d160463962cf9dfca8c6f95cb666a31d34fbb523388d15892d64eb81c8dd4e61fb48c26fe8c65d50f0a57070126256cbaa3351dd5345f75b3dfae62b59da6c6a5601be3e08690cfa96c07691e2cc7c29037cd9dbb7f2f0b45a67f765332c3eb982086a31f0e3a43f0eaa54f7cba9f76e9429971f3eb4b0128e349101ba66c8af8522bbca17dc2d6011dabe78bfc23fba26b9bb48bd3a72d57ac4ad2b4925fab9cec34a8b668f268095fbe61fe2be5cd0067ff055b38244078b6657c2fd3fea68ed3fa00151bc1b1808722d1b045620e83503fb610ae35516d893e53edbcc4530f8c8f349a7e5f57916175a3a613a698dae2d95a1221b73fb4f012e762d4bfd36e2da96ae52bf4d109c8bfe495e70f254507911008ac07a1dcbb68665a7c7d32aa6cb1c590dbfe426d9e0c7b5d5d639b4d22acf5951498510a21c8f6e99a6e42ddc288a209560b30471e15109805cfa144e9f2a5242c93e32fce29ceb31cf255c722357d46ba9c14ca07e2435c92934ac29298cc7a0c80cf87b2df7036cbf754587d3d87bdc70543d2dbfade4c56c513e26dc3de4db8a6cb5daa0f5c9fbf8c8156ddccf5ea9a11a3030483e2693faac9ab05be5b27003b8f68b69ae0bb4e8f0adaa4bb69d024c03aa9e75f8e5928afe53445771432c3a875d855887f1d31501d496016f2ebf778d2d3f0815975eb577014c98c08cc7c56e88078848510bfa674e28e181e2bda582c56c3b302851d142863aca955ff00396c7404c25fecba7491f280de3f5866869850955bc73d87a6d376d21180ee0fb710fa4ee4cc6f45ea24eb39e79d89af2b2087ee67ebd41e7a9e2245c9f2d744447190751ac691abd0988676104e6beb99cff273adecc67f8832f584510998b92a58f82f8038b8a98a18ffd8c49f2e8d87659a343eb249a6f7ca1e38349fba63280f237aa82d22129313ce680fb4f7d2681d5a725395a80f1dc402a9fa6865ec1f90a46b9fa8c813fb10cfe435ec5cbf3e56b826f46f8b0f774f9a505af51eb795f22239ae538d28f8899bc7ca1fe19923c09017ff904af35542bf9ab18aeab05976a59d89f80e0cac97527228ef28ff1557abf60f9ca9c6ed55c6a1819c71187ffdec51e74b9828ae26291598ecb740a9d06244da0b30d0eb22f2d3bcfe686ffe3f57b57721ac343feef4e4eada8d4b130602024bd75b1e9817699aa3582c2c940f1d79772846f2a680174a06b781dd9cdd1ba8c61626a521a71db5a22e876fb27564660f72e8a732371ecc0e3a358655a982b0b17bb4a41fdcd06d8d633b324996af1407ad0588b034c73f833f2ac48a76f67f2374dd153527640c35919b36c524723ea2c068f9ed2df65b3572e6985eddd901cdc80055f50618940d16f5ac0d9de0e88b2d3e678baed621adaade949e7b7ec4c491c8f939d588b2152275f712f2fe5557f7e14a43cbb0d8046a68bf2c4b567407d06ebdb213c859c796ac70518948238128a5c686a1a5e565b82632b6782d1e58802efa5d65618a3e77a6d28c1643a3e18d2e29312a532b3bcc626cb1084acb5b027b9fa6b2680c00061b93c971d49d9a26c9ca97fb337b34de0d9cc884c2d3f72833da6d8bdf9d87d45f9e7f0e758f3307b6c51906dd9da40b44545afbdfb0a7d67251d685f8a843f9a99e3ad3ba07c33a915e31a0e23c2b62e6b996b9c994e7af0443ff7d8635ca0d25f97a64983c382a85730cc1c6f166507edc25b405acc36c8b217ec046c29693b729967a03392b13b934f719bd9fbc3d1e58a8cc58a576392845b49aaa5d506ebf293fcf8cd72c9f539782c3c52d8455bc856480ca7711be0900669cbeb22d49cae32bbabe277b6180daf1d89d6b7cb349bf4b1c5b6147bff35dd590e982a7ca216f675d7c1b23af9ba9846ee8bd10a5ea7c8b154aea41b9234b7c48ae60facb5067ad99454ce2112d6d927c288465eb04e18faec47ae6a98a4340c2f55810f6a7534450631d383c7c4f9aa701cacd5cc4e9e228d842b8a04f21e4dd1f9e8f9bfd24913f89e3f5c4b936ed507a365b87725580dbd3cb47298185bab6ba21bda77671c1e096aba26d2529144e55602acd8e4cba838f12b81614d4aa88fa005268ab3defdceb023683cc058e63310b7b0a3c3c07af1f7e03b6999dd9a275052371e2fd0120e8a11d3d4fb37b9237d78195d23cbb3700a496edabc474db54073a7da410cca01488537dc70a4b4b58143091be53807718179c8627a8c386e08b73e0f3b0dbc1db582922064f60d3f10d013aa4b00b8b63529c6e9a40b9e7daee3a0e4e8b37a50b47287c79d6df8576ec8fde3cd28087ac546d902af89e98c83a5583b93272d4fa4b54022931ce0f612b0908cea36af8a284a86d4d481c2d3cefb93b1aa27d2f5bd13bddde5912e7e7a58380a3afde42296693bb487b16eab856a6e62f452e50be151f51409d3ae6d42f1f6de6c4de7dc43c0b46ca37cfef48b4987ab2702d83525659f811cd2ad2434450a6a2c251147b4bbbd5f4bfeaf09b3016ece9fe82619a83f40436a69c9bb7ff91d0116ac199a344b06cccc4ae99bd8f2e8543a1b0e0bf3d5cc461e76ed6ffcfeb1b8ff79284299f095d87cbbb6c8f5291fc66eca3e6643a29303913dd049c817f62e7ba700ca6781b9ad6dff260b386081d1aedd7ab8f8f7290aeceee9e14847d0bc18dccbdf5f2f6ada676b9c73cee3124d7a812c34edd44a6cecf9ffac98a485835dba83782b4461eac236fc67214e49abd49fed2f335f11eefdfe8cacdb1159217d147ec4d8c4cd887d0ccd1f1dbbec018a8ae8c29e667b6aa2b71862c7441bca6cfdb75d5ed3899593bc7fde11579a4793aa99d40fdc96bee998c317daf787c41918d312666486cc4931dbda423bab386b6e587deed7573cd491820579c46364fbd64794f45b02efcff9b739d57eed76a98a0f5de835357ee0988ff52b362667dd567595ef3fd5e12594d2b832c07c2f9f673dbc953386eb81ce40b040933148c8993d039512be67f68ea952effde1e6027e7a49c7e86c4338a81d1e0d1e7a90d7035264e9d3c8fe93e8df754c25fd47aeea09462ce29690a7aca3469affc0d587d2ad0a776b09eb50544e68b6cbc1142a597f0012223af91be0557eb8826540d14fc7df206a42227ed818e1acbd48a82b092aadac863fbaee018aaac7654e9deaac35076a2c7310f56086f319cd89d16a0eb43e2f482bbca5e1a28d186e2e2e069e346c7b0c4fd004769e423551be673cce5247e93a8f00e20c4706c7233f54267882a83d16183823e5223b650a8e4e4423c64a011ffcc5df4cea6eeda8f19d83d00b208b88176cd0aaf6832fb72d973aea9d2937f84a56788719180d2c29265e27898c95a4851a72e2bf7df7495b89a22dd6870ec3cf15368ec566693aeb56469b36466db9bb2ba779129e12881fb03efe56a2c739b785bfa7dfd97f9fca0384bce9f0c1c832a59274a718fecf8b2bdbc3938d71b21f5e45c2ed570200f38fe6bde14c3f1005c5ac838e137d5c4693cbf0abf7579a6b6ef727e417ca073f5ad5c0b2194d9f049e4bc3216491029a62c073c8b0988e670ba29db3d92be239eb4e37c69469f5761b2818790e755e8837f3ed77e32e6c3527b4de58eb006ccc734b7102ca45c348e128bc1cc04ec09e3aeb7c8ffe6fa27f3d367b07e680566ba0975bfcd9dee2812ce01dc4a6eccb5f796e7a01a54f7c34abb4b35838ad4b0714259585caa9f2e5ce969272558590b32e63bc971af862d9309bbcbffbdf827d87e7e5064f4a8d02bd97c2443c5ceeaec297ceb66c561375d8fcaab9dd1c0587653ce8772711f8cd1f3f91022e854db2c9b2eaccdcef1c961ffbc68d08d67a5243abf4a1b429324a3ab183bad68084f53800cf338e1aeed6a666766b90139233720c4017b200e4b636ab1a8ae43528833c24e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
